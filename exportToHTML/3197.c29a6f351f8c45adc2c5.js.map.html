<html>
<head>
<title>3197.c29a6f351f8c45adc2c5.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3197.c29a6f351f8c45adc2c5.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3197.c29a6f351f8c45adc2c5.js?v=c29a6f351f8c45adc2c5&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;AAAO;AACP;AACA;AACO;AACP;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;AClCgC;AACzB;AACP,aAAa,EAAE,OAAO,KAAK,EAAE,OAAO;AACpC;AACA;AACO,uBAAuB,EAAE;AAChC,aAAa,EAAE,OAAO,KAAK,EAAE,OAAO;AACpC;AACA;AACA,aAAa,EAAE,OAAO,KAAK,EAAE,OAAO;AACpC;AACA;AACA;AACO;AACP,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN,IAAI,EAAE;AACN;AACA;;ACzC4G;AAClB;AAC1F;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oCAAoC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,EAAE,QAAQ,EAAE,QAAQ,EAAE,YAAY,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB,qBAAqB;AACrB;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA,6BAA6B,EAAE;AAC/B;AACA;AACA;AACA,YAAY,aAAa;AACzB,qBAAqB;AACrB;AACA;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B,6BAA6B,EAAE;AAC/B,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B,EAAE;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AC1tBO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrFkD;AACW;AAC7D;;;;;;;;;;;;;;;;ACI8B;;AAE9B;AAMiB;;AAEjB;AACA,yCAAyC,sFAA2B;AACpE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM,WAAW,+EAAoB;AACzE;AACA;AACA,0CAA0C,6DAAe;AACzD,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,mBAAmB,yDAAM;AACzB,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,kFAAuB;AAC3B;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;AC7C4B;;AAE9B;AAMiB;;AAEjB;AACA,sCAAsC,sFAA2B;AACjE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM,WAAW,+EAAoB;AACzE;AACA;AACA,uCAAuC,6DAAe;AACtD,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,gBAAgB,yDAAM;AACtB,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,+EAAoB;AACxB;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDF;AACA;AACA;AACA;AACA;AAC8F;AAC1C;AACC;AACkB;AAClC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,uCAA+B;AAC5D;AACA;AACA,mBAAmB,uCAAM,CAAC,uDAA6B,CAAC,2CAAe;AACvE,oBAAoB,uCAAM,CAAC,iDAAuB,GAAG,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wEAAwE,cAAG,mBAAmB,+DAA+D;AAC7J;AACA;AACA;;;;;;ACtCA;AACA,4DAA4D,2BAA2B;;AAEvF;AACgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,yCAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB,GAAG,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,iCAAiC;AAC/C,cAAc,kCAAkC;AAChD,cAAc,qCAAqC;AACnD,cAAc,oCAAoC;AAClD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,gBAAgB;AAC9B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc,iBAAiB;AAC/B,cAAc,gCAAgC;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,uCAAuC;AACrD,cAAc,eAAe;AAC7B,cAAc,sCAAsC;AACpD,cAAc,gBAAgB;AAC9B,cAAc,uCAAuC;AACrD,cAAc,eAAe;AAC7B,cAAc,sCAAsC;AACpD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,sCAAsC;AACpD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,cAAc,YAAY;AAC1B,cAAc,gCAAgC;AAC9C,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,kCAAkC;AAChD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,oCAAoC;AAClD,cAAc,uCAAuC;AACrD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,gCAAgC;AAC9C,cAAc,kCAAkC;AAChD,cAAc,mCAAmC;AACjD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,cAAc,kBAAkB;AAChC,cAAc,YAAY;AAC1B,cAAc,YAAY;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC,cAAc,kBAAkB;AAChC,cAAc,aAAa;AAC3B,cAAc,sCAAsC;AACpD,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAC8C;AAC9C;AACA,yFAAyF,mBAAmB,GAAG,yEAAyE,8DAA8D,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,iCAAiC,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,6BAA6B,qCAAqC,EAAE,2BAA2B,mBAAmB,kCAAkC,oBAAoB,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,iGAAiG,EAAE,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,mBAAmB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,+DAA+D,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,+BAA+B;AACnsH;AACA,+FAA+F,mBAAmB,GAAG,2EAA2E,gEAAgE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,wCAAwC,EAAE,oCAAoC,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,oEAAoE,2BAA2B,mBAAmB,gBAAgB,mBAAmB,EAAE,EAAE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,oEAAoE,2BAA2B,mBAAmB,gBAAgB,mBAAmB,EAAE,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,EAAE,iGAAiG,EAAE,wDAAwD,6BAA6B,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,gEAAgE,2BAA2B,mBAAmB,iBAAiB,oBAAoB,EAAE,8BAA8B,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,4CAA4C,qCAAqC,eAAe,+CAA+C,iCAAiC,EAAE,qDAAqD,uDAAuD,iCAAiC,EAAE,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,mBAAmB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,+DAA+D,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,+BAA+B;AAC7oK;AACA,sFAAsF,mBAAmB,GAAG,wEAAwE,6DAA6D,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,gCAAgC,EAAE,sEAAsE,qCAAqC,mBAAmB,EAAE,oCAAoC,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,sEAAsE,2BAA2B,mBAAmB,gBAAgB,mBAAmB,EAAE,EAAE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,sEAAsE,2BAA2B,mBAAmB,gBAAgB,mBAAmB,EAAE,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,EAAE,iGAAiG,EAAE,uDAAuD,6BAA6B,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,8BAA8B,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,gEAAgE,+CAA+C,iCAAiC,EAAE,0DAA0D,qCAAqC,eAAe,+DAA+D,iCAAiC,EAAE,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,mBAAmB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,+DAA+D,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,+BAA+B;AACxkK;AACA,iHAAiH,mBAAmB,GAAG,iFAAiF,sEAAsE,6BAA6B,2BAA2B,oBAAoB,kCAAkC,EAAE,8CAA8C,EAAE,oCAAoC,6BAA6B,2BAA2B,oBAAoB,kCAAkC,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,EAAE,6BAA6B,2BAA2B,oBAAoB,kCAAkC,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,EAAE,2BAA2B,oBAAoB,kCAAkC,EAAE,EAAE,iGAAiG,EAAE,sEAAsE,oCAAoC,oEAAoE,2BAA2B,mBAAmB,iBAAiB,EAAE,sEAAsE,2BAA2B,mBAAmB,iBAAiB,EAAE,uEAAuE,2BAA2B,mBAAmB,iBAAiB,EAAE,mEAAmE,2BAA2B,mBAAmB,iBAAiB,EAAE,8FAA8F,EAAE,qEAAqE,6BAA6B,8BAA8B,EAAE,mEAAmE,2BAA2B,mBAAmB,iBAAiB,EAAE,8FAA8F,EAAE,sEAAsE,6BAA6B,mEAAmE,2BAA2B,mBAAmB,iBAAiB,EAAE,8BAA8B,EAAE,8FAA8F,EAAE,kEAAkE,6BAA6B,2BAA2B,mBAAmB,gBAAgB,EAAE,qEAAqE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,oCAAoC,+BAA+B,EAAE,6BAA6B,8BAA8B,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,8BAA8B,EAAE,EAAE,EAAE,qEAAqE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,8FAA8F,EAAE,kDAAkD,6BAA6B,kCAAkC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,iEAAiE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,kEAAkE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,6BAA6B,+BAA+B,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,+GAA+G,EAAE,oDAAoD,6BAA6B,oCAAoC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,oCAAoC,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,iEAAiE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,kEAAkE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,6BAA6B,+BAA+B,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,+GAA+G,EAAE,qDAAqD,6BAA6B,qCAAqC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,+BAA+B,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,+GAA+G,EAAE,iDAAiD,6BAA6B,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,sEAAsE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,sEAAsE,2BAA2B,oBAAoB,gBAAgB,mBAAmB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,+GAA+G,EAAE,8DAA8D,4CAA4C,4CAA4C,4CAA4C,iCAAiC,+BAA+B,EAAE,iCAAiC,+BAA+B,EAAE,EAAE,iCAAiC,+BAA+B,EAAE,EAAE,iCAAiC,+BAA+B,EAAE,iCAAiC,EAAE,sDAAsD,0CAA0C,iCAAiC,EAAE,6DAA6D,yDAAyD,iCAAiC,EAAE,wDAAwD,sDAAsD,iCAAiC,EAAE,yDAAyD,qDAAqD,iCAAiC,EAAE,0DAA0D,oCAAoC,UAAU,GAAG,iCAAiC,EAAE,yDAAyD,qCAAqC,iCAAiC,EAAE,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,2BAA2B,oBAAoB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,oBAAoB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,+DAA+D,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,+BAA+B;AAC5hW;AACA,qGAAqG,mBAAmB,GAAG,qEAAqE,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,YAAY,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,mBAAmB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,EAAE,kEAAkE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,oCAAoC,qCAAqC,EAAE,6BAA6B,qCAAqC,EAAE,8BAA8B,EAAE,EAAE,sCAAsC,EAAE,6BAA6B,qCAAqC,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,8BAA8B,EAAE,EAAE,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,oCAAoC,2BAA2B,mBAAmB,gBAAgB,EAAE,wEAAwE,2BAA2B,oBAAoB,iBAAiB,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,EAAE,EAAE,iGAAiG,EAAE,sDAAsD,oCAAoC,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,+GAA+G,EAAE,sDAAsD,gEAAgE,oCAAoC,+BAA+B,EAAE,+BAA+B,EAAE,+BAA+B,GAAG,+GAA+G,EAAE,mDAAmD,6BAA6B,mCAAmC,EAAE,oCAAoC,6BAA6B,gCAAgC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,mDAAmD,EAAE,oEAAoE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,kCAAkC,EAAE,iEAAiE,oCAAoC,mCAAmC,EAAE,oCAAoC,EAAE,sCAAsC,GAAG,EAAE,oBAAoB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,mDAAmD,6BAA6B,mCAAmC,EAAE,iEAAiE,oCAAoC,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,GAAG,EAAE,6BAA6B,mCAAmC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,kDAAkD,6BAA6B,kCAAkC,EAAE,mEAAmE,oCAAoC,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,GAAG,EAAE,oCAAoC,6BAA6B,gCAAgC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,kCAAkC,EAAE,iEAAiE,oCAAoC,mCAAmC,EAAE,oCAAoC,EAAE,sCAAsC,GAAG,EAAE,oBAAoB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,qDAAqD,6BAA6B,oCAAoC,qCAAqC,EAAE,mCAAmC,EAAE,EAAE,mEAAmE,oCAAoC,2BAA2B,oBAAoB,gBAAgB,EAAE,2BAA2B,oBAAoB,gBAAgB,GAAG,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,0DAA0D,6BAA6B,wCAAwC,EAAE,oCAAoC,6BAA6B,gCAAgC,EAAE,+DAA+D,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,oCAAoC,EAAE,mEAAmE,2BAA2B,oBAAoB,iBAAiB,EAAE,oBAAoB,EAAE,2BAA2B,mBAAmB,gBAAgB,EAAE,+GAA+G,EAAE,4CAA4C,qCAAqC,eAAe,iDAAiD,iCAAiC,EAAE,2CAA2C,qCAAqC,eAAe,iEAAiE,iCAAiC,EAAE,qDAAqD,uDAAuD,iCAAiC,0FAA0F;AACr0U;AACA,4FAA4F,mBAAmB,GAAG,kEAAkE,mDAAmD,oEAAoE,+CAA+C,EAAE,oEAAoE,+CAA+C,EAAE,iEAAiE,+CAA+C,kBAAkB,EAAE,kDAAkD,gEAAgE,yCAAyC,gCAAgC,uBAAuB,EAAE,+CAA+C,8CAA8C,oBAAoB,kBAAkB,YAAY,oFAAoF,6BAA6B,oCAAoC,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,qEAAqE,2BAA2B,mBAAmB,iBAAiB,EAAE,kEAAkE,2BAA2B,mBAAmB,iBAAiB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,8FAA8F,EAAE,oFAAoF,oCAAoC,2BAA2B,mBAAmB,kCAAkC,EAAE,oBAAoB,EAAE,8FAA8F,EAAE,sDAAsD,6CAA6C,iCAAiC,EAAE,wDAAwD,2GAA2G,IAAI,IAAI,IAAI,iCAAiC,EAAE,wDAAwD,qGAAqG,iCAAiC,EAAE,oDAAoD,yGAAyG,iCAAiC,EAAE,uEAAuE,2CAA2C,kBAAkB,EAAE,iEAAiE,mHAAmH,kBAAkB,EAAE,sEAAsE,2CAA2C,eAAe,8BAA8B,kBAAkB,EAAE,gFAAgF,2DAA2D,kBAAkB,EAAE,+DAA+D,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,oCAAoC,uCAAuC,EAAE,wCAAwC,EAAE,6BAA6B,uCAAuC,EAAE,8BAA8B,EAAE,EAAE,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,oCAAoC,2BAA2B,mBAAmB,gBAAgB,EAAE,6BAA6B,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,EAAE,6BAA6B,kCAAkC,EAAE,oEAAoE,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,oEAAoE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,EAAE,6BAA6B,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,EAAE,2BAA2B,mBAAmB,gBAAgB,oBAAoB,EAAE,iGAAiG,EAAE,kEAAkE,6BAA6B,8BAA8B,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,8BAA8B,EAAE,8FAA8F,EAAE,iDAAiD,6BAA6B,iEAAiE,2BAA2B,oBAAoB,iBAAiB,EAAE,2BAA2B,oBAAoB,kCAAkC,EAAE,+GAA+G,EAAE,kDAAkD,6BAA6B,iEAAiE,2BAA2B,oBAAoB,iBAAiB,EAAE,2BAA2B,oBAAoB,kCAAkC,EAAE,4BAA4B,EAAE,EAAE,2BAA2B,oBAAoB,gBAAgB,EAAE,4BAA4B,EAAE,EAAE,+GAA+G,EAAE,oEAAoE,oCAAoC,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,EAAE,6BAA6B,2BAA2B,mBAAmB,kCAAkC,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,EAAE,6BAA6B,8BAA8B,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,qEAAqE,2BAA2B,oBAAoB,iBAAiB,oBAAoB,EAAE,2BAA2B,mBAAmB,kCAAkC,EAAE,EAAE,8FAA8F,EAAE,0DAA0D,wBAAwB,eAAe,6BAA6B,iEAAiE,iCAAiC,oBAAoB,aAAa,2BAA2B,oBAAoB,gBAAgB,2BAA2B,EAAE,gDAAgD,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,+GAA+G,EAAE,wDAAwD,wBAAwB,eAAe,kEAAkE,2BAA2B,oBAAoB,iBAAiB,+GAA+G,EAAE,mDAAmD,oCAAoC,6BAA6B,iEAAiE,wCAAwC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iEAAiE,mCAAmC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iEAAiE,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iEAAiE,iCAAiC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,6BAA6B,iEAAiE,uCAAuC,EAAE,kEAAkE,2BAA2B,oBAAoB,iBAAiB,EAAE,EAAE,+GAA+G,EAAE,+CAA+C,qCAAqC,eAAe,+DAA+D,iCAAiC,EAAE,gDAAgD,sCAAsC,eAAe,4CAA4C,iCAAiC,kCAAkC,EAAE,iCAAiC,mCAAmC,EAAE,iCAAiC,EAAE,kDAAkD,qCAAqC,eAAe,4CAA4C,iCAAiC,oCAAoC,EAAE,iCAAiC,qCAAqC,EAAE,iCAAiC,EAAE,2CAA2C,qCAAqC,eAAe,6DAA6D,iCAAiC,EAAE,qDAAqD,uDAAuD,iCAAiC,0FAA0F;;AAEzpX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACgD;;AAEhD;AACA,gEAAgE,IAAI,IAAI;AACxE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,4CAAqB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,GAAG;AAC/C;AACA;AACA,iFAAiF,GAAG,0BAA0B,GAAG;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAC8C;AAC9C,gDAAgD,wCAAmB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAsCE;;;;;;;;;;;;;;;;;ACpjB4B;;AAE9B;AAMiB;;AAEjB;AACA,6CAA6C,sFAA2B;AACxE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,+CAA+C,wFAA6B;AAC5E;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM;AAC1C;AACA;AACA,8CAA8C,6DAAe;AAC7D,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,uBAAuB,yDAAM;AAC7B,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,sFAA2B;AAC/B;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;AC9D4B;;AAE9B;AAMiB;;AAEjB;AACA,qCAAqC,sFAA2B;AAChE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM,WAAW,+EAAoB;AACzE;AACA;AACA,sCAAsC,6DAAe;AACrD,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,eAAe,yDAAM;AACrB,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,8EAAmB;AACvB;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;AC7C4B;;AAE9B;AAMiB;;AAEjB;AACA,oCAAoC,sFAA2B;AAC/D;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,wFAA6B;AACnE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM;AAC1C;AACA;AACA,qCAAqC,6DAAe;AACpD,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,cAAc,yDAAM;AACpB,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,6EAAkB;AACtB;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;AC1D4B;;AAE9B;AAMiB;;AAEjB;AACA,uCAAuC,sFAA2B;AAClE;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC,oCAAoC,qEAAM,WAAW,+EAAoB;AACzE;AACA;AACA,wCAAwC,6DAAe;AACvD,iBAAiB,yDAAM;AACvB,IAAI,+EAA6B;AACjC,IAAI,uFAA4B;AAChC;AACA,iBAAiB,yDAAM;AACvB,IAAI,yEAAuB,GAAG,QAAQ;AACtC,IAAI,gFAAqB;AACzB;AACA;AACA;AACA,WAAW;AACX;AACA,qEAAM;;AAKJ;;;;;;;;;;;;;;;;;;;;AChDuD;AAIA;AAIA;AAIA;AAIA;AAIA;AAqCA;;AAEzD;AACA;AACA;AACA,wBAAwB,gGAAM;AAC9B,YAAY,0CAA0C,QAAQ,qGAAwD;AACtH;AACA;AACA,GAAG;AACH,0BAA0B,gGAAM;AAChC,YAAY,8CAA8C,QAAQ,oGAA0D;AAC5H;AACA;AACA,GAAG;AACH,uBAAuB,gGAAM;AAC7B,YAAY,wCAAwC,QAAQ,qGAAuD;AACnH;AACA;AACA,GAAG;AACH,gCAAgC,gGAAM;AACtC,YAAY,0DAA0D,QAAQ,qGAAgE;AAC9I;AACA;AACA,GAAG;AACH,4BAA4B,gGAAM;AAClC,YAAY,kDAAkD,QAAQ,qGAA4D;AAClI;AACA;AACA,GAAG;AACH,yBAAyB,gGAAM;AAC/B,YAAY,4CAA4C,QAAQ,qGAAyD;AACzH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gGAAM;AACN;AACA;AACA;AACA;AACA,6BAA6B,aAAa,EAAE,aAAa;AACzD;AACA;AACA;AACA,IAAI,gGAAM;AACV;AACA;AAkDE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5KF;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,IAAC;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iDAAe,SAAS,EAAC;;;;;AC9Be;AACD;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAAS;AAChD,SAAS,UAAS;AAClB;;AAEA,qDAAe,IAAI,EAAC;;;;;;;;;;;;;;;;;ACrCwB;AACF;AACQ;AACP;AACC;AACf;;AAE7B;AACA;;AAEA;AACA,IAAI,qBAAc;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA,IAAI,aAAM,GAAG,kCAAc;AAC3B,MAAM,+BAAW,YAAY,8BAAW;AACxC,IAAI,8BAAU,SAAS,uBAAI;AAC3B;AACA;AACA;AACA,QAAQ,qBAAc;AACtB,MAAM,+BAAW;AACjB;AACA;AACA,CAAC;;AAED,uDAAe,aAAM,EAAC;;;;;;;;;;;ACzDgB;AACQ;AACJ;AACI;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,kBAAkB;AAClB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,cAAc,4BAAQ,CAAC,gCAAY;AACnC;AACA,GAAG;AACH,cAAc,gCAAY;AAC1B,SAAS,8BAAU;AACnB;AACA,GAAG;AACH;;AAEA,uDAAe,MAAM,EAAC;;;;;;;ACpCoB;AACG;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,SAAS,+BAAY,WAAW,8BAAU;AAC1C;;AAEA,oDAAe,YAAY,EAAC;;;;;;;ACjBkB;AACN;AACF;;AAEtC;AACA,mBAAmB,wBAAQ,IAAI,wBAAQ;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAAS,iBAAiB,aAAY;;AAEpE,yDAAe,QAAQ,EAAC;;;AC1BqD;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2BAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAO;AACf;AACA,SAAS;AACT;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACO;AACP;AACA;AACA,QAAQ,gBAAM,OAAO,gBAAM;AAC3B;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sBAAG;AACd;AACO;AACP;AACA,eAAe,sBAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8BAA8B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAAQ;AACpB;AACA;AACA;AACA;AACA,yCAAyC,kBAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChO0C;AAC8I;AACxL;AACA;AACA;AACO;AACP;AACA,QAAQ,0BAAO;AACf,6BAA6B,cAAI;AACjC;AACA,mCAAmC,WAAW;AAC9C;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA,wCAAwC,MAAM;AAC9C;AACA;AACA,wCAAwC,mBAAmB;AAC3D;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM,GAAG,uCAAuC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM,GAAG,iCAAiC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAO;AACf;AACA;AACA;AACA,oCAAoC,WAAW,GAAG,mBAAmB;AACrE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,oBAAoB,QAAQ,GAAG,oCAAoC;AACnE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;ACtGsC;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,4BAAQ;AAC3C;;AAEA,qDAAe,IAAI,EAAC;;;;;;;;;ACxBkB;;AAEtC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA,EAAE,4BAAQ;AACV;AACA;AACA,GAAG;AACH;AACA;;AAEA,gDAAe,QAAQ,EAAC;;;;;;;ACrBgB;AACM;AACR;AACH;AACe;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,kCAAkC;AACzC,OAAO;AACP;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAO,eAAe,yBAAS,GAAG,SAAQ;AACvD,eAAe,kCAAc;AAC7B;AACA;AACA,0BAA0B,gCAAY;AACtC;;AAEA,qDAAe,IAAI,EAAC;;;;;AClDwB;AACD;AACN;AACE;AACN;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAAW,4BAA4B,yBAAM;AAC5D,sCAAsC,4BAAS;;AAE/C;AACA;AACA;AACA;AACA,SAAS,2BAAQ;AACjB;AACA,mBAAmB,+BAAW;AAC9B;;AAEA,yDAAe,QAAQ,EAAC;;;ACpDxB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;ACtBY;;AAEtC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,EAAE,4BAAQ;AACV;AACA;AACA,GAAG;AACH;AACA;;AAEA,iDAAe,SAAS,EAAC;;;ACpBiB;AACF;AACM;AACX;AACe;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,YAAY,QAAQ;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,8CAA8C;AACrD,OAAO;AACP;AACA;AACA;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAO,eAAe,WAAU,GAAG,UAAS;AACzD,eAAe,kCAAc;AAC7B;AACA;AACA,0BAA0B,gCAAY;AACtC;;AAEA,sDAAe,KAAK,EAAC;;;ACvD6B;AAC0J;AACrM;AACP,4BAA4B,WAAW;AACvC,wBAAwB,MAAM;AAC9B,wBAAwB,UAAU;AAClC,wBAAwB,mBAAmB;AAC3C,wBAAwB,gCAAgC;AACxD,wBAAwB,uBAAuB;AAC/C,wBAAwB,QAAQ;AAChC,wBAAwB,IAAI;AAC5B;AACO;AACP,+CAA+C,MAAM;AACrD,wBAAwB,UAAU;AAClC,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA,eAAe,cAAI;AACnB;AACA,SAAS;AACT;AACA,6BAA6B,WAAW,IAAI,kBAAQ;AACpD;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C,4BAA4B,WAAW;AACvC;AACA;AACA,eAAe,eAAK;AACpB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACO;AACP,2BAA2B,WAAW;AACtC;AACO;AACP;AACA,wBAAwB,WAAW;AACnC;AACA;AACA,6BAA6B,MAAM;AACnC;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9E+C;AAC4D;AACpG;AACP;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,QAAQ;AACrC;AACA;AACA,aAAa,cAAc;AAC3B;AACA;AACA,aAAa,eAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,cAAc;AAChD;AACA;AACA;AACA;AACA,WAAW,cAAI;AACf;AACO;AACP,kCAAkC,sBAAG;AACrC;AACA,KAAK;AACL,WAAW,cAAI,CAAC,0BAAO;AACvB;AACO;AACP;AACA;AACA;;ACvDA;AACO,MAAM,YAAE;AACf;;ACFuC;AACJ;AACS;AACP;AACU;AAC/C;AACA;AACO,kCAAkC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,WAAW,GAAG,sBAAsB;AACjE,qCAAqC,KAAK;AAC1C;AACA;AACA;AACO;AACP;AACA,IAAI,0BAAO;AACX;AACA,QAAQ,gBAAM;AACd,KAAK;AACL;AACA;AACO;AACP,4CAA4C,YAAE;AAC9C;AACO;AACP;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAe,MAAM,EAAC;;;ACvCsB;AACF;AACI;AACX;AACF;;AAEjC;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA,OAAO,8CAA8C;AACrD,OAAO;AACP;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA,qBAAqB,2BAA2B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAO,eAAe,2BAAW,GAAG,0BAAU;AAC3D,0BAA0B,gBAAM,CAAC,gCAAY;AAC7C;;AAEA,uDAAe,MAAM,EAAC;;;;;AC7CsB;AACL;;AAEvC;AACA,IAAI,iBAAS;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4BAAS;AAC/C;AACA,YAAY,iBAAS;AACrB;AACA,SAAS,+BAAW;AACpB;;AAEA,wDAAe,OAAO,EAAC;;;;;;;;;;;;;;;ACzCe;AACU;AACQ;AAClB;AACE;AACF;;AAEtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,iBAAiB,6BAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,4BAAQ,SAAS,6BAAS;AACvC;AACA;AACA,eAAe,iCAAiB;AAChC;AACA;AACA;AACA,eAAe,wBAAQ;AACvB;AACA,iBAAiB,wBAAQ;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sDAAe,cAAc,EAAC;;;;;;;;;AClEoB;AACN;AACN;AACiB;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4BAAQ;AACzB,SAAS,oCAAiB;AAC1B,MAAM,eAAc,QAAQ,+BAAW,YAAY,gCAAiB;AACpE;AACA,CAAC;;AAED,2DAAe,UAAU,EAAC;;;AChC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAe,OAAO,EAAC;;;AC9BvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qDAAe,IAAI,EAAC;;;;;ACtBb;AACP;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACO;AACP;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;;ACb0D;AAC1D;AACA,yBAAyB,uBAAY;AAC9B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;ACjB+D;AACa;AACb;AACZ;AACuB;AAC1E;AACO;AACA;AACP;AACA,oBAAoB,YAAY;AAChC,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa,IAAI,4BAA4B;AAC7D,+CAA+C,mBAAmB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW,IAAI,4BAA4B;AACvD,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,4BAA4B,sBAAsB;AAClD;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,uBAAuB;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,qCAAqC,kBAAkB,EAAE;AAC9H;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,0EAA0E,kBAAkB;AAC5F;AACA,8CAA8C,kBAAkB;AAChE;AACA,0DAA0D,wBAAwB;AAClF,0DAA0D,wBAAwB;AAClF,yEAAyE,yBAAyB;AAClG;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAM;AACjB;AACA;AACA,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB;AACzD;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAI;AACf;AACA,mBAAmB,kBAAQ;AAC3B;AACA;AACA;AACA;AACA,oBAAoB,uBAAI;AACxB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAAO;AAClB,UAAU,eAAK;AACf;AACA;AACA,6BAA6B,4BAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAI;AACpB,mBAAmB,kBAAQ;AAC3B,SAAS;AACT;AACA;AACA;;AC/O8D;AACO;AACuJ;AAC5K;AAC6D;AAC1D;AACnD;AACO;AACA;AACA;AACA;AACP;AACA;AACO;AACP;AACA;AACO;AACP,cAAc,2BAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4BAA4B,gBAAM;AAClC,yCAAyC,KAAK;AAC9C,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,sBAAG;AACpC;AACA;AACA,gBAAgB,kBAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6BAAU;AAC/B;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAG;AAC9B,4BAA4B,sBAAG;AAC/B;AACA;AACA,8BAA8B,KAAK;AACnC;AACA;AACA,qBAAqB,2BAAQ;AAC7B;AACA;AACA,qBAAqB,8BAAW;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC,sBAAG;AACzC;AACA;AACA,wCAAwC,0BAAO;AAC/C,sBAAsB,sBAAG,0BAA0B,iBAAO;AAC1D,uBAAuB,iBAAO;AAC9B;AACA;AACA,SAAS;AACT,+BAA+B,sBAAG;AAClC,8BAA8B,sBAAG,+BAA+B,sBAAG;AACnE,KAAK;AACL;AACA;AACA;AACA,wCAAwC,sBAAG;AAC3C;AACA,4CAA4C,sBAAG;AAC/C,oBAAoB,sBAAG;AACvB;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAG;AAClC,4BAA4B,sBAAG;AAC/B,sBAAsB,yBAAM;AAC5B;AACA,gBAAgB,2BAAQ,+BAA+B,KAAK;AAC5D;AACA;AACA;AACA,SAAS,IAAI;AACb,6BAA6B,sBAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,2CAA2C,yBAAM;AACjD;AACA;AACA;AACA;AACA;AACA,yBAAyB,0BAAO;AAChC;AACA,oBAAoB,0BAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,yBAAyB,kBAAQ;AACjC;AACA;AACA;AACA,4BAA4B,WAAW,IAAI,2BAA2B,CAAC;AACvE,yDAAyD,gCAAgC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,6BAA6B;AAC5E;AACA;AACA;AACA,4BAA4B,0BAAO;AACnC;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAAO;AAC/B;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB,WAAW,IAAI,2BAA2B,CAAC;AACnE,6CAA6C,iBAAiB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAM,8BAA8B,kBAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,yCAAyC,yBAAM;AAC/C,gBAAgB,sBAAG;AACnB,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL,kBAAkB,oBAAU;AAC5B,aAAa;AACb;AACO;AACP,yCAAyC,yBAAM;AAC/C;AACA,iBAAiB,kBAAQ;AACzB,aAAa,6BAAU;AACvB,aAAa,sBAAG;AAChB,aAAa,2BAAQ;AACrB,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA,yCAAyC,0BAA0B,gCAAgC,gBAAgB;AACnH,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL,kBAAkB,oBAAU;AAC5B,aAAa;AACb;AACA;AACO;AACP,kCAAkC,4BAAiB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAM;AAC/B;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,+BAA+B,yBAAM;AACrC;AACA;AACA,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP,oCAAoC,4BAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yBAAM;AAC/B;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,yBAAyB,yBAAM;AAC/B;AACA;AACA,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA,4BAA4B,sBAAG;AAC/B,eAAe,yBAAM;AACrB;AACA,iBAAiB,kBAAQ;AACzB,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,wBAAwB,iBAAO;AAC/B,8BAA8B,yBAAM;AACpC;AACA,KAAK;AACL,mBAAmB,sBAAG;AACtB,+BAA+B,sBAAG;AAClC;AACA,SAAS;AACT,8BAA8B,cAAK;AACnC;AACA,kDAAkD,cAAc;AAChE,sEAAsE,2BAA2B;AACjG,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,yBAAyB,yBAAM;AAC/B,aAAa,sBAAG;AAChB;AACA;AACA;AACA,yBAAyB,KAAK,sBAAsB,KAAK,QAAQ,2BAAQ;AACzE,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,yBAAyB,yBAAM;AAC/B,kDAAkD,kBAAQ;AAC1D,KAAK;AACL,mBAAmB,sBAAG;AACtB,qCAAqC,aAAa,6DAA6D,kBAAkB;AACjI;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,wBAAwB,yBAAM;AAC9B;AACA,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA,YAAY,2BAAQ;AACpB,0BAA0B,uCAAuC;AACjE;AACA,iBAAiB,kBAAQ;AACzB,0BAA0B,8CAA8C;AACxE;AACA;AACA,KAAK;AACL,IAAI,0BAAO;AACX,QAAQ,0BAAO,iBAAiB,qBAAqB;AACrD;AACA,wCAAwC,eAAe;AACvD,iEAAiE,aAAa;AAC9E;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,kBAAQ;AAChB;AACA;AACA;AACA,aAAa,6BAAU;AACvB;AACA,qCAAqC;AACrC;AACA,aAAa,sBAAG;AAChB;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,YAAY,uBAAI;AAChB;AACO;AACP;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACO;AACP;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACO;AACP;AACA;AACA,SAAS,sBAAG;AACZ;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C,SAAS;AACT;AACA,SAAS,sBAAG;AACZ;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C,SAAS;AACT;AACA,QAAQ,sBAAG;AACX,QAAQ,sBAAG;AACX,SAAS,sBAAG;AACZ;AACA,uEAAuE,aAAa,KAAK,4BAA4B;AACrH;AACA,kBAAkB,wBAAwB;AAC1C,SAAS;AACT;AACA,QAAQ,sBAAG;AACX,QAAQ,0BAAO;AACf,YAAY,0BAAO;AACnB,oBAAoB,8BAAW;AAC/B;AACA;AACA,gCAAgC,aAAa,eAAe,QAAQ;AACpE,8BAA8B,wBAAwB;AACtD,qBAAqB;AACrB;AACA,yBAAyB,sBAAG;AAC5B,sCAAsC,0BAAO;AAC7C;AACA;AACA,oBAAoB,0BAAO;AAC3B,6BAA6B,8BAAW;AACxC,6BAA6B,kBAAQ;AACrC;AACA,uGAAuG,mBAAmB,cAAc,iBAAiB,qBAAqB,aAAa;AAC3L,sCAAsC,wBAAwB;AAC9D,6BAA6B;AAC7B;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,0BAA0B,iBAAO,CAAC,0BAAO,CAAC,yBAAM;AAChD,+BAA+B,gBAAM,oDAAoD,KAAK;AAC9F;AACA;AACA,QAAQ,0BAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAG;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,sBAAsB,uBAAI;AAC1B,IAAI,0BAAO;AACX;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,kBAAQ;AAChB;AACA;AACA,aAAa,6BAAU;AACvB;AACA;AACA;AACA,aAAa,sBAAG;AAChB;AACA;AACA;AACA,aAAa,2BAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP,QAAQ,2BAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAQ;AACpB;AACA;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA,iBAAiB,2BAAQ;AACzB;AACA;AACA;AACA;AACA;AACA,qBAAqB,OAAO,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,0BAA0B,wBAAwB;AAClD;AACA,wCAAwC,aAAa;AACrD,8BAA8B,eAAe;AAC7C;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAG;AACzB,YAAY,2BAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAO;AACf;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;;;;;;;;AC12BO;AACP;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;ACPgH;AACzG;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAAO;AACX;AACA,KAAK;AACL;AACO;AACP,iBAAiB,kCAAK;AACtB;AACA;AACA;AACA,qBAAqB,iBAAO,CAAC,0BAAO,CAAC,sBAAG;AACxC,8BAA8B,oBAAU;AACxC;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,IAAI,0BAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP,IAAI,0BAAO;AACX;AACA;AACA,QAAQ,0BAAO;AACf;AACA,SAAS;AACT,KAAK;AACL;AACO;AACP,IAAI,0BAAO;AACX;AACA,KAAK;AACL;AACO;AACP,IAAI,0BAAO;AACX;AACA,KAAK;AACL,IAAI,0BAAO;AACX;AACA;AACA,aAAa,kBAAQ;AACrB;AACA;AACA,KAAK;AACL;AACO;AACP,WAAW,sBAAG;AACd;AACO;AACP,WAAW,sBAAG;AACd;AACO;AACP,WAAW,sBAAG;AACd;AACO;AACP,WAAW,sBAAG;AACd;AACO;AACP,WAAW,sBAAG;AACd;AACA;;ACjHO;AACP;AACA,sEAAsE,YAAY;AAClF,KAAK;AACL;AACA,2CAA2C,6BAA6B,gBAAgB,YAAY,iBAAiB,QAAQ;AAC7H,KAAK;AACL;AACA;;ACR8N;AAC1F;AACzD;AAC3B;AACqB;AACR;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4DAA4D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO,OAAO,UAAU;AAC3D;AACA,wBAAwB,cAAc,EAAE,KAAK;AAC7C;AACA;AACA;AACA,mCAAmC,OAAO,OAAO,UAAU,UAAU,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAM,GAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,6BAA6B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAAO;AAC3B;AACA,iCAAiC,aAAa,kCAAK,mBAAmB;AACtE,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA,uCAAuC,kCAAK;AAC5C;AACA,aAAa;AACb;AACA;AACA,mFAAmF,oBAAoB;AACvG,iBAAiB;AACjB;AACA,qFAAqF,2BAA2B;AAChH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB,uDAAuD,gBAAM,iCAAiC,8BAAW;AACzG,aAAa;AACb,iCAAiC,uBAAI;AACrC,YAAY,0BAAO;AACnB,0CAA0C,YAAY;AACtD;AACA;AACA;AACA,2FAA2F,gBAAgB;AAC3G,yBAAyB;AACzB;AACA;AACA;AACA;AACA,wBAAwB,0BAAO;AAC/B,wBAAwB,iBAAiB;AACzC;AACA;AACA,gDAAgD,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,yBAAyB;AACzB;AACA;AACA;AACA;AACA,2CAA2C,gBAAM,GAAG;AACpD;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,iBAAiB,0BAAO;AACxB;AACA,uCAAuC,sBAAG;AAC1C;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB,gBAAgB,aAAa;AAC7B,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC,qCAAqC,uBAAQ;AAC7C;AACA;AACA;AACA,2CAA2C,mBAAI;AAC/C;AACA;AACA;AACA,uCAAuC,mBAAI;AAC3C;AACA;AACA,4CAA4C,uBAAQ;AACpD;AACA;AACA,4DAA4D,mBAAI;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,6BAA6B;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,yCAAyC,yBAAM;AAC/C;AACA;AACA;AACA;AACA,iBAAiB;AACjB,mDAAmD,0BAAO;AAC1D,kDAAkD,6BAA6B;AAC/E;AACA;AACA;AACA,aAAa;AACb;AACA,gBAAgB,sBAAsB;AACtC,aAAa;AACb;AACA,gBAAgB,gBAAgB;AAChC,aAAa;AACb,SAAS;AACT;AACA;AACA,aAAa,0BAAO;AACpB,mCAAmC,sBAAG;AACtC;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,wBAAwB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,gCAAgC,uBAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4BAA4B;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACroBuD;AACb;AAC8B;AACjE,SAAS,wBAAU;AAC1B,QAAQ,2BAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO,SAAS,2BAAa;AAC7B,WAAW,2BAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8BAAW;AACpB;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA;AACA,IAAI,iBAAiB;AACrB,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA;AACA;AACO,0BAA0B,sBAAsB,KAAK,KAAK;AACjE,iBAAiB;AACV;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,sBAAsB;AACjC;AACA;;ACtFqE;AACtB;AACuC;AAC/E;AACP,gCAAgC,sCAAsC;AACtE,yBAAyB,2BAAa;AACtC;AACA,qBAAqB,wBAAU,YAAY;AAC3C,mCAAmC,eAAe;AAClD,iCAAiC,aAAa,iBAAiB,aAAa;AAC5E;AACA,KAAK;AACL,oCAAoC,0BAA0B;AAC9D;AACA,KAAK;AACL,8BAA8B,yEAAyE;AACvG;AACA;AACA,2BAA2B,cAAK;AAChC;AACA;AACA;AACA;AACA;AACA,sCAAsC,yBAAM;AAC5C,4CAA4C,sBAAG,sCAAsC,sBAAG,8BAA8B,wBAAU,4BAA4B;AAC5J,2CAA2C,sBAAG,iDAAiD,QAAQ,IAAI,QAAQ;AACnH,qFAAqF,kCAAkC;AACvH;AACA;AACA,KAAK;AACL,4BAA4B,kEAAkE;AAC9F;AACA;AACA,2BAA2B,cAAK;AAChC;AACA;AACA;AACA;AACA;AACA,4CAA4C,sBAAG,2CAA2C,sBAAG,8BAA8B,wBAAU,2BAA2B;AAChK;AACA,oBAAoB,mCAAmC;AACvD;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA,qCAAqC,WAAW;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAK;AACnC;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,uBAAuB,QAAQ,EAAE,8BAA8B,KAAK,oCAAoC,cAAc;AACtH,4CAA4C,uBAAuB,kCAAkC,aAAa;AAClH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uFAAuF,UAAU;AACjG;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,sBAAG,kCAAkC,wBAAU;AACvE;AACA,mDAAmD,oCAAoC;AACvF,qBAAqB,WAAW,YAAY,0BAA0B;AACtE,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA,wBAAwB,sBAAG,kCAAkC,wBAAU;AACvE;AACA,+DAA+D,oCAAoC,UAAU,WAAW;AACxH,wBAAwB,0BAA0B;AAClD,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA,0CAA0C,QAAQ,iBAAiB,0BAA0B;AAC7F;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,wDAAwD,2BAA2B;AACnF,sBAAsB,wBAAwB,YAAY,0BAA0B;AACpF;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,wBAAwB,YAAY,0BAA0B,gBAAgB,2CAA2C;AAC3I;AACA,KAAK;AACL;AACA;AACA,0BAA0B,sBAAG;AAC7B,qCAAqC,UAAU,MAAM;AACrD;AACA,2BAA2B;AAC3B;AACA,sBAAsB,SAAS;AAC/B,sFAAsF,kBAAkB;AACxG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA;AACA;AACA,wDAAwD,SAAS,0CAA0C,oBAAoB;AAC/H;AACA,KAAK;AACL;AACA;;AC9KwL;AACjL;AACP;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA,iBAAiB,WAAW;AAC5B;AACA,iBAAiB,MAAM;AACvB;AACA,iBAAiB,mBAAmB;AACpC;AACA,iBAAiB,gCAAgC;AACjD;AACA,iBAAiB,uBAAuB;AACxC;AACA,iBAAiB,UAAU;AAC3B;AACA,iBAAiB,WAAW;AAC5B;AACA,iBAAiB,QAAQ;AACzB;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnDiE;AACrB;AACG;AACxC;AACP;AACA;AACA;AACA;AACO,qCAAqC,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0BAAO,CAAC,yBAAM;AACtB;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACrCA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uDAAe,eAAe,EAAC;;;ACrBO;;AAEtC;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA,EAAE,4BAAQ;AACV;AACA,GAAG;AACH;AACA;;AAEA,sDAAe,cAAc,EAAC;;;ACpBsB;AACF;AACJ;AACX;;AAEnC;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA,eAAe,0BAAO,eAAe,gBAAe,GAAG,eAAc;AACrE;;AAEA,oCAAoC,gCAAY;AAChD;AACA;;AAEA,wDAAe,gBAAgB,EAAC;;;ACtBoB;AACE;;AAEtD;AACA,IAAI,mBAAW;;AAEf;AACA,IAAI,sBAAc,GAAG,mBAAW;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,cAAc,iBAAgB;AAC9B,MAAM,sBAAc;AACpB;AACA,IAAI;AACJ,IAAI,mCAAe;AACnB;AACA,CAAC;;AAED,wDAAe,OAAO,EAAC;;;ACxCiB;AACD;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4BAAS;AAChD;AACA,SAAS,UAAS;AAClB;;AAEA,0DAAe,SAAS,EAAC;;;ACtCoE;AAC1D;AACI;AACuJ;AACvL,+CAA+C,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAK,iCAAiC;AAC/D,+BAA+B,kCAAK,uCAAuC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW,GAAG,sBAAsB;AACrE,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wDAAwD,UAAU;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mCAAmC,cAAM;AACzC;AACA,0CAA0C,QAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sCAAsC,cAAM;AAC5C;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,yCAAyC,cAAM;AAC/C;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,sDAAsD,cAAM;AAC5D;AACA,6DAA6D,QAAQ;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,kCAAK;AACpB;AACA;AACA;AACA;AACA,8BAA8B,cAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,WAAW;AACvC;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA,oBAAoB,UAAU;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA,oBAAoB,WAAW,GAAG,6BAA6B;AAC/D,oBAAoB,UAAU;AAC9B,qCAAqC,QAAQ,GAAG,8BAA8B;AAC9E,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA,oBAAoB,UAAU;AAC9B,qCAAqC,QAAQ,GAAG,8BAA8B;AAC9E,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA,oBAAoB,UAAU;AAC9B;AACA,iBAAiB;AACjB;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C,YAAY,0BAAO;AACnB;AACA;AACA;AACA,oBAAoB,0BAAO;AAC3B;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAI;AACvB,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA,gBAAgB,uBAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAI;AACzB,2BAA2B,mBAAS;AACpC,iCAAiC,mBAAS;AAC1C;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,cAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C,iCAAiC,kCAAK;AACtC;AACA,uCAAuC,kCAAK;AAC5C;AACA;AACA;AACA,mEAAmE,cAAI;AACvE;AACA;AACA;AACA;AACA;AACA,iCAAiC,MAAM;AACvC;AACA;AACA;AACA,qBAAqB,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,cAAI;AAChD;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA,wCAAwC,UAAU;AAClD;AACA;AACA,aAAa;AACb,sEAAsE,cAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA,sCAAsC,QAAQ;AAC9C;AACA,aAAa;AACb,wCAAwC,UAAU;AAClD;AACA;AACA,aAAa;AACb,sEAAsE,cAAI;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA,qBAAqB,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA,aAAa;AACb,sCAAsC,UAAU;AAChD;AACA;AACA,aAAa;AACb,oEAAoE,cAAI;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,UAAU;AAC3C;AACA;AACA;AACA,qBAAqB,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA,aAAa;AACb,oEAAoE,cAAI;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA,mDAAmD,cAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA,4CAA4C,cAAI;AAChD;AACA;AACA,aAAa;AACb;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAK;AAC9B;AACA,mCAAmC,kCAAK;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3e+E;AAC1B;AACd;AAC4D;AAC8F;AAC1L;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA,wBAAwB,MAAM;AAC9B;AACA;AACA,6BAA6B,UAAU;AACvC;AACA;AACA,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA,6BAA6B,gCAAgC;AAC7D;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,2CAA2C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,kCAAkC;AAC5C,UAAU,sBAAsB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,UAAU,kCAAkC;AAC5C,UAAU,sBAAsB;AAChC;AACA;AACO;AACP;AACA,oCAAoC,eAAK;AACzC,eAAe,eAAK;AACpB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAG;AAClC,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAG;AACnC,mBAAmB,0BAAO;AAC1B,SAAS;AACT,4BAA4B,yBAAM;AAClC,YAAY,0BAAO;AACnB,qBAAqB,sBAAG;AACxB;AACA;AACA,gBAAgB,0BAAO;AACvB,yBAAyB,sBAAG;AAC5B;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,SAAS,IAAI;AACb;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oCAAoC,eAAK;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kCAAkC,0BAAO;AACzC;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAM;AACtC;AACA,gBAAgB,0BAAO;AACvB;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uCAAuC;AACpE;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,wBAAwB,sBAAG,wBAAwB,iBAAiB;AACpE;AACA,uBAAuB,sBAAG;AAC1B;AACA,QAAQ,0BAAO;AACf;AACA,YAAY,0BAAO;AACnB;AACA,aAAa;AACb,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA,6BAA6B,6BAA6B;AAC1D;AACA;AACA,sCAAsC,8CAA8C;AACpF;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAAO;AACvC;AACA;AACA;AACA;AACA;AACA,wCAAwC,uBAAuB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,iBAAiB;AACxE;AACA;AACA,oBAAoB,0BAAO;AAC3B;AACA,wBAAwB,0BAAO;AAC/B;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAe,GAAG,uBAAuB;AACpE,0BAA0B,WAAe,GAAG,sBAAsB;AAClE;AACA;AACO;AACP,sCAAsC,wBAAwB;AAC9D;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,eAAK;AACb;AACA;AACA;AACA,SAAS;AACT;AACO;AACP,WAAW,eAAK,qCAAqC,eAAK,iCAAiC,eAAK,wBAAwB,0BAAO;AAC/H;AACA;;ACtdoL;AACnH;AAC6L;AAClH;AACjF;AACG;AACvD;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,WAAW,sBAAG,sEAAsE,MAAM,yBAAyB,8BAA8B;AACjJ;AACO;AACP,4BAA4B,0BAAO;AACnC;AACA,8BAA8B,0BAAO;AACrC,gCAAgC,0BAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAO;AACpC,uBAAuB,gBAAM;AAC7B;AACA,KAAK;AACL,mBAAmB,sBAAG,CAAC,yBAAM;AAC7B,0BAA0B,cAAK;AAC/B;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP,cAAc,oBAAoB,OAAO,KAAK,SAAS,KAAK,iCAAiC;AAC7F;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACO,4CAA4C,WAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,yBAAM;AAC9B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,SAAS,kBAAQ;AACjB;AACA,8CAA8C,SAAS,4CAA4C,UAAU;AAC7G;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA;AACA,QAAQ,0BAAO;AACf;AACA;AACA;AACA;AACA,mCAAmC,kBAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,sBAAsB,yBAAyB;AAC/C;AACA,aAAa;AACb;AACA;AACA;AACA,+BAA+B,oBAAU;AACzC,oCAAoC,0BAAO;AAC3C,4BAA4B,kCAAK;AACjC;AACA;AACA,SAAS;AACT;AACA;AACA;AACO;AACP;AACA,QAAQ,0BAAO;AACf;AACA;AACA,sBAAsB,cAAK;AAC3B;AACA,6BAA6B,WAAW;AACxC;AACA;AACA,kCAAkC,WAAe;AACjD,6BAA6B,MAAM;AACnC,6BAA6B,mBAAmB;AAChD,6BAA6B,gCAAgC;AAC7D,6BAA6B,uBAAuB;AACpD,6BAA6B,UAAU;AACvC;AACA;AACA,kCAAkC,WAAW;AAC7C;AACA,iBAAiB,0BAAO,CAAC,sBAAG;AAC5B;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA,qBAAqB,cAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,0BAAO;AAC1B,2BAA2B,mBAAS;AACpC,eAAe,0BAAO;AACtB,uCAAuC,uBAAuB,wBAAwB,sBAAsB;AAC5G,gBAAgB,0BAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,8BAA8B,yBAAyB;AACvD;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAM;AAChB,mBAAmB,0BAAO;AAC1B;AACA;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA,KAAK;AACL;AACA;AACO,kCAAkC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,mBAAmB,0BAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,0BAA0B,yBAAyB;AACnD;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,IAAI,0BAAO;AACX;AACA;AACA;AACA,QAAQ,0BAAO;AACf,6BAA6B,WAAW;AACxC;AACA;AACA,0BAA0B,gCAAgC;AAC1D;AACA,gBAAgB,0BAAO,CAAC,0BAAO;AAC/B;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,0BAA0B,yBAAyB;AACnD;AACA,iBAAiB;AACjB;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA,iCAAiC,yBAAM;AACvC;AACA;AACA;AACA;AACA,QAAQ,0BAAO;AACf;AACA,YAAY,0BAAO;AACnB;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA,KAAK;AACL,uBAAuB,sBAAG;AAC1B,4BAA4B,sBAAG;AAC/B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACO;AACP;AACA,4BAA4B,yBAAM;AAClC,gCAAgC,sBAAG;AACnC,qBAAqB;AACrB,SAAS;AACT;AACA,KAAK;AACL,mBAAmB,iBAAO,CAAC,0BAAO;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yBAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC,SAAS;AACT,qCAAqC,sBAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,uBAAuB,sBAAG;AAC1B,IAAI,0BAAO;AACX;AACA,YAAY,kBAAQ;AACpB;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;;AClb8C;AACuB;AACA;AAC+C;AAC7G,SAAS,mCAAc;AAC9B,0BAA0B,2BAAQ;AAClC,wBAAwB,mCAAmC;AAC3D,KAAK;AACL;AACA,IAAI,0BAAO;AACX;AACA,KAAK;AACL,WAAW,cAAiB;AAC5B;AACO,SAAS,oCAAe;AAC/B,cAAc,2BAAQ;AACtB,wBAAwB,oCAAoC;AAC5D,KAAK;AACL,WAAW,eAAkB;AAC7B;AACA;;ACpBqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,WAAW,kBAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;ACzDyF;AACC;AACpB;AAC9B;AACa;AAC9C;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,+BAA+B,sBAAG;AAClC;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,wBAAwB;AACtD;AACA,mCAAmC,mBAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA,yCAAyC,uBAAI;AAC7C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAI;AACnC,iCAAiC,YAAY;AAC7C;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4BAA4B,sBAAG;AAC/B;AACA,SAAS;AACT,eAAe,0BAAO;AACtB;AACA;AACA;AACA,oBAAoB,GAAG;AACvB;AACA,6EAA6E,YAAE;AAC/E;AACA;AACA;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kCAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAG;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,GAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjSA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACP;AACO;AACP;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACP;AACO;AACP;AACA;AACA;AACA;;ACzB6C;AAC8B;AACf;AACoG;AACmB;AAC5K;AACP;AACA;AACA;AACA,2HAA2H,qBAAqB;AAChJ;AACA;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAAO,yBAAyB,uBAAuB,2BAA2B,oCAAoC;AACrI;AACA;AACA,eAAe,0BAAO,yBAAyB,0BAA0B,cAAc,oCAAoC;AAC3H;AACA;AACA,eAAe,0BAAO,yBAAyB,wCAAwC,4BAA4B,oCAAoC;AACvJ;AACA;AACA,eAAe,iCAAiC,sBAAsB,oCAAoC;AAC1G;AACA;AACA,eAAe,uBAAuB,kHAAkH,8BAA8B;AACtL;AACA;AACA,eAAe,iCAAiC,2FAA2F,WAAW,oBAAoB,uCAAuC;AACjN;AACA;AACA;;AC9CyC;AACY;AACoG;AACnF;AACA;AACtE;AACA;AACA;AACO;AACP;AACA,oCAAoC,sBAAG;AACvC;AACA,cAAc,qBAAqB;AACnC,4BAA4B,sBAAG;AAC/B;AACA,cAAc,qBAAqB;AACnC,iCAAiC,sBAAG;AACpC;AACA,kBAAkB,oBAAoB,GAAG,iCAAiC;AAC1E;AACA;AACA;AACA,QAAQ,0BAAO;AACf,+BAA+B,eAAe;AAC9C,wBAAwB,mHAAmH;AAC3I,gBAAgB,0BAAO;AACvB;AACA,uCAAuC,oBAAoB,WAAW,EAAE,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,oCAAoC,2BAA2B,0CAA0C,MAAM;AAC/G;AACA,qBAAqB;AACrB,iBAAiB;AACjB,gBAAgB,0BAAO;AACvB,sEAAsE,QAAQ,uCAAuC,oBAAoB;AACzI,iBAAiB;AACjB,gBAAgB,0BAAO;AACvB,sEAAsE,UAAU,mCAAmC,oBAAoB;AACvI,iBAAiB;AACjB,gBAAgB,0BAAO;AACvB,sEAAsE,gBAAgB,gDAAgD,oBAAoB;AAC1J,iBAAiB;AACjB,gBAAgB,0BAAO;AACvB,sEAAsE,oBAAoB,6DAA6D,oBAAoB;AAC3K,iBAAiB;AACjB,gBAAgB,0BAAO;AACvB,sEAAsE,YAAY,oDAAoD,oBAAoB;AAC1J,iBAAiB;AACjB,aAAa;AACb,SAAS;AACT;AACA;AACA,2BAA2B,cAAc,EAAE,2CAA2C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,wBAAwB,2BAA2B;AACnD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,eAAe,2BAA2B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtEA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;ACT4G;AAC7C;AACxD;AACP,0BAA0B,uBAAI;AAC9B;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,cAAc;AAClB;AACA;AACA;AACA,gBAAgB,0BAAO;AACvB;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAAW;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iBAAiB,0BAAO;AACxB,sCAAsC,sBAAG;AACzC,+DAA+D,sBAAsB;AACrF,uBAAuB,kDAAkD;AACzE;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,IAAI,cAAc;AAClB;AACA,IAAI,0BAAO;AACX;AACA,KAAK;AACL;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC,8DAA8D;AACxD;AACP;AACA;AACA;AACO;AACP,6BAA6B,yBAAM;AACnC,eAAe,6BAAU;AACzB,KAAK;AACL,mBAAmB,sBAAG;AACtB;AACA,6CAA6C,aAAa,OAAO,oCAAoC;AACrG;AACA;AACA;AACA,KAAK;AACL,WAAW,iBAAO;AAClB;AACA;;ACzF2H;AAClE;AACkE;AACtE;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,oCAAoC,sBAAG;AACvC;AACA,cAAc,qBAAqB;AACnC;AACA,4CAA4C,mBAAI;AAChD,yCAAyC,mBAAI;AAC7C,mCAAmC,mBAAI;AACvC,sCAAsC,mBAAI;AAC1C,+BAA+B,mBAAI;AACnC;AACA;AACA;AACA;AACA,oDAAoD,mBAAmB;AACvE,mDAAmD,mBAAmB;AACtE,uCAAuC,mBAAI;AAC3C;AACA;AACA;AACA,oDAAoD,mBAAI;AACxD,mDAAmD,mBAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E,mDAAmD,yBAAyB;AAC5E,uCAAuC,mBAAI;AAC3C;AACA;AACA;AACA;AACA,oDAAoD,mBAAI;AACxD,mDAAmD,mBAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,mBAAI;AACpD,+CAA+C,mBAAI;AACnD,mCAAmC,mBAAI;AACvC,8CAA8C,mBAAI;AAClD;AACA;AACA,8EAA8E,4BAA4B;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAoB;AAC5B;AACA;AACA;AACA;AACA,YAAY,8BAAW;AACvB,iDAAiD,oCAAoC,iBAAiB,uBAAI;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAAW;AACvB,mCAAmC,wCAAwC,iBAAiB,uBAAI;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9L2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrE6C;AACuB;AACU;AACA;AACX;AACf;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mBAAmB;AAC3D,YAAY,kBAAQ;AACpB,2BAA2B,oCAAoC;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D,2BAA2B,wBAAwB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gBAAgB,CAAC,yBAAM;AACtC;AACA;AACA;;;;AC7U0G;AACiE;AAChD;AACpE;AAC8H;AAClI;AACW;AACT;AACiF;AACtI;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAG;AACf;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB;AACA;AACA;AACA,gBAAgB,0BAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0BAAO;AACnB,6BAA6B,yBAAM;AACnC;AACA;AACA,aAAa,IAAI;AACjB;AACA,iBAAiB,sBAAG;AACpB,YAAY,eAAK,CAAC,0BAAO,CAAC,yBAAM,0BAA0B,WAAW;AACrE,kCAAkC,0BAAO,CAAC,yBAAM;AAChD,iCAAiC,cAAI;AACrC,6BAA6B,yBAAM;AACnC;AACA;AACA,aAAa,IAAI;AACjB;AACA,iBAAiB,2BAAQ;AACzB,6BAA6B,kCAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC,8BAA8B,sBAAG;AACjC,cAAc,0BAAO,CAAC,yBAAM;AAC5B,cAAc,yBAAM;AACpB,sCAAsC,eAAK,sCAAsC,0BAAO;AACxF;AACA,cAAc,kCAAkC;AAChD,cAAc,sBAAsB;AACpC;AACA;AACA;AACA,QAAQ,iBAAiB,CAAC,yBAAM;AAChC;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA,8BAA8B,sBAAG;AACjC;AACA,cAAc,mBAAmB;AACjC,kCAAkC,sBAAG;AACrC;AACA,cAAc,mBAAmB;AACjC;AACA;AACA,oDAAoD,oBAAoB,GAAG,uBAAuB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,uCAAuC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gBAAgB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA,sHAAsH,gBAAgB,kBAAkB,iCAAiC;AACzL;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oCAAoC;AACpD,uCAAuC,oBAAoB,kBAAkB,oCAAoC;AACjH;AACA;AACA,+DAA+D,SAAS;AACxE;AACA;AACA;AACA,uDAAuD,QAAQ;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,QAAQ,kBAAkB,2BAA2B;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8BAA8B;AAC9C,uCAAuC,YAAY,kBAAkB,8BAA8B;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oBAAoB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D,qBAAqB,0BAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,kCAAkC,wBAAwB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,0BAA0B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kCAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,GAAG;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7hB+G;AACxE;AACgE;AAClD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA,oCAAoC,sBAAG;AACvC;AACA,cAAc,qBAAqB;AACnC;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA,qCAAqC,kCAAK;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kCAAK;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kCAAkC,kBAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,sBAAsB;AACnE;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,kCAAkC,oBAAoB;AACtD;AACA;AACA;;ACzE8F;AAC/C;AACxC;AACP;AACA;AACA;AACA,YAAY,8BAAW;AACvB,kCAAkC,cAAc;AAChD;AACA,eAAe,uBAAuB;AACtC;AACA;AACA;AACA;AACA,4BAA4B,cAAK;AACjC;AACA;AACA,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA;;ACrBmF;AAC2G;AACxI;AAC4B;AACC;AACxC;AACqB;AAChE;AACA;AACA;AACA;AACA;AACA,mCAAmC,uBAAuB;AAC1D,YAAY,WAAW,GAAG,wCAAwC,KAAK,KAAK;AAC5E,iBAAiB;AACjB,8BAA8B,mBAAmB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,+BAA+B,IAAI;AACnC;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA,0BAA0B,IAAI;AAC9B;AACA;AACA,4BAA4B,IAAI;AAChC;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA,sCAAsC,IAAI;AAC1C,sCAAsC,IAAI;AAC1C,qCAAqC,IAAI;AACzC,iCAAiC,IAAI;AACrC,mCAAmC,IAAI;AACvC,uCAAuC,IAAI;AAC3C,2CAA2C,IAAI;AAC/C,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA,wCAAwC,IAAI,GAAG,4BAA4B;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA;AACA,8BAA8B,gCAAgC;AAC9D;AACA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAG;AAC9B,+CAA+C,yBAAyB;AACxE,kEAAkE,2BAA2B;AAC7F,8CAA8C,gCAAgC;AAC9E;AACA;AACA;AACA,yBAAyB,uBAAI;AAC7B;AACA,oCAAoC,WAAW;AAC/C;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,+CAA+C,yBAAyB;AACxE,8DAA8D,wBAAwB;AACtF,8CAA8C,gCAAgC;AAC9E;AACA;AACA;AACA,yBAAyB,uBAAI;AAC7B,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAI;AACzB,0BAA0B,6BAAU;AACpC,0CAA0C,iCAAiC;AAC3E;AACA;AACA;AACA,QAAQ,sBAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAI;AACzB;AACA,uBAAuB,0BAAO;AAC9B;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA,KAAK;AACL,QAAQ,sBAAG;AACX;AACA;AACA,0BAA0B,cAAI,oBAAoB,6BAAU;AAC5D;AACA;AACA,IAAI,0BAAO;AACX,gCAAgC,WAAW,GAAG,gBAAgB;AAC9D;AACA,YAAY,sBAAG;AACf,wEAAwE;AACxE;AACA;AACA,iBAAiB,sBAAG;AACpB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C,oEAAoE,mBAAmB;AACvF;AACA;AACA;AACA;AACA;;ACtSgC;AACU;AACW;AACrD;AACA;AACA;AACO;AACP;AACA,YAAY,sBAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO,OAAO,UAAU;AACvD;AACA,oBAAoB,cAAc,EAAE,KAAK;AACzC;AACA;AACA;AACA,+BAA+B,OAAO,OAAO,UAAU,UAAU,KAAK;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/CO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;;ACnBsE;AACjB;AACS;AACS;AACiC;AACb;AACrC;AACF;AACG;AACE;AACE;AACM;AACR;AACE;AACF;AACG;AACN;AACG;AAClD,oBAAoB,mBAAmB,CAAC,GAAG;AAClD;AACO;AACP;AACA;AACA;AACA;AACA,0BAA0B,0BAA0B;AACpD;AACA;AACA;AACA,CAAC;AACM;AACP;AACA;AACA,CAAC;AACM;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AACxD;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gBAAgB;AAChC,aAAa;AACb;AACA;AACA;AACA;AACA,oBAAoB,0BAAO;AAC3B;AACA;AACA;AACA,2CAA2C,cAAc;AACzD;AACA,yBAAyB;AACzB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,iCAAiC,mCAAc;AAC/C,2BAA2B,yBAAM;AACjC,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA,oBAAoB,0BAAO;AAC3B,6CAA6C,oCAAe;AAC5D,+BAA+B,yBAAM;AACrC,oCAAoC,yBAAM;AAC1C,wCAAwC,oCAAoC;AAC5E;AACA,qBAAqB;AACrB,sDAAsD,iBAAiB;AACvE;AACA,+BAA+B,yBAAM;AACrC,oCAAoC,yBAAM;AAC1C;AACA,qBAAqB;AACrB;AACA;AACA,aAAa;AACb;AACA,gBAAgB,0BAAO;AACvB;AACA;AACA;AACA,2CAA2C,sBAAsB,CAAC,yBAAM;AACxE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,+BAA+B,yBAAM;AACrC,qBAAqB;AACrB,sDAAsD,yBAAM;AAC5D,iBAAiB;AACjB;AACA;AACA,iBAAiB,0BAAO;AACxB,gCAAgC,sBAAG;AACnC,wEAAwE,0DAA0D;AAClI;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sBAAG;AACf;AACA;AACA;AACA;AACA;AACA,+BAA+B,sBAAG;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,IAAI,WAAW;AACf,IAAI,UAAU;AACd,IAAI,WAAW;AACf,IAAI,YAAY;AAChB,IAAI,gBAAgB;AACpB,IAAI,aAAa;AACjB,IAAI,YAAY;AAChB,IAAI,aAAa;AACjB,IAAI,YAAY;AAChB,IAAI,iBAAiB;AACrB;AACO,wBAAwB,sDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,4BAA4B,kCAAK;AACjC;AACA;AACA;AACA;AACA;;ACxMwC;AACD;AACvC;AACA;AACA;AACA;AACO;AACP,2DAA2D;AAC3D;AACA;AACA;AACA;;ACXA;AACA;AACuC;AAC4E;AAC1C;AACzE;AACsH;AACtH;AACiE;AACO;AACxE;AACsE;AACiG;AAC7F;AAC1E;AAC8L;AAC9L;AACuF;AAC9B;AACzD;AACO;AACP;AACA;AACA;AACA;AACuE;AAChE,MAAM,UAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AAC0D;AACmB;AACf;AACV;AACpD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,8BAAc,UAAU,2CAAiB,UAAU,2CAAkB,CAAC,uCAAa;AAC/F;AACA;AACA;AACA;AACA;AACA,oBAAoB,mCAAiB;AACrC;AACA;AACA;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACmC;AACM;AAC2H;AAC7J;AACP,cAAc,UAAU,GAAG,KAAK,GAAG,WAAW;AAC9C;AACO;AACA;AACA;AACA;AACA;AACP;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oBAAQ;AACtC;AACA;AACA,mCAAmC,uBAAW;AAC9C;AACA;AACA,mCAAmC,uBAAW;AAC9C;AACA;AACA,mCAAmC,kBAAM;AACzC,eAAe,UAAM;AACrB;AACA,mCAAmC,sBAAU;AAC7C;AACA;AACA,mCAAmC,mCAAuB;AAC1D;AACA;AACA,mCAAmC,+BAAmB;AACtD;AACA;AACA,mCAAmC,4CAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iBAAiB,sBAAG;AACpB;AACA;AACA;AACA,SAAS,UAAM;AACf;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAM,CAAC,sBAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,iCAAiC;AACjC,4BAA4B;AAC5B;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,2BAA2B;AAC3B,6BAA6B;AAC7B,wBAAwB;AACxB;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAW;AACzC;AACA;AACA,mCAAmC,kBAAM;AACzC;AACA;AACA,mCAAmC,sBAAU;AAC7C;AACA;AACA,mCAAmC,mCAAuB;AAC1D;AACA;AACA,mCAAmC,+BAAmB;AACtD;AACA;AACA,mCAAmC,4CAAgC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,mIAAmI;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnZA;AACA;AACA;AACA;AACA;AACmC;AAC5B;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,UAAU,WAAW,OAAO,GAAG,yBAAyB,GAAG,4DAA4D;AACrI;AACA;;;;;;;;;;AC7C8C;AACR;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAC/C,YAAY,QAAQ,IAAI,QAAQ;AAChC;AACA;AACA,mCAAmC,4BAAQ,QAAQ,gCAAY;AAC/D;;AAEA,uDAAe,MAAM,EAAC;;;;;;;;;;;AC9BtB;AACA;AACA;AACA;AACA;AACuO;AACnH;AAChD;AACjC;AACQ;AACF;AACN;AACQ;AACA;AACA;AACF;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACO,sCAAsC,gCAAoB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAA4D;AAC5E;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,4BAA4B,sBAAG,CAAC,iCAAiB;AACjD;AACA;AACA;AACA;AACA,SAAS,gBAAgB,sBAAG;AAC5B;AACA,gCAAgC,yBAAM;AACtC,gBAAgB,0BAAO;AACvB;AACA;AACA,wBAAwB,0BAAO;AAC/B;AACA,yBAAyB;AACzB;AACA,iBAAiB;AACjB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAuD;AACvE;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA,qBAAqB,sBAAG,CAAC,iCAAiB;AAC1C;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,sBAAG;AACtB,SAAS;AACT;AACA;AACA,sCAAsC,0BAAO;AAC7C;AACA,gBAAgB,0BAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yBAAM;AAC1C;AACA;AACA,wBAAwB,0BAAO;AAC/B;AACA,yBAAyB;AACzB;AACA;AACA,iBAAiB,IAAI;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,sBAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,sBAAG,kCAAkC,0BAAU;AACnE;AACA,2DAA2D,oCAAoC,QAAQ,yCAAyC,EAAE,WAAW;AAC7J,oBAAoB,0BAA0B;AAC9C,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAW;AACnC;AACA;AACA,6BAA6B,kBAAM;AACnC;AACA;AACA,6BAA6B,uBAAW;AACxC;AACA;AACA,6BAA6B,+BAAmB;AAChD;AACA;AACA,6BAA6B,4CAAgC;AAC7D;AACA;AACA,6BAA6B,mCAAuB;AACpD;AACA;AACA,6BAA6B,sBAAU;AACvC;AACA;AACA,6BAA6B,oBAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAAO;AACnC,2BAA2B,gBAAM;AACjC,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,YAAY;AACzC;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C,QAAQ,4BAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,aAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3iBA;AACA;AACA;AACA;AACA;AACkE;AAClE;;;;ACNA;AACA;AACA;AACA;AACa;AACN;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACZ;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AACpB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA,0EAA0E,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,KAAK;AACzG;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,aAAa;AACjB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA,IAAI,oCAAoC;AACxC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oCAAoC;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oEAAoE;AACrE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA,IAAI,kBAAkB;AACtB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,eAAe;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,eAAe;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;AAC3B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AACtB;AACP;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AAC1D;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS,gCAAgC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AACtC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA,6DAA6D,GAAG;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,qBAAqB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8BAA8B;AAClC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,8BAA8B;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA,IAAI,uCAAuC;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,uCAAuC;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0EAA0E;AAC3E;AACA;AACA,IAAI,+CAA+C;AACnD;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,+CAA+C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0FAA0F;AAC3F;AACA;AACA,IAAI,wBAAwB;AAC5B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,wBAAwB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,kBAAkB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AAC1B;AACP;AACA;AACA,uDAAuD,qBAAqB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wCAAwC;AAClC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yBAAyB;AACnE;AACA;AACA;AACA,uDAAuD,oBAAoB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AAC9B;AACP;AACA;AACA,uDAAuD,aAAa;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB,IAAI;AAC5D;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA,IAAI,4BAA4B;AAChC;AACO;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oDAAoD;AACrD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,wBAAwB;AACxC,gBAAgB,wBAAwB;AACxC;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sDAAsD;AACvD;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AACxC;AACP;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA,IAAI,gBAAgB;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA,IAAI,yBAAyB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;AACA;AACA,IAAI,oBAAoB;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,oBAAoB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wDAAwD;AACzD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AAC3C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8DAA8D;AAC/D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4EAA4E;AAC7E;AACA;AACA,IAAI,0BAA0B;AAC9B;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,yDAAyD,0BAA0B;AACnF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AAC1C;AACP;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AACxB;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,kCAAkC;AAC5B;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oDAAoD;AAC9C;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,oDAAoD;AACrD;AACA,qBAAqB,+DAA+D;AACpF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kEAAkE;AAC5D;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,wDAAwD;AAClD;AACP;AACA;AACA,iBAAiB;AACjB;AACA;AACA,CAAC,0DAA0D;AACpD;AACP;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC,YAAY,oEAAoB;AACvC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,qBAAqB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gBAAgB;;;AC7qEjB;AACA;AACA;AACA;AACA;AACuD;AACF;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,kCAAY;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,kCAAY;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C,wBAAwB,mBAAmB;AAC3C,qCAAqC;AACrC;AACA;AACA;AACA;AACA,qBAAqB,OAAO,QAAQ,oBAAoB,QAAQ;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClPA;AACA;AACA;AACA;AACA;AACqG;AACxC;AAC6B;AACV;AAC8B;AACvD;AAChD;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,mCAAmC,+FAA+F;AACrN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,+BAA+B,cAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wCAAc;AAC/B;AACA;AACA;AACA,6BAA6B,6CAAmB;AAChD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA,uEAAuE,aAAa;AACpF;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA,uCAAuC,yBAAS;AAChD;AACA;AACA;AACA;AACA,qBAAqB,yBAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,4CAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAyB;AACrC;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAkB,UAAU,wBAAY;AACvE;AACA;AACA,yCAAyC,gCAAgB;AACzD,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,sCAA0B;AACzC;AACA;AACA,eAAe,sCAA0B;AACzC;AACA;AACA,eAAe,sCAA0B;AACzC;AACA;AACA,eAAe,sCAA0B;AACzC;AACA;AACO;AACP,gCAAgC,kBAAkB;AAClD;AACA;AACA;AACA,8BAA8B,qDAAqD;AACnF,oCAAoC,cAAc;AAClD,4BAA4B,aAAa,cAAc,aAAa;AACpE;AACA,oCAAoC,gBAAgB;AACpD,oDAAoD,qBAAqB;AACzE;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,iBAAiB;AACrE;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAqB;AACrD;AACA;AACA,kEAAkE,oBAAoB;AACtF,sBAAsB,gCAAoB,GAAG,mCAAmC;AAChF,sBAAsB,uBAAuB;AAC7C;AACA,gEAAgE;AAChE,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACheA;AACA;AACA;AACA;AACA;AAC4C;AAC4O;AAC9M;AAC9B;AACsD;AAC3F;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8CAAoB;AAC1C,wBAAwB,yBAAM,uBAAuB,wBAAY;AACjE;AACA,kDAAkD,oBAAoB,qDAAqD;AAC3H;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAS;AACjB;AACA;AACA,aAAa,wBAAQ;AACrB;AACA;AACA,aAAa,4BAAY;AACzB;AACA;AACA,aAAa,gCAAgB;AAC7B;AACA;AACA,aAAa,0BAAU;AACvB;AACA;AACA,aAAa,8BAAc;AAC3B;AACA;AACA,aAAa,gCAAgB;AAC7B;AACA;AACA,aAAa,uBAAO;AACpB;AACA;AACA,aAAa,2BAAW;AACxB;AACA,+CAA+C,eAAG;AAClD;AACA;AACA,kBAAkB,+BAAiB,+CAA+C,cAAc;AAChG;AACA;AACA;AACA;AACA,uBAAuB,qCAAW;AAClC;AACA;AACA;AACA;AACA,QAAQ,4BAAY;AACpB;AACA;AACA,sHAAsH;AACtH;AACA;AACA,aAAa,8BAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,kBAAkB,+BAAiB,uCAAuC,uBAAuB;AACjG;AACA;AACA,QAAQ,mCAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6BAAa;AACrB;AACA;AACA;AACA;AACA,aAAa,6BAAa;AAC1B;AACA;AACA;AACA;AACA,aAAa,0BAAU;AACvB;AACA;AACA;AACA,aAAa,oCAAoB;AACjC;AACA;AACA;AACA,aAAa,+BAAgB;AAC7B;AACA;AACA;AACA,IAAI,mCAAiB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS,GAAG,QAAQ;AAC7C;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uBAAO;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,4CAAkB;AAC7C;AACA;AACA,0EAA0E,qCAAW;AACrF;AACA;AACA;AACA,aAAa,0BAAU,cAAc,4BAAY;AACjD;AACA;AACA;AACA;AACA;AACA,aAAa,0BAAU,cAAc,8BAAc;AACnD;AACA;AACA;AACA;AACA,aAAa,yBAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,yBAAyB,yBAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,iBAAiB;AACjB;AACA,yBAAyB,yBAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ,mCAAiB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA;AACA,QAAQ,4BAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4BAAY;AAC5B,gBAAgB,uBAAO,YAAY,8BAAc,YAAY,gCAAgB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;;AChXA;AACA;AACA;AACA;AACA;AAC8D;AACN;AACjD;AACP;AACA;AACA,uBAAuB,uBAAuB;AAC9C,IAAI,YAAY;AAChB;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACoD;AACI;AACxD;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,uBAAuB,aAAa;AACpC,WAAW,YAAY;AACvB;AACA;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACsF;AACtF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,oCAAuB;AACtC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,gCAAkB;AAC/B;AACA;AACA;AACA;AACO;AACP,mBAAmB,gCAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,kBAAkB,8BAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;AACO,MAAM,sBAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AClGA;AACA;AACA;AACA;AACa;AACb,MAAM,qBAAgB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,SAAS;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,oGAAoG,SAAS;AAC7G;AACA;AACA;AACA;AACA,qBAAqB,qBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,IAAI,iBAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,qBAAgB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE,iBAAY,KAAK,iBAAY,KAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkE;AACpB;AACe;AACjB;AACA;AAC5C;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC;AAChC;AACP;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAAiB;AAC5D;AACA;AACA;AACA;AACA,qDAAqD,cAAG;AACxD,YAAY,8BAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8BAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,eAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,iBAAY;AAC7F;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxQA;AACA;AACA;AACA;AACA;AAC6D;AACuB;AACF;AACpB;AACJ;AAC1D;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,8BAAiB;AACxD,2BAA2B,+BAAS;AACpC,kBAAkB,iBAAiB;AACnC,YAAY,sCAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sCAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF,aAAa;AAC9F;AACA,yDAAyD,cAAc,4DAA4D,aAAa,KAAK,aAAa,GAAG;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAS;AAC7B;AACA;AACA;AACA,yBAAyB,4CAAoB;AAC7C;AACA;AACA,wHAAwH,sCAAsC;AAC9J;AACA;AACA;AACA;AACA,qCAAqC,kCAAY;AACjD,2DAA2D,sCAAsC;AACjG,sEAAsE,aAAa;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,2CAA2C,GAAG,UAAU,WAAW,QAAQ;AACxJ;AACA,uBAAuB,iCAAS;AAChC,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,uBAAuB,sCAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sCAAc;AAC9B,yBAAyB;AACzB;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E,2BAA2B;AACxG;AACA;AACA,qDAAqD,cAAc,4DAA4D,2BAA2B,KAAK,aAAa,GAAG;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kCAAY;AACrC,yCAAyC,aAAa;AACtD,yGAAyG,aAAa;AACtH;AACA;AACA,6CAA6C,cAAc,2CAA2C,eAAe,SAAS,2BAA2B,wBAAwB;AACjL;AACA;AACA;;ACpKA;AACA;AACA;AACA;AACA;AACgE;AACzD;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6CAAmB;AAClC;AACA;AACA;;ACpBA;AACA;AACA;AACA;AACA;AACwC;AACzB;AACR;AACP;AACA,wBAAwB,gBAAK;AAC7B,uBAAuB,gBAAK;AAC5B,uBAAuB,gBAAK;AAC5B,wBAAwB,gBAAK;AAC7B,2BAA2B,gBAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAG;AAClB;AACA;AACA,CAAC,4BAA4B;AAC7B;;ACvCA;AACA;AACA;AACA;AACA;AAC2D;AACX;AACI;AACmB;AAC3B;AACK;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wCAAc;AAC7C;AACA;AACA;AACA,oBAAoB,mCAAW;AAC/B;AACA;AACA;AACA;AACA,4BAA4B,mCAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,iCAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACA;AACA;AACA,wBAAwB,iCAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uCAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;ACtFA;AACA;AACA;AACA;AACA;AACgD;AAChD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAS,KAAK,yBAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACA;AACA;AACA;AACA,eAAe,yBAAM;AACrB;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3LA;AACA;AACA;AACA;AACA;AAC6D;AACa;AACvB;AACW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,iDAAiD,8BAAiB;AAClE;AACA;AACA;AACA,gBAAgB,8CAA8C,eAAe,0BAA0B;AACvG,sFAAsF,eAAe;AACrG,+CAA+C,kBAAkB;AACjE;AACA,qEAAqE,0BAA0B;AAC/F;AACA,+CAA+C,kBAAkB,qCAAqC,gBAAgB,2FAA2F,iBAAiB;AAClO;AACA;AACA,2BAA2B,8CAA8C;AACzE;AACA,iEAAiE,gCAAc,gBAAgB,8BAAiB;AAChH;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,8BAAiB;AACtE;AACA,2BAA2B,QAAQ;AACnC;AACA,2BAA2B,uCAAiB;AAC5C,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFA;AACA;AACA;AACA;AACA;AAC0D;AAC1D;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA,eAAe,2BAAY;AAC3B;AACA;AACA;;AC/EA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,4BAA4B,4DAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,6CAA6C;AAC7C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0CAA0C;AAC1C;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACmD;AACC;AACR;AACS;AAC9C;AACP;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA,4BAA4B,iCAAW;AACvC;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAM;AACtC;AACA;AACA,cAAc;AACd;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAW,CAAC,yBAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAM;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,WAAW;AAC9B;AACA;AACA;AACA;AACA;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;;AChEA;AACA;AACA;AACA;AACA;AACiC;AAC0B;AACP;AACa;AAC1D;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iCAAW;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAA0D;AACrF;AACA;AACA;AACA;AACA,iBAAiB,mCAAW;AAC5B;AACA;AACA;AACA,uCAAuC,iCAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU,GAAG,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iCAAS;AAC1B;AACA;AACA,iFAAiF;AACjF;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA,8FAA8F;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,4CAA4C,8CAAoB;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA;AACA;AACA;AACA,6BAA6B,iCAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iCAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,cAAG;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,cAAG;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzNA;AACA;AACA;AACA;AACA;AACgD;AAChD;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK,wDAAwD,gBAAgB;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,gGAAgG,IAAI,kBAAkB,WAAW;AACjI;AACA;AACA,gGAAgG,IAAI;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7EA;AACA;AACA;AACA;AACA;AACgD;AACG;AACc;AACrB;AAC5C;AACA;AACA;AACO;AACP,aAAa;AACb;AACO;AACP;AACA;AACA,CAAC,gDAAgD;AACjD;AACA;AACA;AACO;AACP;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mCAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA;AACA;AACA,+BAA+B,eAAe,IAAI,eAAe,KAAK,MAAM;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yBAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxJA;AACA;AACA;AACA;AACA;AAC6D;AACuB;AAClC;AACG;AAC+B;AAC1B;AACnD;AACP;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB,8BAAiB;AAClF;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA,yEAAyE,QAAQ,wGAAwG;AACzL;AACA;AACA;AACA,0EAA0E,QAAQ,yGAAyG;AAC3L;AACA;AACA;AACA,0EAA0E,QAAQ,yGAAyG;AAC3L;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,kCAAkC;AAClC;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,kCAAkC;AAClC;AACA;AACA;AACA;AACA,wBAAwB,kCAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,8BAAiB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,8BAAiB;AACxF;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA,sEAAsE,8BAAiB;AACvF,0BAA0B,+BAAS;AACnC,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,sEAAsE,8BAAiB;AACvF;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,kBAAkB,6CAAmB;AACrC;AACA;AACA,kBAAkB,4CAAkB;AACpC;AACA;AACA;AACA;AACA,qBAAqB,uBAAuB;AAC5C,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,gDAAgD,gCAAgC;AAChF;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,mBAAmB,cAAc;AACjC;AACA,mBAAmB,cAAc;AACjC;AACA,mBAAmB,cAAc;AACjC;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;AAC/C;;ACnPA;AACA;AACA;AACA;AACA;AAC6D;AACV;AAC8B;AACvB;AACI;AACb;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA,0EAA0E,iCAAW;AACrF;AACA;AACA;AACA,4CAA4C,MAAM;AAClD;AACA;AACA,0CAA0C,QAAQ,qGAAqG,uCAAiB;AACxK;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,8BAA8B,uCAAiB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,qDAAqD,8BAAiB;AACtE;AACA;AACA,8BAA8B,+BAAS;AACvC,kBAAkB,iBAAiB;AACnC,YAAY,sCAAgB,6BAA6B,sCAAc;AACvE;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAW;AAClC;AACA;AACA;AACA;AACA;AACA,qBAAqB,uCAAiB;AACtC,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qCAAqC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;AC7CA;AACA;AACA;AACA;AACA;AAC4C;AACS;AACrD;AACA;AACA;AACO;AACP;AACA,0BAA0B,sBAAQ;AAClC;AACA;AACA,uDAAuD,cAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,wBAAwB;AACpF,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;;ACdA;AACA;AACA;AACA;AACA;AAC6D;AACT;AACD;AACqD;AAC5D;AAC8B;AAC3B;AACxC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,0CAA0C,QAAQ;AAClD;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,gBAAgB,8BAAiB;AACxE;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA,qCAAqC,aAAa;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oHAAoH,kBAAkB;AACtI;AACA;AACA;AACA;AACA;AACA,8EAA8E,yBAAyB,YAAY;AACnH,iCAAiC;AACjC;AACA,6BAA6B;AAC7B,6CAA6C,aAAa;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA,iDAAiD,8BAAiB;AAClE,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,kBAAkB;AAC9F,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA;AACA,+BAA+B,yBAAM;AACrC;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA,SAAS;AACT;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAa;AACzD;AACA,4CAA4C,aAAa;AACzD;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,SAAS;AACT;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,SAAS;AACT;AACA,4CAA4C,aAAa;AACzD;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,0BAA0B;AAC1F;AACA;AACA,2BAA2B,oBAAoB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,uFAAuF,oBAAoB;AAC3G;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,8BAAiB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,gCAAkB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uBAAuB,gCAAkB;AACzC,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF,+IAA+I,kBAAkB;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzXA;AACA;AACA;AACA;AACA;AACoD;AACD;AACU;AACjB;AACK;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iCAAW;AACxC;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA,aAAa;AACb,SAAS;AACT,eAAe,yBAAM;AACrB;AACA;AACA,2BAA2B,yBAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,8BAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,8BAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3FA;AACA;AACA;AACA;AACA;AAC6D;AACW;AAClB;AAC/C;AACP;AACA;AACA,0BAA0B,sBAAQ;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ,kGAAkG;AACrJ;AACA,qDAAqD,8BAAiB;AACtE;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA;AACA;AACA;;AClHA;AACA;AACA;AACA;AACA;AACiF;AAC1E;AACP;AACA,eAAe,qCAAyB;AACxC;AACA;AACA,eAAe,qCAAyB;AACxC;AACA;AACO,mCAAmC;AACnC;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,mCAAmC,iBAAe;AAClD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AAC8D;AACU;AAC5B;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAc;AAC9C;AACA;AACA,4BAA4B,EAAE,KAAK,EAAE,GAAG,EAAE;AAC1C,0BAA0B,MAAM,EAAE,KAAK,EAAE,GAAG,EAAE,gBAAgB,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA,2BAA2B,KAAK;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ;AACtC,4BAA4B,QAAQ;AACpC;AACA;AACA;AACA,2BAA2B,KAAK;AAChC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA,mBAAmB,KAAK;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK,QAAQ,QAAQ,gDAAgD,QAAQ;AACxG,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,QAAQ,QAAQ,yDAAyD,QAAQ;AAC7G,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK,QAAQ,QAAQ,yDAAyD,QAAQ;AACjH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK,QAAQ,QAAQ,yDAAyD,QAAQ;AACjH,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK,QAAQ,QAAQ,gDAAgD,QAAQ;AACpG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,QAAQ;AAClC;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+FAA+F,KAAK;AACpG;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qCAAY;AACjE;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA,sBAAsB,MAAM,EAAE,QAAQ;AACtC;AACA;AACA,sBAAsB,KAAK,IAAI,QAAQ;AACvC;AACA;AACA;AACA,qBAAqB,EAAE,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,OAAO,GAAG,UAAU,EAAE,OAAO;AACnD;AACA,sBAAsB,MAAM,IAAI,QAAQ;AACxC;AACA;AACA,sBAAsB,KAAK,IAAI,QAAQ;AACvC;AACA;AACA;AACA,qBAAqB,EAAE,MAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,QAAQ;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAG;AACX,mBAAmB,QAAQ,IAAI,QAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3fA;AACA;AACA;AACA;AACA;AACoD;AACH;AAC1C;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,OAAO;AAC9B,gCAAgC,UAAU;AAC1C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc,KAAK,GAAG,UAAU,GAAG;AAC1F,uBAAuB,QAAQ,IAAI,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACwE;AAChB;AACjD;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,oBAAoB;AAChC;AACA;AACA,qBAAqB,qCAAe;AACpC;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACyE;AAC7B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpJA;AACA;AACA;AACA;AACA;AACsF;AACe;AAC9F;AACP;AACA,uCAAuC,oCAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,8BAAiB;AAChE,6BAA6B,sBAAQ;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,qCAAqC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1EA;AACA;AACA;AACA;AACA;AACuG;AACrC;AAC2C;AAC3D;AACF;AACE;AAC3C;AACP;AACA,uCAAuC,KAAK;AAC5C,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,QAAQ,oBAAoB;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAAS;AACvC,oCAAoC;AACpC;AACA;AACA,kCAAkC,+BAAS;AAC3C,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAS;AACjC;AACA;AACA,6BAA6B,mCAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAS;AAC9B;AACA;AACA,qBAAqB,mCAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qCAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAkB;AAC9B;AACA;AACA,iBAAiB,qCAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAAS;AACvC,oCAAoC;AACpC;AACA;AACA;AACA,kCAAkC,+BAAS;AAC3C;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iCAAS;AACjC;AACA;AACA,6BAA6B,mCAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,iCAAS;AAC9B;AACA;AACA,qBAAqB,mCAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,+BAAS;AACvC,gBAAgB,iCAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;;AClRA;AACA;AACA;AACA;AACA;AACoE;AACW;AACN;AACT;AACI;AACb;AACa;AACL;AACa;AACN;AACE;AACT;AACe;AACL;AACgD;AACjD;AACI;AACH;AACyB;AAC/B;AACQ;AACQ;AACI;AACV;AACE;AACjB;AACO;AACV;AAC3D;AACA;AACA;AACA;AACO;AACP;AACA;AACA,+CAA+C,sBAAsB;AACrE,qDAAqD,0BAA0B;AAC/E,SAAS;AACT;AACA,2CAA2C,kBAAkB;AAC7D,yCAAyC,mBAAmB;AAC5D,yCAAyC,mBAAmB;AAC5D,4CAA4C,sBAAsB;AAClE,sCAAsC,4CAAqB;AAC3D,oCAAoC,wCAAmB;AACvD,qCAAqC,YAAY;AACjD,kDAAkD,iCAAiC;AACnF,iDAAiD,gCAAgC;AACjF,SAAS;AACT;AACA,sCAAsC,qBAAqB;AAC3D,0DAA0D,iCAAiC;AAC3F,4DAA4D,mCAAmC;AAC/F,SAAS;AACT;AACA,sCAAsC,aAAa;AACnD,oCAAoC,mBAAmB;AACvD,6CAA6C,oBAAoB;AACjE,gDAAgD,uBAAuB;AACvE,0CAA0C,iBAAiB;AAC3D,SAAS;AACT;AACA,wCAAwC,eAAe;AACvD,8CAA8C,qBAAqB;AACnE,SAAS;AACT;AACA,iDAAiD,wBAAwB;AACzE,kDAAkD,kBAAkB;AACpE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,2CAA2C,sBAAsB;AACjE;AACA,gDAAgD,uBAAuB;AACvE,sDAAsD,6BAA6B;AACnF,+CAA+C,sBAAsB;AACrE,4CAA4C,mBAAmB;AAC/D,gDAAgD,uBAAuB;AACvE;AACA,qCAAqC,oBAAoB;AACzD,qDAAqD,4BAA4B;AACjF;AACA;AACA;AACA;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,+CAA+C;AAC/C,CAAC,wBAAwB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,sHAAsH;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kHAAkH,kBAAkB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1IA;AACA;AACA;AACA;AAC6D;AACtD;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO;AACA;AACP;AACA;AACO,0CAA0C,4EAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wBAAwB,GAAG,iBAAiB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kDAAkD;AAC5E,0BAA0B,wCAAwC;AAClE,0BAA0B,mCAAmC;AAC7D,0BAA0B,sCAAsC;AAChE,0BAA0B,yCAAyC;AACnE,0BAA0B,cAAc;AACxC,0BAA0B,iCAAiC;AAC3D,0BAA0B,iCAAiC;AAC3D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sCAAsC;AAChE,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2CAA2C;AACrE,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C,0BAA0B,kDAAkD;AAC5E,0BAA0B,oBAAoB;AAC9C,0BAA0B,oCAAoC;AAC9D,0BAA0B,uCAAuC;AACjE,0BAA0B,wCAAwC;AAClE,0BAA0B,sBAAsB;AAChD,0BAA0B,cAAc;AACxC,0BAA0B,sCAAsC;AAChE,0BAA0B,oBAAoB;AAC9C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD,0BAA0B,oBAAoB;AAC9C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,0BAA0B,uCAAuC;AACjE,0BAA0B,qCAAqC;AAC/D,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD,0BAA0B,yCAAyC;AACnE,0BAA0B,cAAc;AACxC,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,iBAAiB;AAC3C,0BAA0B,sBAAsB;AAChD,0BAA0B,mBAAmB;AAC7C,0BAA0B,kBAAkB;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,oCAAoC;AAC9D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,iBAAiB;AAC3C,0BAA0B,mBAAmB;AAC7C,0BAA0B,kBAAkB;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,cAAc;AACxC,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,+CAA+C;AACzE,0BAA0B,mBAAmB;AAC7C,0BAA0B,kBAAkB;AAC5C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,oCAAoC;AAC9D,0BAA0B,wBAAwB;AAClD,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qCAAqC;AAC/D,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,oCAAoC;AAC9D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,oCAAoC;AAC9D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,oCAAoC;AAC9D,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B,mBAAmB;AAC7C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB;AAC/C,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;;;;;;;;;;;;;;;;;ACxsBA;AACA;AACA;AACA;AACA;AACmC;AACqD;AAC9B;AACsB;AACmB;AACvD;AACrC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,kEAAM,CAAC,uFAAoB;AAC1D;AACA;AACA;AACA;AACA,+EAA+E,8EAAY;AAC3F;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iFAAc;AAC1C;AACA;AACA;AACA,sBAAsB,gFAAa;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8EAAY,UAAU,uDAAK;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+EAAY;AAChC,6BAA6B,gFAAiB,cAAc,4EAAS;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2FAAyB;AAChD;AACA;AACA;AACA;AACA;AACA,sFAAsF,gFAAc;AACpG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AAC6E;AACM;AAC5E;AACP;AACA;AACA,YAAY,uFAAgB;AAC5B,sBAAsB,4FAAyB;AAC/C;AACA,YAAY,iFAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,8EAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;AACzC;;;;;;;;;;;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB;AAC3D;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AAC2D;AACmB;AACrC;AACzC;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,wBAAwB,oEAAS;AACjC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,qBAAqB,oEAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,eAAe,2DAAU;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,oEAAS;AAC7B;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oEAAS;AACrC,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAW;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,eAAe,gEAAc;AAC7B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAc;AACjC;AACA,eAAe,gEAAc,gDAAgD,mBAAmB;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gEAAO;AAClB;AACA;AACA;AACA;AACA;AACO;AACP,eAAe,2DAAU;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,oBAAoB,sEAAW;AAC/B;AACA,6BAA6B,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA,4BAA4B,sEAAW;AACvC,qCAAqC,sBAAsB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAW;AAC1B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChRA;AACA;AACA;AACA;AACA;AACqF;AACxC;AAC7C;AACA;AACA;AACA;AACO;AACP,eAAe,gEAAc;AAC7B,YAAY,6EAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI,mBAAmB;AAC5B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;AACpC;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,UAAU,GAAG;AACb;AACO,kCAAkC,EAAE;AAC3C;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAa;AACzB;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,WAAW,wEAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4CAA4C;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpTA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,wBAAwB,SAAS,KAAK,sBAAsB,GAAG,2BAA2B;AAC1F;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACuD;AACF;AACE;AACgB;AAC5B;AACoB;AAC/D;AACA;AACA;AACA;AACO;AACP,mCAAmC,+EAAgB;AACnD;AACA;AACA;AACA;AACO;AACP,uCAAuC,iFAAkB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iFAAkB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAiB;AACrB,YAAY,6EAAc,2BAA2B,qFAAsB;AAC3E;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,mCAAmC,wEAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2EAAkB,qBAAqB,+EAAgB;AACnF;AACA;AACA;AACA;AACA,QAAQ,6EAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,QAAQ,4EAAa;AACrB;AACA;AACA,yBAAyB,kEAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4EAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA,2BAA2B,2EAAkB,wBAAwB,+EAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,iFAAkB;AAC1B;AACA,YAAY,2EAAY;AACxB;AACA;AACA;AACA,iBAAiB,+EAAgB;AACjC;AACA;AACA;AACA;AACA,YAAY,4EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAAkB,OAAO,+EAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAiB;AACxC,YAAY,+EAAgB;AAC5B;AACA;AACA;AACA,iBAAiB,6EAAc,UAAU,+EAAgB;AACzD;AACA;AACA,iBAAiB,+EAAgB;AACjC;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,0EAAiB;AACxC,YAAY,6EAAc;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,+EAAgB;AAChC;AACA;AACA;AACA,iBAAiB,+EAAgB;AACjC;AACA;AACA,iBAAiB,2EAAY;AAC7B;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+EAAgB;AAChC;AACA;AACA,qBAAqB,8EAAe,aAAa,yEAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,QAAQ,+EAAgB;AACxB;AACA;AACA,aAAa,8EAAe,UAAU,yEAAU,UAAU,+EAAgB;AAC1E;AACA;AACA,aAAa,2EAAY;AACzB;AACA;AACA;AACA;AACA;AACA,aAAa,iFAAkB;AAC/B;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACO;AACP;AACA,QAAQ,iFAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yFAA0B;AAClC;AACA;AACA,aAAa,kFAAmB;AAChC;AACA;AACA,aAAa,mFAAoB;AACjC;AACA;AACA,aAAa,qFAAsB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,iFAAkB;AAC/B;AACA;AACA,aAAa,+EAAgB;AAC7B;AACA;AACA,aAAa,+EAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,6EAAc;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,qDAAqD,gEAAgE;AACrH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,8BAA8B,SAAS,IAAI,uCAAuC;AAClF;AACA;AACA,KAAK;AACL;AACA;AACA,iCAAiC,wCAAwC,GAAG,SAAS;AACrF;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,mCAAmC,2BAA2B,GAAG,4BAA4B;AAC7F;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,wEAAY;AACvB;AACA;AACA;AACA;AACA,oBAAoB,6DAA6D,EAAE,MAAM;AACzF;AACA;AACA,kBAAkB,MAAM,EAAE,oBAAoB;AAC9C;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnkBA;AACA;AACA;AACA;AACA;AAC4E;AACrE;AACP,yBAAyB,4EAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,iFAAiB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,qBAAqB,OAAO;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACO;AACP;AACA;AACA;AACO;AACP,mCAAmC;AACnC;AACO;AACP,+EAA+E,qBAAqB,EAAE,qBAAqB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,6BAA6B,UAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACxSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,6EAA6E;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,wBAAwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,gCAAgC;AACvE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,uCAAuC,+CAA+C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACO,oCAAoC,8BAA8B;AACzE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,uCAAuC,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;AAC/B;;;;;;;;;;;;AC7fA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;AChBqC;;AAErC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qCAAqC,iEAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,YAAY,EAAC;;;;;;;;;;;;AC/B5B;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA,iEAAe,MAAM,EAAC;;;;;;;;;;;;;;ACbgB;AACK;;AAE3C;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA,eAAe,oEAAW;;AAE1B,EAAE,iEAAQ;AACV;AACA,GAAG;AACH;AACA;;AAEA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrBqB;AACN;AACF;AACC;AACL;;AAEhC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,OAAO,2BAAQ;AACf;AACA;AACA,SAAS,4BAAQ;;AAEjB;AACA;AACA;AACA;;AAEA;AACA,cAAc,yBAAK;AACnB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,2BAAQ;AAC3B;AACA,aAAa,2BAAO,2BAA2B;AAC/C;AACA;AACA,IAAI,+BAAW;AACf;AACA;AACA;AACA;;AAEA,+CAAe,OAAO,EAAC;;;AClDa;AACA;AACE;;AAEtC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,2BAAO;;AAEvB;AACA,MAAM,QAAO,SAAS,4BAAQ;AAC9B;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;;;;;;;;;;;AC7Bc;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA,oBAAoB,QAAQ,IAAI,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAS;AAClB;;AAEA,iEAAe,KAAK,EAAC;;;;;;;;;;;;;;;;ACnCiB;AACb;AACyB;AACjB;;AAEjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,gBAAgB,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAChD,WAAW;AACX;AACA,eAAe,iEAAQ;AACvB;;AAEA;AACA;AACA;;AAEA,eAAe,uEAAc;AAC7B;AACA;;AAEA;AACA;AACA,gBAAgB,+DAAM;AACtB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,2DAAE;AACb;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED,iEAAe,QAAQ,EAAC;;;;;;;;;;;;;;;;;;;;;;AC/DsB;AACH;AACd;;AAE7B;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,SAAS,8BAAW;AACpB,qBAAqB,gCAAY;AACjC,mBAAmB,uBAAI;AACvB,kCAAkC;AAClC;AACA;AACA;AACA;AACA;;AAEA,kDAAe,UAAU,EAAC;;;;;;;ACxBsB;AACF;AACP;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,OAAO,oCAAoC;AAC3C,OAAO,oCAAoC;AAC3C,OAAO;AACP;AACA;AACA,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA,wBAAwB,iCAAiC;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,4BAAS;AAC/C;AACA;AACA;AACA,SAAS,iCAAa,QAAQ,gCAAY;AAC1C;;AAEA,0DAAe,SAAS,EAAC;;;ACtDiB;AACH;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA,OAAO,8CAA8C;AACrD,OAAO,+CAA+C;AACtD,OAAO;AACP;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAU,CAAC,mBAAS;;AAE/B,qDAAe,IAAI,EAAC;;;;;;;;;;;;;;ACzCwB;AACjB;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oEAAW,CAAC,4DAAG;AACxB;;AAEA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;AC5BqB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oEAAW;AAC7B;;AAEA,iEAAe,OAAO,EAAC;;;;;;;;;;;;;;;;ACrBvB;AACA;;AAEA;AACA,IAAI,uBAAc;;AAElB;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,2BAA2B,uBAAc;AACzC;;AAEA,+CAAe,OAAO,EAAC;;;;;AClBa;AACA;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,cAAc;AACzB,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB,OAAO;AACzB,0BAA0B,gBAAgB,QAAQ,GAAG;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2BAAO,eAAe,QAAO;AACxD;;AAEA,oDAAe,GAAG,EAAC;;;;;;;;;;;;;;;AClCuB;AACP;AACU;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,gEAAO,WAAW,qEAAY,WAAW,mEAAU;AACzD;;AAEA,iEAAe,QAAQ,EAAC;;;;;;;;;;;;AC7BxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iEAAe,IAAI,EAAC;;;;;;;;;;;;;;;;ACnBkB;AACQ;AACV;AACD;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA,OAAO,kBAAkB;AACzB,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gEAAO,eAAe,6DAAQ,GAAG,4DAAO;AACrD,0BAA0B,qEAAY;AACtC;;AAEA,iEAAe,GAAG,EAAC;;;;;;;;;;;;;;;ACpD2B;AACZ;AACG;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAY,QAAQ,6DAAQ,EAAE,2DAAM;AAC1C;AACA;;AAEA,iEAAe,GAAG,EAAC;;;;;;;;;;;;;;;;AC5BnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uDAAe,eAAe,EAAC;;;AClBqB;;AAEpD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,sBAAsB,gBAAe;AACrC;AACA;;AAEA,gDAAe,QAAQ,EAAC;;;;;;;AClBc;AACD;AACA;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,2BAAQ;AACd;AACA;AACA,MAAM,2BAAQ;AACd;AACA,YAAY,2BAAQ;AACpB;AACA;AACA;AACA;AACA,UAAU,SAAQ;AAClB;AACA;AACA;AACA;AACA;;AAEA,yDAAe,QAAQ,EAAC;;;AC/Da;;AAErC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kBAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA,yDAAe,QAAQ,EAAC;;;;;;;;;;;;;ACzCa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iEAAQ;AACvB;;AAEA;AACA;;AAEA,iEAAe,SAAS,EAAC;;;;;;;;ACnCzB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;ACvLhB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,+BAA+B,GAAG,yBAAyB;AAC3D,cAAc,mBAAO,CAAC,KAAO;AAC7B,WAAW,mBAAO,CAAC,KAAM;AACzB,iBAAiB,mBAAO,CAAC,GAAU;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wBAAwB,yBAAyB,yBAAyB;AAC3E;AACA;AACA,aAAa,YAAY;AACzB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;;;;;;;;;AC/FlB;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,aAAa;AAC/B,cAAc,mBAAO,CAAC,KAAO;AAC7B;AACA;AACA,0BAA0B;AAC1B,+BAA+B;AAC/B,CAAC,YAAY,aAAa,aAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,+CAA+C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;;;;;;;;;AC/Ha;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa,GAAG,cAAc,GAAG,cAAc,GAAG,eAAe;AACtH;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,mBAAmB;;;;;;;;;AClCN;AACb;AACA;AACA;AACA;AACA,8CAA6C,EAAE,aAAa,EAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;AACnB,kBAAe;;;;;;;;;;;;;;ACtBf,QAAQ,MAAM,aAAa,OAAO,QAAQ,cAAc,gGAAgG,gBAAgB,gCAAgC,YAAY,KAAK,gCAAgC,KAAK,gBAAgB,KAAK,WAAW,mBAAmB,wBAAwB,kGAAkG,yBAAyB,mBAAmB,yEAAyE,UAAU,oCAAoC,iBAAiB,SAAS,oCAAoC,+DAA+D,QAAQ,6BAA6B,SAAS,OAAO,mBAAmB,yCAAyC,UAAU,KAAK,MAAM,oCAAoC,OAAO,mEAAmE,yDAAyD,uBAAuB,+BAA+B,2DAA2D,4EAA4E,wBAAwB,6CAA6C,iBAAiB,kCAAkC,cAAc,mBAAmB,KAAK,mBAAmB,2CAA2C,qCAAqC,wBAAwB,4BAA4B,gDAAgD,YAAY,iCAAiC,KAAK,6BAA6B,iCAAiC,KAAK,wCAAwC,KAAK,KAAK,UAAU,QAAQ,gDAAgD,6BAA6B,oDAAoD,MAAM,wBAAwB,+BAA+B,cAAc,SAAS,YAAY,KAAK,iEAAiE,6EAA6E,uBAAuB,SAAS,qBAAqB,+BAA+B,0DAA0D,KAAK,iCAAiC,OAAO,IAAI,OAAO,UAAU,kDAAkD,wBAAwB,yFAAyF,KAAK,oBAAoB,+CAA+C,uCAAuC,sBAAsB,iBAAiB,KAAK,KAAK,sBAAsB,WAAW,OAAO,MAAM,OAAO,+EAA+E,mDAAmD,iBAAiB,KAAK,6BAA6B,OAAO,MAAM,OAAO,yBAAyB,6BAA6B,qBAAqB,KAAK,4CAA4C,KAAK,KAAK,sBAAsB,6EAA6E,YAAY,MAAM,OAAO,qEAAqE,oBAAoB,iIAAiI,qBAAqB,uDAAuD,kCAAkC,MAAM,mBAAmB,KAAK,OAAO,uCAAuC,yBAAyB,iCAAiC,uBAAuB,4CAA4C,KAAK,mGAAmG,YAAY,MAAM,MAAM,4QAA4Q,8CAA8C,uBAAuB,MAAM,cAAc,WAAW,+BAA+B,YAAY,YAAY,qCAAqC,YAAY,+DAA+D,uBAAuB,EAAE,8DAA8D,4FAA4F,eAAe,wCAAwC,SAAS,GAAG,SAAS,MAAM,MAAM,iBAAiB,sBAAsB,mBAAmB,OAAO,aAAa,OAAO,UAAU,oCAAoC,0BAA0B,0BAA0B,2CAA2C,gBAAgB,iEAAiE,0BAA0B,YAAY,YAAY,OAAO,aAAa,QAAQ,gBAAgB,WAAW,EAAE,GAAG,kGAAkG,0BAA0B,+KAA+K,oKAAoK,kFAAkF,QAAQ,gBAAgB,yPAAyP,OAAO,UAAU,KAAK,MAAM,SAAS,4BAA4B,4KAA4K,qBAAqB,kDAAkD,UAAU,0DAA0D,SAAS,iEAAiE,aAAa,kBAAkB,QAAQ,kBAAkB,IAAI,+CAA+C,GAAG,kUAAkU,qBAAqB,kBAAkB,uFAAuF,eAAe,QAAQ,iDAAiD,uBAAuB,uEAAuE,6BAA6B,eAAe,8DAA8D,iBAAiB,eAAe,iBAAiB,SAAS,YAAY,iBAAiB,MAAM,4BAA4B,iBAAiB,qEAAqE,UAAU,mBAAmB,kBAAkB,gBAAgB,aAAa,aAAa,4DAA4D,eAAe,oFAAoF,SAAS,SAAS,QAAQ,iSAAiS,SAAS,4KAA4K,kBAAkB,WAAW,YAAY,WAAW,KAAK,wBAAwB,8MAA8M,KAAK,8BAA8B,aAAa,wFAAwF,qEAAqE,cAAc,MAAM,YAAY,WAAW,KAAK,wBAAwB,6EAA6E,sBAAsB,gBAAgB,MAAM,8DAA8D,YAAY,EAAE,OAAO,oQAAoQ,gBAAgB,cAAc,UAAU,+CAA+C,GAAG,oDAAoD,qBAAqB,WAAW,sBAAsB,8HAA8H,uGAAuG,MAAM,4DAA4D,wBAAwB,qBAAqB,0BAA0B,GAAG,YAAY,GAAG,2CAA2C,wBAAwB,oBAAoB,0BAA0B,GAAG,YAAY,GAAG,cAAc,iEAAiE,cAAc,IAAI,6BAA6B,MAAM,kDAAkD,sCAAsC,cAAc,2CAA2C,aAAa,yBAAyB,MAAM,aAAa,4BAA4B,eAAe,yBAAyB,EAAE,gCAAgC,kBAAkB,uBAAuB,wBAAwB,6DAA6D,OAAO,EAAE,uBAAuB,0CAA0C,wBAAwB,0DAA0D,OAAO,EAAE,wBAAwB,0BAA0B,uBAAuB,0BAA0B,SAAS,GAAG,UAAU,IAAW,MAAM,UAAU;AAC98U&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/regexp-to-ast/lib/src/api.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/grammar-loader.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/utils/lib/src/to-fast-properties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseSlice.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/drop.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/assign.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/pickBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseIsRegExp.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/isRegExp.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/gast/lib/src/model.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/rest.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/uniq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseSome.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/some.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/includes.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_arrayEvery.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseEvery.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/every.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/gast/lib/src/helpers.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/first.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/constants.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/follow.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/negate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/reject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/indexOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseDifference.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/difference.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/compact.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/head.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/utils/lib/src/print.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/reg_exp_parser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/reg_exp.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/lexer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/utils/lib/src/timer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/tokens.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/lexer_errors_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/lexer_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/scan/tokens_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/errors_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/gast/lib/src/visitor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/resolver.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_arrayAggregator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseAggregator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_createAggregator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/groupBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/dropRight.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/interpreter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/lookahead.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/checks.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/exceptions_public.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/keys.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/cst/cst.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/lang/lang_extensions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/parse/parser/parser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@chevrotain/cst-dts-gen/lib/src/api.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain/lib/src/api.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/languages/grammar-config.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain-allstar/lib/atn.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain-allstar/lib/dfa.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/uniqBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain-allstar/lib/all-star-lookahead.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/chevrotain-allstar/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-languageserver-types/lib/esm/main.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/cst-node-builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/langium-parser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/parser-builder-base.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/completion-parser-builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/langium-parser-builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/promise-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-languageserver-textdocument/lib/esm/main.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/documents.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/linker.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/name-provider.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/uri-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/references.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/collections.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/scope-computation.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/scope.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/caching.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/references/scope-provider.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/serializer/json-serializer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/service-registry.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/validation/validation-registry.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/validation/document-validator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/ast-descriptions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/ast-node-locator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/configuration.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/disposable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/document-builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/index-manager.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/workspace-manager.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/lexer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/documentation/jsdoc.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/documentation/documentation-provider.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/documentation/comment-provider.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/async-parser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/workspace-lock.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/serializer/hydrator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/default-module.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/dependency-injection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/languages/generated/ast.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/token-builder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/parser/value-converter.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/syntax-tree.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/ast-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/cst-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/errors.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/grammar-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/regexp-utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/utils/stream.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/langium/lib/workspace/file-system-provider.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseExtremum.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseLt.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseSet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_basePickBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/clone.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/defaults.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_createFind.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/findIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/find.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/flatMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/flatten.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/has.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/isString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/last.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/map.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_trimmedEndIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/_baseTrim.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toFinite.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash-es/toInteger.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/process/browser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/cancellation.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/events.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/is.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-jsonrpc/lib/common/ral.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/vscode-uri/lib/esm/index.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export function cc(char) {</span><span class="s3">\n    </span><span class="s1">return char.charCodeAt(0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function insertToSet(item, set) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(item)) {</span><span class="s3">\n        </span><span class="s1">item.forEach(function (subItem) {</span><span class="s3">\n            </span><span class="s1">set.push(subItem);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">set.push(item);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function addFlag(flagObj, flagKey) {</span><span class="s3">\n    </span><span class="s1">if (flagObj[flagKey] === true) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">duplicate flag </span><span class="s3">\&quot; </span><span class="s1">+ flagKey;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const x = flagObj[flagKey];</span><span class="s3">\n    </span><span class="s1">flagObj[flagKey] = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function ASSERT_EXISTS(obj) {</span><span class="s3">\n    </span><span class="s1">// istanbul ignore next</span><span class="s3">\n    </span><span class="s1">if (obj === undefined) {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Internal Error - Should never get here!</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// istanbul ignore next</span><span class="s3">\n</span><span class="s1">export function ASSERT_NEVER_REACH_HERE() {</span><span class="s3">\n    </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Internal Error - Should never get here!</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isCharacter(obj) {</span><span class="s3">\n    </span><span class="s1">return obj[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">] === </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { cc } from </span><span class="s3">\&quot;</span><span class="s1">./utils.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const digitsCharCodes = [];</span><span class="s3">\n</span><span class="s1">for (let i = cc(</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">); i &lt;= cc(</span><span class="s3">\&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">); i++) {</span><span class="s3">\n    </span><span class="s1">digitsCharCodes.push(i);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const wordCharCodes = [cc(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)].concat(digitsCharCodes);</span><span class="s3">\n</span><span class="s1">for (let i = cc(</span><span class="s3">\&quot;</span><span class="s1">a</span><span class="s3">\&quot;</span><span class="s1">); i &lt;= cc(</span><span class="s3">\&quot;</span><span class="s1">z</span><span class="s3">\&quot;</span><span class="s1">); i++) {</span><span class="s3">\n    </span><span class="s1">wordCharCodes.push(i);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">for (let i = cc(</span><span class="s3">\&quot;</span><span class="s1">A</span><span class="s3">\&quot;</span><span class="s1">); i &lt;= cc(</span><span class="s3">\&quot;</span><span class="s1">Z</span><span class="s3">\&quot;</span><span class="s1">); i++) {</span><span class="s3">\n    </span><span class="s1">wordCharCodes.push(i);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes</span><span class="s3">\n</span><span class="s1">export const whitespaceCodes = [</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot; \&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u00a0</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u1680</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2000</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2001</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2002</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2003</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2004</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2005</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2006</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2007</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2008</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2009</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u200a</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u202f</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u205f</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">u3000</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">cc(</span><span class="s3">\&quot;\\</span><span class="s1">ufeff</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=character-classes.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addFlag, ASSERT_EXISTS, ASSERT_NEVER_REACH_HERE, cc, insertToSet, isCharacter, } from </span><span class="s3">\&quot;</span><span class="s1">./utils.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { digitsCharCodes, whitespaceCodes, wordCharCodes, } from </span><span class="s3">\&quot;</span><span class="s1">./character-classes.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// consts and utilities</span><span class="s3">\n</span><span class="s1">const hexDigitPattern = /[0-9a-fA-F]/;</span><span class="s3">\n</span><span class="s1">const decimalPattern = /[0-9]/;</span><span class="s3">\n</span><span class="s1">const decimalPatternNoZero = /[1-9]/;</span><span class="s3">\n</span><span class="s1">// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983</span><span class="s3">\n</span><span class="s1">// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern</span><span class="s3">\n</span><span class="s1">export class RegExpParser {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.idx = 0;</span><span class="s3">\n        </span><span class="s1">this.input = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.groupIdx = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">saveState() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">idx: this.idx,</span><span class="s3">\n            </span><span class="s1">input: this.input,</span><span class="s3">\n            </span><span class="s1">groupIdx: this.groupIdx,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">restoreState(newState) {</span><span class="s3">\n        </span><span class="s1">this.idx = newState.idx;</span><span class="s3">\n        </span><span class="s1">this.input = newState.input;</span><span class="s3">\n        </span><span class="s1">this.groupIdx = newState.groupIdx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pattern(input) {</span><span class="s3">\n        </span><span class="s1">// parser state</span><span class="s3">\n        </span><span class="s1">this.idx = 0;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.groupIdx = 0;</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const value = this.disjunction();</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const flags = {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Flags</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">loc: { begin: this.idx, end: input.length },</span><span class="s3">\n            </span><span class="s1">global: false,</span><span class="s3">\n            </span><span class="s1">ignoreCase: false,</span><span class="s3">\n            </span><span class="s1">multiLine: false,</span><span class="s3">\n            </span><span class="s1">unicode: false,</span><span class="s3">\n            </span><span class="s1">sticky: false,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">while (this.isRegExpFlag()) {</span><span class="s3">\n            </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">addFlag(flags, </span><span class="s3">\&quot;</span><span class="s1">global</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">addFlag(flags, </span><span class="s3">\&quot;</span><span class="s1">ignoreCase</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">m</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">addFlag(flags, </span><span class="s3">\&quot;</span><span class="s1">multiLine</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">addFlag(flags, </span><span class="s3">\&quot;</span><span class="s1">unicode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">addFlag(flags, </span><span class="s3">\&quot;</span><span class="s1">sticky</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.idx !== this.input.length) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Redundant input: </span><span class="s3">\&quot; </span><span class="s1">+ this.input.substring(this.idx));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">flags: flags,</span><span class="s3">\n            </span><span class="s1">value: value,</span><span class="s3">\n            </span><span class="s1">loc: this.loc(0),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">disjunction() {</span><span class="s3">\n        </span><span class="s1">const alts = [];</span><span class="s3">\n        </span><span class="s1">const begin = this.idx;</span><span class="s3">\n        </span><span class="s1">alts.push(this.alternative());</span><span class="s3">\n        </span><span class="s1">while (this.peekChar() === </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">alts.push(this.alternative());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Disjunction</span><span class="s3">\&quot;</span><span class="s1">, value: alts, loc: this.loc(begin) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">alternative() {</span><span class="s3">\n        </span><span class="s1">const terms = [];</span><span class="s3">\n        </span><span class="s1">const begin = this.idx;</span><span class="s3">\n        </span><span class="s1">while (this.isTerm()) {</span><span class="s3">\n            </span><span class="s1">terms.push(this.term());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Alternative</span><span class="s3">\&quot;</span><span class="s1">, value: terms, loc: this.loc(begin) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">term() {</span><span class="s3">\n        </span><span class="s1">if (this.isAssertion()) {</span><span class="s3">\n            </span><span class="s1">return this.assertion();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.atom();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assertion() {</span><span class="s3">\n        </span><span class="s1">const begin = this.idx;</span><span class="s3">\n        </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">StartAnchor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    </span><span class="s1">loc: this.loc(begin),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">EndAnchor</span><span class="s3">\&quot;</span><span class="s1">, loc: this.loc(begin) };</span><span class="s3">\n            </span><span class="s1">// '</span><span class="s3">\\</span><span class="s1">b' or '</span><span class="s3">\\</span><span class="s1">B'</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">return {</span><span class="s3">\n                            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">WordBoundary</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                            </span><span class="s1">loc: this.loc(begin),</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">return {</span><span class="s3">\n                            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NonWordBoundary</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                            </span><span class="s1">loc: this.loc(begin),</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// istanbul ignore next</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Invalid Assertion Escape</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">// '(?=' or '(?!'</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">let type;</span><span class="s3">\n                </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">Lookahead</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">type = </span><span class="s3">\&quot;</span><span class="s1">NegativeLookahead</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">ASSERT_EXISTS(type);</span><span class="s3">\n                </span><span class="s1">const disjunction = this.disjunction();</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">type: type,</span><span class="s3">\n                    </span><span class="s1">value: disjunction,</span><span class="s3">\n                    </span><span class="s1">loc: this.loc(begin),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore next</span><span class="s3">\n        </span><span class="s1">return ASSERT_NEVER_REACH_HERE();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">quantifier(isBacktracking = false) {</span><span class="s3">\n        </span><span class="s1">let range = undefined;</span><span class="s3">\n        </span><span class="s1">const begin = this.idx;</span><span class="s3">\n        </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">range = {</span><span class="s3">\n                    </span><span class="s1">atLeast: 0,</span><span class="s3">\n                    </span><span class="s1">atMost: Infinity,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">range = {</span><span class="s3">\n                    </span><span class="s1">atLeast: 1,</span><span class="s3">\n                    </span><span class="s1">atMost: Infinity,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">range = {</span><span class="s3">\n                    </span><span class="s1">atLeast: 0,</span><span class="s3">\n                    </span><span class="s1">atMost: 1,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">const atLeast = this.integerIncludingZero();</span><span class="s3">\n                </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">range = {</span><span class="s3">\n                            </span><span class="s1">atLeast: atLeast,</span><span class="s3">\n                            </span><span class="s1">atMost: atLeast,</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">let atMost;</span><span class="s3">\n                        </span><span class="s1">if (this.isDigit()) {</span><span class="s3">\n                            </span><span class="s1">atMost = this.integerIncludingZero();</span><span class="s3">\n                            </span><span class="s1">range = {</span><span class="s3">\n                                </span><span class="s1">atLeast: atLeast,</span><span class="s3">\n                                </span><span class="s1">atMost: atMost,</span><span class="s3">\n                            </span><span class="s1">};</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">range = {</span><span class="s3">\n                                </span><span class="s1">atLeast: atLeast,</span><span class="s3">\n                                </span><span class="s1">atMost: Infinity,</span><span class="s3">\n                            </span><span class="s1">};</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// throwing exceptions from </span><span class="s3">\&quot;</span><span class="s1">ASSERT_EXISTS</span><span class="s3">\&quot; </span><span class="s1">during backtracking</span><span class="s3">\n                </span><span class="s1">// causes severe performance degradations</span><span class="s3">\n                </span><span class="s1">if (isBacktracking === true &amp;&amp; range === undefined) {</span><span class="s3">\n                    </span><span class="s1">return undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">ASSERT_EXISTS(range);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// throwing exceptions from </span><span class="s3">\&quot;</span><span class="s1">ASSERT_EXISTS</span><span class="s3">\&quot; </span><span class="s1">during backtracking</span><span class="s3">\n        </span><span class="s1">// causes severe performance degradations</span><span class="s3">\n        </span><span class="s1">if (isBacktracking === true &amp;&amp; range === undefined) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore else</span><span class="s3">\n        </span><span class="s1">if (ASSERT_EXISTS(range)) {</span><span class="s3">\n            </span><span class="s1">if (this.peekChar(0) === </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">range.greedy = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">range.greedy = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">range.type = </span><span class="s3">\&quot;</span><span class="s1">Quantifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">range.loc = this.loc(begin);</span><span class="s3">\n            </span><span class="s1">return range;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atom() {</span><span class="s3">\n        </span><span class="s1">let atom;</span><span class="s3">\n        </span><span class="s1">const begin = this.idx;</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">atom = this.dotAll();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">atom = this.atomEscape();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">atom = this.characterClass();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">atom = this.group();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (atom === undefined &amp;&amp; this.isPatternCharacter()) {</span><span class="s3">\n            </span><span class="s1">atom = this.patternCharacter();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore else</span><span class="s3">\n        </span><span class="s1">if (ASSERT_EXISTS(atom)) {</span><span class="s3">\n            </span><span class="s1">atom.loc = this.loc(begin);</span><span class="s3">\n            </span><span class="s1">if (this.isQuantifier()) {</span><span class="s3">\n                </span><span class="s1">atom.quantifier = this.quantifier();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return atom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore next</span><span class="s3">\n        </span><span class="s1">return ASSERT_NEVER_REACH_HERE();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dotAll() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">complement: true,</span><span class="s3">\n            </span><span class="s1">value: [cc(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">), cc(</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">), cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">), cc(</span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">)],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atomEscape() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">2</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">3</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">4</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">5</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">6</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">7</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">8</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">9</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.decimalEscapeAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">S</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">W</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.characterClassEscape();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.controlEscapeAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.controlLetterEscapeAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.nulCharacterAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.hexEscapeSequenceAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.regExpUnicodeEscapeSequenceAtom();</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return this.identityEscapeAtom();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decimalEscapeAtom() {</span><span class="s3">\n        </span><span class="s1">const value = this.positiveInteger();</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">GroupBackReference</span><span class="s3">\&quot;</span><span class="s1">, value: value };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">characterClassEscape() {</span><span class="s3">\n        </span><span class="s1">let set;</span><span class="s3">\n        </span><span class="s1">let complement = false;</span><span class="s3">\n        </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = digitsCharCodes;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = digitsCharCodes;</span><span class="s3">\n                </span><span class="s1">complement = true;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = whitespaceCodes;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">S</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = whitespaceCodes;</span><span class="s3">\n                </span><span class="s1">complement = true;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = wordCharCodes;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">W</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">set = wordCharCodes;</span><span class="s3">\n                </span><span class="s1">complement = true;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore else</span><span class="s3">\n        </span><span class="s1">if (ASSERT_EXISTS(set)) {</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">, value: set, complement: complement };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore next</span><span class="s3">\n        </span><span class="s1">return ASSERT_NEVER_REACH_HERE();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">controlEscapeAtom() {</span><span class="s3">\n        </span><span class="s1">let escapeCode;</span><span class="s3">\n        </span><span class="s1">switch (this.popChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">escapeCode = cc(</span><span class="s3">\&quot;\\</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">escapeCode = cc(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">escapeCode = cc(</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">escapeCode = cc(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">escapeCode = cc(</span><span class="s3">\&quot;\\</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore else</span><span class="s3">\n        </span><span class="s1">if (ASSERT_EXISTS(escapeCode)) {</span><span class="s3">\n            </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: escapeCode };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// istanbul ignore next</span><span class="s3">\n        </span><span class="s1">return ASSERT_NEVER_REACH_HERE();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">controlLetterEscapeAtom() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const letter = this.popChar();</span><span class="s3">\n        </span><span class="s1">if (/[a-zA-Z]/.test(letter) === false) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Invalid </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const letterCode = letter.toUpperCase().charCodeAt(0) - 64;</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: letterCode };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nulCharacterAtom() {</span><span class="s3">\n        </span><span class="s1">// TODO implement '[lookahead  DecimalDigit]'</span><span class="s3">\n        </span><span class="s1">// TODO: for the deprecated octal escape sequence</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: cc(</span><span class="s3">\&quot;\\</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hexEscapeSequenceAtom() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return this.parseHexDigits(2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">regExpUnicodeEscapeSequenceAtom() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return this.parseHexDigits(4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">identityEscapeAtom() {</span><span class="s3">\n        </span><span class="s1">// TODO: implement </span><span class="s3">\&quot;</span><span class="s1">SourceCharacter but not UnicodeIDContinue</span><span class="s3">\&quot;\n        </span><span class="s1">// // http://unicode.org/reports/tr31/#Specific_Character_Adjustments</span><span class="s3">\n        </span><span class="s1">const escapedChar = this.popChar();</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: cc(escapedChar) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">classPatternCharacterAtom() {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">TBD</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">const nextChar = this.popChar();</span><span class="s3">\n                </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: cc(nextChar) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">characterClass() {</span><span class="s3">\n        </span><span class="s1">const set = [];</span><span class="s3">\n        </span><span class="s1">let complement = false;</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (this.peekChar(0) === </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">complement = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (this.isClassAtom()) {</span><span class="s3">\n            </span><span class="s1">const from = this.classAtom();</span><span class="s3">\n            </span><span class="s1">const isFromSingleChar = from.type === </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (isCharacter(from) &amp;&amp; this.isRangeDash()) {</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">const to = this.classAtom();</span><span class="s3">\n                </span><span class="s1">const isToSingleChar = to.type === </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">// a range can only be used when both sides are single characters</span><span class="s3">\n                </span><span class="s1">if (isCharacter(to)) {</span><span class="s3">\n                    </span><span class="s1">if (to.value &lt; from.value) {</span><span class="s3">\n                        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Range out of order in character class</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">set.push({ from: from.value, to: to.value });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// literal dash</span><span class="s3">\n                    </span><span class="s1">insertToSet(from.value, set);</span><span class="s3">\n                    </span><span class="s1">set.push(cc(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                    </span><span class="s1">insertToSet(to.value, set);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">insertToSet(from.value, set);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">, complement: complement, value: set };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">classAtom() {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">TBD</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.classEscape();</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return this.classPatternCharacterAtom();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">classEscape() {</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">// Matches a backspace.</span><span class="s3">\n            </span><span class="s1">// (Not to be confused with </span><span class="s3">\\</span><span class="s1">b word boundary outside characterClass)</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: cc(</span><span class="s3">\&quot;\\</span><span class="s1">u0008</span><span class="s3">\&quot;</span><span class="s1">) };</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">S</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">w</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">W</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.characterClassEscape();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.controlEscapeAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.controlLetterEscapeAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.nulCharacterAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.hexEscapeSequenceAtom();</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return this.regExpUnicodeEscapeSequenceAtom();</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return this.identityEscapeAtom();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">group() {</span><span class="s3">\n        </span><span class="s1">let capturing = true;</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar(0)) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">capturing = false;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">this.groupIdx++;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const value = this.disjunction();</span><span class="s3">\n        </span><span class="s1">this.consumeChar(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const groupAst = {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">capturing: capturing,</span><span class="s3">\n            </span><span class="s1">value: value,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (capturing) {</span><span class="s3">\n            </span><span class="s1">groupAst[</span><span class="s3">\&quot;</span><span class="s1">idx</span><span class="s3">\&quot;</span><span class="s1">] = this.groupIdx;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return groupAst;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">positiveInteger() {</span><span class="s3">\n        </span><span class="s1">let number = this.popChar();</span><span class="s3">\n        </span><span class="s1">// istanbul ignore next - can't ever get here due to previous lookahead checks</span><span class="s3">\n        </span><span class="s1">// still implementing this error checking in case this ever changes.</span><span class="s3">\n        </span><span class="s1">if (decimalPatternNoZero.test(number) === false) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Expecting a positive integer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (decimalPattern.test(this.peekChar(0))) {</span><span class="s3">\n            </span><span class="s1">number += this.popChar();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return parseInt(number, 10);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">integerIncludingZero() {</span><span class="s3">\n        </span><span class="s1">let number = this.popChar();</span><span class="s3">\n        </span><span class="s1">if (decimalPattern.test(number) === false) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Expecting an integer</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (decimalPattern.test(this.peekChar(0))) {</span><span class="s3">\n            </span><span class="s1">number += this.popChar();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return parseInt(number, 10);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">patternCharacter() {</span><span class="s3">\n        </span><span class="s1">const nextChar = this.popChar();</span><span class="s3">\n        </span><span class="s1">switch (nextChar) {</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">// istanbul ignore next</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">// istanbul ignore next</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">TBD</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: cc(nextChar) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isRegExpFlag() {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar(0)) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">m</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isRangeDash() {</span><span class="s3">\n        </span><span class="s1">return this.peekChar() === </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.isClassAtom(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isDigit() {</span><span class="s3">\n        </span><span class="s1">return decimalPattern.test(this.peekChar(0));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isClassAtom(howMuch = 0) {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar(howMuch)) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isTerm() {</span><span class="s3">\n        </span><span class="s1">return this.isAtom() || this.isAssertion();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isAtom() {</span><span class="s3">\n        </span><span class="s1">if (this.isPatternCharacter()) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar(0)) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">: // atomEscape</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">: // characterClass</span><span class="s3">\n            </span><span class="s1">// TODO: isAtom must be called before isAssertion - disambiguate</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">: // group</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isAssertion() {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar(0)) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">// '</span><span class="s3">\\</span><span class="s1">b' or '</span><span class="s3">\\</span><span class="s1">B'</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">switch (this.peekChar(1)) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                    </span><span class="s1">default:</span><span class="s3">\n                        </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// '(?=' or '(?!'</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return (this.peekChar(1) === </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(this.peekChar(2) === </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">|| this.peekChar(2) === </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isQuantifier() {</span><span class="s3">\n        </span><span class="s1">const prevState = this.saveState();</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return this.quantifier(true) !== undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.restoreState(prevState);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isPatternCharacter() {</span><span class="s3">\n        </span><span class="s1">switch (this.peekChar()) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2028</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;\\</span><span class="s1">u2029</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parseHexDigits(howMany) {</span><span class="s3">\n        </span><span class="s1">let hexString = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; howMany; i++) {</span><span class="s3">\n            </span><span class="s1">const hexChar = this.popChar();</span><span class="s3">\n            </span><span class="s1">if (hexDigitPattern.test(hexChar) === false) {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Expecting a HexDecimal digits</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">hexString += hexChar;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const charCode = parseInt(hexString, 16);</span><span class="s3">\n        </span><span class="s1">return { type: </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">, value: charCode };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">peekChar(howMuch = 0) {</span><span class="s3">\n        </span><span class="s1">return this.input[this.idx + howMuch];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">popChar() {</span><span class="s3">\n        </span><span class="s1">const nextChar = this.peekChar(0);</span><span class="s3">\n        </span><span class="s1">this.consumeChar(undefined);</span><span class="s3">\n        </span><span class="s1">return nextChar;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeChar(char) {</span><span class="s3">\n        </span><span class="s1">if (char !== undefined &amp;&amp; this.input[this.idx] !== char) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Expected: '</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">char +</span><span class="s3">\n                \&quot;</span><span class="s1">' but found: '</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">this.input[this.idx] +</span><span class="s3">\n                \&quot;</span><span class="s1">' at offset: </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">this.idx);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.idx &gt;= this.input.length) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Unexpected end of input</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.idx++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">loc(begin) {</span><span class="s3">\n        </span><span class="s1">return { begin: begin, end: this.idx };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=regexp-parser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export class BaseRegExpVisitor {</span><span class="s3">\n    </span><span class="s1">visitChildren(node) {</span><span class="s3">\n        </span><span class="s1">for (const key in node) {</span><span class="s3">\n            </span><span class="s1">const child = node[key];</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n            </span><span class="s1">if (node.hasOwnProperty(key)) {</span><span class="s3">\n                </span><span class="s1">if (child.type !== undefined) {</span><span class="s3">\n                    </span><span class="s1">this.visit(child);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (Array.isArray(child)) {</span><span class="s3">\n                    </span><span class="s1">child.forEach((subChild) =&gt; {</span><span class="s3">\n                        </span><span class="s1">this.visit(subChild);</span><span class="s3">\n                    </span><span class="s1">}, this);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visit(node) {</span><span class="s3">\n        </span><span class="s1">switch (node.type) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Pattern</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitPattern(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Flags</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitFlags(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Disjunction</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitDisjunction(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Alternative</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitAlternative(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">StartAnchor</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitStartAnchor(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">EndAnchor</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitEndAnchor(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WordBoundary</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitWordBoundary(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NonWordBoundary</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitNonWordBoundary(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Lookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitLookahead(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NegativeLookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitNegativeLookahead(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitCharacter(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitSet(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitGroup(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">GroupBackReference</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitGroupBackReference(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Quantifier</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitQuantifier(node);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.visitChildren(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitPattern(node) { }</span><span class="s3">\n    </span><span class="s1">visitFlags(node) { }</span><span class="s3">\n    </span><span class="s1">visitDisjunction(node) { }</span><span class="s3">\n    </span><span class="s1">visitAlternative(node) { }</span><span class="s3">\n    </span><span class="s1">// Assertion</span><span class="s3">\n    </span><span class="s1">visitStartAnchor(node) { }</span><span class="s3">\n    </span><span class="s1">visitEndAnchor(node) { }</span><span class="s3">\n    </span><span class="s1">visitWordBoundary(node) { }</span><span class="s3">\n    </span><span class="s1">visitNonWordBoundary(node) { }</span><span class="s3">\n    </span><span class="s1">visitLookahead(node) { }</span><span class="s3">\n    </span><span class="s1">visitNegativeLookahead(node) { }</span><span class="s3">\n    </span><span class="s1">// atoms</span><span class="s3">\n    </span><span class="s1">visitCharacter(node) { }</span><span class="s3">\n    </span><span class="s1">visitSet(node) { }</span><span class="s3">\n    </span><span class="s1">visitGroup(node) { }</span><span class="s3">\n    </span><span class="s1">visitGroupBackReference(node) { }</span><span class="s3">\n    </span><span class="s1">visitQuantifier(node) { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=base-regexp-visitor.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export { RegExpParser } from </span><span class="s3">\&quot;</span><span class="s1">./regexp-parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { BaseRegExpVisitor } from </span><span class="s3">\&quot;</span><span class="s1">./base-regexp-visitor.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=api.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">GitGraphGeneratedModule,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/gitGraph/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">inject,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/gitGraph/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var GitGraphTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">GitGraphTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/gitGraph/module.ts</span><span class="s3">\n</span><span class="s1">var GitGraphModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new GitGraphTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new CommonValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createGitGraphServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const GitGraph = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">GitGraphGeneratedModule,</span><span class="s3">\n    </span><span class="s1">GitGraphModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(GitGraph);</span><span class="s3">\n  </span><span class="s1">return { shared, GitGraph };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createGitGraphServices, </span><span class="s3">\&quot;</span><span class="s1">createGitGraphServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">GitGraphModule,</span><span class="s3">\n  </span><span class="s1">createGitGraphServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">RadarGeneratedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/radar/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">inject</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/radar/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var RadarTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">RadarTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">radar-beta</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/radar/module.ts</span><span class="s3">\n</span><span class="s1">var RadarModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new RadarTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new CommonValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createRadarServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const Radar = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">RadarGeneratedModule,</span><span class="s3">\n    </span><span class="s1">RadarModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(Radar);</span><span class="s3">\n  </span><span class="s1">return { shared, Radar };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createRadarServices, </span><span class="s3">\&quot;</span><span class="s1">createRadarServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">RadarModule,</span><span class="s3">\n  </span><span class="s1">createRadarServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { createDefaultCoreModule, createDefaultSharedCoreModule } from '../default-module.js';</span><span class="s3">\n</span><span class="s1">import { inject } from '../dependency-injection.js';</span><span class="s3">\n</span><span class="s1">import * as ast from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { EmptyFileSystem } from '../workspace/file-system-provider.js';</span><span class="s3">\n</span><span class="s1">import { URI } from './uri-utils.js';</span><span class="s3">\n</span><span class="s1">const minimalGrammarModule = {</span><span class="s3">\n    </span><span class="s1">Grammar: () =&gt; undefined,</span><span class="s3">\n    </span><span class="s1">LanguageMetaData: () =&gt; ({</span><span class="s3">\n        </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n        </span><span class="s1">fileExtensions: ['.langium'],</span><span class="s3">\n        </span><span class="s1">languageId: 'langium'</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const minimalSharedGrammarModule = {</span><span class="s3">\n    </span><span class="s1">AstReflection: () =&gt; new ast.LangiumGrammarAstReflection()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createMinimalGrammarServices() {</span><span class="s3">\n    </span><span class="s1">const shared = inject(createDefaultSharedCoreModule(EmptyFileSystem), minimalSharedGrammarModule);</span><span class="s3">\n    </span><span class="s1">const grammar = inject(createDefaultCoreModule({ shared }), minimalGrammarModule);</span><span class="s3">\n    </span><span class="s1">shared.ServiceRegistry.register(grammar);</span><span class="s3">\n    </span><span class="s1">return grammar;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Load a Langium grammar for your language from a JSON string. This is used by several services,</span><span class="s3">\n </span><span class="s1">* most notably the parser builder which interprets the grammar to create a parser.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function loadGrammarFromJson(json) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const services = createMinimalGrammarServices();</span><span class="s3">\n    </span><span class="s1">const astNode = services.serializer.JsonSerializer.deserialize(json);</span><span class="s3">\n    </span><span class="s1">services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${(_a = astNode.name) !== null &amp;&amp; _a !== void 0 ? _a : 'grammar'}.langium`));</span><span class="s3">\n    </span><span class="s1">return astNode;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=grammar-loader.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;var __defProp = Object.defineProperty;</span><span class="s3">\n</span><span class="s1">var __name = (target, value) =&gt; __defProp(target, </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">, { value, configurable: true });</span><span class="s3">\n\n</span><span class="s1">// src/language/generated/ast.ts</span><span class="s3">\n</span><span class="s1">import { AbstractAstReflection } from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Statement = </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Architecture = </span><span class="s3">\&quot;</span><span class="s1">Architecture</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isArchitecture(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Architecture);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isArchitecture, </span><span class="s3">\&quot;</span><span class="s1">isArchitecture</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Axis = </span><span class="s3">\&quot;</span><span class="s1">Axis</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Branch = </span><span class="s3">\&quot;</span><span class="s1">Branch</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isBranch(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Branch);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isBranch, </span><span class="s3">\&quot;</span><span class="s1">isBranch</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Checkout = </span><span class="s3">\&quot;</span><span class="s1">Checkout</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var CherryPicking = </span><span class="s3">\&quot;</span><span class="s1">CherryPicking</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Commit = </span><span class="s3">\&quot;</span><span class="s1">Commit</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isCommit(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Commit);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isCommit, </span><span class="s3">\&quot;</span><span class="s1">isCommit</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Common = </span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isCommon(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Common);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isCommon, </span><span class="s3">\&quot;</span><span class="s1">isCommon</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Curve = </span><span class="s3">\&quot;</span><span class="s1">Curve</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Edge = </span><span class="s3">\&quot;</span><span class="s1">Edge</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Entry = </span><span class="s3">\&quot;</span><span class="s1">Entry</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var GitGraph = </span><span class="s3">\&quot;</span><span class="s1">GitGraph</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isGitGraph(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, GitGraph);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isGitGraph, </span><span class="s3">\&quot;</span><span class="s1">isGitGraph</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Group = </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Info = </span><span class="s3">\&quot;</span><span class="s1">Info</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isInfo(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Info);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isInfo, </span><span class="s3">\&quot;</span><span class="s1">isInfo</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Junction = </span><span class="s3">\&quot;</span><span class="s1">Junction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Merge = </span><span class="s3">\&quot;</span><span class="s1">Merge</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isMerge(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Merge);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isMerge, </span><span class="s3">\&quot;</span><span class="s1">isMerge</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Option = </span><span class="s3">\&quot;</span><span class="s1">Option</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Packet = </span><span class="s3">\&quot;</span><span class="s1">Packet</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isPacket(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Packet);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isPacket, </span><span class="s3">\&quot;</span><span class="s1">isPacket</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var PacketBlock = </span><span class="s3">\&quot;</span><span class="s1">PacketBlock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isPacketBlock(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, PacketBlock);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isPacketBlock, </span><span class="s3">\&quot;</span><span class="s1">isPacketBlock</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Pie = </span><span class="s3">\&quot;</span><span class="s1">Pie</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isPie(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, Pie);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isPie, </span><span class="s3">\&quot;</span><span class="s1">isPie</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var PieSection = </span><span class="s3">\&quot;</span><span class="s1">PieSection</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function isPieSection(item) {</span><span class="s3">\n  </span><span class="s1">return reflection.isInstance(item, PieSection);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(isPieSection, </span><span class="s3">\&quot;</span><span class="s1">isPieSection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Radar = </span><span class="s3">\&quot;</span><span class="s1">Radar</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Service = </span><span class="s3">\&quot;</span><span class="s1">Service</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var Direction = </span><span class="s3">\&quot;</span><span class="s1">Direction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var MermaidAstReflection = class extends AbstractAstReflection {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">MermaidAstReflection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getAllTypes() {</span><span class="s3">\n    </span><span class="s1">return [Architecture, Axis, Branch, Checkout, CherryPicking, Commit, Common, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Junction, Merge, Option, Packet, PacketBlock, Pie, PieSection, Radar, Service, Statement];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">computeIsSubtype(subtype, supertype) {</span><span class="s3">\n    </span><span class="s1">switch (subtype) {</span><span class="s3">\n      </span><span class="s1">case Branch:</span><span class="s3">\n      </span><span class="s1">case Checkout:</span><span class="s3">\n      </span><span class="s1">case CherryPicking:</span><span class="s3">\n      </span><span class="s1">case Commit:</span><span class="s3">\n      </span><span class="s1">case Merge: {</span><span class="s3">\n        </span><span class="s1">return this.isSubtype(Statement, supertype);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Direction: {</span><span class="s3">\n        </span><span class="s1">return this.isSubtype(GitGraph, supertype);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getReferenceType(refInfo) {</span><span class="s3">\n    </span><span class="s1">const referenceId = `${refInfo.container.$type}:${refInfo.property}`;</span><span class="s3">\n    </span><span class="s1">switch (referenceId) {</span><span class="s3">\n      </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Entry:axis</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">return Axis;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">throw new Error(`${referenceId} is not a valid reference id.`);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">getTypeMetaData(type) {</span><span class="s3">\n    </span><span class="s1">switch (type) {</span><span class="s3">\n      </span><span class="s1">case Architecture: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Architecture,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">edges</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">groups</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">junctions</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">services</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Axis: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Axis,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Branch: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Branch,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">order</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Checkout: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Checkout,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">branch</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case CherryPicking: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: CherryPicking,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">parent</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] }</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Commit: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Commit,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Common: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Common,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Curve: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Curve,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">entries</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Edge: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Edge,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">lhsDir</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">lhsGroup</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">lhsId</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">lhsInto</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">rhsDir</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">rhsGroup</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">rhsId</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">rhsInto</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Entry: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Entry,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">axis</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case GitGraph: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: GitGraph,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">statements</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Group: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Group,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">icon</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Info: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Info,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Junction: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Junction,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Merge: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Merge,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">branch</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Option: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Option,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false }</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Packet: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Packet,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">blocks</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case PacketBlock: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: PacketBlock,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Pie: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Pie,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">showData</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: false },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case PieSection: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: PieSection,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Radar: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Radar,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">axes</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">curves</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Service: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Service,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">icon</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">iconText</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">case Direction: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: Direction,</span><span class="s3">\n          </span><span class="s1">properties: [</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">dir</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">statements</span><span class="s3">\&quot;</span><span class="s1">, defaultValue: [] },</span><span class="s3">\n            </span><span class="s1">{ name: </span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">]</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default: {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">name: type,</span><span class="s3">\n          </span><span class="s1">properties: []</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var reflection = new MermaidAstReflection();</span><span class="s3">\n\n</span><span class="s1">// src/language/generated/grammar.ts</span><span class="s3">\n</span><span class="s1">import { loadGrammarFromJson } from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var loadedInfoGrammar;</span><span class="s3">\n</span><span class="s1">var InfoGrammar = /* @__PURE__ */ __name(() =&gt; loadedInfoGrammar ?? (loadedInfoGrammar = loadGrammarFromJson('{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Info</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Info</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">info</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">showInfo</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}')), </span><span class="s3">\&quot;</span><span class="s1">InfoGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var loadedPacketGrammar;</span><span class="s3">\n</span><span class="s1">var PacketGrammar = /* @__PURE__ */ __name(() =&gt; loadedPacketGrammar ?? (loadedPacketGrammar = loadGrammarFromJson(`{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Packet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Packet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">packet-beta</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">blocks</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">blocks</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">PacketBlock</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">INT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/0|[1-9][0-9]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">STRING</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\&quot;</span><span class="s1">[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]*</span><span class="s3">\\\\\&quot;</span><span class="s1">|'[^']*'/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@7</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@8</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@9</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}`)), </span><span class="s3">\&quot;</span><span class="s1">PacketGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var loadedPieGrammar;</span><span class="s3">\n</span><span class="s1">var PieGrammar = /* @__PURE__ */ __name(() =&gt; loadedPieGrammar ?? (loadedPieGrammar = loadGrammarFromJson('{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Pie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Pie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">pie</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">showData</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">showData</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">sections</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">PieSection</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">PIE_SECTION_LABEL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\&quot;</span><span class="s1">[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]+</span><span class="s3">\\\\\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">PIE_SECTION_VALUE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/(0|[1-9][0-9]*)(</span><span class="s3">\\\\\\\\</span><span class="s1">.[0-9]+)?/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@7</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@8</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@9</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}')), </span><span class="s3">\&quot;</span><span class="s1">PieGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var loadedArchitectureGrammar;</span><span class="s3">\n</span><span class="s1">var ArchitectureGrammar = /* @__PURE__ */ __name(() =&gt; loadedArchitectureGrammar ?? (loadedArchitectureGrammar = loadGrammarFromJson('{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Architecture</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Architecture</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">architecture-beta</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@16</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">groups</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">services</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@6</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">junctions</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@7</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">edges</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@8</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">LeftPort</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lhsDir</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@9</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RightPort</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">rhsDir</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@9</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Arrow</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lhsInto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@15</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">}]}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">rhsInto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@15</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">icon</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Service</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">service</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">iconText</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@11</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">icon</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Junction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Edge</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lhsId</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">lhsGroup</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@14</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">rhsId</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@10</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">rhsGroup</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@14</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARROW_DIRECTION</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalAlternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalAlternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalAlternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot;</span><span class="s1">}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">}}]},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARCH_ID</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">w]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARCH_TEXT_ICON</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">(</span><span class="s3">\\\\\&quot;</span><span class="s1">[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]+</span><span class="s3">\\\\\&quot;\\\\\\\\</span><span class="s1">)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARCH_ICON</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">([</span><span class="s3">\\\\\\\\</span><span class="s1">w-:]+</span><span class="s3">\\\\\\\\</span><span class="s1">)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARCH_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">[[</span><span class="s3">\\\\\\\\</span><span class="s1">w ]+</span><span class="s3">\\\\\\\\</span><span class="s1">]/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARROW_GROUP</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">{group</span><span class="s3">\\\\\\\\</span><span class="s1">}/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ARROW_INTO</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/&lt;|&gt;/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@19</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@21</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}')), </span><span class="s3">\&quot;</span><span class="s1">ArchitectureGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var loadedGitGraphGrammar;</span><span class="s3">\n</span><span class="s1">var GitGraphGrammar = /* @__PURE__ */ __name(() =&gt; loadedGitGraphGrammar ?? (loadedGitGraphGrammar = loadGrammarFromJson(`{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">GitGraph</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">GitGraph</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">gitGraph:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">}]}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@0</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">statements</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@11</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@14</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@15</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@16</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Direction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">dir</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">LR</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TB</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">BT</span><span class="s3">\&quot;</span><span class="s1">}]}},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Commit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">commit</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">msg:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">message</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tag:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">type:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NORMAL</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">REVERSE</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">HIGHLIGHT</span><span class="s3">\&quot;</span><span class="s1">}]}}]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Branch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">branch</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@19</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">order:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">order</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Merge</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">merge</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">branch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@19</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tag:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">type:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NORMAL</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">REVERSE</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">HIGHLIGHT</span><span class="s3">\&quot;</span><span class="s1">}]}}]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Checkout</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">checkout</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">branch</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@19</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CherryPicking</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">cherry-pick</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tag:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">tags</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">parent:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">parent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">INT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[0-9]+(?=</span><span class="s3">\\\\\\\\</span><span class="s1">s)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ID</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">w([-</span><span class="s3">\\\\\\\\</span><span class="s1">./</span><span class="s3">\\\\\\\\</span><span class="s1">w]*[-</span><span class="s3">\\\\\\\\</span><span class="s1">w])?/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">STRING</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\&quot;</span><span class="s1">[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]*</span><span class="s3">\\\\\&quot;</span><span class="s1">|'[^']*'/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}`)), </span><span class="s3">\&quot;</span><span class="s1">GitGraphGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var loadedRadarGrammar;</span><span class="s3">\n</span><span class="s1">var RadarGrammar = /* @__PURE__ */ __name(() =&gt; loadedRadarGrammar ?? (loadedRadarGrammar = loadGrammarFromJson(`{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isDeclared</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Radar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">interfaces</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Common</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">}}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Interface</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Entry</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">attributes</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">axis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReferenceType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">referenceType</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">typeRef</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">}}}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TypeAttribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SimpleType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">primitiveType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">isOptional</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">superTypes</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TitleAndAccessibilities</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accDescr</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@3</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">accTitle</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@4</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">title</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@5</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EOL</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">dataType</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">EndOfFile</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NEWLINE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_DESCR</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accDescr(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:([^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)|</span><span class="s3">\\\\\\\\</span><span class="s1">s*{([^}]*)})/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ACC_TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*accTitle[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*:(?:[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TITLE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*title(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*?(?=%%)|[</span><span class="s3">\\\\\\\\</span><span class="s1">t ][^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*|)/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">WHITESPACE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]+/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">YAML</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/---[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n(?:[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n)?---(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DIRECTIVE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%{[</span><span class="s3">\\\\\\\\</span><span class="s1">S</span><span class="s3">\\\\\\\\</span><span class="s1">s]*?}%%(?:</span><span class="s3">\\\\\\\\</span><span class="s1">r?</span><span class="s3">\\\\\\\\</span><span class="s1">n|(?!</span><span class="s3">\\\\\\\\</span><span class="s1">S))/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">SINGLE_LINE_COMMENT</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[</span><span class="s3">\\\\\\\\</span><span class="s1">t ]*%%[^</span><span class="s3">\\\\\\\\</span><span class="s1">n</span><span class="s3">\\\\\\\\</span><span class="s1">r]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Radar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">radar-beta</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">radar-beta:</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">radar-beta</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">}]}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@0</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">axis</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">axes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">axes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">curve</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">curves</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">curves</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@13</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">options</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@17</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Label</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@22</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Axis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@21</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@11</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Curve</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@21</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@11</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@14</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:true,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Entries</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">entries</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@16</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">entries</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@16</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">entries</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@15</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">entries</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">+=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@15</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@2</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">DetailedEntry</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">returnType</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/interfaces@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">axis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CrossReference</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@12</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@21</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]},</span><span class="s3">\&quot;</span><span class="s1">deprecatedSyntax</span><span class="s3">\&quot;</span><span class="s1">:false}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">cardinality</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NumberEntry</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">returnType</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/interfaces@1</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ParserRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Option</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Alternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">showLegend</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@19</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ticks</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">max</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">min</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@18</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">graticule</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Assignment</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">feature</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">terminal</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RuleCall</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">rule</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$ref</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">#/rules@20</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">:[]}}]}]},</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">entry</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">parameters</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">wildcard</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">NUMBER</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/(0|[1-9][0-9]*)(</span><span class="s3">\\\\\\\\</span><span class="s1">.[0-9]+)?/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">BOOLEAN</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalAlternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">}}]},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">GRATICULE</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalAlternatives</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">elements</span><span class="s3">\&quot;</span><span class="s1">:[{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">circle</span><span class="s3">\&quot;</span><span class="s1">}},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">CharacterRange</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">}}]},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ID</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">ReturnType</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/[a-zA-Z_][a-zA-Z0-9</span><span class="s3">\\\\\\\\</span><span class="s1">-_]*/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false},{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">TerminalRule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">STRING</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">:{</span><span class="s3">\&quot;</span><span class="s1">$type</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">RegexToken</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">regex</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\\\\\&quot;</span><span class="s1">[^</span><span class="s3">\\\\\&quot;</span><span class="s1">]*</span><span class="s3">\\\\\&quot;</span><span class="s1">|'[^']*'/</span><span class="s3">\&quot;</span><span class="s1">},</span><span class="s3">\&quot;</span><span class="s1">fragment</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">:false}],</span><span class="s3">\&quot;</span><span class="s1">definesHiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:false,</span><span class="s3">\&quot;</span><span class="s1">hiddenTokens</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">imports</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">types</span><span class="s3">\&quot;</span><span class="s1">:[],</span><span class="s3">\&quot;</span><span class="s1">usedGrammars</span><span class="s3">\&quot;</span><span class="s1">:[]}`)), </span><span class="s3">\&quot;</span><span class="s1">RadarGrammar</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/language/generated/module.ts</span><span class="s3">\n</span><span class="s1">var InfoLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">info</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var PacketLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">packet</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var PieLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">pie</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ArchitectureLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">architecture</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var GitGraphLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var RadarLanguageMetaData = {</span><span class="s3">\n  </span><span class="s1">languageId: </span><span class="s3">\&quot;</span><span class="s1">radar</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">fileExtensions: [</span><span class="s3">\&quot;</span><span class="s1">.mmd</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.mermaid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">caseInsensitive: false,</span><span class="s3">\n  </span><span class="s1">mode: </span><span class="s3">\&quot;</span><span class="s1">production</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var MermaidGeneratedSharedModule = {</span><span class="s3">\n  </span><span class="s1">AstReflection: /* @__PURE__ */ __name(() =&gt; new MermaidAstReflection(), </span><span class="s3">\&quot;</span><span class="s1">AstReflection</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var InfoGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; InfoGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; InfoLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var PacketGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; PacketGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; PacketLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var PieGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; PieGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; PieLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ArchitectureGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; ArchitectureGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; ArchitectureLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var GitGraphGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; GitGraphGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; GitGraphLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var RadarGeneratedModule = {</span><span class="s3">\n  </span><span class="s1">Grammar: /* @__PURE__ */ __name(() =&gt; RadarGrammar(), </span><span class="s3">\&quot;</span><span class="s1">Grammar</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">LanguageMetaData: /* @__PURE__ */ __name(() =&gt; RadarLanguageMetaData, </span><span class="s3">\&quot;</span><span class="s1">LanguageMetaData</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">parser: {}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/common/valueConverter.ts</span><span class="s3">\n</span><span class="s1">import { DefaultValueConverter } from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/common/matcher.ts</span><span class="s3">\n</span><span class="s1">var accessibilityDescrRegex = /accDescr(?:[</span><span class="s3">\\</span><span class="s1">t ]*:([^</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]*)|</span><span class="s3">\\</span><span class="s1">s*{([^}]*)})/;</span><span class="s3">\n</span><span class="s1">var accessibilityTitleRegex = /accTitle[</span><span class="s3">\\</span><span class="s1">t ]*:([^</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]*)/;</span><span class="s3">\n</span><span class="s1">var titleRegex = /title([</span><span class="s3">\\</span><span class="s1">t ][^</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]*|)/;</span><span class="s3">\n\n</span><span class="s1">// src/language/common/valueConverter.ts</span><span class="s3">\n</span><span class="s1">var rulesRegexes = {</span><span class="s3">\n  </span><span class="s1">ACC_DESCR: accessibilityDescrRegex,</span><span class="s3">\n  </span><span class="s1">ACC_TITLE: accessibilityTitleRegex,</span><span class="s3">\n  </span><span class="s1">TITLE: titleRegex</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var AbstractMermaidValueConverter = class extends DefaultValueConverter {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">AbstractMermaidValueConverter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">runConverter(rule, input, cstNode) {</span><span class="s3">\n    </span><span class="s1">let value = this.runCommonConverter(rule, input, cstNode);</span><span class="s3">\n    </span><span class="s1">if (value === void 0) {</span><span class="s3">\n      </span><span class="s1">value = this.runCustomConverter(rule, input, cstNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value === void 0) {</span><span class="s3">\n      </span><span class="s1">return super.runConverter(rule, input, cstNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">runCommonConverter(rule, input, _cstNode) {</span><span class="s3">\n    </span><span class="s1">const regex = rulesRegexes[rule.name];</span><span class="s3">\n    </span><span class="s1">if (regex === void 0) {</span><span class="s3">\n      </span><span class="s1">return void 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const match = regex.exec(input);</span><span class="s3">\n    </span><span class="s1">if (match === null) {</span><span class="s3">\n      </span><span class="s1">return void 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (match[1] !== void 0) {</span><span class="s3">\n      </span><span class="s1">return match[1].trim().replace(/[</span><span class="s3">\\</span><span class="s1">t ]{2,}/gm, </span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (match[2] !== void 0) {</span><span class="s3">\n      </span><span class="s1">return match[2].replace(/^</span><span class="s3">\\</span><span class="s1">s*/gm, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(/</span><span class="s3">\\</span><span class="s1">s+$/gm, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(/[</span><span class="s3">\\</span><span class="s1">t ]{2,}/gm, </span><span class="s3">\&quot; \&quot;</span><span class="s1">).replace(/[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]{2,}/gm, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var CommonValueConverter = class extends AbstractMermaidValueConverter {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">CommonValueConverter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">runCustomConverter(_rule, _input, _cstNode) {</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/common/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">import { DefaultTokenBuilder } from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var AbstractMermaidTokenBuilder = class extends DefaultTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">AbstractMermaidTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor(keywords) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">this.keywords = new Set(keywords);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">buildKeywordTokens(rules, terminalTokens, options) {</span><span class="s3">\n    </span><span class="s1">const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);</span><span class="s3">\n    </span><span class="s1">tokenTypes.forEach((tokenType) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (this.keywords.has(tokenType.name) &amp;&amp; tokenType.PATTERN !== void 0) {</span><span class="s3">\n        </span><span class="s1">tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + </span><span class="s3">\&quot;</span><span class="s1">(?:(?=%%)|(?!</span><span class="s3">\\\\</span><span class="s1">S))</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return tokenTypes;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">CommonTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">Statement,</span><span class="s3">\n  </span><span class="s1">Architecture,</span><span class="s3">\n  </span><span class="s1">isArchitecture,</span><span class="s3">\n  </span><span class="s1">Branch,</span><span class="s3">\n  </span><span class="s1">isBranch,</span><span class="s3">\n  </span><span class="s1">Commit,</span><span class="s3">\n  </span><span class="s1">isCommit,</span><span class="s3">\n  </span><span class="s1">isCommon,</span><span class="s3">\n  </span><span class="s1">GitGraph,</span><span class="s3">\n  </span><span class="s1">isGitGraph,</span><span class="s3">\n  </span><span class="s1">Info,</span><span class="s3">\n  </span><span class="s1">isInfo,</span><span class="s3">\n  </span><span class="s1">Merge,</span><span class="s3">\n  </span><span class="s1">isMerge,</span><span class="s3">\n  </span><span class="s1">Packet,</span><span class="s3">\n  </span><span class="s1">isPacket,</span><span class="s3">\n  </span><span class="s1">PacketBlock,</span><span class="s3">\n  </span><span class="s1">isPacketBlock,</span><span class="s3">\n  </span><span class="s1">Pie,</span><span class="s3">\n  </span><span class="s1">isPie,</span><span class="s3">\n  </span><span class="s1">PieSection,</span><span class="s3">\n  </span><span class="s1">isPieSection,</span><span class="s3">\n  </span><span class="s1">Radar,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">InfoGeneratedModule,</span><span class="s3">\n  </span><span class="s1">PacketGeneratedModule,</span><span class="s3">\n  </span><span class="s1">PieGeneratedModule,</span><span class="s3">\n  </span><span class="s1">ArchitectureGeneratedModule,</span><span class="s3">\n  </span><span class="s1">GitGraphGeneratedModule,</span><span class="s3">\n  </span><span class="s1">RadarGeneratedModule,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidValueConverter,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonTokenBuilder</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidValueConverter,</span><span class="s3">\n  </span><span class="s1">ArchitectureGeneratedModule,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/architecture/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">inject</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/architecture/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var ArchitectureTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">ArchitectureTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">architecture</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/architecture/valueConverter.ts</span><span class="s3">\n</span><span class="s1">var ArchitectureValueConverter = class extends AbstractMermaidValueConverter {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">ArchitectureValueConverter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">runCustomConverter(rule, input, _cstNode) {</span><span class="s3">\n    </span><span class="s1">if (rule.name === </span><span class="s3">\&quot;</span><span class="s1">ARCH_ICON</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return input.replace(/[()]/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).trim();</span><span class="s3">\n    </span><span class="s1">} else if (rule.name === </span><span class="s3">\&quot;</span><span class="s1">ARCH_TEXT_ICON</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return input.replace(/[</span><span class="s3">\&quot;</span><span class="s1">()]/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (rule.name === </span><span class="s3">\&quot;</span><span class="s1">ARCH_TITLE</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return input.replace(/[[</span><span class="s3">\\</span><span class="s1">]]/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).trim();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return void 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/architecture/module.ts</span><span class="s3">\n</span><span class="s1">var ArchitectureModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new ArchitectureTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new ArchitectureValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createArchitectureServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const Architecture = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">ArchitectureGeneratedModule,</span><span class="s3">\n    </span><span class="s1">ArchitectureModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(Architecture);</span><span class="s3">\n  </span><span class="s1">return { shared, Architecture };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createArchitectureServices, </span><span class="s3">\&quot;</span><span class="s1">createArchitectureServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">ArchitectureModule,</span><span class="s3">\n  </span><span class="s1">createArchitectureServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">InfoGeneratedModule,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/info/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">inject</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/info/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var InfoTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">InfoTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">info</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">showInfo</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/info/module.ts</span><span class="s3">\n</span><span class="s1">var InfoModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new InfoTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new CommonValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createInfoServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const Info = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">InfoGeneratedModule,</span><span class="s3">\n    </span><span class="s1">InfoModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(Info);</span><span class="s3">\n  </span><span class="s1">return { shared, Info };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createInfoServices, </span><span class="s3">\&quot;</span><span class="s1">createInfoServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">InfoModule,</span><span class="s3">\n  </span><span class="s1">createInfoServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidValueConverter,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">PieGeneratedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/pie/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">inject</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/pie/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var PieTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">PieTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">pie</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">showData</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/pie/valueConverter.ts</span><span class="s3">\n</span><span class="s1">var PieValueConverter = class extends AbstractMermaidValueConverter {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">PieValueConverter</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">runCustomConverter(rule, input, _cstNode) {</span><span class="s3">\n    </span><span class="s1">if (rule.name !== </span><span class="s3">\&quot;</span><span class="s1">PIE_SECTION_LABEL</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return void 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return input.replace(/</span><span class="s3">\&quot;</span><span class="s1">/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).trim();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/pie/module.ts</span><span class="s3">\n</span><span class="s1">var PieModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new PieTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new PieValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createPieServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const Pie = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">PieGeneratedModule,</span><span class="s3">\n    </span><span class="s1">PieModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(Pie);</span><span class="s3">\n  </span><span class="s1">return { shared, Pie };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createPieServices, </span><span class="s3">\&quot;</span><span class="s1">createPieServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">PieModule,</span><span class="s3">\n  </span><span class="s1">createPieServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">PacketGeneratedModule,</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/packet/module.ts</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">EmptyFileSystem,</span><span class="s3">\n  </span><span class="s1">createDefaultCoreModule,</span><span class="s3">\n  </span><span class="s1">createDefaultSharedCoreModule,</span><span class="s3">\n  </span><span class="s1">inject</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">langium</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/language/packet/tokenBuilder.ts</span><span class="s3">\n</span><span class="s1">var PacketTokenBuilder = class extends AbstractMermaidTokenBuilder {</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">PacketTokenBuilder</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">constructor() {</span><span class="s3">\n    </span><span class="s1">super([</span><span class="s3">\&quot;</span><span class="s1">packet-beta</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/language/packet/module.ts</span><span class="s3">\n</span><span class="s1">var PacketModule = {</span><span class="s3">\n  </span><span class="s1">parser: {</span><span class="s3">\n    </span><span class="s1">TokenBuilder: /* @__PURE__ */ __name(() =&gt; new PacketTokenBuilder(), </span><span class="s3">\&quot;</span><span class="s1">TokenBuilder</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">ValueConverter: /* @__PURE__ */ __name(() =&gt; new CommonValueConverter(), </span><span class="s3">\&quot;</span><span class="s1">ValueConverter</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function createPacketServices(context = EmptyFileSystem) {</span><span class="s3">\n  </span><span class="s1">const shared = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultSharedCoreModule(context),</span><span class="s3">\n    </span><span class="s1">MermaidGeneratedSharedModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const Packet = inject(</span><span class="s3">\n    </span><span class="s1">createDefaultCoreModule({ shared }),</span><span class="s3">\n    </span><span class="s1">PacketGeneratedModule,</span><span class="s3">\n    </span><span class="s1">PacketModule</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">shared.ServiceRegistry.register(Packet);</span><span class="s3">\n  </span><span class="s1">return { shared, Packet };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(createPacketServices, </span><span class="s3">\&quot;</span><span class="s1">createPacketServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">PacketModule,</span><span class="s3">\n  </span><span class="s1">createPacketServices</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">GitGraphModule,</span><span class="s3">\n  </span><span class="s1">createGitGraphServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">InfoModule,</span><span class="s3">\n  </span><span class="s1">createInfoServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PacketModule,</span><span class="s3">\n  </span><span class="s1">createPacketServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">PieModule,</span><span class="s3">\n  </span><span class="s1">createPieServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ArchitectureModule,</span><span class="s3">\n  </span><span class="s1">createArchitectureServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">RadarModule,</span><span class="s3">\n  </span><span class="s1">createRadarServices</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidValueConverter,</span><span class="s3">\n  </span><span class="s1">Architecture,</span><span class="s3">\n  </span><span class="s1">ArchitectureGeneratedModule,</span><span class="s3">\n  </span><span class="s1">Branch,</span><span class="s3">\n  </span><span class="s1">Commit,</span><span class="s3">\n  </span><span class="s1">CommonTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">GitGraph,</span><span class="s3">\n  </span><span class="s1">GitGraphGeneratedModule,</span><span class="s3">\n  </span><span class="s1">Info,</span><span class="s3">\n  </span><span class="s1">InfoGeneratedModule,</span><span class="s3">\n  </span><span class="s1">Merge,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">Packet,</span><span class="s3">\n  </span><span class="s1">PacketBlock,</span><span class="s3">\n  </span><span class="s1">PacketGeneratedModule,</span><span class="s3">\n  </span><span class="s1">Pie,</span><span class="s3">\n  </span><span class="s1">PieGeneratedModule,</span><span class="s3">\n  </span><span class="s1">PieSection,</span><span class="s3">\n  </span><span class="s1">Radar,</span><span class="s3">\n  </span><span class="s1">RadarGeneratedModule,</span><span class="s3">\n  </span><span class="s1">Statement,</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">isArchitecture,</span><span class="s3">\n  </span><span class="s1">isBranch,</span><span class="s3">\n  </span><span class="s1">isCommit,</span><span class="s3">\n  </span><span class="s1">isCommon,</span><span class="s3">\n  </span><span class="s1">isGitGraph,</span><span class="s3">\n  </span><span class="s1">isInfo,</span><span class="s3">\n  </span><span class="s1">isMerge,</span><span class="s3">\n  </span><span class="s1">isPacket,</span><span class="s3">\n  </span><span class="s1">isPacketBlock,</span><span class="s3">\n  </span><span class="s1">isPie,</span><span class="s3">\n  </span><span class="s1">isPieSection</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/parse.ts</span><span class="s3">\n</span><span class="s1">var parsers = {};</span><span class="s3">\n</span><span class="s1">var initializers = {</span><span class="s3">\n  </span><span class="s1">info: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createInfoServices: createInfoServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/info-4N47QTOZ.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createInfoServices2().Info.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.info = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">info</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">packet: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createPacketServices: createPacketServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/packet-KVYON367.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createPacketServices2().Packet.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.packet = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">packet</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">pie: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createPieServices: createPieServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/pie-R6RNRRYF.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createPieServices2().Pie.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.pie = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">pie</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">architecture: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createArchitectureServices: createArchitectureServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/architecture-4AB2E3PP.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createArchitectureServices2().Architecture.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.architecture = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">architecture</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">gitGraph: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createGitGraphServices: createGitGraphServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/gitGraph-O2Q2CXLX.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.gitGraph = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">gitGraph</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">radar: /* @__PURE__ */ __name(async () =&gt; {</span><span class="s3">\n    </span><span class="s1">const { createRadarServices: createRadarServices2 } = await import(</span><span class="s3">\&quot;</span><span class="s1">./chunks/mermaid-parser.core/radar-MK3ICKWK.mjs</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parser = createRadarServices2().Radar.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">parsers.radar = parser;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">radar</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">async function parse(diagramType, text) {</span><span class="s3">\n  </span><span class="s1">const initializer = initializers[diagramType];</span><span class="s3">\n  </span><span class="s1">if (!initializer) {</span><span class="s3">\n    </span><span class="s1">throw new Error(`Unknown diagram type: ${diagramType}`);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!parsers[diagramType]) {</span><span class="s3">\n    </span><span class="s1">await initializer();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const parser = parsers[diagramType];</span><span class="s3">\n  </span><span class="s1">const result = parser.parse(text);</span><span class="s3">\n  </span><span class="s1">if (result.lexerErrors.length &gt; 0 || result.parserErrors.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">throw new MermaidParseError(result);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result.value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(parse, </span><span class="s3">\&quot;</span><span class="s1">parse</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var MermaidParseError = class extends Error {</span><span class="s3">\n  </span><span class="s1">constructor(result) {</span><span class="s3">\n    </span><span class="s1">const lexerErrors = result.lexerErrors.map((err) =&gt; err.message).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const parserErrors = result.parserErrors.map((err) =&gt; err.message).join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">super(`Parsing failed: ${lexerErrors} ${parserErrors}`);</span><span class="s3">\n    </span><span class="s1">this.result = result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">MermaidParseError</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">AbstractMermaidTokenBuilder,</span><span class="s3">\n  </span><span class="s1">AbstractMermaidValueConverter,</span><span class="s3">\n  </span><span class="s1">Architecture,</span><span class="s3">\n  </span><span class="s1">ArchitectureGeneratedModule,</span><span class="s3">\n  </span><span class="s1">ArchitectureModule,</span><span class="s3">\n  </span><span class="s1">Branch,</span><span class="s3">\n  </span><span class="s1">Commit,</span><span class="s3">\n  </span><span class="s1">CommonTokenBuilder,</span><span class="s3">\n  </span><span class="s1">CommonValueConverter,</span><span class="s3">\n  </span><span class="s1">GitGraph,</span><span class="s3">\n  </span><span class="s1">GitGraphGeneratedModule,</span><span class="s3">\n  </span><span class="s1">GitGraphModule,</span><span class="s3">\n  </span><span class="s1">Info,</span><span class="s3">\n  </span><span class="s1">InfoGeneratedModule,</span><span class="s3">\n  </span><span class="s1">InfoModule,</span><span class="s3">\n  </span><span class="s1">Merge,</span><span class="s3">\n  </span><span class="s1">MermaidGeneratedSharedModule,</span><span class="s3">\n  </span><span class="s1">MermaidParseError,</span><span class="s3">\n  </span><span class="s1">Packet,</span><span class="s3">\n  </span><span class="s1">PacketBlock,</span><span class="s3">\n  </span><span class="s1">PacketGeneratedModule,</span><span class="s3">\n  </span><span class="s1">PacketModule,</span><span class="s3">\n  </span><span class="s1">Pie,</span><span class="s3">\n  </span><span class="s1">PieGeneratedModule,</span><span class="s3">\n  </span><span class="s1">PieModule,</span><span class="s3">\n  </span><span class="s1">PieSection,</span><span class="s3">\n  </span><span class="s1">Radar,</span><span class="s3">\n  </span><span class="s1">RadarGeneratedModule,</span><span class="s3">\n  </span><span class="s1">RadarModule,</span><span class="s3">\n  </span><span class="s1">Statement,</span><span class="s3">\n  </span><span class="s1">createArchitectureServices,</span><span class="s3">\n  </span><span class="s1">createGitGraphServices,</span><span class="s3">\n  </span><span class="s1">createInfoServices,</span><span class="s3">\n  </span><span class="s1">createPacketServices,</span><span class="s3">\n  </span><span class="s1">createPieServices,</span><span class="s3">\n  </span><span class="s1">createRadarServices,</span><span class="s3">\n  </span><span class="s1">isArchitecture,</span><span class="s3">\n  </span><span class="s1">isBranch,</span><span class="s3">\n  </span><span class="s1">isCommit,</span><span class="s3">\n  </span><span class="s1">isCommon,</span><span class="s3">\n  </span><span class="s1">isGitGraph,</span><span class="s3">\n  </span><span class="s1">isInfo,</span><span class="s3">\n  </span><span class="s1">isMerge,</span><span class="s3">\n  </span><span class="s1">isPacket,</span><span class="s3">\n  </span><span class="s1">isPacketBlock,</span><span class="s3">\n  </span><span class="s1">isPie,</span><span class="s3">\n  </span><span class="s1">isPieSection,</span><span class="s3">\n  </span><span class="s1">parse</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216</span><span class="s3">\n</span><span class="s1">export function toFastProperties(toBecomeFast) {</span><span class="s3">\n    </span><span class="s1">function FakeConstructor() { }</span><span class="s3">\n    </span><span class="s1">// If our object is used as a constructor, it would receive</span><span class="s3">\n    </span><span class="s1">FakeConstructor.prototype = toBecomeFast;</span><span class="s3">\n    </span><span class="s1">const fakeInstance = new FakeConstructor();</span><span class="s3">\n    </span><span class="s1">function fakeAccess() {</span><span class="s3">\n        </span><span class="s1">return typeof fakeInstance.bar;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// help V8 understand this is a </span><span class="s3">\&quot;</span><span class="s1">real</span><span class="s3">\&quot; </span><span class="s1">prototype by actually using</span><span class="s3">\n    </span><span class="s1">// the fake instance.</span><span class="s3">\n    </span><span class="s1">fakeAccess();</span><span class="s3">\n    </span><span class="s1">fakeAccess();</span><span class="s3">\n    </span><span class="s1">// Always true condition to suppress the Firefox warning of unreachable</span><span class="s3">\n    </span><span class="s1">// code after a return statement.</span><span class="s3">\n    </span><span class="s1">if (1)</span><span class="s3">\n        </span><span class="s1">return toBecomeFast;</span><span class="s3">\n    </span><span class="s1">// Eval prevents optimization of this method (even though this is dead code)</span><span class="s3">\n    </span><span class="s1">// - https://esbuild.github.io/content-types/#direct-eval</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n    </span><span class="s1">// tslint:disable-next-line</span><span class="s3">\n    </span><span class="s1">(0, eval)(toBecomeFast);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=to-fast-properties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.slice` without an iteratee call guard.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to slice.</span><span class="s3">\n </span><span class="s1">* @param {number} [start=0] The start position.</span><span class="s3">\n </span><span class="s1">* @param {number} [end=array.length] The end position.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the slice of `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSlice(array, start, end) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array.length;</span><span class="s3">\n\n  </span><span class="s1">if (start &lt; 0) {</span><span class="s3">\n    </span><span class="s1">start = -start &gt; length ? 0 : (length + start);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">end = end &gt; length ? length : end;</span><span class="s3">\n  </span><span class="s1">if (end &lt; 0) {</span><span class="s3">\n    </span><span class="s1">end += length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">length = start &gt; end ? 0 : ((end - start) &gt;&gt;&gt; 0);</span><span class="s3">\n  </span><span class="s1">start &gt;&gt;&gt;= 0;</span><span class="s3">\n\n  </span><span class="s1">var result = Array(length);</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">result[index] = array[index + start];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseSlice;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseSlice from './_baseSlice.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a slice of `array` with `n` elements dropped from the beginning.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.5.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to query.</span><span class="s3">\n </span><span class="s1">* @param {number} [n=1] The number of elements to drop.</span><span class="s3">\n </span><span class="s1">* @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the slice of `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.drop([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 3]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.drop([1, 2, 3], 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; [3]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.drop([1, 2, 3], 5);</span><span class="s3">\n </span><span class="s1">* // =&gt; []</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.drop([1, 2, 3], 0);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, 3]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function drop(array, n, guard) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">n = (guard || n === undefined) ? 1 : toInteger(n);</span><span class="s3">\n  </span><span class="s1">return baseSlice(array, n &lt; 0 ? 0 : n, length);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default drop;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import assignValue from './_assignValue.js';</span><span class="s3">\n</span><span class="s1">import copyObject from './_copyObject.js';</span><span class="s3">\n</span><span class="s1">import createAssigner from './_createAssigner.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n</span><span class="s1">import isPrototype from './_isPrototype.js';</span><span class="s3">\n</span><span class="s1">import keys from './keys.js';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns own enumerable string keyed properties of source objects to the</span><span class="s3">\n </span><span class="s1">* destination object. Source objects are applied from left to right.</span><span class="s3">\n </span><span class="s1">* Subsequent sources overwrite property assignments of previous sources.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object` and is loosely based on</span><span class="s3">\n </span><span class="s1">* [`Object.assign`](https://mdn.io/Object/assign).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.10.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.assignIn</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.a = 1;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Bar() {</span><span class="s3">\n </span><span class="s1">*   this.c = 3;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.b = 2;</span><span class="s3">\n </span><span class="s1">* Bar.prototype.d = 4;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.assign({ 'a': 0 }, new Foo, new Bar);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var assign = createAssigner(function(object, source) {</span><span class="s3">\n  </span><span class="s1">if (isPrototype(source) || isArrayLike(source)) {</span><span class="s3">\n    </span><span class="s1">copyObject(source, keys(source), object);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (var key in source) {</span><span class="s3">\n    </span><span class="s1">if (hasOwnProperty.call(source, key)) {</span><span class="s3">\n      </span><span class="s1">assignValue(object, key, source[key]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default assign;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayMap from './_arrayMap.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import basePickBy from './_basePickBy.js';</span><span class="s3">\n</span><span class="s1">import getAllKeysIn from './_getAllKeysIn.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an object composed of the `object` properties `predicate` returns</span><span class="s3">\n </span><span class="s1">* truthy for. The predicate is invoked with two arguments: (value, key).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per property.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1, 'b': '2', 'c': 3 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.pickBy(object, _.isNumber);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function pickBy(object, predicate) {</span><span class="s3">\n  </span><span class="s1">if (object == null) {</span><span class="s3">\n    </span><span class="s1">return {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var props = arrayMap(getAllKeysIn(object), function(prop) {</span><span class="s3">\n    </span><span class="s1">return [prop];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">predicate = baseIteratee(predicate);</span><span class="s3">\n  </span><span class="s1">return basePickBy(object, props, function(value, path) {</span><span class="s3">\n    </span><span class="s1">return predicate(value, path[0]);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default pickBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseGetTag from './_baseGetTag.js';</span><span class="s3">\n</span><span class="s1">import isObjectLike from './isObjectLike.js';</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var regexpTag = '[object RegExp]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isRegExp` without Node.js optimizations.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a regexp, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsRegExp(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp; baseGetTag(value) == regexpTag;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseIsRegExp;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIsRegExp from './_baseIsRegExp.js';</span><span class="s3">\n</span><span class="s1">import baseUnary from './_baseUnary.js';</span><span class="s3">\n</span><span class="s1">import nodeUtil from './_nodeUtil.js';</span><span class="s3">\n\n</span><span class="s1">/* Node.js helper references. */</span><span class="s3">\n</span><span class="s1">var nodeIsRegExp = nodeUtil &amp;&amp; nodeUtil.isRegExp;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `RegExp` object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a regexp, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isRegExp(/abc/);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isRegExp('/abc/');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;</span><span class="s3">\n\n</span><span class="s1">export default isRegExp;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { assign, forEach, isRegExp, isString, map, pickBy } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?</span><span class="s3">\n</span><span class="s1">function tokenLabel(tokType) {</span><span class="s3">\n    </span><span class="s1">if (hasTokenLabel(tokType)) {</span><span class="s3">\n        </span><span class="s1">return tokType.LABEL;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return tokType.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?</span><span class="s3">\n</span><span class="s1">function hasTokenLabel(obj) {</span><span class="s3">\n    </span><span class="s1">return isString(obj.LABEL) &amp;&amp; obj.LABEL !== </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class AbstractProduction {</span><span class="s3">\n    </span><span class="s1">get definition() {</span><span class="s3">\n        </span><span class="s1">return this._definition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set definition(value) {</span><span class="s3">\n        </span><span class="s1">this._definition = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(_definition) {</span><span class="s3">\n        </span><span class="s1">this._definition = _definition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">accept(visitor) {</span><span class="s3">\n        </span><span class="s1">visitor.visit(this);</span><span class="s3">\n        </span><span class="s1">forEach(this.definition, (prod) =&gt; {</span><span class="s3">\n            </span><span class="s1">prod.accept(visitor);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NonTerminal extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super([]);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set definition(definition) {</span><span class="s3">\n        </span><span class="s1">// immutable</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get definition() {</span><span class="s3">\n        </span><span class="s1">if (this.referencedRule !== undefined) {</span><span class="s3">\n            </span><span class="s1">return this.referencedRule.definition;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">accept(visitor) {</span><span class="s3">\n        </span><span class="s1">visitor.visit(this);</span><span class="s3">\n        </span><span class="s1">// don't visit children of a reference, we will get cyclic infinite loops if we do so</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Rule extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.orgText = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Alternative extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.ignoreAmbiguities = false;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Option extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RepetitionMandatory extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RepetitionMandatoryWithSeparator extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Repetition extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RepetitionWithSeparator extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Alternation extends AbstractProduction {</span><span class="s3">\n    </span><span class="s1">get definition() {</span><span class="s3">\n        </span><span class="s1">return this._definition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set definition(value) {</span><span class="s3">\n        </span><span class="s1">this._definition = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super(options.definition);</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">this.ignoreAmbiguities = false;</span><span class="s3">\n        </span><span class="s1">this.hasPredicates = false;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Terminal {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this.idx = 1;</span><span class="s3">\n        </span><span class="s1">assign(this, pickBy(options, (v) =&gt; v !== undefined));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">accept(visitor) {</span><span class="s3">\n        </span><span class="s1">visitor.visit(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function serializeGrammar(topRules) {</span><span class="s3">\n    </span><span class="s1">return map(topRules, serializeProduction);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function serializeProduction(node) {</span><span class="s3">\n    </span><span class="s1">function convertDefinition(definition) {</span><span class="s3">\n        </span><span class="s1">return map(definition, serializeProduction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (node instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">const serializedNonTerminal = {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">NonTerminal</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: node.nonTerminalName,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (isString(node.label)) {</span><span class="s3">\n            </span><span class="s1">serializedNonTerminal.label = node.label;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return serializedNonTerminal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Alternative) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Alternative</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Option) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Option</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof RepetitionMandatory) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatory</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatoryWithSeparator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof RepetitionWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">RepetitionWithSeparator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Repetition</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Alternation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">const serializedTerminal = {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Terminal</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: node.terminalType.name,</span><span class="s3">\n            </span><span class="s1">label: tokenLabel(node.terminalType),</span><span class="s3">\n            </span><span class="s1">idx: node.idx,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (isString(node.label)) {</span><span class="s3">\n            </span><span class="s1">serializedTerminal.terminalLabel = node.label;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const pattern = node.terminalType.PATTERN;</span><span class="s3">\n        </span><span class="s1">if (node.terminalType.PATTERN) {</span><span class="s3">\n            </span><span class="s1">serializedTerminal.pattern = isRegExp(pattern)</span><span class="s3">\n                </span><span class="s1">? pattern.source</span><span class="s3">\n                </span><span class="s1">: pattern;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return serializedTerminal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (node instanceof Rule) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">Rule</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: node.name,</span><span class="s3">\n            </span><span class="s1">orgText: node.orgText,</span><span class="s3">\n            </span><span class="s1">definition: convertDefinition(node.definition),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=model.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { drop, forEach } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*  A Grammar Walker that computes the </span><span class="s3">\&quot;</span><span class="s1">remaining</span><span class="s3">\&quot; </span><span class="s1">grammar </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">a productions in the grammar.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RestWalker {</span><span class="s3">\n    </span><span class="s1">walk(prod, prevRest = []) {</span><span class="s3">\n        </span><span class="s1">forEach(prod.definition, (subProd, index) =&gt; {</span><span class="s3">\n            </span><span class="s1">const currRest = drop(prod.definition, index + 1);</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n            </span><span class="s1">if (subProd instanceof NonTerminal) {</span><span class="s3">\n                </span><span class="s1">this.walkProdRef(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">this.walkTerminal(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof Alternative) {</span><span class="s3">\n                </span><span class="s1">this.walkFlat(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof Option) {</span><span class="s3">\n                </span><span class="s1">this.walkOption(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof RepetitionMandatory) {</span><span class="s3">\n                </span><span class="s1">this.walkAtLeastOne(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n                </span><span class="s1">this.walkAtLeastOneSep(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof RepetitionWithSeparator) {</span><span class="s3">\n                </span><span class="s1">this.walkManySep(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof Repetition) {</span><span class="s3">\n                </span><span class="s1">this.walkMany(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (subProd instanceof Alternation) {</span><span class="s3">\n                </span><span class="s1">this.walkOr(subProd, currRest, prevRest);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkTerminal(terminal, currRest, prevRest) { }</span><span class="s3">\n    </span><span class="s1">walkProdRef(refProd, currRest, prevRest) { }</span><span class="s3">\n    </span><span class="s1">walkFlat(flatProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABCDEF =&gt; after the D the rest is EF</span><span class="s3">\n        </span><span class="s1">const fullOrRest = currRest.concat(prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(flatProd, fullOrRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkOption(optionProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC(DE)?F =&gt; after the (DE)? the rest is F</span><span class="s3">\n        </span><span class="s1">const fullOrRest = currRest.concat(prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(optionProd, fullOrRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkAtLeastOne(atLeastOneProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC(DE)+F =&gt; after the (DE)+ the rest is (DE)?F</span><span class="s3">\n        </span><span class="s1">const fullAtLeastOneRest = [</span><span class="s3">\n            </span><span class="s1">new Option({ definition: atLeastOneProd.definition }),</span><span class="s3">\n        </span><span class="s1">].concat(currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(atLeastOneProd, fullAtLeastOneRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC DE(,DE)* F =&gt; after the (,DE)+ the rest is (,DE)?F</span><span class="s3">\n        </span><span class="s1">const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkMany(manyProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC(DE)*F =&gt; after the (DE)* the rest is (DE)?F</span><span class="s3">\n        </span><span class="s1">const fullManyRest = [</span><span class="s3">\n            </span><span class="s1">new Option({ definition: manyProd.definition }),</span><span class="s3">\n        </span><span class="s1">].concat(currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(manyProd, fullManyRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkManySep(manySepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC (DE(,DE)*)? F =&gt; after the (,DE)* the rest is (,DE)?F</span><span class="s3">\n        </span><span class="s1">const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">this.walk(manySepProd, fullManySepRest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkOr(orProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// ABC(D|E|F)G =&gt; when finding the (D|E|F) the rest is G</span><span class="s3">\n        </span><span class="s1">const fullOrRest = currRest.concat(prevRest);</span><span class="s3">\n        </span><span class="s1">// walk all different alternatives</span><span class="s3">\n        </span><span class="s1">forEach(orProd.definition, (alt) =&gt; {</span><span class="s3">\n            </span><span class="s1">// wrapping each alternative in a single definition wrapper</span><span class="s3">\n            </span><span class="s1">// to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows</span><span class="s3">\n            </span><span class="s1">// (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1</span><span class="s3">\n            </span><span class="s1">const prodWrapper = new Alternative({ definition: [alt] });</span><span class="s3">\n            </span><span class="s1">this.walk(prodWrapper, fullOrRest);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {</span><span class="s3">\n    </span><span class="s1">const repSepRest = [</span><span class="s3">\n        </span><span class="s1">new Option({</span><span class="s3">\n            </span><span class="s1">definition: [</span><span class="s3">\n                </span><span class="s1">new Terminal({ terminalType: repSepProd.separator }),</span><span class="s3">\n            </span><span class="s1">].concat(repSepProd.definition),</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">const fullRepSepRest = repSepRest.concat(currRest, prevRest);</span><span class="s3">\n    </span><span class="s1">return fullRepSepRest;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=rest.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseUniq from './_baseUniq.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a duplicate-free version of an array, using</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons, in which only the first occurrence of each element</span><span class="s3">\n </span><span class="s1">* is kept. The order of result values is determined by the order they occur</span><span class="s3">\n </span><span class="s1">* in the array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new duplicate free array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniq([2, 1, 2]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 1]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function uniq(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length) ? baseUniq(array) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default uniq;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseEach from './_baseEach.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.some` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if any element passes the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSome(collection, predicate) {</span><span class="s3">\n  </span><span class="s1">var result;</span><span class="s3">\n\n  </span><span class="s1">baseEach(collection, function(value, index, collection) {</span><span class="s3">\n    </span><span class="s1">result = predicate(value, index, collection);</span><span class="s3">\n    </span><span class="s1">return !result;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return !!result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseSome;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arraySome from './_arraySome.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseSome from './_baseSome.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `predicate` returns truthy for **any** element of `collection`.</span><span class="s3">\n </span><span class="s1">* Iteration is stopped once `predicate` returns truthy. The predicate is</span><span class="s3">\n </span><span class="s1">* invoked with three arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if any element passes the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.some([null, 0, 'yes', false], Boolean);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'active': true },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'active': false }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.some(users, { 'user': 'barney', 'active': false });</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.some(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.some(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function some(collection, predicate, guard) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arraySome : baseSome;</span><span class="s3">\n  </span><span class="s1">if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) {</span><span class="s3">\n    </span><span class="s1">predicate = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return func(collection, baseIteratee(predicate, 3));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default some;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIndexOf from './_baseIndexOf.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n</span><span class="s1">import isString from './isString.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n</span><span class="s1">import values from './values.js';</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMax = Math.max;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is in `collection`. If `collection` is a string, it's</span><span class="s3">\n </span><span class="s1">* checked for a substring of `value`, otherwise</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* is used for equality comparisons. If `fromIndex` is negative, it's used as</span><span class="s3">\n </span><span class="s1">* the offset from the end of `collection`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object|string} collection The collection to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is found, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.includes([1, 2, 3], 1);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.includes([1, 2, 3], 1, 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.includes({ 'a': 1, 'b': 2 }, 1);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.includes('abcd', 'bc');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function includes(collection, value, fromIndex, guard) {</span><span class="s3">\n  </span><span class="s1">collection = isArrayLike(collection) ? collection : values(collection);</span><span class="s3">\n  </span><span class="s1">fromIndex = (fromIndex &amp;&amp; !guard) ? toInteger(fromIndex) : 0;</span><span class="s3">\n\n  </span><span class="s1">var length = collection.length;</span><span class="s3">\n  </span><span class="s1">if (fromIndex &lt; 0) {</span><span class="s3">\n    </span><span class="s1">fromIndex = nativeMax(length + fromIndex, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return isString(collection)</span><span class="s3">\n    </span><span class="s1">? (fromIndex &lt;= length &amp;&amp; collection.indexOf(value, fromIndex) &gt; -1)</span><span class="s3">\n    </span><span class="s1">: (!!length &amp;&amp; baseIndexOf(collection, value, fromIndex) &gt; -1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default includes;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.every` for arrays without support for</span><span class="s3">\n </span><span class="s1">* iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if all elements pass the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayEvery(array, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (!predicate(array[index], index, array)) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default arrayEvery;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseEach from './_baseEach.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.every` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if all elements pass the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseEvery(collection, predicate) {</span><span class="s3">\n  </span><span class="s1">var result = true;</span><span class="s3">\n  </span><span class="s1">baseEach(collection, function(value, index, collection) {</span><span class="s3">\n    </span><span class="s1">result = !!predicate(value, index, collection);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseEvery;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayEvery from './_arrayEvery.js';</span><span class="s3">\n</span><span class="s1">import baseEvery from './_baseEvery.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `predicate` returns truthy for **all** elements of `collection`.</span><span class="s3">\n </span><span class="s1">* Iteration is stopped once `predicate` returns falsey. The predicate is</span><span class="s3">\n </span><span class="s1">* invoked with three arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method returns `true` for</span><span class="s3">\n </span><span class="s1">* [empty collections](https://en.wikipedia.org/wiki/Empty_set) because</span><span class="s3">\n </span><span class="s1">* [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of</span><span class="s3">\n </span><span class="s1">* elements of empty collections.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if all elements pass the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.every([true, 1, null, 'yes'], Boolean);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 36, 'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 40, 'active': false }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.every(users, { 'user': 'barney', 'active': false });</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.every(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.every(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function every(collection, predicate, guard) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayEvery : baseEvery;</span><span class="s3">\n  </span><span class="s1">if (guard &amp;&amp; isIterateeCall(collection, predicate, guard)) {</span><span class="s3">\n    </span><span class="s1">predicate = undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return func(collection, baseIteratee(predicate, 3));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default every;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { every, includes, some } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { AbstractProduction, Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">./model.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function isSequenceProd(prod) {</span><span class="s3">\n    </span><span class="s1">return (prod instanceof Alternative ||</span><span class="s3">\n        </span><span class="s1">prod instanceof Option ||</span><span class="s3">\n        </span><span class="s1">prod instanceof Repetition ||</span><span class="s3">\n        </span><span class="s1">prod instanceof RepetitionMandatory ||</span><span class="s3">\n        </span><span class="s1">prod instanceof RepetitionMandatoryWithSeparator ||</span><span class="s3">\n        </span><span class="s1">prod instanceof RepetitionWithSeparator ||</span><span class="s3">\n        </span><span class="s1">prod instanceof Terminal ||</span><span class="s3">\n        </span><span class="s1">prod instanceof Rule);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isOptionalProd(prod, alreadyVisited = []) {</span><span class="s3">\n    </span><span class="s1">const isDirectlyOptional = prod instanceof Option ||</span><span class="s3">\n        </span><span class="s1">prod instanceof Repetition ||</span><span class="s3">\n        </span><span class="s1">prod instanceof RepetitionWithSeparator;</span><span class="s3">\n    </span><span class="s1">if (isDirectlyOptional) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another</span><span class="s3">\n    </span><span class="s1">// empty optional top rule</span><span class="s3">\n    </span><span class="s1">// may be indirectly optional ((A?B?C?) | (D?E?F?))</span><span class="s3">\n    </span><span class="s1">if (prod instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">// for OR its enough for just one of the alternatives to be optional</span><span class="s3">\n        </span><span class="s1">return some(prod.definition, (subProd) =&gt; {</span><span class="s3">\n            </span><span class="s1">return isOptionalProd(subProd, alreadyVisited);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof NonTerminal &amp;&amp; includes(alreadyVisited, prod)) {</span><span class="s3">\n        </span><span class="s1">// avoiding stack overflow due to infinite recursion</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof AbstractProduction) {</span><span class="s3">\n        </span><span class="s1">if (prod instanceof NonTerminal) {</span><span class="s3">\n            </span><span class="s1">alreadyVisited.push(prod);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return every(prod.definition, (subProd) =&gt; {</span><span class="s3">\n            </span><span class="s1">return isOptionalProd(subProd, alreadyVisited);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isBranchingProd(prod) {</span><span class="s3">\n    </span><span class="s1">return prod instanceof Alternation;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getProductionDslName(prod) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (prod instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">SUBRULE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Option) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">OPTION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">OR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatory) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">AT_LEAST_ONE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">AT_LEAST_ONE_SEP</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">MANY_SEP</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">MANY</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">CONSUME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=helpers.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { flatten, map, uniq } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isBranchingProd, isOptionalProd, isSequenceProd, NonTerminal, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function first(prod) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (prod instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">// this could in theory cause infinite loops if</span><span class="s3">\n        </span><span class="s1">// (1) prod A refs prod B.</span><span class="s3">\n        </span><span class="s1">// (2) prod B refs prod A</span><span class="s3">\n        </span><span class="s1">// (3) AB can match the empty set</span><span class="s3">\n        </span><span class="s1">// in other words a cycle where everything is optional so the first will keep</span><span class="s3">\n        </span><span class="s1">// looking ahead for the next optional part and will never exit</span><span class="s3">\n        </span><span class="s1">// currently there is no safeguard for this unique edge case because</span><span class="s3">\n        </span><span class="s1">// (1) not sure a grammar in which this can happen is useful for anything (productive)</span><span class="s3">\n        </span><span class="s1">return first(prod.referencedRule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">return firstForTerminal(prod);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isSequenceProd(prod)) {</span><span class="s3">\n        </span><span class="s1">return firstForSequence(prod);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isBranchingProd(prod)) {</span><span class="s3">\n        </span><span class="s1">return firstForBranching(prod);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function firstForSequence(prod) {</span><span class="s3">\n    </span><span class="s1">let firstSet = [];</span><span class="s3">\n    </span><span class="s1">const seq = prod.definition;</span><span class="s3">\n    </span><span class="s1">let nextSubProdIdx = 0;</span><span class="s3">\n    </span><span class="s1">let hasInnerProdsRemaining = seq.length &gt; nextSubProdIdx;</span><span class="s3">\n    </span><span class="s1">let currSubProd;</span><span class="s3">\n    </span><span class="s1">// so we enter the loop at least once (if the definition is not empty</span><span class="s3">\n    </span><span class="s1">let isLastInnerProdOptional = true;</span><span class="s3">\n    </span><span class="s1">// scan a sequence until it's end or until we have found a NONE optional production in it</span><span class="s3">\n    </span><span class="s1">while (hasInnerProdsRemaining &amp;&amp; isLastInnerProdOptional) {</span><span class="s3">\n        </span><span class="s1">currSubProd = seq[nextSubProdIdx];</span><span class="s3">\n        </span><span class="s1">isLastInnerProdOptional = isOptionalProd(currSubProd);</span><span class="s3">\n        </span><span class="s1">firstSet = firstSet.concat(first(currSubProd));</span><span class="s3">\n        </span><span class="s1">nextSubProdIdx = nextSubProdIdx + 1;</span><span class="s3">\n        </span><span class="s1">hasInnerProdsRemaining = seq.length &gt; nextSubProdIdx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return uniq(firstSet);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function firstForBranching(prod) {</span><span class="s3">\n    </span><span class="s1">const allAlternativesFirsts = map(prod.definition, (innerProd) =&gt; {</span><span class="s3">\n        </span><span class="s1">return first(innerProd);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return uniq(flatten(allAlternativesFirsts));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function firstForTerminal(terminal) {</span><span class="s3">\n    </span><span class="s1">return [terminal.terminalType];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=first.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;// TODO: can this be removed? where is it used?</span><span class="s3">\n</span><span class="s1">export const IN = </span><span class="s3">\&quot;</span><span class="s1">_~IN~_</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=constants.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RestWalker } from </span><span class="s3">\&quot;</span><span class="s1">./rest.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { first } from </span><span class="s3">\&quot;</span><span class="s1">./first.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { assign, forEach } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { IN } from </span><span class="s3">\&quot;</span><span class="s1">../constants.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternative } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// This ResyncFollowsWalker computes all of the follows required for RESYNC</span><span class="s3">\n</span><span class="s1">// (skipping reference production).</span><span class="s3">\n</span><span class="s1">export class ResyncFollowsWalker extends RestWalker {</span><span class="s3">\n    </span><span class="s1">constructor(topProd) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.topProd = topProd;</span><span class="s3">\n        </span><span class="s1">this.follows = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startWalking() {</span><span class="s3">\n        </span><span class="s1">this.walk(this.topProd);</span><span class="s3">\n        </span><span class="s1">return this.follows;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkTerminal(terminal, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// do nothing! just like in the public sector after 13:00</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkProdRef(refProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +</span><span class="s3">\n            </span><span class="s1">this.topProd.name;</span><span class="s3">\n        </span><span class="s1">const fullRest = currRest.concat(prevRest);</span><span class="s3">\n        </span><span class="s1">const restProd = new Alternative({ definition: fullRest });</span><span class="s3">\n        </span><span class="s1">const t_in_topProd_follows = first(restProd);</span><span class="s3">\n        </span><span class="s1">this.follows[followName] = t_in_topProd_follows;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function computeAllProdsFollows(topProductions) {</span><span class="s3">\n    </span><span class="s1">const reSyncFollows = {};</span><span class="s3">\n    </span><span class="s1">forEach(topProductions, (topProd) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();</span><span class="s3">\n        </span><span class="s1">assign(reSyncFollows, currRefsFollow);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return reSyncFollows;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {</span><span class="s3">\n    </span><span class="s1">return inner.name + occurenceInParent + IN;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildInProdFollowPrefix(terminal) {</span><span class="s3">\n    </span><span class="s1">const terminalName = terminal.terminalType.name;</span><span class="s3">\n    </span><span class="s1">return terminalName + terminal.idx + IN;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=follow.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Error message constants. */</span><span class="s3">\n</span><span class="s1">var FUNC_ERROR_TEXT = 'Expected a function';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function that negates the result of the predicate `func`. The</span><span class="s3">\n </span><span class="s1">* `func` predicate is invoked with the `this` binding and arguments of the</span><span class="s3">\n </span><span class="s1">* created function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Function</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The predicate to negate.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new negated function.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function isEven(n) {</span><span class="s3">\n </span><span class="s1">*   return n % 2 == 0;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 3, 5]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function negate(predicate) {</span><span class="s3">\n  </span><span class="s1">if (typeof predicate != 'function') {</span><span class="s3">\n    </span><span class="s1">throw new TypeError(FUNC_ERROR_TEXT);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function() {</span><span class="s3">\n    </span><span class="s1">var args = arguments;</span><span class="s3">\n    </span><span class="s1">switch (args.length) {</span><span class="s3">\n      </span><span class="s1">case 0: return !predicate.call(this);</span><span class="s3">\n      </span><span class="s1">case 1: return !predicate.call(this, args[0]);</span><span class="s3">\n      </span><span class="s1">case 2: return !predicate.call(this, args[0], args[1]);</span><span class="s3">\n      </span><span class="s1">case 3: return !predicate.call(this, args[0], args[1], args[2]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return !predicate.apply(this, args);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default negate;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayFilter from './_arrayFilter.js';</span><span class="s3">\n</span><span class="s1">import baseFilter from './_baseFilter.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n</span><span class="s1">import negate from './negate.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The opposite of `_.filter`; this method returns the elements of `collection`</span><span class="s3">\n </span><span class="s1">* that `predicate` does **not** return truthy for.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new filtered array.</span><span class="s3">\n </span><span class="s1">* @see _.filter</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 36, 'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 40, 'active': true }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.reject(users, function(o) { return !o.active; });</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for ['fred']</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.reject(users, { 'age': 40, 'active': true });</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for ['barney']</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.reject(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for ['fred']</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.reject(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for ['barney']</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function reject(collection, predicate) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayFilter : baseFilter;</span><span class="s3">\n  </span><span class="s1">return func(collection, negate(baseIteratee(predicate, 3)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default reject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIndexOf from './_baseIndexOf.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMax = Math.max;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the index at which the first occurrence of `value` is found in `array`</span><span class="s3">\n </span><span class="s1">* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons. If `fromIndex` is negative, it's used as the</span><span class="s3">\n </span><span class="s1">* offset from the end of `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.indexOf([1, 2, 1, 2], 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // Search from the `fromIndex`.</span><span class="s3">\n </span><span class="s1">* _.indexOf([1, 2, 1, 2], 2, 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function indexOf(array, value, fromIndex) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = fromIndex == null ? 0 : toInteger(fromIndex);</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">index = nativeMax(length + index, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseIndexOf(array, value, index);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default indexOf;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import SetCache from './_SetCache.js';</span><span class="s3">\n</span><span class="s1">import arrayIncludes from './_arrayIncludes.js';</span><span class="s3">\n</span><span class="s1">import arrayIncludesWith from './_arrayIncludesWith.js';</span><span class="s3">\n</span><span class="s1">import arrayMap from './_arrayMap.js';</span><span class="s3">\n</span><span class="s1">import baseUnary from './_baseUnary.js';</span><span class="s3">\n</span><span class="s1">import cacheHas from './_cacheHas.js';</span><span class="s3">\n\n</span><span class="s1">/** Used as the size to enable large array optimizations. */</span><span class="s3">\n</span><span class="s1">var LARGE_ARRAY_SIZE = 200;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of methods like `_.difference` without support</span><span class="s3">\n </span><span class="s1">* for excluding multiple arrays or iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Array} values The values to exclude.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of filtered values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseDifference(array, values, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">includes = arrayIncludes,</span><span class="s3">\n      </span><span class="s1">isCommon = true,</span><span class="s3">\n      </span><span class="s1">length = array.length,</span><span class="s3">\n      </span><span class="s1">result = [],</span><span class="s3">\n      </span><span class="s1">valuesLength = values.length;</span><span class="s3">\n\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (iteratee) {</span><span class="s3">\n    </span><span class="s1">values = arrayMap(values, baseUnary(iteratee));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (comparator) {</span><span class="s3">\n    </span><span class="s1">includes = arrayIncludesWith;</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (values.length &gt;= LARGE_ARRAY_SIZE) {</span><span class="s3">\n    </span><span class="s1">includes = cacheHas;</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">values = new SetCache(values);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">outer:</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">computed = iteratee == null ? value : iteratee(value);</span><span class="s3">\n\n    </span><span class="s1">value = (comparator || value !== 0) ? value : 0;</span><span class="s3">\n    </span><span class="s1">if (isCommon &amp;&amp; computed === computed) {</span><span class="s3">\n      </span><span class="s1">var valuesIndex = valuesLength;</span><span class="s3">\n      </span><span class="s1">while (valuesIndex--) {</span><span class="s3">\n        </span><span class="s1">if (values[valuesIndex] === computed) {</span><span class="s3">\n          </span><span class="s1">continue outer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!includes(values, computed, comparator)) {</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseDifference;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseDifference from './_baseDifference.js';</span><span class="s3">\n</span><span class="s1">import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n</span><span class="s1">import baseRest from './_baseRest.js';</span><span class="s3">\n</span><span class="s1">import isArrayLikeObject from './isArrayLikeObject.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of `array` values not included in the other given arrays</span><span class="s3">\n </span><span class="s1">* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons. The order and references of result values are</span><span class="s3">\n </span><span class="s1">* determined by the first array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** Unlike `_.pullAll`, this method returns a new array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {...Array} [values] The values to exclude.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of filtered values.</span><span class="s3">\n </span><span class="s1">* @see _.without, _.xor</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.difference([2, 1], [2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var difference = baseRest(function(array, values) {</span><span class="s3">\n  </span><span class="s1">return isArrayLikeObject(array)</span><span class="s3">\n    </span><span class="s1">? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))</span><span class="s3">\n    </span><span class="s1">: [];</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default difference;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Creates an array with all falsey values removed. The values `false`, `null`,</span><span class="s3">\n </span><span class="s1">* `0`, `</span><span class="s3">\&quot;\&quot;</span><span class="s1">`, `undefined`, and `NaN` are falsey.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to compact.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of filtered values.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.compact([0, 1, false, 2, '', 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, 3]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compact(array) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length,</span><span class="s3">\n      </span><span class="s1">resIndex = 0,</span><span class="s3">\n      </span><span class="s1">result = [];</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index];</span><span class="s3">\n    </span><span class="s1">if (value) {</span><span class="s3">\n      </span><span class="s1">result[resIndex++] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default compact;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Gets the first element of `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @alias first</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to query.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the first element of `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.head([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.head([]);</span><span class="s3">\n </span><span class="s1">* // =&gt; undefined</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function head(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length) ? array[0] : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default head;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;export function PRINT_ERROR(msg) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else - can't override global.console in node.js */</span><span class="s3">\n    </span><span class="s1">if (console &amp;&amp; console.error) {</span><span class="s3">\n        </span><span class="s1">console.error(`Error: ${msg}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function PRINT_WARNING(msg) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else - can't override global.console in node.js*/</span><span class="s3">\n    </span><span class="s1">if (console &amp;&amp; console.warn) {</span><span class="s3">\n        </span><span class="s1">// TODO: modify docs accordingly</span><span class="s3">\n        </span><span class="s1">console.warn(`Warning: ${msg}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=print.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { RegExpParser, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/regexp-to-ast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">let regExpAstCache = {};</span><span class="s3">\n</span><span class="s1">const regExpParser = new RegExpParser();</span><span class="s3">\n</span><span class="s1">export function getRegExpAst(regExp) {</span><span class="s3">\n    </span><span class="s1">const regExpStr = regExp.toString();</span><span class="s3">\n    </span><span class="s1">if (regExpAstCache.hasOwnProperty(regExpStr)) {</span><span class="s3">\n        </span><span class="s1">return regExpAstCache[regExpStr];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const regExpAst = regExpParser.pattern(regExpStr);</span><span class="s3">\n        </span><span class="s1">regExpAstCache[regExpStr] = regExpAst;</span><span class="s3">\n        </span><span class="s1">return regExpAst;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function clearRegExpParserCache() {</span><span class="s3">\n    </span><span class="s1">regExpAstCache = {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=reg_exp_parser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { BaseRegExpVisitor, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/regexp-to-ast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { every, find, forEach, includes, isArray, values } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { PRINT_ERROR, PRINT_WARNING } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getRegExpAst } from </span><span class="s3">\&quot;</span><span class="s1">./reg_exp_parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { charCodeToOptimizedIndex, minOptimizationVal } from </span><span class="s3">\&quot;</span><span class="s1">./lexer.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const complementErrorMessage = </span><span class="s3">\&quot;</span><span class="s1">Complement Sets are not supported for first char optimization</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const failedOptimizationPrefixMsg = 'Unable to use </span><span class="s3">\&quot;</span><span class="s1">first char</span><span class="s3">\&quot; </span><span class="s1">lexer optimizations:</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n</span><span class="s1">export function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const ast = getRegExpAst(regExp);</span><span class="s3">\n        </span><span class="s1">const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);</span><span class="s3">\n        </span><span class="s1">return firstChars;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (e) {</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n        </span><span class="s1">// Testing this relies on the regexp-to-ast library having a bug... */</span><span class="s3">\n        </span><span class="s1">// TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc</span><span class="s3">\n        </span><span class="s1">if (e.message === complementErrorMessage) {</span><span class="s3">\n            </span><span class="s1">if (ensureOptimizations) {</span><span class="s3">\n                </span><span class="s1">PRINT_WARNING(`${failedOptimizationPrefixMsg}` +</span><span class="s3">\n                    </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tUnable to optimize: &lt; ${regExp.toString()} &gt;</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tComplement Sets cannot be automatically optimized.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tThis will disable the lexer's first char optimizations.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let msgSuffix = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (ensureOptimizations) {</span><span class="s3">\n                </span><span class="s1">msgSuffix =</span><span class="s3">\n                    \&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">tThis will disable the lexer's first char optimizations.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                        \&quot;\\</span><span class="s1">tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">PRINT_ERROR(`${failedOptimizationPrefixMsg}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tFailed parsing: &lt; ${regExp.toString()} &gt;</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tUsing the @chevrotain/regexp-to-ast library</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                \&quot;\\</span><span class="s1">tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">msgSuffix);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function firstCharOptimizedIndices(ast, result, ignoreCase) {</span><span class="s3">\n    </span><span class="s1">switch (ast.type) {</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Disjunction</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; ast.value.length; i++) {</span><span class="s3">\n                </span><span class="s1">firstCharOptimizedIndices(ast.value[i], result, ignoreCase);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Alternative</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n            </span><span class="s1">const terms = ast.value;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; terms.length; i++) {</span><span class="s3">\n                </span><span class="s1">const term = terms[i];</span><span class="s3">\n                </span><span class="s1">// skip terms that cannot effect the first char results</span><span class="s3">\n                </span><span class="s1">switch (term.type) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">EndAnchor</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">// A group back reference cannot affect potential starting char.</span><span class="s3">\n                    </span><span class="s1">// because if a back reference is the first production than automatically</span><span class="s3">\n                    </span><span class="s1">// the group being referenced has had to come BEFORE so its codes have already been added</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">GroupBackReference</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">// assertions do not affect potential starting codes</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Lookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NegativeLookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">StartAnchor</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">WordBoundary</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NonWordBoundary</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const atom = term;</span><span class="s3">\n                </span><span class="s1">switch (atom.type) {</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Character</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">addOptimizedIdxToResult(atom.value, result, ignoreCase);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Set</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">if (atom.complement === true) {</span><span class="s3">\n                            </span><span class="s1">throw Error(complementErrorMessage);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">forEach(atom.value, (code) =&gt; {</span><span class="s3">\n                            </span><span class="s1">if (typeof code === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                                </span><span class="s1">addOptimizedIdxToResult(code, result, ignoreCase);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else {</span><span class="s3">\n                                </span><span class="s1">// range</span><span class="s3">\n                                </span><span class="s1">const range = code;</span><span class="s3">\n                                </span><span class="s1">// cannot optimize when ignoreCase is</span><span class="s3">\n                                </span><span class="s1">if (ignoreCase === true) {</span><span class="s3">\n                                    </span><span class="s1">for (let rangeCode = range.from; rangeCode &lt;= range.to; rangeCode++) {</span><span class="s3">\n                                        </span><span class="s1">addOptimizedIdxToResult(rangeCode, result, ignoreCase);</span><span class="s3">\n                                    </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">// Optimization (2 orders of magnitude less work for very large ranges)</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">// handle unoptimized values</span><span class="s3">\n                                    </span><span class="s1">for (let rangeCode = range.from; rangeCode &lt;= range.to &amp;&amp; rangeCode &lt; minOptimizationVal; rangeCode++) {</span><span class="s3">\n                                        </span><span class="s1">addOptimizedIdxToResult(rangeCode, result, ignoreCase);</span><span class="s3">\n                                    </span><span class="s1">}</span><span class="s3">\n                                    </span><span class="s1">// Less common charCode where we optimize for faster init time, by using larger </span><span class="s3">\&quot;</span><span class="s1">buckets</span><span class="s3">\&quot;\n                                    </span><span class="s1">if (range.to &gt;= minOptimizationVal) {</span><span class="s3">\n                                        </span><span class="s1">const minUnOptVal = range.from &gt;= minOptimizationVal</span><span class="s3">\n                                            </span><span class="s1">? range.from</span><span class="s3">\n                                            </span><span class="s1">: minOptimizationVal;</span><span class="s3">\n                                        </span><span class="s1">const maxUnOptVal = range.to;</span><span class="s3">\n                                        </span><span class="s1">const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);</span><span class="s3">\n                                        </span><span class="s1">const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);</span><span class="s3">\n                                        </span><span class="s1">for (let currOptIdx = minOptIdx; currOptIdx &lt;= maxOptIdx; currOptIdx++) {</span><span class="s3">\n                                            </span><span class="s1">result[currOptIdx] = currOptIdx;</span><span class="s3">\n                                        </span><span class="s1">}</span><span class="s3">\n                                    </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                        </span><span class="s1">firstCharOptimizedIndices(atom.value, result, ignoreCase);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n                    </span><span class="s1">default:</span><span class="s3">\n                        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Non Exhaustive Match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// reached a mandatory production, no more **start** codes can be found on this alternative</span><span class="s3">\n                </span><span class="s1">const isOptionalQuantifier = atom.quantifier !== undefined &amp;&amp; atom.quantifier.atLeast === 0;</span><span class="s3">\n                </span><span class="s1">if (</span><span class="s3">\n                </span><span class="s1">// A group may be optional due to empty contents /(?:)/</span><span class="s3">\n                </span><span class="s1">// or if everything inside it is optional /((a)?)/</span><span class="s3">\n                </span><span class="s1">(atom.type === </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isWholeOptional(atom) === false) ||</span><span class="s3">\n                    </span><span class="s1">// If this term is not a group it may only be optional if it has an optional quantifier</span><span class="s3">\n                    </span><span class="s1">(atom.type !== </span><span class="s3">\&quot;</span><span class="s1">Group</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isOptionalQuantifier === false)) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match!</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// console.log(Object.keys(result).length)</span><span class="s3">\n    </span><span class="s1">return values(result);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addOptimizedIdxToResult(code, result, ignoreCase) {</span><span class="s3">\n    </span><span class="s1">const optimizedCharIdx = charCodeToOptimizedIndex(code);</span><span class="s3">\n    </span><span class="s1">result[optimizedCharIdx] = optimizedCharIdx;</span><span class="s3">\n    </span><span class="s1">if (ignoreCase === true) {</span><span class="s3">\n        </span><span class="s1">handleIgnoreCase(code, result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function handleIgnoreCase(code, result) {</span><span class="s3">\n    </span><span class="s1">const char = String.fromCharCode(code);</span><span class="s3">\n    </span><span class="s1">const upperChar = char.toUpperCase();</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (upperChar !== char) {</span><span class="s3">\n        </span><span class="s1">const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));</span><span class="s3">\n        </span><span class="s1">result[optimizedCharIdx] = optimizedCharIdx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const lowerChar = char.toLowerCase();</span><span class="s3">\n        </span><span class="s1">if (lowerChar !== char) {</span><span class="s3">\n            </span><span class="s1">const optimizedCharIdx = charCodeToOptimizedIndex(lowerChar.charCodeAt(0));</span><span class="s3">\n            </span><span class="s1">result[optimizedCharIdx] = optimizedCharIdx;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findCode(setNode, targetCharCodes) {</span><span class="s3">\n    </span><span class="s1">return find(setNode.value, (codeOrRange) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (typeof codeOrRange === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">return includes(targetCharCodes, codeOrRange);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// range</span><span class="s3">\n            </span><span class="s1">const range = codeOrRange;</span><span class="s3">\n            </span><span class="s1">return (find(targetCharCodes, (targetCode) =&gt; range.from &lt;= targetCode &amp;&amp; targetCode &lt;= range.to) !== undefined);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isWholeOptional(ast) {</span><span class="s3">\n    </span><span class="s1">const quantifier = ast.quantifier;</span><span class="s3">\n    </span><span class="s1">if (quantifier &amp;&amp; quantifier.atLeast === 0) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!ast.value) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isArray(ast.value)</span><span class="s3">\n        </span><span class="s1">? every(ast.value, isWholeOptional)</span><span class="s3">\n        </span><span class="s1">: isWholeOptional(ast.value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CharCodeFinder extends BaseRegExpVisitor {</span><span class="s3">\n    </span><span class="s1">constructor(targetCharCodes) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.targetCharCodes = targetCharCodes;</span><span class="s3">\n        </span><span class="s1">this.found = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitChildren(node) {</span><span class="s3">\n        </span><span class="s1">// No need to keep looking...</span><span class="s3">\n        </span><span class="s1">if (this.found === true) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// switch lookaheads as they do not actually consume any characters thus</span><span class="s3">\n        </span><span class="s1">// finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.</span><span class="s3">\n        </span><span class="s1">switch (node.type) {</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">Lookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitLookahead(node);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">NegativeLookahead</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n                </span><span class="s1">this.visitNegativeLookahead(node);</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">super.visitChildren(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitCharacter(node) {</span><span class="s3">\n        </span><span class="s1">if (includes(this.targetCharCodes, node.value)) {</span><span class="s3">\n            </span><span class="s1">this.found = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitSet(node) {</span><span class="s3">\n        </span><span class="s1">if (node.complement) {</span><span class="s3">\n            </span><span class="s1">if (findCode(node, this.targetCharCodes) === undefined) {</span><span class="s3">\n                </span><span class="s1">this.found = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (findCode(node, this.targetCharCodes) !== undefined) {</span><span class="s3">\n                </span><span class="s1">this.found = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function canMatchCharCode(charCodes, pattern) {</span><span class="s3">\n    </span><span class="s1">if (pattern instanceof RegExp) {</span><span class="s3">\n        </span><span class="s1">const ast = getRegExpAst(pattern);</span><span class="s3">\n        </span><span class="s1">const charCodeFinder = new CharCodeFinder(charCodes);</span><span class="s3">\n        </span><span class="s1">charCodeFinder.visit(ast);</span><span class="s3">\n        </span><span class="s1">return charCodeFinder.found;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return (find(pattern, (char) =&gt; {</span><span class="s3">\n            </span><span class="s1">return includes(charCodes, char.charCodeAt(0));</span><span class="s3">\n        </span><span class="s1">}) !== undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=reg_exp.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { BaseRegExpVisitor } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/regexp-to-ast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Lexer, LexerDefinitionErrorType, } from </span><span class="s3">\&quot;</span><span class="s1">./lexer_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { compact, defaults, difference, filter, find, first, flatten, forEach, has, includes, indexOf, isArray, isEmpty, isFunction, isRegExp, isString, isUndefined, keys, map, reduce, reject, values, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { PRINT_ERROR } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { canMatchCharCode, failedOptimizationPrefixMsg, getOptimizedStartCodesIndices, } from </span><span class="s3">\&quot;</span><span class="s1">./reg_exp.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getRegExpAst } from </span><span class="s3">\&quot;</span><span class="s1">./reg_exp_parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const PATTERN = </span><span class="s3">\&quot;</span><span class="s1">PATTERN</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const DEFAULT_MODE = </span><span class="s3">\&quot;</span><span class="s1">defaultMode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const MODES = </span><span class="s3">\&quot;</span><span class="s1">modes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export let SUPPORT_STICKY = typeof new RegExp(</span><span class="s3">\&quot;</span><span class="s1">(?:)</span><span class="s3">\&quot;</span><span class="s1">).sticky === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function disableSticky() {</span><span class="s3">\n    </span><span class="s1">SUPPORT_STICKY = false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function enableSticky() {</span><span class="s3">\n    </span><span class="s1">SUPPORT_STICKY = true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function analyzeTokenTypes(tokenTypes, options) {</span><span class="s3">\n    </span><span class="s1">options = defaults(options, {</span><span class="s3">\n        </span><span class="s1">useSticky: SUPPORT_STICKY,</span><span class="s3">\n        </span><span class="s1">debug: false,</span><span class="s3">\n        </span><span class="s1">safeMode: false,</span><span class="s3">\n        </span><span class="s1">positionTracking: </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">lineTerminatorCharacters: [</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n        </span><span class="s1">tracer: (msg, action) =&gt; action(),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const tracer = options.tracer;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">initCharCodeToOptimizedIndexMap</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">initCharCodeToOptimizedIndexMap();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let onlyRelevantTypes;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">Reject Lexer.NA</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">onlyRelevantTypes = reject(tokenTypes, (currType) =&gt; {</span><span class="s3">\n            </span><span class="s1">return currType[PATTERN] === Lexer.NA;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let hasCustom = false;</span><span class="s3">\n    </span><span class="s1">let allTransformedPatterns;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">Transform Patterns</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">hasCustom = false;</span><span class="s3">\n        </span><span class="s1">allTransformedPatterns = map(onlyRelevantTypes, (currType) =&gt; {</span><span class="s3">\n            </span><span class="s1">const currPattern = currType[PATTERN];</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n            </span><span class="s1">if (isRegExp(currPattern)) {</span><span class="s3">\n                </span><span class="s1">const regExpSource = currPattern.source;</span><span class="s3">\n                </span><span class="s1">if (regExpSource.length === 1 &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">// only these regExp meta characters which can appear in a length one regExp</span><span class="s3">\n                    </span><span class="s1">regExpSource !== </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                    </span><span class="s1">regExpSource !== </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                    </span><span class="s1">regExpSource !== </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                    </span><span class="s1">!currPattern.ignoreCase) {</span><span class="s3">\n                    </span><span class="s1">return regExpSource;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (regExpSource.length === 2 &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">regExpSource[0] === </span><span class="s3">\&quot;\\\\\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n                    </span><span class="s1">// not a meta character</span><span class="s3">\n                    </span><span class="s1">!includes([</span><span class="s3">\n                        \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">D</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">S</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">f</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">v</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">w</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                        \&quot;</span><span class="s1">W</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                    </span><span class="s1">], regExpSource[1])) {</span><span class="s3">\n                    </span><span class="s1">// escaped meta Characters: /</span><span class="s3">\\</span><span class="s1">+/ /</span><span class="s3">\\</span><span class="s1">[/</span><span class="s3">\n                    </span><span class="s1">// or redundant escaping: /</span><span class="s3">\\</span><span class="s1">a/</span><span class="s3">\n                    </span><span class="s1">// without the escaping </span><span class="s3">\&quot;\\\&quot;\n                    </span><span class="s1">return regExpSource[1];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return options.useSticky</span><span class="s3">\n                        </span><span class="s1">? addStickyFlag(currPattern)</span><span class="s3">\n                        </span><span class="s1">: addStartOfInput(currPattern);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isFunction(currPattern)) {</span><span class="s3">\n                </span><span class="s1">hasCustom = true;</span><span class="s3">\n                </span><span class="s1">// CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object</span><span class="s3">\n                </span><span class="s1">return { exec: currPattern };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (typeof currPattern === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">hasCustom = true;</span><span class="s3">\n                </span><span class="s1">// ICustomPattern</span><span class="s3">\n                </span><span class="s1">return currPattern;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (typeof currPattern === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (currPattern.length === 1) {</span><span class="s3">\n                    </span><span class="s1">return currPattern;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">const escapedRegExpString = currPattern.replace(/[</span><span class="s3">\\\\</span><span class="s1">^$.*+?()[</span><span class="s3">\\</span><span class="s1">]{}|]/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">const wrappedRegExp = new RegExp(escapedRegExpString);</span><span class="s3">\n                    </span><span class="s1">return options.useSticky</span><span class="s3">\n                        </span><span class="s1">? addStickyFlag(wrappedRegExp)</span><span class="s3">\n                        </span><span class="s1">: addStartOfInput(wrappedRegExp);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let patternIdxToType;</span><span class="s3">\n    </span><span class="s1">let patternIdxToGroup;</span><span class="s3">\n    </span><span class="s1">let patternIdxToLongerAltIdxArr;</span><span class="s3">\n    </span><span class="s1">let patternIdxToPushMode;</span><span class="s3">\n    </span><span class="s1">let patternIdxToPopMode;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">misc mapping</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">patternIdxToType = map(onlyRelevantTypes, (currType) =&gt; currType.tokenTypeIdx);</span><span class="s3">\n        </span><span class="s1">patternIdxToGroup = map(onlyRelevantTypes, (clazz) =&gt; {</span><span class="s3">\n            </span><span class="s1">const groupName = clazz.GROUP;</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n            </span><span class="s1">if (groupName === Lexer.SKIPPED) {</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isString(groupName)) {</span><span class="s3">\n                </span><span class="s1">return groupName;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isUndefined(groupName)) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz) =&gt; {</span><span class="s3">\n            </span><span class="s1">const longerAltType = clazz.LONGER_ALT;</span><span class="s3">\n            </span><span class="s1">if (longerAltType) {</span><span class="s3">\n                </span><span class="s1">const longerAltIdxArr = isArray(longerAltType)</span><span class="s3">\n                    </span><span class="s1">? map(longerAltType, (type) =&gt; indexOf(onlyRelevantTypes, type))</span><span class="s3">\n                    </span><span class="s1">: [indexOf(onlyRelevantTypes, longerAltType)];</span><span class="s3">\n                </span><span class="s1">return longerAltIdxArr;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">patternIdxToPushMode = map(onlyRelevantTypes, (clazz) =&gt; clazz.PUSH_MODE);</span><span class="s3">\n        </span><span class="s1">patternIdxToPopMode = map(onlyRelevantTypes, (clazz) =&gt; has(clazz, </span><span class="s3">\&quot;</span><span class="s1">POP_MODE</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let patternIdxToCanLineTerminator;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">Line Terminator Handling</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);</span><span class="s3">\n        </span><span class="s1">patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) =&gt; false);</span><span class="s3">\n        </span><span class="s1">if (options.positionTracking !== </span><span class="s3">\&quot;</span><span class="s1">onlyOffset</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (has(tokType, </span><span class="s3">\&quot;</span><span class="s1">LINE_BREAKS</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">return !!tokType.LINE_BREAKS;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let patternIdxToIsCustom;</span><span class="s3">\n    </span><span class="s1">let patternIdxToShort;</span><span class="s3">\n    </span><span class="s1">let emptyGroups;</span><span class="s3">\n    </span><span class="s1">let patternIdxToConfig;</span><span class="s3">\n    </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">Misc Mapping #2</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n        </span><span class="s1">patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);</span><span class="s3">\n        </span><span class="s1">patternIdxToShort = map(allTransformedPatterns, isShortPattern);</span><span class="s3">\n        </span><span class="s1">emptyGroups = reduce(onlyRelevantTypes, (acc, clazz) =&gt; {</span><span class="s3">\n            </span><span class="s1">const groupName = clazz.GROUP;</span><span class="s3">\n            </span><span class="s1">if (isString(groupName) &amp;&amp; !(groupName === Lexer.SKIPPED)) {</span><span class="s3">\n                </span><span class="s1">acc[groupName] = [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return acc;</span><span class="s3">\n        </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">patternIdxToConfig = map(allTransformedPatterns, (x, idx) =&gt; {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">pattern: allTransformedPatterns[idx],</span><span class="s3">\n                </span><span class="s1">longerAlt: patternIdxToLongerAltIdxArr[idx],</span><span class="s3">\n                </span><span class="s1">canLineTerminator: patternIdxToCanLineTerminator[idx],</span><span class="s3">\n                </span><span class="s1">isCustom: patternIdxToIsCustom[idx],</span><span class="s3">\n                </span><span class="s1">short: patternIdxToShort[idx],</span><span class="s3">\n                </span><span class="s1">group: patternIdxToGroup[idx],</span><span class="s3">\n                </span><span class="s1">push: patternIdxToPushMode[idx],</span><span class="s3">\n                </span><span class="s1">pop: patternIdxToPopMode[idx],</span><span class="s3">\n                </span><span class="s1">tokenTypeIdx: patternIdxToType[idx],</span><span class="s3">\n                </span><span class="s1">tokenType: onlyRelevantTypes[idx],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let canBeOptimized = true;</span><span class="s3">\n    </span><span class="s1">let charCodeToPatternIdxToConfig = [];</span><span class="s3">\n    </span><span class="s1">if (!options.safeMode) {</span><span class="s3">\n        </span><span class="s1">tracer(</span><span class="s3">\&quot;</span><span class="s1">First Char Optimization</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">charCodeToPatternIdxToConfig = reduce(onlyRelevantTypes, (result, currTokType, idx) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (typeof currTokType.PATTERN === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">const charCode = currTokType.PATTERN.charCodeAt(0);</span><span class="s3">\n                    </span><span class="s1">const optimizedIdx = charCodeToOptimizedIndex(charCode);</span><span class="s3">\n                    </span><span class="s1">addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (isArray(currTokType.START_CHARS_HINT)) {</span><span class="s3">\n                    </span><span class="s1">let lastOptimizedIdx;</span><span class="s3">\n                    </span><span class="s1">forEach(currTokType.START_CHARS_HINT, (charOrInt) =&gt; {</span><span class="s3">\n                        </span><span class="s1">const charCode = typeof charOrInt === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;\n                            </span><span class="s1">? charOrInt.charCodeAt(0)</span><span class="s3">\n                            </span><span class="s1">: charOrInt;</span><span class="s3">\n                        </span><span class="s1">const currOptimizedIdx = charCodeToOptimizedIndex(charCode);</span><span class="s3">\n                        </span><span class="s1">// Avoid adding the config multiple times</span><span class="s3">\n                        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n                        </span><span class="s1">// - Difficult to check this scenario effects as it is only a performance</span><span class="s3">\n                        </span><span class="s1">//   optimization that does not change correctness</span><span class="s3">\n                        </span><span class="s1">if (lastOptimizedIdx !== currOptimizedIdx) {</span><span class="s3">\n                            </span><span class="s1">lastOptimizedIdx = currOptimizedIdx;</span><span class="s3">\n                            </span><span class="s1">addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (isRegExp(currTokType.PATTERN)) {</span><span class="s3">\n                    </span><span class="s1">if (currTokType.PATTERN.unicode) {</span><span class="s3">\n                        </span><span class="s1">canBeOptimized = false;</span><span class="s3">\n                        </span><span class="s1">if (options.ensureOptimizations) {</span><span class="s3">\n                            </span><span class="s1">PRINT_ERROR(`${failedOptimizationPrefixMsg}` +</span><span class="s3">\n                                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tUnable to analyze &lt; ${currTokType.PATTERN.toString()} &gt; pattern.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                                \&quot;\\</span><span class="s1">tThe regexp unicode flag is not currently supported by the regexp-to-ast library.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                                \&quot;\\</span><span class="s1">tThis will disable the lexer's first char optimizations.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                                \&quot;\\</span><span class="s1">tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">const optimizedCodes = getOptimizedStartCodesIndices(currTokType.PATTERN, options.ensureOptimizations);</span><span class="s3">\n                        </span><span class="s1">/* istanbul ignore if */</span><span class="s3">\n                        </span><span class="s1">// start code will only be empty given an empty regExp or failure of regexp-to-ast library</span><span class="s3">\n                        </span><span class="s1">// the first should be a different validation and the second cannot be tested.</span><span class="s3">\n                        </span><span class="s1">if (isEmpty(optimizedCodes)) {</span><span class="s3">\n                            </span><span class="s1">// we cannot understand what codes may start possible matches</span><span class="s3">\n                            </span><span class="s1">// The optimization correctness requires knowing start codes for ALL patterns.</span><span class="s3">\n                            </span><span class="s1">// Not actually sure this is an error, no debug message</span><span class="s3">\n                            </span><span class="s1">canBeOptimized = false;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">forEach(optimizedCodes, (code) =&gt; {</span><span class="s3">\n                            </span><span class="s1">addToMapOfArrays(result, code, patternIdxToConfig[idx]);</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (options.ensureOptimizations) {</span><span class="s3">\n                        </span><span class="s1">PRINT_ERROR(`${failedOptimizationPrefixMsg}` +</span><span class="s3">\n                            </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tTokenType: &lt;${currTokType.name}&gt; is using a custom token pattern without providing &lt;start_chars_hint&gt; parameter.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                            \&quot;\\</span><span class="s1">tThis will disable the lexer's first char optimizations.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                            \&quot;\\</span><span class="s1">tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">canBeOptimized = false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">}, []);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">emptyGroups: emptyGroups,</span><span class="s3">\n        </span><span class="s1">patternIdxToConfig: patternIdxToConfig,</span><span class="s3">\n        </span><span class="s1">charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,</span><span class="s3">\n        </span><span class="s1">hasCustom: hasCustom,</span><span class="s3">\n        </span><span class="s1">canBeOptimized: canBeOptimized,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validatePatterns(tokenTypes, validModesNames) {</span><span class="s3">\n    </span><span class="s1">let errors = [];</span><span class="s3">\n    </span><span class="s1">const missingResult = findMissingPatterns(tokenTypes);</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(missingResult.errors);</span><span class="s3">\n    </span><span class="s1">const invalidResult = findInvalidPatterns(missingResult.valid);</span><span class="s3">\n    </span><span class="s1">const validTokenTypes = invalidResult.valid;</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(invalidResult.errors);</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(validateRegExpPattern(validTokenTypes));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findInvalidGroupType(validTokenTypes));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findUnreachablePatterns(validTokenTypes));</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validateRegExpPattern(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">let errors = [];</span><span class="s3">\n    </span><span class="s1">const withRegExpPatterns = filter(tokenTypes, (currTokType) =&gt; isRegExp(currTokType[PATTERN]));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));</span><span class="s3">\n    </span><span class="s1">errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findMissingPatterns(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return !has(currType, PATTERN);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(tokenTypesWithMissingPattern, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Token Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- missing static 'PATTERN' property</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.MISSING_PATTERN,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const valid = difference(tokenTypes, tokenTypesWithMissingPattern);</span><span class="s3">\n    </span><span class="s1">return { errors, valid };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findInvalidPatterns(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = currType[PATTERN];</span><span class="s3">\n        </span><span class="s1">return (!isRegExp(pattern) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isFunction(pattern) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!has(pattern, </span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isString(pattern));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(tokenTypesWithInvalidPattern, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Token Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'PATTERN' can only be a RegExp, a</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot; </span><span class="s1">Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.INVALID_PATTERN,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);</span><span class="s3">\n    </span><span class="s1">return { errors, valid };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const end_of_input = /[^</span><span class="s3">\\\\</span><span class="s1">][$]/;</span><span class="s3">\n</span><span class="s1">export function findEndOfInputAnchor(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">class EndAnchorFinder extends BaseRegExpVisitor {</span><span class="s3">\n        </span><span class="s1">constructor() {</span><span class="s3">\n            </span><span class="s1">super(...arguments);</span><span class="s3">\n            </span><span class="s1">this.found = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">visitEndAnchor(node) {</span><span class="s3">\n            </span><span class="s1">this.found = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const invalidRegex = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = currType.PATTERN;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const regexpAst = getRegExpAst(pattern);</span><span class="s3">\n            </span><span class="s1">const endAnchorVisitor = new EndAnchorFinder();</span><span class="s3">\n            </span><span class="s1">endAnchorVisitor.visit(regexpAst);</span><span class="s3">\n            </span><span class="s1">return endAnchorVisitor.found;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">// old behavior in case of runtime exceptions with regexp-to-ast.</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore next - cannot ensure an error in regexp-to-ast*/</span><span class="s3">\n            </span><span class="s1">return end_of_input.test(pattern.source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(invalidRegex, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Unexpected RegExp Anchor Error:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tToken Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'PATTERN' cannot contain end of input anchor '$'</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tfor details.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findEmptyMatchRegExps(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const matchesEmptyString = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = currType.PATTERN;</span><span class="s3">\n        </span><span class="s1">return pattern.test(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(matchesEmptyString, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Token Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'PATTERN' must not match an empty string</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const start_of_input = /[^</span><span class="s3">\\\\</span><span class="s1">[][</span><span class="s3">\\</span><span class="s1">^]|^</span><span class="s3">\\</span><span class="s1">^/;</span><span class="s3">\n</span><span class="s1">export function findStartOfInputAnchor(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">class StartAnchorFinder extends BaseRegExpVisitor {</span><span class="s3">\n        </span><span class="s1">constructor() {</span><span class="s3">\n            </span><span class="s1">super(...arguments);</span><span class="s3">\n            </span><span class="s1">this.found = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">visitStartAnchor(node) {</span><span class="s3">\n            </span><span class="s1">this.found = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const invalidRegex = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = currType.PATTERN;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const regexpAst = getRegExpAst(pattern);</span><span class="s3">\n            </span><span class="s1">const startAnchorVisitor = new StartAnchorFinder();</span><span class="s3">\n            </span><span class="s1">startAnchorVisitor.visit(regexpAst);</span><span class="s3">\n            </span><span class="s1">return startAnchorVisitor.found;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">// old behavior in case of runtime exceptions with regexp-to-ast.</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore next - cannot ensure an error in regexp-to-ast*/</span><span class="s3">\n            </span><span class="s1">return start_of_input.test(pattern.source);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(invalidRegex, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Unexpected RegExp Anchor Error:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tToken Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'PATTERN' cannot contain start of input anchor '^'</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tfor details.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findUnsupportedFlags(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const invalidFlags = filter(tokenTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = currType[PATTERN];</span><span class="s3">\n        </span><span class="s1">return pattern instanceof RegExp &amp;&amp; (pattern.multiline || pattern.global);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(invalidFlags, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Token Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'PATTERN' may NOT contain global('g') or multiline('m')</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// This can only test for identical duplicate RegExps, not semantically equivalent ones.</span><span class="s3">\n</span><span class="s1">export function findDuplicatePatterns(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const found = [];</span><span class="s3">\n    </span><span class="s1">let identicalPatterns = map(tokenTypes, (outerType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return reduce(tokenTypes, (result, innerType) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (outerType.PATTERN.source === innerType.PATTERN.source &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!includes(found, innerType) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">innerType.PATTERN !== Lexer.NA) {</span><span class="s3">\n                </span><span class="s1">// this avoids duplicates in the result, each Token Type may only appear in one </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;\n                </span><span class="s1">// in essence we are creating Equivalence classes on equality relation.</span><span class="s3">\n                </span><span class="s1">found.push(innerType);</span><span class="s3">\n                </span><span class="s1">result.push(innerType);</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">identicalPatterns = compact(identicalPatterns);</span><span class="s3">\n    </span><span class="s1">const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) =&gt; {</span><span class="s3">\n        </span><span class="s1">return currIdenticalSet.length &gt; 1;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(duplicatePatterns, (setOfIdentical) =&gt; {</span><span class="s3">\n        </span><span class="s1">const tokenTypeNames = map(setOfIdentical, (currType) =&gt; {</span><span class="s3">\n            </span><span class="s1">return currType.name;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const dupPatternSrc = first(setOfIdentical).PATTERN;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: `The same RegExp pattern -&gt;${dupPatternSrc}&lt;-` +</span><span class="s3">\n                </span><span class="s1">`has been used in all of the following Token Types: ${tokenTypeNames.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)} &lt;-`,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,</span><span class="s3">\n            </span><span class="s1">tokenTypes: setOfIdentical,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findInvalidGroupType(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const invalidTypes = filter(tokenTypes, (clazz) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!has(clazz, </span><span class="s3">\&quot;</span><span class="s1">GROUP</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const group = clazz.GROUP;</span><span class="s3">\n        </span><span class="s1">return group !== Lexer.SKIPPED &amp;&amp; group !== Lexer.NA &amp;&amp; !isString(group);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(invalidTypes, (currType) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Token Type: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">currType.name +</span><span class="s3">\n                \&quot;</span><span class="s1">&lt;- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [currType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findModesThatDoNotExist(tokenTypes, validModes) {</span><span class="s3">\n    </span><span class="s1">const invalidModes = filter(tokenTypes, (clazz) =&gt; {</span><span class="s3">\n        </span><span class="s1">return (clazz.PUSH_MODE !== undefined &amp;&amp; !includes(validModes, clazz.PUSH_MODE));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(invalidModes, (tokType) =&gt; {</span><span class="s3">\n        </span><span class="s1">const msg = `Token Type: -&gt;${tokType.name}&lt;- static 'PUSH_MODE' value cannot refer to a Lexer Mode -&gt;${tokType.PUSH_MODE}&lt;-` +</span><span class="s3">\n            </span><span class="s1">`which does not exist`;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: msg,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,</span><span class="s3">\n            </span><span class="s1">tokenTypes: [tokType],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findUnreachablePatterns(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">const canBeTested = reduce(tokenTypes, (result, tokType, idx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const pattern = tokType.PATTERN;</span><span class="s3">\n        </span><span class="s1">if (pattern === Lexer.NA) {</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// a more comprehensive validation for all forms of regExps would require</span><span class="s3">\n        </span><span class="s1">// deeper regExp analysis capabilities</span><span class="s3">\n        </span><span class="s1">if (isString(pattern)) {</span><span class="s3">\n            </span><span class="s1">result.push({ str: pattern, idx, tokenType: tokType });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isRegExp(pattern) &amp;&amp; noMetaChar(pattern)) {</span><span class="s3">\n            </span><span class="s1">result.push({ str: pattern.source, idx, tokenType: tokType });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">forEach(tokenTypes, (tokType, testIdx) =&gt; {</span><span class="s3">\n        </span><span class="s1">forEach(canBeTested, ({ str, idx, tokenType }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (testIdx &lt; idx &amp;&amp; testTokenType(str, tokType.PATTERN)) {</span><span class="s3">\n                </span><span class="s1">const msg = `Token: -&gt;${tokenType.name}&lt;- can never be matched.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                    </span><span class="s1">`Because it appears AFTER the Token Type -&gt;${tokType.name}&lt;-` +</span><span class="s3">\n                    </span><span class="s1">`in the lexer's definition.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                    </span><span class="s1">`See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;</span><span class="s3">\n                </span><span class="s1">errors.push({</span><span class="s3">\n                    </span><span class="s1">message: msg,</span><span class="s3">\n                    </span><span class="s1">type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,</span><span class="s3">\n                    </span><span class="s1">tokenTypes: [tokType, tokenType],</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function testTokenType(str, pattern) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (isRegExp(pattern)) {</span><span class="s3">\n        </span><span class="s1">const regExpArray = pattern.exec(str);</span><span class="s3">\n        </span><span class="s1">return regExpArray !== null &amp;&amp; regExpArray.index === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isFunction(pattern)) {</span><span class="s3">\n        </span><span class="s1">// maintain the API of custom patterns</span><span class="s3">\n        </span><span class="s1">return pattern(str, 0, [], {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (has(pattern, </span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">// maintain the API of custom patterns</span><span class="s3">\n        </span><span class="s1">return pattern.exec(str, 0, [], {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof pattern === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return pattern === str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function noMetaChar(regExp) {</span><span class="s3">\n    </span><span class="s1">//https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp</span><span class="s3">\n    </span><span class="s1">const metaChars = [</span><span class="s3">\n        \&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;\\\\\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">return (find(metaChars, (char) =&gt; regExp.source.indexOf(char) !== -1) === undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function addStartOfInput(pattern) {</span><span class="s3">\n    </span><span class="s1">const flags = pattern.ignoreCase ? </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.</span><span class="s3">\n    </span><span class="s1">// duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)</span><span class="s3">\n    </span><span class="s1">return new RegExp(`^(?:${pattern.source})`, flags);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function addStickyFlag(pattern) {</span><span class="s3">\n    </span><span class="s1">const flags = pattern.ignoreCase ? </span><span class="s3">\&quot;</span><span class="s1">iy</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.</span><span class="s3">\n    </span><span class="s1">// duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)</span><span class="s3">\n    </span><span class="s1">return new RegExp(`${pattern.source}`, flags);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">// some run time checks to help the end users.</span><span class="s3">\n    </span><span class="s1">if (!has(lexerDefinition, DEFAULT_MODE)) {</span><span class="s3">\n        </span><span class="s1">errors.push({</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">A MultiMode Lexer cannot be initialized without a &lt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">DEFAULT_MODE +</span><span class="s3">\n                \&quot;</span><span class="s1">&gt; property in its definition</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!has(lexerDefinition, MODES)) {</span><span class="s3">\n        </span><span class="s1">errors.push({</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">A MultiMode Lexer cannot be initialized without a &lt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">MODES +</span><span class="s3">\n                \&quot;</span><span class="s1">&gt; property in its definition</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(lexerDefinition, MODES) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">has(lexerDefinition, DEFAULT_MODE) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!has(lexerDefinition.modes, lexerDefinition.defaultMode)) {</span><span class="s3">\n        </span><span class="s1">errors.push({</span><span class="s3">\n            </span><span class="s1">message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: &lt;${lexerDefinition.defaultMode}&gt;` +</span><span class="s3">\n                </span><span class="s1">`which does not exist</span><span class="s3">\\</span><span class="s1">n`,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(lexerDefinition, MODES)) {</span><span class="s3">\n        </span><span class="s1">forEach(lexerDefinition.modes, (currModeValue, currModeName) =&gt; {</span><span class="s3">\n            </span><span class="s1">forEach(currModeValue, (currTokType, currIdx) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (isUndefined(currTokType)) {</span><span class="s3">\n                    </span><span class="s1">errors.push({</span><span class="s3">\n                        </span><span class="s1">message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +</span><span class="s3">\n                            </span><span class="s1">`&lt;${currModeName}&gt; at index: &lt;${currIdx}&gt;</span><span class="s3">\\</span><span class="s1">n`,</span><span class="s3">\n                        </span><span class="s1">type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (has(currTokType, </span><span class="s3">\&quot;</span><span class="s1">LONGER_ALT</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">const longerAlt = isArray(currTokType.LONGER_ALT)</span><span class="s3">\n                        </span><span class="s1">? currTokType.LONGER_ALT</span><span class="s3">\n                        </span><span class="s1">: [currTokType.LONGER_ALT];</span><span class="s3">\n                    </span><span class="s1">forEach(longerAlt, (currLongerAlt) =&gt; {</span><span class="s3">\n                        </span><span class="s1">if (!isUndefined(currLongerAlt) &amp;&amp;</span><span class="s3">\n                            </span><span class="s1">!includes(currModeValue, currLongerAlt)) {</span><span class="s3">\n                            </span><span class="s1">errors.push({</span><span class="s3">\n                                </span><span class="s1">message: `A MultiMode Lexer cannot be initialized with a longer_alt &lt;${currLongerAlt.name}&gt; on token &lt;${currTokType.name}&gt; outside of mode &lt;${currModeName}&gt;</span><span class="s3">\\</span><span class="s1">n`,</span><span class="s3">\n                                </span><span class="s1">type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {</span><span class="s3">\n    </span><span class="s1">const warnings = [];</span><span class="s3">\n    </span><span class="s1">let hasAnyLineBreak = false;</span><span class="s3">\n    </span><span class="s1">const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));</span><span class="s3">\n    </span><span class="s1">const concreteTokenTypes = reject(allTokenTypes, (currType) =&gt; currType[PATTERN] === Lexer.NA);</span><span class="s3">\n    </span><span class="s1">const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);</span><span class="s3">\n    </span><span class="s1">if (trackLines) {</span><span class="s3">\n        </span><span class="s1">forEach(concreteTokenTypes, (tokType) =&gt; {</span><span class="s3">\n            </span><span class="s1">const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);</span><span class="s3">\n            </span><span class="s1">if (currIssue !== false) {</span><span class="s3">\n                </span><span class="s1">const message = buildLineBreakIssueMessage(tokType, currIssue);</span><span class="s3">\n                </span><span class="s1">const warningDescriptor = {</span><span class="s3">\n                    </span><span class="s1">message,</span><span class="s3">\n                    </span><span class="s1">type: currIssue.issue,</span><span class="s3">\n                    </span><span class="s1">tokenType: tokType,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">warnings.push(warningDescriptor);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// we don't want to attempt to scan if the user explicitly specified the line_breaks option.</span><span class="s3">\n                </span><span class="s1">if (has(tokType, </span><span class="s3">\&quot;</span><span class="s1">LINE_BREAKS</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">if (tokType.LINE_BREAKS === true) {</span><span class="s3">\n                        </span><span class="s1">hasAnyLineBreak = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (canMatchCharCode(terminatorCharCodes, tokType.PATTERN)) {</span><span class="s3">\n                        </span><span class="s1">hasAnyLineBreak = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (trackLines &amp;&amp; !hasAnyLineBreak) {</span><span class="s3">\n        </span><span class="s1">warnings.push({</span><span class="s3">\n            </span><span class="s1">message: </span><span class="s3">\&quot;</span><span class="s1">Warning: No LINE_BREAKS Found.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tThis Lexer has been defined to track line and column information,</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tBut none of the Token Types can be identified as matching a line terminator.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS </span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tfor details.</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return warnings;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function cloneEmptyGroups(emptyGroups) {</span><span class="s3">\n    </span><span class="s1">const clonedResult = {};</span><span class="s3">\n    </span><span class="s1">const groupKeys = keys(emptyGroups);</span><span class="s3">\n    </span><span class="s1">forEach(groupKeys, (currKey) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currGroupValue = emptyGroups[currKey];</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n        </span><span class="s1">if (isArray(currGroupValue)) {</span><span class="s3">\n            </span><span class="s1">clonedResult[currKey] = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return clonedResult;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// TODO: refactor to avoid duplication</span><span class="s3">\n</span><span class="s1">export function isCustomPattern(tokenType) {</span><span class="s3">\n    </span><span class="s1">const pattern = tokenType.PATTERN;</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (isRegExp(pattern)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isFunction(pattern)) {</span><span class="s3">\n        </span><span class="s1">// CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (has(pattern, </span><span class="s3">\&quot;</span><span class="s1">exec</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">// ICustomPattern</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isString(pattern)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isShortPattern(pattern) {</span><span class="s3">\n    </span><span class="s1">if (isString(pattern) &amp;&amp; pattern.length === 1) {</span><span class="s3">\n        </span><span class="s1">return pattern.charCodeAt(0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Faster than using a RegExp for default newline detection during lexing.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const LineTerminatorOptimizedTester = {</span><span class="s3">\n    </span><span class="s1">// implements /</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?/g.test</span><span class="s3">\n    </span><span class="s1">test: function (text) {</span><span class="s3">\n        </span><span class="s1">const len = text.length;</span><span class="s3">\n        </span><span class="s1">for (let i = this.lastIndex; i &lt; len; i++) {</span><span class="s3">\n            </span><span class="s1">const c = text.charCodeAt(i);</span><span class="s3">\n            </span><span class="s1">if (c === 10) {</span><span class="s3">\n                </span><span class="s1">this.lastIndex = i + 1;</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (c === 13) {</span><span class="s3">\n                </span><span class="s1">if (text.charCodeAt(i + 1) === 10) {</span><span class="s3">\n                    </span><span class="s1">this.lastIndex = i + 2;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.lastIndex = i + 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">lastIndex: 0,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {</span><span class="s3">\n    </span><span class="s1">if (has(tokType, </span><span class="s3">\&quot;</span><span class="s1">LINE_BREAKS</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">// if the user explicitly declared the line_breaks option we will respect their choice</span><span class="s3">\n        </span><span class="s1">// and assume it is correct.</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n        </span><span class="s1">if (isRegExp(tokType.PATTERN)) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">// TODO: why is the casting suddenly needed?</span><span class="s3">\n                </span><span class="s1">canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">/* istanbul ignore next - to test this we would have to mock &lt;canMatchCharCode&gt; to throw an error */</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,</span><span class="s3">\n                    </span><span class="s1">errMsg: e.message,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isString(tokType.PATTERN)) {</span><span class="s3">\n            </span><span class="s1">// string literal patterns can always be analyzed to detect line terminator usage</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isCustomPattern(tokType)) {</span><span class="s3">\n            </span><span class="s1">// custom token types</span><span class="s3">\n            </span><span class="s1">return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildLineBreakIssueMessage(tokType, details) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\&quot;</span><span class="s1">Warning: unable to identify line terminator usage in pattern.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tThe problem is in the &lt;${tokType.name}&gt; Token Type</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">t Root cause: ${details.errMsg}.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            \&quot;\\</span><span class="s1">tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {</span><span class="s3">\n        </span><span class="s1">return (</span><span class="s3">\&quot;</span><span class="s1">Warning: A Custom Token Pattern should specify the &lt;line_breaks&gt; option.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">tThe problem is in the &lt;${tokType.name}&gt; Token Type</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            \&quot;\\</span><span class="s1">tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getCharCodes(charsOrCodes) {</span><span class="s3">\n    </span><span class="s1">const charCodes = map(charsOrCodes, (numOrString) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (isString(numOrString)) {</span><span class="s3">\n            </span><span class="s1">return numOrString.charCodeAt(0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return numOrString;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return charCodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addToMapOfArrays(map, key, value) {</span><span class="s3">\n    </span><span class="s1">if (map[key] === undefined) {</span><span class="s3">\n        </span><span class="s1">map[key] = [value];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">map[key].push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const minOptimizationVal = 256;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We are mapping charCode above ASCI (256) into buckets each in the size of 256.</span><span class="s3">\n </span><span class="s1">* This is because ASCI are the most common start chars so each one of those will get its own</span><span class="s3">\n </span><span class="s1">* possible token configs vector.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Tokens starting with charCodes </span><span class="s3">\&quot;</span><span class="s1">above</span><span class="s3">\&quot; </span><span class="s1">ASCI are uncommon, so we can </span><span class="s3">\&quot;</span><span class="s1">afford</span><span class="s3">\&quot;\n </span><span class="s1">* to place these into buckets of possible token configs, What we gain from</span><span class="s3">\n </span><span class="s1">* this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'</span><span class="s3">\n </span><span class="s1">* which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).</span><span class="s3">\n </span><span class="s1">* Our 'charCodeToPatternIdxToConfig' max size will now be:</span><span class="s3">\n </span><span class="s1">* 256 + (2^16 / 2^8) - 1 === 511</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* note the hack for fast division integer part extraction</span><span class="s3">\n </span><span class="s1">* See: https://stackoverflow.com/a/4228528</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let charCodeToOptimizedIdxMap = [];</span><span class="s3">\n</span><span class="s1">export function charCodeToOptimizedIndex(charCode) {</span><span class="s3">\n    </span><span class="s1">return charCode &lt; minOptimizationVal</span><span class="s3">\n        </span><span class="s1">? charCode</span><span class="s3">\n        </span><span class="s1">: charCodeToOptimizedIdxMap[charCode];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is a compromise between cold start / hot running performance</span><span class="s3">\n </span><span class="s1">* Creating this array takes ~3ms on a modern machine,</span><span class="s3">\n </span><span class="s1">* But if we perform the computation at runtime as needed the CSS Lexer benchmark</span><span class="s3">\n </span><span class="s1">* performance degrades by ~10%</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* TODO: Perhaps it should be lazy initialized only if a charCode &gt; 255 is used.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function initCharCodeToOptimizedIndexMap() {</span><span class="s3">\n    </span><span class="s1">if (isEmpty(charCodeToOptimizedIdxMap)) {</span><span class="s3">\n        </span><span class="s1">charCodeToOptimizedIdxMap = new Array(65536);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; 65536; i++) {</span><span class="s3">\n            </span><span class="s1">charCodeToOptimizedIdxMap[i] = i &gt; 255 ? 255 + ~~(i / 255) : i;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lexer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export function timer(func) {</span><span class="s3">\n    </span><span class="s1">const start = new Date().getTime();</span><span class="s3">\n    </span><span class="s1">const val = func();</span><span class="s3">\n    </span><span class="s1">const end = new Date().getTime();</span><span class="s3">\n    </span><span class="s1">const total = end - start;</span><span class="s3">\n    </span><span class="s1">return { time: total, value: val };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=timer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { clone, compact, difference, flatten, forEach, has, includes, isArray, isEmpty, map, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function tokenStructuredMatcher(tokInstance, tokConstructor) {</span><span class="s3">\n    </span><span class="s1">const instanceType = tokInstance.tokenTypeIdx;</span><span class="s3">\n    </span><span class="s1">if (instanceType === tokConstructor.tokenTypeIdx) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return (tokConstructor.isParent === true &amp;&amp;</span><span class="s3">\n            </span><span class="s1">tokConstructor.categoryMatchesMap[instanceType] === true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Optimized tokenMatcher in case our grammar does not use token categories</span><span class="s3">\n</span><span class="s1">// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead</span><span class="s3">\n</span><span class="s1">export function tokenStructuredMatcherNoCategories(token, tokType) {</span><span class="s3">\n    </span><span class="s1">return token.tokenTypeIdx === tokType.tokenTypeIdx;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export let tokenShortNameIdx = 1;</span><span class="s3">\n</span><span class="s1">export const tokenIdxToClass = {};</span><span class="s3">\n</span><span class="s1">export function augmentTokenTypes(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">// collect the parent Token Types as well.</span><span class="s3">\n    </span><span class="s1">const tokenTypesAndParents = expandCategories(tokenTypes);</span><span class="s3">\n    </span><span class="s1">// add required tokenType and categoryMatches properties</span><span class="s3">\n    </span><span class="s1">assignTokenDefaultProps(tokenTypesAndParents);</span><span class="s3">\n    </span><span class="s1">// fill up the categoryMatches</span><span class="s3">\n    </span><span class="s1">assignCategoriesMapProp(tokenTypesAndParents);</span><span class="s3">\n    </span><span class="s1">assignCategoriesTokensProp(tokenTypesAndParents);</span><span class="s3">\n    </span><span class="s1">forEach(tokenTypesAndParents, (tokType) =&gt; {</span><span class="s3">\n        </span><span class="s1">tokType.isParent = tokType.categoryMatches.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function expandCategories(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">let result = clone(tokenTypes);</span><span class="s3">\n    </span><span class="s1">let categories = tokenTypes;</span><span class="s3">\n    </span><span class="s1">let searching = true;</span><span class="s3">\n    </span><span class="s1">while (searching) {</span><span class="s3">\n        </span><span class="s1">categories = compact(flatten(map(categories, (currTokType) =&gt; currTokType.CATEGORIES)));</span><span class="s3">\n        </span><span class="s1">const newCategories = difference(categories, result);</span><span class="s3">\n        </span><span class="s1">result = result.concat(newCategories);</span><span class="s3">\n        </span><span class="s1">if (isEmpty(newCategories)) {</span><span class="s3">\n            </span><span class="s1">searching = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">categories = newCategories;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assignTokenDefaultProps(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">forEach(tokenTypes, (currTokType) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!hasShortKeyProperty(currTokType)) {</span><span class="s3">\n            </span><span class="s1">tokenIdxToClass[tokenShortNameIdx] = currTokType;</span><span class="s3">\n            </span><span class="s1">currTokType.tokenTypeIdx = tokenShortNameIdx++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// CATEGORIES? : TokenType | TokenType[]</span><span class="s3">\n        </span><span class="s1">if (hasCategoriesProperty(currTokType) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!isArray(currTokType.CATEGORIES)</span><span class="s3">\n        </span><span class="s1">// &amp;&amp;</span><span class="s3">\n        </span><span class="s1">// !isUndefined(currTokType.CATEGORIES.PATTERN)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">currTokType.CATEGORIES = [currTokType.CATEGORIES];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!hasCategoriesProperty(currTokType)) {</span><span class="s3">\n            </span><span class="s1">currTokType.CATEGORIES = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!hasExtendingTokensTypesProperty(currTokType)) {</span><span class="s3">\n            </span><span class="s1">currTokType.categoryMatches = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!hasExtendingTokensTypesMapProperty(currTokType)) {</span><span class="s3">\n            </span><span class="s1">currTokType.categoryMatchesMap = {};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assignCategoriesTokensProp(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">forEach(tokenTypes, (currTokType) =&gt; {</span><span class="s3">\n        </span><span class="s1">// avoid duplications</span><span class="s3">\n        </span><span class="s1">currTokType.categoryMatches = [];</span><span class="s3">\n        </span><span class="s1">forEach(currTokType.categoryMatchesMap, (val, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assignCategoriesMapProp(tokenTypes) {</span><span class="s3">\n    </span><span class="s1">forEach(tokenTypes, (currTokType) =&gt; {</span><span class="s3">\n        </span><span class="s1">singleAssignCategoriesToksMap([], currTokType);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function singleAssignCategoriesToksMap(path, nextNode) {</span><span class="s3">\n    </span><span class="s1">forEach(path, (pathNode) =&gt; {</span><span class="s3">\n        </span><span class="s1">nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">forEach(nextNode.CATEGORIES, (nextCategory) =&gt; {</span><span class="s3">\n        </span><span class="s1">const newPath = path.concat(nextNode);</span><span class="s3">\n        </span><span class="s1">// avoids infinite loops due to cyclic categories.</span><span class="s3">\n        </span><span class="s1">if (!includes(newPath, nextCategory)) {</span><span class="s3">\n            </span><span class="s1">singleAssignCategoriesToksMap(newPath, nextCategory);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function hasShortKeyProperty(tokType) {</span><span class="s3">\n    </span><span class="s1">return has(tokType, </span><span class="s3">\&quot;</span><span class="s1">tokenTypeIdx</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function hasCategoriesProperty(tokType) {</span><span class="s3">\n    </span><span class="s1">return has(tokType, </span><span class="s3">\&quot;</span><span class="s1">CATEGORIES</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function hasExtendingTokensTypesProperty(tokType) {</span><span class="s3">\n    </span><span class="s1">return has(tokType, </span><span class="s3">\&quot;</span><span class="s1">categoryMatches</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function hasExtendingTokensTypesMapProperty(tokType) {</span><span class="s3">\n    </span><span class="s1">return has(tokType, </span><span class="s3">\&quot;</span><span class="s1">categoryMatchesMap</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isTokenType(tokType) {</span><span class="s3">\n    </span><span class="s1">return has(tokType, </span><span class="s3">\&quot;</span><span class="s1">tokenTypeIdx</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=tokens.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export const defaultLexerErrorProvider = {</span><span class="s3">\n    </span><span class="s1">buildUnableToPopLexerModeMessage(token) {</span><span class="s3">\n        </span><span class="s1">return `Unable to pop Lexer Mode after encountering Token -&gt;${token.image}&lt;- The Mode Stack is empty`;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {</span><span class="s3">\n        </span><span class="s1">return (`unexpected character: -&gt;${fullText.charAt(startOffset)}&lt;- at offset: ${startOffset},` + ` skipped ${length} characters.`);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lexer_errors_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { analyzeTokenTypes, charCodeToOptimizedIndex, cloneEmptyGroups, DEFAULT_MODE, LineTerminatorOptimizedTester, performRuntimeChecks, performWarningRuntimeChecks, SUPPORT_STICKY, validatePatterns, } from </span><span class="s3">\&quot;</span><span class="s1">./lexer.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { assign, clone, forEach, identity, isArray, isEmpty, isUndefined, keys, last, map, noop, reduce, reject, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { PRINT_WARNING, timer, toFastProperties } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { augmentTokenTypes } from </span><span class="s3">\&quot;</span><span class="s1">./tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defaultLexerErrorProvider } from </span><span class="s3">\&quot;</span><span class="s1">./lexer_errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { clearRegExpParserCache } from </span><span class="s3">\&quot;</span><span class="s1">./reg_exp_parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export var LexerDefinitionErrorType;</span><span class="s3">\n</span><span class="s1">(function (LexerDefinitionErrorType) {</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">MISSING_PATTERN</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">MISSING_PATTERN</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">INVALID_PATTERN</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">INVALID_PATTERN</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">EOI_ANCHOR_FOUND</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">EOI_ANCHOR_FOUND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">UNSUPPORTED_FLAGS_FOUND</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">UNSUPPORTED_FLAGS_FOUND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_PATTERNS_FOUND</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_PATTERNS_FOUND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">INVALID_GROUP_TYPE_FOUND</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">INVALID_GROUP_TYPE_FOUND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">PUSH_MODE_DOES_NOT_EXIST</span><span class="s3">\&quot;</span><span class="s1">] = 6] = </span><span class="s3">\&quot;</span><span class="s1">PUSH_MODE_DOES_NOT_EXIST</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE</span><span class="s3">\&quot;</span><span class="s1">] = 7] = </span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY</span><span class="s3">\&quot;</span><span class="s1">] = 8] = </span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST</span><span class="s3">\&quot;</span><span class="s1">] = 9] = </span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED</span><span class="s3">\&quot;</span><span class="s1">] = 10] = </span><span class="s3">\&quot;</span><span class="s1">LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">SOI_ANCHOR_FOUND</span><span class="s3">\&quot;</span><span class="s1">] = 11] = </span><span class="s3">\&quot;</span><span class="s1">SOI_ANCHOR_FOUND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">EMPTY_MATCH_PATTERN</span><span class="s3">\&quot;</span><span class="s1">] = 12] = </span><span class="s3">\&quot;</span><span class="s1">EMPTY_MATCH_PATTERN</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">NO_LINE_BREAKS_FLAGS</span><span class="s3">\&quot;</span><span class="s1">] = 13] = </span><span class="s3">\&quot;</span><span class="s1">NO_LINE_BREAKS_FLAGS</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">UNREACHABLE_PATTERN</span><span class="s3">\&quot;</span><span class="s1">] = 14] = </span><span class="s3">\&quot;</span><span class="s1">UNREACHABLE_PATTERN</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">IDENTIFY_TERMINATOR</span><span class="s3">\&quot;</span><span class="s1">] = 15] = </span><span class="s3">\&quot;</span><span class="s1">IDENTIFY_TERMINATOR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">CUSTOM_LINE_BREAK</span><span class="s3">\&quot;</span><span class="s1">] = 16] = </span><span class="s3">\&quot;</span><span class="s1">CUSTOM_LINE_BREAK</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">LexerDefinitionErrorType[LexerDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE</span><span class="s3">\&quot;</span><span class="s1">] = 17] = </span><span class="s3">\&quot;</span><span class="s1">MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));</span><span class="s3">\n</span><span class="s1">const DEFAULT_LEXER_CONFIG = {</span><span class="s3">\n    </span><span class="s1">deferDefinitionErrorsHandling: false,</span><span class="s3">\n    </span><span class="s1">positionTracking: </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">lineTerminatorsPattern: /</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?/g,</span><span class="s3">\n    </span><span class="s1">lineTerminatorCharacters: [</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">ensureOptimizations: false,</span><span class="s3">\n    </span><span class="s1">safeMode: false,</span><span class="s3">\n    </span><span class="s1">errorMessageProvider: defaultLexerErrorProvider,</span><span class="s3">\n    </span><span class="s1">traceInitPerf: false,</span><span class="s3">\n    </span><span class="s1">skipValidations: false,</span><span class="s3">\n    </span><span class="s1">recoveryEnabled: true,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Object.freeze(DEFAULT_LEXER_CONFIG);</span><span class="s3">\n</span><span class="s1">export class Lexer {</span><span class="s3">\n    </span><span class="s1">constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {</span><span class="s3">\n        </span><span class="s1">this.lexerDefinition = lexerDefinition;</span><span class="s3">\n        </span><span class="s1">this.lexerDefinitionErrors = [];</span><span class="s3">\n        </span><span class="s1">this.lexerDefinitionWarning = [];</span><span class="s3">\n        </span><span class="s1">this.patternIdxToConfig = {};</span><span class="s3">\n        </span><span class="s1">this.charCodeToPatternIdxToConfig = {};</span><span class="s3">\n        </span><span class="s1">this.modes = [];</span><span class="s3">\n        </span><span class="s1">this.emptyGroups = {};</span><span class="s3">\n        </span><span class="s1">this.trackStartLines = true;</span><span class="s3">\n        </span><span class="s1">this.trackEndLines = true;</span><span class="s3">\n        </span><span class="s1">this.hasCustom = false;</span><span class="s3">\n        </span><span class="s1">this.canModeBeOptimized = {};</span><span class="s3">\n        </span><span class="s1">// Duplicated from the parser's perf trace trait to allow future extraction</span><span class="s3">\n        </span><span class="s1">// of the lexer to a separate package.</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT = (phaseDesc, phaseImpl) =&gt; {</span><span class="s3">\n            </span><span class="s1">// No need to optimize this using NOOP pattern because</span><span class="s3">\n            </span><span class="s1">// It is not called in a hot spot...</span><span class="s3">\n            </span><span class="s1">if (this.traceInitPerf === true) {</span><span class="s3">\n                </span><span class="s1">this.traceInitIndent++;</span><span class="s3">\n                </span><span class="s1">const indent = new Array(this.traceInitIndent + 1).join(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (this.traceInitIndent &lt; this.traceInitMaxIdent) {</span><span class="s3">\n                    </span><span class="s1">console.log(`${indent}--&gt; &lt;${phaseDesc}&gt;`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { time, value } = timer(phaseImpl);</span><span class="s3">\n                </span><span class="s1">/* istanbul ignore next - Difficult to reproduce specific performance behavior (&gt;10ms) in tests */</span><span class="s3">\n                </span><span class="s1">const traceMethod = time &gt; 10 ? console.warn : console.log;</span><span class="s3">\n                </span><span class="s1">if (this.traceInitIndent &lt; this.traceInitMaxIdent) {</span><span class="s3">\n                    </span><span class="s1">traceMethod(`${indent}&lt;-- &lt;${phaseDesc}&gt; time: ${time}ms`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.traceInitIndent--;</span><span class="s3">\n                </span><span class="s1">return value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return phaseImpl();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (typeof config === </span><span class="s3">\&quot;</span><span class="s1">boolean</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">The second argument to the Lexer constructor is now an ILexerConfig Object.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;</span><span class="s1">a boolean 2nd argument is no longer supported</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// todo: defaults func?</span><span class="s3">\n        </span><span class="s1">this.config = assign({}, DEFAULT_LEXER_CONFIG, config);</span><span class="s3">\n        </span><span class="s1">const traceInitVal = this.config.traceInitPerf;</span><span class="s3">\n        </span><span class="s1">if (traceInitVal === true) {</span><span class="s3">\n            </span><span class="s1">this.traceInitMaxIdent = Infinity;</span><span class="s3">\n            </span><span class="s1">this.traceInitPerf = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (typeof traceInitVal === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">this.traceInitMaxIdent = traceInitVal;</span><span class="s3">\n            </span><span class="s1">this.traceInitPerf = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.traceInitIndent = -1;</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Lexer Constructor</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">let actualDefinition;</span><span class="s3">\n            </span><span class="s1">let hasOnlySingleMode = true;</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Lexer Config handling</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.config.lineTerminatorsPattern ===</span><span class="s3">\n                    </span><span class="s1">DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {</span><span class="s3">\n                    </span><span class="s1">// optimized built-in implementation for the defaults definition of lineTerminators</span><span class="s3">\n                    </span><span class="s1">this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (this.config.lineTerminatorCharacters ===</span><span class="s3">\n                        </span><span class="s1">DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {</span><span class="s3">\n                        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Error: Missing &lt;lineTerminatorCharacters&gt; property on the Lexer config.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                            \&quot;\\</span><span class="s1">tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (config.safeMode &amp;&amp; config.ensureOptimizations) {</span><span class="s3">\n                    </span><span class="s1">throw Error('</span><span class="s3">\&quot;</span><span class="s1">safeMode</span><span class="s3">\&quot; </span><span class="s1">and </span><span class="s3">\&quot;</span><span class="s1">ensureOptimizations</span><span class="s3">\&quot; </span><span class="s1">flags are mutually exclusive.');</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);</span><span class="s3">\n                </span><span class="s1">this.trackEndLines = /full/i.test(this.config.positionTracking);</span><span class="s3">\n                </span><span class="s1">// Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.</span><span class="s3">\n                </span><span class="s1">if (isArray(lexerDefinition)) {</span><span class="s3">\n                    </span><span class="s1">actualDefinition = {</span><span class="s3">\n                        </span><span class="s1">modes: { defaultMode: clone(lexerDefinition) },</span><span class="s3">\n                        </span><span class="s1">defaultMode: DEFAULT_MODE,</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// no conversion needed, input should already be a IMultiModeLexerDefinition</span><span class="s3">\n                    </span><span class="s1">hasOnlySingleMode = false;</span><span class="s3">\n                    </span><span class="s1">actualDefinition = clone(lexerDefinition);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (this.config.skipValidations === false) {</span><span class="s3">\n                </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">performRuntimeChecks</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(performRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">performWarningRuntimeChecks</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(performWarningRuntimeChecks(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// for extra robustness to avoid throwing an none informative error message</span><span class="s3">\n            </span><span class="s1">actualDefinition.modes = actualDefinition.modes</span><span class="s3">\n                </span><span class="s1">? actualDefinition.modes</span><span class="s3">\n                </span><span class="s1">: {};</span><span class="s3">\n            </span><span class="s1">// an error of undefined TokenTypes will be detected in </span><span class="s3">\&quot;</span><span class="s1">performRuntimeChecks</span><span class="s3">\&quot; </span><span class="s1">above.</span><span class="s3">\n            </span><span class="s1">// this transformation is to increase robustness in the case of partially invalid lexer definition.</span><span class="s3">\n            </span><span class="s1">forEach(actualDefinition.modes, (currModeValue, currModeName) =&gt; {</span><span class="s3">\n                </span><span class="s1">actualDefinition.modes[currModeName] = reject(currModeValue, (currTokType) =&gt; isUndefined(currTokType));</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const allModeNames = keys(actualDefinition.modes);</span><span class="s3">\n            </span><span class="s1">forEach(actualDefinition.modes, (currModDef, currModName) =&gt; {</span><span class="s3">\n                </span><span class="s1">this.TRACE_INIT(`Mode: &lt;${currModName}&gt; processing`, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.modes.push(currModName);</span><span class="s3">\n                    </span><span class="s1">if (this.config.skipValidations === false) {</span><span class="s3">\n                        </span><span class="s1">this.TRACE_INIT(`validatePatterns`, () =&gt; {</span><span class="s3">\n                            </span><span class="s1">this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(validatePatterns(currModDef, allModeNames));</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// If definition errors were encountered, the analysis phase may fail unexpectedly/</span><span class="s3">\n                    </span><span class="s1">// Considering a lexer with definition errors may never be used, there is no point</span><span class="s3">\n                    </span><span class="s1">// to performing the analysis anyhow...</span><span class="s3">\n                    </span><span class="s1">if (isEmpty(this.lexerDefinitionErrors)) {</span><span class="s3">\n                        </span><span class="s1">augmentTokenTypes(currModDef);</span><span class="s3">\n                        </span><span class="s1">let currAnalyzeResult;</span><span class="s3">\n                        </span><span class="s1">this.TRACE_INIT(`analyzeTokenTypes`, () =&gt; {</span><span class="s3">\n                            </span><span class="s1">currAnalyzeResult = analyzeTokenTypes(currModDef, {</span><span class="s3">\n                                </span><span class="s1">lineTerminatorCharacters: this.config.lineTerminatorCharacters,</span><span class="s3">\n                                </span><span class="s1">positionTracking: config.positionTracking,</span><span class="s3">\n                                </span><span class="s1">ensureOptimizations: config.ensureOptimizations,</span><span class="s3">\n                                </span><span class="s1">safeMode: config.safeMode,</span><span class="s3">\n                                </span><span class="s1">tracer: this.TRACE_INIT,</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">this.patternIdxToConfig[currModName] =</span><span class="s3">\n                            </span><span class="s1">currAnalyzeResult.patternIdxToConfig;</span><span class="s3">\n                        </span><span class="s1">this.charCodeToPatternIdxToConfig[currModName] =</span><span class="s3">\n                            </span><span class="s1">currAnalyzeResult.charCodeToPatternIdxToConfig;</span><span class="s3">\n                        </span><span class="s1">this.emptyGroups = assign({}, this.emptyGroups, currAnalyzeResult.emptyGroups);</span><span class="s3">\n                        </span><span class="s1">this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;</span><span class="s3">\n                        </span><span class="s1">this.canModeBeOptimized[currModName] =</span><span class="s3">\n                            </span><span class="s1">currAnalyzeResult.canBeOptimized;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.defaultMode = actualDefinition.defaultMode;</span><span class="s3">\n            </span><span class="s1">if (!isEmpty(this.lexerDefinitionErrors) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!this.config.deferDefinitionErrorsHandling) {</span><span class="s3">\n                </span><span class="s1">const allErrMessages = map(this.lexerDefinitionErrors, (error) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return error.message;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">const allErrMessagesString = allErrMessages.join(</span><span class="s3">\&quot;</span><span class="s1">-----------------------</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Errors detected in definition of Lexer:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ allErrMessagesString);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Only print warning if there are no errors, This will avoid pl</span><span class="s3">\n            </span><span class="s1">forEach(this.lexerDefinitionWarning, (warningDescriptor) =&gt; {</span><span class="s3">\n                </span><span class="s1">PRINT_WARNING(warningDescriptor.message);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Choosing sub-methods implementations</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">// Choose the relevant internal implementations for this specific parser.</span><span class="s3">\n                </span><span class="s1">// These implementations should be in-lined by the JavaScript engine</span><span class="s3">\n                </span><span class="s1">// to provide optimal performance in each scenario.</span><span class="s3">\n                </span><span class="s1">if (SUPPORT_STICKY) {</span><span class="s3">\n                    </span><span class="s1">this.chopInput = identity;</span><span class="s3">\n                    </span><span class="s1">this.match = this.matchWithTest;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.updateLastIndex = noop;</span><span class="s3">\n                    </span><span class="s1">this.match = this.matchWithExec;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (hasOnlySingleMode) {</span><span class="s3">\n                    </span><span class="s1">this.handleModes = noop;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this.trackStartLines === false) {</span><span class="s3">\n                    </span><span class="s1">this.computeNewColumn = identity;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this.trackEndLines === false) {</span><span class="s3">\n                    </span><span class="s1">this.updateTokenEndLineColumnLocation = noop;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (/full/i.test(this.config.positionTracking)) {</span><span class="s3">\n                    </span><span class="s1">this.createTokenInstance = this.createFullToken;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (/onlyStart/i.test(this.config.positionTracking)) {</span><span class="s3">\n                    </span><span class="s1">this.createTokenInstance = this.createStartOnlyToken;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (/onlyOffset/i.test(this.config.positionTracking)) {</span><span class="s3">\n                    </span><span class="s1">this.createTokenInstance = this.createOffsetOnlyToken;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw Error(`Invalid &lt;positionTracking&gt; config option: </span><span class="s3">\&quot;</span><span class="s1">${this.config.positionTracking}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this.hasCustom) {</span><span class="s3">\n                    </span><span class="s1">this.addToken = this.addTokenUsingPush;</span><span class="s3">\n                    </span><span class="s1">this.handlePayload = this.handlePayloadWithCustom;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.addToken = this.addTokenUsingMemberAccess;</span><span class="s3">\n                    </span><span class="s1">this.handlePayload = this.handlePayloadNoCustom;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Failed Optimization Warnings</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">const unOptimizedModes = reduce(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (canBeOptimized === false) {</span><span class="s3">\n                        </span><span class="s1">cannotBeOptimized.push(modeName);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return cannotBeOptimized;</span><span class="s3">\n                </span><span class="s1">}, []);</span><span class="s3">\n                </span><span class="s1">if (config.ensureOptimizations &amp;&amp; !isEmpty(unOptimizedModes)) {</span><span class="s3">\n                    </span><span class="s1">throw Error(`Lexer Modes: &lt; ${unOptimizedModes.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)} &gt; cannot be optimized.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                        </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">t Disable the </span><span class="s3">\&quot;</span><span class="s1">ensureOptimizations</span><span class="s3">\&quot; </span><span class="s1">lexer config flag to silently ignore this and run the lexer in an un-optimized mode.</span><span class="s3">\\</span><span class="s1">n' +</span><span class="s3">\n                        \&quot;\\</span><span class="s1">t Or inspect the console log for details on how to resolve these issues.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">clearRegExpParserCache</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">clearRegExpParserCache();</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">toFastProperties</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">toFastProperties(this);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tokenize(text, initialMode = this.defaultMode) {</span><span class="s3">\n        </span><span class="s1">if (!isEmpty(this.lexerDefinitionErrors)) {</span><span class="s3">\n            </span><span class="s1">const allErrMessages = map(this.lexerDefinitionErrors, (error) =&gt; {</span><span class="s3">\n                </span><span class="s1">return error.message;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const allErrMessagesString = allErrMessages.join(</span><span class="s3">\&quot;</span><span class="s1">-----------------------</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Unable to Tokenize because Errors detected in definition of Lexer:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                </span><span class="s1">allErrMessagesString);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.tokenizeInternal(text, initialMode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// There is quite a bit of duplication between this and </span><span class="s3">\&quot;</span><span class="s1">tokenizeInternalLazy</span><span class="s3">\&quot;\n    </span><span class="s1">// This is intentional due to performance considerations.</span><span class="s3">\n    </span><span class="s1">// this method also used quite a bit of `!` none null assertions because it is too optimized</span><span class="s3">\n    </span><span class="s1">// for `tsc` to always understand it is </span><span class="s3">\&quot;</span><span class="s1">safe</span><span class="s3">\&quot;\n    </span><span class="s1">tokenizeInternal(text, initialMode) {</span><span class="s3">\n        </span><span class="s1">let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;</span><span class="s3">\n        </span><span class="s1">const orgText = text;</span><span class="s3">\n        </span><span class="s1">const orgLength = orgText.length;</span><span class="s3">\n        </span><span class="s1">let offset = 0;</span><span class="s3">\n        </span><span class="s1">let matchedTokensIndex = 0;</span><span class="s3">\n        </span><span class="s1">// initializing the tokensArray to the </span><span class="s3">\&quot;</span><span class="s1">guessed</span><span class="s3">\&quot; </span><span class="s1">size.</span><span class="s3">\n        </span><span class="s1">// guessing too little will still reduce the number of array re-sizes on pushes.</span><span class="s3">\n        </span><span class="s1">// guessing too large (Tested by guessing x4 too large) may cost a bit more of memory</span><span class="s3">\n        </span><span class="s1">// but would still have a faster runtime by avoiding (All but one) array resizing.</span><span class="s3">\n        </span><span class="s1">const guessedNumberOfTokens = this.hasCustom</span><span class="s3">\n            </span><span class="s1">? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.</span><span class="s3">\n            </span><span class="s1">: Math.floor(text.length / 10);</span><span class="s3">\n        </span><span class="s1">const matchedTokens = new Array(guessedNumberOfTokens);</span><span class="s3">\n        </span><span class="s1">const errors = [];</span><span class="s3">\n        </span><span class="s1">let line = this.trackStartLines ? 1 : undefined;</span><span class="s3">\n        </span><span class="s1">let column = this.trackStartLines ? 1 : undefined;</span><span class="s3">\n        </span><span class="s1">const groups = cloneEmptyGroups(this.emptyGroups);</span><span class="s3">\n        </span><span class="s1">const trackLines = this.trackStartLines;</span><span class="s3">\n        </span><span class="s1">const lineTerminatorPattern = this.config.lineTerminatorsPattern;</span><span class="s3">\n        </span><span class="s1">let currModePatternsLength = 0;</span><span class="s3">\n        </span><span class="s1">let patternIdxToConfig = [];</span><span class="s3">\n        </span><span class="s1">let currCharCodeToPatternIdxToConfig = [];</span><span class="s3">\n        </span><span class="s1">const modeStack = [];</span><span class="s3">\n        </span><span class="s1">const emptyArray = [];</span><span class="s3">\n        </span><span class="s1">Object.freeze(emptyArray);</span><span class="s3">\n        </span><span class="s1">let getPossiblePatterns;</span><span class="s3">\n        </span><span class="s1">function getPossiblePatternsSlow() {</span><span class="s3">\n            </span><span class="s1">return patternIdxToConfig;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function getPossiblePatternsOptimized(charCode) {</span><span class="s3">\n            </span><span class="s1">const optimizedCharIdx = charCodeToOptimizedIndex(charCode);</span><span class="s3">\n            </span><span class="s1">const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];</span><span class="s3">\n            </span><span class="s1">if (possiblePatterns === undefined) {</span><span class="s3">\n                </span><span class="s1">return emptyArray;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return possiblePatterns;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const pop_mode = (popToken) =&gt; {</span><span class="s3">\n            </span><span class="s1">// TODO: perhaps avoid this error in the edge case there is no more input?</span><span class="s3">\n            </span><span class="s1">if (modeStack.length === 1 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">// if we have both a POP_MODE and a PUSH_MODE this is in-fact a </span><span class="s3">\&quot;</span><span class="s1">transition</span><span class="s3">\&quot;\n                </span><span class="s1">// So no error should occur.</span><span class="s3">\n                </span><span class="s1">popToken.tokenType.PUSH_MODE === undefined) {</span><span class="s3">\n                </span><span class="s1">// if we try to pop the last mode there lexer will no longer have ANY mode.</span><span class="s3">\n                </span><span class="s1">// thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.</span><span class="s3">\n                </span><span class="s1">const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);</span><span class="s3">\n                </span><span class="s1">errors.push({</span><span class="s3">\n                    </span><span class="s1">offset: popToken.startOffset,</span><span class="s3">\n                    </span><span class="s1">line: popToken.startLine,</span><span class="s3">\n                    </span><span class="s1">column: popToken.startColumn,</span><span class="s3">\n                    </span><span class="s1">length: popToken.image.length,</span><span class="s3">\n                    </span><span class="s1">message: msg,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">modeStack.pop();</span><span class="s3">\n                </span><span class="s1">const newMode = last(modeStack);</span><span class="s3">\n                </span><span class="s1">patternIdxToConfig = this.patternIdxToConfig[newMode];</span><span class="s3">\n                </span><span class="s1">currCharCodeToPatternIdxToConfig =</span><span class="s3">\n                    </span><span class="s1">this.charCodeToPatternIdxToConfig[newMode];</span><span class="s3">\n                </span><span class="s1">currModePatternsLength = patternIdxToConfig.length;</span><span class="s3">\n                </span><span class="s1">const modeCanBeOptimized = this.canModeBeOptimized[newMode] &amp;&amp; this.config.safeMode === false;</span><span class="s3">\n                </span><span class="s1">if (currCharCodeToPatternIdxToConfig &amp;&amp; modeCanBeOptimized) {</span><span class="s3">\n                    </span><span class="s1">getPossiblePatterns = getPossiblePatternsOptimized;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">getPossiblePatterns = getPossiblePatternsSlow;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">function push_mode(newMode) {</span><span class="s3">\n            </span><span class="s1">modeStack.push(newMode);</span><span class="s3">\n            </span><span class="s1">currCharCodeToPatternIdxToConfig =</span><span class="s3">\n                </span><span class="s1">this.charCodeToPatternIdxToConfig[newMode];</span><span class="s3">\n            </span><span class="s1">patternIdxToConfig = this.patternIdxToConfig[newMode];</span><span class="s3">\n            </span><span class="s1">currModePatternsLength = patternIdxToConfig.length;</span><span class="s3">\n            </span><span class="s1">currModePatternsLength = patternIdxToConfig.length;</span><span class="s3">\n            </span><span class="s1">const modeCanBeOptimized = this.canModeBeOptimized[newMode] &amp;&amp; this.config.safeMode === false;</span><span class="s3">\n            </span><span class="s1">if (currCharCodeToPatternIdxToConfig &amp;&amp; modeCanBeOptimized) {</span><span class="s3">\n                </span><span class="s1">getPossiblePatterns = getPossiblePatternsOptimized;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">getPossiblePatterns = getPossiblePatternsSlow;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// this pattern seems to avoid a V8 de-optimization, although that de-optimization does not</span><span class="s3">\n        </span><span class="s1">// seem to matter performance wise.</span><span class="s3">\n        </span><span class="s1">push_mode.call(this, initialMode);</span><span class="s3">\n        </span><span class="s1">let currConfig;</span><span class="s3">\n        </span><span class="s1">const recoveryEnabled = this.config.recoveryEnabled;</span><span class="s3">\n        </span><span class="s1">while (offset &lt; orgLength) {</span><span class="s3">\n            </span><span class="s1">matchedImage = null;</span><span class="s3">\n            </span><span class="s1">const nextCharCode = orgText.charCodeAt(offset);</span><span class="s3">\n            </span><span class="s1">const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);</span><span class="s3">\n            </span><span class="s1">const chosenPatternsLength = chosenPatternIdxToConfig.length;</span><span class="s3">\n            </span><span class="s1">for (i = 0; i &lt; chosenPatternsLength; i++) {</span><span class="s3">\n                </span><span class="s1">currConfig = chosenPatternIdxToConfig[i];</span><span class="s3">\n                </span><span class="s1">const currPattern = currConfig.pattern;</span><span class="s3">\n                </span><span class="s1">payload = null;</span><span class="s3">\n                </span><span class="s1">// manually in-lined because &gt; 600 chars won't be in-lined in V8</span><span class="s3">\n                </span><span class="s1">const singleCharCode = currConfig.short;</span><span class="s3">\n                </span><span class="s1">if (singleCharCode !== false) {</span><span class="s3">\n                    </span><span class="s1">if (nextCharCode === singleCharCode) {</span><span class="s3">\n                        </span><span class="s1">// single character string</span><span class="s3">\n                        </span><span class="s1">matchedImage = currPattern;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (currConfig.isCustom === true) {</span><span class="s3">\n                    </span><span class="s1">match = currPattern.exec(orgText, offset, matchedTokens, groups);</span><span class="s3">\n                    </span><span class="s1">if (match !== null) {</span><span class="s3">\n                        </span><span class="s1">matchedImage = match[0];</span><span class="s3">\n                        </span><span class="s1">if (match.payload !== undefined) {</span><span class="s3">\n                            </span><span class="s1">payload = match.payload;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">matchedImage = null;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.updateLastIndex(currPattern, offset);</span><span class="s3">\n                    </span><span class="s1">matchedImage = this.match(currPattern, text, offset);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (matchedImage !== null) {</span><span class="s3">\n                    </span><span class="s1">// even though this pattern matched we must try a another longer alternative.</span><span class="s3">\n                    </span><span class="s1">// this can be used to prioritize keywords over identifiers</span><span class="s3">\n                    </span><span class="s1">longerAlt = currConfig.longerAlt;</span><span class="s3">\n                    </span><span class="s1">if (longerAlt !== undefined) {</span><span class="s3">\n                        </span><span class="s1">// TODO: micro optimize, avoid extra prop access</span><span class="s3">\n                        </span><span class="s1">// by saving/linking longerAlt on the original config?</span><span class="s3">\n                        </span><span class="s1">const longerAltLength = longerAlt.length;</span><span class="s3">\n                        </span><span class="s1">for (k = 0; k &lt; longerAltLength; k++) {</span><span class="s3">\n                            </span><span class="s1">const longerAltConfig = patternIdxToConfig[longerAlt[k]];</span><span class="s3">\n                            </span><span class="s1">const longerAltPattern = longerAltConfig.pattern;</span><span class="s3">\n                            </span><span class="s1">altPayload = null;</span><span class="s3">\n                            </span><span class="s1">// single Char can never be a longer alt so no need to test it.</span><span class="s3">\n                            </span><span class="s1">// manually in-lined because &gt; 600 chars won't be in-lined in V8</span><span class="s3">\n                            </span><span class="s1">if (longerAltConfig.isCustom === true) {</span><span class="s3">\n                                </span><span class="s1">match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);</span><span class="s3">\n                                </span><span class="s1">if (match !== null) {</span><span class="s3">\n                                    </span><span class="s1">matchAltImage = match[0];</span><span class="s3">\n                                    </span><span class="s1">if (match.payload !== undefined) {</span><span class="s3">\n                                        </span><span class="s1">altPayload = match.payload;</span><span class="s3">\n                                    </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">matchAltImage = null;</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else {</span><span class="s3">\n                                </span><span class="s1">this.updateLastIndex(longerAltPattern, offset);</span><span class="s3">\n                                </span><span class="s1">matchAltImage = this.match(longerAltPattern, text, offset);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">if (matchAltImage &amp;&amp; matchAltImage.length &gt; matchedImage.length) {</span><span class="s3">\n                                </span><span class="s1">matchedImage = matchAltImage;</span><span class="s3">\n                                </span><span class="s1">payload = altPayload;</span><span class="s3">\n                                </span><span class="s1">currConfig = longerAltConfig;</span><span class="s3">\n                                </span><span class="s1">// Exit the loop early after matching one of the longer alternatives</span><span class="s3">\n                                </span><span class="s1">// The first matched alternative takes precedence</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// successful match</span><span class="s3">\n            </span><span class="s1">if (matchedImage !== null) {</span><span class="s3">\n                </span><span class="s1">imageLength = matchedImage.length;</span><span class="s3">\n                </span><span class="s1">group = currConfig.group;</span><span class="s3">\n                </span><span class="s1">if (group !== undefined) {</span><span class="s3">\n                    </span><span class="s1">tokType = currConfig.tokenTypeIdx;</span><span class="s3">\n                    </span><span class="s1">// TODO: </span><span class="s3">\&quot;</span><span class="s1">offset + imageLength</span><span class="s3">\&quot; </span><span class="s1">and the new column may be computed twice in case of </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">location information inside</span><span class="s3">\n                    </span><span class="s1">// createFullToken method</span><span class="s3">\n                    </span><span class="s1">newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);</span><span class="s3">\n                    </span><span class="s1">this.handlePayload(newToken, payload);</span><span class="s3">\n                    </span><span class="s1">// TODO: optimize NOOP in case there are no special groups?</span><span class="s3">\n                    </span><span class="s1">if (group === false) {</span><span class="s3">\n                        </span><span class="s1">matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">groups[group].push(newToken);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">text = this.chopInput(text, imageLength);</span><span class="s3">\n                </span><span class="s1">offset = offset + imageLength;</span><span class="s3">\n                </span><span class="s1">// TODO: with newlines the column may be assigned twice</span><span class="s3">\n                </span><span class="s1">column = this.computeNewColumn(column, imageLength);</span><span class="s3">\n                </span><span class="s1">if (trackLines === true &amp;&amp; currConfig.canLineTerminator === true) {</span><span class="s3">\n                    </span><span class="s1">let numOfLTsInMatch = 0;</span><span class="s3">\n                    </span><span class="s1">let foundTerminator;</span><span class="s3">\n                    </span><span class="s1">let lastLTEndOffset;</span><span class="s3">\n                    </span><span class="s1">lineTerminatorPattern.lastIndex = 0;</span><span class="s3">\n                    </span><span class="s1">do {</span><span class="s3">\n                        </span><span class="s1">foundTerminator = lineTerminatorPattern.test(matchedImage);</span><span class="s3">\n                        </span><span class="s1">if (foundTerminator === true) {</span><span class="s3">\n                            </span><span class="s1">lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;</span><span class="s3">\n                            </span><span class="s1">numOfLTsInMatch++;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">} while (foundTerminator === true);</span><span class="s3">\n                    </span><span class="s1">if (numOfLTsInMatch !== 0) {</span><span class="s3">\n                        </span><span class="s1">line = line + numOfLTsInMatch;</span><span class="s3">\n                        </span><span class="s1">column = imageLength - lastLTEndOffset;</span><span class="s3">\n                        </span><span class="s1">this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// will be NOOP if no modes present</span><span class="s3">\n                </span><span class="s1">this.handleModes(currConfig, pop_mode, push_mode, newToken);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// error recovery, drop characters until we identify a valid token's start point</span><span class="s3">\n                </span><span class="s1">const errorStartOffset = offset;</span><span class="s3">\n                </span><span class="s1">const errorLine = line;</span><span class="s3">\n                </span><span class="s1">const errorColumn = column;</span><span class="s3">\n                </span><span class="s1">let foundResyncPoint = recoveryEnabled === false;</span><span class="s3">\n                </span><span class="s1">while (foundResyncPoint === false &amp;&amp; offset &lt; orgLength) {</span><span class="s3">\n                    </span><span class="s1">// Identity Func (when sticky flag is enabled)</span><span class="s3">\n                    </span><span class="s1">text = this.chopInput(text, 1);</span><span class="s3">\n                    </span><span class="s1">offset++;</span><span class="s3">\n                    </span><span class="s1">for (j = 0; j &lt; currModePatternsLength; j++) {</span><span class="s3">\n                        </span><span class="s1">const currConfig = patternIdxToConfig[j];</span><span class="s3">\n                        </span><span class="s1">const currPattern = currConfig.pattern;</span><span class="s3">\n                        </span><span class="s1">// manually in-lined because &gt; 600 chars won't be in-lined in V8</span><span class="s3">\n                        </span><span class="s1">const singleCharCode = currConfig.short;</span><span class="s3">\n                        </span><span class="s1">if (singleCharCode !== false) {</span><span class="s3">\n                            </span><span class="s1">if (orgText.charCodeAt(offset) === singleCharCode) {</span><span class="s3">\n                                </span><span class="s1">// single character string</span><span class="s3">\n                                </span><span class="s1">foundResyncPoint = true;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (currConfig.isCustom === true) {</span><span class="s3">\n                            </span><span class="s1">foundResyncPoint =</span><span class="s3">\n                                </span><span class="s1">currPattern.exec(orgText, offset, matchedTokens, groups) !== null;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">this.updateLastIndex(currPattern, offset);</span><span class="s3">\n                            </span><span class="s1">foundResyncPoint = currPattern.exec(text) !== null;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (foundResyncPoint === true) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">errLength = offset - errorStartOffset;</span><span class="s3">\n                </span><span class="s1">column = this.computeNewColumn(column, errLength);</span><span class="s3">\n                </span><span class="s1">// at this point we either re-synced or reached the end of the input text</span><span class="s3">\n                </span><span class="s1">msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);</span><span class="s3">\n                </span><span class="s1">errors.push({</span><span class="s3">\n                    </span><span class="s1">offset: errorStartOffset,</span><span class="s3">\n                    </span><span class="s1">line: errorLine,</span><span class="s3">\n                    </span><span class="s1">column: errorColumn,</span><span class="s3">\n                    </span><span class="s1">length: errLength,</span><span class="s3">\n                    </span><span class="s1">message: msg,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">if (recoveryEnabled === false) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// if we do have custom patterns which push directly into the</span><span class="s3">\n        </span><span class="s1">// TODO: custom tokens should not push directly??</span><span class="s3">\n        </span><span class="s1">if (!this.hasCustom) {</span><span class="s3">\n            </span><span class="s1">// if we guessed a too large size for the tokens array this will shrink it to the right size.</span><span class="s3">\n            </span><span class="s1">matchedTokens.length = matchedTokensIndex;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">tokens: matchedTokens,</span><span class="s3">\n            </span><span class="s1">groups: groups,</span><span class="s3">\n            </span><span class="s1">errors: errors,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handleModes(config, pop_mode, push_mode, newToken) {</span><span class="s3">\n        </span><span class="s1">if (config.pop === true) {</span><span class="s3">\n            </span><span class="s1">// need to save the PUSH_MODE property as if the mode is popped</span><span class="s3">\n            </span><span class="s1">// patternIdxToPopMode is updated to reflect the new mode after popping the stack</span><span class="s3">\n            </span><span class="s1">const pushMode = config.push;</span><span class="s3">\n            </span><span class="s1">pop_mode(newToken);</span><span class="s3">\n            </span><span class="s1">if (pushMode !== undefined) {</span><span class="s3">\n                </span><span class="s1">push_mode.call(this, pushMode);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (config.push !== undefined) {</span><span class="s3">\n            </span><span class="s1">push_mode.call(this, config.push);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chopInput(text, length) {</span><span class="s3">\n        </span><span class="s1">return text.substring(length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateLastIndex(regExp, newLastIndex) {</span><span class="s3">\n        </span><span class="s1">regExp.lastIndex = newLastIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler</span><span class="s3">\n    </span><span class="s1">updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {</span><span class="s3">\n        </span><span class="s1">let lastCharIsLT, fixForEndingInLT;</span><span class="s3">\n        </span><span class="s1">if (group !== undefined) {</span><span class="s3">\n            </span><span class="s1">// a none skipped multi line Token, need to update endLine/endColumn</span><span class="s3">\n            </span><span class="s1">lastCharIsLT = lastLTIdx === imageLength - 1;</span><span class="s3">\n            </span><span class="s1">fixForEndingInLT = lastCharIsLT ? -1 : 0;</span><span class="s3">\n            </span><span class="s1">if (!(numOfLTsInMatch === 1 &amp;&amp; lastCharIsLT === true)) {</span><span class="s3">\n                </span><span class="s1">// if a token ends in a LT that last LT only affects the line numbering of following Tokens</span><span class="s3">\n                </span><span class="s1">newToken.endLine = line + fixForEndingInLT;</span><span class="s3">\n                </span><span class="s1">// the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)</span><span class="s3">\n                </span><span class="s1">// inclusive to exclusive range.</span><span class="s3">\n                </span><span class="s1">newToken.endColumn = column - 1 + -fixForEndingInLT;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// else single LT in the last character of a token, no need to modify the endLine/EndColumn</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeNewColumn(oldColumn, imageLength) {</span><span class="s3">\n        </span><span class="s1">return oldColumn + imageLength;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">image,</span><span class="s3">\n            </span><span class="s1">startOffset,</span><span class="s3">\n            </span><span class="s1">tokenTypeIdx,</span><span class="s3">\n            </span><span class="s1">tokenType,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">image,</span><span class="s3">\n            </span><span class="s1">startOffset,</span><span class="s3">\n            </span><span class="s1">startLine,</span><span class="s3">\n            </span><span class="s1">startColumn,</span><span class="s3">\n            </span><span class="s1">tokenTypeIdx,</span><span class="s3">\n            </span><span class="s1">tokenType,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">image,</span><span class="s3">\n            </span><span class="s1">startOffset,</span><span class="s3">\n            </span><span class="s1">endOffset: startOffset + imageLength - 1,</span><span class="s3">\n            </span><span class="s1">startLine,</span><span class="s3">\n            </span><span class="s1">endLine: startLine,</span><span class="s3">\n            </span><span class="s1">startColumn,</span><span class="s3">\n            </span><span class="s1">endColumn: startColumn + imageLength - 1,</span><span class="s3">\n            </span><span class="s1">tokenTypeIdx,</span><span class="s3">\n            </span><span class="s1">tokenType,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addTokenUsingPush(tokenVector, index, tokenToAdd) {</span><span class="s3">\n        </span><span class="s1">tokenVector.push(tokenToAdd);</span><span class="s3">\n        </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {</span><span class="s3">\n        </span><span class="s1">tokenVector[index] = tokenToAdd;</span><span class="s3">\n        </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">handlePayloadNoCustom(token, payload) { }</span><span class="s3">\n    </span><span class="s1">handlePayloadWithCustom(token, payload) {</span><span class="s3">\n        </span><span class="s1">if (payload !== null) {</span><span class="s3">\n            </span><span class="s1">token.payload = payload;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matchWithTest(pattern, text, offset) {</span><span class="s3">\n        </span><span class="s1">const found = pattern.test(text);</span><span class="s3">\n        </span><span class="s1">if (found === true) {</span><span class="s3">\n            </span><span class="s1">return text.substring(offset, pattern.lastIndex);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matchWithExec(pattern, text) {</span><span class="s3">\n        </span><span class="s1">const regExpArray = pattern.exec(text);</span><span class="s3">\n        </span><span class="s1">return regExpArray !== null ? regExpArray[0] : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Lexer.SKIPPED = </span><span class="s3">\&quot;</span><span class="s1">This marks a skipped Token pattern, this means each token identified by it will</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">Lexer.NA = /NOT_APPLICABLE/;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lexer_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { has, isString, isUndefined } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Lexer } from </span><span class="s3">\&quot;</span><span class="s1">./lexer_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { augmentTokenTypes, tokenStructuredMatcher } from </span><span class="s3">\&quot;</span><span class="s1">./tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function tokenLabel(tokType) {</span><span class="s3">\n    </span><span class="s1">if (hasTokenLabel(tokType)) {</span><span class="s3">\n        </span><span class="s1">return tokType.LABEL;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return tokType.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tokenName(tokType) {</span><span class="s3">\n    </span><span class="s1">return tokType.name;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function hasTokenLabel(obj) {</span><span class="s3">\n    </span><span class="s1">return isString(obj.LABEL) &amp;&amp; obj.LABEL !== </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const PARENT = </span><span class="s3">\&quot;</span><span class="s1">parent</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const CATEGORIES = </span><span class="s3">\&quot;</span><span class="s1">categories</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const LABEL = </span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const GROUP = </span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const PUSH_MODE = </span><span class="s3">\&quot;</span><span class="s1">push_mode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const POP_MODE = </span><span class="s3">\&quot;</span><span class="s1">pop_mode</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const LONGER_ALT = </span><span class="s3">\&quot;</span><span class="s1">longer_alt</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const LINE_BREAKS = </span><span class="s3">\&quot;</span><span class="s1">line_breaks</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const START_CHARS_HINT = </span><span class="s3">\&quot;</span><span class="s1">start_chars_hint</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function createToken(config) {</span><span class="s3">\n    </span><span class="s1">return createTokenInternal(config);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTokenInternal(config) {</span><span class="s3">\n    </span><span class="s1">const pattern = config.pattern;</span><span class="s3">\n    </span><span class="s1">const tokenType = {};</span><span class="s3">\n    </span><span class="s1">tokenType.name = config.name;</span><span class="s3">\n    </span><span class="s1">if (!isUndefined(pattern)) {</span><span class="s3">\n        </span><span class="s1">tokenType.PATTERN = pattern;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, PARENT)) {</span><span class="s3">\n        </span><span class="s1">throw (</span><span class="s3">\&quot;</span><span class="s1">The parent property is no longer supported.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot;</span><span class="s1">See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, CATEGORIES)) {</span><span class="s3">\n        </span><span class="s1">// casting to ANY as this will be fixed inside `augmentTokenTypes``</span><span class="s3">\n        </span><span class="s1">tokenType.CATEGORIES = config[CATEGORIES];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">augmentTokenTypes([tokenType]);</span><span class="s3">\n    </span><span class="s1">if (has(config, LABEL)) {</span><span class="s3">\n        </span><span class="s1">tokenType.LABEL = config[LABEL];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, GROUP)) {</span><span class="s3">\n        </span><span class="s1">tokenType.GROUP = config[GROUP];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, POP_MODE)) {</span><span class="s3">\n        </span><span class="s1">tokenType.POP_MODE = config[POP_MODE];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, PUSH_MODE)) {</span><span class="s3">\n        </span><span class="s1">tokenType.PUSH_MODE = config[PUSH_MODE];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, LONGER_ALT)) {</span><span class="s3">\n        </span><span class="s1">tokenType.LONGER_ALT = config[LONGER_ALT];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, LINE_BREAKS)) {</span><span class="s3">\n        </span><span class="s1">tokenType.LINE_BREAKS = config[LINE_BREAKS];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(config, START_CHARS_HINT)) {</span><span class="s3">\n        </span><span class="s1">tokenType.START_CHARS_HINT = config[START_CHARS_HINT];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tokenType;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const EOF = createToken({ name: </span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">, pattern: Lexer.NA });</span><span class="s3">\n</span><span class="s1">augmentTokenTypes([EOF]);</span><span class="s3">\n</span><span class="s1">export function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">image,</span><span class="s3">\n        </span><span class="s1">startOffset,</span><span class="s3">\n        </span><span class="s1">endOffset,</span><span class="s3">\n        </span><span class="s1">startLine,</span><span class="s3">\n        </span><span class="s1">endLine,</span><span class="s3">\n        </span><span class="s1">startColumn,</span><span class="s3">\n        </span><span class="s1">endColumn,</span><span class="s3">\n        </span><span class="s1">tokenTypeIdx: tokType.tokenTypeIdx,</span><span class="s3">\n        </span><span class="s1">tokenType: tokType,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tokenMatcher(token, tokType) {</span><span class="s3">\n    </span><span class="s1">return tokenStructuredMatcher(token, tokType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=tokens_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { hasTokenLabel, tokenLabel } from </span><span class="s3">\&quot;</span><span class="s1">../scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { first, map, reduce } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getProductionDslName, NonTerminal, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const defaultParserErrorProvider = {</span><span class="s3">\n    </span><span class="s1">buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {</span><span class="s3">\n        </span><span class="s1">const hasLabel = hasTokenLabel(expected);</span><span class="s3">\n        </span><span class="s1">const expectedMsg = hasLabel</span><span class="s3">\n            </span><span class="s1">? `--&gt; ${tokenLabel(expected)} &lt;--`</span><span class="s3">\n            </span><span class="s1">: `token of type --&gt; ${expected.name} &lt;--`;</span><span class="s3">\n        </span><span class="s1">const msg = `Expecting ${expectedMsg} but found --&gt; '${actual.image}' &lt;--`;</span><span class="s3">\n        </span><span class="s1">return msg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">Redundant input, expecting EOF but found: </span><span class="s3">\&quot; </span><span class="s1">+ firstRedundant.image;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {</span><span class="s3">\n        </span><span class="s1">const errPrefix = </span><span class="s3">\&quot;</span><span class="s1">Expecting: </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">// TODO: issue: No Viable Alternative Error may have incomplete details. #502</span><span class="s3">\n        </span><span class="s1">const actualText = first(actual).image;</span><span class="s3">\n        </span><span class="s1">const errSuffix = </span><span class="s3">\&quot;\\</span><span class="s1">nbut found: '</span><span class="s3">\&quot; </span><span class="s1">+ actualText + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (customUserDescription) {</span><span class="s3">\n            </span><span class="s1">return errPrefix + customUserDescription + errSuffix;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const allLookAheadPaths = reduce(expectedPathsPerAlt, (result, currAltPaths) =&gt; result.concat(currAltPaths), []);</span><span class="s3">\n            </span><span class="s1">const nextValidTokenSequences = map(allLookAheadPaths, (currPath) =&gt; `[${map(currPath, (currTokenType) =&gt; tokenLabel(currTokenType)).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}]`);</span><span class="s3">\n            </span><span class="s1">const nextValidSequenceItems = map(nextValidTokenSequences, (itemMsg, idx) =&gt; `  ${idx + 1}. ${itemMsg}`);</span><span class="s3">\n            </span><span class="s1">const calculatedDescription = `one of these possible Token sequences:</span><span class="s3">\\</span><span class="s1">n${nextValidSequenceItems.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n            </span><span class="s1">return errPrefix + calculatedDescription + errSuffix;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {</span><span class="s3">\n        </span><span class="s1">const errPrefix = </span><span class="s3">\&quot;</span><span class="s1">Expecting: </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">// TODO: issue: No Viable Alternative Error may have incomplete details. #502</span><span class="s3">\n        </span><span class="s1">const actualText = first(actual).image;</span><span class="s3">\n        </span><span class="s1">const errSuffix = </span><span class="s3">\&quot;\\</span><span class="s1">nbut found: '</span><span class="s3">\&quot; </span><span class="s1">+ actualText + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (customUserDescription) {</span><span class="s3">\n            </span><span class="s1">return errPrefix + customUserDescription + errSuffix;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const nextValidTokenSequences = map(expectedIterationPaths, (currPath) =&gt; `[${map(currPath, (currTokenType) =&gt; tokenLabel(currTokenType)).join(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}]`);</span><span class="s3">\n            </span><span class="s1">const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::</span><span class="s3">\\</span><span class="s1">n  ` +</span><span class="s3">\n                </span><span class="s1">`&lt;${nextValidTokenSequences.join(</span><span class="s3">\&quot; </span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}&gt;`;</span><span class="s3">\n            </span><span class="s1">return errPrefix + calculatedDescription + errSuffix;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Object.freeze(defaultParserErrorProvider);</span><span class="s3">\n</span><span class="s1">export const defaultGrammarResolverErrorProvider = {</span><span class="s3">\n    </span><span class="s1">buildRuleNotFoundError(topLevelRule, undefinedRule) {</span><span class="s3">\n        </span><span class="s1">const msg = </span><span class="s3">\&quot;</span><span class="s1">Invalid grammar, reference to a rule which is not defined: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">undefinedRule.nonTerminalName +</span><span class="s3">\n            \&quot;</span><span class="s1">&lt;-</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot;</span><span class="s1">inside top level rule: -&gt;</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            </span><span class="s1">topLevelRule.name +</span><span class="s3">\n            \&quot;</span><span class="s1">&lt;-</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return msg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export const defaultGrammarValidatorErrorProvider = {</span><span class="s3">\n    </span><span class="s1">buildDuplicateFoundError(topLevelRule, duplicateProds) {</span><span class="s3">\n        </span><span class="s1">function getExtraProductionArgument(prod) {</span><span class="s3">\n            </span><span class="s1">if (prod instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">return prod.terminalType.name;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (prod instanceof NonTerminal) {</span><span class="s3">\n                </span><span class="s1">return prod.nonTerminalName;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const topLevelName = topLevelRule.name;</span><span class="s3">\n        </span><span class="s1">const duplicateProd = first(duplicateProds);</span><span class="s3">\n        </span><span class="s1">const index = duplicateProd.idx;</span><span class="s3">\n        </span><span class="s1">const dslName = getProductionDslName(duplicateProd);</span><span class="s3">\n        </span><span class="s1">const extraArgument = getExtraProductionArgument(duplicateProd);</span><span class="s3">\n        </span><span class="s1">const hasExplicitIndex = index &gt; 0;</span><span class="s3">\n        </span><span class="s1">let msg = `-&gt;${dslName}${hasExplicitIndex ? index : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}&lt;- ${extraArgument ? `with argument: -&gt;${extraArgument}&lt;-` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">appears more than once (${duplicateProds.length} times) in the top level rule: -&gt;${topLevelName}&lt;-.                  </span><span class="s3">\n                  </span><span class="s1">For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES </span><span class="s3">\n                  </span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">// white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...</span><span class="s3">\n        </span><span class="s1">msg = msg.replace(/[ </span><span class="s3">\\</span><span class="s1">t]+/g, </span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">msg = msg.replace(/</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">s+/g, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return msg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildNamespaceConflictError(rule) {</span><span class="s3">\n        </span><span class="s1">const errMsg = `Namespace conflict found in grammar.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: &lt;${rule.name}&gt;.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`To resolve this make sure each Terminal and Non-Terminal names are unique</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`This is easy to accomplish by using the convention that Terminal names start with an uppercase letter</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`and Non-Terminal names start with a lower case letter.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildAlternationPrefixAmbiguityError(options) {</span><span class="s3">\n        </span><span class="s1">const pathMsg = map(options.prefixPath, (currTok) =&gt; tokenLabel(currTok)).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const occurrence = options.alternation.idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: options.alternation.idx;</span><span class="s3">\n        </span><span class="s1">const errMsg = `Ambiguous alternatives: &lt;${options.ambiguityIndices.join(</span><span class="s3">\&quot; </span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}&gt; due to common lookahead prefix</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`in &lt;OR${occurrence}&gt; inside &lt;${options.topLevelRule.name}&gt; Rule,</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`&lt;${pathMsg}&gt; may appears as a prefix path in all these alternatives.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`For Further details.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildAlternationAmbiguityError(options) {</span><span class="s3">\n        </span><span class="s1">const pathMsg = map(options.prefixPath, (currtok) =&gt; tokenLabel(currtok)).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const occurrence = options.alternation.idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: options.alternation.idx;</span><span class="s3">\n        </span><span class="s1">let currMessage = `Ambiguous Alternatives Detected: &lt;${options.ambiguityIndices.join(</span><span class="s3">\&quot; </span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)}&gt; in &lt;OR${occurrence}&gt;` +</span><span class="s3">\n            </span><span class="s1">` inside &lt;${options.topLevelRule.name}&gt; Rule,</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`&lt;${pathMsg}&gt; may appears as a prefix path in all these alternatives.</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n        </span><span class="s1">currMessage =</span><span class="s3">\n            </span><span class="s1">currMessage +</span><span class="s3">\n                </span><span class="s1">`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                </span><span class="s1">`For Further details.`;</span><span class="s3">\n        </span><span class="s1">return currMessage;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildEmptyRepetitionError(options) {</span><span class="s3">\n        </span><span class="s1">let dslName = getProductionDslName(options.repetition);</span><span class="s3">\n        </span><span class="s1">if (options.repetition.idx !== 0) {</span><span class="s3">\n            </span><span class="s1">dslName += options.repetition.idx;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const errMsg = `The repetition &lt;${dslName}&gt; within Rule &lt;${options.topLevelRule.name}&gt; can never consume any tokens.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`This could lead to an infinite loop.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// TODO: remove - `errors_public` from nyc.config.js exclude</span><span class="s3">\n    </span><span class="s1">//       once this method is fully removed from this file</span><span class="s3">\n    </span><span class="s1">buildTokenNameError(options) {</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">deprecated</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildEmptyAlternationError(options) {</span><span class="s3">\n        </span><span class="s1">const errMsg = `Ambiguous empty alternative: &lt;${options.emptyChoiceIdx + 1}&gt;` +</span><span class="s3">\n            </span><span class="s1">` in &lt;OR${options.alternation.idx}&gt; inside &lt;${options.topLevelRule.name}&gt; Rule.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`Only the last alternative may be an empty alternative.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildTooManyAlternativesError(options) {</span><span class="s3">\n        </span><span class="s1">const errMsg = `An Alternation cannot have more than 256 alternatives:</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`&lt;OR${options.alternation.idx}&gt; inside &lt;${options.topLevelRule.name}&gt; Rule.</span><span class="s3">\\</span><span class="s1">n has ${options.alternation.definition.length + 1} alternatives.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildLeftRecursionError(options) {</span><span class="s3">\n        </span><span class="s1">const ruleName = options.topLevelRule.name;</span><span class="s3">\n        </span><span class="s1">const pathNames = map(options.leftRecursionPath, (currRule) =&gt; currRule.name);</span><span class="s3">\n        </span><span class="s1">const leftRecursivePath = `${ruleName} --&gt; ${pathNames</span><span class="s3">\n            </span><span class="s1">.concat([ruleName])</span><span class="s3">\n            </span><span class="s1">.join(</span><span class="s3">\&quot; </span><span class="s1">--&gt; </span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n        </span><span class="s1">const errMsg = `Left Recursion found in grammar.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`rule: &lt;${ruleName}&gt; can be invoked from itself (directly or indirectly)</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`without consuming any Tokens. The grammar path that causes this is: </span><span class="s3">\\</span><span class="s1">n ${leftRecursivePath}</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">` To fix this refactor your grammar to remove the left recursion.</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">// TODO: remove - `errors_public` from nyc.config.js exclude</span><span class="s3">\n    </span><span class="s1">//       once this method is fully removed from this file</span><span class="s3">\n    </span><span class="s1">buildInvalidRuleNameError(options) {</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">deprecated</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">buildDuplicateRuleNameError(options) {</span><span class="s3">\n        </span><span class="s1">let ruleName;</span><span class="s3">\n        </span><span class="s1">if (options.topLevelRule instanceof Rule) {</span><span class="s3">\n            </span><span class="s1">ruleName = options.topLevelRule.name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">ruleName = options.topLevelRule;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const errMsg = `Duplicate definition, rule: -&gt;${ruleName}&lt;- is already defined in the grammar: -&gt;${options.grammarName}&lt;-`;</span><span class="s3">\n        </span><span class="s1">return errMsg;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=errors_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">./model.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class GAstVisitor {</span><span class="s3">\n    </span><span class="s1">visit(node) {</span><span class="s3">\n        </span><span class="s1">const nodeAny = node;</span><span class="s3">\n        </span><span class="s1">switch (nodeAny.constructor) {</span><span class="s3">\n            </span><span class="s1">case NonTerminal:</span><span class="s3">\n                </span><span class="s1">return this.visitNonTerminal(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Alternative:</span><span class="s3">\n                </span><span class="s1">return this.visitAlternative(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Option:</span><span class="s3">\n                </span><span class="s1">return this.visitOption(nodeAny);</span><span class="s3">\n            </span><span class="s1">case RepetitionMandatory:</span><span class="s3">\n                </span><span class="s1">return this.visitRepetitionMandatory(nodeAny);</span><span class="s3">\n            </span><span class="s1">case RepetitionMandatoryWithSeparator:</span><span class="s3">\n                </span><span class="s1">return this.visitRepetitionMandatoryWithSeparator(nodeAny);</span><span class="s3">\n            </span><span class="s1">case RepetitionWithSeparator:</span><span class="s3">\n                </span><span class="s1">return this.visitRepetitionWithSeparator(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Repetition:</span><span class="s3">\n                </span><span class="s1">return this.visitRepetition(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Alternation:</span><span class="s3">\n                </span><span class="s1">return this.visitAlternation(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Terminal:</span><span class="s3">\n                </span><span class="s1">return this.visitTerminal(nodeAny);</span><span class="s3">\n            </span><span class="s1">case Rule:</span><span class="s3">\n                </span><span class="s1">return this.visitRule(nodeAny);</span><span class="s3">\n            </span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitNonTerminal(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitAlternative(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitOption(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitRepetition(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatory(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatoryWithSeparator(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitRepetitionWithSeparator(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitAlternation(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitTerminal(node) { }</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">visitRule(node) { }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=visitor.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { ParserDefinitionErrorType, } from </span><span class="s3">\&quot;</span><span class="s1">../parser/parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { forEach, values } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { GAstVisitor } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function resolveGrammar(topLevels, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);</span><span class="s3">\n    </span><span class="s1">refResolver.resolveRefs();</span><span class="s3">\n    </span><span class="s1">return refResolver.errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class GastRefResolverVisitor extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor(nameToTopRule, errMsgProvider) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.nameToTopRule = nameToTopRule;</span><span class="s3">\n        </span><span class="s1">this.errMsgProvider = errMsgProvider;</span><span class="s3">\n        </span><span class="s1">this.errors = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolveRefs() {</span><span class="s3">\n        </span><span class="s1">forEach(values(this.nameToTopRule), (prod) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.currTopLevel = prod;</span><span class="s3">\n            </span><span class="s1">prod.accept(this);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitNonTerminal(node) {</span><span class="s3">\n        </span><span class="s1">const ref = this.nameToTopRule[node.nonTerminalName];</span><span class="s3">\n        </span><span class="s1">if (!ref) {</span><span class="s3">\n            </span><span class="s1">const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);</span><span class="s3">\n            </span><span class="s1">this.errors.push({</span><span class="s3">\n                </span><span class="s1">message: msg,</span><span class="s3">\n                </span><span class="s1">type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,</span><span class="s3">\n                </span><span class="s1">ruleName: this.currTopLevel.name,</span><span class="s3">\n                </span><span class="s1">unresolvedRefName: node.nonTerminalName,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">node.referencedRule = ref;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=resolver.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseAggregator` for arrays.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} setter The function to set `accumulator` values.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The iteratee to transform keys.</span><span class="s3">\n </span><span class="s1">* @param {Object} accumulator The initial aggregated object.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns `accumulator`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayAggregator(array, setter, iteratee, accumulator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index];</span><span class="s3">\n    </span><span class="s1">setter(accumulator, value, iteratee(value), array);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return accumulator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default arrayAggregator;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseEach from './_baseEach.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Aggregates elements of `collection` on `accumulator` with keys transformed</span><span class="s3">\n </span><span class="s1">* by `iteratee` and values set by `setter`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} setter The function to set `accumulator` values.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The iteratee to transform keys.</span><span class="s3">\n </span><span class="s1">* @param {Object} accumulator The initial aggregated object.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns `accumulator`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseAggregator(collection, setter, iteratee, accumulator) {</span><span class="s3">\n  </span><span class="s1">baseEach(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">setter(accumulator, value, iteratee(value), collection);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return accumulator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseAggregator;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayAggregator from './_arrayAggregator.js';</span><span class="s3">\n</span><span class="s1">import baseAggregator from './_baseAggregator.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function like `_.groupBy`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} setter The function to set accumulator values.</span><span class="s3">\n </span><span class="s1">* @param {Function} [initializer] The accumulator object initializer.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new aggregator function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createAggregator(setter, initializer) {</span><span class="s3">\n  </span><span class="s1">return function(collection, iteratee) {</span><span class="s3">\n    </span><span class="s1">var func = isArray(collection) ? arrayAggregator : baseAggregator,</span><span class="s3">\n        </span><span class="s1">accumulator = initializer ? initializer() : {};</span><span class="s3">\n\n    </span><span class="s1">return func(collection, setter, baseIteratee(iteratee, 2), accumulator);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default createAggregator;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseAssignValue from './_baseAssignValue.js';</span><span class="s3">\n</span><span class="s1">import createAggregator from './_createAggregator.js';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an object composed of keys generated from the results of running</span><span class="s3">\n </span><span class="s1">* each element of `collection` thru `iteratee`. The order of grouped values</span><span class="s3">\n </span><span class="s1">* is determined by the order they occur in `collection`. The corresponding</span><span class="s3">\n </span><span class="s1">* value of each key is an array of elements responsible for generating the</span><span class="s3">\n </span><span class="s1">* key. The iteratee is invoked with one argument: (value).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The iteratee to transform keys.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the composed aggregate object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.groupBy([6.1, 4.2, 6.3], Math.floor);</span><span class="s3">\n </span><span class="s1">* // =&gt; { '4': [4.2], '6': [6.1, 6.3] }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.groupBy(['one', 'two', 'three'], 'length');</span><span class="s3">\n </span><span class="s1">* // =&gt; { '3': ['one', 'two'], '5': ['three'] }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var groupBy = createAggregator(function(result, value, key) {</span><span class="s3">\n  </span><span class="s1">if (hasOwnProperty.call(result, key)) {</span><span class="s3">\n    </span><span class="s1">result[key].push(value);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">baseAssignValue(result, key, [value]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default groupBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseSlice from './_baseSlice.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a slice of `array` with `n` elements dropped from the end.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to query.</span><span class="s3">\n </span><span class="s1">* @param {number} [n=1] The number of elements to drop.</span><span class="s3">\n </span><span class="s1">* @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the slice of `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.dropRight([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.dropRight([1, 2, 3], 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.dropRight([1, 2, 3], 5);</span><span class="s3">\n </span><span class="s1">* // =&gt; []</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.dropRight([1, 2, 3], 0);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, 3]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function dropRight(array, n, guard) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">n = (guard || n === undefined) ? 1 : toInteger(n);</span><span class="s3">\n  </span><span class="s1">n = length - n;</span><span class="s3">\n  </span><span class="s1">return baseSlice(array, 0, n &lt; 0 ? 0 : n);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default dropRight;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { clone, drop, dropRight, first as _first, forEach, isEmpty, last, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { first } from </span><span class="s3">\&quot;</span><span class="s1">./first.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { RestWalker } from </span><span class="s3">\&quot;</span><span class="s1">./rest.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class AbstractNextPossibleTokensWalker extends RestWalker {</span><span class="s3">\n    </span><span class="s1">constructor(topProd, path) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.topProd = topProd;</span><span class="s3">\n        </span><span class="s1">this.path = path;</span><span class="s3">\n        </span><span class="s1">this.possibleTokTypes = [];</span><span class="s3">\n        </span><span class="s1">this.nextProductionName = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.nextProductionOccurrence = 0;</span><span class="s3">\n        </span><span class="s1">this.found = false;</span><span class="s3">\n        </span><span class="s1">this.isAtEndOfPath = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startWalking() {</span><span class="s3">\n        </span><span class="s1">this.found = false;</span><span class="s3">\n        </span><span class="s1">if (this.path.ruleStack[0] !== this.topProd.name) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">The path does not start with the walker's top Rule!</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// immutable for the win</span><span class="s3">\n        </span><span class="s1">this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion</span><span class="s3">\n        </span><span class="s1">this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion</span><span class="s3">\n        </span><span class="s1">// already verified that the first production is valid, we now seek the 2nd production</span><span class="s3">\n        </span><span class="s1">this.ruleStack.pop();</span><span class="s3">\n        </span><span class="s1">this.occurrenceStack.pop();</span><span class="s3">\n        </span><span class="s1">this.updateExpectedNext();</span><span class="s3">\n        </span><span class="s1">this.walk(this.topProd);</span><span class="s3">\n        </span><span class="s1">return this.possibleTokTypes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walk(prod, prevRest = []) {</span><span class="s3">\n        </span><span class="s1">// stop scanning once we found the path</span><span class="s3">\n        </span><span class="s1">if (!this.found) {</span><span class="s3">\n            </span><span class="s1">super.walk(prod, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkProdRef(refProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">// found the next production, need to keep walking in it</span><span class="s3">\n        </span><span class="s1">if (refProd.referencedRule.name === this.nextProductionName &amp;&amp;</span><span class="s3">\n            </span><span class="s1">refProd.idx === this.nextProductionOccurrence) {</span><span class="s3">\n            </span><span class="s1">const fullRest = currRest.concat(prevRest);</span><span class="s3">\n            </span><span class="s1">this.updateExpectedNext();</span><span class="s3">\n            </span><span class="s1">this.walk(refProd.referencedRule, fullRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateExpectedNext() {</span><span class="s3">\n        </span><span class="s1">// need to consume the Terminal</span><span class="s3">\n        </span><span class="s1">if (isEmpty(this.ruleStack)) {</span><span class="s3">\n            </span><span class="s1">// must reset nextProductionXXX to avoid walking down another Top Level production while what we are</span><span class="s3">\n            </span><span class="s1">// really seeking is the last Terminal...</span><span class="s3">\n            </span><span class="s1">this.nextProductionName = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.nextProductionOccurrence = 0;</span><span class="s3">\n            </span><span class="s1">this.isAtEndOfPath = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.nextProductionName = this.ruleStack.pop();</span><span class="s3">\n            </span><span class="s1">this.nextProductionOccurrence = this.occurrenceStack.pop();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {</span><span class="s3">\n    </span><span class="s1">constructor(topProd, path) {</span><span class="s3">\n        </span><span class="s1">super(topProd, path);</span><span class="s3">\n        </span><span class="s1">this.path = path;</span><span class="s3">\n        </span><span class="s1">this.nextTerminalName = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.nextTerminalOccurrence = 0;</span><span class="s3">\n        </span><span class="s1">this.nextTerminalName = this.path.lastTok.name;</span><span class="s3">\n        </span><span class="s1">this.nextTerminalOccurrence = this.path.lastTokOccurrence;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkTerminal(terminal, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (this.isAtEndOfPath &amp;&amp;</span><span class="s3">\n            </span><span class="s1">terminal.terminalType.name === this.nextTerminalName &amp;&amp;</span><span class="s3">\n            </span><span class="s1">terminal.idx === this.nextTerminalOccurrence &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!this.found) {</span><span class="s3">\n            </span><span class="s1">const fullRest = currRest.concat(prevRest);</span><span class="s3">\n            </span><span class="s1">const restProd = new Alternative({ definition: fullRest });</span><span class="s3">\n            </span><span class="s1">this.possibleTokTypes = first(restProd);</span><span class="s3">\n            </span><span class="s1">this.found = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This walker only </span><span class="s3">\&quot;</span><span class="s1">walks</span><span class="s3">\&quot; </span><span class="s1">a single </span><span class="s3">\&quot;</span><span class="s1">TOP</span><span class="s3">\&quot; </span><span class="s1">level in the Grammar Ast, this means</span><span class="s3">\n </span><span class="s1">* it never </span><span class="s3">\&quot;</span><span class="s1">follows</span><span class="s3">\&quot; </span><span class="s1">production refs</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class AbstractNextTerminalAfterProductionWalker extends RestWalker {</span><span class="s3">\n    </span><span class="s1">constructor(topRule, occurrence) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.topRule = topRule;</span><span class="s3">\n        </span><span class="s1">this.occurrence = occurrence;</span><span class="s3">\n        </span><span class="s1">this.result = {</span><span class="s3">\n            </span><span class="s1">token: undefined,</span><span class="s3">\n            </span><span class="s1">occurrence: undefined,</span><span class="s3">\n            </span><span class="s1">isEndOfRule: undefined,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startWalking() {</span><span class="s3">\n        </span><span class="s1">this.walk(this.topRule);</span><span class="s3">\n        </span><span class="s1">return this.result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {</span><span class="s3">\n    </span><span class="s1">walkMany(manyProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (manyProd.idx === this.occurrence) {</span><span class="s3">\n            </span><span class="s1">const firstAfterMany = _first(currRest.concat(prevRest));</span><span class="s3">\n            </span><span class="s1">this.result.isEndOfRule = firstAfterMany === undefined;</span><span class="s3">\n            </span><span class="s1">if (firstAfterMany instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">this.result.token = firstAfterMany.terminalType;</span><span class="s3">\n                </span><span class="s1">this.result.occurrence = firstAfterMany.idx;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">super.walkMany(manyProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {</span><span class="s3">\n    </span><span class="s1">walkManySep(manySepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (manySepProd.idx === this.occurrence) {</span><span class="s3">\n            </span><span class="s1">const firstAfterManySep = _first(currRest.concat(prevRest));</span><span class="s3">\n            </span><span class="s1">this.result.isEndOfRule = firstAfterManySep === undefined;</span><span class="s3">\n            </span><span class="s1">if (firstAfterManySep instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">this.result.token = firstAfterManySep.terminalType;</span><span class="s3">\n                </span><span class="s1">this.result.occurrence = firstAfterManySep.idx;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">super.walkManySep(manySepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {</span><span class="s3">\n    </span><span class="s1">walkAtLeastOne(atLeastOneProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (atLeastOneProd.idx === this.occurrence) {</span><span class="s3">\n            </span><span class="s1">const firstAfterAtLeastOne = _first(currRest.concat(prevRest));</span><span class="s3">\n            </span><span class="s1">this.result.isEndOfRule = firstAfterAtLeastOne === undefined;</span><span class="s3">\n            </span><span class="s1">if (firstAfterAtLeastOne instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">this.result.token = firstAfterAtLeastOne.terminalType;</span><span class="s3">\n                </span><span class="s1">this.result.occurrence = firstAfterAtLeastOne.idx;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// TODO: reduce code duplication in the AfterWalkers</span><span class="s3">\n</span><span class="s1">export class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {</span><span class="s3">\n    </span><span class="s1">walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (atleastOneSepProd.idx === this.occurrence) {</span><span class="s3">\n            </span><span class="s1">const firstAfterfirstAfterAtLeastOneSep = _first(currRest.concat(prevRest));</span><span class="s3">\n            </span><span class="s1">this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;</span><span class="s3">\n            </span><span class="s1">if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {</span><span class="s3">\n                </span><span class="s1">this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;</span><span class="s3">\n                </span><span class="s1">this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function possiblePathsFrom(targetDef, maxLength, currPath = []) {</span><span class="s3">\n    </span><span class="s1">// avoid side effects</span><span class="s3">\n    </span><span class="s1">currPath = clone(currPath);</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">// TODO: avoid inner funcs</span><span class="s3">\n    </span><span class="s1">function remainingPathWith(nextDef) {</span><span class="s3">\n        </span><span class="s1">return nextDef.concat(drop(targetDef, i + 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: avoid inner funcs</span><span class="s3">\n    </span><span class="s1">function getAlternativesForProd(definition) {</span><span class="s3">\n        </span><span class="s1">const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);</span><span class="s3">\n        </span><span class="s1">return result.concat(alternatives);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the</span><span class="s3">\n     </span><span class="s1">* following (rest) of the targetDef.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the</span><span class="s3">\n     </span><span class="s1">* the optional production.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">while (currPath.length &lt; maxLength &amp;&amp; i &lt; targetDef.length) {</span><span class="s3">\n        </span><span class="s1">const prod = targetDef[i];</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n        </span><span class="s1">if (prod instanceof Alternative) {</span><span class="s3">\n            </span><span class="s1">return getAlternativesForProd(prod.definition);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof NonTerminal) {</span><span class="s3">\n            </span><span class="s1">return getAlternativesForProd(prod.definition);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Option) {</span><span class="s3">\n            </span><span class="s1">result = getAlternativesForProd(prod.definition);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionMandatory) {</span><span class="s3">\n            </span><span class="s1">const newDef = prod.definition.concat([</span><span class="s3">\n                </span><span class="s1">new Repetition({</span><span class="s3">\n                    </span><span class="s1">definition: prod.definition,</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n            </span><span class="s1">return getAlternativesForProd(newDef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n            </span><span class="s1">const newDef = [</span><span class="s3">\n                </span><span class="s1">new Alternative({ definition: prod.definition }),</span><span class="s3">\n                </span><span class="s1">new Repetition({</span><span class="s3">\n                    </span><span class="s1">definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">];</span><span class="s3">\n            </span><span class="s1">return getAlternativesForProd(newDef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionWithSeparator) {</span><span class="s3">\n            </span><span class="s1">const newDef = prod.definition.concat([</span><span class="s3">\n                </span><span class="s1">new Repetition({</span><span class="s3">\n                    </span><span class="s1">definition: [new Terminal({ terminalType: prod.separator })].concat(prod.definition),</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n            </span><span class="s1">result = getAlternativesForProd(newDef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Repetition) {</span><span class="s3">\n            </span><span class="s1">const newDef = prod.definition.concat([</span><span class="s3">\n                </span><span class="s1">new Repetition({</span><span class="s3">\n                    </span><span class="s1">definition: prod.definition,</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n            </span><span class="s1">result = getAlternativesForProd(newDef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Alternation) {</span><span class="s3">\n            </span><span class="s1">forEach(prod.definition, (currAlt) =&gt; {</span><span class="s3">\n                </span><span class="s1">// TODO: this is a limited check for empty alternatives</span><span class="s3">\n                </span><span class="s1">//   It would prevent a common case of infinite loops during parser initialization.</span><span class="s3">\n                </span><span class="s1">//   However **in-directly** empty alternatives may still cause issues.</span><span class="s3">\n                </span><span class="s1">if (isEmpty(currAlt.definition) === false) {</span><span class="s3">\n                    </span><span class="s1">result = getAlternativesForProd(currAlt.definition);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Terminal) {</span><span class="s3">\n            </span><span class="s1">currPath.push(prod.terminalType);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">i++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result.push({</span><span class="s3">\n        </span><span class="s1">partialPath: currPath,</span><span class="s3">\n        </span><span class="s1">suffixDef: drop(targetDef, i),</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {</span><span class="s3">\n    </span><span class="s1">const EXIT_NON_TERMINAL = </span><span class="s3">\&quot;</span><span class="s1">EXIT_NONE_TERMINAL</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// to avoid creating a new Array each time.</span><span class="s3">\n    </span><span class="s1">const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];</span><span class="s3">\n    </span><span class="s1">const EXIT_ALTERNATIVE = </span><span class="s3">\&quot;</span><span class="s1">EXIT_ALTERNATIVE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">let foundCompletePath = false;</span><span class="s3">\n    </span><span class="s1">const tokenVectorLength = tokenVector.length;</span><span class="s3">\n    </span><span class="s1">const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;</span><span class="s3">\n    </span><span class="s1">const result = [];</span><span class="s3">\n    </span><span class="s1">const possiblePaths = [];</span><span class="s3">\n    </span><span class="s1">possiblePaths.push({</span><span class="s3">\n        </span><span class="s1">idx: -1,</span><span class="s3">\n        </span><span class="s1">def: initialDef,</span><span class="s3">\n        </span><span class="s1">ruleStack: [],</span><span class="s3">\n        </span><span class="s1">occurrenceStack: [],</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">while (!isEmpty(possiblePaths)) {</span><span class="s3">\n        </span><span class="s1">const currPath = possiblePaths.pop();</span><span class="s3">\n        </span><span class="s1">// skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)</span><span class="s3">\n        </span><span class="s1">if (currPath === EXIT_ALTERNATIVE) {</span><span class="s3">\n            </span><span class="s1">if (foundCompletePath &amp;&amp;</span><span class="s3">\n                </span><span class="s1">last(possiblePaths).idx &lt;= minimalAlternativesIndex) {</span><span class="s3">\n                </span><span class="s1">// remove irrelevant alternative</span><span class="s3">\n                </span><span class="s1">possiblePaths.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const currDef = currPath.def;</span><span class="s3">\n        </span><span class="s1">const currIdx = currPath.idx;</span><span class="s3">\n        </span><span class="s1">const currRuleStack = currPath.ruleStack;</span><span class="s3">\n        </span><span class="s1">const currOccurrenceStack = currPath.occurrenceStack;</span><span class="s3">\n        </span><span class="s1">// For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT</span><span class="s3">\n        </span><span class="s1">if (isEmpty(currDef)) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const prod = currDef[0];</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n        </span><span class="s1">if (prod === EXIT_NON_TERMINAL) {</span><span class="s3">\n            </span><span class="s1">const nextPath = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: drop(currDef),</span><span class="s3">\n                </span><span class="s1">ruleStack: dropRight(currRuleStack),</span><span class="s3">\n                </span><span class="s1">occurrenceStack: dropRight(currOccurrenceStack),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPath);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Terminal) {</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n            </span><span class="s1">if (currIdx &lt; tokenVectorLength - 1) {</span><span class="s3">\n                </span><span class="s1">const nextIdx = currIdx + 1;</span><span class="s3">\n                </span><span class="s1">const actualToken = tokenVector[nextIdx];</span><span class="s3">\n                </span><span class="s1">if (tokMatcher(actualToken, prod.terminalType)) {</span><span class="s3">\n                    </span><span class="s1">const nextPath = {</span><span class="s3">\n                        </span><span class="s1">idx: nextIdx,</span><span class="s3">\n                        </span><span class="s1">def: drop(currDef),</span><span class="s3">\n                        </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                        </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">possiblePaths.push(nextPath);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// end of the line</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (currIdx === tokenVectorLength - 1) {</span><span class="s3">\n                </span><span class="s1">// IGNORE ABOVE ELSE</span><span class="s3">\n                </span><span class="s1">result.push({</span><span class="s3">\n                    </span><span class="s1">nextTokenType: prod.terminalType,</span><span class="s3">\n                    </span><span class="s1">nextTokenOccurrence: prod.idx,</span><span class="s3">\n                    </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                    </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">foundCompletePath = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof NonTerminal) {</span><span class="s3">\n            </span><span class="s1">const newRuleStack = clone(currRuleStack);</span><span class="s3">\n            </span><span class="s1">newRuleStack.push(prod.nonTerminalName);</span><span class="s3">\n            </span><span class="s1">const newOccurrenceStack = clone(currOccurrenceStack);</span><span class="s3">\n            </span><span class="s1">newOccurrenceStack.push(prod.idx);</span><span class="s3">\n            </span><span class="s1">const nextPath = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),</span><span class="s3">\n                </span><span class="s1">ruleStack: newRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: newOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPath);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Option) {</span><span class="s3">\n            </span><span class="s1">// the order of alternatives is meaningful, FILO (Last path will be traversed first).</span><span class="s3">\n            </span><span class="s1">const nextPathWithout = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: drop(currDef),</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWithout);</span><span class="s3">\n            </span><span class="s1">// required marker to avoid backtracking paths whose higher priority alternatives already matched</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(EXIT_ALTERNATIVE);</span><span class="s3">\n            </span><span class="s1">const nextPathWith = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: prod.definition.concat(drop(currDef)),</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWith);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionMandatory) {</span><span class="s3">\n            </span><span class="s1">// TODO:(THE NEW operators here take a while...) (convert once?)</span><span class="s3">\n            </span><span class="s1">const secondIteration = new Repetition({</span><span class="s3">\n                </span><span class="s1">definition: prod.definition,</span><span class="s3">\n                </span><span class="s1">idx: prod.idx,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const nextDef = prod.definition.concat([secondIteration], drop(currDef));</span><span class="s3">\n            </span><span class="s1">const nextPath = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: nextDef,</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPath);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n            </span><span class="s1">// TODO:(THE NEW operators here take a while...) (convert once?)</span><span class="s3">\n            </span><span class="s1">const separatorGast = new Terminal({</span><span class="s3">\n                </span><span class="s1">terminalType: prod.separator,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const secondIteration = new Repetition({</span><span class="s3">\n                </span><span class="s1">definition: [separatorGast].concat(prod.definition),</span><span class="s3">\n                </span><span class="s1">idx: prod.idx,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const nextDef = prod.definition.concat([secondIteration], drop(currDef));</span><span class="s3">\n            </span><span class="s1">const nextPath = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: nextDef,</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPath);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof RepetitionWithSeparator) {</span><span class="s3">\n            </span><span class="s1">// the order of alternatives is meaningful, FILO (Last path will be traversed first).</span><span class="s3">\n            </span><span class="s1">const nextPathWithout = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: drop(currDef),</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWithout);</span><span class="s3">\n            </span><span class="s1">// required marker to avoid backtracking paths whose higher priority alternatives already matched</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(EXIT_ALTERNATIVE);</span><span class="s3">\n            </span><span class="s1">const separatorGast = new Terminal({</span><span class="s3">\n                </span><span class="s1">terminalType: prod.separator,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const nthRepetition = new Repetition({</span><span class="s3">\n                </span><span class="s1">definition: [separatorGast].concat(prod.definition),</span><span class="s3">\n                </span><span class="s1">idx: prod.idx,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const nextDef = prod.definition.concat([nthRepetition], drop(currDef));</span><span class="s3">\n            </span><span class="s1">const nextPathWith = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: nextDef,</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWith);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Repetition) {</span><span class="s3">\n            </span><span class="s1">// the order of alternatives is meaningful, FILO (Last path will be traversed first).</span><span class="s3">\n            </span><span class="s1">const nextPathWithout = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: drop(currDef),</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWithout);</span><span class="s3">\n            </span><span class="s1">// required marker to avoid backtracking paths whose higher priority alternatives already matched</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(EXIT_ALTERNATIVE);</span><span class="s3">\n            </span><span class="s1">// TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?</span><span class="s3">\n            </span><span class="s1">const nthRepetition = new Repetition({</span><span class="s3">\n                </span><span class="s1">definition: prod.definition,</span><span class="s3">\n                </span><span class="s1">idx: prod.idx,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const nextDef = prod.definition.concat([nthRepetition], drop(currDef));</span><span class="s3">\n            </span><span class="s1">const nextPathWith = {</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: nextDef,</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(nextPathWith);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Alternation) {</span><span class="s3">\n            </span><span class="s1">// the order of alternatives is meaningful, FILO (Last path will be traversed first).</span><span class="s3">\n            </span><span class="s1">for (let i = prod.definition.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n                </span><span class="s1">const currAlt = prod.definition[i];</span><span class="s3">\n                </span><span class="s1">const currAltPath = {</span><span class="s3">\n                    </span><span class="s1">idx: currIdx,</span><span class="s3">\n                    </span><span class="s1">def: currAlt.definition.concat(drop(currDef)),</span><span class="s3">\n                    </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                    </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">possiblePaths.push(currAltPath);</span><span class="s3">\n                </span><span class="s1">possiblePaths.push(EXIT_ALTERNATIVE);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Alternative) {</span><span class="s3">\n            </span><span class="s1">possiblePaths.push({</span><span class="s3">\n                </span><span class="s1">idx: currIdx,</span><span class="s3">\n                </span><span class="s1">def: prod.definition.concat(drop(currDef)),</span><span class="s3">\n                </span><span class="s1">ruleStack: currRuleStack,</span><span class="s3">\n                </span><span class="s1">occurrenceStack: currOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prod instanceof Rule) {</span><span class="s3">\n            </span><span class="s1">// last because we should only encounter at most a single one of these per invocation.</span><span class="s3">\n            </span><span class="s1">possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {</span><span class="s3">\n    </span><span class="s1">const newRuleStack = clone(currRuleStack);</span><span class="s3">\n    </span><span class="s1">newRuleStack.push(topRule.name);</span><span class="s3">\n    </span><span class="s1">const newCurrOccurrenceStack = clone(currOccurrenceStack);</span><span class="s3">\n    </span><span class="s1">// top rule is always assumed to have been called with occurrence index 1</span><span class="s3">\n    </span><span class="s1">newCurrOccurrenceStack.push(1);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">idx: currIdx,</span><span class="s3">\n        </span><span class="s1">def: topRule.definition,</span><span class="s3">\n        </span><span class="s1">ruleStack: newRuleStack,</span><span class="s3">\n        </span><span class="s1">occurrenceStack: newCurrOccurrenceStack,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=interpreter.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { every, flatten, forEach, has, isEmpty, map, reduce } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { possiblePathsFrom } from </span><span class="s3">\&quot;</span><span class="s1">./interpreter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { RestWalker } from </span><span class="s3">\&quot;</span><span class="s1">./rest.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from </span><span class="s3">\&quot;</span><span class="s1">../../scan/tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, Alternative as AlternativeGAST, GAstVisitor, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export var PROD_TYPE;</span><span class="s3">\n</span><span class="s1">(function (PROD_TYPE) {</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">OPTION</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">OPTION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">REPETITION</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">REPETITION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">REPETITION_MANDATORY</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">REPETITION_MANDATORY</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">REPETITION_MANDATORY_WITH_SEPARATOR</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">REPETITION_MANDATORY_WITH_SEPARATOR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">REPETITION_WITH_SEPARATOR</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">REPETITION_WITH_SEPARATOR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">PROD_TYPE[PROD_TYPE[</span><span class="s3">\&quot;</span><span class="s1">ALTERNATION</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">ALTERNATION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(PROD_TYPE || (PROD_TYPE = {}));</span><span class="s3">\n</span><span class="s1">export function getProdType(prod) {</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (prod instanceof Option || prod === </span><span class="s3">\&quot;</span><span class="s1">Option</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.OPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Repetition || prod === </span><span class="s3">\&quot;</span><span class="s1">Repetition</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.REPETITION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatory ||</span><span class="s3">\n        </span><span class="s1">prod === </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatory</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.REPETITION_MANDATORY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatoryWithSeparator ||</span><span class="s3">\n        </span><span class="s1">prod === </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatoryWithSeparator</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionWithSeparator ||</span><span class="s3">\n        </span><span class="s1">prod === </span><span class="s3">\&quot;</span><span class="s1">RepetitionWithSeparator</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.REPETITION_WITH_SEPARATOR;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Alternation || prod === </span><span class="s3">\&quot;</span><span class="s1">Alternation</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return PROD_TYPE.ALTERNATION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getLookaheadPaths(options) {</span><span class="s3">\n    </span><span class="s1">const { occurrence, rule, prodType, maxLookahead } = options;</span><span class="s3">\n    </span><span class="s1">const type = getProdType(prodType);</span><span class="s3">\n    </span><span class="s1">if (type === PROD_TYPE.ALTERNATION) {</span><span class="s3">\n        </span><span class="s1">return getLookaheadPathsForOr(occurrence, rule, maxLookahead);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {</span><span class="s3">\n    </span><span class="s1">const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);</span><span class="s3">\n    </span><span class="s1">const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)</span><span class="s3">\n        </span><span class="s1">? tokenStructuredMatcherNoCategories</span><span class="s3">\n        </span><span class="s1">: tokenStructuredMatcher;</span><span class="s3">\n    </span><span class="s1">return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare</span><span class="s3">\n </span><span class="s1">*  the lookahead </span><span class="s3">\&quot;</span><span class="s1">inside</span><span class="s3">\&quot; </span><span class="s1">the production and the lookahead immediately </span><span class="s3">\&quot;</span><span class="s1">after</span><span class="s3">\&quot; </span><span class="s1">it in the same top level rule (context free).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  Example: given a production:</span><span class="s3">\n </span><span class="s1">*  ABC(DE)?DF</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two</span><span class="s3">\n </span><span class="s1">*  alternatives.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {</span><span class="s3">\n    </span><span class="s1">const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);</span><span class="s3">\n    </span><span class="s1">const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)</span><span class="s3">\n        </span><span class="s1">? tokenStructuredMatcherNoCategories</span><span class="s3">\n        </span><span class="s1">: tokenStructuredMatcher;</span><span class="s3">\n    </span><span class="s1">return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {</span><span class="s3">\n    </span><span class="s1">const numOfAlts = alts.length;</span><span class="s3">\n    </span><span class="s1">const areAllOneTokenLookahead = every(alts, (currAlt) =&gt; {</span><span class="s3">\n        </span><span class="s1">return every(currAlt, (currPath) =&gt; {</span><span class="s3">\n            </span><span class="s1">return currPath.length === 1;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// This version takes into account the predicates as well.</span><span class="s3">\n    </span><span class="s1">if (hasPredicates) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @returns {number} - The chosen alternative index</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return function (orAlts) {</span><span class="s3">\n            </span><span class="s1">// unfortunately the predicates must be extracted every single time</span><span class="s3">\n            </span><span class="s1">// as they cannot be cached due to references to parameters(vars) which are no longer valid.</span><span class="s3">\n            </span><span class="s1">// note that in the common case of no predicates, no cpu time will be wasted on this (see else block)</span><span class="s3">\n            </span><span class="s1">const predicates = map(orAlts, (currAlt) =&gt; currAlt.GATE);</span><span class="s3">\n            </span><span class="s1">for (let t = 0; t &lt; numOfAlts; t++) {</span><span class="s3">\n                </span><span class="s1">const currAlt = alts[t];</span><span class="s3">\n                </span><span class="s1">const currNumOfPaths = currAlt.length;</span><span class="s3">\n                </span><span class="s1">const currPredicate = predicates[t];</span><span class="s3">\n                </span><span class="s1">if (currPredicate !== undefined &amp;&amp; currPredicate.call(this) === false) {</span><span class="s3">\n                    </span><span class="s1">// if the predicate does not match there is no point in checking the paths</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">nextPath: for (let j = 0; j &lt; currNumOfPaths; j++) {</span><span class="s3">\n                    </span><span class="s1">const currPath = currAlt[j];</span><span class="s3">\n                    </span><span class="s1">const currPathLength = currPath.length;</span><span class="s3">\n                    </span><span class="s1">for (let i = 0; i &lt; currPathLength; i++) {</span><span class="s3">\n                        </span><span class="s1">const nextToken = this.LA(i + 1);</span><span class="s3">\n                        </span><span class="s1">if (tokenMatcher(nextToken, currPath[i]) === false) {</span><span class="s3">\n                            </span><span class="s1">// mismatch in current path</span><span class="s3">\n                            </span><span class="s1">// try the next pth</span><span class="s3">\n                            </span><span class="s1">continue nextPath;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// found a full path that matches.</span><span class="s3">\n                    </span><span class="s1">// this will also work for an empty ALT as the loop will be skipped</span><span class="s3">\n                    </span><span class="s1">return t;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// none of the paths for the current alternative matched</span><span class="s3">\n                </span><span class="s1">// try the next alternative</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// none of the alternatives could be matched</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (areAllOneTokenLookahead &amp;&amp; !dynamicTokensEnabled) {</span><span class="s3">\n        </span><span class="s1">// optimized (common) case of all the lookaheads paths requiring only</span><span class="s3">\n        </span><span class="s1">// a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.</span><span class="s3">\n        </span><span class="s1">const singleTokenAlts = map(alts, (currAlt) =&gt; {</span><span class="s3">\n            </span><span class="s1">return flatten(currAlt);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const choiceToAlt = reduce(singleTokenAlts, (result, currAlt, idx) =&gt; {</span><span class="s3">\n            </span><span class="s1">forEach(currAlt, (currTokType) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!has(result, currTokType.tokenTypeIdx)) {</span><span class="s3">\n                    </span><span class="s1">result[currTokType.tokenTypeIdx] = idx;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">forEach(currTokType.categoryMatches, (currExtendingType) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (!has(result, currExtendingType)) {</span><span class="s3">\n                        </span><span class="s1">result[currExtendingType] = idx;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @returns {number} - The chosen alternative index</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return function () {</span><span class="s3">\n            </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n            </span><span class="s1">return choiceToAlt[nextToken.tokenTypeIdx];</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// optimized lookahead without needing to check the predicates at all.</span><span class="s3">\n        </span><span class="s1">// this causes code duplication which is intentional to improve performance.</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @returns {number} - The chosen alternative index</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">return function () {</span><span class="s3">\n            </span><span class="s1">for (let t = 0; t &lt; numOfAlts; t++) {</span><span class="s3">\n                </span><span class="s1">const currAlt = alts[t];</span><span class="s3">\n                </span><span class="s1">const currNumOfPaths = currAlt.length;</span><span class="s3">\n                </span><span class="s1">nextPath: for (let j = 0; j &lt; currNumOfPaths; j++) {</span><span class="s3">\n                    </span><span class="s1">const currPath = currAlt[j];</span><span class="s3">\n                    </span><span class="s1">const currPathLength = currPath.length;</span><span class="s3">\n                    </span><span class="s1">for (let i = 0; i &lt; currPathLength; i++) {</span><span class="s3">\n                        </span><span class="s1">const nextToken = this.LA(i + 1);</span><span class="s3">\n                        </span><span class="s1">if (tokenMatcher(nextToken, currPath[i]) === false) {</span><span class="s3">\n                            </span><span class="s1">// mismatch in current path</span><span class="s3">\n                            </span><span class="s1">// try the next pth</span><span class="s3">\n                            </span><span class="s1">continue nextPath;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// found a full path that matches.</span><span class="s3">\n                    </span><span class="s1">// this will also work for an empty ALT as the loop will be skipped</span><span class="s3">\n                    </span><span class="s1">return t;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// none of the paths for the current alternative matched</span><span class="s3">\n                </span><span class="s1">// try the next alternative</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// none of the alternatives could be matched</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {</span><span class="s3">\n    </span><span class="s1">const areAllOneTokenLookahead = every(alt, (currPath) =&gt; {</span><span class="s3">\n        </span><span class="s1">return currPath.length === 1;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const numOfPaths = alt.length;</span><span class="s3">\n    </span><span class="s1">// optimized (common) case of all the lookaheads paths requiring only</span><span class="s3">\n    </span><span class="s1">// a single token lookahead.</span><span class="s3">\n    </span><span class="s1">if (areAllOneTokenLookahead &amp;&amp; !dynamicTokensEnabled) {</span><span class="s3">\n        </span><span class="s1">const singleTokensTypes = flatten(alt);</span><span class="s3">\n        </span><span class="s1">if (singleTokensTypes.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">isEmpty(singleTokensTypes[0].categoryMatches)) {</span><span class="s3">\n            </span><span class="s1">const expectedTokenType = singleTokensTypes[0];</span><span class="s3">\n            </span><span class="s1">const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;</span><span class="s3">\n            </span><span class="s1">return function () {</span><span class="s3">\n                </span><span class="s1">return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const choiceToAlt = reduce(singleTokensTypes, (result, currTokType, idx) =&gt; {</span><span class="s3">\n                </span><span class="s1">result[currTokType.tokenTypeIdx] = true;</span><span class="s3">\n                </span><span class="s1">forEach(currTokType.categoryMatches, (currExtendingType) =&gt; {</span><span class="s3">\n                    </span><span class="s1">result[currExtendingType] = true;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">}, []);</span><span class="s3">\n            </span><span class="s1">return function () {</span><span class="s3">\n                </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n                </span><span class="s1">return choiceToAlt[nextToken.tokenTypeIdx] === true;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return function () {</span><span class="s3">\n            </span><span class="s1">nextPath: for (let j = 0; j &lt; numOfPaths; j++) {</span><span class="s3">\n                </span><span class="s1">const currPath = alt[j];</span><span class="s3">\n                </span><span class="s1">const currPathLength = currPath.length;</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; currPathLength; i++) {</span><span class="s3">\n                    </span><span class="s1">const nextToken = this.LA(i + 1);</span><span class="s3">\n                    </span><span class="s1">if (tokenMatcher(nextToken, currPath[i]) === false) {</span><span class="s3">\n                        </span><span class="s1">// mismatch in current path</span><span class="s3">\n                        </span><span class="s1">// try the next pth</span><span class="s3">\n                        </span><span class="s1">continue nextPath;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// found a full path that matches.</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// none of the paths matched</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RestDefinitionFinderWalker extends RestWalker {</span><span class="s3">\n    </span><span class="s1">constructor(topProd, targetOccurrence, targetProdType) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.topProd = topProd;</span><span class="s3">\n        </span><span class="s1">this.targetOccurrence = targetOccurrence;</span><span class="s3">\n        </span><span class="s1">this.targetProdType = targetProdType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startWalking() {</span><span class="s3">\n        </span><span class="s1">this.walk(this.topProd);</span><span class="s3">\n        </span><span class="s1">return this.restDef;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkIsTarget(node, expectedProdType, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (node.idx === this.targetOccurrence &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.targetProdType === expectedProdType) {</span><span class="s3">\n            </span><span class="s1">this.restDef = currRest.concat(prevRest);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// performance optimization, do not iterate over the entire Grammar ast after we have found the target</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkOption(optionProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {</span><span class="s3">\n            </span><span class="s1">super.walkOption(optionProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkAtLeastOne(atLeastOneProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {</span><span class="s3">\n            </span><span class="s1">super.walkOption(atLeastOneProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {</span><span class="s3">\n            </span><span class="s1">super.walkOption(atLeastOneSepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkMany(manyProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {</span><span class="s3">\n            </span><span class="s1">super.walkOption(manyProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">walkManySep(manySepProd, currRest, prevRest) {</span><span class="s3">\n        </span><span class="s1">if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {</span><span class="s3">\n            </span><span class="s1">super.walkOption(manySepProd, currRest, prevRest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the definition of a target production in a top level level rule.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class InsideDefinitionFinderVisitor extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor(targetOccurrence, targetProdType, targetRef) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.targetOccurrence = targetOccurrence;</span><span class="s3">\n        </span><span class="s1">this.targetProdType = targetProdType;</span><span class="s3">\n        </span><span class="s1">this.targetRef = targetRef;</span><span class="s3">\n        </span><span class="s1">this.result = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkIsTarget(node, expectedProdName) {</span><span class="s3">\n        </span><span class="s1">if (node.idx === this.targetOccurrence &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.targetProdType === expectedProdName &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(this.targetRef === undefined || node === this.targetRef)) {</span><span class="s3">\n            </span><span class="s1">this.result = node.definition;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitOption(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.OPTION);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetition(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.REPETITION);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatory(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatoryWithSeparator(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionWithSeparator(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitAlternation(node) {</span><span class="s3">\n        </span><span class="s1">this.checkIsTarget(node, PROD_TYPE.ALTERNATION);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function initializeArrayOfArrays(size) {</span><span class="s3">\n    </span><span class="s1">const result = new Array(size);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; size; i++) {</span><span class="s3">\n        </span><span class="s1">result[i] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A sort of hash function between a Path in the grammar and a string.</span><span class="s3">\n </span><span class="s1">* Note that this returns multiple </span><span class="s3">\&quot;</span><span class="s1">hashes</span><span class="s3">\&quot; </span><span class="s1">to support the scenario of token categories.</span><span class="s3">\n </span><span class="s1">* -  A single path with categories may match multiple **actual** paths.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function pathToHashKeys(path) {</span><span class="s3">\n    </span><span class="s1">let keys = [</span><span class="s3">\&quot;\&quot;</span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; path.length; i++) {</span><span class="s3">\n        </span><span class="s1">const tokType = path[i];</span><span class="s3">\n        </span><span class="s1">const longerKeys = [];</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; keys.length; j++) {</span><span class="s3">\n            </span><span class="s1">const currShorterKey = keys[j];</span><span class="s3">\n            </span><span class="s1">longerKeys.push(currShorterKey + </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">+ tokType.tokenTypeIdx);</span><span class="s3">\n            </span><span class="s1">for (let t = 0; t &lt; tokType.categoryMatches.length; t++) {</span><span class="s3">\n                </span><span class="s1">const categoriesKeySuffix = </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot; </span><span class="s1">+ tokType.categoryMatches[t];</span><span class="s3">\n                </span><span class="s1">longerKeys.push(currShorterKey + categoriesKeySuffix);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">keys = longerKeys;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return keys;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Imperative style due to being called from a hot spot</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {</span><span class="s3">\n    </span><span class="s1">for (let currAltIdx = 0; currAltIdx &lt; altKnownPathsKeys.length; currAltIdx++) {</span><span class="s3">\n        </span><span class="s1">// We only want to test vs the other alternatives</span><span class="s3">\n        </span><span class="s1">if (currAltIdx === idx) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];</span><span class="s3">\n        </span><span class="s1">for (let searchIdx = 0; searchIdx &lt; searchPathKeys.length; searchIdx++) {</span><span class="s3">\n            </span><span class="s1">const searchKey = searchPathKeys[searchIdx];</span><span class="s3">\n            </span><span class="s1">if (otherAltKnownPathsKeys[searchKey] === true) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// None of the SearchPathKeys were found in any of the other alternatives</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function lookAheadSequenceFromAlternatives(altsDefs, k) {</span><span class="s3">\n    </span><span class="s1">const partialAlts = map(altsDefs, (currAlt) =&gt; possiblePathsFrom([currAlt], 1));</span><span class="s3">\n    </span><span class="s1">const finalResult = initializeArrayOfArrays(partialAlts.length);</span><span class="s3">\n    </span><span class="s1">const altsHashes = map(partialAlts, (currAltPaths) =&gt; {</span><span class="s3">\n        </span><span class="s1">const dict = {};</span><span class="s3">\n        </span><span class="s1">forEach(currAltPaths, (item) =&gt; {</span><span class="s3">\n            </span><span class="s1">const keys = pathToHashKeys(item.partialPath);</span><span class="s3">\n            </span><span class="s1">forEach(keys, (currKey) =&gt; {</span><span class="s3">\n                </span><span class="s1">dict[currKey] = true;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return dict;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let newData = partialAlts;</span><span class="s3">\n    </span><span class="s1">// maxLookahead loop</span><span class="s3">\n    </span><span class="s1">for (let pathLength = 1; pathLength &lt;= k; pathLength++) {</span><span class="s3">\n        </span><span class="s1">const currDataset = newData;</span><span class="s3">\n        </span><span class="s1">newData = initializeArrayOfArrays(currDataset.length);</span><span class="s3">\n        </span><span class="s1">// alternatives loop</span><span class="s3">\n        </span><span class="s1">for (let altIdx = 0; altIdx &lt; currDataset.length; altIdx++) {</span><span class="s3">\n            </span><span class="s1">const currAltPathsAndSuffixes = currDataset[altIdx];</span><span class="s3">\n            </span><span class="s1">// paths in current alternative loop</span><span class="s3">\n            </span><span class="s1">for (let currPathIdx = 0; currPathIdx &lt; currAltPathsAndSuffixes.length; currPathIdx++) {</span><span class="s3">\n                </span><span class="s1">const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;</span><span class="s3">\n                </span><span class="s1">const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;</span><span class="s3">\n                </span><span class="s1">const prefixKeys = pathToHashKeys(currPathPrefix);</span><span class="s3">\n                </span><span class="s1">const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);</span><span class="s3">\n                </span><span class="s1">// End of the line for this path.</span><span class="s3">\n                </span><span class="s1">if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {</span><span class="s3">\n                    </span><span class="s1">const currAltResult = finalResult[altIdx];</span><span class="s3">\n                    </span><span class="s1">// TODO: Can we implement a containsPath using Maps/Dictionaries?</span><span class="s3">\n                    </span><span class="s1">if (containsPath(currAltResult, currPathPrefix) === false) {</span><span class="s3">\n                        </span><span class="s1">currAltResult.push(currPathPrefix);</span><span class="s3">\n                        </span><span class="s1">// Update all new  keys for the current path.</span><span class="s3">\n                        </span><span class="s1">for (let j = 0; j &lt; prefixKeys.length; j++) {</span><span class="s3">\n                            </span><span class="s1">const currKey = prefixKeys[j];</span><span class="s3">\n                            </span><span class="s1">altsHashes[altIdx][currKey] = true;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Expand longer paths</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">const newPartialPathsAndSuffixes = possiblePathsFrom(suffixDef, pathLength + 1, currPathPrefix);</span><span class="s3">\n                    </span><span class="s1">newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);</span><span class="s3">\n                    </span><span class="s1">// Update keys for new known paths</span><span class="s3">\n                    </span><span class="s1">forEach(newPartialPathsAndSuffixes, (item) =&gt; {</span><span class="s3">\n                        </span><span class="s1">const prefixKeys = pathToHashKeys(item.partialPath);</span><span class="s3">\n                        </span><span class="s1">forEach(prefixKeys, (key) =&gt; {</span><span class="s3">\n                            </span><span class="s1">altsHashes[altIdx][key] = true;</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return finalResult;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {</span><span class="s3">\n    </span><span class="s1">const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);</span><span class="s3">\n    </span><span class="s1">ruleGrammar.accept(visitor);</span><span class="s3">\n    </span><span class="s1">return lookAheadSequenceFromAlternatives(visitor.result, k);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {</span><span class="s3">\n    </span><span class="s1">const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);</span><span class="s3">\n    </span><span class="s1">ruleGrammar.accept(insideDefVisitor);</span><span class="s3">\n    </span><span class="s1">const insideDef = insideDefVisitor.result;</span><span class="s3">\n    </span><span class="s1">const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);</span><span class="s3">\n    </span><span class="s1">const afterDef = afterDefWalker.startWalking();</span><span class="s3">\n    </span><span class="s1">const insideFlat = new AlternativeGAST({ definition: insideDef });</span><span class="s3">\n    </span><span class="s1">const afterFlat = new AlternativeGAST({ definition: afterDef });</span><span class="s3">\n    </span><span class="s1">return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function containsPath(alternative, searchPath) {</span><span class="s3">\n    </span><span class="s1">compareOtherPath: for (let i = 0; i &lt; alternative.length; i++) {</span><span class="s3">\n        </span><span class="s1">const otherPath = alternative[i];</span><span class="s3">\n        </span><span class="s1">if (otherPath.length !== searchPath.length) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; otherPath.length; j++) {</span><span class="s3">\n            </span><span class="s1">const searchTok = searchPath[j];</span><span class="s3">\n            </span><span class="s1">const otherTok = otherPath[j];</span><span class="s3">\n            </span><span class="s1">const matchingTokens = searchTok === otherTok ||</span><span class="s3">\n                </span><span class="s1">otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;</span><span class="s3">\n            </span><span class="s1">if (matchingTokens === false) {</span><span class="s3">\n                </span><span class="s1">continue compareOtherPath;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isStrictPrefixOfPath(prefix, other) {</span><span class="s3">\n    </span><span class="s1">return (prefix.length &lt; other.length &amp;&amp;</span><span class="s3">\n        </span><span class="s1">every(prefix, (tokType, idx) =&gt; {</span><span class="s3">\n            </span><span class="s1">const otherTokType = other[idx];</span><span class="s3">\n            </span><span class="s1">return (tokType === otherTokType ||</span><span class="s3">\n                </span><span class="s1">otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function areTokenCategoriesNotUsed(lookAheadPaths) {</span><span class="s3">\n    </span><span class="s1">return every(lookAheadPaths, (singleAltPaths) =&gt; every(singleAltPaths, (singlePath) =&gt; every(singlePath, (token) =&gt; isEmpty(token.categoryMatches))));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lookahead.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { clone, compact, difference, drop, dropRight, filter, first, flatMap, flatten, forEach, groupBy, includes, isEmpty, map, pickBy, reduce, reject, values, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ParserDefinitionErrorType, } from </span><span class="s3">\&quot;</span><span class="s1">../parser/parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, Alternative as AlternativeGAST, GAstVisitor, getProductionDslName, isOptionalProd, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { containsPath, getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, getProdType, isStrictPrefixOfPath, } from </span><span class="s3">\&quot;</span><span class="s1">./lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { nextPossibleTokensAfter } from </span><span class="s3">\&quot;</span><span class="s1">./interpreter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { tokenStructuredMatcher } from </span><span class="s3">\&quot;</span><span class="s1">../../scan/tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function validateLookahead(options) {</span><span class="s3">\n    </span><span class="s1">const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({</span><span class="s3">\n        </span><span class="s1">rules: options.rules,</span><span class="s3">\n        </span><span class="s1">tokenTypes: options.tokenTypes,</span><span class="s3">\n        </span><span class="s1">grammarName: options.grammarName,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return map(lookaheadValidationErrorMessages, (errorMessage) =&gt; (Object.assign({ type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {</span><span class="s3">\n    </span><span class="s1">const duplicateErrors = flatMap(topLevels, (currTopLevel) =&gt; validateDuplicateProductions(currTopLevel, errMsgProvider));</span><span class="s3">\n    </span><span class="s1">const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);</span><span class="s3">\n    </span><span class="s1">const tooManyAltsErrors = flatMap(topLevels, (curRule) =&gt; validateTooManyAlts(curRule, errMsgProvider));</span><span class="s3">\n    </span><span class="s1">const duplicateRulesError = flatMap(topLevels, (curRule) =&gt; validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));</span><span class="s3">\n    </span><span class="s1">return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validateDuplicateProductions(topLevelRule, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const collectorVisitor = new OccurrenceValidationCollector();</span><span class="s3">\n    </span><span class="s1">topLevelRule.accept(collectorVisitor);</span><span class="s3">\n    </span><span class="s1">const allRuleProductions = collectorVisitor.allProductions;</span><span class="s3">\n    </span><span class="s1">const productionGroups = groupBy(allRuleProductions, identifyProductionForDuplicates);</span><span class="s3">\n    </span><span class="s1">const duplicates = pickBy(productionGroups, (currGroup) =&gt; {</span><span class="s3">\n        </span><span class="s1">return currGroup.length &gt; 1;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(values(duplicates), (currDuplicates) =&gt; {</span><span class="s3">\n        </span><span class="s1">const firstProd = first(currDuplicates);</span><span class="s3">\n        </span><span class="s1">const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);</span><span class="s3">\n        </span><span class="s1">const dslName = getProductionDslName(firstProd);</span><span class="s3">\n        </span><span class="s1">const defError = {</span><span class="s3">\n            </span><span class="s1">message: msg,</span><span class="s3">\n            </span><span class="s1">type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,</span><span class="s3">\n            </span><span class="s1">ruleName: topLevelRule.name,</span><span class="s3">\n            </span><span class="s1">dslName: dslName,</span><span class="s3">\n            </span><span class="s1">occurrence: firstProd.idx,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const param = getExtraProductionArgument(firstProd);</span><span class="s3">\n        </span><span class="s1">if (param) {</span><span class="s3">\n            </span><span class="s1">defError.parameter = param;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return defError;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function identifyProductionForDuplicates(prod) {</span><span class="s3">\n    </span><span class="s1">return `${getProductionDslName(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getExtraProductionArgument(prod) {</span><span class="s3">\n    </span><span class="s1">if (prod instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">return prod.terminalType.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">return prod.nonTerminalName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class OccurrenceValidationCollector extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.allProductions = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitNonTerminal(subrule) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(subrule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitOption(option) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(option);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionWithSeparator(manySep) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(manySep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatory(atLeastOne) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(atLeastOne);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatoryWithSeparator(atLeastOneSep) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(atLeastOneSep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetition(many) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(many);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitAlternation(or) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(or);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitTerminal(terminal) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(terminal);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">const occurrences = reduce(allRules, (result, curRule) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (curRule.name === rule.name) {</span><span class="s3">\n            </span><span class="s1">return result + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}, 0);</span><span class="s3">\n    </span><span class="s1">if (occurrences &gt; 1) {</span><span class="s3">\n        </span><span class="s1">const errMsg = errMsgProvider.buildDuplicateRuleNameError({</span><span class="s3">\n            </span><span class="s1">topLevelRule: rule,</span><span class="s3">\n            </span><span class="s1">grammarName: className,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">errors.push({</span><span class="s3">\n            </span><span class="s1">message: errMsg,</span><span class="s3">\n            </span><span class="s1">type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,</span><span class="s3">\n            </span><span class="s1">ruleName: rule.name,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?</span><span class="s3">\n</span><span class="s1">// This is not part of the IGrammarErrorProvider because the validation cannot be performed on</span><span class="s3">\n</span><span class="s1">// The grammar structure, only at runtime.</span><span class="s3">\n</span><span class="s1">export function validateRuleIsOverridden(ruleName, definedRulesNames, className) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">let errMsg;</span><span class="s3">\n    </span><span class="s1">if (!includes(definedRulesNames, ruleName)) {</span><span class="s3">\n        </span><span class="s1">errMsg =</span><span class="s3">\n            </span><span class="s1">`Invalid rule override, rule: -&gt;${ruleName}&lt;- cannot be overridden in the grammar: -&gt;${className}&lt;-` +</span><span class="s3">\n                </span><span class="s1">`as it is not defined in any of the super grammars `;</span><span class="s3">\n        </span><span class="s1">errors.push({</span><span class="s3">\n            </span><span class="s1">message: errMsg,</span><span class="s3">\n            </span><span class="s1">type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,</span><span class="s3">\n            </span><span class="s1">ruleName: ruleName,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">const nextNonTerminals = getFirstNoneTerminal(currRule.definition);</span><span class="s3">\n    </span><span class="s1">if (isEmpty(nextNonTerminals)) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const ruleName = topRule.name;</span><span class="s3">\n        </span><span class="s1">const foundLeftRecursion = includes(nextNonTerminals, topRule);</span><span class="s3">\n        </span><span class="s1">if (foundLeftRecursion) {</span><span class="s3">\n            </span><span class="s1">errors.push({</span><span class="s3">\n                </span><span class="s1">message: errMsgProvider.buildLeftRecursionError({</span><span class="s3">\n                    </span><span class="s1">topLevelRule: topRule,</span><span class="s3">\n                    </span><span class="s1">leftRecursionPath: path,</span><span class="s3">\n                </span><span class="s1">}),</span><span class="s3">\n                </span><span class="s1">type: ParserDefinitionErrorType.LEFT_RECURSION,</span><span class="s3">\n                </span><span class="s1">ruleName: ruleName,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// we are only looking for cyclic paths leading back to the specific topRule</span><span class="s3">\n        </span><span class="s1">// other cyclic paths are ignored, we still need this difference to avoid infinite loops...</span><span class="s3">\n        </span><span class="s1">const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));</span><span class="s3">\n        </span><span class="s1">const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) =&gt; {</span><span class="s3">\n            </span><span class="s1">const newPath = clone(path);</span><span class="s3">\n            </span><span class="s1">newPath.push(currRefRule);</span><span class="s3">\n            </span><span class="s1">return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return errors.concat(errorsFromNextSteps);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getFirstNoneTerminal(definition) {</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">if (isEmpty(definition)) {</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const firstProd = first(definition);</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n    </span><span class="s1">if (firstProd instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">result.push(firstProd.referencedRule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (firstProd instanceof AlternativeGAST ||</span><span class="s3">\n        </span><span class="s1">firstProd instanceof Option ||</span><span class="s3">\n        </span><span class="s1">firstProd instanceof RepetitionMandatory ||</span><span class="s3">\n        </span><span class="s1">firstProd instanceof RepetitionMandatoryWithSeparator ||</span><span class="s3">\n        </span><span class="s1">firstProd instanceof RepetitionWithSeparator ||</span><span class="s3">\n        </span><span class="s1">firstProd instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">result = result.concat(getFirstNoneTerminal(firstProd.definition));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (firstProd instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">// each sub definition in alternation is a FLAT</span><span class="s3">\n        </span><span class="s1">result = flatten(map(firstProd.definition, (currSubDef) =&gt; getFirstNoneTerminal(currSubDef.definition)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (firstProd instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">// nothing to see, move along</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const isFirstOptional = isOptionalProd(firstProd);</span><span class="s3">\n    </span><span class="s1">const hasMore = definition.length &gt; 1;</span><span class="s3">\n    </span><span class="s1">if (isFirstOptional &amp;&amp; hasMore) {</span><span class="s3">\n        </span><span class="s1">const rest = drop(definition);</span><span class="s3">\n        </span><span class="s1">return result.concat(getFirstNoneTerminal(rest));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class OrCollector extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.alternations = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitAlternation(node) {</span><span class="s3">\n        </span><span class="s1">this.alternations.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const orCollector = new OrCollector();</span><span class="s3">\n    </span><span class="s1">topLevelRule.accept(orCollector);</span><span class="s3">\n    </span><span class="s1">const ors = orCollector.alternations;</span><span class="s3">\n    </span><span class="s1">const errors = flatMap(ors, (currOr) =&gt; {</span><span class="s3">\n        </span><span class="s1">const exceptLast = dropRight(currOr.definition);</span><span class="s3">\n        </span><span class="s1">return flatMap(exceptLast, (currAlternative, currAltIdx) =&gt; {</span><span class="s3">\n            </span><span class="s1">const possibleFirstInAlt = nextPossibleTokensAfter([currAlternative], [], tokenStructuredMatcher, 1);</span><span class="s3">\n            </span><span class="s1">if (isEmpty(possibleFirstInAlt)) {</span><span class="s3">\n                </span><span class="s1">return [</span><span class="s3">\n                    </span><span class="s1">{</span><span class="s3">\n                        </span><span class="s1">message: errMsgProvider.buildEmptyAlternationError({</span><span class="s3">\n                            </span><span class="s1">topLevelRule: topLevelRule,</span><span class="s3">\n                            </span><span class="s1">alternation: currOr,</span><span class="s3">\n                            </span><span class="s1">emptyChoiceIdx: currAltIdx,</span><span class="s3">\n                        </span><span class="s1">}),</span><span class="s3">\n                        </span><span class="s1">type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,</span><span class="s3">\n                        </span><span class="s1">ruleName: topLevelRule.name,</span><span class="s3">\n                        </span><span class="s1">occurrence: currOr.idx,</span><span class="s3">\n                        </span><span class="s1">alternative: currAltIdx + 1,</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const orCollector = new OrCollector();</span><span class="s3">\n    </span><span class="s1">topLevelRule.accept(orCollector);</span><span class="s3">\n    </span><span class="s1">let ors = orCollector.alternations;</span><span class="s3">\n    </span><span class="s1">// New Handling of ignoring ambiguities</span><span class="s3">\n    </span><span class="s1">// - https://github.com/chevrotain/chevrotain/issues/869</span><span class="s3">\n    </span><span class="s1">ors = reject(ors, (currOr) =&gt; currOr.ignoreAmbiguities === true);</span><span class="s3">\n    </span><span class="s1">const errors = flatMap(ors, (currOr) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currOccurrence = currOr.idx;</span><span class="s3">\n        </span><span class="s1">const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;</span><span class="s3">\n        </span><span class="s1">const alternatives = getLookaheadPathsForOr(currOccurrence, topLevelRule, actualMaxLookahead, currOr);</span><span class="s3">\n        </span><span class="s1">const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);</span><span class="s3">\n        </span><span class="s1">const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);</span><span class="s3">\n        </span><span class="s1">return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RepetitionCollector extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.allProductions = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionWithSeparator(manySep) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(manySep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatory(atLeastOne) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(atLeastOne);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatoryWithSeparator(atLeastOneSep) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(atLeastOneSep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetition(many) {</span><span class="s3">\n        </span><span class="s1">this.allProductions.push(many);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateTooManyAlts(topLevelRule, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const orCollector = new OrCollector();</span><span class="s3">\n    </span><span class="s1">topLevelRule.accept(orCollector);</span><span class="s3">\n    </span><span class="s1">const ors = orCollector.alternations;</span><span class="s3">\n    </span><span class="s1">const errors = flatMap(ors, (currOr) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (currOr.definition.length &gt; 255) {</span><span class="s3">\n            </span><span class="s1">return [</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">message: errMsgProvider.buildTooManyAlternativesError({</span><span class="s3">\n                        </span><span class="s1">topLevelRule: topLevelRule,</span><span class="s3">\n                        </span><span class="s1">alternation: currOr,</span><span class="s3">\n                    </span><span class="s1">}),</span><span class="s3">\n                    </span><span class="s1">type: ParserDefinitionErrorType.TOO_MANY_ALTS,</span><span class="s3">\n                    </span><span class="s1">ruleName: topLevelRule.name,</span><span class="s3">\n                    </span><span class="s1">occurrence: currOr.idx,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">forEach(topLevelRules, (currTopRule) =&gt; {</span><span class="s3">\n        </span><span class="s1">const collectorVisitor = new RepetitionCollector();</span><span class="s3">\n        </span><span class="s1">currTopRule.accept(collectorVisitor);</span><span class="s3">\n        </span><span class="s1">const allRuleProductions = collectorVisitor.allProductions;</span><span class="s3">\n        </span><span class="s1">forEach(allRuleProductions, (currProd) =&gt; {</span><span class="s3">\n            </span><span class="s1">const prodType = getProdType(currProd);</span><span class="s3">\n            </span><span class="s1">const actualMaxLookahead = currProd.maxLookahead || maxLookahead;</span><span class="s3">\n            </span><span class="s1">const currOccurrence = currProd.idx;</span><span class="s3">\n            </span><span class="s1">const paths = getLookaheadPathsForOptionalProd(currOccurrence, currTopRule, prodType, actualMaxLookahead);</span><span class="s3">\n            </span><span class="s1">const pathsInsideProduction = paths[0];</span><span class="s3">\n            </span><span class="s1">if (isEmpty(flatten(pathsInsideProduction))) {</span><span class="s3">\n                </span><span class="s1">const errMsg = errMsgProvider.buildEmptyRepetitionError({</span><span class="s3">\n                    </span><span class="s1">topLevelRule: currTopRule,</span><span class="s3">\n                    </span><span class="s1">repetition: currProd,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">errors.push({</span><span class="s3">\n                    </span><span class="s1">message: errMsg,</span><span class="s3">\n                    </span><span class="s1">type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,</span><span class="s3">\n                    </span><span class="s1">ruleName: currTopRule.name,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const foundAmbiguousPaths = [];</span><span class="s3">\n    </span><span class="s1">const identicalAmbiguities = reduce(alternatives, (result, currAlt, currAltIdx) =&gt; {</span><span class="s3">\n        </span><span class="s1">// ignore (skip) ambiguities with this alternative</span><span class="s3">\n        </span><span class="s1">if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">forEach(currAlt, (currPath) =&gt; {</span><span class="s3">\n            </span><span class="s1">const altsCurrPathAppearsIn = [currAltIdx];</span><span class="s3">\n            </span><span class="s1">forEach(alternatives, (currOtherAlt, currOtherAltIdx) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (currAltIdx !== currOtherAltIdx &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">containsPath(currOtherAlt, currPath) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">// ignore (skip) ambiguities with this </span><span class="s3">\&quot;</span><span class="s1">other</span><span class="s3">\&quot; </span><span class="s1">alternative</span><span class="s3">\n                    </span><span class="s1">alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {</span><span class="s3">\n                    </span><span class="s1">altsCurrPathAppearsIn.push(currOtherAltIdx);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (altsCurrPathAppearsIn.length &gt; 1 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!containsPath(foundAmbiguousPaths, currPath)) {</span><span class="s3">\n                </span><span class="s1">foundAmbiguousPaths.push(currPath);</span><span class="s3">\n                </span><span class="s1">result.push({</span><span class="s3">\n                    </span><span class="s1">alts: altsCurrPathAppearsIn,</span><span class="s3">\n                    </span><span class="s1">path: currPath,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">const currErrors = map(identicalAmbiguities, (currAmbDescriptor) =&gt; {</span><span class="s3">\n        </span><span class="s1">const ambgIndices = map(currAmbDescriptor.alts, (currAltIdx) =&gt; currAltIdx + 1);</span><span class="s3">\n        </span><span class="s1">const currMessage = errMsgProvider.buildAlternationAmbiguityError({</span><span class="s3">\n            </span><span class="s1">topLevelRule: rule,</span><span class="s3">\n            </span><span class="s1">alternation: alternation,</span><span class="s3">\n            </span><span class="s1">ambiguityIndices: ambgIndices,</span><span class="s3">\n            </span><span class="s1">prefixPath: currAmbDescriptor.path,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message: currMessage,</span><span class="s3">\n            </span><span class="s1">type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,</span><span class="s3">\n            </span><span class="s1">ruleName: rule.name,</span><span class="s3">\n            </span><span class="s1">occurrence: alternation.idx,</span><span class="s3">\n            </span><span class="s1">alternatives: currAmbDescriptor.alts,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return currErrors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">// flatten</span><span class="s3">\n    </span><span class="s1">const pathsAndIndices = reduce(alternatives, (result, currAlt, idx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currPathsAndIdx = map(currAlt, (currPath) =&gt; {</span><span class="s3">\n            </span><span class="s1">return { idx: idx, path: currPath };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return result.concat(currPathsAndIdx);</span><span class="s3">\n    </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">const errors = compact(flatMap(pathsAndIndices, (currPathAndIdx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const alternativeGast = alternation.definition[currPathAndIdx.idx];</span><span class="s3">\n        </span><span class="s1">// ignore (skip) ambiguities with this alternative</span><span class="s3">\n        </span><span class="s1">if (alternativeGast.ignoreAmbiguities === true) {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const targetIdx = currPathAndIdx.idx;</span><span class="s3">\n        </span><span class="s1">const targetPath = currPathAndIdx.path;</span><span class="s3">\n        </span><span class="s1">const prefixAmbiguitiesPathsAndIndices = filter(pathsAndIndices, (searchPathAndIdx) =&gt; {</span><span class="s3">\n            </span><span class="s1">// prefix ambiguity can only be created from lower idx (higher priority) path</span><span class="s3">\n            </span><span class="s1">return (</span><span class="s3">\n            </span><span class="s1">// ignore (skip) ambiguities with this </span><span class="s3">\&quot;</span><span class="s1">other</span><span class="s3">\&quot; </span><span class="s1">alternative</span><span class="s3">\n            </span><span class="s1">alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==</span><span class="s3">\n                </span><span class="s1">true &amp;&amp;</span><span class="s3">\n                </span><span class="s1">searchPathAndIdx.idx &lt; targetIdx &amp;&amp;</span><span class="s3">\n                </span><span class="s1">// checking for strict prefix because identical lookaheads</span><span class="s3">\n                </span><span class="s1">// will be be detected using a different validation.</span><span class="s3">\n                </span><span class="s1">isStrictPrefixOfPath(searchPathAndIdx.path, targetPath));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const currPathPrefixErrors = map(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) =&gt; {</span><span class="s3">\n            </span><span class="s1">const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];</span><span class="s3">\n            </span><span class="s1">const occurrence = alternation.idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: alternation.idx;</span><span class="s3">\n            </span><span class="s1">const message = errMsgProvider.buildAlternationPrefixAmbiguityError({</span><span class="s3">\n                </span><span class="s1">topLevelRule: rule,</span><span class="s3">\n                </span><span class="s1">alternation: alternation,</span><span class="s3">\n                </span><span class="s1">ambiguityIndices: ambgIndices,</span><span class="s3">\n                </span><span class="s1">prefixPath: currAmbPathAndIdx.path,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">message: message,</span><span class="s3">\n                </span><span class="s1">type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,</span><span class="s3">\n                </span><span class="s1">ruleName: rule.name,</span><span class="s3">\n                </span><span class="s1">occurrence: occurrence,</span><span class="s3">\n                </span><span class="s1">alternatives: ambgIndices,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return currPathPrefixErrors;</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {</span><span class="s3">\n    </span><span class="s1">const errors = [];</span><span class="s3">\n    </span><span class="s1">const tokenNames = map(tokenTypes, (currToken) =&gt; currToken.name);</span><span class="s3">\n    </span><span class="s1">forEach(topLevels, (currRule) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currRuleName = currRule.name;</span><span class="s3">\n        </span><span class="s1">if (includes(tokenNames, currRuleName)) {</span><span class="s3">\n            </span><span class="s1">const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);</span><span class="s3">\n            </span><span class="s1">errors.push({</span><span class="s3">\n                </span><span class="s1">message: errMsg,</span><span class="s3">\n                </span><span class="s1">type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,</span><span class="s3">\n                </span><span class="s1">ruleName: currRuleName,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return errors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=checks.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { defaults, forEach } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { resolveGrammar as orgResolveGrammar } from </span><span class="s3">\&quot;</span><span class="s1">../resolver.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { validateGrammar as orgValidateGrammar } from </span><span class="s3">\&quot;</span><span class="s1">../checks.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defaultGrammarResolverErrorProvider, defaultGrammarValidatorErrorProvider, } from </span><span class="s3">\&quot;</span><span class="s1">../../errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function resolveGrammar(options) {</span><span class="s3">\n    </span><span class="s1">const actualOptions = defaults(options, {</span><span class="s3">\n        </span><span class="s1">errMsgProvider: defaultGrammarResolverErrorProvider,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const topRulesTable = {};</span><span class="s3">\n    </span><span class="s1">forEach(options.rules, (rule) =&gt; {</span><span class="s3">\n        </span><span class="s1">topRulesTable[rule.name] = rule;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateGrammar(options) {</span><span class="s3">\n    </span><span class="s1">options = defaults(options, {</span><span class="s3">\n        </span><span class="s1">errMsgProvider: defaultGrammarValidatorErrorProvider,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return orgValidateGrammar(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=gast_resolver_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { includes } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const MISMATCHED_TOKEN_EXCEPTION = </span><span class="s3">\&quot;</span><span class="s1">MismatchedTokenException</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const NO_VIABLE_ALT_EXCEPTION = </span><span class="s3">\&quot;</span><span class="s1">NoViableAltException</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const EARLY_EXIT_EXCEPTION = </span><span class="s3">\&quot;</span><span class="s1">EarlyExitException</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const NOT_ALL_INPUT_PARSED_EXCEPTION = </span><span class="s3">\&quot;</span><span class="s1">NotAllInputParsedException</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const RECOGNITION_EXCEPTION_NAMES = [</span><span class="s3">\n    </span><span class="s1">MISMATCHED_TOKEN_EXCEPTION,</span><span class="s3">\n    </span><span class="s1">NO_VIABLE_ALT_EXCEPTION,</span><span class="s3">\n    </span><span class="s1">EARLY_EXIT_EXCEPTION,</span><span class="s3">\n    </span><span class="s1">NOT_ALL_INPUT_PARSED_EXCEPTION,</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">Object.freeze(RECOGNITION_EXCEPTION_NAMES);</span><span class="s3">\n</span><span class="s1">// hacks to bypass no support for custom Errors in javascript/typescript</span><span class="s3">\n</span><span class="s1">export function isRecognitionException(error) {</span><span class="s3">\n    </span><span class="s1">// can't do instanceof on hacked custom js exceptions</span><span class="s3">\n    </span><span class="s1">return includes(RECOGNITION_EXCEPTION_NAMES, error.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RecognitionException extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(message, token) {</span><span class="s3">\n        </span><span class="s1">super(message);</span><span class="s3">\n        </span><span class="s1">this.token = token;</span><span class="s3">\n        </span><span class="s1">this.resyncedTokens = [];</span><span class="s3">\n        </span><span class="s1">// fix prototype chain when typescript target is ES5</span><span class="s3">\n        </span><span class="s1">Object.setPrototypeOf(this, new.target.prototype);</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */</span><span class="s3">\n        </span><span class="s1">if (Error.captureStackTrace) {</span><span class="s3">\n            </span><span class="s1">Error.captureStackTrace(this, this.constructor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class MismatchedTokenException extends RecognitionException {</span><span class="s3">\n    </span><span class="s1">constructor(message, token, previousToken) {</span><span class="s3">\n        </span><span class="s1">super(message, token);</span><span class="s3">\n        </span><span class="s1">this.previousToken = previousToken;</span><span class="s3">\n        </span><span class="s1">this.name = MISMATCHED_TOKEN_EXCEPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NoViableAltException extends RecognitionException {</span><span class="s3">\n    </span><span class="s1">constructor(message, token, previousToken) {</span><span class="s3">\n        </span><span class="s1">super(message, token);</span><span class="s3">\n        </span><span class="s1">this.previousToken = previousToken;</span><span class="s3">\n        </span><span class="s1">this.name = NO_VIABLE_ALT_EXCEPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class NotAllInputParsedException extends RecognitionException {</span><span class="s3">\n    </span><span class="s1">constructor(message, token) {</span><span class="s3">\n        </span><span class="s1">super(message, token);</span><span class="s3">\n        </span><span class="s1">this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class EarlyExitException extends RecognitionException {</span><span class="s3">\n    </span><span class="s1">constructor(message, token, previousToken) {</span><span class="s3">\n        </span><span class="s1">super(message, token);</span><span class="s3">\n        </span><span class="s1">this.previousToken = previousToken;</span><span class="s3">\n        </span><span class="s1">this.name = EARLY_EXIT_EXCEPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=exceptions_public.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { createTokenInstance, EOF, tokenMatcher, } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { clone, dropRight, find, flatten, has, includes, isEmpty, map, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { MismatchedTokenException } from </span><span class="s3">\&quot;</span><span class="s1">../../exceptions_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { IN } from </span><span class="s3">\&quot;</span><span class="s1">../../constants.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const EOF_FOLLOW_KEY = {};</span><span class="s3">\n</span><span class="s1">export const IN_RULE_RECOVERY_EXCEPTION = </span><span class="s3">\&quot;</span><span class="s1">InRuleRecoveryException</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class InRuleRecoveryException extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(message) {</span><span class="s3">\n        </span><span class="s1">super(message);</span><span class="s3">\n        </span><span class="s1">this.name = IN_RULE_RECOVERY_EXCEPTION;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This trait is responsible for the error recovery and fault tolerant logic</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Recoverable {</span><span class="s3">\n    </span><span class="s1">initRecoverable(config) {</span><span class="s3">\n        </span><span class="s1">this.firstAfterRepMap = {};</span><span class="s3">\n        </span><span class="s1">this.resyncFollows = {};</span><span class="s3">\n        </span><span class="s1">this.recoveryEnabled = has(config, </span><span class="s3">\&quot;</span><span class="s1">recoveryEnabled</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.recoveryEnabled // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.recoveryEnabled;</span><span class="s3">\n        </span><span class="s1">// performance optimization, NOOP will be inlined which</span><span class="s3">\n        </span><span class="s1">// effectively means that this optional feature does not exist</span><span class="s3">\n        </span><span class="s1">// when not used.</span><span class="s3">\n        </span><span class="s1">if (this.recoveryEnabled) {</span><span class="s3">\n            </span><span class="s1">this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTokenToInsert(tokType) {</span><span class="s3">\n        </span><span class="s1">const tokToInsert = createTokenInstance(tokType, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, NaN, NaN, NaN, NaN, NaN, NaN);</span><span class="s3">\n        </span><span class="s1">tokToInsert.isInsertedInRecovery = true;</span><span class="s3">\n        </span><span class="s1">return tokToInsert;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canTokenTypeBeInsertedInRecovery(tokType) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canTokenTypeBeDeletedInRecovery(tokType) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {</span><span class="s3">\n        </span><span class="s1">// TODO: can the resyncTokenType be cached?</span><span class="s3">\n        </span><span class="s1">const reSyncTokType = this.findReSyncTokenType();</span><span class="s3">\n        </span><span class="s1">const savedLexerState = this.exportLexerState();</span><span class="s3">\n        </span><span class="s1">const resyncedTokens = [];</span><span class="s3">\n        </span><span class="s1">let passedResyncPoint = false;</span><span class="s3">\n        </span><span class="s1">const nextTokenWithoutResync = this.LA(1);</span><span class="s3">\n        </span><span class="s1">let currToken = this.LA(1);</span><span class="s3">\n        </span><span class="s1">const generateErrorMessage = () =&gt; {</span><span class="s3">\n            </span><span class="s1">const previousToken = this.LA(0);</span><span class="s3">\n            </span><span class="s1">// we are preemptively re-syncing before an error has been detected, therefor we must reproduce</span><span class="s3">\n            </span><span class="s1">// the error that would have been thrown</span><span class="s3">\n            </span><span class="s1">const msg = this.errorMessageProvider.buildMismatchTokenMessage({</span><span class="s3">\n                </span><span class="s1">expected: expectedTokType,</span><span class="s3">\n                </span><span class="s1">actual: nextTokenWithoutResync,</span><span class="s3">\n                </span><span class="s1">previous: previousToken,</span><span class="s3">\n                </span><span class="s1">ruleName: this.getCurrRuleFullName(),</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const error = new MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));</span><span class="s3">\n            </span><span class="s1">// the first token here will be the original cause of the error, this is not part of the resyncedTokens property.</span><span class="s3">\n            </span><span class="s1">error.resyncedTokens = dropRight(resyncedTokens);</span><span class="s3">\n            </span><span class="s1">this.SAVE_ERROR(error);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">while (!passedResyncPoint) {</span><span class="s3">\n            </span><span class="s1">// re-synced to a point where we can safely exit the repetition/</span><span class="s3">\n            </span><span class="s1">if (this.tokenMatcher(currToken, expectedTokType)) {</span><span class="s3">\n                </span><span class="s1">generateErrorMessage();</span><span class="s3">\n                </span><span class="s1">return; // must return here to avoid reverting the inputIdx</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (lookAheadFunc.call(this)) {</span><span class="s3">\n                </span><span class="s1">// we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule</span><span class="s3">\n                </span><span class="s1">generateErrorMessage();</span><span class="s3">\n                </span><span class="s1">// recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule</span><span class="s3">\n                </span><span class="s1">grammarRule.apply(this, grammarRuleArgs);</span><span class="s3">\n                </span><span class="s1">return; // must return here to avoid reverting the inputIdx</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.tokenMatcher(currToken, reSyncTokType)) {</span><span class="s3">\n                </span><span class="s1">passedResyncPoint = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">currToken = this.SKIP_TOKEN();</span><span class="s3">\n                </span><span class="s1">this.addToResyncTokens(currToken, resyncedTokens);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// we were unable to find a CLOSER point to resync inside the Repetition, reset the state.</span><span class="s3">\n        </span><span class="s1">// The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">between rules</span><span class="s3">\&quot; </span><span class="s1">resync recovery later in the flow.</span><span class="s3">\n        </span><span class="s1">this.importLexerState(savedLexerState);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {</span><span class="s3">\n        </span><span class="s1">// Edge case of arriving from a MANY repetition which is stuck</span><span class="s3">\n        </span><span class="s1">// Attempting recovery in this case could cause an infinite loop</span><span class="s3">\n        </span><span class="s1">if (notStuck === false) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// no need to recover, next token is what we expect...</span><span class="s3">\n        </span><span class="s1">if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path</span><span class="s3">\n        </span><span class="s1">// and prefer some backtracking path that includes recovered errors.</span><span class="s3">\n        </span><span class="s1">if (this.isBackTracking()) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm</span><span class="s3">\n        </span><span class="s1">// because if it works, it makes the least amount of changes to the input stream (greedy algorithm)</span><span class="s3">\n        </span><span class="s1">//noinspection RedundantIfStatementJS</span><span class="s3">\n        </span><span class="s1">if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Error Recovery functionality</span><span class="s3">\n    </span><span class="s1">getFollowsForInRuleRecovery(tokType, tokIdxInRule) {</span><span class="s3">\n        </span><span class="s1">const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);</span><span class="s3">\n        </span><span class="s1">const follows = this.getNextPossibleTokenTypes(grammarPath);</span><span class="s3">\n        </span><span class="s1">return follows;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tryInRuleRecovery(expectedTokType, follows) {</span><span class="s3">\n        </span><span class="s1">if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {</span><span class="s3">\n            </span><span class="s1">const tokToInsert = this.getTokenToInsert(expectedTokType);</span><span class="s3">\n            </span><span class="s1">return tokToInsert;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {</span><span class="s3">\n            </span><span class="s1">const nextTok = this.SKIP_TOKEN();</span><span class="s3">\n            </span><span class="s1">this.consumeToken();</span><span class="s3">\n            </span><span class="s1">return nextTok;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw new InRuleRecoveryException(</span><span class="s3">\&quot;</span><span class="s1">sad sad panda</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canPerformInRuleRecovery(expectedToken, follows) {</span><span class="s3">\n        </span><span class="s1">return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||</span><span class="s3">\n            </span><span class="s1">this.canRecoverWithSingleTokenDeletion(expectedToken));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canRecoverWithSingleTokenInsertion(expectedTokType, follows) {</span><span class="s3">\n        </span><span class="s1">if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// must know the possible following tokens to perform single token insertion</span><span class="s3">\n        </span><span class="s1">if (isEmpty(follows)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const mismatchedTok = this.LA(1);</span><span class="s3">\n        </span><span class="s1">const isMisMatchedTokInFollows = find(follows, (possibleFollowsTokType) =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);</span><span class="s3">\n        </span><span class="s1">}) !== undefined;</span><span class="s3">\n        </span><span class="s1">return isMisMatchedTokInFollows;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">canRecoverWithSingleTokenDeletion(expectedTokType) {</span><span class="s3">\n        </span><span class="s1">if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);</span><span class="s3">\n        </span><span class="s1">return isNextTokenWhatIsExpected;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isInCurrentRuleReSyncSet(tokenTypeIdx) {</span><span class="s3">\n        </span><span class="s1">const followKey = this.getCurrFollowKey();</span><span class="s3">\n        </span><span class="s1">const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);</span><span class="s3">\n        </span><span class="s1">return includes(currentRuleReSyncSet, tokenTypeIdx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findReSyncTokenType() {</span><span class="s3">\n        </span><span class="s1">const allPossibleReSyncTokTypes = this.flattenFollowSet();</span><span class="s3">\n        </span><span class="s1">// this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input</span><span class="s3">\n        </span><span class="s1">let nextToken = this.LA(1);</span><span class="s3">\n        </span><span class="s1">let k = 2;</span><span class="s3">\n        </span><span class="s1">while (true) {</span><span class="s3">\n            </span><span class="s1">const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) =&gt; {</span><span class="s3">\n                </span><span class="s1">const canMatch = tokenMatcher(nextToken, resyncTokType);</span><span class="s3">\n                </span><span class="s1">return canMatch;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (foundMatch !== undefined) {</span><span class="s3">\n                </span><span class="s1">return foundMatch;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">nextToken = this.LA(k);</span><span class="s3">\n            </span><span class="s1">k++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getCurrFollowKey() {</span><span class="s3">\n        </span><span class="s1">// the length is at least one as we always add the ruleName to the stack before invoking the rule.</span><span class="s3">\n        </span><span class="s1">if (this.RULE_STACK.length === 1) {</span><span class="s3">\n            </span><span class="s1">return EOF_FOLLOW_KEY;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const currRuleShortName = this.getLastExplicitRuleShortName();</span><span class="s3">\n        </span><span class="s1">const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();</span><span class="s3">\n        </span><span class="s1">const prevRuleShortName = this.getPreviousExplicitRuleShortName();</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">ruleName: this.shortRuleNameToFullName(currRuleShortName),</span><span class="s3">\n            </span><span class="s1">idxInCallingRule: currRuleIdx,</span><span class="s3">\n            </span><span class="s1">inRule: this.shortRuleNameToFullName(prevRuleShortName),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildFullFollowKeyStack() {</span><span class="s3">\n        </span><span class="s1">const explicitRuleStack = this.RULE_STACK;</span><span class="s3">\n        </span><span class="s1">const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;</span><span class="s3">\n        </span><span class="s1">return map(explicitRuleStack, (ruleName, idx) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (idx === 0) {</span><span class="s3">\n                </span><span class="s1">return EOF_FOLLOW_KEY;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">ruleName: this.shortRuleNameToFullName(ruleName),</span><span class="s3">\n                </span><span class="s1">idxInCallingRule: explicitOccurrenceStack[idx],</span><span class="s3">\n                </span><span class="s1">inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flattenFollowSet() {</span><span class="s3">\n        </span><span class="s1">const followStack = map(this.buildFullFollowKeyStack(), (currKey) =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.getFollowSetFromFollowKey(currKey);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return flatten(followStack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getFollowSetFromFollowKey(followKey) {</span><span class="s3">\n        </span><span class="s1">if (followKey === EOF_FOLLOW_KEY) {</span><span class="s3">\n            </span><span class="s1">return [EOF];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const followName = followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;</span><span class="s3">\n        </span><span class="s1">return this.resyncFollows[followName];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// It does not make any sense to include a virtual EOF token in the list of resynced tokens</span><span class="s3">\n    </span><span class="s1">// as EOF does not really exist and thus does not contain any useful information (line/column numbers)</span><span class="s3">\n    </span><span class="s1">addToResyncTokens(token, resyncTokens) {</span><span class="s3">\n        </span><span class="s1">if (!this.tokenMatcher(token, EOF)) {</span><span class="s3">\n            </span><span class="s1">resyncTokens.push(token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return resyncTokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reSyncTo(tokType) {</span><span class="s3">\n        </span><span class="s1">const resyncedTokens = [];</span><span class="s3">\n        </span><span class="s1">let nextTok = this.LA(1);</span><span class="s3">\n        </span><span class="s1">while (this.tokenMatcher(nextTok, tokType) === false) {</span><span class="s3">\n            </span><span class="s1">nextTok = this.SKIP_TOKEN();</span><span class="s3">\n            </span><span class="s1">this.addToResyncTokens(nextTok, resyncedTokens);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// the last token is not part of the error.</span><span class="s3">\n        </span><span class="s1">return dropRight(resyncedTokens);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {</span><span class="s3">\n        </span><span class="s1">// by default this is a NO-OP</span><span class="s3">\n        </span><span class="s1">// The actual implementation is with the function(not method) below</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getCurrentGrammarPath(tokType, tokIdxInRule) {</span><span class="s3">\n        </span><span class="s1">const pathRuleStack = this.getHumanReadableRuleStack();</span><span class="s3">\n        </span><span class="s1">const pathOccurrenceStack = clone(this.RULE_OCCURRENCE_STACK);</span><span class="s3">\n        </span><span class="s1">const grammarPath = {</span><span class="s3">\n            </span><span class="s1">ruleStack: pathRuleStack,</span><span class="s3">\n            </span><span class="s1">occurrenceStack: pathOccurrenceStack,</span><span class="s3">\n            </span><span class="s1">lastTok: tokType,</span><span class="s3">\n            </span><span class="s1">lastTokOccurrence: tokIdxInRule,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return grammarPath;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getHumanReadableRuleStack() {</span><span class="s3">\n        </span><span class="s1">return map(this.RULE_STACK, (currShortName) =&gt; this.shortRuleNameToFullName(currShortName));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {</span><span class="s3">\n    </span><span class="s1">const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);</span><span class="s3">\n    </span><span class="s1">let firstAfterRepInfo = this.firstAfterRepMap[key];</span><span class="s3">\n    </span><span class="s1">if (firstAfterRepInfo === undefined) {</span><span class="s3">\n        </span><span class="s1">const currRuleName = this.getCurrRuleFullName();</span><span class="s3">\n        </span><span class="s1">const ruleGrammar = this.getGAstProductions()[currRuleName];</span><span class="s3">\n        </span><span class="s1">const walker = new nextToksWalker(ruleGrammar, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">firstAfterRepInfo = walker.startWalking();</span><span class="s3">\n        </span><span class="s1">this.firstAfterRepMap[key] = firstAfterRepInfo;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let expectTokAfterLastMatch = firstAfterRepInfo.token;</span><span class="s3">\n    </span><span class="s1">let nextTokIdx = firstAfterRepInfo.occurrence;</span><span class="s3">\n    </span><span class="s1">const isEndOfRule = firstAfterRepInfo.isEndOfRule;</span><span class="s3">\n    </span><span class="s1">// special edge case of a TOP most repetition after which the input should END.</span><span class="s3">\n    </span><span class="s1">// this will force an attempt for inRule recovery in that scenario.</span><span class="s3">\n    </span><span class="s1">if (this.RULE_STACK.length === 1 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">isEndOfRule &amp;&amp;</span><span class="s3">\n        </span><span class="s1">expectTokAfterLastMatch === undefined) {</span><span class="s3">\n        </span><span class="s1">expectTokAfterLastMatch = EOF;</span><span class="s3">\n        </span><span class="s1">nextTokIdx = 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// We don't have anything to re-sync to...</span><span class="s3">\n    </span><span class="s1">// this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard</span><span class="s3">\n    </span><span class="s1">if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {</span><span class="s3">\n        </span><span class="s1">// TODO: performance optimization: instead of passing the original args here, we modify</span><span class="s3">\n        </span><span class="s1">// the args param (or create a new one) and make sure the lookahead func is explicitly provided</span><span class="s3">\n        </span><span class="s1">// to avoid searching the cache for it once more.</span><span class="s3">\n        </span><span class="s1">this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=recoverable.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;// Lookahead keys are 32Bit integers in the form</span><span class="s3">\n</span><span class="s1">// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX</span><span class="s3">\n</span><span class="s1">// XXXX -&gt; Occurrence Index bitmap.</span><span class="s3">\n</span><span class="s1">// YYYY -&gt; DSL Method Type bitmap.</span><span class="s3">\n</span><span class="s1">// ZZZZZZZZZZZZZZZ -&gt; Rule short Index bitmap.</span><span class="s3">\n</span><span class="s1">// TTTTTTTTT -&gt; alternation alternative index bitmap</span><span class="s3">\n</span><span class="s1">export const BITS_FOR_METHOD_TYPE = 4;</span><span class="s3">\n</span><span class="s1">export const BITS_FOR_OCCURRENCE_IDX = 8;</span><span class="s3">\n</span><span class="s1">export const BITS_FOR_RULE_IDX = 12;</span><span class="s3">\n</span><span class="s1">// TODO: validation, this means that there may at most 2^8 --&gt; 256 alternatives for an alternation.</span><span class="s3">\n</span><span class="s1">export const BITS_FOR_ALT_IDX = 8;</span><span class="s3">\n</span><span class="s1">// short string used as part of mapping keys.</span><span class="s3">\n</span><span class="s1">// being short improves the performance when composing KEYS for maps out of these</span><span class="s3">\n</span><span class="s1">// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)</span><span class="s3">\n</span><span class="s1">export const OR_IDX = 1 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">export const OPTION_IDX = 2 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">export const MANY_IDX = 3 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">export const AT_LEAST_ONE_IDX = 4 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">export const MANY_SEP_IDX = 5 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">export const AT_LEAST_ONE_SEP_IDX = 6 &lt;&lt; BITS_FOR_OCCURRENCE_IDX;</span><span class="s3">\n</span><span class="s1">// this actually returns a number, but it is always used as a string (object prop key)</span><span class="s3">\n</span><span class="s1">export function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {</span><span class="s3">\n    </span><span class="s1">return occurrence | dslMethodIdx | ruleIdx;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=keys.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { flatMap, isEmpty } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defaultGrammarValidatorErrorProvider } from </span><span class="s3">\&quot;</span><span class="s1">../errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser/parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { validateAmbiguousAlternationAlternatives, validateEmptyOrAlternative, validateNoLeftRecursion, validateSomeNonEmptyLookaheadPath, } from </span><span class="s3">\&quot;</span><span class="s1">./checks.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { buildAlternativesLookAheadFunc, buildLookaheadFuncForOptionalProd, buildLookaheadFuncForOr, buildSingleAlternativeLookaheadFunction, getProdType, } from </span><span class="s3">\&quot;</span><span class="s1">./lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class LLkLookaheadStrategy {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.maxLookahead =</span><span class="s3">\n            </span><span class="s1">(_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null &amp;&amp; _a !== void 0 ? _a : DEFAULT_PARSER_CONFIG.maxLookahead;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validate(options) {</span><span class="s3">\n        </span><span class="s1">const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);</span><span class="s3">\n        </span><span class="s1">if (isEmpty(leftRecursionErrors)) {</span><span class="s3">\n            </span><span class="s1">const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);</span><span class="s3">\n            </span><span class="s1">const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);</span><span class="s3">\n            </span><span class="s1">const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);</span><span class="s3">\n            </span><span class="s1">const allErrors = [</span><span class="s3">\n                </span><span class="s1">...leftRecursionErrors,</span><span class="s3">\n                </span><span class="s1">...emptyAltErrors,</span><span class="s3">\n                </span><span class="s1">...ambiguousAltsErrors,</span><span class="s3">\n                </span><span class="s1">...emptyRepetitionErrors,</span><span class="s3">\n            </span><span class="s1">];</span><span class="s3">\n            </span><span class="s1">return allErrors;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return leftRecursionErrors;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateNoLeftRecursion(rules) {</span><span class="s3">\n        </span><span class="s1">return flatMap(rules, (currTopRule) =&gt; validateNoLeftRecursion(currTopRule, currTopRule, defaultGrammarValidatorErrorProvider));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateEmptyOrAlternatives(rules) {</span><span class="s3">\n        </span><span class="s1">return flatMap(rules, (currTopRule) =&gt; validateEmptyOrAlternative(currTopRule, defaultGrammarValidatorErrorProvider));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateAmbiguousAlternationAlternatives(rules, maxLookahead) {</span><span class="s3">\n        </span><span class="s1">return flatMap(rules, (currTopRule) =&gt; validateAmbiguousAlternationAlternatives(currTopRule, maxLookahead, defaultGrammarValidatorErrorProvider));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {</span><span class="s3">\n        </span><span class="s1">return validateSomeNonEmptyLookaheadPath(rules, maxLookahead, defaultGrammarValidatorErrorProvider);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLookaheadForAlternation(options) {</span><span class="s3">\n        </span><span class="s1">return buildLookaheadFuncForOr(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, buildAlternativesLookAheadFunc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLookaheadForOptional(options) {</span><span class="s3">\n        </span><span class="s1">return buildLookaheadFuncForOptionalProd(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, getProdType(options.prodType), buildSingleAlternativeLookaheadFunction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=llk_lookahead.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { forEach, has } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, getKeyForAutomaticLookahead, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/keys.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { GAstVisitor, getProductionDslName, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { LLkLookaheadStrategy } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/llk_lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Trait responsible for the lookahead related utilities and optimizations.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LooksAhead {</span><span class="s3">\n    </span><span class="s1">initLooksAhead(config) {</span><span class="s3">\n        </span><span class="s1">this.dynamicTokensEnabled = has(config, </span><span class="s3">\&quot;</span><span class="s1">dynamicTokensEnabled</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.dynamicTokensEnabled // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;</span><span class="s3">\n        </span><span class="s1">this.maxLookahead = has(config, </span><span class="s3">\&quot;</span><span class="s1">maxLookahead</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.maxLookahead // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.maxLookahead;</span><span class="s3">\n        </span><span class="s1">this.lookaheadStrategy = has(config, </span><span class="s3">\&quot;</span><span class="s1">lookaheadStrategy</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.lookaheadStrategy // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });</span><span class="s3">\n        </span><span class="s1">this.lookAheadFuncsCache = new Map();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">preComputeLookaheadFunctions(rules) {</span><span class="s3">\n        </span><span class="s1">forEach(rules, (currRule) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () =&gt; {</span><span class="s3">\n                </span><span class="s1">const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);</span><span class="s3">\n                </span><span class="s1">forEach(alternation, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const prodIdx = currProd.idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: currProd.idx;</span><span class="s3">\n                    </span><span class="s1">this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () =&gt; {</span><span class="s3">\n                        </span><span class="s1">const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({</span><span class="s3">\n                            </span><span class="s1">prodOccurrence: currProd.idx,</span><span class="s3">\n                            </span><span class="s1">rule: currRule,</span><span class="s3">\n                            </span><span class="s1">maxLookahead: currProd.maxLookahead || this.maxLookahead,</span><span class="s3">\n                            </span><span class="s1">hasPredicates: currProd.hasPredicates,</span><span class="s3">\n                            </span><span class="s1">dynamicTokensEnabled: this.dynamicTokensEnabled,</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[currRule.name], OR_IDX, currProd.idx);</span><span class="s3">\n                        </span><span class="s1">this.setLaFuncCache(key, laFunc);</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">forEach(repetition, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.computeLookaheadFunc(currRule, currProd.idx, MANY_IDX, </span><span class="s3">\&quot;</span><span class="s1">Repetition</span><span class="s3">\&quot;</span><span class="s1">, currProd.maxLookahead, getProductionDslName(currProd));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">forEach(option, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.computeLookaheadFunc(currRule, currProd.idx, OPTION_IDX, </span><span class="s3">\&quot;</span><span class="s1">Option</span><span class="s3">\&quot;</span><span class="s1">, currProd.maxLookahead, getProductionDslName(currProd));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">forEach(repetitionMandatory, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_IDX, </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatory</span><span class="s3">\&quot;</span><span class="s1">, currProd.maxLookahead, getProductionDslName(currProd));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">forEach(repetitionMandatoryWithSeparator, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.computeLookaheadFunc(currRule, currProd.idx, AT_LEAST_ONE_SEP_IDX, </span><span class="s3">\&quot;</span><span class="s1">RepetitionMandatoryWithSeparator</span><span class="s3">\&quot;</span><span class="s1">, currProd.maxLookahead, getProductionDslName(currProd));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">forEach(repetitionWithSeparator, (currProd) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.computeLookaheadFunc(currRule, currProd.idx, MANY_SEP_IDX, </span><span class="s3">\&quot;</span><span class="s1">RepetitionWithSeparator</span><span class="s3">\&quot;</span><span class="s1">, currProd.maxLookahead, getProductionDslName(currProd));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: prodOccurrence}`, () =&gt; {</span><span class="s3">\n            </span><span class="s1">const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({</span><span class="s3">\n                </span><span class="s1">prodOccurrence,</span><span class="s3">\n                </span><span class="s1">rule,</span><span class="s3">\n                </span><span class="s1">maxLookahead: prodMaxLookahead || this.maxLookahead,</span><span class="s3">\n                </span><span class="s1">dynamicTokensEnabled: this.dynamicTokensEnabled,</span><span class="s3">\n                </span><span class="s1">prodType,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const key = getKeyForAutomaticLookahead(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);</span><span class="s3">\n            </span><span class="s1">this.setLaFuncCache(key, laFunc);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// this actually returns a number, but it is always used as a string (object prop key)</span><span class="s3">\n    </span><span class="s1">getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {</span><span class="s3">\n        </span><span class="s1">const currRuleShortName = this.getLastExplicitRuleShortName();</span><span class="s3">\n        </span><span class="s1">return getKeyForAutomaticLookahead(currRuleShortName, dslMethodIdx, occurrence);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLaFuncFromCache(key) {</span><span class="s3">\n        </span><span class="s1">return this.lookAheadFuncsCache.get(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n    </span><span class="s1">setLaFuncCache(key, value) {</span><span class="s3">\n        </span><span class="s1">this.lookAheadFuncsCache.set(key, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class DslMethodsCollectorVisitor extends GAstVisitor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.dslMethods = {</span><span class="s3">\n            </span><span class="s1">option: [],</span><span class="s3">\n            </span><span class="s1">alternation: [],</span><span class="s3">\n            </span><span class="s1">repetition: [],</span><span class="s3">\n            </span><span class="s1">repetitionWithSeparator: [],</span><span class="s3">\n            </span><span class="s1">repetitionMandatory: [],</span><span class="s3">\n            </span><span class="s1">repetitionMandatoryWithSeparator: [],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reset() {</span><span class="s3">\n        </span><span class="s1">this.dslMethods = {</span><span class="s3">\n            </span><span class="s1">option: [],</span><span class="s3">\n            </span><span class="s1">alternation: [],</span><span class="s3">\n            </span><span class="s1">repetition: [],</span><span class="s3">\n            </span><span class="s1">repetitionWithSeparator: [],</span><span class="s3">\n            </span><span class="s1">repetitionMandatory: [],</span><span class="s3">\n            </span><span class="s1">repetitionMandatoryWithSeparator: [],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitOption(option) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.option.push(option);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionWithSeparator(manySep) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.repetitionWithSeparator.push(manySep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatory(atLeastOne) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.repetitionMandatory.push(atLeastOne);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetitionMandatoryWithSeparator(atLeastOneSep) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitRepetition(many) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.repetition.push(many);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitAlternation(or) {</span><span class="s3">\n        </span><span class="s1">this.dslMethods.alternation.push(or);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const collectorVisitor = new DslMethodsCollectorVisitor();</span><span class="s3">\n</span><span class="s1">export function collectMethods(rule) {</span><span class="s3">\n    </span><span class="s1">collectorVisitor.reset();</span><span class="s3">\n    </span><span class="s1">rule.accept(collectorVisitor);</span><span class="s3">\n    </span><span class="s1">const dslMethods = collectorVisitor.dslMethods;</span><span class="s3">\n    </span><span class="s1">// avoid uncleaned references</span><span class="s3">\n    </span><span class="s1">collectorVisitor.reset();</span><span class="s3">\n    </span><span class="s1">return dslMethods;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=looksahead.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This nodeLocation tracking is not efficient and should only be used</span><span class="s3">\n </span><span class="s1">* when error recovery is enabled or the Token Vector contains virtual Tokens</span><span class="s3">\n </span><span class="s1">* (e.g, Python Indent/Outdent)</span><span class="s3">\n </span><span class="s1">* As it executes the calculation for every single terminal/nonTerminal</span><span class="s3">\n </span><span class="s1">* and does not rely on the fact the token vector is **sorted**</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {</span><span class="s3">\n    </span><span class="s1">// First (valid) update for this cst node</span><span class="s3">\n    </span><span class="s1">if (isNaN(currNodeLocation.startOffset) === true) {</span><span class="s3">\n        </span><span class="s1">// assumption1: Token location information is either NaN or a valid number</span><span class="s3">\n        </span><span class="s1">// assumption2: Token location information is fully valid if it exist</span><span class="s3">\n        </span><span class="s1">// (both start/end offsets exist and are numbers).</span><span class="s3">\n        </span><span class="s1">currNodeLocation.startOffset = newLocationInfo.startOffset;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endOffset = newLocationInfo.endOffset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Once the startOffset has been updated with a valid number it should never receive</span><span class="s3">\n    </span><span class="s1">// any farther updates as the Token vector is sorted.</span><span class="s3">\n    </span><span class="s1">// We still have to check this this condition for every new possible location info</span><span class="s3">\n    </span><span class="s1">// because with error recovery enabled we may encounter invalid tokens (NaN location props)</span><span class="s3">\n    </span><span class="s1">else if (currNodeLocation.endOffset &lt; newLocationInfo.endOffset === true) {</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endOffset = newLocationInfo.endOffset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This nodeLocation tracking is not efficient and should only be used</span><span class="s3">\n </span><span class="s1">* when error recovery is enabled or the Token Vector contains virtual Tokens</span><span class="s3">\n </span><span class="s1">* (e.g, Python Indent/Outdent)</span><span class="s3">\n </span><span class="s1">* As it executes the calculation for every single terminal/nonTerminal</span><span class="s3">\n </span><span class="s1">* and does not rely on the fact the token vector is **sorted**</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setNodeLocationFull(currNodeLocation, newLocationInfo) {</span><span class="s3">\n    </span><span class="s1">// First (valid) update for this cst node</span><span class="s3">\n    </span><span class="s1">if (isNaN(currNodeLocation.startOffset) === true) {</span><span class="s3">\n        </span><span class="s1">// assumption1: Token location information is either NaN or a valid number</span><span class="s3">\n        </span><span class="s1">// assumption2: Token location information is fully valid if it exist</span><span class="s3">\n        </span><span class="s1">// (all start/end props exist and are numbers).</span><span class="s3">\n        </span><span class="s1">currNodeLocation.startOffset = newLocationInfo.startOffset;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.startColumn = newLocationInfo.startColumn;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.startLine = newLocationInfo.startLine;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endOffset = newLocationInfo.endOffset;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endColumn = newLocationInfo.endColumn;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endLine = newLocationInfo.endLine;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Once the start props has been updated with a valid number it should never receive</span><span class="s3">\n    </span><span class="s1">// any farther updates as the Token vector is sorted.</span><span class="s3">\n    </span><span class="s1">// We still have to check this this condition for every new possible location info</span><span class="s3">\n    </span><span class="s1">// because with error recovery enabled we may encounter invalid tokens (NaN location props)</span><span class="s3">\n    </span><span class="s1">else if (currNodeLocation.endOffset &lt; newLocationInfo.endOffset === true) {</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endOffset = newLocationInfo.endOffset;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endColumn = newLocationInfo.endColumn;</span><span class="s3">\n        </span><span class="s1">currNodeLocation.endLine = newLocationInfo.endLine;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function addTerminalToCst(node, token, tokenTypeName) {</span><span class="s3">\n    </span><span class="s1">if (node.children[tokenTypeName] === undefined) {</span><span class="s3">\n        </span><span class="s1">node.children[tokenTypeName] = [token];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">node.children[tokenTypeName].push(token);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function addNoneTerminalToCst(node, ruleName, ruleResult) {</span><span class="s3">\n    </span><span class="s1">if (node.children[ruleName] === undefined) {</span><span class="s3">\n        </span><span class="s1">node.children[ruleName] = [ruleResult];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">node.children[ruleName].push(ruleResult);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=cst.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;const NAME = </span><span class="s3">\&quot;</span><span class="s1">name</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function defineNameProp(obj, nameValue) {</span><span class="s3">\n    </span><span class="s1">Object.defineProperty(obj, NAME, {</span><span class="s3">\n        </span><span class="s1">enumerable: false,</span><span class="s3">\n        </span><span class="s1">configurable: true,</span><span class="s3">\n        </span><span class="s1">writable: false,</span><span class="s3">\n        </span><span class="s1">value: nameValue,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lang_extensions.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { compact, filter, forEach, isArray, isEmpty, isFunction, isUndefined, keys, map, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defineNameProp } from </span><span class="s3">\&quot;</span><span class="s1">../../lang/lang_extensions.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function defaultVisit(ctx, param) {</span><span class="s3">\n    </span><span class="s1">const childrenNames = keys(ctx);</span><span class="s3">\n    </span><span class="s1">const childrenNamesLength = childrenNames.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; childrenNamesLength; i++) {</span><span class="s3">\n        </span><span class="s1">const currChildName = childrenNames[i];</span><span class="s3">\n        </span><span class="s1">const currChildArray = ctx[currChildName];</span><span class="s3">\n        </span><span class="s1">const currChildArrayLength = currChildArray.length;</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; currChildArrayLength; j++) {</span><span class="s3">\n            </span><span class="s1">const currChild = currChildArray[j];</span><span class="s3">\n            </span><span class="s1">// distinction between Tokens Children and CstNode children</span><span class="s3">\n            </span><span class="s1">if (currChild.tokenTypeIdx === undefined) {</span><span class="s3">\n                </span><span class="s1">this[currChild.name](currChild.children, param);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// defaultVisit does not support generic out param</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {</span><span class="s3">\n    </span><span class="s1">const derivedConstructor = function () { };</span><span class="s3">\n    </span><span class="s1">// can be overwritten according to:</span><span class="s3">\n    </span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/</span><span class="s3">\n    </span><span class="s1">// name?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname</span><span class="s3">\n    </span><span class="s1">defineNameProp(derivedConstructor, grammarName + </span><span class="s3">\&quot;</span><span class="s1">BaseSemantics</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const semanticProto = {</span><span class="s3">\n        </span><span class="s1">visit: function (cstNode, param) {</span><span class="s3">\n            </span><span class="s1">// enables writing more concise visitor methods when CstNode has only a single child</span><span class="s3">\n            </span><span class="s1">if (isArray(cstNode)) {</span><span class="s3">\n                </span><span class="s1">// A CST Node's children dictionary can never have empty arrays as values</span><span class="s3">\n                </span><span class="s1">// If a key is defined there will be at least one element in the corresponding value array.</span><span class="s3">\n                </span><span class="s1">cstNode = cstNode[0];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// enables passing optional CstNodes concisely.</span><span class="s3">\n            </span><span class="s1">if (isUndefined(cstNode)) {</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this[cstNode.name](cstNode.children, param);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">validateVisitor: function () {</span><span class="s3">\n            </span><span class="s1">const semanticDefinitionErrors = validateVisitor(this, ruleNames);</span><span class="s3">\n            </span><span class="s1">if (!isEmpty(semanticDefinitionErrors)) {</span><span class="s3">\n                </span><span class="s1">const errorMessages = map(semanticDefinitionErrors, (currDefError) =&gt; currDefError.msg);</span><span class="s3">\n                </span><span class="s1">throw Error(`Errors Detected in CST Visitor &lt;${this.constructor.name}&gt;:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t` +</span><span class="s3">\n                    </span><span class="s1">`${errorMessages.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">).replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">)}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">derivedConstructor.prototype = semanticProto;</span><span class="s3">\n    </span><span class="s1">derivedConstructor.prototype.constructor = derivedConstructor;</span><span class="s3">\n    </span><span class="s1">derivedConstructor._RULE_NAMES = ruleNames;</span><span class="s3">\n    </span><span class="s1">return derivedConstructor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {</span><span class="s3">\n    </span><span class="s1">const derivedConstructor = function () { };</span><span class="s3">\n    </span><span class="s1">// can be overwritten according to:</span><span class="s3">\n    </span><span class="s1">// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/</span><span class="s3">\n    </span><span class="s1">// name?redirectlocale=en-US&amp;redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname</span><span class="s3">\n    </span><span class="s1">defineNameProp(derivedConstructor, grammarName + </span><span class="s3">\&quot;</span><span class="s1">BaseSemanticsWithDefaults</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const withDefaultsProto = Object.create(baseConstructor.prototype);</span><span class="s3">\n    </span><span class="s1">forEach(ruleNames, (ruleName) =&gt; {</span><span class="s3">\n        </span><span class="s1">withDefaultsProto[ruleName] = defaultVisit;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">derivedConstructor.prototype = withDefaultsProto;</span><span class="s3">\n    </span><span class="s1">derivedConstructor.prototype.constructor = derivedConstructor;</span><span class="s3">\n    </span><span class="s1">return derivedConstructor;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var CstVisitorDefinitionError;</span><span class="s3">\n</span><span class="s1">(function (CstVisitorDefinitionError) {</span><span class="s3">\n    </span><span class="s1">CstVisitorDefinitionError[CstVisitorDefinitionError[</span><span class="s3">\&quot;</span><span class="s1">REDUNDANT_METHOD</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">REDUNDANT_METHOD</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">CstVisitorDefinitionError[CstVisitorDefinitionError[</span><span class="s3">\&quot;</span><span class="s1">MISSING_METHOD</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">MISSING_METHOD</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));</span><span class="s3">\n</span><span class="s1">export function validateVisitor(visitorInstance, ruleNames) {</span><span class="s3">\n    </span><span class="s1">const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);</span><span class="s3">\n    </span><span class="s1">return missingErrors;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function validateMissingCstMethods(visitorInstance, ruleNames) {</span><span class="s3">\n    </span><span class="s1">const missingRuleNames = filter(ruleNames, (currRuleName) =&gt; {</span><span class="s3">\n        </span><span class="s1">return isFunction(visitorInstance[currRuleName]) === false;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const errors = map(missingRuleNames, (currRuleName) =&gt; {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">msg: `Missing visitor method: &lt;${currRuleName}&gt; on ${(visitorInstance.constructor.name)} CST Visitor.`,</span><span class="s3">\n            </span><span class="s1">type: CstVisitorDefinitionError.MISSING_METHOD,</span><span class="s3">\n            </span><span class="s1">methodName: currRuleName,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return compact(errors);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=cst_visitor.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { addNoneTerminalToCst, addTerminalToCst, setNodeLocationFull, setNodeLocationOnlyOffset, } from </span><span class="s3">\&quot;</span><span class="s1">../../cst/cst.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { has, isUndefined, keys, noop } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createBaseSemanticVisitorConstructor, createBaseVisitorConstructorWithDefaults, } from </span><span class="s3">\&quot;</span><span class="s1">../../cst/cst_visitor.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This trait is responsible for the CST building logic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class TreeBuilder {</span><span class="s3">\n    </span><span class="s1">initTreeBuilder(config) {</span><span class="s3">\n        </span><span class="s1">this.CST_STACK = [];</span><span class="s3">\n        </span><span class="s1">// outputCst is no longer exposed/defined in the pubic API</span><span class="s3">\n        </span><span class="s1">this.outputCst = config.outputCst;</span><span class="s3">\n        </span><span class="s1">this.nodeLocationTracking = has(config, </span><span class="s3">\&quot;</span><span class="s1">nodeLocationTracking</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.nodeLocationTracking // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.nodeLocationTracking;</span><span class="s3">\n        </span><span class="s1">if (!this.outputCst) {</span><span class="s3">\n            </span><span class="s1">this.cstInvocationStateUpdate = noop;</span><span class="s3">\n            </span><span class="s1">this.cstFinallyStateUpdate = noop;</span><span class="s3">\n            </span><span class="s1">this.cstPostTerminal = noop;</span><span class="s3">\n            </span><span class="s1">this.cstPostNonTerminal = noop;</span><span class="s3">\n            </span><span class="s1">this.cstPostRule = noop;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (/full/i.test(this.nodeLocationTracking)) {</span><span class="s3">\n                </span><span class="s1">if (this.recoveryEnabled) {</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromToken = setNodeLocationFull;</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromNode = setNodeLocationFull;</span><span class="s3">\n                    </span><span class="s1">this.cstPostRule = noop;</span><span class="s3">\n                    </span><span class="s1">this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromToken = noop;</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromNode = noop;</span><span class="s3">\n                    </span><span class="s1">this.cstPostRule = this.cstPostRuleFull;</span><span class="s3">\n                    </span><span class="s1">this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (/onlyOffset/i.test(this.nodeLocationTracking)) {</span><span class="s3">\n                </span><span class="s1">if (this.recoveryEnabled) {</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromToken = setNodeLocationOnlyOffset;</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromNode = setNodeLocationOnlyOffset;</span><span class="s3">\n                    </span><span class="s1">this.cstPostRule = noop;</span><span class="s3">\n                    </span><span class="s1">this.setInitialNodeLocation =</span><span class="s3">\n                        </span><span class="s1">this.setInitialNodeLocationOnlyOffsetRecovery;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromToken = noop;</span><span class="s3">\n                    </span><span class="s1">this.setNodeLocationFromNode = noop;</span><span class="s3">\n                    </span><span class="s1">this.cstPostRule = this.cstPostRuleOnlyOffset;</span><span class="s3">\n                    </span><span class="s1">this.setInitialNodeLocation =</span><span class="s3">\n                        </span><span class="s1">this.setInitialNodeLocationOnlyOffsetRegular;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (/none/i.test(this.nodeLocationTracking)) {</span><span class="s3">\n                </span><span class="s1">this.setNodeLocationFromToken = noop;</span><span class="s3">\n                </span><span class="s1">this.setNodeLocationFromNode = noop;</span><span class="s3">\n                </span><span class="s1">this.cstPostRule = noop;</span><span class="s3">\n                </span><span class="s1">this.setInitialNodeLocation = noop;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw Error(`Invalid &lt;nodeLocationTracking&gt; config option: </span><span class="s3">\&quot;</span><span class="s1">${config.nodeLocationTracking}</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setInitialNodeLocationOnlyOffsetRecovery(cstNode) {</span><span class="s3">\n        </span><span class="s1">cstNode.location = {</span><span class="s3">\n            </span><span class="s1">startOffset: NaN,</span><span class="s3">\n            </span><span class="s1">endOffset: NaN,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setInitialNodeLocationOnlyOffsetRegular(cstNode) {</span><span class="s3">\n        </span><span class="s1">cstNode.location = {</span><span class="s3">\n            </span><span class="s1">// without error recovery the starting Location of a new CstNode is guaranteed</span><span class="s3">\n            </span><span class="s1">// To be the next Token's startOffset (for valid inputs).</span><span class="s3">\n            </span><span class="s1">// For invalid inputs there won't be any CSTOutput so this potential</span><span class="s3">\n            </span><span class="s1">// inaccuracy does not matter</span><span class="s3">\n            </span><span class="s1">startOffset: this.LA(1).startOffset,</span><span class="s3">\n            </span><span class="s1">endOffset: NaN,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setInitialNodeLocationFullRecovery(cstNode) {</span><span class="s3">\n        </span><span class="s1">cstNode.location = {</span><span class="s3">\n            </span><span class="s1">startOffset: NaN,</span><span class="s3">\n            </span><span class="s1">startLine: NaN,</span><span class="s3">\n            </span><span class="s1">startColumn: NaN,</span><span class="s3">\n            </span><span class="s1">endOffset: NaN,</span><span class="s3">\n            </span><span class="s1">endLine: NaN,</span><span class="s3">\n            </span><span class="s1">endColumn: NaN,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">*  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work</span><span class="s3">\n  \n       </span><span class="s1">* @param cstNode</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setInitialNodeLocationFullRegular(cstNode) {</span><span class="s3">\n        </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n        </span><span class="s1">cstNode.location = {</span><span class="s3">\n            </span><span class="s1">startOffset: nextToken.startOffset,</span><span class="s3">\n            </span><span class="s1">startLine: nextToken.startLine,</span><span class="s3">\n            </span><span class="s1">startColumn: nextToken.startColumn,</span><span class="s3">\n            </span><span class="s1">endOffset: NaN,</span><span class="s3">\n            </span><span class="s1">endLine: NaN,</span><span class="s3">\n            </span><span class="s1">endColumn: NaN,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstInvocationStateUpdate(fullRuleName) {</span><span class="s3">\n        </span><span class="s1">const cstNode = {</span><span class="s3">\n            </span><span class="s1">name: fullRuleName,</span><span class="s3">\n            </span><span class="s1">children: Object.create(null),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.setInitialNodeLocation(cstNode);</span><span class="s3">\n        </span><span class="s1">this.CST_STACK.push(cstNode);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstFinallyStateUpdate() {</span><span class="s3">\n        </span><span class="s1">this.CST_STACK.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstPostRuleFull(ruleCstNode) {</span><span class="s3">\n        </span><span class="s1">// casts to `required&lt;CstNodeLocation&gt;` are safe because `cstPostRuleFull` should only be invoked when full location is enabled</span><span class="s3">\n        </span><span class="s1">const prevToken = this.LA(0);</span><span class="s3">\n        </span><span class="s1">const loc = ruleCstNode.location;</span><span class="s3">\n        </span><span class="s1">// If this condition is true it means we consumed at least one Token</span><span class="s3">\n        </span><span class="s1">// In this CstNode.</span><span class="s3">\n        </span><span class="s1">if (loc.startOffset &lt;= prevToken.startOffset === true) {</span><span class="s3">\n            </span><span class="s1">loc.endOffset = prevToken.endOffset;</span><span class="s3">\n            </span><span class="s1">loc.endLine = prevToken.endLine;</span><span class="s3">\n            </span><span class="s1">loc.endColumn = prevToken.endColumn;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot; </span><span class="s1">CstNode edge case</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">loc.startOffset = NaN;</span><span class="s3">\n            </span><span class="s1">loc.startLine = NaN;</span><span class="s3">\n            </span><span class="s1">loc.startColumn = NaN;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstPostRuleOnlyOffset(ruleCstNode) {</span><span class="s3">\n        </span><span class="s1">const prevToken = this.LA(0);</span><span class="s3">\n        </span><span class="s1">// `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.</span><span class="s3">\n        </span><span class="s1">const loc = ruleCstNode.location;</span><span class="s3">\n        </span><span class="s1">// If this condition is true it means we consumed at least one Token</span><span class="s3">\n        </span><span class="s1">// In this CstNode.</span><span class="s3">\n        </span><span class="s1">if (loc.startOffset &lt;= prevToken.startOffset === true) {</span><span class="s3">\n            </span><span class="s1">loc.endOffset = prevToken.endOffset;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">empty</span><span class="s3">\&quot; </span><span class="s1">CstNode edge case</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">loc.startOffset = NaN;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstPostTerminal(key, consumedToken) {</span><span class="s3">\n        </span><span class="s1">const rootCst = this.CST_STACK[this.CST_STACK.length - 1];</span><span class="s3">\n        </span><span class="s1">addTerminalToCst(rootCst, consumedToken, key);</span><span class="s3">\n        </span><span class="s1">// This is only used when **both** error recovery and CST Output are enabled.</span><span class="s3">\n        </span><span class="s1">this.setNodeLocationFromToken(rootCst.location, consumedToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstPostNonTerminal(ruleCstResult, ruleName) {</span><span class="s3">\n        </span><span class="s1">const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];</span><span class="s3">\n        </span><span class="s1">addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);</span><span class="s3">\n        </span><span class="s1">// This is only used when **both** error recovery and CST Output are enabled.</span><span class="s3">\n        </span><span class="s1">this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBaseCstVisitorConstructor() {</span><span class="s3">\n        </span><span class="s1">if (isUndefined(this.baseCstVisitorConstructor)) {</span><span class="s3">\n            </span><span class="s1">const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(this.className, keys(this.gastProductionsCache));</span><span class="s3">\n            </span><span class="s1">this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;</span><span class="s3">\n            </span><span class="s1">return newBaseCstVisitorConstructor;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.baseCstVisitorConstructor;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBaseCstVisitorConstructorWithDefaults() {</span><span class="s3">\n        </span><span class="s1">if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {</span><span class="s3">\n            </span><span class="s1">const newConstructor = createBaseVisitorConstructorWithDefaults(this.className, keys(this.gastProductionsCache), this.getBaseCstVisitorConstructor());</span><span class="s3">\n            </span><span class="s1">this.baseCstVisitorWithDefaultsConstructor = newConstructor;</span><span class="s3">\n            </span><span class="s1">return newConstructor;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.baseCstVisitorWithDefaultsConstructor;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLastExplicitRuleShortName() {</span><span class="s3">\n        </span><span class="s1">const ruleStack = this.RULE_STACK;</span><span class="s3">\n        </span><span class="s1">return ruleStack[ruleStack.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getPreviousExplicitRuleShortName() {</span><span class="s3">\n        </span><span class="s1">const ruleStack = this.RULE_STACK;</span><span class="s3">\n        </span><span class="s1">return ruleStack[ruleStack.length - 2];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLastExplicitRuleOccurrenceIndex() {</span><span class="s3">\n        </span><span class="s1">const occurrenceStack = this.RULE_OCCURRENCE_STACK;</span><span class="s3">\n        </span><span class="s1">return occurrenceStack[occurrenceStack.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=tree_builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { END_OF_FILE } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Trait responsible abstracting over the interaction with Lexer output (Token vector).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This could be generalized to support other kinds of lexers, e.g.</span><span class="s3">\n </span><span class="s1">* - Just in Time Lexing / Lexer-Less parsing.</span><span class="s3">\n </span><span class="s1">* - Streaming Lexer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class LexerAdapter {</span><span class="s3">\n    </span><span class="s1">initLexerAdapter() {</span><span class="s3">\n        </span><span class="s1">this.tokVector = [];</span><span class="s3">\n        </span><span class="s1">this.tokVectorLength = 0;</span><span class="s3">\n        </span><span class="s1">this.currIdx = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set input(newInput) {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore - `this parameter` not supported in setters/getters</span><span class="s3">\n        </span><span class="s1">//   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters</span><span class="s3">\n        </span><span class="s1">if (this.selfAnalysisDone !== true) {</span><span class="s3">\n            </span><span class="s1">throw Error(`Missing &lt;performSelfAnalysis&gt; invocation at the end of the Parser's constructor.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// @ts-ignore - `this parameter` not supported in setters/getters</span><span class="s3">\n        </span><span class="s1">//   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters</span><span class="s3">\n        </span><span class="s1">this.reset();</span><span class="s3">\n        </span><span class="s1">this.tokVector = newInput;</span><span class="s3">\n        </span><span class="s1">this.tokVectorLength = newInput.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get input() {</span><span class="s3">\n        </span><span class="s1">return this.tokVector;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// skips a token and returns the next token</span><span class="s3">\n    </span><span class="s1">SKIP_TOKEN() {</span><span class="s3">\n        </span><span class="s1">if (this.currIdx &lt;= this.tokVector.length - 2) {</span><span class="s3">\n            </span><span class="s1">this.consumeToken();</span><span class="s3">\n            </span><span class="s1">return this.LA(1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return END_OF_FILE;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers</span><span class="s3">\n    </span><span class="s1">// or lexers dependent on parser context.</span><span class="s3">\n    </span><span class="s1">LA(howMuch) {</span><span class="s3">\n        </span><span class="s1">const soughtIdx = this.currIdx + howMuch;</span><span class="s3">\n        </span><span class="s1">if (soughtIdx &lt; 0 || this.tokVectorLength &lt;= soughtIdx) {</span><span class="s3">\n            </span><span class="s1">return END_OF_FILE;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.tokVector[soughtIdx];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeToken() {</span><span class="s3">\n        </span><span class="s1">this.currIdx++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">exportLexerState() {</span><span class="s3">\n        </span><span class="s1">return this.currIdx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">importLexerState(newState) {</span><span class="s3">\n        </span><span class="s1">this.currIdx = newState;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resetLexerState() {</span><span class="s3">\n        </span><span class="s1">this.currIdx = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">moveToTerminatedState() {</span><span class="s3">\n        </span><span class="s1">this.currIdx = this.tokVector.length - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLexerPosition() {</span><span class="s3">\n        </span><span class="s1">return this.exportLexerState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lexer_adapter.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { includes, values } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isRecognitionException } from </span><span class="s3">\&quot;</span><span class="s1">../../exceptions_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defaultGrammarValidatorErrorProvider } from </span><span class="s3">\&quot;</span><span class="s1">../../errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { validateRuleIsOverridden } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/checks.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { serializeGrammar } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This trait is responsible for implementing the public API</span><span class="s3">\n </span><span class="s1">* for defining Chevrotain parsers, i.e:</span><span class="s3">\n </span><span class="s1">* - CONSUME</span><span class="s3">\n </span><span class="s1">* - RULE</span><span class="s3">\n </span><span class="s1">* - OPTION</span><span class="s3">\n </span><span class="s1">* - ...</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RecognizerApi {</span><span class="s3">\n    </span><span class="s1">ACTION(impl) {</span><span class="s3">\n        </span><span class="s1">return impl.call(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consume(idx, tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, idx, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subrule(idx, ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, idx, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">option(idx, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, idx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">or(idx, altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, idx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">many(idx, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.manyInternal(idx, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOne(idx, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.atLeastOneInternal(idx, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 0, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME1(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 1, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME2(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 2, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME3(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 3, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME4(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 4, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME5(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 5, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME6(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 6, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME7(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 7, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME8(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 8, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CONSUME9(tokType, options) {</span><span class="s3">\n        </span><span class="s1">return this.consumeInternal(tokType, 9, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 0, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE1(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 1, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE2(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 2, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE3(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 3, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE4(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 4, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE5(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 5, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE6(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 6, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE7(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 7, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE8(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 8, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SUBRULE9(ruleToCall, options) {</span><span class="s3">\n        </span><span class="s1">return this.subruleInternal(ruleToCall, 9, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION1(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION2(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION3(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION4(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION5(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION6(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 6);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION7(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 7);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION8(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 8);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OPTION9(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.optionInternal(actionORMethodDef, 9);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR1(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR2(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR3(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR4(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR5(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR6(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 6);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR7(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 7);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR8(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 8);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OR9(altsOrOpts) {</span><span class="s3">\n        </span><span class="s1">return this.orInternal(altsOrOpts, 9);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(0, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY1(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(1, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY2(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(2, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY3(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(3, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY4(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(4, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY5(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(5, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY6(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(6, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY7(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(7, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY8(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(8, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY9(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.manyInternal(9, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(0, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP1(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(1, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP2(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(2, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP3(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(3, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP4(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(4, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP5(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(5, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP6(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(6, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP7(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(7, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP8(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(8, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MANY_SEP9(options) {</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternal(9, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(0, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE1(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">return this.atLeastOneInternal(1, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE2(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(2, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE3(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(3, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE4(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(4, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE5(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(5, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE6(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(6, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE7(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(7, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE8(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(8, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE9(actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneInternal(9, actionORMethodDef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(0, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP1(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(1, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP2(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(2, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP3(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(3, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP4(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(4, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP5(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(5, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP6(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(6, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP7(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(7, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP8(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(8, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AT_LEAST_ONE_SEP9(options) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternal(9, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RULE(name, implementation, config = DEFAULT_RULE_CONFIG) {</span><span class="s3">\n        </span><span class="s1">if (includes(this.definedRulesNames, name)) {</span><span class="s3">\n            </span><span class="s1">const errMsg = defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({</span><span class="s3">\n                </span><span class="s1">topLevelRule: name,</span><span class="s3">\n                </span><span class="s1">grammarName: this.className,</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const error = {</span><span class="s3">\n                </span><span class="s1">message: errMsg,</span><span class="s3">\n                </span><span class="s1">type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,</span><span class="s3">\n                </span><span class="s1">ruleName: name,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.definitionErrors.push(error);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.definedRulesNames.push(name);</span><span class="s3">\n        </span><span class="s1">const ruleImplementation = this.defineRule(name, implementation, config);</span><span class="s3">\n        </span><span class="s1">this[name] = ruleImplementation;</span><span class="s3">\n        </span><span class="s1">return ruleImplementation;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OVERRIDE_RULE(name, impl, config = DEFAULT_RULE_CONFIG) {</span><span class="s3">\n        </span><span class="s1">const ruleErrors = validateRuleIsOverridden(name, this.definedRulesNames, this.className);</span><span class="s3">\n        </span><span class="s1">this.definitionErrors = this.definitionErrors.concat(ruleErrors);</span><span class="s3">\n        </span><span class="s1">const ruleImplementation = this.defineRule(name, impl, config);</span><span class="s3">\n        </span><span class="s1">this[name] = ruleImplementation;</span><span class="s3">\n        </span><span class="s1">return ruleImplementation;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">BACKTRACK(grammarRule, args) {</span><span class="s3">\n        </span><span class="s1">return function () {</span><span class="s3">\n            </span><span class="s1">// save org state</span><span class="s3">\n            </span><span class="s1">this.isBackTrackingStack.push(1);</span><span class="s3">\n            </span><span class="s1">const orgState = this.saveRecogState();</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">grammarRule.apply(this, args);</span><span class="s3">\n                </span><span class="s1">// if no exception was thrown we have succeed parsing the rule.</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">if (isRecognitionException(e)) {</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw e;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">finally {</span><span class="s3">\n                </span><span class="s1">this.reloadRecogState(orgState);</span><span class="s3">\n                </span><span class="s1">this.isBackTrackingStack.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// GAST export APIs</span><span class="s3">\n    </span><span class="s1">getGAstProductions() {</span><span class="s3">\n        </span><span class="s1">return this.gastProductionsCache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getSerializedGastProductions() {</span><span class="s3">\n        </span><span class="s1">return serializeGrammar(values(this.gastProductionsCache));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=recognizer_api.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { clone, every, flatten, has, isArray, isEmpty, isObject, reduce, uniq, values, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { AT_LEAST_ONE_IDX, AT_LEAST_ONE_SEP_IDX, BITS_FOR_METHOD_TYPE, BITS_FOR_OCCURRENCE_IDX, MANY_IDX, MANY_SEP_IDX, OPTION_IDX, OR_IDX, } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/keys.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { isRecognitionException, MismatchedTokenException, NotAllInputParsedException, } from </span><span class="s3">\&quot;</span><span class="s1">../../exceptions_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { PROD_TYPE } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { NextTerminalAfterAtLeastOneSepWalker, NextTerminalAfterAtLeastOneWalker, NextTerminalAfterManySepWalker, NextTerminalAfterManyWalker, } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/interpreter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_RULE_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { IN_RULE_RECOVERY_EXCEPTION } from </span><span class="s3">\&quot;</span><span class="s1">./recoverable.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { EOF } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { augmentTokenTypes, isTokenType, tokenStructuredMatcher, tokenStructuredMatcherNoCategories, } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This trait is responsible for the runtime parsing engine</span><span class="s3">\n </span><span class="s1">* Used by the official API (recognizer_api.ts)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RecognizerEngine {</span><span class="s3">\n    </span><span class="s1">initRecognizerEngine(tokenVocabulary, config) {</span><span class="s3">\n        </span><span class="s1">this.className = this.constructor.name;</span><span class="s3">\n        </span><span class="s1">// TODO: would using an ES6 Map or plain object be faster (CST building scenario)</span><span class="s3">\n        </span><span class="s1">this.shortRuleNameToFull = {};</span><span class="s3">\n        </span><span class="s1">this.fullRuleNameToShort = {};</span><span class="s3">\n        </span><span class="s1">this.ruleShortNameIdx = 256;</span><span class="s3">\n        </span><span class="s1">this.tokenMatcher = tokenStructuredMatcherNoCategories;</span><span class="s3">\n        </span><span class="s1">this.subruleIdx = 0;</span><span class="s3">\n        </span><span class="s1">this.definedRulesNames = [];</span><span class="s3">\n        </span><span class="s1">this.tokensMap = {};</span><span class="s3">\n        </span><span class="s1">this.isBackTrackingStack = [];</span><span class="s3">\n        </span><span class="s1">this.RULE_STACK = [];</span><span class="s3">\n        </span><span class="s1">this.RULE_OCCURRENCE_STACK = [];</span><span class="s3">\n        </span><span class="s1">this.gastProductionsCache = {};</span><span class="s3">\n        </span><span class="s1">if (has(config, </span><span class="s3">\&quot;</span><span class="s1">serializedGrammar</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">The Parser's configuration can no longer contain a &lt;serializedGrammar&gt; property.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;\\</span><span class="s1">tFor Further details.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isArray(tokenVocabulary)) {</span><span class="s3">\n            </span><span class="s1">// This only checks for Token vocabularies provided as arrays.</span><span class="s3">\n            </span><span class="s1">// That is good enough because the main objective is to detect users of pre-V4.0 APIs</span><span class="s3">\n            </span><span class="s1">// rather than all edge cases of empty Token vocabularies.</span><span class="s3">\n            </span><span class="s1">if (isEmpty(tokenVocabulary)) {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">A Token Vocabulary cannot be empty.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tNote that the first argument for the parser constructor</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tis no longer a Token vector (since v4.0).</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (typeof tokenVocabulary[0].startOffset === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">The Parser constructor no longer accepts a token vector as the first argument.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                    \&quot;\\</span><span class="s1">tFor Further details.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isArray(tokenVocabulary)) {</span><span class="s3">\n            </span><span class="s1">this.tokensMap = reduce(tokenVocabulary, (acc, tokType) =&gt; {</span><span class="s3">\n                </span><span class="s1">acc[tokType.name] = tokType;</span><span class="s3">\n                </span><span class="s1">return acc;</span><span class="s3">\n            </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (has(tokenVocabulary, </span><span class="s3">\&quot;</span><span class="s1">modes</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">every(flatten(values(tokenVocabulary.modes)), isTokenType)) {</span><span class="s3">\n            </span><span class="s1">const allTokenTypes = flatten(values(tokenVocabulary.modes));</span><span class="s3">\n            </span><span class="s1">const uniqueTokens = uniq(allTokenTypes);</span><span class="s3">\n            </span><span class="s1">this.tokensMap = reduce(uniqueTokens, (acc, tokType) =&gt; {</span><span class="s3">\n                </span><span class="s1">acc[tokType.name] = tokType;</span><span class="s3">\n                </span><span class="s1">return acc;</span><span class="s3">\n            </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isObject(tokenVocabulary)) {</span><span class="s3">\n            </span><span class="s1">this.tokensMap = clone(tokenVocabulary);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">&lt;tokensDictionary&gt; argument must be An Array of Token constructors,</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot; </span><span class="s1">A dictionary of Token constructors or an IMultiModeLexerDefinition</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// always add EOF to the tokenNames -&gt; constructors map. it is useful to assure all the input has been</span><span class="s3">\n        </span><span class="s1">// parsed with a clear error message (</span><span class="s3">\&quot;</span><span class="s1">expecting EOF but found ...</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">this.tokensMap[</span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">] = EOF;</span><span class="s3">\n        </span><span class="s1">const allTokenTypes = has(tokenVocabulary, </span><span class="s3">\&quot;</span><span class="s1">modes</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? flatten(values(tokenVocabulary.modes))</span><span class="s3">\n            </span><span class="s1">: values(tokenVocabulary);</span><span class="s3">\n        </span><span class="s1">const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =&gt; isEmpty(tokenConstructor.categoryMatches));</span><span class="s3">\n        </span><span class="s1">this.tokenMatcher = noTokenCategoriesUsed</span><span class="s3">\n            </span><span class="s1">? tokenStructuredMatcherNoCategories</span><span class="s3">\n            </span><span class="s1">: tokenStructuredMatcher;</span><span class="s3">\n        </span><span class="s1">// Because ES2015+ syntax should be supported for creating Token classes</span><span class="s3">\n        </span><span class="s1">// We cannot assume that the Token classes were created using the </span><span class="s3">\&quot;</span><span class="s1">extendToken</span><span class="s3">\&quot; </span><span class="s1">utilities</span><span class="s3">\n        </span><span class="s1">// Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization</span><span class="s3">\n        </span><span class="s1">augmentTokenTypes(values(this.tokensMap));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">defineRule(ruleName, impl, config) {</span><span class="s3">\n        </span><span class="s1">if (this.selfAnalysisDone) {</span><span class="s3">\n            </span><span class="s1">throw Error(`Grammar rule &lt;${ruleName}&gt; may not be defined after the 'performSelfAnalysis' method has been called'</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n                </span><span class="s1">`Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const resyncEnabled = has(config, </span><span class="s3">\&quot;</span><span class="s1">resyncEnabled</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.resyncEnabled // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_RULE_CONFIG.resyncEnabled;</span><span class="s3">\n        </span><span class="s1">const recoveryValueFunc = has(config, </span><span class="s3">\&quot;</span><span class="s1">recoveryValueFunc</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.recoveryValueFunc // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_RULE_CONFIG.recoveryValueFunc;</span><span class="s3">\n        </span><span class="s1">// performance optimization: Use small integers as keys for the longer human readable </span><span class="s3">\&quot;</span><span class="s1">full</span><span class="s3">\&quot; </span><span class="s1">rule names.</span><span class="s3">\n        </span><span class="s1">// this greatly improves Map access time (as much as 8% for some performance benchmarks).</span><span class="s3">\n        </span><span class="s1">const shortName = this.ruleShortNameIdx &lt;&lt; (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);</span><span class="s3">\n        </span><span class="s1">this.ruleShortNameIdx++;</span><span class="s3">\n        </span><span class="s1">this.shortRuleNameToFull[shortName] = ruleName;</span><span class="s3">\n        </span><span class="s1">this.fullRuleNameToShort[ruleName] = shortName;</span><span class="s3">\n        </span><span class="s1">let invokeRuleWithTry;</span><span class="s3">\n        </span><span class="s1">// Micro optimization, only check the condition **once** on rule definition</span><span class="s3">\n        </span><span class="s1">// instead of **every single** rule invocation.</span><span class="s3">\n        </span><span class="s1">if (this.outputCst === true) {</span><span class="s3">\n            </span><span class="s1">invokeRuleWithTry = function invokeRuleWithTry(...args) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);</span><span class="s3">\n                    </span><span class="s1">impl.apply(this, args);</span><span class="s3">\n                    </span><span class="s1">const cst = this.CST_STACK[this.CST_STACK.length - 1];</span><span class="s3">\n                    </span><span class="s1">this.cstPostRule(cst);</span><span class="s3">\n                    </span><span class="s1">return cst;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">finally {</span><span class="s3">\n                    </span><span class="s1">this.ruleFinallyStateUpdate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">invokeRuleWithTry = function invokeRuleWithTryCst(...args) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);</span><span class="s3">\n                    </span><span class="s1">return impl.apply(this, args);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (e) {</span><span class="s3">\n                    </span><span class="s1">return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">finally {</span><span class="s3">\n                    </span><span class="s1">this.ruleFinallyStateUpdate();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });</span><span class="s3">\n        </span><span class="s1">return wrappedGrammarRule;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {</span><span class="s3">\n        </span><span class="s1">const isFirstInvokedRule = this.RULE_STACK.length === 1;</span><span class="s3">\n        </span><span class="s1">// note the reSync is always enabled for the first rule invocation, because we must always be able to</span><span class="s3">\n        </span><span class="s1">// reSync with EOF and just output some INVALID ParseTree</span><span class="s3">\n        </span><span class="s1">// during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking</span><span class="s3">\n        </span><span class="s1">// path is really the most valid one</span><span class="s3">\n        </span><span class="s1">const reSyncEnabled = resyncEnabledConfig &amp;&amp; !this.isBackTracking() &amp;&amp; this.recoveryEnabled;</span><span class="s3">\n        </span><span class="s1">if (isRecognitionException(e)) {</span><span class="s3">\n            </span><span class="s1">const recogError = e;</span><span class="s3">\n            </span><span class="s1">if (reSyncEnabled) {</span><span class="s3">\n                </span><span class="s1">const reSyncTokType = this.findReSyncTokenType();</span><span class="s3">\n                </span><span class="s1">if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {</span><span class="s3">\n                    </span><span class="s1">recogError.resyncedTokens = this.reSyncTo(reSyncTokType);</span><span class="s3">\n                    </span><span class="s1">if (this.outputCst) {</span><span class="s3">\n                        </span><span class="s1">const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];</span><span class="s3">\n                        </span><span class="s1">partialCstResult.recoveredNode = true;</span><span class="s3">\n                        </span><span class="s1">return partialCstResult;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return recoveryValueFunc(e);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (this.outputCst) {</span><span class="s3">\n                        </span><span class="s1">const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];</span><span class="s3">\n                        </span><span class="s1">partialCstResult.recoveredNode = true;</span><span class="s3">\n                        </span><span class="s1">recogError.partialCstResult = partialCstResult;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// to be handled Further up the call stack</span><span class="s3">\n                    </span><span class="s1">throw recogError;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isFirstInvokedRule) {</span><span class="s3">\n                </span><span class="s1">// otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case</span><span class="s3">\n                </span><span class="s1">this.moveToTerminatedState();</span><span class="s3">\n                </span><span class="s1">// the parser should never throw one of its own errors outside its flow.</span><span class="s3">\n                </span><span class="s1">// even if error recovery is disabled</span><span class="s3">\n                </span><span class="s1">return recoveryValueFunc(e);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// to be recovered Further up the call stack</span><span class="s3">\n                </span><span class="s1">throw recogError;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// some other Error type which we don't know how to handle (for example a built in JavaScript Error)</span><span class="s3">\n            </span><span class="s1">throw e;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Implementation of parsing DSL</span><span class="s3">\n    </span><span class="s1">optionInternal(actionORMethodDef, occurrence) {</span><span class="s3">\n        </span><span class="s1">const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);</span><span class="s3">\n        </span><span class="s1">return this.optionInternalLogic(actionORMethodDef, occurrence, key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optionInternalLogic(actionORMethodDef, occurrence, key) {</span><span class="s3">\n        </span><span class="s1">let lookAheadFunc = this.getLaFuncFromCache(key);</span><span class="s3">\n        </span><span class="s1">let action;</span><span class="s3">\n        </span><span class="s1">if (typeof actionORMethodDef !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef.DEF;</span><span class="s3">\n            </span><span class="s1">const predicate = actionORMethodDef.GATE;</span><span class="s3">\n            </span><span class="s1">// predicate present</span><span class="s3">\n            </span><span class="s1">if (predicate !== undefined) {</span><span class="s3">\n                </span><span class="s1">const orgLookaheadFunction = lookAheadFunc;</span><span class="s3">\n                </span><span class="s1">lookAheadFunc = () =&gt; {</span><span class="s3">\n                    </span><span class="s1">return predicate.call(this) &amp;&amp; orgLookaheadFunction.call(this);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (lookAheadFunc.call(this) === true) {</span><span class="s3">\n            </span><span class="s1">return action.call(this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneInternal(prodOccurrence, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_IDX, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {</span><span class="s3">\n        </span><span class="s1">let lookAheadFunc = this.getLaFuncFromCache(key);</span><span class="s3">\n        </span><span class="s1">let action;</span><span class="s3">\n        </span><span class="s1">if (typeof actionORMethodDef !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef.DEF;</span><span class="s3">\n            </span><span class="s1">const predicate = actionORMethodDef.GATE;</span><span class="s3">\n            </span><span class="s1">// predicate present</span><span class="s3">\n            </span><span class="s1">if (predicate !== undefined) {</span><span class="s3">\n                </span><span class="s1">const orgLookaheadFunction = lookAheadFunc;</span><span class="s3">\n                </span><span class="s1">lookAheadFunc = () =&gt; {</span><span class="s3">\n                    </span><span class="s1">return predicate.call(this) &amp;&amp; orgLookaheadFunction.call(this);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (lookAheadFunc.call(this) === true) {</span><span class="s3">\n            </span><span class="s1">let notStuck = this.doSingleRepetition(action);</span><span class="s3">\n            </span><span class="s1">while (lookAheadFunc.call(this) === true &amp;&amp;</span><span class="s3">\n                </span><span class="s1">notStuck === true) {</span><span class="s3">\n                </span><span class="s1">notStuck = this.doSingleRepetition(action);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// note that while it may seem that this can cause an error because by using a recursive call to</span><span class="s3">\n        </span><span class="s1">// AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call</span><span class="s3">\n        </span><span class="s1">// from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.</span><span class="s3">\n        </span><span class="s1">// Performance optimization: </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot; </span><span class="s1">will be defined as NOOP unless recovery is enabled</span><span class="s3">\n        </span><span class="s1">this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, AT_LEAST_ONE_IDX, prodOccurrence, NextTerminalAfterAtLeastOneWalker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneSepFirstInternal(prodOccurrence, options) {</span><span class="s3">\n        </span><span class="s1">const laKey = this.getKeyForAutomaticLookahead(AT_LEAST_ONE_SEP_IDX, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {</span><span class="s3">\n        </span><span class="s1">const action = options.DEF;</span><span class="s3">\n        </span><span class="s1">const separator = options.SEP;</span><span class="s3">\n        </span><span class="s1">const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);</span><span class="s3">\n        </span><span class="s1">// 1st iteration</span><span class="s3">\n        </span><span class="s1">if (firstIterationLookaheadFunc.call(this) === true) {</span><span class="s3">\n            </span><span class="s1">action.call(this);</span><span class="s3">\n            </span><span class="s1">//  TODO: Optimization can move this function construction into </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot;\n            </span><span class="s1">//  because it is only needed in error recovery scenarios.</span><span class="s3">\n            </span><span class="s1">const separatorLookAheadFunc = () =&gt; {</span><span class="s3">\n                </span><span class="s1">return this.tokenMatcher(this.LA(1), separator);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">// 2nd..nth iterations</span><span class="s3">\n            </span><span class="s1">while (this.tokenMatcher(this.LA(1), separator) === true) {</span><span class="s3">\n                </span><span class="s1">// note that this CONSUME will never enter recovery because</span><span class="s3">\n                </span><span class="s1">// the separatorLookAheadFunc checks that the separator really does exist.</span><span class="s3">\n                </span><span class="s1">this.CONSUME(separator);</span><span class="s3">\n                </span><span class="s1">// No need for checking infinite loop here due to consuming the separator.</span><span class="s3">\n                </span><span class="s1">action.call(this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Performance optimization: </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot; </span><span class="s1">will be defined as NOOP unless recovery is enabled</span><span class="s3">\n            </span><span class="s1">this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [</span><span class="s3">\n                </span><span class="s1">prodOccurrence,</span><span class="s3">\n                </span><span class="s1">separator,</span><span class="s3">\n                </span><span class="s1">separatorLookAheadFunc,</span><span class="s3">\n                </span><span class="s1">action,</span><span class="s3">\n                </span><span class="s1">NextTerminalAfterAtLeastOneSepWalker,</span><span class="s3">\n            </span><span class="s1">], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, NextTerminalAfterAtLeastOneSepWalker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw this.raiseEarlyExitException(prodOccurrence, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manyInternal(prodOccurrence, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manyInternalLogic(prodOccurrence, actionORMethodDef, key) {</span><span class="s3">\n        </span><span class="s1">let lookaheadFunction = this.getLaFuncFromCache(key);</span><span class="s3">\n        </span><span class="s1">let action;</span><span class="s3">\n        </span><span class="s1">if (typeof actionORMethodDef !== </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef.DEF;</span><span class="s3">\n            </span><span class="s1">const predicate = actionORMethodDef.GATE;</span><span class="s3">\n            </span><span class="s1">// predicate present</span><span class="s3">\n            </span><span class="s1">if (predicate !== undefined) {</span><span class="s3">\n                </span><span class="s1">const orgLookaheadFunction = lookaheadFunction;</span><span class="s3">\n                </span><span class="s1">lookaheadFunction = () =&gt; {</span><span class="s3">\n                    </span><span class="s1">return predicate.call(this) &amp;&amp; orgLookaheadFunction.call(this);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">action = actionORMethodDef;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let notStuck = true;</span><span class="s3">\n        </span><span class="s1">while (lookaheadFunction.call(this) === true &amp;&amp; notStuck === true) {</span><span class="s3">\n            </span><span class="s1">notStuck = this.doSingleRepetition(action);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Performance optimization: </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot; </span><span class="s1">will be defined as NOOP unless recovery is enabled</span><span class="s3">\n        </span><span class="s1">this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, MANY_IDX, prodOccurrence, NextTerminalAfterManyWalker, </span><span class="s3">\n        </span><span class="s1">// The notStuck parameter is only relevant when </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot;\n        </span><span class="s1">// is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]</span><span class="s3">\n        </span><span class="s1">// An infinite loop cannot occur as:</span><span class="s3">\n        </span><span class="s1">// - Either the lookahead is guaranteed to consume something (Single Token Separator)</span><span class="s3">\n        </span><span class="s1">// - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).</span><span class="s3">\n        </span><span class="s1">notStuck);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manySepFirstInternal(prodOccurrence, options) {</span><span class="s3">\n        </span><span class="s1">const laKey = this.getKeyForAutomaticLookahead(MANY_SEP_IDX, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">this.manySepFirstInternalLogic(prodOccurrence, options, laKey);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manySepFirstInternalLogic(prodOccurrence, options, key) {</span><span class="s3">\n        </span><span class="s1">const action = options.DEF;</span><span class="s3">\n        </span><span class="s1">const separator = options.SEP;</span><span class="s3">\n        </span><span class="s1">const firstIterationLaFunc = this.getLaFuncFromCache(key);</span><span class="s3">\n        </span><span class="s1">// 1st iteration</span><span class="s3">\n        </span><span class="s1">if (firstIterationLaFunc.call(this) === true) {</span><span class="s3">\n            </span><span class="s1">action.call(this);</span><span class="s3">\n            </span><span class="s1">const separatorLookAheadFunc = () =&gt; {</span><span class="s3">\n                </span><span class="s1">return this.tokenMatcher(this.LA(1), separator);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">// 2nd..nth iterations</span><span class="s3">\n            </span><span class="s1">while (this.tokenMatcher(this.LA(1), separator) === true) {</span><span class="s3">\n                </span><span class="s1">// note that this CONSUME will never enter recovery because</span><span class="s3">\n                </span><span class="s1">// the separatorLookAheadFunc checks that the separator really does exist.</span><span class="s3">\n                </span><span class="s1">this.CONSUME(separator);</span><span class="s3">\n                </span><span class="s1">// No need for checking infinite loop here due to consuming the separator.</span><span class="s3">\n                </span><span class="s1">action.call(this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Performance optimization: </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot; </span><span class="s1">will be defined as NOOP unless recovery is enabled</span><span class="s3">\n            </span><span class="s1">this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [</span><span class="s3">\n                </span><span class="s1">prodOccurrence,</span><span class="s3">\n                </span><span class="s1">separator,</span><span class="s3">\n                </span><span class="s1">separatorLookAheadFunc,</span><span class="s3">\n                </span><span class="s1">action,</span><span class="s3">\n                </span><span class="s1">NextTerminalAfterManySepWalker,</span><span class="s3">\n            </span><span class="s1">], separatorLookAheadFunc, MANY_SEP_IDX, prodOccurrence, NextTerminalAfterManySepWalker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {</span><span class="s3">\n        </span><span class="s1">while (separatorLookAheadFunc()) {</span><span class="s3">\n            </span><span class="s1">// note that this CONSUME will never enter recovery because</span><span class="s3">\n            </span><span class="s1">// the separatorLookAheadFunc checks that the separator really does exist.</span><span class="s3">\n            </span><span class="s1">this.CONSUME(separator);</span><span class="s3">\n            </span><span class="s1">action.call(this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// we can only arrive to this function after an error</span><span class="s3">\n        </span><span class="s1">// has occurred (hence the name 'second') so the following</span><span class="s3">\n        </span><span class="s1">// IF will always be entered, its possible to remove it...</span><span class="s3">\n        </span><span class="s1">// however it is kept to avoid confusion and be consistent.</span><span class="s3">\n        </span><span class="s1">// Performance optimization: </span><span class="s3">\&quot;</span><span class="s1">attemptInRepetitionRecovery</span><span class="s3">\&quot; </span><span class="s1">will be defined as NOOP unless recovery is enabled</span><span class="s3">\n        </span><span class="s1">/* istanbul ignore else */</span><span class="s3">\n        </span><span class="s1">this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [</span><span class="s3">\n            </span><span class="s1">prodOccurrence,</span><span class="s3">\n            </span><span class="s1">separator,</span><span class="s3">\n            </span><span class="s1">separatorLookAheadFunc,</span><span class="s3">\n            </span><span class="s1">action,</span><span class="s3">\n            </span><span class="s1">nextTerminalAfterWalker,</span><span class="s3">\n        </span><span class="s1">], separatorLookAheadFunc, AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">doSingleRepetition(action) {</span><span class="s3">\n        </span><span class="s1">const beforeIteration = this.getLexerPosition();</span><span class="s3">\n        </span><span class="s1">action.call(this);</span><span class="s3">\n        </span><span class="s1">const afterIteration = this.getLexerPosition();</span><span class="s3">\n        </span><span class="s1">// This boolean will indicate if this repetition progressed</span><span class="s3">\n        </span><span class="s1">// or if we are </span><span class="s3">\&quot;</span><span class="s1">stuck</span><span class="s3">\&quot; </span><span class="s1">(potential infinite loop in the repetition).</span><span class="s3">\n        </span><span class="s1">return afterIteration &gt; beforeIteration;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">orInternal(altsOrOpts, occurrence) {</span><span class="s3">\n        </span><span class="s1">const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);</span><span class="s3">\n        </span><span class="s1">const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;</span><span class="s3">\n        </span><span class="s1">const laFunc = this.getLaFuncFromCache(laKey);</span><span class="s3">\n        </span><span class="s1">const altIdxToTake = laFunc.call(this, alts);</span><span class="s3">\n        </span><span class="s1">if (altIdxToTake !== undefined) {</span><span class="s3">\n            </span><span class="s1">const chosenAlternative = alts[altIdxToTake];</span><span class="s3">\n            </span><span class="s1">return chosenAlternative.ALT.call(this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ruleFinallyStateUpdate() {</span><span class="s3">\n        </span><span class="s1">this.RULE_STACK.pop();</span><span class="s3">\n        </span><span class="s1">this.RULE_OCCURRENCE_STACK.pop();</span><span class="s3">\n        </span><span class="s1">// NOOP when cst is disabled</span><span class="s3">\n        </span><span class="s1">this.cstFinallyStateUpdate();</span><span class="s3">\n        </span><span class="s1">if (this.RULE_STACK.length === 0 &amp;&amp; this.isAtEndOfInput() === false) {</span><span class="s3">\n            </span><span class="s1">const firstRedundantTok = this.LA(1);</span><span class="s3">\n            </span><span class="s1">const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({</span><span class="s3">\n                </span><span class="s1">firstRedundant: firstRedundantTok,</span><span class="s3">\n                </span><span class="s1">ruleName: this.getCurrRuleFullName(),</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.SAVE_ERROR(new NotAllInputParsedException(errMsg, firstRedundantTok));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subruleInternal(ruleToCall, idx, options) {</span><span class="s3">\n        </span><span class="s1">let ruleResult;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const args = options !== undefined ? options.ARGS : undefined;</span><span class="s3">\n            </span><span class="s1">this.subruleIdx = idx;</span><span class="s3">\n            </span><span class="s1">ruleResult = ruleToCall.apply(this, args);</span><span class="s3">\n            </span><span class="s1">this.cstPostNonTerminal(ruleResult, options !== undefined &amp;&amp; options.LABEL !== undefined</span><span class="s3">\n                </span><span class="s1">? options.LABEL</span><span class="s3">\n                </span><span class="s1">: ruleToCall.ruleName);</span><span class="s3">\n            </span><span class="s1">return ruleResult;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (e) {</span><span class="s3">\n            </span><span class="s1">throw this.subruleInternalError(e, options, ruleToCall.ruleName);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subruleInternalError(e, options, ruleName) {</span><span class="s3">\n        </span><span class="s1">if (isRecognitionException(e) &amp;&amp; e.partialCstResult !== undefined) {</span><span class="s3">\n            </span><span class="s1">this.cstPostNonTerminal(e.partialCstResult, options !== undefined &amp;&amp; options.LABEL !== undefined</span><span class="s3">\n                </span><span class="s1">? options.LABEL</span><span class="s3">\n                </span><span class="s1">: ruleName);</span><span class="s3">\n            </span><span class="s1">delete e.partialCstResult;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw e;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeInternal(tokType, idx, options) {</span><span class="s3">\n        </span><span class="s1">let consumedToken;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n            </span><span class="s1">if (this.tokenMatcher(nextToken, tokType) === true) {</span><span class="s3">\n                </span><span class="s1">this.consumeToken();</span><span class="s3">\n                </span><span class="s1">consumedToken = nextToken;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.consumeInternalError(tokType, nextToken, options);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (eFromConsumption) {</span><span class="s3">\n            </span><span class="s1">consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.cstPostTerminal(options !== undefined &amp;&amp; options.LABEL !== undefined</span><span class="s3">\n            </span><span class="s1">? options.LABEL</span><span class="s3">\n            </span><span class="s1">: tokType.name, consumedToken);</span><span class="s3">\n        </span><span class="s1">return consumedToken;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeInternalError(tokType, nextToken, options) {</span><span class="s3">\n        </span><span class="s1">let msg;</span><span class="s3">\n        </span><span class="s1">const previousToken = this.LA(0);</span><span class="s3">\n        </span><span class="s1">if (options !== undefined &amp;&amp; options.ERR_MSG) {</span><span class="s3">\n            </span><span class="s1">msg = options.ERR_MSG;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">msg = this.errorMessageProvider.buildMismatchTokenMessage({</span><span class="s3">\n                </span><span class="s1">expected: tokType,</span><span class="s3">\n                </span><span class="s1">actual: nextToken,</span><span class="s3">\n                </span><span class="s1">previous: previousToken,</span><span class="s3">\n                </span><span class="s1">ruleName: this.getCurrRuleFullName(),</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw this.SAVE_ERROR(new MismatchedTokenException(msg, nextToken, previousToken));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeInternalRecovery(tokType, idx, eFromConsumption) {</span><span class="s3">\n        </span><span class="s1">// no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it</span><span class="s3">\n        </span><span class="s1">// but the original syntax could have been parsed successfully without any backtracking + recovery</span><span class="s3">\n        </span><span class="s1">if (this.recoveryEnabled &amp;&amp;</span><span class="s3">\n            </span><span class="s1">// TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?</span><span class="s3">\n            </span><span class="s1">eFromConsumption.name === </span><span class="s3">\&quot;</span><span class="s1">MismatchedTokenException</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n            </span><span class="s1">!this.isBackTracking()) {</span><span class="s3">\n            </span><span class="s1">const follows = this.getFollowsForInRuleRecovery(tokType, idx);</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">return this.tryInRuleRecovery(tokType, follows);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (eFromInRuleRecovery) {</span><span class="s3">\n                </span><span class="s1">if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {</span><span class="s3">\n                    </span><span class="s1">// failed in RuleRecovery.</span><span class="s3">\n                    </span><span class="s1">// throw the original error in order to trigger reSync error recovery</span><span class="s3">\n                    </span><span class="s1">throw eFromConsumption;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw eFromInRuleRecovery;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw eFromConsumption;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">saveRecogState() {</span><span class="s3">\n        </span><span class="s1">// errors is a getter which will clone the errors array</span><span class="s3">\n        </span><span class="s1">const savedErrors = this.errors;</span><span class="s3">\n        </span><span class="s1">const savedRuleStack = clone(this.RULE_STACK);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">errors: savedErrors,</span><span class="s3">\n            </span><span class="s1">lexerState: this.exportLexerState(),</span><span class="s3">\n            </span><span class="s1">RULE_STACK: savedRuleStack,</span><span class="s3">\n            </span><span class="s1">CST_STACK: this.CST_STACK,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reloadRecogState(newState) {</span><span class="s3">\n        </span><span class="s1">this.errors = newState.errors;</span><span class="s3">\n        </span><span class="s1">this.importLexerState(newState.lexerState);</span><span class="s3">\n        </span><span class="s1">this.RULE_STACK = newState.RULE_STACK;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {</span><span class="s3">\n        </span><span class="s1">this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);</span><span class="s3">\n        </span><span class="s1">this.RULE_STACK.push(shortName);</span><span class="s3">\n        </span><span class="s1">// NOOP when cst is disabled</span><span class="s3">\n        </span><span class="s1">this.cstInvocationStateUpdate(fullName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isBackTracking() {</span><span class="s3">\n        </span><span class="s1">return this.isBackTrackingStack.length !== 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getCurrRuleFullName() {</span><span class="s3">\n        </span><span class="s1">const shortName = this.getLastExplicitRuleShortName();</span><span class="s3">\n        </span><span class="s1">return this.shortRuleNameToFull[shortName];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">shortRuleNameToFullName(shortName) {</span><span class="s3">\n        </span><span class="s1">return this.shortRuleNameToFull[shortName];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isAtEndOfInput() {</span><span class="s3">\n        </span><span class="s1">return this.tokenMatcher(this.LA(1), EOF);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reset() {</span><span class="s3">\n        </span><span class="s1">this.resetLexerState();</span><span class="s3">\n        </span><span class="s1">this.subruleIdx = 0;</span><span class="s3">\n        </span><span class="s1">this.isBackTrackingStack = [];</span><span class="s3">\n        </span><span class="s1">this.errors = [];</span><span class="s3">\n        </span><span class="s1">this.RULE_STACK = [];</span><span class="s3">\n        </span><span class="s1">// TODO: extract a specific reset for TreeBuilder trait</span><span class="s3">\n        </span><span class="s1">this.CST_STACK = [];</span><span class="s3">\n        </span><span class="s1">this.RULE_OCCURRENCE_STACK = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=recognizer_engine.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { EarlyExitException, isRecognitionException, NoViableAltException, } from </span><span class="s3">\&quot;</span><span class="s1">../../exceptions_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { clone, has } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { getLookaheadPathsForOptionalProd, getLookaheadPathsForOr, } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Trait responsible for runtime parsing errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ErrorHandler {</span><span class="s3">\n    </span><span class="s1">initErrorHandler(config) {</span><span class="s3">\n        </span><span class="s1">this._errors = [];</span><span class="s3">\n        </span><span class="s1">this.errorMessageProvider = has(config, </span><span class="s3">\&quot;</span><span class="s1">errorMessageProvider</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.errorMessageProvider // assumes end user provides the correct config value/type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.errorMessageProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SAVE_ERROR(error) {</span><span class="s3">\n        </span><span class="s1">if (isRecognitionException(error)) {</span><span class="s3">\n            </span><span class="s1">error.context = {</span><span class="s3">\n                </span><span class="s1">ruleStack: this.getHumanReadableRuleStack(),</span><span class="s3">\n                </span><span class="s1">ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this._errors.push(error);</span><span class="s3">\n            </span><span class="s1">return error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">Trying to save an Error which is not a RecognitionException</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get errors() {</span><span class="s3">\n        </span><span class="s1">return clone(this._errors);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set errors(newErrors) {</span><span class="s3">\n        </span><span class="s1">this._errors = newErrors;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: consider caching the error message computed information</span><span class="s3">\n    </span><span class="s1">raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {</span><span class="s3">\n        </span><span class="s1">const ruleName = this.getCurrRuleFullName();</span><span class="s3">\n        </span><span class="s1">const ruleGrammar = this.getGAstProductions()[ruleName];</span><span class="s3">\n        </span><span class="s1">const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, this.maxLookahead);</span><span class="s3">\n        </span><span class="s1">const insideProdPaths = lookAheadPathsPerAlternative[0];</span><span class="s3">\n        </span><span class="s1">const actualTokens = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt;= this.maxLookahead; i++) {</span><span class="s3">\n            </span><span class="s1">actualTokens.push(this.LA(i));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const msg = this.errorMessageProvider.buildEarlyExitMessage({</span><span class="s3">\n            </span><span class="s1">expectedIterationPaths: insideProdPaths,</span><span class="s3">\n            </span><span class="s1">actual: actualTokens,</span><span class="s3">\n            </span><span class="s1">previous: this.LA(0),</span><span class="s3">\n            </span><span class="s1">customUserDescription: userDefinedErrMsg,</span><span class="s3">\n            </span><span class="s1">ruleName: ruleName,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: consider caching the error message computed information</span><span class="s3">\n    </span><span class="s1">raiseNoAltException(occurrence, errMsgTypes) {</span><span class="s3">\n        </span><span class="s1">const ruleName = this.getCurrRuleFullName();</span><span class="s3">\n        </span><span class="s1">const ruleGrammar = this.getGAstProductions()[ruleName];</span><span class="s3">\n        </span><span class="s1">// TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?</span><span class="s3">\n        </span><span class="s1">const lookAheadPathsPerAlternative = getLookaheadPathsForOr(occurrence, ruleGrammar, this.maxLookahead);</span><span class="s3">\n        </span><span class="s1">const actualTokens = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt;= this.maxLookahead; i++) {</span><span class="s3">\n            </span><span class="s1">actualTokens.push(this.LA(i));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const previousToken = this.LA(0);</span><span class="s3">\n        </span><span class="s1">const errMsg = this.errorMessageProvider.buildNoViableAltMessage({</span><span class="s3">\n            </span><span class="s1">expectedPathsPerAlt: lookAheadPathsPerAlternative,</span><span class="s3">\n            </span><span class="s1">actual: actualTokens,</span><span class="s3">\n            </span><span class="s1">previous: previousToken,</span><span class="s3">\n            </span><span class="s1">customUserDescription: errMsgTypes,</span><span class="s3">\n            </span><span class="s1">ruleName: this.getCurrRuleFullName(),</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">throw this.SAVE_ERROR(new NoViableAltException(errMsg, this.LA(1), previousToken));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=error_handler.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { NextAfterTokenWalker, nextPossibleTokensAfter, } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/interpreter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { first, isUndefined } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class ContentAssist {</span><span class="s3">\n    </span><span class="s1">initContentAssist() { }</span><span class="s3">\n    </span><span class="s1">computeContentAssist(startRuleName, precedingInput) {</span><span class="s3">\n        </span><span class="s1">const startRuleGast = this.gastProductionsCache[startRuleName];</span><span class="s3">\n        </span><span class="s1">if (isUndefined(startRuleGast)) {</span><span class="s3">\n            </span><span class="s1">throw Error(`Rule -&gt;${startRuleName}&lt;- does not exist in this grammar.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return nextPossibleTokensAfter([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...</span><span class="s3">\n    </span><span class="s1">// TODO: should this be more explicitly part of the public API?</span><span class="s3">\n    </span><span class="s1">getNextPossibleTokenTypes(grammarPath) {</span><span class="s3">\n        </span><span class="s1">const topRuleName = first(grammarPath.ruleStack);</span><span class="s3">\n        </span><span class="s1">const gastProductions = this.getGAstProductions();</span><span class="s3">\n        </span><span class="s1">const topProduction = gastProductions[topRuleName];</span><span class="s3">\n        </span><span class="s1">const nextPossibleTokenTypes = new NextAfterTokenWalker(topProduction, grammarPath).startWalking();</span><span class="s3">\n        </span><span class="s1">return nextPossibleTokenTypes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=context_assist.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { forEach, has, isArray, isFunction, last as peek, some, } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Lexer } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/lexer_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { augmentTokenTypes, hasShortKeyProperty, } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/tokens.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createToken, createTokenInstance, } from </span><span class="s3">\&quot;</span><span class="s1">../../../scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { END_OF_FILE } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { BITS_FOR_OCCURRENCE_IDX } from </span><span class="s3">\&quot;</span><span class="s1">../../grammar/keys.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const RECORDING_NULL_OBJECT = {</span><span class="s3">\n    </span><span class="s1">description: </span><span class="s3">\&quot;</span><span class="s1">This Object indicates the Parser is during Recording Phase</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">Object.freeze(RECORDING_NULL_OBJECT);</span><span class="s3">\n</span><span class="s1">const HANDLE_SEPARATOR = true;</span><span class="s3">\n</span><span class="s1">const MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;</span><span class="s3">\n</span><span class="s1">const RFT = createToken({ name: </span><span class="s3">\&quot;</span><span class="s1">RECORDING_PHASE_TOKEN</span><span class="s3">\&quot;</span><span class="s1">, pattern: Lexer.NA });</span><span class="s3">\n</span><span class="s1">augmentTokenTypes([RFT]);</span><span class="s3">\n</span><span class="s1">const RECORDING_PHASE_TOKEN = createTokenInstance(RFT, </span><span class="s3">\&quot;</span><span class="s1">This IToken indicates the Parser is in Recording Phase</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;\&quot; </span><span class="s1">+</span><span class="s3">\n    \&quot;</span><span class="s1">See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\n</span><span class="s1">// Using </span><span class="s3">\&quot;</span><span class="s1">-1</span><span class="s3">\&quot; </span><span class="s1">instead of NaN (as in EOF) because an actual number is less likely to</span><span class="s3">\n</span><span class="s1">// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.</span><span class="s3">\n</span><span class="s1">-1, -1, -1, -1, -1, -1);</span><span class="s3">\n</span><span class="s1">Object.freeze(RECORDING_PHASE_TOKEN);</span><span class="s3">\n</span><span class="s1">const RECORDING_PHASE_CSTNODE = {</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">This CSTNode indicates the Parser is in Recording Phase</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;</span><span class="s1">See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">children: {},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This trait handles the creation of the GAST structure for Chevrotain Grammars</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class GastRecorder {</span><span class="s3">\n    </span><span class="s1">initGastRecorder(config) {</span><span class="s3">\n        </span><span class="s1">this.recordingProdStack = [];</span><span class="s3">\n        </span><span class="s1">this.RECORDING_PHASE = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enableRecording() {</span><span class="s3">\n        </span><span class="s1">this.RECORDING_PHASE = true;</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Enable Recording</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* Warning Dark Voodoo Magic upcoming!</span><span class="s3">\n             </span><span class="s1">* We are </span><span class="s3">\&quot;</span><span class="s1">replacing</span><span class="s3">\&quot; </span><span class="s1">the public parsing DSL methods API</span><span class="s3">\n             </span><span class="s1">* With **new** alternative implementations on the Parser **instance**</span><span class="s3">\n             </span><span class="s1">*</span><span class="s3">\n             </span><span class="s1">* So far this is the only way I've found to avoid performance regressions during parsing time.</span><span class="s3">\n             </span><span class="s1">* - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the </span><span class="s3">\&quot;</span><span class="s1">internal</span><span class="s3">\&quot;\n             </span><span class="s1">*   implementations directly instead.</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; 10; i++) {</span><span class="s3">\n                </span><span class="s1">const idx = i &gt; 0 ? i : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">this[`CONSUME${idx}`] = function (arg1, arg2) {</span><span class="s3">\n                    </span><span class="s1">return this.consumeInternalRecord(arg1, i, arg2);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`SUBRULE${idx}`] = function (arg1, arg2) {</span><span class="s3">\n                    </span><span class="s1">return this.subruleInternalRecord(arg1, i, arg2);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`OPTION${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">return this.optionInternalRecord(arg1, i);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`OR${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">return this.orInternalRecord(arg1, i);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`MANY${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">this.manyInternalRecord(i, arg1);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`MANY_SEP${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">this.manySepFirstInternalRecord(i, arg1);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`AT_LEAST_ONE${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">this.atLeastOneInternalRecord(i, arg1);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {</span><span class="s3">\n                    </span><span class="s1">this.atLeastOneSepFirstInternalRecord(i, arg1);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// DSL methods with the idx(suffix) as an argument</span><span class="s3">\n            </span><span class="s1">this[`consume`] = function (idx, arg1, arg2) {</span><span class="s3">\n                </span><span class="s1">return this.consumeInternalRecord(arg1, idx, arg2);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this[`subrule`] = function (idx, arg1, arg2) {</span><span class="s3">\n                </span><span class="s1">return this.subruleInternalRecord(arg1, idx, arg2);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this[`option`] = function (idx, arg1) {</span><span class="s3">\n                </span><span class="s1">return this.optionInternalRecord(arg1, idx);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this[`or`] = function (idx, arg1) {</span><span class="s3">\n                </span><span class="s1">return this.orInternalRecord(arg1, idx);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this[`many`] = function (idx, arg1) {</span><span class="s3">\n                </span><span class="s1">this.manyInternalRecord(idx, arg1);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this[`atLeastOne`] = function (idx, arg1) {</span><span class="s3">\n                </span><span class="s1">this.atLeastOneInternalRecord(idx, arg1);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.ACTION = this.ACTION_RECORD;</span><span class="s3">\n            </span><span class="s1">this.BACKTRACK = this.BACKTRACK_RECORD;</span><span class="s3">\n            </span><span class="s1">this.LA = this.LA_RECORD;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">disableRecording() {</span><span class="s3">\n        </span><span class="s1">this.RECORDING_PHASE = false;</span><span class="s3">\n        </span><span class="s1">// By deleting these **instance** properties, any future invocation</span><span class="s3">\n        </span><span class="s1">// will be deferred to the original methods on the **prototype** object</span><span class="s3">\n        </span><span class="s1">// This seems to get rid of any incorrect optimizations that V8 may</span><span class="s3">\n        </span><span class="s1">// do during the recording phase.</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Deleting Recording methods</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">const that = this;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; 10; i++) {</span><span class="s3">\n                </span><span class="s1">const idx = i &gt; 0 ? i : </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">delete that[`CONSUME${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`SUBRULE${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`OPTION${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`OR${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`MANY${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`MANY_SEP${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`AT_LEAST_ONE${idx}`];</span><span class="s3">\n                </span><span class="s1">delete that[`AT_LEAST_ONE_SEP${idx}`];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">delete that[`consume`];</span><span class="s3">\n            </span><span class="s1">delete that[`subrule`];</span><span class="s3">\n            </span><span class="s1">delete that[`option`];</span><span class="s3">\n            </span><span class="s1">delete that[`or`];</span><span class="s3">\n            </span><span class="s1">delete that[`many`];</span><span class="s3">\n            </span><span class="s1">delete that[`atLeastOne`];</span><span class="s3">\n            </span><span class="s1">delete that.ACTION;</span><span class="s3">\n            </span><span class="s1">delete that.BACKTRACK;</span><span class="s3">\n            </span><span class="s1">delete that.LA;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">//   Parser methods are called inside an ACTION?</span><span class="s3">\n    </span><span class="s1">//   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?</span><span class="s3">\n    </span><span class="s1">// @ts-expect-error -- noop place holder</span><span class="s3">\n    </span><span class="s1">ACTION_RECORD(impl) {</span><span class="s3">\n        </span><span class="s1">// NO-OP during recording</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Executing backtracking logic will break our recording logic assumptions</span><span class="s3">\n    </span><span class="s1">BACKTRACK_RECORD(grammarRule, args) {</span><span class="s3">\n        </span><span class="s1">return () =&gt; true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// LA is part of the official API and may be used for custom lookahead logic</span><span class="s3">\n    </span><span class="s1">// by end users who may forget to wrap it in ACTION or inside a GATE</span><span class="s3">\n    </span><span class="s1">LA_RECORD(howMuch) {</span><span class="s3">\n        </span><span class="s1">// We cannot use the RECORD_PHASE_TOKEN here because someone may depend</span><span class="s3">\n        </span><span class="s1">// On LA return EOF at the end of the input so an infinite loop may occur.</span><span class="s3">\n        </span><span class="s1">return END_OF_FILE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">topLevelRuleRecord(name, def) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const newTopLevelRule = new Rule({ definition: [], name: name });</span><span class="s3">\n            </span><span class="s1">newTopLevelRule.name = name;</span><span class="s3">\n            </span><span class="s1">this.recordingProdStack.push(newTopLevelRule);</span><span class="s3">\n            </span><span class="s1">def.call(this);</span><span class="s3">\n            </span><span class="s1">this.recordingProdStack.pop();</span><span class="s3">\n            </span><span class="s1">return newTopLevelRule;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (originalError) {</span><span class="s3">\n            </span><span class="s1">if (originalError.KNOWN_RECORDER_ERROR !== true) {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">originalError.message =</span><span class="s3">\n                        </span><span class="s1">originalError.message +</span><span class="s3">\n                            </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t This error was thrown during the </span><span class="s3">\&quot;</span><span class="s1">grammar recording phase</span><span class="s3">\&quot; </span><span class="s1">For more info see:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t' +</span><span class="s3">\n                            \&quot;</span><span class="s1">https://chevrotain.io/docs/guide/internals.html#grammar-recording</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (mutabilityError) {</span><span class="s3">\n                    </span><span class="s1">// We may not be able to modify the original error object</span><span class="s3">\n                    </span><span class="s1">throw originalError;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">throw originalError;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Implementation of parsing DSL</span><span class="s3">\n    </span><span class="s1">optionInternalRecord(actionORMethodDef, occurrence) {</span><span class="s3">\n        </span><span class="s1">return recordProd.call(this, Option, actionORMethodDef, occurrence);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneInternalRecord(occurrence, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOneSepFirstInternalRecord(occurrence, options) {</span><span class="s3">\n        </span><span class="s1">recordProd.call(this, RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manyInternalRecord(occurrence, actionORMethodDef) {</span><span class="s3">\n        </span><span class="s1">recordProd.call(this, Repetition, actionORMethodDef, occurrence);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manySepFirstInternalRecord(occurrence, options) {</span><span class="s3">\n        </span><span class="s1">recordProd.call(this, RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">orInternalRecord(altsOrOpts, occurrence) {</span><span class="s3">\n        </span><span class="s1">return recordOrProd.call(this, altsOrOpts, occurrence);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subruleInternalRecord(ruleToCall, occurrence, options) {</span><span class="s3">\n        </span><span class="s1">assertMethodIdxIsValid(occurrence);</span><span class="s3">\n        </span><span class="s1">if (!ruleToCall || has(ruleToCall, </span><span class="s3">\&quot;</span><span class="s1">ruleName</span><span class="s3">\&quot;</span><span class="s1">) === false) {</span><span class="s3">\n            </span><span class="s1">const error = new Error(`&lt;SUBRULE${getIdxSuffix(occurrence)}&gt; argument is invalid` +</span><span class="s3">\n                </span><span class="s1">` expecting a Parser method reference but got: &lt;${JSON.stringify(ruleToCall)}&gt;` +</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">n inside top level rule: &lt;${this.recordingProdStack[0].name}&gt;`);</span><span class="s3">\n            </span><span class="s1">error.KNOWN_RECORDER_ERROR = true;</span><span class="s3">\n            </span><span class="s1">throw error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const prevProd = peek(this.recordingProdStack);</span><span class="s3">\n        </span><span class="s1">const ruleName = ruleToCall.ruleName;</span><span class="s3">\n        </span><span class="s1">const newNoneTerminal = new NonTerminal({</span><span class="s3">\n            </span><span class="s1">idx: occurrence,</span><span class="s3">\n            </span><span class="s1">nonTerminalName: ruleName,</span><span class="s3">\n            </span><span class="s1">label: options === null || options === void 0 ? void 0 : options.LABEL,</span><span class="s3">\n            </span><span class="s1">// The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created</span><span class="s3">\n            </span><span class="s1">referencedRule: undefined,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">prevProd.definition.push(newNoneTerminal);</span><span class="s3">\n        </span><span class="s1">return this.outputCst</span><span class="s3">\n            </span><span class="s1">? RECORDING_PHASE_CSTNODE</span><span class="s3">\n            </span><span class="s1">: RECORDING_NULL_OBJECT;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consumeInternalRecord(tokType, occurrence, options) {</span><span class="s3">\n        </span><span class="s1">assertMethodIdxIsValid(occurrence);</span><span class="s3">\n        </span><span class="s1">if (!hasShortKeyProperty(tokType)) {</span><span class="s3">\n            </span><span class="s1">const error = new Error(`&lt;CONSUME${getIdxSuffix(occurrence)}&gt; argument is invalid` +</span><span class="s3">\n                </span><span class="s1">` expecting a TokenType reference but got: &lt;${JSON.stringify(tokType)}&gt;` +</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\\</span><span class="s1">n inside top level rule: &lt;${this.recordingProdStack[0].name}&gt;`);</span><span class="s3">\n            </span><span class="s1">error.KNOWN_RECORDER_ERROR = true;</span><span class="s3">\n            </span><span class="s1">throw error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const prevProd = peek(this.recordingProdStack);</span><span class="s3">\n        </span><span class="s1">const newNoneTerminal = new Terminal({</span><span class="s3">\n            </span><span class="s1">idx: occurrence,</span><span class="s3">\n            </span><span class="s1">terminalType: tokType,</span><span class="s3">\n            </span><span class="s1">label: options === null || options === void 0 ? void 0 : options.LABEL,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">prevProd.definition.push(newNoneTerminal);</span><span class="s3">\n        </span><span class="s1">return RECORDING_PHASE_TOKEN;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {</span><span class="s3">\n    </span><span class="s1">assertMethodIdxIsValid(occurrence);</span><span class="s3">\n    </span><span class="s1">const prevProd = peek(this.recordingProdStack);</span><span class="s3">\n    </span><span class="s1">const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;</span><span class="s3">\n    </span><span class="s1">const newProd = new prodConstructor({ definition: [], idx: occurrence });</span><span class="s3">\n    </span><span class="s1">if (handleSep) {</span><span class="s3">\n        </span><span class="s1">newProd.separator = mainProdArg.SEP;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (has(mainProdArg, </span><span class="s3">\&quot;</span><span class="s1">MAX_LOOKAHEAD</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.recordingProdStack.push(newProd);</span><span class="s3">\n    </span><span class="s1">grammarAction.call(this);</span><span class="s3">\n    </span><span class="s1">prevProd.definition.push(newProd);</span><span class="s3">\n    </span><span class="s1">this.recordingProdStack.pop();</span><span class="s3">\n    </span><span class="s1">return RECORDING_NULL_OBJECT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function recordOrProd(mainProdArg, occurrence) {</span><span class="s3">\n    </span><span class="s1">assertMethodIdxIsValid(occurrence);</span><span class="s3">\n    </span><span class="s1">const prevProd = peek(this.recordingProdStack);</span><span class="s3">\n    </span><span class="s1">// Only an array of alternatives</span><span class="s3">\n    </span><span class="s1">const hasOptions = isArray(mainProdArg) === false;</span><span class="s3">\n    </span><span class="s1">const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;</span><span class="s3">\n    </span><span class="s1">const newOrProd = new Alternation({</span><span class="s3">\n        </span><span class="s1">definition: [],</span><span class="s3">\n        </span><span class="s1">idx: occurrence,</span><span class="s3">\n        </span><span class="s1">ignoreAmbiguities: hasOptions &amp;&amp; mainProdArg.IGNORE_AMBIGUITIES === true,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (has(mainProdArg, </span><span class="s3">\&quot;</span><span class="s1">MAX_LOOKAHEAD</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const hasPredicates = some(alts, (currAlt) =&gt; isFunction(currAlt.GATE));</span><span class="s3">\n    </span><span class="s1">newOrProd.hasPredicates = hasPredicates;</span><span class="s3">\n    </span><span class="s1">prevProd.definition.push(newOrProd);</span><span class="s3">\n    </span><span class="s1">forEach(alts, (currAlt) =&gt; {</span><span class="s3">\n        </span><span class="s1">const currAltFlat = new Alternative({ definition: [] });</span><span class="s3">\n        </span><span class="s1">newOrProd.definition.push(currAltFlat);</span><span class="s3">\n        </span><span class="s1">if (has(currAlt, </span><span class="s3">\&quot;</span><span class="s1">IGNORE_AMBIGUITIES</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// **implicit** ignoreAmbiguities due to usage of gate</span><span class="s3">\n        </span><span class="s1">else if (has(currAlt, </span><span class="s3">\&quot;</span><span class="s1">GATE</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">currAltFlat.ignoreAmbiguities = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.recordingProdStack.push(currAltFlat);</span><span class="s3">\n        </span><span class="s1">currAlt.ALT.call(this);</span><span class="s3">\n        </span><span class="s1">this.recordingProdStack.pop();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return RECORDING_NULL_OBJECT;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getIdxSuffix(idx) {</span><span class="s3">\n    </span><span class="s1">return idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: `${idx}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function assertMethodIdxIsValid(idx) {</span><span class="s3">\n    </span><span class="s1">if (idx &lt; 0 || idx &gt; MAX_METHOD_IDX) {</span><span class="s3">\n        </span><span class="s1">const error = new Error(</span><span class="s3">\n        </span><span class="s1">// The stack trace will contain all the needed details</span><span class="s3">\n        </span><span class="s1">`Invalid DSL Method idx value: &lt;${idx}&gt;</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t` +</span><span class="s3">\n            </span><span class="s1">`Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);</span><span class="s3">\n        </span><span class="s1">error.KNOWN_RECORDER_ERROR = true;</span><span class="s3">\n        </span><span class="s1">throw error;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=gast_recorder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { has } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { timer } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { DEFAULT_PARSER_CONFIG } from </span><span class="s3">\&quot;</span><span class="s1">../parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Trait responsible for runtime parsing errors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class PerformanceTracer {</span><span class="s3">\n    </span><span class="s1">initPerformanceTracer(config) {</span><span class="s3">\n        </span><span class="s1">if (has(config, </span><span class="s3">\&quot;</span><span class="s1">traceInitPerf</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">const userTraceInitPerf = config.traceInitPerf;</span><span class="s3">\n            </span><span class="s1">const traceIsNumber = typeof userTraceInitPerf === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.traceInitMaxIdent = traceIsNumber</span><span class="s3">\n                </span><span class="s1">? userTraceInitPerf</span><span class="s3">\n                </span><span class="s1">: Infinity;</span><span class="s3">\n            </span><span class="s1">this.traceInitPerf = traceIsNumber</span><span class="s3">\n                </span><span class="s1">? userTraceInitPerf &gt; 0</span><span class="s3">\n                </span><span class="s1">: userTraceInitPerf; // assumes end user provides the correct config value/type</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.traceInitMaxIdent = 0;</span><span class="s3">\n            </span><span class="s1">this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.traceInitIndent = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TRACE_INIT(phaseDesc, phaseImpl) {</span><span class="s3">\n        </span><span class="s1">// No need to optimize this using NOOP pattern because</span><span class="s3">\n        </span><span class="s1">// It is not called in a hot spot...</span><span class="s3">\n        </span><span class="s1">if (this.traceInitPerf === true) {</span><span class="s3">\n            </span><span class="s1">this.traceInitIndent++;</span><span class="s3">\n            </span><span class="s1">const indent = new Array(this.traceInitIndent + 1).join(</span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (this.traceInitIndent &lt; this.traceInitMaxIdent) {</span><span class="s3">\n                </span><span class="s1">console.log(`${indent}--&gt; &lt;${phaseDesc}&gt;`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const { time, value } = timer(phaseImpl);</span><span class="s3">\n            </span><span class="s1">/* istanbul ignore next - Difficult to reproduce specific performance behavior (&gt;10ms) in tests */</span><span class="s3">\n            </span><span class="s1">const traceMethod = time &gt; 10 ? console.warn : console.log;</span><span class="s3">\n            </span><span class="s1">if (this.traceInitIndent &lt; this.traceInitMaxIdent) {</span><span class="s3">\n                </span><span class="s1">traceMethod(`${indent}&lt;-- &lt;${phaseDesc}&gt; time: ${time}ms`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.traceInitIndent--;</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return phaseImpl();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=perf_tracer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export function applyMixins(derivedCtor, baseCtors) {</span><span class="s3">\n    </span><span class="s1">baseCtors.forEach((baseCtor) =&gt; {</span><span class="s3">\n        </span><span class="s1">const baseProto = baseCtor.prototype;</span><span class="s3">\n        </span><span class="s1">Object.getOwnPropertyNames(baseProto).forEach((propName) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (propName === </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);</span><span class="s3">\n            </span><span class="s1">// Handle Accessors</span><span class="s3">\n            </span><span class="s1">if (basePropDescriptor &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(basePropDescriptor.get || basePropDescriptor.set)) {</span><span class="s3">\n                </span><span class="s1">Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">derivedCtor.prototype[propName] = baseCtor.prototype[propName];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=apply_mixins.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { clone, forEach, has, isEmpty, map, values } from </span><span class="s3">\&quot;</span><span class="s1">lodash-es</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { toFastProperties } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/utils</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { computeAllProdsFollows } from </span><span class="s3">\&quot;</span><span class="s1">../grammar/follow.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createTokenInstance, EOF } from </span><span class="s3">\&quot;</span><span class="s1">../../scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { defaultGrammarValidatorErrorProvider, defaultParserErrorProvider, } from </span><span class="s3">\&quot;</span><span class="s1">../errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { resolveGrammar, validateGrammar, } from </span><span class="s3">\&quot;</span><span class="s1">../grammar/gast/gast_resolver_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Recoverable } from </span><span class="s3">\&quot;</span><span class="s1">./traits/recoverable.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { LooksAhead } from </span><span class="s3">\&quot;</span><span class="s1">./traits/looksahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { TreeBuilder } from </span><span class="s3">\&quot;</span><span class="s1">./traits/tree_builder.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { LexerAdapter } from </span><span class="s3">\&quot;</span><span class="s1">./traits/lexer_adapter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { RecognizerApi } from </span><span class="s3">\&quot;</span><span class="s1">./traits/recognizer_api.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { RecognizerEngine } from </span><span class="s3">\&quot;</span><span class="s1">./traits/recognizer_engine.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ErrorHandler } from </span><span class="s3">\&quot;</span><span class="s1">./traits/error_handler.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ContentAssist } from </span><span class="s3">\&quot;</span><span class="s1">./traits/context_assist.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { GastRecorder } from </span><span class="s3">\&quot;</span><span class="s1">./traits/gast_recorder.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { PerformanceTracer } from </span><span class="s3">\&quot;</span><span class="s1">./traits/perf_tracer.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { applyMixins } from </span><span class="s3">\&quot;</span><span class="s1">./utils/apply_mixins.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { validateLookahead } from </span><span class="s3">\&quot;</span><span class="s1">../grammar/checks.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const END_OF_FILE = createTokenInstance(EOF, </span><span class="s3">\&quot;\&quot;</span><span class="s1">, NaN, NaN, NaN, NaN, NaN, NaN);</span><span class="s3">\n</span><span class="s1">Object.freeze(END_OF_FILE);</span><span class="s3">\n</span><span class="s1">export const DEFAULT_PARSER_CONFIG = Object.freeze({</span><span class="s3">\n    </span><span class="s1">recoveryEnabled: false,</span><span class="s3">\n    </span><span class="s1">maxLookahead: 3,</span><span class="s3">\n    </span><span class="s1">dynamicTokensEnabled: false,</span><span class="s3">\n    </span><span class="s1">outputCst: true,</span><span class="s3">\n    </span><span class="s1">errorMessageProvider: defaultParserErrorProvider,</span><span class="s3">\n    </span><span class="s1">nodeLocationTracking: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">traceInitPerf: false,</span><span class="s3">\n    </span><span class="s1">skipValidations: false,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">export const DEFAULT_RULE_CONFIG = Object.freeze({</span><span class="s3">\n    </span><span class="s1">recoveryValueFunc: () =&gt; undefined,</span><span class="s3">\n    </span><span class="s1">resyncEnabled: true,</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">export var ParserDefinitionErrorType;</span><span class="s3">\n</span><span class="s1">(function (ParserDefinitionErrorType) {</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">INVALID_RULE_NAME</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">INVALID_RULE_NAME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_RULE_NAME</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_RULE_NAME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">INVALID_RULE_OVERRIDE</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">INVALID_RULE_OVERRIDE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_PRODUCTIONS</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">DUPLICATE_PRODUCTIONS</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">UNRESOLVED_SUBRULE_REF</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">UNRESOLVED_SUBRULE_REF</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">LEFT_RECURSION</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">LEFT_RECURSION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">NONE_LAST_EMPTY_ALT</span><span class="s3">\&quot;</span><span class="s1">] = 6] = </span><span class="s3">\&quot;</span><span class="s1">NONE_LAST_EMPTY_ALT</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">AMBIGUOUS_ALTS</span><span class="s3">\&quot;</span><span class="s1">] = 7] = </span><span class="s3">\&quot;</span><span class="s1">AMBIGUOUS_ALTS</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">CONFLICT_TOKENS_RULES_NAMESPACE</span><span class="s3">\&quot;</span><span class="s1">] = 8] = </span><span class="s3">\&quot;</span><span class="s1">CONFLICT_TOKENS_RULES_NAMESPACE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">INVALID_TOKEN_NAME</span><span class="s3">\&quot;</span><span class="s1">] = 9] = </span><span class="s3">\&quot;</span><span class="s1">INVALID_TOKEN_NAME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">NO_NON_EMPTY_LOOKAHEAD</span><span class="s3">\&quot;</span><span class="s1">] = 10] = </span><span class="s3">\&quot;</span><span class="s1">NO_NON_EMPTY_LOOKAHEAD</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">AMBIGUOUS_PREFIX_ALTS</span><span class="s3">\&quot;</span><span class="s1">] = 11] = </span><span class="s3">\&quot;</span><span class="s1">AMBIGUOUS_PREFIX_ALTS</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">TOO_MANY_ALTS</span><span class="s3">\&quot;</span><span class="s1">] = 12] = </span><span class="s3">\&quot;</span><span class="s1">TOO_MANY_ALTS</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">ParserDefinitionErrorType[ParserDefinitionErrorType[</span><span class="s3">\&quot;</span><span class="s1">CUSTOM_LOOKAHEAD_VALIDATION</span><span class="s3">\&quot;</span><span class="s1">] = 13] = </span><span class="s3">\&quot;</span><span class="s1">CUSTOM_LOOKAHEAD_VALIDATION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));</span><span class="s3">\n</span><span class="s1">export function EMPTY_ALT(value = undefined) {</span><span class="s3">\n    </span><span class="s1">return function () {</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class Parser {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">*  @deprecated use the **instance** method with the same name instead</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static performSelfAnalysis(parserInstance) {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">The **static** `performSelfAnalysis` method has been deprecated.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot;\\</span><span class="s1">t</span><span class="s3">\\</span><span class="s1">nUse the **instance** method with the same name instead.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">performSelfAnalysis() {</span><span class="s3">\n        </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">performSelfAnalysis</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">let defErrorsMsgs;</span><span class="s3">\n            </span><span class="s1">this.selfAnalysisDone = true;</span><span class="s3">\n            </span><span class="s1">const className = this.className;</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">toFastProps</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">// Without this voodoo magic the parser would be x3-x4 slower</span><span class="s3">\n                </span><span class="s1">// It seems it is better to invoke `toFastProperties` **before**</span><span class="s3">\n                </span><span class="s1">// Any manipulations of the `this` object done during the recording phase.</span><span class="s3">\n                </span><span class="s1">toFastProperties(this);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Grammar Recording</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">this.enableRecording();</span><span class="s3">\n                    </span><span class="s1">// Building the GAST</span><span class="s3">\n                    </span><span class="s1">forEach(this.definedRulesNames, (currRuleName) =&gt; {</span><span class="s3">\n                        </span><span class="s1">const wrappedRule = this[currRuleName];</span><span class="s3">\n                        </span><span class="s1">const originalGrammarAction = wrappedRule[</span><span class="s3">\&quot;</span><span class="s1">originalGrammarAction</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n                        </span><span class="s1">let recordedRuleGast;</span><span class="s3">\n                        </span><span class="s1">this.TRACE_INIT(`${currRuleName} Rule`, () =&gt; {</span><span class="s3">\n                            </span><span class="s1">recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">this.gastProductionsCache[currRuleName] = recordedRuleGast;</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">finally {</span><span class="s3">\n                    </span><span class="s1">this.disableRecording();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">let resolverErrors = [];</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Grammar Resolving</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">resolverErrors = resolveGrammar({</span><span class="s3">\n                    </span><span class="s1">rules: values(this.gastProductionsCache),</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">this.definitionErrors = this.definitionErrors.concat(resolverErrors);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">Grammar Validations</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                </span><span class="s1">// only perform additional grammar validations IFF no resolving errors have occurred.</span><span class="s3">\n                </span><span class="s1">// as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.</span><span class="s3">\n                </span><span class="s1">if (isEmpty(resolverErrors) &amp;&amp; this.skipValidations === false) {</span><span class="s3">\n                    </span><span class="s1">const validationErrors = validateGrammar({</span><span class="s3">\n                        </span><span class="s1">rules: values(this.gastProductionsCache),</span><span class="s3">\n                        </span><span class="s1">tokenTypes: values(this.tokensMap),</span><span class="s3">\n                        </span><span class="s1">errMsgProvider: defaultGrammarValidatorErrorProvider,</span><span class="s3">\n                        </span><span class="s1">grammarName: className,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">const lookaheadValidationErrors = validateLookahead({</span><span class="s3">\n                        </span><span class="s1">lookaheadStrategy: this.lookaheadStrategy,</span><span class="s3">\n                        </span><span class="s1">rules: values(this.gastProductionsCache),</span><span class="s3">\n                        </span><span class="s1">tokenTypes: values(this.tokensMap),</span><span class="s3">\n                        </span><span class="s1">grammarName: className,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">// this analysis may fail if the grammar is not perfectly valid</span><span class="s3">\n            </span><span class="s1">if (isEmpty(this.definitionErrors)) {</span><span class="s3">\n                </span><span class="s1">// The results of these computations are not needed unless error recovery is enabled.</span><span class="s3">\n                </span><span class="s1">if (this.recoveryEnabled) {</span><span class="s3">\n                    </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">computeAllProdsFollows</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                        </span><span class="s1">const allFollows = computeAllProdsFollows(values(this.gastProductionsCache));</span><span class="s3">\n                        </span><span class="s1">this.resyncFollows = allFollows;</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.TRACE_INIT(</span><span class="s3">\&quot;</span><span class="s1">ComputeLookaheadFunctions</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n                    </span><span class="s1">var _a, _b;</span><span class="s3">\n                    </span><span class="s1">(_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {</span><span class="s3">\n                        </span><span class="s1">rules: values(this.gastProductionsCache),</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">this.preComputeLookaheadFunctions(values(this.gastProductionsCache));</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!isEmpty(this.definitionErrors)) {</span><span class="s3">\n                </span><span class="s1">defErrorsMsgs = map(this.definitionErrors, (defError) =&gt; defError.message);</span><span class="s3">\n                </span><span class="s1">throw new Error(`Parser Definition Errors detected:</span><span class="s3">\\</span><span class="s1">n ${defErrorsMsgs.join(</span><span class="s3">\&quot;\\</span><span class="s1">n-------------------------------</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">)}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(tokenVocabulary, config) {</span><span class="s3">\n        </span><span class="s1">this.definitionErrors = [];</span><span class="s3">\n        </span><span class="s1">this.selfAnalysisDone = false;</span><span class="s3">\n        </span><span class="s1">const that = this;</span><span class="s3">\n        </span><span class="s1">that.initErrorHandler(config);</span><span class="s3">\n        </span><span class="s1">that.initLexerAdapter();</span><span class="s3">\n        </span><span class="s1">that.initLooksAhead(config);</span><span class="s3">\n        </span><span class="s1">that.initRecognizerEngine(tokenVocabulary, config);</span><span class="s3">\n        </span><span class="s1">that.initRecoverable(config);</span><span class="s3">\n        </span><span class="s1">that.initTreeBuilder(config);</span><span class="s3">\n        </span><span class="s1">that.initContentAssist();</span><span class="s3">\n        </span><span class="s1">that.initGastRecorder(config);</span><span class="s3">\n        </span><span class="s1">that.initPerformanceTracer(config);</span><span class="s3">\n        </span><span class="s1">if (has(config, </span><span class="s3">\&quot;</span><span class="s1">ignoredIssues</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">The &lt;ignoredIssues&gt; IParserConfig property has been deprecated.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;</span><span class="s1">Please use the &lt;IGNORE_AMBIGUITIES&gt; flag on the relevant DSL method instead.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;</span><span class="s1">See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n                \&quot;</span><span class="s1">For further details.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.skipValidations = has(config, </span><span class="s3">\&quot;</span><span class="s1">skipValidations</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">? config.skipValidations // casting assumes the end user passing the correct type</span><span class="s3">\n            </span><span class="s1">: DEFAULT_PARSER_CONFIG.skipValidations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.</span><span class="s3">\n</span><span class="s1">// (normally during the parser's constructor).</span><span class="s3">\n</span><span class="s1">// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,</span><span class="s3">\n</span><span class="s1">// for example: duplicate rule names, referencing an unresolved subrule, ect...</span><span class="s3">\n</span><span class="s1">// This flag should not be enabled during normal usage, it is used in special situations, for example when</span><span class="s3">\n</span><span class="s1">// needing to display the parser definition errors in some GUI(online playground).</span><span class="s3">\n</span><span class="s1">Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;</span><span class="s3">\n</span><span class="s1">applyMixins(Parser, [</span><span class="s3">\n    </span><span class="s1">Recoverable,</span><span class="s3">\n    </span><span class="s1">LooksAhead,</span><span class="s3">\n    </span><span class="s1">TreeBuilder,</span><span class="s3">\n    </span><span class="s1">LexerAdapter,</span><span class="s3">\n    </span><span class="s1">RecognizerEngine,</span><span class="s3">\n    </span><span class="s1">RecognizerApi,</span><span class="s3">\n    </span><span class="s1">ErrorHandler,</span><span class="s3">\n    </span><span class="s1">ContentAssist,</span><span class="s3">\n    </span><span class="s1">GastRecorder,</span><span class="s3">\n    </span><span class="s1">PerformanceTracer,</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">export class CstParser extends Parser {</span><span class="s3">\n    </span><span class="s1">constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {</span><span class="s3">\n        </span><span class="s1">const configClone = clone(config);</span><span class="s3">\n        </span><span class="s1">configClone.outputCst = true;</span><span class="s3">\n        </span><span class="s1">super(tokenVocabulary, configClone);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class EmbeddedActionsParser extends Parser {</span><span class="s3">\n    </span><span class="s1">constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {</span><span class="s3">\n        </span><span class="s1">const configClone = clone(config);</span><span class="s3">\n        </span><span class="s1">configClone.outputCst = false;</span><span class="s3">\n        </span><span class="s1">super(tokenVocabulary, configClone);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=parser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { buildModel } from </span><span class="s3">\&quot;</span><span class="s1">./model.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { genDts } from </span><span class="s3">\&quot;</span><span class="s1">./generate.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const defaultOptions = {</span><span class="s3">\n    </span><span class="s1">includeVisitorInterface: true,</span><span class="s3">\n    </span><span class="s1">visitorInterfaceName: </span><span class="s3">\&quot;</span><span class="s1">ICstNodeVisitor</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export function generateCstDts(productions, options) {</span><span class="s3">\n    </span><span class="s1">const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);</span><span class="s3">\n    </span><span class="s1">const model = buildModel(productions);</span><span class="s3">\n    </span><span class="s1">return genDts(model, effectiveOptions);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=api.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* istanbul ignore file - tricky to import some things from this module during testing */</span><span class="s3">\n</span><span class="s1">// semantic version</span><span class="s3">\n</span><span class="s1">export { VERSION } from </span><span class="s3">\&quot;</span><span class="s1">./version.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { CstParser, EmbeddedActionsParser, ParserDefinitionErrorType, EMPTY_ALT, } from </span><span class="s3">\&quot;</span><span class="s1">./parse/parser/parser.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { Lexer, LexerDefinitionErrorType } from </span><span class="s3">\&quot;</span><span class="s1">./scan/lexer_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// Tokens utilities</span><span class="s3">\n</span><span class="s1">export { createToken, createTokenInstance, EOF, tokenLabel, tokenMatcher, tokenName, } from </span><span class="s3">\&quot;</span><span class="s1">./scan/tokens_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// Lookahead</span><span class="s3">\n</span><span class="s1">export { getLookaheadPaths } from </span><span class="s3">\&quot;</span><span class="s1">./parse/grammar/lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { LLkLookaheadStrategy } from </span><span class="s3">\&quot;</span><span class="s1">./parse/grammar/llk_lookahead.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// Other Utilities</span><span class="s3">\n</span><span class="s1">export { defaultParserErrorProvider } from </span><span class="s3">\&quot;</span><span class="s1">./parse/errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { EarlyExitException, isRecognitionException, MismatchedTokenException, NotAllInputParsedException, NoViableAltException, } from </span><span class="s3">\&quot;</span><span class="s1">./parse/exceptions_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { defaultLexerErrorProvider } from </span><span class="s3">\&quot;</span><span class="s1">./scan/lexer_errors_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// grammar reflection API</span><span class="s3">\n</span><span class="s1">export { Alternation, Alternative, NonTerminal, Option, Repetition, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Rule, Terminal, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">// GAST Utilities</span><span class="s3">\n</span><span class="s1">export { serializeGrammar, serializeProduction, GAstVisitor, } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/gast</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export { generateCstDts } from </span><span class="s3">\&quot;</span><span class="s1">@chevrotain/cst-dts-gen</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* istanbul ignore next */</span><span class="s3">\n</span><span class="s1">export function clearCache() {</span><span class="s3">\n    </span><span class="s1">console.warn(</span><span class="s3">\&quot;</span><span class="s1">The clearCache function was 'soft' removed from the Chevrotain API.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t It performs no action other than printing this message.</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n        \&quot;\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t Please avoid using it as it will be completely removed in the future</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export { createSyntaxDiagramsCode } from </span><span class="s3">\&quot;</span><span class="s1">./diagrams/render_public.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export class Parser {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n            \&quot;</span><span class="s1">See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=api.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { DefaultNameRegexp } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">import { isCommentTerminal, terminalRegex } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">import { isMultilineComment } from '../utils/regexp-utils.js';</span><span class="s3">\n</span><span class="s1">import { isTerminalRule } from './generated/ast.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a</span><span class="s3">\n </span><span class="s1">* language-specific module.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createGrammarConfig(services) {</span><span class="s3">\n    </span><span class="s1">const rules = [];</span><span class="s3">\n    </span><span class="s1">const grammar = services.Grammar;</span><span class="s3">\n    </span><span class="s1">for (const rule of grammar.rules) {</span><span class="s3">\n        </span><span class="s1">if (isTerminalRule(rule) &amp;&amp; isCommentTerminal(rule) &amp;&amp; isMultilineComment(terminalRegex(rule))) {</span><span class="s3">\n            </span><span class="s1">rules.push(rule.name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">multilineCommentRules: rules,</span><span class="s3">\n        </span><span class="s1">nameRegexp: DefaultNameRegexp</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=grammar-config.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import map from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/map.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import filter from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/filter.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { Alternation, NonTerminal, Option, RepetitionMandatory, Repetition, Terminal, RepetitionWithSeparator, RepetitionMandatoryWithSeparator } from </span><span class="s3">\&quot;</span><span class="s1">chevrotain</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export function buildATNKey(rule, type, occurrence) {</span><span class="s3">\n    </span><span class="s1">return `${rule.name}_${type}_${occurrence}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ATN_INVALID_TYPE = 0;</span><span class="s3">\n</span><span class="s1">export const ATN_BASIC = 1;</span><span class="s3">\n</span><span class="s1">export const ATN_RULE_START = 2;</span><span class="s3">\n</span><span class="s1">export const ATN_PLUS_BLOCK_START = 4;</span><span class="s3">\n</span><span class="s1">export const ATN_STAR_BLOCK_START = 5;</span><span class="s3">\n</span><span class="s1">// Currently unused as the ATN is not used for lexing</span><span class="s3">\n</span><span class="s1">export const ATN_TOKEN_START = 6;</span><span class="s3">\n</span><span class="s1">export const ATN_RULE_STOP = 7;</span><span class="s3">\n</span><span class="s1">export const ATN_BLOCK_END = 8;</span><span class="s3">\n</span><span class="s1">export const ATN_STAR_LOOP_BACK = 9;</span><span class="s3">\n</span><span class="s1">export const ATN_STAR_LOOP_ENTRY = 10;</span><span class="s3">\n</span><span class="s1">export const ATN_PLUS_LOOP_BACK = 11;</span><span class="s3">\n</span><span class="s1">export const ATN_LOOP_END = 12;</span><span class="s3">\n</span><span class="s1">export class AbstractTransition {</span><span class="s3">\n    </span><span class="s1">constructor(target) {</span><span class="s3">\n        </span><span class="s1">this.target = target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEpsilon() {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class AtomTransition extends AbstractTransition {</span><span class="s3">\n    </span><span class="s1">constructor(target, tokenType) {</span><span class="s3">\n        </span><span class="s1">super(target);</span><span class="s3">\n        </span><span class="s1">this.tokenType = tokenType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class EpsilonTransition extends AbstractTransition {</span><span class="s3">\n    </span><span class="s1">constructor(target) {</span><span class="s3">\n        </span><span class="s1">super(target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEpsilon() {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RuleTransition extends AbstractTransition {</span><span class="s3">\n    </span><span class="s1">constructor(ruleStart, rule, followState) {</span><span class="s3">\n        </span><span class="s1">super(ruleStart);</span><span class="s3">\n        </span><span class="s1">this.rule = rule;</span><span class="s3">\n        </span><span class="s1">this.followState = followState;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEpsilon() {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function createATN(rules) {</span><span class="s3">\n    </span><span class="s1">const atn = {</span><span class="s3">\n        </span><span class="s1">decisionMap: {},</span><span class="s3">\n        </span><span class="s1">decisionStates: [],</span><span class="s3">\n        </span><span class="s1">ruleToStartState: new Map(),</span><span class="s3">\n        </span><span class="s1">ruleToStopState: new Map(),</span><span class="s3">\n        </span><span class="s1">states: []</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">createRuleStartAndStopATNStates(atn, rules);</span><span class="s3">\n    </span><span class="s1">const ruleLength = rules.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; ruleLength; i++) {</span><span class="s3">\n        </span><span class="s1">const rule = rules[i];</span><span class="s3">\n        </span><span class="s1">const ruleBlock = block(atn, rule, rule);</span><span class="s3">\n        </span><span class="s1">if (ruleBlock === undefined) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">buildRuleHandle(atn, rule, ruleBlock);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return atn;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createRuleStartAndStopATNStates(atn, rules) {</span><span class="s3">\n    </span><span class="s1">const ruleLength = rules.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; ruleLength; i++) {</span><span class="s3">\n        </span><span class="s1">const rule = rules[i];</span><span class="s3">\n        </span><span class="s1">const start = newState(atn, rule, undefined, {</span><span class="s3">\n            </span><span class="s1">type: ATN_RULE_START</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const stop = newState(atn, rule, undefined, {</span><span class="s3">\n            </span><span class="s1">type: ATN_RULE_STOP</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">start.stop = stop;</span><span class="s3">\n        </span><span class="s1">atn.ruleToStartState.set(rule, start);</span><span class="s3">\n        </span><span class="s1">atn.ruleToStopState.set(rule, stop);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function atom(atn, rule, production) {</span><span class="s3">\n    </span><span class="s1">if (production instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">return tokenRef(atn, rule, production.terminalType, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">return ruleRef(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">return alternation(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof Option) {</span><span class="s3">\n        </span><span class="s1">return option(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">return repetition(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return repetitionSep(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionMandatory) {</span><span class="s3">\n        </span><span class="s1">return repetitionMandatory(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return repetitionMandatorySep(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return block(atn, rule, production);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function repetition(atn, rule, repetition) {</span><span class="s3">\n    </span><span class="s1">const starState = newState(atn, rule, repetition, {</span><span class="s3">\n        </span><span class="s1">type: ATN_STAR_BLOCK_START</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, starState);</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));</span><span class="s3">\n    </span><span class="s1">return star(atn, rule, repetition, handle);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function repetitionSep(atn, rule, repetition) {</span><span class="s3">\n    </span><span class="s1">const starState = newState(atn, rule, repetition, {</span><span class="s3">\n        </span><span class="s1">type: ATN_STAR_BLOCK_START</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, starState);</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));</span><span class="s3">\n    </span><span class="s1">const sep = tokenRef(atn, rule, repetition.separator, repetition);</span><span class="s3">\n    </span><span class="s1">return star(atn, rule, repetition, handle, sep);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function repetitionMandatory(atn, rule, repetition) {</span><span class="s3">\n    </span><span class="s1">const plusState = newState(atn, rule, repetition, {</span><span class="s3">\n        </span><span class="s1">type: ATN_PLUS_BLOCK_START</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, plusState);</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));</span><span class="s3">\n    </span><span class="s1">return plus(atn, rule, repetition, handle);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function repetitionMandatorySep(atn, rule, repetition) {</span><span class="s3">\n    </span><span class="s1">const plusState = newState(atn, rule, repetition, {</span><span class="s3">\n        </span><span class="s1">type: ATN_PLUS_BLOCK_START</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, plusState);</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));</span><span class="s3">\n    </span><span class="s1">const sep = tokenRef(atn, rule, repetition.separator, repetition);</span><span class="s3">\n    </span><span class="s1">return plus(atn, rule, repetition, handle, sep);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function alternation(atn, rule, alternation) {</span><span class="s3">\n    </span><span class="s1">const start = newState(atn, rule, alternation, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, start);</span><span class="s3">\n    </span><span class="s1">const alts = map(alternation.definition, (e) =&gt; atom(atn, rule, e));</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, start, alternation, ...alts);</span><span class="s3">\n    </span><span class="s1">return handle;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function option(atn, rule, option) {</span><span class="s3">\n    </span><span class="s1">const start = newState(atn, rule, option, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, start);</span><span class="s3">\n    </span><span class="s1">const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));</span><span class="s3">\n    </span><span class="s1">return optional(atn, rule, option, handle);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function block(atn, rule, block) {</span><span class="s3">\n    </span><span class="s1">const handles = filter(map(block.definition, (e) =&gt; atom(atn, rule, e)), (e) =&gt; e !== undefined);</span><span class="s3">\n    </span><span class="s1">if (handles.length === 1) {</span><span class="s3">\n        </span><span class="s1">return handles[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (handles.length === 0) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return makeBlock(atn, handles);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function plus(atn, rule, plus, handle, sep) {</span><span class="s3">\n    </span><span class="s1">const blkStart = handle.left;</span><span class="s3">\n    </span><span class="s1">const blkEnd = handle.right;</span><span class="s3">\n    </span><span class="s1">const loop = newState(atn, rule, plus, {</span><span class="s3">\n        </span><span class="s1">type: ATN_PLUS_LOOP_BACK</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, loop);</span><span class="s3">\n    </span><span class="s1">const end = newState(atn, rule, plus, {</span><span class="s3">\n        </span><span class="s1">type: ATN_LOOP_END</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">blkStart.loopback = loop;</span><span class="s3">\n    </span><span class="s1">end.loopback = loop;</span><span class="s3">\n    </span><span class="s1">atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;</span><span class="s3">\n    </span><span class="s1">epsilon(blkEnd, loop); // block can see loop back</span><span class="s3">\n    </span><span class="s1">// Depending on whether we have a separator we put the exit transition at index 1 or 0</span><span class="s3">\n    </span><span class="s1">// This influences the chosen option in the lookahead DFA</span><span class="s3">\n    </span><span class="s1">if (sep === undefined) {</span><span class="s3">\n        </span><span class="s1">epsilon(loop, blkStart); // loop back to start</span><span class="s3">\n        </span><span class="s1">epsilon(loop, end); // exit</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">epsilon(loop, end); // exit</span><span class="s3">\n        </span><span class="s1">// loop back to start with separator</span><span class="s3">\n        </span><span class="s1">epsilon(loop, sep.left);</span><span class="s3">\n        </span><span class="s1">epsilon(sep.right, blkStart);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">left: blkStart,</span><span class="s3">\n        </span><span class="s1">right: end</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function star(atn, rule, star, handle, sep) {</span><span class="s3">\n    </span><span class="s1">const start = handle.left;</span><span class="s3">\n    </span><span class="s1">const end = handle.right;</span><span class="s3">\n    </span><span class="s1">const entry = newState(atn, rule, star, {</span><span class="s3">\n        </span><span class="s1">type: ATN_STAR_LOOP_ENTRY</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">defineDecisionState(atn, entry);</span><span class="s3">\n    </span><span class="s1">const loopEnd = newState(atn, rule, star, {</span><span class="s3">\n        </span><span class="s1">type: ATN_LOOP_END</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const loop = newState(atn, rule, star, {</span><span class="s3">\n        </span><span class="s1">type: ATN_STAR_LOOP_BACK</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">entry.loopback = loop;</span><span class="s3">\n    </span><span class="s1">loopEnd.loopback = loop;</span><span class="s3">\n    </span><span class="s1">epsilon(entry, start); // loop enter edge (alt 2)</span><span class="s3">\n    </span><span class="s1">epsilon(entry, loopEnd); // bypass loop edge (alt 1)</span><span class="s3">\n    </span><span class="s1">epsilon(end, loop); // block end hits loop back</span><span class="s3">\n    </span><span class="s1">if (sep !== undefined) {</span><span class="s3">\n        </span><span class="s1">epsilon(loop, loopEnd); // end loop</span><span class="s3">\n        </span><span class="s1">// loop back to start of handle using separator</span><span class="s3">\n        </span><span class="s1">epsilon(loop, sep.left);</span><span class="s3">\n        </span><span class="s1">epsilon(sep.right, start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">epsilon(loop, entry); // loop back to entry/exit decision</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">left: entry,</span><span class="s3">\n        </span><span class="s1">right: loopEnd</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function optional(atn, rule, optional, handle) {</span><span class="s3">\n    </span><span class="s1">const start = handle.left;</span><span class="s3">\n    </span><span class="s1">const end = handle.right;</span><span class="s3">\n    </span><span class="s1">epsilon(start, end);</span><span class="s3">\n    </span><span class="s1">atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;</span><span class="s3">\n    </span><span class="s1">return handle;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defineDecisionState(atn, state) {</span><span class="s3">\n    </span><span class="s1">atn.decisionStates.push(state);</span><span class="s3">\n    </span><span class="s1">state.decision = atn.decisionStates.length - 1;</span><span class="s3">\n    </span><span class="s1">return state.decision;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function makeAlts(atn, rule, start, production, ...alts) {</span><span class="s3">\n    </span><span class="s1">const end = newState(atn, rule, production, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BLOCK_END,</span><span class="s3">\n        </span><span class="s1">start</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">start.end = end;</span><span class="s3">\n    </span><span class="s1">for (const alt of alts) {</span><span class="s3">\n        </span><span class="s1">if (alt !== undefined) {</span><span class="s3">\n            </span><span class="s1">// hook alts up to decision block</span><span class="s3">\n            </span><span class="s1">epsilon(start, alt.left);</span><span class="s3">\n            </span><span class="s1">epsilon(alt.right, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">epsilon(start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const handle = {</span><span class="s3">\n        </span><span class="s1">left: start,</span><span class="s3">\n        </span><span class="s1">right: end</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;</span><span class="s3">\n    </span><span class="s1">return handle;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getProdType(production) {</span><span class="s3">\n    </span><span class="s1">if (production instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">return 'Alternation';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof Option) {</span><span class="s3">\n        </span><span class="s1">return 'Option';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">return 'Repetition';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return 'RepetitionWithSeparator';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionMandatory) {</span><span class="s3">\n        </span><span class="s1">return 'RepetitionMandatory';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (production instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return 'RepetitionMandatoryWithSeparator';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invalid production type encountered');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function makeBlock(atn, alts) {</span><span class="s3">\n    </span><span class="s1">const altsLength = alts.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; altsLength - 1; i++) {</span><span class="s3">\n        </span><span class="s1">const handle = alts[i];</span><span class="s3">\n        </span><span class="s1">let transition;</span><span class="s3">\n        </span><span class="s1">if (handle.left.transitions.length === 1) {</span><span class="s3">\n            </span><span class="s1">transition = handle.left.transitions[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const isRuleTransition = transition instanceof RuleTransition;</span><span class="s3">\n        </span><span class="s1">const ruleTransition = transition;</span><span class="s3">\n        </span><span class="s1">const next = alts[i + 1].left;</span><span class="s3">\n        </span><span class="s1">if (handle.left.type === ATN_BASIC &amp;&amp;</span><span class="s3">\n            </span><span class="s1">handle.right.type === ATN_BASIC &amp;&amp;</span><span class="s3">\n            </span><span class="s1">transition !== undefined &amp;&amp;</span><span class="s3">\n            </span><span class="s1">((isRuleTransition &amp;&amp; ruleTransition.followState === handle.right) ||</span><span class="s3">\n                </span><span class="s1">transition.target === handle.right)) {</span><span class="s3">\n            </span><span class="s1">// we can avoid epsilon edge to next element</span><span class="s3">\n            </span><span class="s1">if (isRuleTransition) {</span><span class="s3">\n                </span><span class="s1">ruleTransition.followState = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">transition.target = next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">removeState(atn, handle.right); // we skipped over this state</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// need epsilon if previous block's right end node is complex</span><span class="s3">\n            </span><span class="s1">epsilon(handle.right, next);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const first = alts[0];</span><span class="s3">\n    </span><span class="s1">const last = alts[altsLength - 1];</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">left: first.left,</span><span class="s3">\n        </span><span class="s1">right: last.right</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function tokenRef(atn, rule, tokenType, production) {</span><span class="s3">\n    </span><span class="s1">const left = newState(atn, rule, production, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const right = newState(atn, rule, production, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">addTransition(left, new AtomTransition(right, tokenType));</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">left,</span><span class="s3">\n        </span><span class="s1">right</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ruleRef(atn, currentRule, nonTerminal) {</span><span class="s3">\n    </span><span class="s1">const rule = nonTerminal.referencedRule;</span><span class="s3">\n    </span><span class="s1">const start = atn.ruleToStartState.get(rule);</span><span class="s3">\n    </span><span class="s1">const left = newState(atn, currentRule, nonTerminal, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const right = newState(atn, currentRule, nonTerminal, {</span><span class="s3">\n        </span><span class="s1">type: ATN_BASIC</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const call = new RuleTransition(start, rule, right);</span><span class="s3">\n    </span><span class="s1">addTransition(left, call);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">left,</span><span class="s3">\n        </span><span class="s1">right</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildRuleHandle(atn, rule, block) {</span><span class="s3">\n    </span><span class="s1">const start = atn.ruleToStartState.get(rule);</span><span class="s3">\n    </span><span class="s1">epsilon(start, block.left);</span><span class="s3">\n    </span><span class="s1">const stop = atn.ruleToStopState.get(rule);</span><span class="s3">\n    </span><span class="s1">epsilon(block.right, stop);</span><span class="s3">\n    </span><span class="s1">const handle = {</span><span class="s3">\n        </span><span class="s1">left: start,</span><span class="s3">\n        </span><span class="s1">right: stop</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return handle;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function epsilon(a, b) {</span><span class="s3">\n    </span><span class="s1">const transition = new EpsilonTransition(b);</span><span class="s3">\n    </span><span class="s1">addTransition(a, transition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function newState(atn, rule, production, partial) {</span><span class="s3">\n    </span><span class="s1">const t = Object.assign({ atn,</span><span class="s3">\n        </span><span class="s1">production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);</span><span class="s3">\n    </span><span class="s1">atn.states.push(t);</span><span class="s3">\n    </span><span class="s1">return t;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addTransition(state, transition) {</span><span class="s3">\n    </span><span class="s1">// A single ATN state can only contain epsilon transitions or non-epsilon transitions</span><span class="s3">\n    </span><span class="s1">// Because they are never mixed, only setting the property for the first transition is fine</span><span class="s3">\n    </span><span class="s1">if (state.transitions.length === 0) {</span><span class="s3">\n        </span><span class="s1">state.epsilonOnlyTransitions = transition.isEpsilon();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.transitions.push(transition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function removeState(atn, state) {</span><span class="s3">\n    </span><span class="s1">atn.states.splice(atn.states.indexOf(state), 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=atn.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import map from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/map.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">export const DFA_ERROR = {};</span><span class="s3">\n</span><span class="s1">export class ATNConfigSet {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.map = {};</span><span class="s3">\n        </span><span class="s1">this.configs = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">return this.configs.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finalize() {</span><span class="s3">\n        </span><span class="s1">// Empties the map to free up memory</span><span class="s3">\n        </span><span class="s1">this.map = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(config) {</span><span class="s3">\n        </span><span class="s1">const key = getATNConfigKey(config);</span><span class="s3">\n        </span><span class="s1">// Only add configs which don't exist in our map already</span><span class="s3">\n        </span><span class="s1">// While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption</span><span class="s3">\n        </span><span class="s1">if (!(key in this.map)) {</span><span class="s3">\n            </span><span class="s1">this.map[key] = this.configs.length;</span><span class="s3">\n            </span><span class="s1">this.configs.push(config);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get elements() {</span><span class="s3">\n        </span><span class="s1">return this.configs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get alts() {</span><span class="s3">\n        </span><span class="s1">return map(this.configs, (e) =&gt; e.alt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get key() {</span><span class="s3">\n        </span><span class="s1">let value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (const k in this.map) {</span><span class="s3">\n            </span><span class="s1">value += k + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getATNConfigKey(config, alt = true) {</span><span class="s3">\n    </span><span class="s1">return `${alt ? `a${config.alt}` : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}s${config.state.stateNumber}:${config.stack.map((e) =&gt; e.stateNumber.toString()).join(</span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">)}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=dfa.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseUniq from './_baseUniq.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.uniq` except that it accepts `iteratee` which is</span><span class="s3">\n </span><span class="s1">* invoked for each element in `array` to generate the criterion by which</span><span class="s3">\n </span><span class="s1">* uniqueness is computed. The order of result values is determined by the</span><span class="s3">\n </span><span class="s1">* order they occur in the array. The iteratee is invoked with one argument:</span><span class="s3">\n </span><span class="s1">* (value).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new duplicate free array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniqBy([2.1, 1.2, 2.3], Math.floor);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2.1, 1.2]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');</span><span class="s3">\n </span><span class="s1">* // =&gt; [{ 'x': 1 }, { 'x': 2 }]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function uniqBy(array, iteratee) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default uniqBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { tokenMatcher, tokenLabel, NonTerminal, Alternation, Option, RepetitionMandatory, RepetitionMandatoryWithSeparator, RepetitionWithSeparator, Repetition, Terminal, LLkLookaheadStrategy, getLookaheadPaths } from </span><span class="s3">\&quot;</span><span class="s1">chevrotain</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ATN_RULE_STOP, AtomTransition, buildATNKey, createATN, EpsilonTransition, RuleTransition } from </span><span class="s3">\&quot;</span><span class="s1">./atn.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { ATNConfigSet, DFA_ERROR, getATNConfigKey } from </span><span class="s3">\&quot;</span><span class="s1">./dfa.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import min from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/min.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import flatMap from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/flatMap.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import uniqBy from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/uniqBy.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import map from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/map.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import flatten from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/flatten.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import forEach from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/forEach.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import isEmpty from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/isEmpty.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import reduce from </span><span class="s3">\&quot;</span><span class="s1">lodash-es/reduce.js</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function createDFACache(startState, decision) {</span><span class="s3">\n    </span><span class="s1">const map = {};</span><span class="s3">\n    </span><span class="s1">return (predicateSet) =&gt; {</span><span class="s3">\n        </span><span class="s1">const key = predicateSet.toString();</span><span class="s3">\n        </span><span class="s1">let existing = map[key];</span><span class="s3">\n        </span><span class="s1">if (existing !== undefined) {</span><span class="s3">\n            </span><span class="s1">return existing;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">existing = {</span><span class="s3">\n                </span><span class="s1">atnStartState: startState,</span><span class="s3">\n                </span><span class="s1">decision,</span><span class="s3">\n                </span><span class="s1">states: {}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">map[key] = existing;</span><span class="s3">\n            </span><span class="s1">return existing;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PredicateSet {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.predicates = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">is(index) {</span><span class="s3">\n        </span><span class="s1">return index &gt;= this.predicates.length || this.predicates[index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(index, value) {</span><span class="s3">\n        </span><span class="s1">this.predicates[index] = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">const size = this.predicates.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; size; i++) {</span><span class="s3">\n            </span><span class="s1">value += this.predicates[i] === true ? </span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const EMPTY_PREDICATES = new PredicateSet();</span><span class="s3">\n</span><span class="s1">export class LLStarLookaheadStrategy extends LLkLookaheadStrategy {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null &amp;&amp; _a !== void 0 ? _a : ((message) =&gt; console.log(message));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initialize(options) {</span><span class="s3">\n        </span><span class="s1">this.atn = createATN(options.rules);</span><span class="s3">\n        </span><span class="s1">this.dfas = initATNSimulator(this.atn);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateAmbiguousAlternationAlternatives() {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">validateEmptyOrAlternatives() {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLookaheadForAlternation(options) {</span><span class="s3">\n        </span><span class="s1">const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;</span><span class="s3">\n        </span><span class="s1">const dfas = this.dfas;</span><span class="s3">\n        </span><span class="s1">const logging = this.logging;</span><span class="s3">\n        </span><span class="s1">const key = buildATNKey(rule, 'Alternation', prodOccurrence);</span><span class="s3">\n        </span><span class="s1">const decisionState = this.atn.decisionMap[key];</span><span class="s3">\n        </span><span class="s1">const decisionIndex = decisionState.decision;</span><span class="s3">\n        </span><span class="s1">const partialAlts = map(getLookaheadPaths({</span><span class="s3">\n            </span><span class="s1">maxLookahead: 1,</span><span class="s3">\n            </span><span class="s1">occurrence: prodOccurrence,</span><span class="s3">\n            </span><span class="s1">prodType: </span><span class="s3">\&quot;</span><span class="s1">Alternation</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">rule: rule</span><span class="s3">\n        </span><span class="s1">}), (currAlt) =&gt; map(currAlt, (path) =&gt; path[0]));</span><span class="s3">\n        </span><span class="s1">if (isLL1Sequence(partialAlts, false) &amp;&amp; !dynamicTokensEnabled) {</span><span class="s3">\n            </span><span class="s1">const choiceToAlt = reduce(partialAlts, (result, currAlt, idx) =&gt; {</span><span class="s3">\n                </span><span class="s1">forEach(currAlt, (currTokType) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (currTokType) {</span><span class="s3">\n                        </span><span class="s1">result[currTokType.tokenTypeIdx] = idx;</span><span class="s3">\n                        </span><span class="s1">forEach(currTokType.categoryMatches, (currExtendingType) =&gt; {</span><span class="s3">\n                            </span><span class="s1">result[currExtendingType] = idx;</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">}, {});</span><span class="s3">\n            </span><span class="s1">if (hasPredicates) {</span><span class="s3">\n                </span><span class="s1">return function (orAlts) {</span><span class="s3">\n                    </span><span class="s1">var _a;</span><span class="s3">\n                    </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n                    </span><span class="s1">const prediction = choiceToAlt[nextToken.tokenTypeIdx];</span><span class="s3">\n                    </span><span class="s1">if (orAlts !== undefined &amp;&amp; prediction !== undefined) {</span><span class="s3">\n                        </span><span class="s1">const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;</span><span class="s3">\n                        </span><span class="s1">if (gate !== undefined &amp;&amp; gate.call(this) === false) {</span><span class="s3">\n                            </span><span class="s1">return undefined;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return prediction;</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return function () {</span><span class="s3">\n                    </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n                    </span><span class="s1">return choiceToAlt[nextToken.tokenTypeIdx];</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (hasPredicates) {</span><span class="s3">\n            </span><span class="s1">return function (orAlts) {</span><span class="s3">\n                </span><span class="s1">const predicates = new PredicateSet();</span><span class="s3">\n                </span><span class="s1">const length = orAlts === undefined ? 0 : orAlts.length;</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; length; i++) {</span><span class="s3">\n                    </span><span class="s1">const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;</span><span class="s3">\n                    </span><span class="s1">predicates.set(i, gate === undefined || gate.call(this));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);</span><span class="s3">\n                </span><span class="s1">return typeof result === 'number' ? result : undefined;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return function () {</span><span class="s3">\n                </span><span class="s1">const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);</span><span class="s3">\n                </span><span class="s1">return typeof result === 'number' ? result : undefined;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLookaheadForOptional(options) {</span><span class="s3">\n        </span><span class="s1">const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;</span><span class="s3">\n        </span><span class="s1">const dfas = this.dfas;</span><span class="s3">\n        </span><span class="s1">const logging = this.logging;</span><span class="s3">\n        </span><span class="s1">const key = buildATNKey(rule, prodType, prodOccurrence);</span><span class="s3">\n        </span><span class="s1">const decisionState = this.atn.decisionMap[key];</span><span class="s3">\n        </span><span class="s1">const decisionIndex = decisionState.decision;</span><span class="s3">\n        </span><span class="s1">const alts = map(getLookaheadPaths({</span><span class="s3">\n            </span><span class="s1">maxLookahead: 1,</span><span class="s3">\n            </span><span class="s1">occurrence: prodOccurrence,</span><span class="s3">\n            </span><span class="s1">prodType,</span><span class="s3">\n            </span><span class="s1">rule</span><span class="s3">\n        </span><span class="s1">}), (e) =&gt; {</span><span class="s3">\n            </span><span class="s1">return map(e, (g) =&gt; g[0]);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (isLL1Sequence(alts) &amp;&amp; alts[0][0] &amp;&amp; !dynamicTokensEnabled) {</span><span class="s3">\n            </span><span class="s1">const alt = alts[0];</span><span class="s3">\n            </span><span class="s1">const singleTokensTypes = flatten(alt);</span><span class="s3">\n            </span><span class="s1">if (singleTokensTypes.length === 1 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">isEmpty(singleTokensTypes[0].categoryMatches)) {</span><span class="s3">\n                </span><span class="s1">const expectedTokenType = singleTokensTypes[0];</span><span class="s3">\n                </span><span class="s1">const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;</span><span class="s3">\n                </span><span class="s1">return function () {</span><span class="s3">\n                    </span><span class="s1">return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const choiceToAlt = reduce(singleTokensTypes, (result, currTokType) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (currTokType !== undefined) {</span><span class="s3">\n                        </span><span class="s1">result[currTokType.tokenTypeIdx] = true;</span><span class="s3">\n                        </span><span class="s1">forEach(currTokType.categoryMatches, (currExtendingType) =&gt; {</span><span class="s3">\n                            </span><span class="s1">result[currExtendingType] = true;</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}, {});</span><span class="s3">\n                </span><span class="s1">return function () {</span><span class="s3">\n                    </span><span class="s1">const nextToken = this.LA(1);</span><span class="s3">\n                    </span><span class="s1">return choiceToAlt[nextToken.tokenTypeIdx] === true;</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return function () {</span><span class="s3">\n            </span><span class="s1">const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);</span><span class="s3">\n            </span><span class="s1">return typeof result === </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">? false : result === 0;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isLL1Sequence(sequences, allowEmpty = true) {</span><span class="s3">\n    </span><span class="s1">const fullSet = new Set();</span><span class="s3">\n    </span><span class="s1">for (const alt of sequences) {</span><span class="s3">\n        </span><span class="s1">const altSet = new Set();</span><span class="s3">\n        </span><span class="s1">for (const tokType of alt) {</span><span class="s3">\n            </span><span class="s1">if (tokType === undefined) {</span><span class="s3">\n                </span><span class="s1">if (allowEmpty) {</span><span class="s3">\n                    </span><span class="s1">// Epsilon production encountered</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);</span><span class="s3">\n            </span><span class="s1">for (const index of indices) {</span><span class="s3">\n                </span><span class="s1">if (fullSet.has(index)) {</span><span class="s3">\n                    </span><span class="s1">if (!altSet.has(index)) {</span><span class="s3">\n                        </span><span class="s1">return false;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">fullSet.add(index);</span><span class="s3">\n                    </span><span class="s1">altSet.add(index);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function initATNSimulator(atn) {</span><span class="s3">\n    </span><span class="s1">const decisionLength = atn.decisionStates.length;</span><span class="s3">\n    </span><span class="s1">const decisionToDFA = Array(decisionLength);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; decisionLength; i++) {</span><span class="s3">\n        </span><span class="s1">decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return decisionToDFA;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function adaptivePredict(dfaCaches, decision, predicateSet, logging) {</span><span class="s3">\n    </span><span class="s1">const dfa = dfaCaches[decision](predicateSet);</span><span class="s3">\n    </span><span class="s1">let start = dfa.start;</span><span class="s3">\n    </span><span class="s1">if (start === undefined) {</span><span class="s3">\n        </span><span class="s1">const closure = computeStartState(dfa.atnStartState);</span><span class="s3">\n        </span><span class="s1">start = addDFAState(dfa, newDFAState(closure));</span><span class="s3">\n        </span><span class="s1">dfa.start = start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);</span><span class="s3">\n    </span><span class="s1">return alt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function performLookahead(dfa, s0, predicateSet, logging) {</span><span class="s3">\n    </span><span class="s1">let previousD = s0;</span><span class="s3">\n    </span><span class="s1">let i = 1;</span><span class="s3">\n    </span><span class="s1">const path = [];</span><span class="s3">\n    </span><span class="s1">let t = this.LA(i++);</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">let d = getExistingTargetState(previousD, t);</span><span class="s3">\n        </span><span class="s1">if (d === undefined) {</span><span class="s3">\n            </span><span class="s1">d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (d === DFA_ERROR) {</span><span class="s3">\n            </span><span class="s1">return buildAdaptivePredictError(path, previousD, t);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (d.isAcceptState === true) {</span><span class="s3">\n            </span><span class="s1">return d.prediction;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">previousD = d;</span><span class="s3">\n        </span><span class="s1">path.push(t);</span><span class="s3">\n        </span><span class="s1">t = this.LA(i++);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {</span><span class="s3">\n    </span><span class="s1">const reach = computeReachSet(previousD.configs, token, predicateSet);</span><span class="s3">\n    </span><span class="s1">if (reach.size === 0) {</span><span class="s3">\n        </span><span class="s1">addDFAEdge(dfa, previousD, token, DFA_ERROR);</span><span class="s3">\n        </span><span class="s1">return DFA_ERROR;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let newState = newDFAState(reach);</span><span class="s3">\n    </span><span class="s1">const predictedAlt = getUniqueAlt(reach, predicateSet);</span><span class="s3">\n    </span><span class="s1">if (predictedAlt !== undefined) {</span><span class="s3">\n        </span><span class="s1">newState.isAcceptState = true;</span><span class="s3">\n        </span><span class="s1">newState.prediction = predictedAlt;</span><span class="s3">\n        </span><span class="s1">newState.configs.uniqueAlt = predictedAlt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (hasConflictTerminatingPrediction(reach)) {</span><span class="s3">\n        </span><span class="s1">const prediction = min(reach.alts);</span><span class="s3">\n        </span><span class="s1">newState.isAcceptState = true;</span><span class="s3">\n        </span><span class="s1">newState.prediction = prediction;</span><span class="s3">\n        </span><span class="s1">newState.configs.uniqueAlt = prediction;</span><span class="s3">\n        </span><span class="s1">reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newState = addDFAEdge(dfa, previousD, token, newState);</span><span class="s3">\n    </span><span class="s1">return newState;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {</span><span class="s3">\n    </span><span class="s1">const prefixPath = [];</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt;= lookahead; i++) {</span><span class="s3">\n        </span><span class="s1">prefixPath.push(this.LA(i).tokenType);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const atnState = dfa.atnStartState;</span><span class="s3">\n    </span><span class="s1">const topLevelRule = atnState.rule;</span><span class="s3">\n    </span><span class="s1">const production = atnState.production;</span><span class="s3">\n    </span><span class="s1">const message = buildAmbiguityError({</span><span class="s3">\n        </span><span class="s1">topLevelRule,</span><span class="s3">\n        </span><span class="s1">ambiguityIndices,</span><span class="s3">\n        </span><span class="s1">production,</span><span class="s3">\n        </span><span class="s1">prefixPath</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">logging(message);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildAmbiguityError(options) {</span><span class="s3">\n    </span><span class="s1">const pathMsg = map(options.prefixPath, (currtok) =&gt; tokenLabel(currtok)).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const occurrence = options.production.idx === 0 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: options.production.idx;</span><span class="s3">\n    </span><span class="s1">let currMessage = `Ambiguous Alternatives Detected: &lt;${options.ambiguityIndices.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">)}&gt; in &lt;${getProductionDslName(options.production)}${occurrence}&gt;` +</span><span class="s3">\n        </span><span class="s1">` inside &lt;${options.topLevelRule.name}&gt; Rule,</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n        </span><span class="s1">`&lt;${pathMsg}&gt; may appears as a prefix path in all these alternatives.</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">currMessage =</span><span class="s3">\n        </span><span class="s1">currMessage +</span><span class="s3">\n            </span><span class="s1">`See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES</span><span class="s3">\\</span><span class="s1">n` +</span><span class="s3">\n            </span><span class="s1">`For Further details.`;</span><span class="s3">\n    </span><span class="s1">return currMessage;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getProductionDslName(prod) {</span><span class="s3">\n    </span><span class="s1">if (prod instanceof NonTerminal) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">SUBRULE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Option) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">OPTION</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Alternation) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">OR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatory) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">AT_LEAST_ONE</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionMandatoryWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">AT_LEAST_ONE_SEP</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof RepetitionWithSeparator) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">MANY_SEP</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Repetition) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">MANY</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prod instanceof Terminal) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">CONSUME</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw Error(</span><span class="s3">\&quot;</span><span class="s1">non exhaustive match</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildAdaptivePredictError(path, previous, current) {</span><span class="s3">\n    </span><span class="s1">const nextTransitions = flatMap(previous.configs.elements, (e) =&gt; e.state.transitions);</span><span class="s3">\n    </span><span class="s1">const nextTokenTypes = uniqBy(nextTransitions</span><span class="s3">\n        </span><span class="s1">.filter((e) =&gt; e instanceof AtomTransition)</span><span class="s3">\n        </span><span class="s1">.map((e) =&gt; e.tokenType), (e) =&gt; e.tokenTypeIdx);</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">actualToken: current,</span><span class="s3">\n        </span><span class="s1">possibleTokenTypes: nextTokenTypes,</span><span class="s3">\n        </span><span class="s1">tokenPath: path</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getExistingTargetState(state, token) {</span><span class="s3">\n    </span><span class="s1">return state.edges[token.tokenTypeIdx];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeReachSet(configs, token, predicateSet) {</span><span class="s3">\n    </span><span class="s1">const intermediate = new ATNConfigSet();</span><span class="s3">\n    </span><span class="s1">const skippedStopStates = [];</span><span class="s3">\n    </span><span class="s1">for (const c of configs.elements) {</span><span class="s3">\n        </span><span class="s1">if (predicateSet.is(c.alt) === false) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (c.state.type === ATN_RULE_STOP) {</span><span class="s3">\n            </span><span class="s1">skippedStopStates.push(c);</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const transitionLength = c.state.transitions.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; transitionLength; i++) {</span><span class="s3">\n            </span><span class="s1">const transition = c.state.transitions[i];</span><span class="s3">\n            </span><span class="s1">const target = getReachableTarget(transition, token);</span><span class="s3">\n            </span><span class="s1">if (target !== undefined) {</span><span class="s3">\n                </span><span class="s1">intermediate.add({</span><span class="s3">\n                    </span><span class="s1">state: target,</span><span class="s3">\n                    </span><span class="s1">alt: c.alt,</span><span class="s3">\n                    </span><span class="s1">stack: c.stack</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let reach;</span><span class="s3">\n    </span><span class="s1">if (skippedStopStates.length === 0 &amp;&amp; intermediate.size === 1) {</span><span class="s3">\n        </span><span class="s1">reach = intermediate;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (reach === undefined) {</span><span class="s3">\n        </span><span class="s1">reach = new ATNConfigSet();</span><span class="s3">\n        </span><span class="s1">for (const c of intermediate.elements) {</span><span class="s3">\n            </span><span class="s1">closure(c, reach);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (skippedStopStates.length &gt; 0 &amp;&amp; !hasConfigInRuleStopState(reach)) {</span><span class="s3">\n        </span><span class="s1">for (const c of skippedStopStates) {</span><span class="s3">\n            </span><span class="s1">reach.add(c);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return reach;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getReachableTarget(transition, token) {</span><span class="s3">\n    </span><span class="s1">if (transition instanceof AtomTransition &amp;&amp;</span><span class="s3">\n        </span><span class="s1">tokenMatcher(token, transition.tokenType)) {</span><span class="s3">\n        </span><span class="s1">return transition.target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getUniqueAlt(configs, predicateSet) {</span><span class="s3">\n    </span><span class="s1">let alt;</span><span class="s3">\n    </span><span class="s1">for (const c of configs.elements) {</span><span class="s3">\n        </span><span class="s1">if (predicateSet.is(c.alt) === true) {</span><span class="s3">\n            </span><span class="s1">if (alt === undefined) {</span><span class="s3">\n                </span><span class="s1">alt = c.alt;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (alt !== c.alt) {</span><span class="s3">\n                </span><span class="s1">return undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return alt;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function newDFAState(closure) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">configs: closure,</span><span class="s3">\n        </span><span class="s1">edges: {},</span><span class="s3">\n        </span><span class="s1">isAcceptState: false,</span><span class="s3">\n        </span><span class="s1">prediction: -1</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addDFAEdge(dfa, from, token, to) {</span><span class="s3">\n    </span><span class="s1">to = addDFAState(dfa, to);</span><span class="s3">\n    </span><span class="s1">from.edges[token.tokenTypeIdx] = to;</span><span class="s3">\n    </span><span class="s1">return to;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addDFAState(dfa, state) {</span><span class="s3">\n    </span><span class="s1">if (state === DFA_ERROR) {</span><span class="s3">\n        </span><span class="s1">return state;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Repetitions have the same config set</span><span class="s3">\n    </span><span class="s1">// Therefore, storing the key of the config in a map allows us to create a loop in our DFA</span><span class="s3">\n    </span><span class="s1">const mapKey = state.configs.key;</span><span class="s3">\n    </span><span class="s1">const existing = dfa.states[mapKey];</span><span class="s3">\n    </span><span class="s1">if (existing !== undefined) {</span><span class="s3">\n        </span><span class="s1">return existing;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.configs.finalize();</span><span class="s3">\n    </span><span class="s1">dfa.states[mapKey] = state;</span><span class="s3">\n    </span><span class="s1">return state;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeStartState(atnState) {</span><span class="s3">\n    </span><span class="s1">const configs = new ATNConfigSet();</span><span class="s3">\n    </span><span class="s1">const numberOfTransitions = atnState.transitions.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numberOfTransitions; i++) {</span><span class="s3">\n        </span><span class="s1">const target = atnState.transitions[i].target;</span><span class="s3">\n        </span><span class="s1">const config = {</span><span class="s3">\n            </span><span class="s1">state: target,</span><span class="s3">\n            </span><span class="s1">alt: i,</span><span class="s3">\n            </span><span class="s1">stack: []</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">closure(config, configs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return configs;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function closure(config, configs) {</span><span class="s3">\n    </span><span class="s1">const p = config.state;</span><span class="s3">\n    </span><span class="s1">if (p.type === ATN_RULE_STOP) {</span><span class="s3">\n        </span><span class="s1">if (config.stack.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">const atnStack = [...config.stack];</span><span class="s3">\n            </span><span class="s1">const followState = atnStack.pop();</span><span class="s3">\n            </span><span class="s1">const followConfig = {</span><span class="s3">\n                </span><span class="s1">state: followState,</span><span class="s3">\n                </span><span class="s1">alt: config.alt,</span><span class="s3">\n                </span><span class="s1">stack: atnStack</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">closure(followConfig, configs);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Dipping into outer context, simply add the config</span><span class="s3">\n            </span><span class="s1">// This will stop computation once every config is at the rule stop state</span><span class="s3">\n            </span><span class="s1">configs.add(config);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!p.epsilonOnlyTransitions) {</span><span class="s3">\n        </span><span class="s1">configs.add(config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const transitionLength = p.transitions.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; transitionLength; i++) {</span><span class="s3">\n        </span><span class="s1">const transition = p.transitions[i];</span><span class="s3">\n        </span><span class="s1">const c = getEpsilonTarget(config, transition);</span><span class="s3">\n        </span><span class="s1">if (c !== undefined) {</span><span class="s3">\n            </span><span class="s1">closure(c, configs);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getEpsilonTarget(config, transition) {</span><span class="s3">\n    </span><span class="s1">if (transition instanceof EpsilonTransition) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">state: transition.target,</span><span class="s3">\n            </span><span class="s1">alt: config.alt,</span><span class="s3">\n            </span><span class="s1">stack: config.stack</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (transition instanceof RuleTransition) {</span><span class="s3">\n        </span><span class="s1">const stack = [...config.stack, transition.followState];</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">state: transition.target,</span><span class="s3">\n            </span><span class="s1">alt: config.alt,</span><span class="s3">\n            </span><span class="s1">stack</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasConfigInRuleStopState(configs) {</span><span class="s3">\n    </span><span class="s1">for (const c of configs.elements) {</span><span class="s3">\n        </span><span class="s1">if (c.state.type === ATN_RULE_STOP) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function allConfigsInRuleStopStates(configs) {</span><span class="s3">\n    </span><span class="s1">for (const c of configs.elements) {</span><span class="s3">\n        </span><span class="s1">if (c.state.type !== ATN_RULE_STOP) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasConflictTerminatingPrediction(configs) {</span><span class="s3">\n    </span><span class="s1">if (allConfigsInRuleStopStates(configs)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const altSets = getConflictingAltSets(configs.elements);</span><span class="s3">\n    </span><span class="s1">const heuristic = hasConflictingAltSet(altSets) &amp;&amp; !hasStateAssociatedWithOneAlt(altSets);</span><span class="s3">\n    </span><span class="s1">return heuristic;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getConflictingAltSets(configs) {</span><span class="s3">\n    </span><span class="s1">const configToAlts = new Map();</span><span class="s3">\n    </span><span class="s1">for (const c of configs) {</span><span class="s3">\n        </span><span class="s1">const key = getATNConfigKey(c, false);</span><span class="s3">\n        </span><span class="s1">let alts = configToAlts.get(key);</span><span class="s3">\n        </span><span class="s1">if (alts === undefined) {</span><span class="s3">\n            </span><span class="s1">alts = {};</span><span class="s3">\n            </span><span class="s1">configToAlts.set(key, alts);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">alts[c.alt] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return configToAlts;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasConflictingAltSet(altSets) {</span><span class="s3">\n    </span><span class="s1">for (const value of Array.from(altSets.values())) {</span><span class="s3">\n        </span><span class="s1">if (Object.keys(value).length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function hasStateAssociatedWithOneAlt(altSets) {</span><span class="s3">\n    </span><span class="s1">for (const value of Array.from(altSets.values())) {</span><span class="s3">\n        </span><span class="s1">if (Object.keys(value).length === 1) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=all-star-lookahead.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export { LLStarLookaheadStrategy } from './all-star-lookahead.js';</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">'use strict';</span><span class="s3">\n</span><span class="s1">export var DocumentUri;</span><span class="s3">\n</span><span class="s1">(function (DocumentUri) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentUri.is = is;</span><span class="s3">\n</span><span class="s1">})(DocumentUri || (DocumentUri = {}));</span><span class="s3">\n</span><span class="s1">export var URI;</span><span class="s3">\n</span><span class="s1">(function (URI) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">URI.is = is;</span><span class="s3">\n</span><span class="s1">})(URI || (URI = {}));</span><span class="s3">\n</span><span class="s1">export var integer;</span><span class="s3">\n</span><span class="s1">(function (integer) {</span><span class="s3">\n    </span><span class="s1">integer.MIN_VALUE = -2147483648;</span><span class="s3">\n    </span><span class="s1">integer.MAX_VALUE = 2147483647;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'number' &amp;&amp; integer.MIN_VALUE &lt;= value &amp;&amp; value &lt;= integer.MAX_VALUE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">integer.is = is;</span><span class="s3">\n</span><span class="s1">})(integer || (integer = {}));</span><span class="s3">\n</span><span class="s1">export var uinteger;</span><span class="s3">\n</span><span class="s1">(function (uinteger) {</span><span class="s3">\n    </span><span class="s1">uinteger.MIN_VALUE = 0;</span><span class="s3">\n    </span><span class="s1">uinteger.MAX_VALUE = 2147483647;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'number' &amp;&amp; uinteger.MIN_VALUE &lt;= value &amp;&amp; value &lt;= uinteger.MAX_VALUE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">uinteger.is = is;</span><span class="s3">\n</span><span class="s1">})(uinteger || (uinteger = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Position namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Position} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Position;</span><span class="s3">\n</span><span class="s1">(function (Position) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new Position literal from the given line and character.</span><span class="s3">\n     </span><span class="s1">* @param line The position's line.</span><span class="s3">\n     </span><span class="s1">* @param character The position's character.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(line, character) {</span><span class="s3">\n        </span><span class="s1">if (line === Number.MAX_VALUE) {</span><span class="s3">\n            </span><span class="s1">line = uinteger.MAX_VALUE;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (character === Number.MAX_VALUE) {</span><span class="s3">\n            </span><span class="s1">character = uinteger.MAX_VALUE;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { line, character };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Position.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Position} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.uinteger(candidate.line) &amp;&amp; Is.uinteger(candidate.character);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Position.is = is;</span><span class="s3">\n</span><span class="s1">})(Position || (Position = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Range namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Range} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Range;</span><span class="s3">\n</span><span class="s1">(function (Range) {</span><span class="s3">\n    </span><span class="s1">function create(one, two, three, four) {</span><span class="s3">\n        </span><span class="s1">if (Is.uinteger(one) &amp;&amp; Is.uinteger(two) &amp;&amp; Is.uinteger(three) &amp;&amp; Is.uinteger(four)) {</span><span class="s3">\n            </span><span class="s1">return { start: Position.create(one, two), end: Position.create(three, four) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (Position.is(one) &amp;&amp; Position.is(two)) {</span><span class="s3">\n            </span><span class="s1">return { start: one, end: two };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Range.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Range} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Position.is(candidate.start) &amp;&amp; Position.is(candidate.end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Range.is = is;</span><span class="s3">\n</span><span class="s1">})(Range || (Range = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Location namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Location} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Location;</span><span class="s3">\n</span><span class="s1">(function (Location) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a Location literal.</span><span class="s3">\n     </span><span class="s1">* @param uri The location's uri.</span><span class="s3">\n     </span><span class="s1">* @param range The location's range.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, range) {</span><span class="s3">\n        </span><span class="s1">return { uri, range };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Location.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Location} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Range.is(candidate.range) &amp;&amp; (Is.string(candidate.uri) || Is.undefined(candidate.uri));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Location.is = is;</span><span class="s3">\n</span><span class="s1">})(Location || (Location = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The LocationLink namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link LocationLink} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var LocationLink;</span><span class="s3">\n</span><span class="s1">(function (LocationLink) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a LocationLink literal.</span><span class="s3">\n     </span><span class="s1">* @param targetUri The definition's uri.</span><span class="s3">\n     </span><span class="s1">* @param targetRange The full range of the definition.</span><span class="s3">\n     </span><span class="s1">* @param targetSelectionRange The span of the symbol definition at the target.</span><span class="s3">\n     </span><span class="s1">* @param originSelectionRange The span of the symbol being defined in the originating source file.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {</span><span class="s3">\n        </span><span class="s1">return { targetUri, targetRange, targetSelectionRange, originSelectionRange };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">LocationLink.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link LocationLink} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Range.is(candidate.targetRange) &amp;&amp; Is.string(candidate.targetUri)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Range.is(candidate.targetSelectionRange)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">LocationLink.is = is;</span><span class="s3">\n</span><span class="s1">})(LocationLink || (LocationLink = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Color namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Color} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Color;</span><span class="s3">\n</span><span class="s1">(function (Color) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new Color literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(red, green, blue, alpha) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">red,</span><span class="s3">\n            </span><span class="s1">green,</span><span class="s3">\n            </span><span class="s1">blue,</span><span class="s3">\n            </span><span class="s1">alpha,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Color.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Color} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.numberRange(candidate.red, 0, 1)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.numberRange(candidate.green, 0, 1)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.numberRange(candidate.blue, 0, 1)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.numberRange(candidate.alpha, 0, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Color.is = is;</span><span class="s3">\n</span><span class="s1">})(Color || (Color = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The ColorInformation namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link ColorInformation} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var ColorInformation;</span><span class="s3">\n</span><span class="s1">(function (ColorInformation) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new ColorInformation literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, color) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">range,</span><span class="s3">\n            </span><span class="s1">color,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ColorInformation.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link ColorInformation} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Range.is(candidate.range) &amp;&amp; Color.is(candidate.color);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ColorInformation.is = is;</span><span class="s3">\n</span><span class="s1">})(ColorInformation || (ColorInformation = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Color namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link ColorPresentation} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var ColorPresentation;</span><span class="s3">\n</span><span class="s1">(function (ColorPresentation) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new ColorInformation literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(label, textEdit, additionalTextEdits) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">label,</span><span class="s3">\n            </span><span class="s1">textEdit,</span><span class="s3">\n            </span><span class="s1">additionalTextEdits,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ColorPresentation.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link ColorInformation} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.string(candidate.label)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ColorPresentation.is = is;</span><span class="s3">\n</span><span class="s1">})(ColorPresentation || (ColorPresentation = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of predefined range kinds.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var FoldingRangeKind;</span><span class="s3">\n</span><span class="s1">(function (FoldingRangeKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Folding range for a comment</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">FoldingRangeKind.Comment = 'comment';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Folding range for an import or include</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">FoldingRangeKind.Imports = 'imports';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Folding range for a region (e.g. `#region`)</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">FoldingRangeKind.Region = 'region';</span><span class="s3">\n</span><span class="s1">})(FoldingRangeKind || (FoldingRangeKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The folding range namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link FoldingRange} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var FoldingRange;</span><span class="s3">\n</span><span class="s1">(function (FoldingRange) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new FoldingRange literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {</span><span class="s3">\n        </span><span class="s1">const result = {</span><span class="s3">\n            </span><span class="s1">startLine,</span><span class="s3">\n            </span><span class="s1">endLine</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (Is.defined(startCharacter)) {</span><span class="s3">\n            </span><span class="s1">result.startCharacter = startCharacter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(endCharacter)) {</span><span class="s3">\n            </span><span class="s1">result.endCharacter = endCharacter;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(kind)) {</span><span class="s3">\n            </span><span class="s1">result.kind = kind;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(collapsedText)) {</span><span class="s3">\n            </span><span class="s1">result.collapsedText = collapsedText;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">FoldingRange.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link FoldingRange} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.uinteger(candidate.startLine) &amp;&amp; Is.uinteger(candidate.startLine)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.kind) || Is.string(candidate.kind));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">FoldingRange.is = is;</span><span class="s3">\n</span><span class="s1">})(FoldingRange || (FoldingRange = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The DiagnosticRelatedInformation namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link DiagnosticRelatedInformation} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DiagnosticRelatedInformation;</span><span class="s3">\n</span><span class="s1">(function (DiagnosticRelatedInformation) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new DiagnosticRelatedInformation literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(location, message) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">location,</span><span class="s3">\n            </span><span class="s1">message</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DiagnosticRelatedInformation.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Location.is(candidate.location) &amp;&amp; Is.string(candidate.message);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DiagnosticRelatedInformation.is = is;</span><span class="s3">\n</span><span class="s1">})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The diagnostic's severity.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DiagnosticSeverity;</span><span class="s3">\n</span><span class="s1">(function (DiagnosticSeverity) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reports an error.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticSeverity.Error = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reports a warning.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticSeverity.Warning = 2;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reports an information.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticSeverity.Information = 3;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reports a hint.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticSeverity.Hint = 4;</span><span class="s3">\n</span><span class="s1">})(DiagnosticSeverity || (DiagnosticSeverity = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The diagnostic tags.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.15.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DiagnosticTag;</span><span class="s3">\n</span><span class="s1">(function (DiagnosticTag) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Unused or unnecessary code.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Clients are allowed to render diagnostics with this tag faded out instead of having</span><span class="s3">\n     </span><span class="s1">* an error squiggle.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticTag.Unnecessary = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Deprecated or obsolete code.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Clients are allowed to rendered diagnostics with this tag strike through.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DiagnosticTag.Deprecated = 2;</span><span class="s3">\n</span><span class="s1">})(DiagnosticTag || (DiagnosticTag = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CodeDescription;</span><span class="s3">\n</span><span class="s1">(function (CodeDescription) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.string(candidate.href);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeDescription.is = is;</span><span class="s3">\n</span><span class="s1">})(CodeDescription || (CodeDescription = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Diagnostic namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Diagnostic} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Diagnostic;</span><span class="s3">\n</span><span class="s1">(function (Diagnostic) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new Diagnostic literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, message, severity, code, source, relatedInformation) {</span><span class="s3">\n        </span><span class="s1">let result = { range, message };</span><span class="s3">\n        </span><span class="s1">if (Is.defined(severity)) {</span><span class="s3">\n            </span><span class="s1">result.severity = severity;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(code)) {</span><span class="s3">\n            </span><span class="s1">result.code = code;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(source)) {</span><span class="s3">\n            </span><span class="s1">result.source = source;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(relatedInformation)) {</span><span class="s3">\n            </span><span class="s1">result.relatedInformation = relatedInformation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Diagnostic.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Diagnostic} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Range.is(candidate.range)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.string(candidate.message)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.number(candidate.severity) || Is.undefined(candidate.severity))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.string(candidate.source) || Is.undefined(candidate.source))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Diagnostic.is = is;</span><span class="s3">\n</span><span class="s1">})(Diagnostic || (Diagnostic = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Command namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link Command} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Command;</span><span class="s3">\n</span><span class="s1">(function (Command) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new Command literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(title, command, ...args) {</span><span class="s3">\n        </span><span class="s1">let result = { title, command };</span><span class="s3">\n        </span><span class="s1">if (Is.defined(args) &amp;&amp; args.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">result.arguments = args;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Command.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link Command} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.title) &amp;&amp; Is.string(candidate.command);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Command.is = is;</span><span class="s3">\n</span><span class="s1">})(Command || (Command = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The TextEdit namespace provides helper function to create replace,</span><span class="s3">\n </span><span class="s1">* insert and delete edits more easily.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TextEdit;</span><span class="s3">\n</span><span class="s1">(function (TextEdit) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a replace text edit.</span><span class="s3">\n     </span><span class="s1">* @param range The range of text to be replaced.</span><span class="s3">\n     </span><span class="s1">* @param newText The new text.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function replace(range, newText) {</span><span class="s3">\n        </span><span class="s1">return { range, newText };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextEdit.replace = replace;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates an insert text edit.</span><span class="s3">\n     </span><span class="s1">* @param position The position to insert the text at.</span><span class="s3">\n     </span><span class="s1">* @param newText The text to be inserted.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function insert(position, newText) {</span><span class="s3">\n        </span><span class="s1">return { range: { start: position, end: position }, newText };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextEdit.insert = insert;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a delete text edit.</span><span class="s3">\n     </span><span class="s1">* @param range The range of text to be deleted.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function del(range) {</span><span class="s3">\n        </span><span class="s1">return { range, newText: '' };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextEdit.del = del;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.string(candidate.newText)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Range.is(candidate.range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextEdit.is = is;</span><span class="s3">\n</span><span class="s1">})(TextEdit || (TextEdit = {}));</span><span class="s3">\n</span><span class="s1">export var ChangeAnnotation;</span><span class="s3">\n</span><span class="s1">(function (ChangeAnnotation) {</span><span class="s3">\n    </span><span class="s1">function create(label, needsConfirmation, description) {</span><span class="s3">\n        </span><span class="s1">const result = { label };</span><span class="s3">\n        </span><span class="s1">if (needsConfirmation !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.needsConfirmation = needsConfirmation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (description !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.description = description;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ChangeAnnotation.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Is.string(candidate.label) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(Is.string(candidate.description) || candidate.description === undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ChangeAnnotation.is = is;</span><span class="s3">\n</span><span class="s1">})(ChangeAnnotation || (ChangeAnnotation = {}));</span><span class="s3">\n</span><span class="s1">export var ChangeAnnotationIdentifier;</span><span class="s3">\n</span><span class="s1">(function (ChangeAnnotationIdentifier) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.string(candidate);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ChangeAnnotationIdentifier.is = is;</span><span class="s3">\n</span><span class="s1">})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));</span><span class="s3">\n</span><span class="s1">export var AnnotatedTextEdit;</span><span class="s3">\n</span><span class="s1">(function (AnnotatedTextEdit) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates an annotated replace text edit.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param range The range of text to be replaced.</span><span class="s3">\n     </span><span class="s1">* @param newText The new text.</span><span class="s3">\n     </span><span class="s1">* @param annotation The annotation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function replace(range, newText, annotation) {</span><span class="s3">\n        </span><span class="s1">return { range, newText, annotationId: annotation };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AnnotatedTextEdit.replace = replace;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates an annotated insert text edit.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param position The position to insert the text at.</span><span class="s3">\n     </span><span class="s1">* @param newText The text to be inserted.</span><span class="s3">\n     </span><span class="s1">* @param annotation The annotation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function insert(position, newText, annotation) {</span><span class="s3">\n        </span><span class="s1">return { range: { start: position, end: position }, newText, annotationId: annotation };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AnnotatedTextEdit.insert = insert;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates an annotated delete text edit.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param range The range of text to be deleted.</span><span class="s3">\n     </span><span class="s1">* @param annotation The annotation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function del(range, annotation) {</span><span class="s3">\n        </span><span class="s1">return { range, newText: '', annotationId: annotation };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AnnotatedTextEdit.del = del;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return TextEdit.is(candidate) &amp;&amp; (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">AnnotatedTextEdit.is = is;</span><span class="s3">\n</span><span class="s1">})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The TextDocumentEdit namespace provides helper function to create</span><span class="s3">\n </span><span class="s1">* an edit that manipulates a text document.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TextDocumentEdit;</span><span class="s3">\n</span><span class="s1">(function (TextDocumentEdit) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new `TextDocumentEdit`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(textDocument, edits) {</span><span class="s3">\n        </span><span class="s1">return { textDocument, edits };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentEdit.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Array.isArray(candidate.edits);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentEdit.is = is;</span><span class="s3">\n</span><span class="s1">})(TextDocumentEdit || (TextDocumentEdit = {}));</span><span class="s3">\n</span><span class="s1">export var CreateFile;</span><span class="s3">\n</span><span class="s1">(function (CreateFile) {</span><span class="s3">\n    </span><span class="s1">function create(uri, options, annotation) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">kind: 'create',</span><span class="s3">\n            </span><span class="s1">uri</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (options !== undefined &amp;&amp; (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {</span><span class="s3">\n            </span><span class="s1">result.options = options;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (annotation !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.annotationId = annotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CreateFile.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; candidate.kind === 'create' &amp;&amp; Is.string(candidate.uri) &amp;&amp; (candidate.options === undefined ||</span><span class="s3">\n            </span><span class="s1">((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) &amp;&amp; (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) &amp;&amp; (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CreateFile.is = is;</span><span class="s3">\n</span><span class="s1">})(CreateFile || (CreateFile = {}));</span><span class="s3">\n</span><span class="s1">export var RenameFile;</span><span class="s3">\n</span><span class="s1">(function (RenameFile) {</span><span class="s3">\n    </span><span class="s1">function create(oldUri, newUri, options, annotation) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">kind: 'rename',</span><span class="s3">\n            </span><span class="s1">oldUri,</span><span class="s3">\n            </span><span class="s1">newUri</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (options !== undefined &amp;&amp; (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {</span><span class="s3">\n            </span><span class="s1">result.options = options;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (annotation !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.annotationId = annotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RenameFile.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; candidate.kind === 'rename' &amp;&amp; Is.string(candidate.oldUri) &amp;&amp; Is.string(candidate.newUri) &amp;&amp; (candidate.options === undefined ||</span><span class="s3">\n            </span><span class="s1">((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) &amp;&amp; (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) &amp;&amp; (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RenameFile.is = is;</span><span class="s3">\n</span><span class="s1">})(RenameFile || (RenameFile = {}));</span><span class="s3">\n</span><span class="s1">export var DeleteFile;</span><span class="s3">\n</span><span class="s1">(function (DeleteFile) {</span><span class="s3">\n    </span><span class="s1">function create(uri, options, annotation) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">kind: 'delete',</span><span class="s3">\n            </span><span class="s1">uri</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (options !== undefined &amp;&amp; (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {</span><span class="s3">\n            </span><span class="s1">result.options = options;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (annotation !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.annotationId = annotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DeleteFile.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; candidate.kind === 'delete' &amp;&amp; Is.string(candidate.uri) &amp;&amp; (candidate.options === undefined ||</span><span class="s3">\n            </span><span class="s1">((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) &amp;&amp; (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) &amp;&amp; (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DeleteFile.is = is;</span><span class="s3">\n</span><span class="s1">})(DeleteFile || (DeleteFile = {}));</span><span class="s3">\n</span><span class="s1">export var WorkspaceEdit;</span><span class="s3">\n</span><span class="s1">(function (WorkspaceEdit) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.changes !== undefined || candidate.documentChanges !== undefined) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.documentChanges === undefined || candidate.documentChanges.every((change) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (Is.string(change.kind)) {</span><span class="s3">\n                    </span><span class="s1">return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return TextDocumentEdit.is(change);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">WorkspaceEdit.is = is;</span><span class="s3">\n</span><span class="s1">})(WorkspaceEdit || (WorkspaceEdit = {}));</span><span class="s3">\n</span><span class="s1">class TextEditChangeImpl {</span><span class="s3">\n    </span><span class="s1">constructor(edits, changeAnnotations) {</span><span class="s3">\n        </span><span class="s1">this.edits = edits;</span><span class="s3">\n        </span><span class="s1">this.changeAnnotations = changeAnnotations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">insert(position, newText, annotation) {</span><span class="s3">\n        </span><span class="s1">let edit;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">edit = TextEdit.insert(position, newText);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ChangeAnnotationIdentifier.is(annotation)) {</span><span class="s3">\n            </span><span class="s1">id = annotation;</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.insert(position, newText, annotation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.assertChangeAnnotations(this.changeAnnotations);</span><span class="s3">\n            </span><span class="s1">id = this.changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.insert(position, newText, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.edits.push(edit);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(range, newText, annotation) {</span><span class="s3">\n        </span><span class="s1">let edit;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">edit = TextEdit.replace(range, newText);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ChangeAnnotationIdentifier.is(annotation)) {</span><span class="s3">\n            </span><span class="s1">id = annotation;</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.replace(range, newText, annotation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.assertChangeAnnotations(this.changeAnnotations);</span><span class="s3">\n            </span><span class="s1">id = this.changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.replace(range, newText, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.edits.push(edit);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete(range, annotation) {</span><span class="s3">\n        </span><span class="s1">let edit;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">edit = TextEdit.del(range);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ChangeAnnotationIdentifier.is(annotation)) {</span><span class="s3">\n            </span><span class="s1">id = annotation;</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.del(range, annotation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.assertChangeAnnotations(this.changeAnnotations);</span><span class="s3">\n            </span><span class="s1">id = this.changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">edit = AnnotatedTextEdit.del(range, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.edits.push(edit);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">add(edit) {</span><span class="s3">\n        </span><span class="s1">this.edits.push(edit);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">all() {</span><span class="s3">\n        </span><span class="s1">return this.edits;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this.edits.splice(0, this.edits.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assertChangeAnnotations(value) {</span><span class="s3">\n        </span><span class="s1">if (value === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Text edit change is not configured to manage change annotations.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A helper class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ChangeAnnotations {</span><span class="s3">\n    </span><span class="s1">constructor(annotations) {</span><span class="s3">\n        </span><span class="s1">this._annotations = annotations === undefined ? Object.create(null) : annotations;</span><span class="s3">\n        </span><span class="s1">this._counter = 0;</span><span class="s3">\n        </span><span class="s1">this._size = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">all() {</span><span class="s3">\n        </span><span class="s1">return this._annotations;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">return this._size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">manage(idOrAnnotation, annotation) {</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {</span><span class="s3">\n            </span><span class="s1">id = idOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">id = this.nextId();</span><span class="s3">\n            </span><span class="s1">annotation = idOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._annotations[id] !== undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Id ${id} is already in use.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`No annotation provided for id ${id}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._annotations[id] = annotation;</span><span class="s3">\n        </span><span class="s1">this._size++;</span><span class="s3">\n        </span><span class="s1">return id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextId() {</span><span class="s3">\n        </span><span class="s1">this._counter++;</span><span class="s3">\n        </span><span class="s1">return this._counter.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A workspace change helps constructing changes to a workspace.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class WorkspaceChange {</span><span class="s3">\n    </span><span class="s1">constructor(workspaceEdit) {</span><span class="s3">\n        </span><span class="s1">this._textEditChanges = Object.create(null);</span><span class="s3">\n        </span><span class="s1">if (workspaceEdit !== undefined) {</span><span class="s3">\n            </span><span class="s1">this._workspaceEdit = workspaceEdit;</span><span class="s3">\n            </span><span class="s1">if (workspaceEdit.documentChanges) {</span><span class="s3">\n                </span><span class="s1">this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);</span><span class="s3">\n                </span><span class="s1">workspaceEdit.changeAnnotations = this._changeAnnotations.all();</span><span class="s3">\n                </span><span class="s1">workspaceEdit.documentChanges.forEach((change) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (TextDocumentEdit.is(change)) {</span><span class="s3">\n                        </span><span class="s1">const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);</span><span class="s3">\n                        </span><span class="s1">this._textEditChanges[change.textDocument.uri] = textEditChange;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (workspaceEdit.changes) {</span><span class="s3">\n                </span><span class="s1">Object.keys(workspaceEdit.changes).forEach((key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);</span><span class="s3">\n                    </span><span class="s1">this._textEditChanges[key] = textEditChange;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._workspaceEdit = {};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns the underlying {@link WorkspaceEdit} literal</span><span class="s3">\n     </span><span class="s1">* use to be returned from a workspace edit operation like rename.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get edit() {</span><span class="s3">\n        </span><span class="s1">this.initDocumentChanges();</span><span class="s3">\n        </span><span class="s1">if (this._changeAnnotations !== undefined) {</span><span class="s3">\n            </span><span class="s1">if (this._changeAnnotations.size === 0) {</span><span class="s3">\n                </span><span class="s1">this._workspaceEdit.changeAnnotations = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._workspaceEdit;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTextEditChange(key) {</span><span class="s3">\n        </span><span class="s1">if (OptionalVersionedTextDocumentIdentifier.is(key)) {</span><span class="s3">\n            </span><span class="s1">this.initDocumentChanges();</span><span class="s3">\n            </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Workspace edit is not configured for document changes.');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const textDocument = { uri: key.uri, version: key.version };</span><span class="s3">\n            </span><span class="s1">let result = this._textEditChanges[textDocument.uri];</span><span class="s3">\n            </span><span class="s1">if (!result) {</span><span class="s3">\n                </span><span class="s1">const edits = [];</span><span class="s3">\n                </span><span class="s1">const textDocumentEdit = {</span><span class="s3">\n                    </span><span class="s1">textDocument,</span><span class="s3">\n                    </span><span class="s1">edits</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this._workspaceEdit.documentChanges.push(textDocumentEdit);</span><span class="s3">\n                </span><span class="s1">result = new TextEditChangeImpl(edits, this._changeAnnotations);</span><span class="s3">\n                </span><span class="s1">this._textEditChanges[textDocument.uri] = result;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.initChanges();</span><span class="s3">\n            </span><span class="s1">if (this._workspaceEdit.changes === undefined) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Workspace edit is not configured for normal text edit changes.');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let result = this._textEditChanges[key];</span><span class="s3">\n            </span><span class="s1">if (!result) {</span><span class="s3">\n                </span><span class="s1">let edits = [];</span><span class="s3">\n                </span><span class="s1">this._workspaceEdit.changes[key] = edits;</span><span class="s3">\n                </span><span class="s1">result = new TextEditChangeImpl(edits);</span><span class="s3">\n                </span><span class="s1">this._textEditChanges[key] = result;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initDocumentChanges() {</span><span class="s3">\n        </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined &amp;&amp; this._workspaceEdit.changes === undefined) {</span><span class="s3">\n            </span><span class="s1">this._changeAnnotations = new ChangeAnnotations();</span><span class="s3">\n            </span><span class="s1">this._workspaceEdit.documentChanges = [];</span><span class="s3">\n            </span><span class="s1">this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initChanges() {</span><span class="s3">\n        </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined &amp;&amp; this._workspaceEdit.changes === undefined) {</span><span class="s3">\n            </span><span class="s1">this._workspaceEdit.changes = Object.create(null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createFile(uri, optionsOrAnnotation, options) {</span><span class="s3">\n        </span><span class="s1">this.initDocumentChanges();</span><span class="s3">\n        </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Workspace edit is not configured for document changes.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let annotation;</span><span class="s3">\n        </span><span class="s1">if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {</span><span class="s3">\n            </span><span class="s1">annotation = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">options = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let operation;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">operation = CreateFile.create(uri, options);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">operation = CreateFile.create(uri, options, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._workspaceEdit.documentChanges.push(operation);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">renameFile(oldUri, newUri, optionsOrAnnotation, options) {</span><span class="s3">\n        </span><span class="s1">this.initDocumentChanges();</span><span class="s3">\n        </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Workspace edit is not configured for document changes.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let annotation;</span><span class="s3">\n        </span><span class="s1">if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {</span><span class="s3">\n            </span><span class="s1">annotation = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">options = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let operation;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">operation = RenameFile.create(oldUri, newUri, options);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">operation = RenameFile.create(oldUri, newUri, options, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._workspaceEdit.documentChanges.push(operation);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">deleteFile(uri, optionsOrAnnotation, options) {</span><span class="s3">\n        </span><span class="s1">this.initDocumentChanges();</span><span class="s3">\n        </span><span class="s1">if (this._workspaceEdit.documentChanges === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Workspace edit is not configured for document changes.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let annotation;</span><span class="s3">\n        </span><span class="s1">if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {</span><span class="s3">\n            </span><span class="s1">annotation = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">options = optionsOrAnnotation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let operation;</span><span class="s3">\n        </span><span class="s1">let id;</span><span class="s3">\n        </span><span class="s1">if (annotation === undefined) {</span><span class="s3">\n            </span><span class="s1">operation = DeleteFile.create(uri, options);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);</span><span class="s3">\n            </span><span class="s1">operation = DeleteFile.create(uri, options, id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._workspaceEdit.documentChanges.push(operation);</span><span class="s3">\n        </span><span class="s1">if (id !== undefined) {</span><span class="s3">\n            </span><span class="s1">return id;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The TextDocumentIdentifier namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link TextDocumentIdentifier} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TextDocumentIdentifier;</span><span class="s3">\n</span><span class="s1">(function (TextDocumentIdentifier) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new TextDocumentIdentifier literal.</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri) {</span><span class="s3">\n        </span><span class="s1">return { uri };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentIdentifier.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.uri);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentIdentifier.is = is;</span><span class="s3">\n</span><span class="s1">})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The VersionedTextDocumentIdentifier namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link VersionedTextDocumentIdentifier} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var VersionedTextDocumentIdentifier;</span><span class="s3">\n</span><span class="s1">(function (VersionedTextDocumentIdentifier) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new VersionedTextDocumentIdentifier literal.</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">* @param version The document's version.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, version) {</span><span class="s3">\n        </span><span class="s1">return { uri, version };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">VersionedTextDocumentIdentifier.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.uri) &amp;&amp; Is.integer(candidate.version);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">VersionedTextDocumentIdentifier.is = is;</span><span class="s3">\n</span><span class="s1">})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link OptionalVersionedTextDocumentIdentifier} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var OptionalVersionedTextDocumentIdentifier;</span><span class="s3">\n</span><span class="s1">(function (OptionalVersionedTextDocumentIdentifier) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new OptionalVersionedTextDocumentIdentifier literal.</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">* @param version The document's version.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, version) {</span><span class="s3">\n        </span><span class="s1">return { uri, version };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OptionalVersionedTextDocumentIdentifier.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.uri) &amp;&amp; (candidate.version === null || Is.integer(candidate.version));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">OptionalVersionedTextDocumentIdentifier.is = is;</span><span class="s3">\n</span><span class="s1">})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The TextDocumentItem namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link TextDocumentItem} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TextDocumentItem;</span><span class="s3">\n</span><span class="s1">(function (TextDocumentItem) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new TextDocumentItem literal.</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">* @param languageId The document's language identifier.</span><span class="s3">\n     </span><span class="s1">* @param version The document's version number.</span><span class="s3">\n     </span><span class="s1">* @param text The document's text.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, languageId, version, text) {</span><span class="s3">\n        </span><span class="s1">return { uri, languageId, version, text };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentItem.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link TextDocumentItem} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.uri) &amp;&amp; Is.string(candidate.languageId) &amp;&amp; Is.integer(candidate.version) &amp;&amp; Is.string(candidate.text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocumentItem.is = is;</span><span class="s3">\n</span><span class="s1">})(TextDocumentItem || (TextDocumentItem = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Describes the content type that a client supports in various</span><span class="s3">\n </span><span class="s1">* result literals like `Hover`, `ParameterInfo` or `CompletionItem`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Please note that `MarkupKinds` must not start with a `$`. This kinds</span><span class="s3">\n </span><span class="s1">* are reserved for internal usage.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var MarkupKind;</span><span class="s3">\n</span><span class="s1">(function (MarkupKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Plain text is supported as a content format</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MarkupKind.PlainText = 'plaintext';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Markdown is supported as a content format</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MarkupKind.Markdown = 'markdown';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given value is a value of the {@link MarkupKind} type.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MarkupKind.is = is;</span><span class="s3">\n</span><span class="s1">})(MarkupKind || (MarkupKind = {}));</span><span class="s3">\n</span><span class="s1">export var MarkupContent;</span><span class="s3">\n</span><span class="s1">(function (MarkupContent) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given value conforms to the {@link MarkupContent} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(value) &amp;&amp; MarkupKind.is(candidate.kind) &amp;&amp; Is.string(candidate.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MarkupContent.is = is;</span><span class="s3">\n</span><span class="s1">})(MarkupContent || (MarkupContent = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The kind of a completion entry.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CompletionItemKind;</span><span class="s3">\n</span><span class="s1">(function (CompletionItemKind) {</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Text = 1;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Method = 2;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Function = 3;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Constructor = 4;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Field = 5;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Variable = 6;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Class = 7;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Interface = 8;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Module = 9;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Property = 10;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Unit = 11;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Value = 12;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Enum = 13;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Keyword = 14;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Snippet = 15;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Color = 16;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.File = 17;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Reference = 18;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Folder = 19;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.EnumMember = 20;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Constant = 21;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Struct = 22;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Event = 23;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.Operator = 24;</span><span class="s3">\n    </span><span class="s1">CompletionItemKind.TypeParameter = 25;</span><span class="s3">\n</span><span class="s1">})(CompletionItemKind || (CompletionItemKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Defines whether the insert text in a completion item should be interpreted as</span><span class="s3">\n </span><span class="s1">* plain text or a snippet.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InsertTextFormat;</span><span class="s3">\n</span><span class="s1">(function (InsertTextFormat) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The primary text to be inserted is treated as a plain string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InsertTextFormat.PlainText = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The primary text to be inserted is treated as a snippet.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* A snippet can define tab stops and placeholders with `$1`, `$2`</span><span class="s3">\n     </span><span class="s1">* and `${3:foo}`. `$0` defines the final tab stop, it defaults to</span><span class="s3">\n     </span><span class="s1">* the end of the snippet. Placeholders with equal identifiers are linked,</span><span class="s3">\n     </span><span class="s1">* that is typing in one will update others too.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InsertTextFormat.Snippet = 2;</span><span class="s3">\n</span><span class="s1">})(InsertTextFormat || (InsertTextFormat = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Completion item tags are extra annotations that tweak the rendering of a completion</span><span class="s3">\n </span><span class="s1">* item.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.15.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CompletionItemTag;</span><span class="s3">\n</span><span class="s1">(function (CompletionItemTag) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Render a completion as obsolete, usually using a strike-out.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CompletionItemTag.Deprecated = 1;</span><span class="s3">\n</span><span class="s1">})(CompletionItemTag || (CompletionItemTag = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InsertReplaceEdit;</span><span class="s3">\n</span><span class="s1">(function (InsertReplaceEdit) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new insert / replace edit</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(newText, insert, replace) {</span><span class="s3">\n        </span><span class="s1">return { newText, insert, replace };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InsertReplaceEdit.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.string(candidate.newText) &amp;&amp; Range.is(candidate.insert) &amp;&amp; Range.is(candidate.replace);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InsertReplaceEdit.is = is;</span><span class="s3">\n</span><span class="s1">})(InsertReplaceEdit || (InsertReplaceEdit = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* How whitespace and indentation is handled during completion</span><span class="s3">\n </span><span class="s1">* item insertion.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InsertTextMode;</span><span class="s3">\n</span><span class="s1">(function (InsertTextMode) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The insertion or replace strings is taken as it is. If the</span><span class="s3">\n     </span><span class="s1">* value is multi line the lines below the cursor will be</span><span class="s3">\n     </span><span class="s1">* inserted using the indentation defined in the string value.</span><span class="s3">\n     </span><span class="s1">* The client will not apply any kind of adjustments to the</span><span class="s3">\n     </span><span class="s1">* string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InsertTextMode.asIs = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The editor adjusts leading whitespace of new lines so that</span><span class="s3">\n     </span><span class="s1">* they match the indentation up to the cursor of the line for</span><span class="s3">\n     </span><span class="s1">* which the item is accepted.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Consider a line like this: &lt;2tabs&gt;&lt;cursor&gt;&lt;3tabs&gt;foo. Accepting a</span><span class="s3">\n     </span><span class="s1">* multi line completion item is indented using 2 tabs and all</span><span class="s3">\n     </span><span class="s1">* following lines inserted will be indented using 2 tabs as well.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InsertTextMode.adjustIndentation = 2;</span><span class="s3">\n</span><span class="s1">})(InsertTextMode || (InsertTextMode = {}));</span><span class="s3">\n</span><span class="s1">export var CompletionItemLabelDetails;</span><span class="s3">\n</span><span class="s1">(function (CompletionItemLabelDetails) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (Is.string(candidate.detail) || candidate.detail === undefined) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(Is.string(candidate.description) || candidate.description === undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CompletionItemLabelDetails.is = is;</span><span class="s3">\n</span><span class="s1">})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The CompletionItem namespace provides functions to deal with</span><span class="s3">\n </span><span class="s1">* completion items.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CompletionItem;</span><span class="s3">\n</span><span class="s1">(function (CompletionItem) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a completion item and seed it with a label.</span><span class="s3">\n     </span><span class="s1">* @param label The completion item's label</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(label) {</span><span class="s3">\n        </span><span class="s1">return { label };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CompletionItem.create = create;</span><span class="s3">\n</span><span class="s1">})(CompletionItem || (CompletionItem = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The CompletionList namespace provides functions to deal with</span><span class="s3">\n </span><span class="s1">* completion lists.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CompletionList;</span><span class="s3">\n</span><span class="s1">(function (CompletionList) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new completion list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param items The completion items.</span><span class="s3">\n     </span><span class="s1">* @param isIncomplete The list is not complete.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(items, isIncomplete) {</span><span class="s3">\n        </span><span class="s1">return { items: items ? items : [], isIncomplete: !!isIncomplete };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CompletionList.create = create;</span><span class="s3">\n</span><span class="s1">})(CompletionList || (CompletionList = {}));</span><span class="s3">\n</span><span class="s1">export var MarkedString;</span><span class="s3">\n</span><span class="s1">(function (MarkedString) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a marked string from plain text.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param plainText The plain text.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function fromPlainText(plainText) {</span><span class="s3">\n        </span><span class="s1">return plainText.replace(/[</span><span class="s3">\\\\</span><span class="s1">`*_{}[</span><span class="s3">\\</span><span class="s1">]()#+</span><span class="s3">\\</span><span class="s1">-.!]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MarkedString.fromPlainText = fromPlainText;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given value conforms to the {@link MarkedString} type.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.string(candidate) || (Is.objectLiteral(candidate) &amp;&amp; Is.string(candidate.language) &amp;&amp; Is.string(candidate.value));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">MarkedString.is = is;</span><span class="s3">\n</span><span class="s1">})(MarkedString || (MarkedString = {}));</span><span class="s3">\n</span><span class="s1">export var Hover;</span><span class="s3">\n</span><span class="s1">(function (Hover) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given value conforms to the {@link Hover} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return !!candidate &amp;&amp; Is.objectLiteral(candidate) &amp;&amp; (MarkupContent.is(candidate.contents) ||</span><span class="s3">\n            </span><span class="s1">MarkedString.is(candidate.contents) ||</span><span class="s3">\n            </span><span class="s1">Is.typedArray(candidate.contents, MarkedString.is)) &amp;&amp; (value.range === undefined || Range.is(value.range));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Hover.is = is;</span><span class="s3">\n</span><span class="s1">})(Hover || (Hover = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The ParameterInformation namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link ParameterInformation} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var ParameterInformation;</span><span class="s3">\n</span><span class="s1">(function (ParameterInformation) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new parameter information literal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param label A label string.</span><span class="s3">\n     </span><span class="s1">* @param documentation A doc string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(label, documentation) {</span><span class="s3">\n        </span><span class="s1">return documentation ? { label, documentation } : { label };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ParameterInformation.create = create;</span><span class="s3">\n</span><span class="s1">})(ParameterInformation || (ParameterInformation = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The SignatureInformation namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link SignatureInformation} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SignatureInformation;</span><span class="s3">\n</span><span class="s1">(function (SignatureInformation) {</span><span class="s3">\n    </span><span class="s1">function create(label, documentation, ...parameters) {</span><span class="s3">\n        </span><span class="s1">let result = { label };</span><span class="s3">\n        </span><span class="s1">if (Is.defined(documentation)) {</span><span class="s3">\n            </span><span class="s1">result.documentation = documentation;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Is.defined(parameters)) {</span><span class="s3">\n            </span><span class="s1">result.parameters = parameters;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">result.parameters = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SignatureInformation.create = create;</span><span class="s3">\n</span><span class="s1">})(SignatureInformation || (SignatureInformation = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A document highlight kind.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DocumentHighlightKind;</span><span class="s3">\n</span><span class="s1">(function (DocumentHighlightKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A textual occurrence.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentHighlightKind.Text = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Read-access of a symbol, like reading a variable.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentHighlightKind.Read = 2;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Write-access of a symbol, like writing to a variable.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentHighlightKind.Write = 3;</span><span class="s3">\n</span><span class="s1">})(DocumentHighlightKind || (DocumentHighlightKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* DocumentHighlight namespace to provide helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link DocumentHighlight} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DocumentHighlight;</span><span class="s3">\n</span><span class="s1">(function (DocumentHighlight) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a DocumentHighlight object.</span><span class="s3">\n     </span><span class="s1">* @param range The range the highlight applies to.</span><span class="s3">\n     </span><span class="s1">* @param kind The highlight kind</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, kind) {</span><span class="s3">\n        </span><span class="s1">let result = { range };</span><span class="s3">\n        </span><span class="s1">if (Is.number(kind)) {</span><span class="s3">\n            </span><span class="s1">result.kind = kind;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentHighlight.create = create;</span><span class="s3">\n</span><span class="s1">})(DocumentHighlight || (DocumentHighlight = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A symbol kind.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SymbolKind;</span><span class="s3">\n</span><span class="s1">(function (SymbolKind) {</span><span class="s3">\n    </span><span class="s1">SymbolKind.File = 1;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Module = 2;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Namespace = 3;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Package = 4;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Class = 5;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Method = 6;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Property = 7;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Field = 8;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Constructor = 9;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Enum = 10;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Interface = 11;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Function = 12;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Variable = 13;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Constant = 14;</span><span class="s3">\n    </span><span class="s1">SymbolKind.String = 15;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Number = 16;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Boolean = 17;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Array = 18;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Object = 19;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Key = 20;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Null = 21;</span><span class="s3">\n    </span><span class="s1">SymbolKind.EnumMember = 22;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Struct = 23;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Event = 24;</span><span class="s3">\n    </span><span class="s1">SymbolKind.Operator = 25;</span><span class="s3">\n    </span><span class="s1">SymbolKind.TypeParameter = 26;</span><span class="s3">\n</span><span class="s1">})(SymbolKind || (SymbolKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Symbol tags are extra annotations that tweak the rendering of a symbol.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SymbolTag;</span><span class="s3">\n</span><span class="s1">(function (SymbolTag) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Render a symbol as obsolete, usually using a strike-out.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">SymbolTag.Deprecated = 1;</span><span class="s3">\n</span><span class="s1">})(SymbolTag || (SymbolTag = {}));</span><span class="s3">\n</span><span class="s1">export var SymbolInformation;</span><span class="s3">\n</span><span class="s1">(function (SymbolInformation) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new symbol information literal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param name The name of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param kind The kind of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param range The range of the location of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param uri The resource of the location of symbol.</span><span class="s3">\n     </span><span class="s1">* @param containerName The name of the symbol containing the symbol.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(name, kind, range, uri, containerName) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">name,</span><span class="s3">\n            </span><span class="s1">kind,</span><span class="s3">\n            </span><span class="s1">location: { uri, range }</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (containerName) {</span><span class="s3">\n            </span><span class="s1">result.containerName = containerName;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SymbolInformation.create = create;</span><span class="s3">\n</span><span class="s1">})(SymbolInformation || (SymbolInformation = {}));</span><span class="s3">\n</span><span class="s1">export var WorkspaceSymbol;</span><span class="s3">\n</span><span class="s1">(function (WorkspaceSymbol) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new workspace symbol.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param name The name of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param kind The kind of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param uri The resource of the location of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param range An options range of the location.</span><span class="s3">\n     </span><span class="s1">* @returns A WorkspaceSymbol.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(name, kind, uri, range) {</span><span class="s3">\n        </span><span class="s1">return range !== undefined</span><span class="s3">\n            </span><span class="s1">? { name, kind, location: { uri, range } }</span><span class="s3">\n            </span><span class="s1">: { name, kind, location: { uri } };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">WorkspaceSymbol.create = create;</span><span class="s3">\n</span><span class="s1">})(WorkspaceSymbol || (WorkspaceSymbol = {}));</span><span class="s3">\n</span><span class="s1">export var DocumentSymbol;</span><span class="s3">\n</span><span class="s1">(function (DocumentSymbol) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new symbol information literal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param name The name of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param detail The detail of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param kind The kind of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param range The range of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param selectionRange The selectionRange of the symbol.</span><span class="s3">\n     </span><span class="s1">* @param children Children of the symbol.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(name, detail, kind, range, selectionRange, children) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">name,</span><span class="s3">\n            </span><span class="s1">detail,</span><span class="s3">\n            </span><span class="s1">kind,</span><span class="s3">\n            </span><span class="s1">range,</span><span class="s3">\n            </span><span class="s1">selectionRange</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (children !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.children = children;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentSymbol.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link DocumentSymbol} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Is.string(candidate.name) &amp;&amp; Is.number(candidate.kind) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Range.is(candidate.range) &amp;&amp; Range.is(candidate.selectionRange) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.detail === undefined || Is.string(candidate.detail)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.children === undefined || Array.isArray(candidate.children)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.tags === undefined || Array.isArray(candidate.tags));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentSymbol.is = is;</span><span class="s3">\n</span><span class="s1">})(DocumentSymbol || (DocumentSymbol = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of predefined code action kinds</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CodeActionKind;</span><span class="s3">\n</span><span class="s1">(function (CodeActionKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Empty kind.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.Empty = '';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for quickfix actions: 'quickfix'</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.QuickFix = 'quickfix';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for refactoring actions: 'refactor'</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.Refactor = 'refactor';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for refactoring extraction actions: 'refactor.extract'</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Example extract actions:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* - Extract method</span><span class="s3">\n     </span><span class="s1">* - Extract function</span><span class="s3">\n     </span><span class="s1">* - Extract variable</span><span class="s3">\n     </span><span class="s1">* - Extract interface from class</span><span class="s3">\n     </span><span class="s1">* - ...</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.RefactorExtract = 'refactor.extract';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for refactoring inline actions: 'refactor.inline'</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Example inline actions:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* - Inline function</span><span class="s3">\n     </span><span class="s1">* - Inline variable</span><span class="s3">\n     </span><span class="s1">* - Inline constant</span><span class="s3">\n     </span><span class="s1">* - ...</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.RefactorInline = 'refactor.inline';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for refactoring rewrite actions: 'refactor.rewrite'</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Example rewrite actions:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* - Convert JavaScript function to class</span><span class="s3">\n     </span><span class="s1">* - Add or remove parameter</span><span class="s3">\n     </span><span class="s1">* - Encapsulate field</span><span class="s3">\n     </span><span class="s1">* - Make method static</span><span class="s3">\n     </span><span class="s1">* - Move method to base class</span><span class="s3">\n     </span><span class="s1">* - ...</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.RefactorRewrite = 'refactor.rewrite';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for source actions: `source`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Source code actions apply to the entire file.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.Source = 'source';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for an organize imports source action: `source.organizeImports`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.SourceOrganizeImports = 'source.organizeImports';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base kind for auto-fix source actions: `source.fixAll`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Fix all actions automatically fix errors that have a clear fix that do not require user input.</span><span class="s3">\n     </span><span class="s1">* They should not suppress errors or perform unsafe fixes such as generating new types or classes.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @since 3.15.0</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionKind.SourceFixAll = 'source.fixAll';</span><span class="s3">\n</span><span class="s1">})(CodeActionKind || (CodeActionKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The reason why code actions were requested.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CodeActionTriggerKind;</span><span class="s3">\n</span><span class="s1">(function (CodeActionTriggerKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Code actions were explicitly requested by the user or by an extension.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionTriggerKind.Invoked = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Code actions were requested automatically.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This typically happens when current selection in a file changes, but can</span><span class="s3">\n     </span><span class="s1">* also be triggered when file content changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CodeActionTriggerKind.Automatic = 2;</span><span class="s3">\n</span><span class="s1">})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The CodeActionContext namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link CodeActionContext} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CodeActionContext;</span><span class="s3">\n</span><span class="s1">(function (CodeActionContext) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new CodeActionContext literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(diagnostics, only, triggerKind) {</span><span class="s3">\n        </span><span class="s1">let result = { diagnostics };</span><span class="s3">\n        </span><span class="s1">if (only !== undefined &amp;&amp; only !== null) {</span><span class="s3">\n            </span><span class="s1">result.only = only;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (triggerKind !== undefined &amp;&amp; triggerKind !== null) {</span><span class="s3">\n            </span><span class="s1">result.triggerKind = triggerKind;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeActionContext.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link CodeActionContext} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.typedArray(candidate.diagnostics, Diagnostic.is)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeActionContext.is = is;</span><span class="s3">\n</span><span class="s1">})(CodeActionContext || (CodeActionContext = {}));</span><span class="s3">\n</span><span class="s1">export var CodeAction;</span><span class="s3">\n</span><span class="s1">(function (CodeAction) {</span><span class="s3">\n    </span><span class="s1">function create(title, kindOrCommandOrEdit, kind) {</span><span class="s3">\n        </span><span class="s1">let result = { title };</span><span class="s3">\n        </span><span class="s1">let checkKind = true;</span><span class="s3">\n        </span><span class="s1">if (typeof kindOrCommandOrEdit === 'string') {</span><span class="s3">\n            </span><span class="s1">checkKind = false;</span><span class="s3">\n            </span><span class="s1">result.kind = kindOrCommandOrEdit;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (Command.is(kindOrCommandOrEdit)) {</span><span class="s3">\n            </span><span class="s1">result.command = kindOrCommandOrEdit;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">result.edit = kindOrCommandOrEdit;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (checkKind &amp;&amp; kind !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.kind = kind;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeAction.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; Is.string(candidate.title) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.kind === undefined || Is.string(candidate.kind)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.edit !== undefined || candidate.command !== undefined) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.command === undefined || Command.is(candidate.command)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeAction.is = is;</span><span class="s3">\n</span><span class="s1">})(CodeAction || (CodeAction = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The CodeLens namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link CodeLens} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var CodeLens;</span><span class="s3">\n</span><span class="s1">(function (CodeLens) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new CodeLens literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, data) {</span><span class="s3">\n        </span><span class="s1">let result = { range };</span><span class="s3">\n        </span><span class="s1">if (Is.defined(data)) {</span><span class="s3">\n            </span><span class="s1">result.data = data;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeLens.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link CodeLens} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Range.is(candidate.range) &amp;&amp; (Is.undefined(candidate.command) || Command.is(candidate.command));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CodeLens.is = is;</span><span class="s3">\n</span><span class="s1">})(CodeLens || (CodeLens = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The FormattingOptions namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link FormattingOptions} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var FormattingOptions;</span><span class="s3">\n</span><span class="s1">(function (FormattingOptions) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new FormattingOptions literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(tabSize, insertSpaces) {</span><span class="s3">\n        </span><span class="s1">return { tabSize, insertSpaces };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">FormattingOptions.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link FormattingOptions} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.uinteger(candidate.tabSize) &amp;&amp; Is.boolean(candidate.insertSpaces);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">FormattingOptions.is = is;</span><span class="s3">\n</span><span class="s1">})(FormattingOptions || (FormattingOptions = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The DocumentLink namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link DocumentLink} literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DocumentLink;</span><span class="s3">\n</span><span class="s1">(function (DocumentLink) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new DocumentLink literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, target, data) {</span><span class="s3">\n        </span><span class="s1">return { range, target, data };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentLink.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link DocumentLink} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Range.is(candidate.range) &amp;&amp; (Is.undefined(candidate.target) || Is.string(candidate.target));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DocumentLink.is = is;</span><span class="s3">\n</span><span class="s1">})(DocumentLink || (DocumentLink = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The SelectionRange namespace provides helper function to work with</span><span class="s3">\n </span><span class="s1">* SelectionRange literals.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SelectionRange;</span><span class="s3">\n</span><span class="s1">(function (SelectionRange) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new SelectionRange</span><span class="s3">\n     </span><span class="s1">* @param range the range.</span><span class="s3">\n     </span><span class="s1">* @param parent an optional parent.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, parent) {</span><span class="s3">\n        </span><span class="s1">return { range, parent };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SelectionRange.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Range.is(candidate.range) &amp;&amp; (candidate.parent === undefined || SelectionRange.is(candidate.parent));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SelectionRange.is = is;</span><span class="s3">\n</span><span class="s1">})(SelectionRange || (SelectionRange = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of predefined token types. This set is not fixed</span><span class="s3">\n </span><span class="s1">* an clients can specify additional token types via the</span><span class="s3">\n </span><span class="s1">* corresponding client capabilities.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SemanticTokenTypes;</span><span class="s3">\n</span><span class="s1">(function (SemanticTokenTypes) {</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Represents a generic type. Acts as a fallback for types which can't be mapped to</span><span class="s3">\n     </span><span class="s1">* a specific type like class or enum.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">struct</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">struct</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">typeParameter</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">typeParameter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">parameter</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">parameter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">enumMember</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">enumMember</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">event</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">event</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">method</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">macro</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">modifier</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">modifier</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @since 3.17.0</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">SemanticTokenTypes[</span><span class="s3">\&quot;</span><span class="s1">decorator</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">decorator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(SemanticTokenTypes || (SemanticTokenTypes = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of predefined token modifiers. This set is not fixed</span><span class="s3">\n </span><span class="s1">* an clients can specify additional token types via the</span><span class="s3">\n </span><span class="s1">* corresponding client capabilities.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SemanticTokenModifiers;</span><span class="s3">\n</span><span class="s1">(function (SemanticTokenModifiers) {</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">declaration</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">definition</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">readonly</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">readonly</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">deprecated</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">deprecated</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">abstract</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">abstract</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">modification</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">modification</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">documentation</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">documentation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">SemanticTokenModifiers[</span><span class="s3">\&quot;</span><span class="s1">defaultLibrary</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">defaultLibrary</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @since 3.16.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var SemanticTokens;</span><span class="s3">\n</span><span class="s1">(function (SemanticTokens) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; (candidate.resultId === undefined || typeof candidate.resultId === 'string') &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Array.isArray(candidate.data) &amp;&amp; (candidate.data.length === 0 || typeof candidate.data[0] === 'number');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SemanticTokens.is = is;</span><span class="s3">\n</span><span class="s1">})(SemanticTokens || (SemanticTokens = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The InlineValueText namespace provides functions to deal with InlineValueTexts.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlineValueText;</span><span class="s3">\n</span><span class="s1">(function (InlineValueText) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new InlineValueText literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, text) {</span><span class="s3">\n        </span><span class="s1">return { range, text };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueText.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate !== undefined &amp;&amp; candidate !== null &amp;&amp; Range.is(candidate.range) &amp;&amp; Is.string(candidate.text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueText.is = is;</span><span class="s3">\n</span><span class="s1">})(InlineValueText || (InlineValueText = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlineValueVariableLookup;</span><span class="s3">\n</span><span class="s1">(function (InlineValueVariableLookup) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new InlineValueText literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, variableName, caseSensitiveLookup) {</span><span class="s3">\n        </span><span class="s1">return { range, variableName, caseSensitiveLookup };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueVariableLookup.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate !== undefined &amp;&amp; candidate !== null &amp;&amp; Range.is(candidate.range) &amp;&amp; Is.boolean(candidate.caseSensitiveLookup)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.string(candidate.variableName) || candidate.variableName === undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueVariableLookup.is = is;</span><span class="s3">\n</span><span class="s1">})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlineValueEvaluatableExpression;</span><span class="s3">\n</span><span class="s1">(function (InlineValueEvaluatableExpression) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new InlineValueEvaluatableExpression literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(range, expression) {</span><span class="s3">\n        </span><span class="s1">return { range, expression };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueEvaluatableExpression.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate !== undefined &amp;&amp; candidate !== null &amp;&amp; Range.is(candidate.range)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.string(candidate.expression) || candidate.expression === undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueEvaluatableExpression.is = is;</span><span class="s3">\n</span><span class="s1">})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The InlineValueContext namespace provides helper functions to work with</span><span class="s3">\n </span><span class="s1">* {@link InlineValueContext} literals.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlineValueContext;</span><span class="s3">\n</span><span class="s1">(function (InlineValueContext) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new InlineValueContext literal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(frameId, stoppedLocation) {</span><span class="s3">\n        </span><span class="s1">return { frameId, stoppedLocation };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueContext.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link InlineValueContext} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Range.is(value.stoppedLocation);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineValueContext.is = is;</span><span class="s3">\n</span><span class="s1">})(InlineValueContext || (InlineValueContext = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Inlay hint kinds.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.17.0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlayHintKind;</span><span class="s3">\n</span><span class="s1">(function (InlayHintKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An inlay hint that for a type annotation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InlayHintKind.Type = 1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An inlay hint that is for a parameter.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InlayHintKind.Parameter = 2;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">return value === 1 || value === 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlayHintKind.is = is;</span><span class="s3">\n</span><span class="s1">})(InlayHintKind || (InlayHintKind = {}));</span><span class="s3">\n</span><span class="s1">export var InlayHintLabelPart;</span><span class="s3">\n</span><span class="s1">(function (InlayHintLabelPart) {</span><span class="s3">\n    </span><span class="s1">function create(value) {</span><span class="s3">\n        </span><span class="s1">return { value };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlayHintLabelPart.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.location === undefined || Location.is(candidate.location))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.command === undefined || Command.is(candidate.command));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlayHintLabelPart.is = is;</span><span class="s3">\n</span><span class="s1">})(InlayHintLabelPart || (InlayHintLabelPart = {}));</span><span class="s3">\n</span><span class="s1">export var InlayHint;</span><span class="s3">\n</span><span class="s1">(function (InlayHint) {</span><span class="s3">\n    </span><span class="s1">function create(position, label, kind) {</span><span class="s3">\n        </span><span class="s1">const result = { position, label };</span><span class="s3">\n        </span><span class="s1">if (kind !== undefined) {</span><span class="s3">\n            </span><span class="s1">result.kind = kind;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlayHint.create = create;</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; Position.is(candidate.position)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.kind === undefined || InlayHintKind.is(candidate.kind))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))</span><span class="s3">\n            </span><span class="s1">&amp;&amp; (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlayHint.is = is;</span><span class="s3">\n</span><span class="s1">})(InlayHint || (InlayHint = {}));</span><span class="s3">\n</span><span class="s1">export var StringValue;</span><span class="s3">\n</span><span class="s1">(function (StringValue) {</span><span class="s3">\n    </span><span class="s1">function createSnippet(value) {</span><span class="s3">\n        </span><span class="s1">return { kind: 'snippet', value };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">StringValue.createSnippet = createSnippet;</span><span class="s3">\n</span><span class="s1">})(StringValue || (StringValue = {}));</span><span class="s3">\n</span><span class="s1">export var InlineCompletionItem;</span><span class="s3">\n</span><span class="s1">(function (InlineCompletionItem) {</span><span class="s3">\n    </span><span class="s1">function create(insertText, filterText, range, command) {</span><span class="s3">\n        </span><span class="s1">return { insertText, filterText, range, command };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineCompletionItem.create = create;</span><span class="s3">\n</span><span class="s1">})(InlineCompletionItem || (InlineCompletionItem = {}));</span><span class="s3">\n</span><span class="s1">export var InlineCompletionList;</span><span class="s3">\n</span><span class="s1">(function (InlineCompletionList) {</span><span class="s3">\n    </span><span class="s1">function create(items) {</span><span class="s3">\n        </span><span class="s1">return { items };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineCompletionList.create = create;</span><span class="s3">\n</span><span class="s1">})(InlineCompletionList || (InlineCompletionList = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @since 3.18.0</span><span class="s3">\n </span><span class="s1">* @proposed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var InlineCompletionTriggerKind;</span><span class="s3">\n</span><span class="s1">(function (InlineCompletionTriggerKind) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Completion was triggered explicitly by a user gesture.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InlineCompletionTriggerKind.Invoked = 0;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Completion was triggered automatically while editing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">InlineCompletionTriggerKind.Automatic = 1;</span><span class="s3">\n</span><span class="s1">})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));</span><span class="s3">\n</span><span class="s1">export var SelectedCompletionInfo;</span><span class="s3">\n</span><span class="s1">(function (SelectedCompletionInfo) {</span><span class="s3">\n    </span><span class="s1">function create(range, text) {</span><span class="s3">\n        </span><span class="s1">return { range, text };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">SelectedCompletionInfo.create = create;</span><span class="s3">\n</span><span class="s1">})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));</span><span class="s3">\n</span><span class="s1">export var InlineCompletionContext;</span><span class="s3">\n</span><span class="s1">(function (InlineCompletionContext) {</span><span class="s3">\n    </span><span class="s1">function create(triggerKind, selectedCompletionInfo) {</span><span class="s3">\n        </span><span class="s1">return { triggerKind, selectedCompletionInfo };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">InlineCompletionContext.create = create;</span><span class="s3">\n</span><span class="s1">})(InlineCompletionContext || (InlineCompletionContext = {}));</span><span class="s3">\n</span><span class="s1">export var WorkspaceFolder;</span><span class="s3">\n</span><span class="s1">(function (WorkspaceFolder) {</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.objectLiteral(candidate) &amp;&amp; URI.is(candidate.uri) &amp;&amp; Is.string(candidate.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">WorkspaceFolder.is = is;</span><span class="s3">\n</span><span class="s1">})(WorkspaceFolder || (WorkspaceFolder = {}));</span><span class="s3">\n</span><span class="s1">export const EOL = ['</span><span class="s3">\\</span><span class="s1">n', '</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n', '</span><span class="s3">\\</span><span class="s1">r'];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use the text document from the new vscode-languageserver-textdocument package.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TextDocument;</span><span class="s3">\n</span><span class="s1">(function (TextDocument) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new ITextDocument literal from the given uri and content.</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">* @param languageId The document's language Id.</span><span class="s3">\n     </span><span class="s1">* @param version The document's version.</span><span class="s3">\n     </span><span class="s1">* @param content The document's content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, languageId, version, content) {</span><span class="s3">\n        </span><span class="s1">return new FullTextDocument(uri, languageId, version, content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether the given literal conforms to the {@link ITextDocument} interface.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">let candidate = value;</span><span class="s3">\n        </span><span class="s1">return Is.defined(candidate) &amp;&amp; Is.string(candidate.uri) &amp;&amp; (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) &amp;&amp; Is.uinteger(candidate.lineCount)</span><span class="s3">\n            </span><span class="s1">&amp;&amp; Is.func(candidate.getText) &amp;&amp; Is.func(candidate.positionAt) &amp;&amp; Is.func(candidate.offsetAt) ? true : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.is = is;</span><span class="s3">\n    </span><span class="s1">function applyEdits(document, edits) {</span><span class="s3">\n        </span><span class="s1">let text = document.getText();</span><span class="s3">\n        </span><span class="s1">let sortedEdits = mergeSort(edits, (a, b) =&gt; {</span><span class="s3">\n            </span><span class="s1">let diff = a.range.start.line - b.range.start.line;</span><span class="s3">\n            </span><span class="s1">if (diff === 0) {</span><span class="s3">\n                </span><span class="s1">return a.range.start.character - b.range.start.character;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return diff;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let lastModifiedOffset = text.length;</span><span class="s3">\n        </span><span class="s1">for (let i = sortedEdits.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">let e = sortedEdits[i];</span><span class="s3">\n            </span><span class="s1">let startOffset = document.offsetAt(e.range.start);</span><span class="s3">\n            </span><span class="s1">let endOffset = document.offsetAt(e.range.end);</span><span class="s3">\n            </span><span class="s1">if (endOffset &lt;= lastModifiedOffset) {</span><span class="s3">\n                </span><span class="s1">text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw new Error('Overlapping edit');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">lastModifiedOffset = startOffset;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.applyEdits = applyEdits;</span><span class="s3">\n    </span><span class="s1">function mergeSort(data, compare) {</span><span class="s3">\n        </span><span class="s1">if (data.length &lt;= 1) {</span><span class="s3">\n            </span><span class="s1">// sorted</span><span class="s3">\n            </span><span class="s1">return data;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const p = (data.length / 2) | 0;</span><span class="s3">\n        </span><span class="s1">const left = data.slice(0, p);</span><span class="s3">\n        </span><span class="s1">const right = data.slice(p);</span><span class="s3">\n        </span><span class="s1">mergeSort(left, compare);</span><span class="s3">\n        </span><span class="s1">mergeSort(right, compare);</span><span class="s3">\n        </span><span class="s1">let leftIdx = 0;</span><span class="s3">\n        </span><span class="s1">let rightIdx = 0;</span><span class="s3">\n        </span><span class="s1">let i = 0;</span><span class="s3">\n        </span><span class="s1">while (leftIdx &lt; left.length &amp;&amp; rightIdx &lt; right.length) {</span><span class="s3">\n            </span><span class="s1">let ret = compare(left[leftIdx], right[rightIdx]);</span><span class="s3">\n            </span><span class="s1">if (ret &lt;= 0) {</span><span class="s3">\n                </span><span class="s1">// smaller_equal -&gt; take left to preserve order</span><span class="s3">\n                </span><span class="s1">data[i++] = left[leftIdx++];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// greater -&gt; take right</span><span class="s3">\n                </span><span class="s1">data[i++] = right[rightIdx++];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (leftIdx &lt; left.length) {</span><span class="s3">\n            </span><span class="s1">data[i++] = left[leftIdx++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (rightIdx &lt; right.length) {</span><span class="s3">\n            </span><span class="s1">data[i++] = right[rightIdx++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})(TextDocument || (TextDocument = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @deprecated Use the text document from the new vscode-languageserver-textdocument package.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class FullTextDocument {</span><span class="s3">\n    </span><span class="s1">constructor(uri, languageId, version, content) {</span><span class="s3">\n        </span><span class="s1">this._uri = uri;</span><span class="s3">\n        </span><span class="s1">this._languageId = languageId;</span><span class="s3">\n        </span><span class="s1">this._version = version;</span><span class="s3">\n        </span><span class="s1">this._content = content;</span><span class="s3">\n        </span><span class="s1">this._lineOffsets = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get uri() {</span><span class="s3">\n        </span><span class="s1">return this._uri;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get languageId() {</span><span class="s3">\n        </span><span class="s1">return this._languageId;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get version() {</span><span class="s3">\n        </span><span class="s1">return this._version;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getText(range) {</span><span class="s3">\n        </span><span class="s1">if (range) {</span><span class="s3">\n            </span><span class="s1">let start = this.offsetAt(range.start);</span><span class="s3">\n            </span><span class="s1">let end = this.offsetAt(range.end);</span><span class="s3">\n            </span><span class="s1">return this._content.substring(start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(event, version) {</span><span class="s3">\n        </span><span class="s1">this._content = event.text;</span><span class="s3">\n        </span><span class="s1">this._version = version;</span><span class="s3">\n        </span><span class="s1">this._lineOffsets = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLineOffsets() {</span><span class="s3">\n        </span><span class="s1">if (this._lineOffsets === undefined) {</span><span class="s3">\n            </span><span class="s1">let lineOffsets = [];</span><span class="s3">\n            </span><span class="s1">let text = this._content;</span><span class="s3">\n            </span><span class="s1">let isLineStart = true;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; text.length; i++) {</span><span class="s3">\n                </span><span class="s1">if (isLineStart) {</span><span class="s3">\n                    </span><span class="s1">lineOffsets.push(i);</span><span class="s3">\n                    </span><span class="s1">isLineStart = false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let ch = text.charAt(i);</span><span class="s3">\n                </span><span class="s1">isLineStart = (ch === '</span><span class="s3">\\</span><span class="s1">r' || ch === '</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n                </span><span class="s1">if (ch === '</span><span class="s3">\\</span><span class="s1">r' &amp;&amp; i + 1 &lt; text.length &amp;&amp; text.charAt(i + 1) === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (isLineStart &amp;&amp; text.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">lineOffsets.push(text.length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._lineOffsets = lineOffsets;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._lineOffsets;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">positionAt(offset) {</span><span class="s3">\n        </span><span class="s1">offset = Math.max(Math.min(offset, this._content.length), 0);</span><span class="s3">\n        </span><span class="s1">let lineOffsets = this.getLineOffsets();</span><span class="s3">\n        </span><span class="s1">let low = 0, high = lineOffsets.length;</span><span class="s3">\n        </span><span class="s1">if (high === 0) {</span><span class="s3">\n            </span><span class="s1">return Position.create(0, offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (low &lt; high) {</span><span class="s3">\n            </span><span class="s1">let mid = Math.floor((low + high) / 2);</span><span class="s3">\n            </span><span class="s1">if (lineOffsets[mid] &gt; offset) {</span><span class="s3">\n                </span><span class="s1">high = mid;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">low = mid + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// low is the least x for which the line offset is larger than the current offset</span><span class="s3">\n        </span><span class="s1">// or array.length if no line offset is larger than the current offset</span><span class="s3">\n        </span><span class="s1">let line = low - 1;</span><span class="s3">\n        </span><span class="s1">return Position.create(line, offset - lineOffsets[line]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">offsetAt(position) {</span><span class="s3">\n        </span><span class="s1">let lineOffsets = this.getLineOffsets();</span><span class="s3">\n        </span><span class="s1">if (position.line &gt;= lineOffsets.length) {</span><span class="s3">\n            </span><span class="s1">return this._content.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (position.line &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let lineOffset = lineOffsets[position.line];</span><span class="s3">\n        </span><span class="s1">let nextLineOffset = (position.line + 1 &lt; lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;</span><span class="s3">\n        </span><span class="s1">return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineCount() {</span><span class="s3">\n        </span><span class="s1">return this.getLineOffsets().length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var Is;</span><span class="s3">\n</span><span class="s1">(function (Is) {</span><span class="s3">\n    </span><span class="s1">const toString = Object.prototype.toString;</span><span class="s3">\n    </span><span class="s1">function defined(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value !== 'undefined';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.defined = defined;</span><span class="s3">\n    </span><span class="s1">function undefined(value) {</span><span class="s3">\n        </span><span class="s1">return typeof value === 'undefined';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.undefined = undefined;</span><span class="s3">\n    </span><span class="s1">function boolean(value) {</span><span class="s3">\n        </span><span class="s1">return value === true || value === false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.boolean = boolean;</span><span class="s3">\n    </span><span class="s1">function string(value) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object String]';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.string = string;</span><span class="s3">\n    </span><span class="s1">function number(value) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object Number]';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.number = number;</span><span class="s3">\n    </span><span class="s1">function numberRange(value, min, max) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object Number]' &amp;&amp; min &lt;= value &amp;&amp; value &lt;= max;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.numberRange = numberRange;</span><span class="s3">\n    </span><span class="s1">function integer(value) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object Number]' &amp;&amp; -2147483648 &lt;= value &amp;&amp; value &lt;= 2147483647;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.integer = integer;</span><span class="s3">\n    </span><span class="s1">function uinteger(value) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object Number]' &amp;&amp; 0 &lt;= value &amp;&amp; value &lt;= 2147483647;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.uinteger = uinteger;</span><span class="s3">\n    </span><span class="s1">function func(value) {</span><span class="s3">\n        </span><span class="s1">return toString.call(value) === '[object Function]';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.func = func;</span><span class="s3">\n    </span><span class="s1">function objectLiteral(value) {</span><span class="s3">\n        </span><span class="s1">// Strictly speaking class instances pass this check as well. Since the LSP</span><span class="s3">\n        </span><span class="s1">// doesn't use classes we ignore this for now. If we do we need to add something</span><span class="s3">\n        </span><span class="s1">// like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`</span><span class="s3">\n        </span><span class="s1">return value !== null &amp;&amp; typeof value === 'object';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.objectLiteral = objectLiteral;</span><span class="s3">\n    </span><span class="s1">function typedArray(value, check) {</span><span class="s3">\n        </span><span class="s1">return Array.isArray(value) &amp;&amp; value.every(check);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Is.typedArray = typedArray;</span><span class="s3">\n</span><span class="s1">})(Is || (Is = {}));</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Position } from 'vscode-languageserver-types';</span><span class="s3">\n</span><span class="s1">import { tokenToRange } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">export class CstNodeBuilder {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.nodeStack = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get current() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null &amp;&amp; _a !== void 0 ? _a : this.rootNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildRootNode(input) {</span><span class="s3">\n        </span><span class="s1">this.rootNode = new RootCstNodeImpl(input);</span><span class="s3">\n        </span><span class="s1">this.rootNode.root = this.rootNode;</span><span class="s3">\n        </span><span class="s1">this.nodeStack = [this.rootNode];</span><span class="s3">\n        </span><span class="s1">return this.rootNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildCompositeNode(feature) {</span><span class="s3">\n        </span><span class="s1">const compositeNode = new CompositeCstNodeImpl();</span><span class="s3">\n        </span><span class="s1">compositeNode.grammarSource = feature;</span><span class="s3">\n        </span><span class="s1">compositeNode.root = this.rootNode;</span><span class="s3">\n        </span><span class="s1">this.current.content.push(compositeNode);</span><span class="s3">\n        </span><span class="s1">this.nodeStack.push(compositeNode);</span><span class="s3">\n        </span><span class="s1">return compositeNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildLeafNode(token, feature) {</span><span class="s3">\n        </span><span class="s1">const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, !feature);</span><span class="s3">\n        </span><span class="s1">leafNode.grammarSource = feature;</span><span class="s3">\n        </span><span class="s1">leafNode.root = this.rootNode;</span><span class="s3">\n        </span><span class="s1">this.current.content.push(leafNode);</span><span class="s3">\n        </span><span class="s1">return leafNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeNode(node) {</span><span class="s3">\n        </span><span class="s1">const parent = node.container;</span><span class="s3">\n        </span><span class="s1">if (parent) {</span><span class="s3">\n            </span><span class="s1">const index = parent.content.indexOf(node);</span><span class="s3">\n            </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">parent.content.splice(index, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addHiddenNodes(tokens) {</span><span class="s3">\n        </span><span class="s1">const nodes = [];</span><span class="s3">\n        </span><span class="s1">for (const token of tokens) {</span><span class="s3">\n            </span><span class="s1">const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);</span><span class="s3">\n            </span><span class="s1">leafNode.root = this.rootNode;</span><span class="s3">\n            </span><span class="s1">nodes.push(leafNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let current = this.current;</span><span class="s3">\n        </span><span class="s1">let added = false;</span><span class="s3">\n        </span><span class="s1">// If we are within a composite node, we add the hidden nodes to the content</span><span class="s3">\n        </span><span class="s1">if (current.content.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">current.content.push(...nodes);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise we are at a newly created node</span><span class="s3">\n        </span><span class="s1">// Instead of adding the hidden nodes here, we search for the first parent node with content</span><span class="s3">\n        </span><span class="s1">while (current.container) {</span><span class="s3">\n            </span><span class="s1">const index = current.container.content.indexOf(current);</span><span class="s3">\n            </span><span class="s1">if (index &gt; 0) {</span><span class="s3">\n                </span><span class="s1">// Add the hidden nodes before the current node</span><span class="s3">\n                </span><span class="s1">current.container.content.splice(index, 0, ...nodes);</span><span class="s3">\n                </span><span class="s1">added = true;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">current = current.container;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If we arrive at the root node, we add the hidden nodes at the beginning</span><span class="s3">\n        </span><span class="s1">// This is the case if the hidden nodes are the first nodes in the tree</span><span class="s3">\n        </span><span class="s1">if (!added) {</span><span class="s3">\n            </span><span class="s1">this.rootNode.content.unshift(...nodes);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">construct(item) {</span><span class="s3">\n        </span><span class="s1">const current = this.current;</span><span class="s3">\n        </span><span class="s1">// The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)</span><span class="s3">\n        </span><span class="s1">// Only if the $type is a string, we actually assign the element</span><span class="s3">\n        </span><span class="s1">if (typeof item.$type === 'string') {</span><span class="s3">\n            </span><span class="s1">this.current.astNode = item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">item.$cstNode = current;</span><span class="s3">\n        </span><span class="s1">const node = this.nodeStack.pop();</span><span class="s3">\n        </span><span class="s1">// Empty composite nodes are not valid</span><span class="s3">\n        </span><span class="s1">// Simply remove the node from the tree</span><span class="s3">\n        </span><span class="s1">if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {</span><span class="s3">\n            </span><span class="s1">this.removeNode(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class AbstractCstNode {</span><span class="s3">\n    </span><span class="s1">/** @deprecated use `container` instead. */</span><span class="s3">\n    </span><span class="s1">get parent() {</span><span class="s3">\n        </span><span class="s1">return this.container;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** @deprecated use `grammarSource` instead. */</span><span class="s3">\n    </span><span class="s1">get feature() {</span><span class="s3">\n        </span><span class="s1">return this.grammarSource;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get hidden() {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get astNode() {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;</span><span class="s3">\n        </span><span class="s1">if (!node) {</span><span class="s3">\n            </span><span class="s1">throw new Error('This node has no associated AST element');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set astNode(value) {</span><span class="s3">\n        </span><span class="s1">this._astNode = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** @deprecated use `astNode` instead. */</span><span class="s3">\n    </span><span class="s1">get element() {</span><span class="s3">\n        </span><span class="s1">return this.astNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get text() {</span><span class="s3">\n        </span><span class="s1">return this.root.fullText.substring(this.offset, this.end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class LeafCstNodeImpl extends AbstractCstNode {</span><span class="s3">\n    </span><span class="s1">get offset() {</span><span class="s3">\n        </span><span class="s1">return this._offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() {</span><span class="s3">\n        </span><span class="s1">return this._length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get end() {</span><span class="s3">\n        </span><span class="s1">return this._offset + this._length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get hidden() {</span><span class="s3">\n        </span><span class="s1">return this._hidden;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get tokenType() {</span><span class="s3">\n        </span><span class="s1">return this._tokenType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get range() {</span><span class="s3">\n        </span><span class="s1">return this._range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(offset, length, range, tokenType, hidden = false) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._hidden = hidden;</span><span class="s3">\n        </span><span class="s1">this._offset = offset;</span><span class="s3">\n        </span><span class="s1">this._tokenType = tokenType;</span><span class="s3">\n        </span><span class="s1">this._length = length;</span><span class="s3">\n        </span><span class="s1">this._range = range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class CompositeCstNodeImpl extends AbstractCstNode {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.content = new CstNodeContainer(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** @deprecated use `content` instead. */</span><span class="s3">\n    </span><span class="s1">get children() {</span><span class="s3">\n        </span><span class="s1">return this.content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get offset() {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null &amp;&amp; _b !== void 0 ? _b : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() {</span><span class="s3">\n        </span><span class="s1">return this.end - this.offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get end() {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null &amp;&amp; _b !== void 0 ? _b : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get range() {</span><span class="s3">\n        </span><span class="s1">const firstNode = this.firstNonHiddenNode;</span><span class="s3">\n        </span><span class="s1">const lastNode = this.lastNonHiddenNode;</span><span class="s3">\n        </span><span class="s1">if (firstNode &amp;&amp; lastNode) {</span><span class="s3">\n            </span><span class="s1">if (this._rangeCache === undefined) {</span><span class="s3">\n                </span><span class="s1">const { range: firstRange } = firstNode;</span><span class="s3">\n                </span><span class="s1">const { range: lastRange } = lastNode;</span><span class="s3">\n                </span><span class="s1">this._rangeCache = { start: firstRange.start, end: lastRange.end.line &lt; firstRange.start.line ? firstRange.start : lastRange.end };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this._rangeCache;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return { start: Position.create(0, 0), end: Position.create(0, 0) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get firstNonHiddenNode() {</span><span class="s3">\n        </span><span class="s1">for (const child of this.content) {</span><span class="s3">\n            </span><span class="s1">if (!child.hidden) {</span><span class="s3">\n                </span><span class="s1">return child;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.content[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lastNonHiddenNode() {</span><span class="s3">\n        </span><span class="s1">for (let i = this.content.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">const child = this.content[i];</span><span class="s3">\n            </span><span class="s1">if (!child.hidden) {</span><span class="s3">\n                </span><span class="s1">return child;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.content[this.content.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CstNodeContainer extends Array {</span><span class="s3">\n    </span><span class="s1">constructor(parent) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.parent = parent;</span><span class="s3">\n        </span><span class="s1">Object.setPrototypeOf(this, CstNodeContainer.prototype);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">push(...items) {</span><span class="s3">\n        </span><span class="s1">this.addParents(items);</span><span class="s3">\n        </span><span class="s1">return super.push(...items);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unshift(...items) {</span><span class="s3">\n        </span><span class="s1">this.addParents(items);</span><span class="s3">\n        </span><span class="s1">return super.unshift(...items);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">splice(start, count, ...items) {</span><span class="s3">\n        </span><span class="s1">this.addParents(items);</span><span class="s3">\n        </span><span class="s1">return super.splice(start, count, ...items);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addParents(items) {</span><span class="s3">\n        </span><span class="s1">for (const item of items) {</span><span class="s3">\n            </span><span class="s1">item.container = this.parent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class RootCstNodeImpl extends CompositeCstNodeImpl {</span><span class="s3">\n    </span><span class="s1">get text() {</span><span class="s3">\n        </span><span class="s1">return this._text.substring(this.offset, this.end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get fullText() {</span><span class="s3">\n        </span><span class="s1">return this._text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(input) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._text = '';</span><span class="s3">\n        </span><span class="s1">this._text = input !== null &amp;&amp; input !== void 0 ? input : '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=cst-node-builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';</span><span class="s3">\n</span><span class="s1">import { LLStarLookaheadStrategy } from 'chevrotain-allstar';</span><span class="s3">\n</span><span class="s1">import { isAssignment, isCrossReference, isKeyword } from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { getExplicitRuleType, isDataTypeRule } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">import { assignMandatoryProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { CstNodeBuilder } from './cst-node-builder.js';</span><span class="s3">\n</span><span class="s1">export const DatatypeSymbol = Symbol('Datatype');</span><span class="s3">\n</span><span class="s1">function isDataTypeNode(node) {</span><span class="s3">\n    </span><span class="s1">return node.$type === DatatypeSymbol;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const ruleSuffix = '</span><span class="s3">\\</span><span class="s1">u200B';</span><span class="s3">\n</span><span class="s1">const withRuleSuffix = (name) =&gt; name.endsWith(ruleSuffix) ? name : name + ruleSuffix;</span><span class="s3">\n</span><span class="s1">export class AbstractLangiumParser {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this._unorderedGroups = new Map();</span><span class="s3">\n        </span><span class="s1">this.allRules = new Map();</span><span class="s3">\n        </span><span class="s1">this.lexer = services.parser.Lexer;</span><span class="s3">\n        </span><span class="s1">const tokens = this.lexer.definition;</span><span class="s3">\n        </span><span class="s1">const production = services.LanguageMetaData.mode === 'production';</span><span class="s3">\n        </span><span class="s1">this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">alternatives(idx, choices) {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapOr(idx, choices);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">optional(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapOption(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">many(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapMany(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">atLeastOne(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapAtLeastOne(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getRule(name) {</span><span class="s3">\n        </span><span class="s1">return this.allRules.get(name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isRecording() {</span><span class="s3">\n        </span><span class="s1">return this.wrapper.IS_RECORDING;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get unorderedGroups() {</span><span class="s3">\n        </span><span class="s1">return this._unorderedGroups;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getRuleStack() {</span><span class="s3">\n        </span><span class="s1">return this.wrapper.RULE_STACK;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finalize() {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapSelfAnalysis();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class LangiumParser extends AbstractLangiumParser {</span><span class="s3">\n    </span><span class="s1">get current() {</span><span class="s3">\n        </span><span class="s1">return this.stack[this.stack.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">super(services);</span><span class="s3">\n        </span><span class="s1">this.nodeBuilder = new CstNodeBuilder();</span><span class="s3">\n        </span><span class="s1">this.stack = [];</span><span class="s3">\n        </span><span class="s1">this.assignmentMap = new Map();</span><span class="s3">\n        </span><span class="s1">this.linker = services.references.Linker;</span><span class="s3">\n        </span><span class="s1">this.converter = services.parser.ValueConverter;</span><span class="s3">\n        </span><span class="s1">this.astReflection = services.shared.AstReflection;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rule(rule, impl) {</span><span class="s3">\n        </span><span class="s1">const type = this.computeRuleType(rule);</span><span class="s3">\n        </span><span class="s1">const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));</span><span class="s3">\n        </span><span class="s1">this.allRules.set(rule.name, ruleMethod);</span><span class="s3">\n        </span><span class="s1">if (rule.entry) {</span><span class="s3">\n            </span><span class="s1">this.mainRule = ruleMethod;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ruleMethod;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeRuleType(rule) {</span><span class="s3">\n        </span><span class="s1">if (rule.fragment) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isDataTypeRule(rule)) {</span><span class="s3">\n            </span><span class="s1">return DatatypeSymbol;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const explicit = getExplicitRuleType(rule);</span><span class="s3">\n            </span><span class="s1">return explicit !== null &amp;&amp; explicit !== void 0 ? explicit : rule.name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse(input, options = {}) {</span><span class="s3">\n        </span><span class="s1">this.nodeBuilder.buildRootNode(input);</span><span class="s3">\n        </span><span class="s1">const lexerResult = this.lexerResult = this.lexer.tokenize(input);</span><span class="s3">\n        </span><span class="s1">this.wrapper.input = lexerResult.tokens;</span><span class="s3">\n        </span><span class="s1">const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;</span><span class="s3">\n        </span><span class="s1">if (!ruleMethod) {</span><span class="s3">\n            </span><span class="s1">throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const result = ruleMethod.call(this.wrapper, {});</span><span class="s3">\n        </span><span class="s1">this.nodeBuilder.addHiddenNodes(lexerResult.hidden);</span><span class="s3">\n        </span><span class="s1">this.unorderedGroups.clear();</span><span class="s3">\n        </span><span class="s1">this.lexerResult = undefined;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">value: result,</span><span class="s3">\n            </span><span class="s1">lexerErrors: lexerResult.errors,</span><span class="s3">\n            </span><span class="s1">lexerReport: lexerResult.report,</span><span class="s3">\n            </span><span class="s1">parserErrors: this.wrapper.errors</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startImplementation($type, implementation) {</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; {</span><span class="s3">\n            </span><span class="s1">// Only create a new AST node in case the calling rule is not a fragment rule</span><span class="s3">\n            </span><span class="s1">const createNode = !this.isRecording() &amp;&amp; $type !== undefined;</span><span class="s3">\n            </span><span class="s1">if (createNode) {</span><span class="s3">\n                </span><span class="s1">const node = { $type };</span><span class="s3">\n                </span><span class="s1">this.stack.push(node);</span><span class="s3">\n                </span><span class="s1">if ($type === DatatypeSymbol) {</span><span class="s3">\n                    </span><span class="s1">node.value = '';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let result;</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">result = implementation(args);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">result = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (result === undefined &amp;&amp; createNode) {</span><span class="s3">\n                </span><span class="s1">result = this.construct();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">extractHiddenTokens(token) {</span><span class="s3">\n        </span><span class="s1">const hiddenTokens = this.lexerResult.hidden;</span><span class="s3">\n        </span><span class="s1">if (!hiddenTokens.length) {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const offset = token.startOffset;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; hiddenTokens.length; i++) {</span><span class="s3">\n            </span><span class="s1">const token = hiddenTokens[i];</span><span class="s3">\n            </span><span class="s1">if (token.startOffset &gt; offset) {</span><span class="s3">\n                </span><span class="s1">return hiddenTokens.splice(0, i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return hiddenTokens.splice(0, hiddenTokens.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consume(idx, tokenType, feature) {</span><span class="s3">\n        </span><span class="s1">const token = this.wrapper.wrapConsume(idx, tokenType);</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording() &amp;&amp; this.isValidToken(token)) {</span><span class="s3">\n            </span><span class="s1">const hiddenTokens = this.extractHiddenTokens(token);</span><span class="s3">\n            </span><span class="s1">this.nodeBuilder.addHiddenNodes(hiddenTokens);</span><span class="s3">\n            </span><span class="s1">const leafNode = this.nodeBuilder.buildLeafNode(token, feature);</span><span class="s3">\n            </span><span class="s1">const { assignment, isCrossRef } = this.getAssignment(feature);</span><span class="s3">\n            </span><span class="s1">const current = this.current;</span><span class="s3">\n            </span><span class="s1">if (assignment) {</span><span class="s3">\n                </span><span class="s1">const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);</span><span class="s3">\n                </span><span class="s1">this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isDataTypeNode(current)) {</span><span class="s3">\n                </span><span class="s1">let text = token.image;</span><span class="s3">\n                </span><span class="s1">if (!isKeyword(feature)) {</span><span class="s3">\n                    </span><span class="s1">text = this.converter.convert(text, leafNode).toString();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">current.value += text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Most consumed parser tokens are valid. However there are two cases in which they are not valid:</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed</span><span class="s3">\n     </span><span class="s1">* 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isValidToken(token) {</span><span class="s3">\n        </span><span class="s1">return !token.isInsertedInRecovery &amp;&amp; !isNaN(token.startOffset) &amp;&amp; typeof token.endOffset === 'number' &amp;&amp; !isNaN(token.endOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subrule(idx, rule, fragment, feature, args) {</span><span class="s3">\n        </span><span class="s1">let cstNode;</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording() &amp;&amp; !fragment) {</span><span class="s3">\n            </span><span class="s1">// We only want to create a new CST node if the subrule actually creates a new AST node.</span><span class="s3">\n            </span><span class="s1">// In other cases like calls of fragment rules the current CST/AST is populated further.</span><span class="s3">\n            </span><span class="s1">// Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.</span><span class="s3">\n            </span><span class="s1">// This is intended, as fragment rules only enrich the current AST node</span><span class="s3">\n            </span><span class="s1">cstNode = this.nodeBuilder.buildCompositeNode(feature);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording() &amp;&amp; cstNode &amp;&amp; cstNode.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this.performSubruleAssignment(subruleResult, feature, cstNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">performSubruleAssignment(result, feature, cstNode) {</span><span class="s3">\n        </span><span class="s1">const { assignment, isCrossRef } = this.getAssignment(feature);</span><span class="s3">\n        </span><span class="s1">if (assignment) {</span><span class="s3">\n            </span><span class="s1">this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!assignment) {</span><span class="s3">\n            </span><span class="s1">// If we call a subrule without an assignment we either:</span><span class="s3">\n            </span><span class="s1">// 1. append the result of the subrule (data type rule)</span><span class="s3">\n            </span><span class="s1">// 2. override the current object with the newly parsed object</span><span class="s3">\n            </span><span class="s1">// If the current element is an AST node and the result of the subrule</span><span class="s3">\n            </span><span class="s1">// is a data type rule, we can safely discard the results.</span><span class="s3">\n            </span><span class="s1">const current = this.current;</span><span class="s3">\n            </span><span class="s1">if (isDataTypeNode(current)) {</span><span class="s3">\n                </span><span class="s1">current.value += result.toString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (typeof result === 'object' &amp;&amp; result) {</span><span class="s3">\n                </span><span class="s1">const object = this.assignWithoutOverride(result, current);</span><span class="s3">\n                </span><span class="s1">const newItem = object;</span><span class="s3">\n                </span><span class="s1">this.stack.pop();</span><span class="s3">\n                </span><span class="s1">this.stack.push(newItem);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">action($type, action) {</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording()) {</span><span class="s3">\n            </span><span class="s1">let last = this.current;</span><span class="s3">\n            </span><span class="s1">if (action.feature &amp;&amp; action.operator) {</span><span class="s3">\n                </span><span class="s1">last = this.construct();</span><span class="s3">\n                </span><span class="s1">this.nodeBuilder.removeNode(last.$cstNode);</span><span class="s3">\n                </span><span class="s1">const node = this.nodeBuilder.buildCompositeNode(action);</span><span class="s3">\n                </span><span class="s1">node.content.push(last.$cstNode);</span><span class="s3">\n                </span><span class="s1">const newItem = { $type };</span><span class="s3">\n                </span><span class="s1">this.stack.push(newItem);</span><span class="s3">\n                </span><span class="s1">this.assign(action.operator, action.feature, last, last.$cstNode, false);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">last.$type = $type;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">construct() {</span><span class="s3">\n        </span><span class="s1">if (this.isRecording()) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const obj = this.current;</span><span class="s3">\n        </span><span class="s1">linkContentToContainer(obj);</span><span class="s3">\n        </span><span class="s1">this.nodeBuilder.construct(obj);</span><span class="s3">\n        </span><span class="s1">this.stack.pop();</span><span class="s3">\n        </span><span class="s1">if (isDataTypeNode(obj)) {</span><span class="s3">\n            </span><span class="s1">return this.converter.convert(obj.value, obj.$cstNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">assignMandatoryProperties(this.astReflection, obj);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAssignment(feature) {</span><span class="s3">\n        </span><span class="s1">if (!this.assignmentMap.has(feature)) {</span><span class="s3">\n            </span><span class="s1">const assignment = getContainerOfType(feature, isAssignment);</span><span class="s3">\n            </span><span class="s1">this.assignmentMap.set(feature, {</span><span class="s3">\n                </span><span class="s1">assignment: assignment,</span><span class="s3">\n                </span><span class="s1">isCrossRef: assignment ? isCrossReference(assignment.terminal) : false</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.assignmentMap.get(feature);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assign(operator, feature, value, cstNode, isCrossRef) {</span><span class="s3">\n        </span><span class="s1">const obj = this.current;</span><span class="s3">\n        </span><span class="s1">let item;</span><span class="s3">\n        </span><span class="s1">if (isCrossRef &amp;&amp; typeof value === 'string') {</span><span class="s3">\n            </span><span class="s1">item = this.linker.buildReference(obj, feature, cstNode, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">item = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (operator) {</span><span class="s3">\n            </span><span class="s1">case '=': {</span><span class="s3">\n                </span><span class="s1">obj[feature] = item;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case '?=': {</span><span class="s3">\n                </span><span class="s1">obj[feature] = true;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case '+=': {</span><span class="s3">\n                </span><span class="s1">if (!Array.isArray(obj[feature])) {</span><span class="s3">\n                    </span><span class="s1">obj[feature] = [];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">obj[feature].push(item);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assignWithoutOverride(target, source) {</span><span class="s3">\n        </span><span class="s1">for (const [name, existingValue] of Object.entries(source)) {</span><span class="s3">\n            </span><span class="s1">const newValue = target[name];</span><span class="s3">\n            </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n                </span><span class="s1">target[name] = existingValue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (Array.isArray(newValue) &amp;&amp; Array.isArray(existingValue)) {</span><span class="s3">\n                </span><span class="s1">existingValue.push(...newValue);</span><span class="s3">\n                </span><span class="s1">target[name] = existingValue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The target was parsed from a unassigned subrule</span><span class="s3">\n        </span><span class="s1">// After the subrule construction, it received a cst node</span><span class="s3">\n        </span><span class="s1">// This CST node will later be overriden by the cst node builder</span><span class="s3">\n        </span><span class="s1">// To prevent references to stale AST nodes in the CST,</span><span class="s3">\n        </span><span class="s1">// we need to remove the reference here</span><span class="s3">\n        </span><span class="s1">const targetCstNode = target.$cstNode;</span><span class="s3">\n        </span><span class="s1">if (targetCstNode) {</span><span class="s3">\n            </span><span class="s1">targetCstNode.astNode = undefined;</span><span class="s3">\n            </span><span class="s1">target.$cstNode = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get definitionErrors() {</span><span class="s3">\n        </span><span class="s1">return this.wrapper.definitionErrors;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class AbstractParserErrorMessageProvider {</span><span class="s3">\n    </span><span class="s1">buildMismatchTokenMessage(options) {</span><span class="s3">\n        </span><span class="s1">return defaultParserErrorProvider.buildMismatchTokenMessage(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildNotAllInputParsedMessage(options) {</span><span class="s3">\n        </span><span class="s1">return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildNoViableAltMessage(options) {</span><span class="s3">\n        </span><span class="s1">return defaultParserErrorProvider.buildNoViableAltMessage(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildEarlyExitMessage(options) {</span><span class="s3">\n        </span><span class="s1">return defaultParserErrorProvider.buildEarlyExitMessage(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {</span><span class="s3">\n    </span><span class="s1">buildMismatchTokenMessage({ expected, actual }) {</span><span class="s3">\n        </span><span class="s1">const expectedMsg = expected.LABEL</span><span class="s3">\n            </span><span class="s1">? '`' + expected.LABEL + '`'</span><span class="s3">\n            </span><span class="s1">: expected.name.endsWith(':KW')</span><span class="s3">\n                </span><span class="s1">? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`</span><span class="s3">\n                </span><span class="s1">: `token of type '${expected.name}'`;</span><span class="s3">\n        </span><span class="s1">return `Expecting ${expectedMsg} but found </span><span class="s3">\\</span><span class="s1">`${actual.image}</span><span class="s3">\\</span><span class="s1">`.`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildNotAllInputParsedMessage({ firstRedundant }) {</span><span class="s3">\n        </span><span class="s1">return `Expecting end of file but found </span><span class="s3">\\</span><span class="s1">`${firstRedundant.image}</span><span class="s3">\\</span><span class="s1">`.`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class LangiumCompletionParser extends AbstractLangiumParser {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.tokens = [];</span><span class="s3">\n        </span><span class="s1">this.elementStack = [];</span><span class="s3">\n        </span><span class="s1">this.lastElementStack = [];</span><span class="s3">\n        </span><span class="s1">this.nextTokenIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.stackSize = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">action() {</span><span class="s3">\n        </span><span class="s1">// NOOP</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">construct() {</span><span class="s3">\n        </span><span class="s1">// NOOP</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse(input) {</span><span class="s3">\n        </span><span class="s1">this.resetState();</span><span class="s3">\n        </span><span class="s1">const tokens = this.lexer.tokenize(input, { mode: 'partial' });</span><span class="s3">\n        </span><span class="s1">this.tokens = tokens.tokens;</span><span class="s3">\n        </span><span class="s1">this.wrapper.input = [...this.tokens];</span><span class="s3">\n        </span><span class="s1">this.mainRule.call(this.wrapper, {});</span><span class="s3">\n        </span><span class="s1">this.unorderedGroups.clear();</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">tokens: this.tokens,</span><span class="s3">\n            </span><span class="s1">elementStack: [...this.lastElementStack],</span><span class="s3">\n            </span><span class="s1">tokenIndex: this.nextTokenIndex</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rule(rule, impl) {</span><span class="s3">\n        </span><span class="s1">const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));</span><span class="s3">\n        </span><span class="s1">this.allRules.set(rule.name, ruleMethod);</span><span class="s3">\n        </span><span class="s1">if (rule.entry) {</span><span class="s3">\n            </span><span class="s1">this.mainRule = ruleMethod;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ruleMethod;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resetState() {</span><span class="s3">\n        </span><span class="s1">this.elementStack = [];</span><span class="s3">\n        </span><span class="s1">this.lastElementStack = [];</span><span class="s3">\n        </span><span class="s1">this.nextTokenIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.stackSize = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startImplementation(implementation) {</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; {</span><span class="s3">\n            </span><span class="s1">const size = this.keepStackSize();</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">implementation(args);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">finally {</span><span class="s3">\n                </span><span class="s1">this.resetStackSize(size);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeUnexpectedElements() {</span><span class="s3">\n        </span><span class="s1">this.elementStack.splice(this.stackSize);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">keepStackSize() {</span><span class="s3">\n        </span><span class="s1">const size = this.elementStack.length;</span><span class="s3">\n        </span><span class="s1">this.stackSize = size;</span><span class="s3">\n        </span><span class="s1">return size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resetStackSize(size) {</span><span class="s3">\n        </span><span class="s1">this.removeUnexpectedElements();</span><span class="s3">\n        </span><span class="s1">this.stackSize = size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">consume(idx, tokenType, feature) {</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapConsume(idx, tokenType);</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording()) {</span><span class="s3">\n            </span><span class="s1">this.lastElementStack = [...this.elementStack, feature];</span><span class="s3">\n            </span><span class="s1">this.nextTokenIndex = this.currIdx + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">subrule(idx, rule, fragment, feature, args) {</span><span class="s3">\n        </span><span class="s1">this.before(feature);</span><span class="s3">\n        </span><span class="s1">this.wrapper.wrapSubrule(idx, rule, args);</span><span class="s3">\n        </span><span class="s1">this.after(feature);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">before(element) {</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording()) {</span><span class="s3">\n            </span><span class="s1">this.elementStack.push(element);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">after(element) {</span><span class="s3">\n        </span><span class="s1">if (!this.isRecording()) {</span><span class="s3">\n            </span><span class="s1">const index = this.elementStack.lastIndexOf(element);</span><span class="s3">\n            </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">this.elementStack.splice(index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get currIdx() {</span><span class="s3">\n        </span><span class="s1">return this.wrapper.currIdx;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultConfig = {</span><span class="s3">\n    </span><span class="s1">recoveryEnabled: true,</span><span class="s3">\n    </span><span class="s1">nodeLocationTracking: 'full',</span><span class="s3">\n    </span><span class="s1">skipValidations: true,</span><span class="s3">\n    </span><span class="s1">errorMessageProvider: new LangiumParserErrorMessageProvider()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class wraps the embedded actions parser of chevrotain and exposes protected methods.</span><span class="s3">\n </span><span class="s1">* This way, we can build the `LangiumParser` as a composition.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ChevrotainWrapper extends EmbeddedActionsParser {</span><span class="s3">\n    </span><span class="s1">constructor(tokens, config) {</span><span class="s3">\n        </span><span class="s1">const useDefaultLookahead = config &amp;&amp; 'maxLookahead' in config;</span><span class="s3">\n        </span><span class="s1">super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead</span><span class="s3">\n                </span><span class="s1">? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })</span><span class="s3">\n                </span><span class="s1">: new LLStarLookaheadStrategy({</span><span class="s3">\n                    </span><span class="s1">// If validations are skipped, don't log the lookahead warnings</span><span class="s3">\n                    </span><span class="s1">logging: config.skipValidations ? () =&gt; { } : undefined</span><span class="s3">\n                </span><span class="s1">}) }), config));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get IS_RECORDING() {</span><span class="s3">\n        </span><span class="s1">return this.RECORDING_PHASE;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DEFINE_RULE(name, impl) {</span><span class="s3">\n        </span><span class="s1">return this.RULE(name, impl);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapSelfAnalysis() {</span><span class="s3">\n        </span><span class="s1">this.performSelfAnalysis();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapConsume(idx, tokenType) {</span><span class="s3">\n        </span><span class="s1">return this.consume(idx, tokenType);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapSubrule(idx, rule, args) {</span><span class="s3">\n        </span><span class="s1">return this.subrule(idx, rule, {</span><span class="s3">\n            </span><span class="s1">ARGS: [args]</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapOr(idx, choices) {</span><span class="s3">\n        </span><span class="s1">this.or(idx, choices);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapOption(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.option(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapMany(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.many(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapAtLeastOne(idx, callback) {</span><span class="s3">\n        </span><span class="s1">this.atLeastOne(idx, callback);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=langium-parser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { EMPTY_ALT, EOF } from 'chevrotain';</span><span class="s3">\n</span><span class="s1">import { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup, isBooleanLiteral } from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { findNameAssignment, getAllReachableRules, getTypeName } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">export function createParser(grammar, parser, tokens) {</span><span class="s3">\n    </span><span class="s1">const parserContext = {</span><span class="s3">\n        </span><span class="s1">parser,</span><span class="s3">\n        </span><span class="s1">tokens,</span><span class="s3">\n        </span><span class="s1">ruleNames: new Map()</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">buildRules(parserContext, grammar);</span><span class="s3">\n    </span><span class="s1">return parser;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildRules(parserContext, grammar) {</span><span class="s3">\n    </span><span class="s1">const reachable = getAllReachableRules(grammar, false);</span><span class="s3">\n    </span><span class="s1">const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule =&gt; reachable.has(rule));</span><span class="s3">\n    </span><span class="s1">for (const rule of parserRules) {</span><span class="s3">\n        </span><span class="s1">const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });</span><span class="s3">\n        </span><span class="s1">parserContext.parser.rule(rule, buildElement(ctx, rule.definition));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildElement(ctx, element, ignoreGuard = false) {</span><span class="s3">\n    </span><span class="s1">let method;</span><span class="s3">\n    </span><span class="s1">if (isKeyword(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildKeyword(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isAction(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildAction(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isAssignment(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildElement(ctx, element.terminal);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isCrossReference(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildCrossReference(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isRuleCall(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildRuleCall(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isAlternatives(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildAlternatives(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isUnorderedGroup(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildUnorderedGroup(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isGroup(element)) {</span><span class="s3">\n        </span><span class="s1">method = buildGroup(ctx, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isEndOfFile(element)) {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.consume++;</span><span class="s3">\n        </span><span class="s1">method = () =&gt; ctx.parser.consume(idx, EOF, element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildAction(ctx, action) {</span><span class="s3">\n    </span><span class="s1">const actionType = getTypeName(action);</span><span class="s3">\n    </span><span class="s1">return () =&gt; ctx.parser.action(actionType, action);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildRuleCall(ctx, ruleCall) {</span><span class="s3">\n    </span><span class="s1">const rule = ruleCall.rule.ref;</span><span class="s3">\n    </span><span class="s1">if (isParserRule(rule)) {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.subrule++;</span><span class="s3">\n        </span><span class="s1">const fragment = rule.fragment;</span><span class="s3">\n        </span><span class="s1">const predicate = ruleCall.arguments.length &gt; 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () =&gt; ({});</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isTerminalRule(rule)) {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.consume++;</span><span class="s3">\n        </span><span class="s1">const method = getToken(ctx, rule.name);</span><span class="s3">\n        </span><span class="s1">return () =&gt; ctx.parser.consume(idx, method, ruleCall);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!rule) {</span><span class="s3">\n        </span><span class="s1">throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">assertUnreachable(rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildRuleCallPredicate(rule, namedArgs) {</span><span class="s3">\n    </span><span class="s1">const predicates = namedArgs.map(e =&gt; buildPredicate(e.value));</span><span class="s3">\n    </span><span class="s1">return (args) =&gt; {</span><span class="s3">\n        </span><span class="s1">const ruleArgs = {};</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; predicates.length; i++) {</span><span class="s3">\n            </span><span class="s1">const ruleTarget = rule.parameters[i];</span><span class="s3">\n            </span><span class="s1">const predicate = predicates[i];</span><span class="s3">\n            </span><span class="s1">ruleArgs[ruleTarget.name] = predicate(args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ruleArgs;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildPredicate(condition) {</span><span class="s3">\n    </span><span class="s1">if (isDisjunction(condition)) {</span><span class="s3">\n        </span><span class="s1">const left = buildPredicate(condition.left);</span><span class="s3">\n        </span><span class="s1">const right = buildPredicate(condition.right);</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; (left(args) || right(args));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isConjunction(condition)) {</span><span class="s3">\n        </span><span class="s1">const left = buildPredicate(condition.left);</span><span class="s3">\n        </span><span class="s1">const right = buildPredicate(condition.right);</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; (left(args) &amp;&amp; right(args));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isNegation(condition)) {</span><span class="s3">\n        </span><span class="s1">const value = buildPredicate(condition.value);</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; !value(args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isParameterReference(condition)) {</span><span class="s3">\n        </span><span class="s1">const name = condition.parameter.ref.name;</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; args !== undefined &amp;&amp; args[name] === true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isBooleanLiteral(condition)) {</span><span class="s3">\n        </span><span class="s1">const value = Boolean(condition.true);</span><span class="s3">\n        </span><span class="s1">return () =&gt; value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assertUnreachable(condition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildAlternatives(ctx, alternatives) {</span><span class="s3">\n    </span><span class="s1">if (alternatives.elements.length === 1) {</span><span class="s3">\n        </span><span class="s1">return buildElement(ctx, alternatives.elements[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const methods = [];</span><span class="s3">\n        </span><span class="s1">for (const element of alternatives.elements) {</span><span class="s3">\n            </span><span class="s1">const predicatedMethod = {</span><span class="s3">\n                </span><span class="s1">// Since we handle the guard condition in the alternative already</span><span class="s3">\n                </span><span class="s1">// We can ignore the group guard condition inside</span><span class="s3">\n                </span><span class="s1">ALT: buildElement(ctx, element, true)</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">const guard = getGuardCondition(element);</span><span class="s3">\n            </span><span class="s1">if (guard) {</span><span class="s3">\n                </span><span class="s1">predicatedMethod.GATE = buildPredicate(guard);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">methods.push(predicatedMethod);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const idx = ctx.or++;</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; ctx.parser.alternatives(idx, methods.map(method =&gt; {</span><span class="s3">\n            </span><span class="s1">const alt = {</span><span class="s3">\n                </span><span class="s1">ALT: () =&gt; method.ALT(args)</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">const gate = method.GATE;</span><span class="s3">\n            </span><span class="s1">if (gate) {</span><span class="s3">\n                </span><span class="s1">alt.GATE = () =&gt; gate(args);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return alt;</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildUnorderedGroup(ctx, group) {</span><span class="s3">\n    </span><span class="s1">if (group.elements.length === 1) {</span><span class="s3">\n        </span><span class="s1">return buildElement(ctx, group.elements[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const methods = [];</span><span class="s3">\n    </span><span class="s1">for (const element of group.elements) {</span><span class="s3">\n        </span><span class="s1">const predicatedMethod = {</span><span class="s3">\n            </span><span class="s1">// Since we handle the guard condition in the alternative already</span><span class="s3">\n            </span><span class="s1">// We can ignore the group guard condition inside</span><span class="s3">\n            </span><span class="s1">ALT: buildElement(ctx, element, true)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const guard = getGuardCondition(element);</span><span class="s3">\n        </span><span class="s1">if (guard) {</span><span class="s3">\n            </span><span class="s1">predicatedMethod.GATE = buildPredicate(guard);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">methods.push(predicatedMethod);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const orIdx = ctx.or++;</span><span class="s3">\n    </span><span class="s1">const idFunc = (groupIdx, lParser) =&gt; {</span><span class="s3">\n        </span><span class="s1">const stackId = lParser.getRuleStack().join('-');</span><span class="s3">\n        </span><span class="s1">return `uGroup_${groupIdx}_${stackId}`;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">const alternatives = (args) =&gt; ctx.parser.alternatives(orIdx, methods.map((method, idx) =&gt; {</span><span class="s3">\n        </span><span class="s1">const alt = { ALT: () =&gt; true };</span><span class="s3">\n        </span><span class="s1">const parser = ctx.parser;</span><span class="s3">\n        </span><span class="s1">alt.ALT = () =&gt; {</span><span class="s3">\n            </span><span class="s1">method.ALT(args);</span><span class="s3">\n            </span><span class="s1">if (!parser.isRecording()) {</span><span class="s3">\n                </span><span class="s1">const key = idFunc(orIdx, parser);</span><span class="s3">\n                </span><span class="s1">if (!parser.unorderedGroups.get(key)) {</span><span class="s3">\n                    </span><span class="s1">// init after clear state</span><span class="s3">\n                    </span><span class="s1">parser.unorderedGroups.set(key, []);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const groupState = parser.unorderedGroups.get(key);</span><span class="s3">\n                </span><span class="s1">if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {</span><span class="s3">\n                    </span><span class="s1">// Not accessed yet</span><span class="s3">\n                    </span><span class="s1">groupState[idx] = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const gate = method.GATE;</span><span class="s3">\n        </span><span class="s1">if (gate) {</span><span class="s3">\n            </span><span class="s1">alt.GATE = () =&gt; gate(args);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">alt.GATE = () =&gt; {</span><span class="s3">\n                </span><span class="s1">const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));</span><span class="s3">\n                </span><span class="s1">const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);</span><span class="s3">\n                </span><span class="s1">return allow;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return alt;</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');</span><span class="s3">\n    </span><span class="s1">return (args) =&gt; {</span><span class="s3">\n        </span><span class="s1">wrapped(args);</span><span class="s3">\n        </span><span class="s1">if (!ctx.parser.isRecording()) {</span><span class="s3">\n            </span><span class="s1">ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildGroup(ctx, group) {</span><span class="s3">\n    </span><span class="s1">const methods = group.elements.map(e =&gt; buildElement(ctx, e));</span><span class="s3">\n    </span><span class="s1">return (args) =&gt; methods.forEach(method =&gt; method(args));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getGuardCondition(element) {</span><span class="s3">\n    </span><span class="s1">if (isGroup(element)) {</span><span class="s3">\n        </span><span class="s1">return element.guardCondition;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {</span><span class="s3">\n    </span><span class="s1">if (!terminal) {</span><span class="s3">\n        </span><span class="s1">if (!crossRef.type.ref) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const assignment = findNameAssignment(crossRef.type.ref);</span><span class="s3">\n        </span><span class="s1">const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;</span><span class="s3">\n        </span><span class="s1">if (!assignTerminal) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return buildCrossReference(ctx, crossRef, assignTerminal);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isRuleCall(terminal) &amp;&amp; isParserRule(terminal.rule.ref)) {</span><span class="s3">\n        </span><span class="s1">// The terminal is a data type rule here. Everything else will result in a validation error.</span><span class="s3">\n        </span><span class="s1">const rule = terminal.rule.ref;</span><span class="s3">\n        </span><span class="s1">const idx = ctx.subrule++;</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isRuleCall(terminal) &amp;&amp; isTerminalRule(terminal.rule.ref)) {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.consume++;</span><span class="s3">\n        </span><span class="s1">const terminalRule = getToken(ctx, terminal.rule.ref.name);</span><span class="s3">\n        </span><span class="s1">return () =&gt; ctx.parser.consume(idx, terminalRule, crossRef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isKeyword(terminal)) {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.consume++;</span><span class="s3">\n        </span><span class="s1">const keyword = getToken(ctx, terminal.value);</span><span class="s3">\n        </span><span class="s1">return () =&gt; ctx.parser.consume(idx, keyword, crossRef);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw new Error('Could not build cross reference parser');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildKeyword(ctx, keyword) {</span><span class="s3">\n    </span><span class="s1">const idx = ctx.consume++;</span><span class="s3">\n    </span><span class="s1">const token = ctx.tokens[keyword.value];</span><span class="s3">\n    </span><span class="s1">if (!token) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Could not find token for keyword: ' + keyword.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return () =&gt; ctx.parser.consume(idx, token, keyword);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function wrap(ctx, guard, method, cardinality) {</span><span class="s3">\n    </span><span class="s1">const gate = guard &amp;&amp; buildPredicate(guard);</span><span class="s3">\n    </span><span class="s1">if (!cardinality) {</span><span class="s3">\n        </span><span class="s1">if (gate) {</span><span class="s3">\n            </span><span class="s1">const idx = ctx.or++;</span><span class="s3">\n            </span><span class="s1">return (args) =&gt; ctx.parser.alternatives(idx, [</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">ALT: () =&gt; method(args),</span><span class="s3">\n                    </span><span class="s1">GATE: () =&gt; gate(args)</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">ALT: EMPTY_ALT(),</span><span class="s3">\n                    </span><span class="s1">GATE: () =&gt; !gate(args)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return method;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cardinality === '*') {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.many++;</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; ctx.parser.many(idx, {</span><span class="s3">\n            </span><span class="s1">DEF: () =&gt; method(args),</span><span class="s3">\n            </span><span class="s1">GATE: gate ? () =&gt; gate(args) : undefined</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (cardinality === '+') {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.many++;</span><span class="s3">\n        </span><span class="s1">if (gate) {</span><span class="s3">\n            </span><span class="s1">const orIdx = ctx.or++;</span><span class="s3">\n            </span><span class="s1">// In the case of a guard condition for the `+` group</span><span class="s3">\n            </span><span class="s1">// We combine it with an empty alternative</span><span class="s3">\n            </span><span class="s1">// If the condition returns true, it needs to parse at least a single iteration</span><span class="s3">\n            </span><span class="s1">// If its false, it is not allowed to parse anything</span><span class="s3">\n            </span><span class="s1">return (args) =&gt; ctx.parser.alternatives(orIdx, [</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">ALT: () =&gt; ctx.parser.atLeastOne(idx, {</span><span class="s3">\n                        </span><span class="s1">DEF: () =&gt; method(args)</span><span class="s3">\n                    </span><span class="s1">}),</span><span class="s3">\n                    </span><span class="s1">GATE: () =&gt; gate(args)</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">ALT: EMPTY_ALT(),</span><span class="s3">\n                    </span><span class="s1">GATE: () =&gt; !gate(args)</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return (args) =&gt; ctx.parser.atLeastOne(idx, {</span><span class="s3">\n                </span><span class="s1">DEF: () =&gt; method(args),</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (cardinality === '?') {</span><span class="s3">\n        </span><span class="s1">const idx = ctx.optional++;</span><span class="s3">\n        </span><span class="s1">return (args) =&gt; ctx.parser.optional(idx, {</span><span class="s3">\n            </span><span class="s1">DEF: () =&gt; method(args),</span><span class="s3">\n            </span><span class="s1">GATE: gate ? () =&gt; gate(args) : undefined</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">assertUnreachable(cardinality);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getRule(ctx, element) {</span><span class="s3">\n    </span><span class="s1">const name = getRuleName(ctx, element);</span><span class="s3">\n    </span><span class="s1">const rule = ctx.parser.getRule(name);</span><span class="s3">\n    </span><span class="s1">if (!rule)</span><span class="s3">\n        </span><span class="s1">throw new Error(`Rule </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot; </span><span class="s1">not found.</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">return rule;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getRuleName(ctx, element) {</span><span class="s3">\n    </span><span class="s1">if (isParserRule(element)) {</span><span class="s3">\n        </span><span class="s1">return element.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ctx.ruleNames.has(element)) {</span><span class="s3">\n        </span><span class="s1">return ctx.ruleNames.get(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let item = element;</span><span class="s3">\n        </span><span class="s1">let parent = item.$container;</span><span class="s3">\n        </span><span class="s1">let ruleName = element.$type;</span><span class="s3">\n        </span><span class="s1">while (!isParserRule(parent)) {</span><span class="s3">\n            </span><span class="s1">if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {</span><span class="s3">\n                </span><span class="s1">const index = parent.elements.indexOf(item);</span><span class="s3">\n                </span><span class="s1">ruleName = index.toString() + ':' + ruleName;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">item = parent;</span><span class="s3">\n            </span><span class="s1">parent = parent.$container;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const rule = parent;</span><span class="s3">\n        </span><span class="s1">ruleName = rule.name + ':' + ruleName;</span><span class="s3">\n        </span><span class="s1">ctx.ruleNames.set(element, ruleName);</span><span class="s3">\n        </span><span class="s1">return ruleName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getToken(ctx, name) {</span><span class="s3">\n    </span><span class="s1">const token = ctx.tokens[name];</span><span class="s3">\n    </span><span class="s1">if (!token)</span><span class="s3">\n        </span><span class="s1">throw new Error(`Token </span><span class="s3">\&quot;</span><span class="s1">${name}</span><span class="s3">\&quot; </span><span class="s1">not found.</span><span class="s3">\&quot;</span><span class="s1">`);</span><span class="s3">\n    </span><span class="s1">return token;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=parser-builder-base.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { LangiumCompletionParser } from './langium-parser.js';</span><span class="s3">\n</span><span class="s1">import { createParser } from './parser-builder-base.js';</span><span class="s3">\n</span><span class="s1">export function createCompletionParser(services) {</span><span class="s3">\n    </span><span class="s1">const grammar = services.Grammar;</span><span class="s3">\n    </span><span class="s1">const lexer = services.parser.Lexer;</span><span class="s3">\n    </span><span class="s1">const parser = new LangiumCompletionParser(services);</span><span class="s3">\n    </span><span class="s1">createParser(grammar, parser, lexer.definition);</span><span class="s3">\n    </span><span class="s1">parser.finalize();</span><span class="s3">\n    </span><span class="s1">return parser;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=completion-parser-builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { LangiumParser } from './langium-parser.js';</span><span class="s3">\n</span><span class="s1">import { createParser } from './parser-builder-base.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create and finalize a Langium parser. The parser rules are derived from the grammar, which is</span><span class="s3">\n </span><span class="s1">* available at `services.Grammar`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createLangiumParser(services) {</span><span class="s3">\n    </span><span class="s1">const parser = prepareLangiumParser(services);</span><span class="s3">\n    </span><span class="s1">parser.finalize();</span><span class="s3">\n    </span><span class="s1">return parser;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a Langium parser without finalizing it. This is used to extract more detailed error</span><span class="s3">\n </span><span class="s1">* information when the parser is initially validated.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function prepareLangiumParser(services) {</span><span class="s3">\n    </span><span class="s1">const grammar = services.Grammar;</span><span class="s3">\n    </span><span class="s1">const lexer = services.parser.Lexer;</span><span class="s3">\n    </span><span class="s1">const parser = new LangiumParser(services);</span><span class="s3">\n    </span><span class="s1">return createParser(grammar, parser, lexer.definition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=langium-parser-builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Delays the execution of the current code to the next tick of the event loop.</span><span class="s3">\n </span><span class="s1">* Don't call this method directly in a tight loop to prevent too many promises from being created.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function delayNextTick() {</span><span class="s3">\n    </span><span class="s1">return new Promise(resolve =&gt; {</span><span class="s3">\n        </span><span class="s1">// In case we are running in a non-node environment, `setImmediate` isn't available.</span><span class="s3">\n        </span><span class="s1">// Using `setTimeout` of the browser API accomplishes the same result.</span><span class="s3">\n        </span><span class="s1">if (typeof setImmediate === 'undefined') {</span><span class="s3">\n            </span><span class="s1">setTimeout(resolve, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">setImmediate(resolve);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let lastTick = 0;</span><span class="s3">\n</span><span class="s1">let globalInterruptionPeriod = 10;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Reset the global interruption period and create a cancellation token source.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function startCancelableOperation() {</span><span class="s3">\n    </span><span class="s1">lastTick = performance.now();</span><span class="s3">\n    </span><span class="s1">return new CancellationTokenSource();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Change the period duration for `interruptAndCheck` to the given number of milliseconds.</span><span class="s3">\n </span><span class="s1">* The default value is 10ms.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function setInterruptionPeriod(period) {</span><span class="s3">\n    </span><span class="s1">globalInterruptionPeriod = period;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This symbol may be thrown in an asynchronous context by any Langium service that receives</span><span class="s3">\n </span><span class="s1">* a `CancellationToken`. This means that the promise returned by such a service is rejected with</span><span class="s3">\n </span><span class="s1">* this symbol as rejection reason.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const OperationCancelled = Symbol('OperationCancelled');</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use this in a `catch` block to check whether the thrown object indicates that the operation</span><span class="s3">\n </span><span class="s1">* has been cancelled.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isOperationCancelled(err) {</span><span class="s3">\n    </span><span class="s1">return err === OperationCancelled;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function does two things:</span><span class="s3">\n </span><span class="s1">*  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined</span><span class="s3">\n </span><span class="s1">*     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.</span><span class="s3">\n </span><span class="s1">*  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation</span><span class="s3">\n </span><span class="s1">*     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* All services in Langium that receive a `CancellationToken` may potentially call this function, so the</span><span class="s3">\n </span><span class="s1">* `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to</span><span class="s3">\n </span><span class="s1">* the promise) to avoid that event being exposed as an error.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export async function interruptAndCheck(token) {</span><span class="s3">\n    </span><span class="s1">if (token === CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">// Early exit in case cancellation was disabled by the caller</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const current = performance.now();</span><span class="s3">\n    </span><span class="s1">if (current - lastTick &gt;= globalInterruptionPeriod) {</span><span class="s3">\n        </span><span class="s1">lastTick = current;</span><span class="s3">\n        </span><span class="s1">await delayNextTick();</span><span class="s3">\n        </span><span class="s1">// prevent calling delayNextTick every iteration of loop</span><span class="s3">\n        </span><span class="s1">// where delayNextTick takes up the majority or all of the</span><span class="s3">\n        </span><span class="s1">// globalInterruptionPeriod itself</span><span class="s3">\n        </span><span class="s1">lastTick = performance.now();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (token.isCancellationRequested) {</span><span class="s3">\n        </span><span class="s1">throw OperationCancelled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Simple implementation of the deferred pattern.</span><span class="s3">\n </span><span class="s1">* An object that exposes a promise and functions to resolve and reject it.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Deferred {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.promise = new Promise((resolve, reject) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.resolve = (arg) =&gt; {</span><span class="s3">\n                </span><span class="s1">resolve(arg);</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">this.reject = (err) =&gt; {</span><span class="s3">\n                </span><span class="s1">reject(err);</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=promise-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">'use strict';</span><span class="s3">\n</span><span class="s1">class FullTextDocument {</span><span class="s3">\n    </span><span class="s1">constructor(uri, languageId, version, content) {</span><span class="s3">\n        </span><span class="s1">this._uri = uri;</span><span class="s3">\n        </span><span class="s1">this._languageId = languageId;</span><span class="s3">\n        </span><span class="s1">this._version = version;</span><span class="s3">\n        </span><span class="s1">this._content = content;</span><span class="s3">\n        </span><span class="s1">this._lineOffsets = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get uri() {</span><span class="s3">\n        </span><span class="s1">return this._uri;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get languageId() {</span><span class="s3">\n        </span><span class="s1">return this._languageId;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get version() {</span><span class="s3">\n        </span><span class="s1">return this._version;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getText(range) {</span><span class="s3">\n        </span><span class="s1">if (range) {</span><span class="s3">\n            </span><span class="s1">const start = this.offsetAt(range.start);</span><span class="s3">\n            </span><span class="s1">const end = this.offsetAt(range.end);</span><span class="s3">\n            </span><span class="s1">return this._content.substring(start, end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(changes, version) {</span><span class="s3">\n        </span><span class="s1">for (const change of changes) {</span><span class="s3">\n            </span><span class="s1">if (FullTextDocument.isIncremental(change)) {</span><span class="s3">\n                </span><span class="s1">// makes sure start is before end</span><span class="s3">\n                </span><span class="s1">const range = getWellformedRange(change.range);</span><span class="s3">\n                </span><span class="s1">// update content</span><span class="s3">\n                </span><span class="s1">const startOffset = this.offsetAt(range.start);</span><span class="s3">\n                </span><span class="s1">const endOffset = this.offsetAt(range.end);</span><span class="s3">\n                </span><span class="s1">this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);</span><span class="s3">\n                </span><span class="s1">// update the offsets</span><span class="s3">\n                </span><span class="s1">const startLine = Math.max(range.start.line, 0);</span><span class="s3">\n                </span><span class="s1">const endLine = Math.max(range.end.line, 0);</span><span class="s3">\n                </span><span class="s1">let lineOffsets = this._lineOffsets;</span><span class="s3">\n                </span><span class="s1">const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);</span><span class="s3">\n                </span><span class="s1">if (endLine - startLine === addedLineOffsets.length) {</span><span class="s3">\n                    </span><span class="s1">for (let i = 0, len = addedLineOffsets.length; i &lt; len; i++) {</span><span class="s3">\n                        </span><span class="s1">lineOffsets[i + startLine + 1] = addedLineOffsets[i];</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (addedLineOffsets.length &lt; 10000) {</span><span class="s3">\n                        </span><span class="s1">lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else { // avoid too many arguments for splice</span><span class="s3">\n                        </span><span class="s1">this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const diff = change.text.length - (endOffset - startOffset);</span><span class="s3">\n                </span><span class="s1">if (diff !== 0) {</span><span class="s3">\n                    </span><span class="s1">for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i &lt; len; i++) {</span><span class="s3">\n                        </span><span class="s1">lineOffsets[i] = lineOffsets[i] + diff;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (FullTextDocument.isFull(change)) {</span><span class="s3">\n                </span><span class="s1">this._content = change.text;</span><span class="s3">\n                </span><span class="s1">this._lineOffsets = undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw new Error('Unknown change event received');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._version = version;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLineOffsets() {</span><span class="s3">\n        </span><span class="s1">if (this._lineOffsets === undefined) {</span><span class="s3">\n            </span><span class="s1">this._lineOffsets = computeLineOffsets(this._content, true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._lineOffsets;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">positionAt(offset) {</span><span class="s3">\n        </span><span class="s1">offset = Math.max(Math.min(offset, this._content.length), 0);</span><span class="s3">\n        </span><span class="s1">const lineOffsets = this.getLineOffsets();</span><span class="s3">\n        </span><span class="s1">let low = 0, high = lineOffsets.length;</span><span class="s3">\n        </span><span class="s1">if (high === 0) {</span><span class="s3">\n            </span><span class="s1">return { line: 0, character: offset };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (low &lt; high) {</span><span class="s3">\n            </span><span class="s1">const mid = Math.floor((low + high) / 2);</span><span class="s3">\n            </span><span class="s1">if (lineOffsets[mid] &gt; offset) {</span><span class="s3">\n                </span><span class="s1">high = mid;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">low = mid + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// low is the least x for which the line offset is larger than the current offset</span><span class="s3">\n        </span><span class="s1">// or array.length if no line offset is larger than the current offset</span><span class="s3">\n        </span><span class="s1">const line = low - 1;</span><span class="s3">\n        </span><span class="s1">offset = this.ensureBeforeEOL(offset, lineOffsets[line]);</span><span class="s3">\n        </span><span class="s1">return { line, character: offset - lineOffsets[line] };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">offsetAt(position) {</span><span class="s3">\n        </span><span class="s1">const lineOffsets = this.getLineOffsets();</span><span class="s3">\n        </span><span class="s1">if (position.line &gt;= lineOffsets.length) {</span><span class="s3">\n            </span><span class="s1">return this._content.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (position.line &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const lineOffset = lineOffsets[position.line];</span><span class="s3">\n        </span><span class="s1">if (position.character &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return lineOffset;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const nextLineOffset = (position.line + 1 &lt; lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;</span><span class="s3">\n        </span><span class="s1">const offset = Math.min(lineOffset + position.character, nextLineOffset);</span><span class="s3">\n        </span><span class="s1">return this.ensureBeforeEOL(offset, lineOffset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ensureBeforeEOL(offset, lineOffset) {</span><span class="s3">\n        </span><span class="s1">while (offset &gt; lineOffset &amp;&amp; isEOL(this._content.charCodeAt(offset - 1))) {</span><span class="s3">\n            </span><span class="s1">offset--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineCount() {</span><span class="s3">\n        </span><span class="s1">return this.getLineOffsets().length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static isIncremental(event) {</span><span class="s3">\n        </span><span class="s1">const candidate = event;</span><span class="s3">\n        </span><span class="s1">return candidate !== undefined &amp;&amp; candidate !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof candidate.text === 'string' &amp;&amp; candidate.range !== undefined &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static isFull(event) {</span><span class="s3">\n        </span><span class="s1">const candidate = event;</span><span class="s3">\n        </span><span class="s1">return candidate !== undefined &amp;&amp; candidate !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof candidate.text === 'string' &amp;&amp; candidate.range === undefined &amp;&amp; candidate.rangeLength === undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var TextDocument;</span><span class="s3">\n</span><span class="s1">(function (TextDocument) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new text document.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param uri The document's uri.</span><span class="s3">\n     </span><span class="s1">* @param languageId  The document's language Id.</span><span class="s3">\n     </span><span class="s1">* @param version The document's initial version number.</span><span class="s3">\n     </span><span class="s1">* @param content The document's content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function create(uri, languageId, version, content) {</span><span class="s3">\n        </span><span class="s1">return new FullTextDocument(uri, languageId, version, content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.create = create;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Updates a TextDocument by modifying its content.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param document the document to update. Only documents created by TextDocument.create are valid inputs.</span><span class="s3">\n     </span><span class="s1">* @param changes the changes to apply to the document.</span><span class="s3">\n     </span><span class="s1">* @param version the changes version for the document.</span><span class="s3">\n     </span><span class="s1">* @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function update(document, changes, version) {</span><span class="s3">\n        </span><span class="s1">if (document instanceof FullTextDocument) {</span><span class="s3">\n            </span><span class="s1">document.update(changes, version);</span><span class="s3">\n            </span><span class="s1">return document;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new Error('TextDocument.update: document must be created by TextDocument.create');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.update = update;</span><span class="s3">\n    </span><span class="s1">function applyEdits(document, edits) {</span><span class="s3">\n        </span><span class="s1">const text = document.getText();</span><span class="s3">\n        </span><span class="s1">const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) =&gt; {</span><span class="s3">\n            </span><span class="s1">const diff = a.range.start.line - b.range.start.line;</span><span class="s3">\n            </span><span class="s1">if (diff === 0) {</span><span class="s3">\n                </span><span class="s1">return a.range.start.character - b.range.start.character;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return diff;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">let lastModifiedOffset = 0;</span><span class="s3">\n        </span><span class="s1">const spans = [];</span><span class="s3">\n        </span><span class="s1">for (const e of sortedEdits) {</span><span class="s3">\n            </span><span class="s1">const startOffset = document.offsetAt(e.range.start);</span><span class="s3">\n            </span><span class="s1">if (startOffset &lt; lastModifiedOffset) {</span><span class="s3">\n                </span><span class="s1">throw new Error('Overlapping edit');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (startOffset &gt; lastModifiedOffset) {</span><span class="s3">\n                </span><span class="s1">spans.push(text.substring(lastModifiedOffset, startOffset));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (e.newText.length) {</span><span class="s3">\n                </span><span class="s1">spans.push(e.newText);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">lastModifiedOffset = document.offsetAt(e.range.end);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">spans.push(text.substr(lastModifiedOffset));</span><span class="s3">\n        </span><span class="s1">return spans.join('');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextDocument.applyEdits = applyEdits;</span><span class="s3">\n</span><span class="s1">})(TextDocument || (TextDocument = {}));</span><span class="s3">\n</span><span class="s1">function mergeSort(data, compare) {</span><span class="s3">\n    </span><span class="s1">if (data.length &lt;= 1) {</span><span class="s3">\n        </span><span class="s1">// sorted</span><span class="s3">\n        </span><span class="s1">return data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const p = (data.length / 2) | 0;</span><span class="s3">\n    </span><span class="s1">const left = data.slice(0, p);</span><span class="s3">\n    </span><span class="s1">const right = data.slice(p);</span><span class="s3">\n    </span><span class="s1">mergeSort(left, compare);</span><span class="s3">\n    </span><span class="s1">mergeSort(right, compare);</span><span class="s3">\n    </span><span class="s1">let leftIdx = 0;</span><span class="s3">\n    </span><span class="s1">let rightIdx = 0;</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">while (leftIdx &lt; left.length &amp;&amp; rightIdx &lt; right.length) {</span><span class="s3">\n        </span><span class="s1">const ret = compare(left[leftIdx], right[rightIdx]);</span><span class="s3">\n        </span><span class="s1">if (ret &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">// smaller_equal -&gt; take left to preserve order</span><span class="s3">\n            </span><span class="s1">data[i++] = left[leftIdx++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// greater -&gt; take right</span><span class="s3">\n            </span><span class="s1">data[i++] = right[rightIdx++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (leftIdx &lt; left.length) {</span><span class="s3">\n        </span><span class="s1">data[i++] = left[leftIdx++];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (rightIdx &lt; right.length) {</span><span class="s3">\n        </span><span class="s1">data[i++] = right[rightIdx++];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return data;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function computeLineOffsets(text, isAtLineStart, textOffset = 0) {</span><span class="s3">\n    </span><span class="s1">const result = isAtLineStart ? [textOffset] : [];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; text.length; i++) {</span><span class="s3">\n        </span><span class="s1">const ch = text.charCodeAt(i);</span><span class="s3">\n        </span><span class="s1">if (isEOL(ch)) {</span><span class="s3">\n            </span><span class="s1">if (ch === 13 /* CharCode.CarriageReturn */ &amp;&amp; i + 1 &lt; text.length &amp;&amp; text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {</span><span class="s3">\n                </span><span class="s1">i++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">result.push(textOffset + i + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isEOL(char) {</span><span class="s3">\n    </span><span class="s1">return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getWellformedRange(range) {</span><span class="s3">\n    </span><span class="s1">const start = range.start;</span><span class="s3">\n    </span><span class="s1">const end = range.end;</span><span class="s3">\n    </span><span class="s1">if (start.line &gt; end.line || (start.line === end.line &amp;&amp; start.character &gt; end.character)) {</span><span class="s3">\n        </span><span class="s1">return { start: end, end: start };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return range;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getWellformedEdit(textEdit) {</span><span class="s3">\n    </span><span class="s1">const range = getWellformedRange(textEdit.range);</span><span class="s3">\n    </span><span class="s1">if (range !== textEdit.range) {</span><span class="s3">\n        </span><span class="s1">return { newText: textEdit.newText, range };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return textEdit;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,</span><span class="s3">\n </span><span class="s1">*  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,</span><span class="s3">\n </span><span class="s1">*  the overhead is very small, just a few kilobytes.</span><span class="s3">\n </span><span class="s1">* Everything else of that package (at the time contributing) is also defined</span><span class="s3">\n </span><span class="s1">*  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export { TextDocument } from 'vscode-languageserver-textdocument';</span><span class="s3">\n</span><span class="s1">import { TextDocument } from './documents.js';</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { URI } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A document is subject to several phases that are run in predefined order. Any state value implies that</span><span class="s3">\n </span><span class="s1">* smaller state values are finished as well.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var DocumentState;</span><span class="s3">\n</span><span class="s1">(function (DocumentState) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The text content has changed and needs to be parsed again. The AST held by this outdated</span><span class="s3">\n     </span><span class="s1">* document instance is no longer valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">Changed</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Changed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An AST has been created from the text content. The document structure can be traversed,</span><span class="s3">\n     </span><span class="s1">* but cross-references cannot be resolved yet. If necessary, the structure can be manipulated</span><span class="s3">\n     </span><span class="s1">* at this stage as a preprocessing step.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">Parsed</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Parsed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The `IndexManager` service has processed AST nodes of this document. This means the</span><span class="s3">\n     </span><span class="s1">* exported symbols are available in the global scope and can be resolved from other documents.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">IndexedContent</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">IndexedContent</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The `ScopeComputation` service has processed this document. This means the local symbols</span><span class="s3">\n     </span><span class="s1">* are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.</span><span class="s3">\n     </span><span class="s1">* Once a document has reached this state, you may follow every reference - it will lazily</span><span class="s3">\n     </span><span class="s1">* resolve its `ref` property and yield either the target AST node or `undefined` in case</span><span class="s3">\n     </span><span class="s1">* the target is not in scope.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">ComputedScopes</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">ComputedScopes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The `Linker` service has processed this document. All outgoing references have been</span><span class="s3">\n     </span><span class="s1">* resolved or marked as erroneous.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">Linked</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">Linked</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The `IndexManager` service has processed AST node references of this document. This is</span><span class="s3">\n     </span><span class="s1">* necessary to determine which documents are affected by a change in one of the workspace</span><span class="s3">\n     </span><span class="s1">* documents.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">IndexedReferences</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">IndexedReferences</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The `DocumentValidator` service has processed this document. The language server listens</span><span class="s3">\n     </span><span class="s1">* to the results of this phase and sends diagnostics to the client.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DocumentState[DocumentState[</span><span class="s3">\&quot;</span><span class="s1">Validated</span><span class="s3">\&quot;</span><span class="s1">] = 6] = </span><span class="s3">\&quot;</span><span class="s1">Validated</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(DocumentState || (DocumentState = {}));</span><span class="s3">\n</span><span class="s1">export class DefaultLangiumDocumentFactory {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n        </span><span class="s1">this.textDocuments = services.workspace.TextDocuments;</span><span class="s3">\n        </span><span class="s1">this.fileSystemProvider = services.workspace.FileSystemProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async fromUri(uri, cancellationToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const content = await this.fileSystemProvider.readFile(uri);</span><span class="s3">\n        </span><span class="s1">return this.createAsync(uri, content, cancellationToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromTextDocument(textDocument, uri, token) {</span><span class="s3">\n        </span><span class="s1">uri = uri !== null &amp;&amp; uri !== void 0 ? uri : URI.parse(textDocument.uri);</span><span class="s3">\n        </span><span class="s1">if (CancellationToken.is(token)) {</span><span class="s3">\n            </span><span class="s1">return this.createAsync(uri, textDocument, token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.create(uri, textDocument, token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromString(text, uri, token) {</span><span class="s3">\n        </span><span class="s1">if (CancellationToken.is(token)) {</span><span class="s3">\n            </span><span class="s1">return this.createAsync(uri, text, token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.create(uri, text, token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fromModel(model, uri) {</span><span class="s3">\n        </span><span class="s1">return this.create(uri, { $model: model });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">create(uri, content, options) {</span><span class="s3">\n        </span><span class="s1">if (typeof content === 'string') {</span><span class="s3">\n            </span><span class="s1">const parseResult = this.parse(uri, content, options);</span><span class="s3">\n            </span><span class="s1">return this.createLangiumDocument(parseResult, uri, undefined, content);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ('$model' in content) {</span><span class="s3">\n            </span><span class="s1">const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };</span><span class="s3">\n            </span><span class="s1">return this.createLangiumDocument(parseResult, uri);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const parseResult = this.parse(uri, content.getText(), options);</span><span class="s3">\n            </span><span class="s1">return this.createLangiumDocument(parseResult, uri, content);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async createAsync(uri, content, cancelToken) {</span><span class="s3">\n        </span><span class="s1">if (typeof content === 'string') {</span><span class="s3">\n            </span><span class="s1">const parseResult = await this.parseAsync(uri, content, cancelToken);</span><span class="s3">\n            </span><span class="s1">return this.createLangiumDocument(parseResult, uri, undefined, content);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);</span><span class="s3">\n            </span><span class="s1">return this.createLangiumDocument(parseResult, uri, content);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a LangiumDocument from a given parse result.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* A TextDocument is created on demand if it is not provided as argument here. Usually this</span><span class="s3">\n     </span><span class="s1">* should not be necessary because the main purpose of the TextDocument is to convert between</span><span class="s3">\n     </span><span class="s1">* text ranges and offsets, which is done solely in LSP request handling.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* With the introduction of {@link update} below this method is supposed to be mainly called</span><span class="s3">\n     </span><span class="s1">* during workspace initialization and on addition/recognition of new files, while changes in</span><span class="s3">\n     </span><span class="s1">* existing documents are processed via {@link update}.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createLangiumDocument(parseResult, uri, textDocument, text) {</span><span class="s3">\n        </span><span class="s1">let document;</span><span class="s3">\n        </span><span class="s1">if (textDocument) {</span><span class="s3">\n            </span><span class="s1">document = {</span><span class="s3">\n                </span><span class="s1">parseResult,</span><span class="s3">\n                </span><span class="s1">uri,</span><span class="s3">\n                </span><span class="s1">state: DocumentState.Parsed,</span><span class="s3">\n                </span><span class="s1">references: [],</span><span class="s3">\n                </span><span class="s1">textDocument</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const textDocumentGetter = this.createTextDocumentGetter(uri, text);</span><span class="s3">\n            </span><span class="s1">document = {</span><span class="s3">\n                </span><span class="s1">parseResult,</span><span class="s3">\n                </span><span class="s1">uri,</span><span class="s3">\n                </span><span class="s1">state: DocumentState.Parsed,</span><span class="s3">\n                </span><span class="s1">references: [],</span><span class="s3">\n                </span><span class="s1">get textDocument() {</span><span class="s3">\n                    </span><span class="s1">return textDocumentGetter();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">parseResult.value.$document = document;</span><span class="s3">\n        </span><span class="s1">return document;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async update(document, cancellationToken) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">// The CST full text property contains the original text that was used to create the AST.</span><span class="s3">\n        </span><span class="s1">const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;</span><span class="s3">\n        </span><span class="s1">const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());</span><span class="s3">\n        </span><span class="s1">const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);</span><span class="s3">\n        </span><span class="s1">if (textDocument) {</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(document, 'textDocument', {</span><span class="s3">\n                </span><span class="s1">value: textDocument</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(document, 'textDocument', {</span><span class="s3">\n                </span><span class="s1">get: textDocumentGetter</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Some of these documents can be pretty large, so parsing them again can be quite expensive.</span><span class="s3">\n        </span><span class="s1">// Therefore, we only parse if the text has actually changed.</span><span class="s3">\n        </span><span class="s1">if (oldText !== text) {</span><span class="s3">\n            </span><span class="s1">document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);</span><span class="s3">\n            </span><span class="s1">document.parseResult.value.$document = document;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">document.state = DocumentState.Parsed;</span><span class="s3">\n        </span><span class="s1">return document;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse(uri, text, options) {</span><span class="s3">\n        </span><span class="s1">const services = this.serviceRegistry.getServices(uri);</span><span class="s3">\n        </span><span class="s1">return services.parser.LangiumParser.parse(text, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parseAsync(uri, text, cancellationToken) {</span><span class="s3">\n        </span><span class="s1">const services = this.serviceRegistry.getServices(uri);</span><span class="s3">\n        </span><span class="s1">return services.parser.AsyncParser.parse(text, cancellationToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createTextDocumentGetter(uri, text) {</span><span class="s3">\n        </span><span class="s1">const serviceRegistry = this.serviceRegistry;</span><span class="s3">\n        </span><span class="s1">let textDoc = undefined;</span><span class="s3">\n        </span><span class="s1">return () =&gt; {</span><span class="s3">\n            </span><span class="s1">return textDoc !== null &amp;&amp; textDoc !== void 0 ? textDoc : (textDoc = TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null &amp;&amp; text !== void 0 ? text : ''));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class DefaultLangiumDocuments {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.documentMap = new Map();</span><span class="s3">\n        </span><span class="s1">this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get all() {</span><span class="s3">\n        </span><span class="s1">return stream(this.documentMap.values());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addDocument(document) {</span><span class="s3">\n        </span><span class="s1">const uriString = document.uri.toString();</span><span class="s3">\n        </span><span class="s1">if (this.documentMap.has(uriString)) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`A document with the URI '${uriString}' is already present.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.documentMap.set(uriString, document);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getDocument(uri) {</span><span class="s3">\n        </span><span class="s1">const uriString = uri.toString();</span><span class="s3">\n        </span><span class="s1">return this.documentMap.get(uriString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async getOrCreateDocument(uri, cancellationToken) {</span><span class="s3">\n        </span><span class="s1">let document = this.getDocument(uri);</span><span class="s3">\n        </span><span class="s1">if (document) {</span><span class="s3">\n            </span><span class="s1">return document;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);</span><span class="s3">\n        </span><span class="s1">this.addDocument(document);</span><span class="s3">\n        </span><span class="s1">return document;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createDocument(uri, text, cancellationToken) {</span><span class="s3">\n        </span><span class="s1">if (cancellationToken) {</span><span class="s3">\n            </span><span class="s1">return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document =&gt; {</span><span class="s3">\n                </span><span class="s1">this.addDocument(document);</span><span class="s3">\n                </span><span class="s1">return document;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const document = this.langiumDocumentFactory.fromString(text, uri);</span><span class="s3">\n            </span><span class="s1">this.addDocument(document);</span><span class="s3">\n            </span><span class="s1">return document;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasDocument(uri) {</span><span class="s3">\n        </span><span class="s1">return this.documentMap.has(uri.toString());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">invalidateDocument(uri) {</span><span class="s3">\n        </span><span class="s1">const uriString = uri.toString();</span><span class="s3">\n        </span><span class="s1">const langiumDoc = this.documentMap.get(uriString);</span><span class="s3">\n        </span><span class="s1">if (langiumDoc) {</span><span class="s3">\n            </span><span class="s1">const linker = this.serviceRegistry.getServices(uri).references.Linker;</span><span class="s3">\n            </span><span class="s1">linker.unlink(langiumDoc);</span><span class="s3">\n            </span><span class="s1">langiumDoc.state = DocumentState.Changed;</span><span class="s3">\n            </span><span class="s1">langiumDoc.precomputedScopes = undefined;</span><span class="s3">\n            </span><span class="s1">langiumDoc.diagnostics = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return langiumDoc;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">deleteDocument(uri) {</span><span class="s3">\n        </span><span class="s1">const uriString = uri.toString();</span><span class="s3">\n        </span><span class="s1">const langiumDoc = this.documentMap.get(uriString);</span><span class="s3">\n        </span><span class="s1">if (langiumDoc) {</span><span class="s3">\n            </span><span class="s1">langiumDoc.state = DocumentState.Changed;</span><span class="s3">\n            </span><span class="s1">this.documentMap.delete(uriString);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return langiumDoc;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=documents.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { findRootNode, streamAst, streamReferences } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { interruptAndCheck } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { DocumentState } from '../workspace/documents.js';</span><span class="s3">\n</span><span class="s1">const ref_resolving = Symbol('ref_resolving');</span><span class="s3">\n</span><span class="s1">export class DefaultLinker {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.reflection = services.shared.AstReflection;</span><span class="s3">\n        </span><span class="s1">this.langiumDocuments = () =&gt; services.shared.workspace.LangiumDocuments;</span><span class="s3">\n        </span><span class="s1">this.scopeProvider = services.references.ScopeProvider;</span><span class="s3">\n        </span><span class="s1">this.astNodeLocator = services.workspace.AstNodeLocator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async link(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">for (const node of streamAst(document.parseResult.value)) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">streamReferences(node).forEach(ref =&gt; this.doLink(ref, document));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">doLink(refInfo, document) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const ref = refInfo.reference;</span><span class="s3">\n        </span><span class="s1">// The reference may already have been resolved lazily by accessing its `ref` property.</span><span class="s3">\n        </span><span class="s1">if (ref._ref === undefined) {</span><span class="s3">\n            </span><span class="s1">ref._ref = ref_resolving;</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">const description = this.getCandidate(refInfo);</span><span class="s3">\n                </span><span class="s1">if (isLinkingError(description)) {</span><span class="s3">\n                    </span><span class="s1">ref._ref = description;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">ref._nodeDescription = description;</span><span class="s3">\n                    </span><span class="s1">if (this.langiumDocuments().hasDocument(description.documentUri)) {</span><span class="s3">\n                        </span><span class="s1">// The target document is already loaded</span><span class="s3">\n                        </span><span class="s1">const linkedNode = this.loadAstNode(description);</span><span class="s3">\n                        </span><span class="s1">ref._ref = linkedNode !== null &amp;&amp; linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// Try to load the target AST node later using the already provided description</span><span class="s3">\n                        </span><span class="s1">ref._ref = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);</span><span class="s3">\n                </span><span class="s1">const errorMessage = (_a = err.message) !== null &amp;&amp; _a !== void 0 ? _a : String(err);</span><span class="s3">\n                </span><span class="s1">ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Add the reference to the document's array of references</span><span class="s3">\n            </span><span class="s1">// Only add if the reference has been not been resolved earlier</span><span class="s3">\n            </span><span class="s1">// Otherwise we end up with duplicates</span><span class="s3">\n            </span><span class="s1">// See also implementation of `buildReference`</span><span class="s3">\n            </span><span class="s1">document.references.push(ref);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unlink(document) {</span><span class="s3">\n        </span><span class="s1">for (const ref of document.references) {</span><span class="s3">\n            </span><span class="s1">delete ref._ref;</span><span class="s3">\n            </span><span class="s1">delete ref._nodeDescription;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">document.references = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getCandidate(refInfo) {</span><span class="s3">\n        </span><span class="s1">const scope = this.scopeProvider.getScope(refInfo);</span><span class="s3">\n        </span><span class="s1">const description = scope.getElement(refInfo.reference.$refText);</span><span class="s3">\n        </span><span class="s1">return description !== null &amp;&amp; description !== void 0 ? description : this.createLinkingError(refInfo);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildReference(node, property, refNode, refText) {</span><span class="s3">\n        </span><span class="s1">// See behavior description in doc of Linker, update that on changes in here.</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-this-alias</span><span class="s3">\n        </span><span class="s1">const linker = this;</span><span class="s3">\n        </span><span class="s1">const reference = {</span><span class="s3">\n            </span><span class="s1">$refNode: refNode,</span><span class="s3">\n            </span><span class="s1">$refText: refText,</span><span class="s3">\n            </span><span class="s1">get ref() {</span><span class="s3">\n                </span><span class="s1">var _a;</span><span class="s3">\n                </span><span class="s1">if (isAstNode(this._ref)) {</span><span class="s3">\n                    </span><span class="s1">// Most frequent case: the target is already resolved.</span><span class="s3">\n                    </span><span class="s1">return this._ref;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (isAstNodeDescription(this._nodeDescription)) {</span><span class="s3">\n                    </span><span class="s1">// A candidate has been found before, but it is not loaded yet.</span><span class="s3">\n                    </span><span class="s1">const linkedNode = linker.loadAstNode(this._nodeDescription);</span><span class="s3">\n                    </span><span class="s1">this._ref = linkedNode !== null &amp;&amp; linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (this._ref === undefined) {</span><span class="s3">\n                    </span><span class="s1">// The reference has not been linked yet, so do that now.</span><span class="s3">\n                    </span><span class="s1">this._ref = ref_resolving;</span><span class="s3">\n                    </span><span class="s1">const document = findRootNode(node).$document;</span><span class="s3">\n                    </span><span class="s1">const refData = linker.getLinkedNode({ reference, container: node, property });</span><span class="s3">\n                    </span><span class="s1">if (refData.error &amp;&amp; document &amp;&amp; document.state &lt; DocumentState.ComputedScopes) {</span><span class="s3">\n                        </span><span class="s1">// Document scope is not ready, don't set `this._ref` so linker can retry later.</span><span class="s3">\n                        </span><span class="s1">return this._ref = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this._ref = (_a = refData.node) !== null &amp;&amp; _a !== void 0 ? _a : refData.error;</span><span class="s3">\n                    </span><span class="s1">this._nodeDescription = refData.descr;</span><span class="s3">\n                    </span><span class="s1">document === null || document === void 0 ? void 0 : document.references.push(this);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (this._ref === ref_resolving) {</span><span class="s3">\n                    </span><span class="s1">throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return isAstNode(this._ref) ? this._ref : undefined;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">get $nodeDescription() {</span><span class="s3">\n                </span><span class="s1">return this._nodeDescription;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">get error() {</span><span class="s3">\n                </span><span class="s1">return isLinkingError(this._ref) ? this._ref : undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return reference;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLinkedNode(refInfo) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const description = this.getCandidate(refInfo);</span><span class="s3">\n            </span><span class="s1">if (isLinkingError(description)) {</span><span class="s3">\n                </span><span class="s1">return { error: description };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const linkedNode = this.loadAstNode(description);</span><span class="s3">\n            </span><span class="s1">if (linkedNode) {</span><span class="s3">\n                </span><span class="s1">return { node: linkedNode, descr: description };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">descr: description,</span><span class="s3">\n                    </span><span class="s1">error: this.createLinkingError(refInfo, description)</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);</span><span class="s3">\n            </span><span class="s1">const errorMessage = (_a = err.message) !== null &amp;&amp; _a !== void 0 ? _a : String(err);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">loadAstNode(nodeDescription) {</span><span class="s3">\n        </span><span class="s1">if (nodeDescription.node) {</span><span class="s3">\n            </span><span class="s1">return nodeDescription.node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);</span><span class="s3">\n        </span><span class="s1">if (!doc) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createLinkingError(refInfo, targetDescription) {</span><span class="s3">\n        </span><span class="s1">// Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug</span><span class="s3">\n        </span><span class="s1">// in the language implementation.</span><span class="s3">\n        </span><span class="s1">const document = findRootNode(refInfo.container).$document;</span><span class="s3">\n        </span><span class="s1">if (document &amp;&amp; document.state &lt; DocumentState.ComputedScopes) {</span><span class="s3">\n            </span><span class="s1">console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const referenceType = this.reflection.getReferenceType(refInfo);</span><span class="s3">\n        </span><span class="s1">return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=linker.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { findNodeForProperty } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">export function isNamed(node) {</span><span class="s3">\n    </span><span class="s1">return typeof node.name === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class DefaultNameProvider {</span><span class="s3">\n    </span><span class="s1">getName(node) {</span><span class="s3">\n        </span><span class="s1">if (isNamed(node)) {</span><span class="s3">\n            </span><span class="s1">return node.name;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getNameNode(node) {</span><span class="s3">\n        </span><span class="s1">return findNodeForProperty(node.$cstNode, 'name');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=name-provider.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { URI, Utils } from 'vscode-uri';</span><span class="s3">\n</span><span class="s1">export { URI };</span><span class="s3">\n</span><span class="s1">export var UriUtils;</span><span class="s3">\n</span><span class="s1">(function (UriUtils) {</span><span class="s3">\n    </span><span class="s1">UriUtils.basename = Utils.basename;</span><span class="s3">\n    </span><span class="s1">UriUtils.dirname = Utils.dirname;</span><span class="s3">\n    </span><span class="s1">UriUtils.extname = Utils.extname;</span><span class="s3">\n    </span><span class="s1">UriUtils.joinPath = Utils.joinPath;</span><span class="s3">\n    </span><span class="s1">UriUtils.resolvePath = Utils.resolvePath;</span><span class="s3">\n    </span><span class="s1">function equals(a, b) {</span><span class="s3">\n        </span><span class="s1">return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">UriUtils.equals = equals;</span><span class="s3">\n    </span><span class="s1">function relative(from, to) {</span><span class="s3">\n        </span><span class="s1">const fromPath = typeof from === 'string' ? from : from.path;</span><span class="s3">\n        </span><span class="s1">const toPath = typeof to === 'string' ? to : to.path;</span><span class="s3">\n        </span><span class="s1">const fromParts = fromPath.split('/').filter(e =&gt; e.length &gt; 0);</span><span class="s3">\n        </span><span class="s1">const toParts = toPath.split('/').filter(e =&gt; e.length &gt; 0);</span><span class="s3">\n        </span><span class="s1">let i = 0;</span><span class="s3">\n        </span><span class="s1">for (; i &lt; fromParts.length; i++) {</span><span class="s3">\n            </span><span class="s1">if (fromParts[i] !== toParts[i]) {</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const backPart = '../'.repeat(fromParts.length - i);</span><span class="s3">\n        </span><span class="s1">const toPart = toParts.slice(i).join('/');</span><span class="s3">\n        </span><span class="s1">return backPart + toPart;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">UriUtils.relative = relative;</span><span class="s3">\n    </span><span class="s1">function normalize(uri) {</span><span class="s3">\n        </span><span class="s1">return URI.parse(uri.toString()).toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">UriUtils.normalize = normalize;</span><span class="s3">\n</span><span class="s1">})(UriUtils || (UriUtils = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=uri-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { findAssignment } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">import { isReference } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { getDocument } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { isChildNode, toDocumentSegment } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { UriUtils } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultReferences {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.nameProvider = services.references.NameProvider;</span><span class="s3">\n        </span><span class="s1">this.index = services.shared.workspace.IndexManager;</span><span class="s3">\n        </span><span class="s1">this.nodeLocator = services.workspace.AstNodeLocator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findDeclaration(sourceCstNode) {</span><span class="s3">\n        </span><span class="s1">if (sourceCstNode) {</span><span class="s3">\n            </span><span class="s1">const assignment = findAssignment(sourceCstNode);</span><span class="s3">\n            </span><span class="s1">const nodeElem = sourceCstNode.astNode;</span><span class="s3">\n            </span><span class="s1">if (assignment &amp;&amp; nodeElem) {</span><span class="s3">\n                </span><span class="s1">const reference = nodeElem[assignment.feature];</span><span class="s3">\n                </span><span class="s1">if (isReference(reference)) {</span><span class="s3">\n                    </span><span class="s1">return reference.ref;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (Array.isArray(reference)) {</span><span class="s3">\n                    </span><span class="s1">for (const ref of reference) {</span><span class="s3">\n                        </span><span class="s1">if (isReference(ref) &amp;&amp; ref.$refNode</span><span class="s3">\n                            </span><span class="s1">&amp;&amp; ref.$refNode.offset &lt;= sourceCstNode.offset</span><span class="s3">\n                            </span><span class="s1">&amp;&amp; ref.$refNode.end &gt;= sourceCstNode.end) {</span><span class="s3">\n                            </span><span class="s1">return ref.ref;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (nodeElem) {</span><span class="s3">\n                </span><span class="s1">const nameNode = this.nameProvider.getNameNode(nodeElem);</span><span class="s3">\n                </span><span class="s1">// Only return the targeted node in case the targeted cst node is the name node or part of it</span><span class="s3">\n                </span><span class="s1">if (nameNode &amp;&amp; (nameNode === sourceCstNode || isChildNode(sourceCstNode, nameNode))) {</span><span class="s3">\n                    </span><span class="s1">return nodeElem;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findDeclarationNode(sourceCstNode) {</span><span class="s3">\n        </span><span class="s1">const astNode = this.findDeclaration(sourceCstNode);</span><span class="s3">\n        </span><span class="s1">if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {</span><span class="s3">\n            </span><span class="s1">const targetNode = this.nameProvider.getNameNode(astNode);</span><span class="s3">\n            </span><span class="s1">return targetNode !== null &amp;&amp; targetNode !== void 0 ? targetNode : astNode.$cstNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findReferences(targetNode, options) {</span><span class="s3">\n        </span><span class="s1">const refs = [];</span><span class="s3">\n        </span><span class="s1">if (options.includeDeclaration) {</span><span class="s3">\n            </span><span class="s1">const ref = this.getReferenceToSelf(targetNode);</span><span class="s3">\n            </span><span class="s1">if (ref) {</span><span class="s3">\n                </span><span class="s1">refs.push(ref);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));</span><span class="s3">\n        </span><span class="s1">if (options.documentUri) {</span><span class="s3">\n            </span><span class="s1">indexReferences = indexReferences.filter(ref =&gt; UriUtils.equals(ref.sourceUri, options.documentUri));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">refs.push(...indexReferences);</span><span class="s3">\n        </span><span class="s1">return stream(refs);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getReferenceToSelf(targetNode) {</span><span class="s3">\n        </span><span class="s1">const nameNode = this.nameProvider.getNameNode(targetNode);</span><span class="s3">\n        </span><span class="s1">if (nameNode) {</span><span class="s3">\n            </span><span class="s1">const doc = getDocument(targetNode);</span><span class="s3">\n            </span><span class="s1">const path = this.nodeLocator.getAstNodePath(targetNode);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">sourceUri: doc.uri,</span><span class="s3">\n                </span><span class="s1">sourcePath: path,</span><span class="s3">\n                </span><span class="s1">targetUri: doc.uri,</span><span class="s3">\n                </span><span class="s1">targetPath: path,</span><span class="s3">\n                </span><span class="s1">segment: toDocumentSegment(nameNode),</span><span class="s3">\n                </span><span class="s1">local: true</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=references.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Reduction, stream } from './stream.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A multimap is a variation of a Map that has potentially multiple values for every key.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class MultiMap {</span><span class="s3">\n    </span><span class="s1">constructor(elements) {</span><span class="s3">\n        </span><span class="s1">this.map = new Map();</span><span class="s3">\n        </span><span class="s1">if (elements) {</span><span class="s3">\n            </span><span class="s1">for (const [key, value] of elements) {</span><span class="s3">\n                </span><span class="s1">this.add(key, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The total number of values in the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">return Reduction.sum(stream(this.map.values()).map(a =&gt; a.length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clear all entries in the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this.map.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Operates differently depending on whether a `value` is given:</span><span class="s3">\n     </span><span class="s1">*  * With a value, this method deletes the specific key / value pair from the multimap.</span><span class="s3">\n     </span><span class="s1">*  * Without a value, all values associated with the given key are deleted.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns `true` if a value existed and has been removed, or `false` if the specified</span><span class="s3">\n     </span><span class="s1">*     key / value does not exist.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">delete(key, value) {</span><span class="s3">\n        </span><span class="s1">if (value === undefined) {</span><span class="s3">\n            </span><span class="s1">return this.map.delete(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const values = this.map.get(key);</span><span class="s3">\n            </span><span class="s1">if (values) {</span><span class="s3">\n                </span><span class="s1">const index = values.indexOf(value);</span><span class="s3">\n                </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n                    </span><span class="s1">if (values.length === 1) {</span><span class="s3">\n                        </span><span class="s1">this.map.delete(key);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">values.splice(index, 1);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns an array of all values associated with the given key. If no value exists,</span><span class="s3">\n     </span><span class="s1">* an empty array is returned.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a</span><span class="s3">\n     </span><span class="s1">* value and `delete` to remove a value from the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get(key) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return (_a = this.map.get(key)) !== null &amp;&amp; _a !== void 0 ? _a : [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Operates differently depending on whether a `value` is given:</span><span class="s3">\n     </span><span class="s1">*  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.</span><span class="s3">\n     </span><span class="s1">*  * Without a value, this method returns `true` if the given key is present in the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">has(key, value) {</span><span class="s3">\n        </span><span class="s1">if (value === undefined) {</span><span class="s3">\n            </span><span class="s1">return this.map.has(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const values = this.map.get(key);</span><span class="s3">\n            </span><span class="s1">if (values) {</span><span class="s3">\n                </span><span class="s1">return values.indexOf(value) &gt;= 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add the given key / value pair to the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">add(key, value) {</span><span class="s3">\n        </span><span class="s1">if (this.map.has(key)) {</span><span class="s3">\n            </span><span class="s1">this.map.get(key).push(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.map.set(key, [value]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add the given set of key / value pairs to the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addAll(key, values) {</span><span class="s3">\n        </span><span class="s1">if (this.map.has(key)) {</span><span class="s3">\n            </span><span class="s1">this.map.get(key).push(...values);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.map.set(key, Array.from(values));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Invokes the given callback function for every key / value pair in the multimap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">forEach(callbackfn) {</span><span class="s3">\n        </span><span class="s1">this.map.forEach((array, key) =&gt; array.forEach(value =&gt; callbackfn(value, key, this)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns an iterator of key, value pairs for every entry in the map.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n        </span><span class="s1">return this.entries().iterator();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns a stream of key, value pairs for every entry in the map.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">entries() {</span><span class="s3">\n        </span><span class="s1">return stream(this.map.entries())</span><span class="s3">\n            </span><span class="s1">.flatMap(([key, array]) =&gt; array.map(value =&gt; [key, value]));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns a stream of keys in the map.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">keys() {</span><span class="s3">\n        </span><span class="s1">return stream(this.map.keys());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns a stream of values in the map.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">values() {</span><span class="s3">\n        </span><span class="s1">return stream(this.map.values()).flat();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns a stream of key, value set pairs for every key in the map.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">entriesGroupedByKey() {</span><span class="s3">\n        </span><span class="s1">return stream(this.map.entries());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class BiMap {</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">return this.map.size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(elements) {</span><span class="s3">\n        </span><span class="s1">this.map = new Map();</span><span class="s3">\n        </span><span class="s1">this.inverse = new Map();</span><span class="s3">\n        </span><span class="s1">if (elements) {</span><span class="s3">\n            </span><span class="s1">for (const [key, value] of elements) {</span><span class="s3">\n                </span><span class="s1">this.set(key, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this.map.clear();</span><span class="s3">\n        </span><span class="s1">this.inverse.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(key, value) {</span><span class="s3">\n        </span><span class="s1">this.map.set(key, value);</span><span class="s3">\n        </span><span class="s1">this.inverse.set(value, key);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get(key) {</span><span class="s3">\n        </span><span class="s1">return this.map.get(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getKey(value) {</span><span class="s3">\n        </span><span class="s1">return this.inverse.get(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete(key) {</span><span class="s3">\n        </span><span class="s1">const value = this.map.get(key);</span><span class="s3">\n        </span><span class="s1">if (value !== undefined) {</span><span class="s3">\n            </span><span class="s1">this.map.delete(key);</span><span class="s3">\n            </span><span class="s1">this.inverse.delete(value);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=collections.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021-2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { streamAllContents, streamContents } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { MultiMap } from '../utils/collections.js';</span><span class="s3">\n</span><span class="s1">import { interruptAndCheck } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The default scope computation creates and collectes descriptions of the AST nodes to be exported into the</span><span class="s3">\n </span><span class="s1">* _global_ scope from the given document. By default those are the document's root AST node and its directly</span><span class="s3">\n </span><span class="s1">* contained child nodes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them</span><span class="s3">\n </span><span class="s1">* in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,</span><span class="s3">\n </span><span class="s1">* target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)</span><span class="s3">\n </span><span class="s1">* are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)</span><span class="s3">\n </span><span class="s1">* are _invisible_ by default, but that can be changed by customizing this service.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DefaultScopeComputation {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.nameProvider = services.references.NameProvider;</span><span class="s3">\n        </span><span class="s1">this.descriptions = services.workspace.AstNodeDescriptionProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async computeExports(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.</span><span class="s3">\n     </span><span class="s1">* The list of children to be considered is determined by the function parameter {@link children}.</span><span class="s3">\n     </span><span class="s1">* By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.</span><span class="s3">\n     </span><span class="s1">* @param document The document containing the AST node to be exported.</span><span class="s3">\n     </span><span class="s1">* @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.</span><span class="s3">\n     </span><span class="s1">* @param cancelToken Indicates when to cancel the current operation.</span><span class="s3">\n     </span><span class="s1">* @throws `OperationCancelled` if a user action occurs during execution.</span><span class="s3">\n     </span><span class="s1">* @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async computeExportsForNode(parentNode, document, children = streamContents, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const exports = [];</span><span class="s3">\n        </span><span class="s1">this.exportNode(parentNode, exports, document);</span><span class="s3">\n        </span><span class="s1">for (const node of children(parentNode)) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">this.exportNode(node, exports, document);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return exports;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add a single node to the list of exports if it has a name. Override this method to change how</span><span class="s3">\n     </span><span class="s1">* symbols are exported, e.g. by modifying their exported name.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">exportNode(node, exports, document) {</span><span class="s3">\n        </span><span class="s1">const name = this.nameProvider.getName(node);</span><span class="s3">\n        </span><span class="s1">if (name) {</span><span class="s3">\n            </span><span class="s1">exports.push(this.descriptions.createDescription(node, name, document));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async computeLocalScopes(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const rootNode = document.parseResult.value;</span><span class="s3">\n        </span><span class="s1">const scopes = new MultiMap();</span><span class="s3">\n        </span><span class="s1">// Here we navigate the full AST - local scopes shall be available in the whole document</span><span class="s3">\n        </span><span class="s1">for (const node of streamAllContents(rootNode)) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">this.processNode(node, document, scopes);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return scopes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process a single node during scopes computation. The default implementation makes the node visible</span><span class="s3">\n     </span><span class="s1">* in the subtree of its container (if the node has a name). Override this method to change this,</span><span class="s3">\n     </span><span class="s1">* e.g. by increasing the visibility to a higher level in the AST.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">processNode(node, document, scopes) {</span><span class="s3">\n        </span><span class="s1">const container = node.$container;</span><span class="s3">\n        </span><span class="s1">if (container) {</span><span class="s3">\n            </span><span class="s1">const name = this.nameProvider.getName(node);</span><span class="s3">\n            </span><span class="s1">if (name) {</span><span class="s3">\n                </span><span class="s1">scopes.add(container, this.descriptions.createDescription(node, name, document));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=scope-computation.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { EMPTY_STREAM, stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing</span><span class="s3">\n </span><span class="s1">* the next level of elements, which are queried when a target element is not found in the stream provided</span><span class="s3">\n </span><span class="s1">* to this scope.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class StreamScope {</span><span class="s3">\n    </span><span class="s1">constructor(elements, outerScope, options) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.elements = elements;</span><span class="s3">\n        </span><span class="s1">this.outerScope = outerScope;</span><span class="s3">\n        </span><span class="s1">this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null &amp;&amp; _a !== void 0 ? _a : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAllElements() {</span><span class="s3">\n        </span><span class="s1">if (this.outerScope) {</span><span class="s3">\n            </span><span class="s1">return this.elements.concat(this.outerScope.getAllElements());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this.elements;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getElement(name) {</span><span class="s3">\n        </span><span class="s1">const local = this.caseInsensitive</span><span class="s3">\n            </span><span class="s1">? this.elements.find(e =&gt; e.name.toLowerCase() === name.toLowerCase())</span><span class="s3">\n            </span><span class="s1">: this.elements.find(e =&gt; e.name === name);</span><span class="s3">\n        </span><span class="s1">if (local) {</span><span class="s3">\n            </span><span class="s1">return local;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.outerScope) {</span><span class="s3">\n            </span><span class="s1">return this.outerScope.getElement(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class MapScope {</span><span class="s3">\n    </span><span class="s1">constructor(elements, outerScope, options) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.elements = new Map();</span><span class="s3">\n        </span><span class="s1">this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null &amp;&amp; _a !== void 0 ? _a : false;</span><span class="s3">\n        </span><span class="s1">for (const element of elements) {</span><span class="s3">\n            </span><span class="s1">const name = this.caseInsensitive</span><span class="s3">\n                </span><span class="s1">? element.name.toLowerCase()</span><span class="s3">\n                </span><span class="s1">: element.name;</span><span class="s3">\n            </span><span class="s1">this.elements.set(name, element);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.outerScope = outerScope;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getElement(name) {</span><span class="s3">\n        </span><span class="s1">const localName = this.caseInsensitive ? name.toLowerCase() : name;</span><span class="s3">\n        </span><span class="s1">const local = this.elements.get(localName);</span><span class="s3">\n        </span><span class="s1">if (local) {</span><span class="s3">\n            </span><span class="s1">return local;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.outerScope) {</span><span class="s3">\n            </span><span class="s1">return this.outerScope.getElement(name);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAllElements() {</span><span class="s3">\n        </span><span class="s1">let elementStream = stream(this.elements.values());</span><span class="s3">\n        </span><span class="s1">if (this.outerScope) {</span><span class="s3">\n            </span><span class="s1">elementStream = elementStream.concat(this.outerScope.getAllElements());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return elementStream;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const EMPTY_SCOPE = {</span><span class="s3">\n    </span><span class="s1">getElement() {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">getAllElements() {</span><span class="s3">\n        </span><span class="s1">return EMPTY_STREAM;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=scope.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export class DisposableCache {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.toDispose = [];</span><span class="s3">\n        </span><span class="s1">this.isDisposed = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onDispose(disposable) {</span><span class="s3">\n        </span><span class="s1">this.toDispose.push(disposable);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">this.clear();</span><span class="s3">\n        </span><span class="s1">this.isDisposed = true;</span><span class="s3">\n        </span><span class="s1">this.toDispose.forEach(disposable =&gt; disposable.dispose());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throwIfDisposed() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">throw new Error('This cache has already been disposed');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class SimpleCache extends DisposableCache {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.cache = new Map();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">has(key) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">return this.cache.has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(key, value) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">this.cache.set(key, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get(key, provider) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">if (this.cache.has(key)) {</span><span class="s3">\n            </span><span class="s1">return this.cache.get(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (provider) {</span><span class="s3">\n            </span><span class="s1">const value = provider();</span><span class="s3">\n            </span><span class="s1">this.cache.set(key, value);</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete(key) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">return this.cache.delete(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">this.cache.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class ContextCache extends DisposableCache {</span><span class="s3">\n    </span><span class="s1">constructor(converter) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.cache = new Map();</span><span class="s3">\n        </span><span class="s1">this.converter = converter !== null &amp;&amp; converter !== void 0 ? converter : (value =&gt; value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">has(contextKey, key) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">return this.cacheForContext(contextKey).has(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set(contextKey, key, value) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">this.cacheForContext(contextKey).set(key, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get(contextKey, key, provider) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">const contextCache = this.cacheForContext(contextKey);</span><span class="s3">\n        </span><span class="s1">if (contextCache.has(key)) {</span><span class="s3">\n            </span><span class="s1">return contextCache.get(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (provider) {</span><span class="s3">\n            </span><span class="s1">const value = provider();</span><span class="s3">\n            </span><span class="s1">contextCache.set(key, value);</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">delete(contextKey, key) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">return this.cacheForContext(contextKey).delete(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clear(contextKey) {</span><span class="s3">\n        </span><span class="s1">this.throwIfDisposed();</span><span class="s3">\n        </span><span class="s1">if (contextKey) {</span><span class="s3">\n            </span><span class="s1">const mapKey = this.converter(contextKey);</span><span class="s3">\n            </span><span class="s1">this.cache.delete(mapKey);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.cache.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cacheForContext(contextKey) {</span><span class="s3">\n        </span><span class="s1">const mapKey = this.converter(contextKey);</span><span class="s3">\n        </span><span class="s1">let documentCache = this.cache.get(mapKey);</span><span class="s3">\n        </span><span class="s1">if (!documentCache) {</span><span class="s3">\n            </span><span class="s1">documentCache = new Map();</span><span class="s3">\n            </span><span class="s1">this.cache.set(mapKey, documentCache);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return documentCache;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Every key/value pair in this cache is scoped to a document.</span><span class="s3">\n </span><span class="s1">* If this document is changed or deleted, all associated key/value pairs are deleted.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DocumentCache extends ContextCache {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new document cache.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param sharedServices Service container instance to hook into document lifecycle events.</span><span class="s3">\n     </span><span class="s1">* @param state Optional document state on which the cache should evict.</span><span class="s3">\n     </span><span class="s1">* If not provided, the cache will evict on `DocumentBuilder#onUpdate`.</span><span class="s3">\n     </span><span class="s1">* *Deleted* documents are considered in both cases.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,</span><span class="s3">\n     </span><span class="s1">* which triggers on all documents that have been affected by this change, assuming that the</span><span class="s3">\n     </span><span class="s1">* state is `DocumentState.Linked` or a later state.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(sharedServices, state) {</span><span class="s3">\n        </span><span class="s1">super(uri =&gt; uri.toString());</span><span class="s3">\n        </span><span class="s1">if (state) {</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document =&gt; {</span><span class="s3">\n                </span><span class="s1">this.clear(document.uri.toString());</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) =&gt; {</span><span class="s3">\n                </span><span class="s1">for (const uri of deleted) { // react only on deleted documents</span><span class="s3">\n                    </span><span class="s1">this.clear(uri);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) =&gt; {</span><span class="s3">\n                </span><span class="s1">const allUris = changed.concat(deleted); // react on both changed and deleted documents</span><span class="s3">\n                </span><span class="s1">for (const uri of allUris) {</span><span class="s3">\n                    </span><span class="s1">this.clear(uri);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Every key/value pair in this cache is scoped to the whole workspace.</span><span class="s3">\n </span><span class="s1">* If any document in the workspace is added, changed or deleted, the whole cache is evicted.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class WorkspaceCache extends SimpleCache {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a new workspace cache.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param sharedServices Service container instance to hook into document lifecycle events.</span><span class="s3">\n     </span><span class="s1">* @param state Optional document state on which the cache should evict.</span><span class="s3">\n     </span><span class="s1">* If not provided, the cache will evict on `DocumentBuilder#onUpdate`.</span><span class="s3">\n     </span><span class="s1">* *Deleted* documents are considered in both cases.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(sharedServices, state) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">if (state) {</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () =&gt; {</span><span class="s3">\n                </span><span class="s1">this.clear();</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (deleted.length &gt; 0) { // react only on deleted documents</span><span class="s3">\n                    </span><span class="s1">this.clear();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.clear();</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=caching.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021-2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { MapScope, StreamScope } from './scope.js';</span><span class="s3">\n</span><span class="s1">import { getDocument } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { WorkspaceCache } from '../utils/caching.js';</span><span class="s3">\n</span><span class="s1">export class DefaultScopeProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.reflection = services.shared.AstReflection;</span><span class="s3">\n        </span><span class="s1">this.nameProvider = services.references.NameProvider;</span><span class="s3">\n        </span><span class="s1">this.descriptions = services.workspace.AstNodeDescriptionProvider;</span><span class="s3">\n        </span><span class="s1">this.indexManager = services.shared.workspace.IndexManager;</span><span class="s3">\n        </span><span class="s1">this.globalScopeCache = new WorkspaceCache(services.shared);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getScope(context) {</span><span class="s3">\n        </span><span class="s1">const scopes = [];</span><span class="s3">\n        </span><span class="s1">const referenceType = this.reflection.getReferenceType(context);</span><span class="s3">\n        </span><span class="s1">const precomputed = getDocument(context.container).precomputedScopes;</span><span class="s3">\n        </span><span class="s1">if (precomputed) {</span><span class="s3">\n            </span><span class="s1">let currentNode = context.container;</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">const allDescriptions = precomputed.get(currentNode);</span><span class="s3">\n                </span><span class="s1">if (allDescriptions.length &gt; 0) {</span><span class="s3">\n                    </span><span class="s1">scopes.push(stream(allDescriptions).filter(desc =&gt; this.reflection.isSubtype(desc.type, referenceType)));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">currentNode = currentNode.$container;</span><span class="s3">\n            </span><span class="s1">} while (currentNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let result = this.getGlobalScope(referenceType, context);</span><span class="s3">\n        </span><span class="s1">for (let i = scopes.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">result = this.createScope(scopes[i], result);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a scope for the given collection of AST node descriptions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createScope(elements, outerScope, options) {</span><span class="s3">\n        </span><span class="s1">return new StreamScope(stream(elements), outerScope, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a scope for the given collection of AST nodes, which need to be transformed into respective</span><span class="s3">\n     </span><span class="s1">* descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createScopeForNodes(elements, outerScope, options) {</span><span class="s3">\n        </span><span class="s1">const s = stream(elements).map(e =&gt; {</span><span class="s3">\n            </span><span class="s1">const name = this.nameProvider.getName(e);</span><span class="s3">\n            </span><span class="s1">if (name) {</span><span class="s3">\n                </span><span class="s1">return this.descriptions.createDescription(e, name);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}).nonNullable();</span><span class="s3">\n        </span><span class="s1">return new StreamScope(s, outerScope, options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a global scope filtered for the given reference type.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getGlobalScope(referenceType, _context) {</span><span class="s3">\n        </span><span class="s1">return this.globalScopeCache.get(referenceType, () =&gt; new MapScope(this.indexManager.allElements(referenceType)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=scope-provider.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { URI } from 'vscode-uri';</span><span class="s3">\n</span><span class="s1">import { isAstNode, isReference } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { getDocument } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { findNodesForProperty } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">export function isAstNodeWithComment(node) {</span><span class="s3">\n    </span><span class="s1">return typeof node.$comment === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isIntermediateReference(obj) {</span><span class="s3">\n    </span><span class="s1">return typeof obj === 'object' &amp;&amp; !!obj &amp;&amp; ('$ref' in obj || '$error' in obj);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class DefaultJsonSerializer {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">/** The set of AstNode properties to be ignored by the serializer. */</span><span class="s3">\n        </span><span class="s1">this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);</span><span class="s3">\n        </span><span class="s1">this.langiumDocuments = services.shared.workspace.LangiumDocuments;</span><span class="s3">\n        </span><span class="s1">this.astNodeLocator = services.workspace.AstNodeLocator;</span><span class="s3">\n        </span><span class="s1">this.nameProvider = services.references.NameProvider;</span><span class="s3">\n        </span><span class="s1">this.commentProvider = services.documentation.CommentProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">serialize(node, options) {</span><span class="s3">\n        </span><span class="s1">const serializeOptions = options !== null &amp;&amp; options !== void 0 ? options : {};</span><span class="s3">\n        </span><span class="s1">const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;</span><span class="s3">\n        </span><span class="s1">const defaultReplacer = (key, value) =&gt; this.replacer(key, value, serializeOptions);</span><span class="s3">\n        </span><span class="s1">const replacer = specificReplacer ? (key, value) =&gt; specificReplacer(key, value, defaultReplacer) : defaultReplacer;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.currentDocument = getDocument(node);</span><span class="s3">\n            </span><span class="s1">return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">this.currentDocument = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">deserialize(content, options) {</span><span class="s3">\n        </span><span class="s1">const deserializeOptions = options !== null &amp;&amp; options !== void 0 ? options : {};</span><span class="s3">\n        </span><span class="s1">const root = JSON.parse(content);</span><span class="s3">\n        </span><span class="s1">this.linkNode(root, root, deserializeOptions);</span><span class="s3">\n        </span><span class="s1">return root;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c, _d;</span><span class="s3">\n        </span><span class="s1">if (this.ignoreProperties.has(key)) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isReference(value)) {</span><span class="s3">\n            </span><span class="s1">const refValue = value.ref;</span><span class="s3">\n            </span><span class="s1">const $refText = refText ? value.$refText : undefined;</span><span class="s3">\n            </span><span class="s1">if (refValue) {</span><span class="s3">\n                </span><span class="s1">const targetDocument = getDocument(refValue);</span><span class="s3">\n                </span><span class="s1">let targetUri = '';</span><span class="s3">\n                </span><span class="s1">if (this.currentDocument &amp;&amp; this.currentDocument !== targetDocument) {</span><span class="s3">\n                    </span><span class="s1">if (uriConverter) {</span><span class="s3">\n                        </span><span class="s1">targetUri = uriConverter(targetDocument.uri, value);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">targetUri = targetDocument.uri.toString();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const targetPath = this.astNodeLocator.getAstNodePath(refValue);</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">$ref: `${targetUri}#${targetPath}`,</span><span class="s3">\n                    </span><span class="s1">$refText</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">$error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null &amp;&amp; _b !== void 0 ? _b : 'Could not resolve reference',</span><span class="s3">\n                    </span><span class="s1">$refText</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isAstNode(value)) {</span><span class="s3">\n            </span><span class="s1">let astNode = undefined;</span><span class="s3">\n            </span><span class="s1">if (textRegions) {</span><span class="s3">\n                </span><span class="s1">astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));</span><span class="s3">\n                </span><span class="s1">if ((!key || value.$document) &amp;&amp; (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {</span><span class="s3">\n                    </span><span class="s1">// The document URI is added to the root node of the resulting JSON tree</span><span class="s3">\n                    </span><span class="s1">astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (sourceText &amp;&amp; !key) {</span><span class="s3">\n                </span><span class="s1">astNode !== null &amp;&amp; astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));</span><span class="s3">\n                </span><span class="s1">astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (comments) {</span><span class="s3">\n                </span><span class="s1">astNode !== null &amp;&amp; astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));</span><span class="s3">\n                </span><span class="s1">const comment = this.commentProvider.getComment(value);</span><span class="s3">\n                </span><span class="s1">if (comment) {</span><span class="s3">\n                    </span><span class="s1">astNode.$comment = comment.replace(/</span><span class="s3">\\</span><span class="s1">r/g, '');</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return astNode !== null &amp;&amp; astNode !== void 0 ? astNode : value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addAstNodeRegionWithAssignmentsTo(node) {</span><span class="s3">\n        </span><span class="s1">const createDocumentSegment = cstNode =&gt; ({</span><span class="s3">\n            </span><span class="s1">offset: cstNode.offset,</span><span class="s3">\n            </span><span class="s1">end: cstNode.end,</span><span class="s3">\n            </span><span class="s1">length: cstNode.length,</span><span class="s3">\n            </span><span class="s1">range: cstNode.range,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (node.$cstNode) {</span><span class="s3">\n            </span><span class="s1">const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);</span><span class="s3">\n            </span><span class="s1">const assignments = textRegion.assignments = {};</span><span class="s3">\n            </span><span class="s1">Object.keys(node).filter(key =&gt; !key.startsWith('$')).forEach(key =&gt; {</span><span class="s3">\n                </span><span class="s1">const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);</span><span class="s3">\n                </span><span class="s1">if (propertyAssignments.length !== 0) {</span><span class="s3">\n                    </span><span class="s1">assignments[key] = propertyAssignments;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">linkNode(node, root, options, container, containerProperty, containerIndex) {</span><span class="s3">\n        </span><span class="s1">for (const [propertyName, item] of Object.entries(node)) {</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(item)) {</span><span class="s3">\n                </span><span class="s1">for (let index = 0; index &lt; item.length; index++) {</span><span class="s3">\n                    </span><span class="s1">const element = item[index];</span><span class="s3">\n                    </span><span class="s1">if (isIntermediateReference(element)) {</span><span class="s3">\n                        </span><span class="s1">item[index] = this.reviveReference(node, propertyName, root, element, options);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (isAstNode(element)) {</span><span class="s3">\n                        </span><span class="s1">this.linkNode(element, root, options, node, propertyName, index);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isIntermediateReference(item)) {</span><span class="s3">\n                </span><span class="s1">node[propertyName] = this.reviveReference(node, propertyName, root, item, options);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isAstNode(item)) {</span><span class="s3">\n                </span><span class="s1">this.linkNode(item, root, options, node, propertyName);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const mutable = node;</span><span class="s3">\n        </span><span class="s1">mutable.$container = container;</span><span class="s3">\n        </span><span class="s1">mutable.$containerProperty = containerProperty;</span><span class="s3">\n        </span><span class="s1">mutable.$containerIndex = containerIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reviveReference(container, property, root, reference, options) {</span><span class="s3">\n        </span><span class="s1">let refText = reference.$refText;</span><span class="s3">\n        </span><span class="s1">let error = reference.$error;</span><span class="s3">\n        </span><span class="s1">if (reference.$ref) {</span><span class="s3">\n            </span><span class="s1">const ref = this.getRefNode(root, reference.$ref, options.uriConverter);</span><span class="s3">\n            </span><span class="s1">if (isAstNode(ref)) {</span><span class="s3">\n                </span><span class="s1">if (!refText) {</span><span class="s3">\n                    </span><span class="s1">refText = this.nameProvider.getName(ref);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">$refText: refText !== null &amp;&amp; refText !== void 0 ? refText : '',</span><span class="s3">\n                    </span><span class="s1">ref</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">error = ref;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (error) {</span><span class="s3">\n            </span><span class="s1">const ref = {</span><span class="s3">\n                </span><span class="s1">$refText: refText !== null &amp;&amp; refText !== void 0 ? refText : ''</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">ref.error = {</span><span class="s3">\n                </span><span class="s1">container,</span><span class="s3">\n                </span><span class="s1">property,</span><span class="s3">\n                </span><span class="s1">message: error,</span><span class="s3">\n                </span><span class="s1">reference: ref</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">return ref;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getRefNode(root, uri, uriConverter) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">const fragmentIndex = uri.indexOf('#');</span><span class="s3">\n            </span><span class="s1">if (fragmentIndex === 0) {</span><span class="s3">\n                </span><span class="s1">const node = this.astNodeLocator.getAstNode(root, uri.substring(1));</span><span class="s3">\n                </span><span class="s1">if (!node) {</span><span class="s3">\n                    </span><span class="s1">return 'Could not resolve path: ' + uri;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return node;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (fragmentIndex &lt; 0) {</span><span class="s3">\n                </span><span class="s1">const documentUri = uriConverter ? uriConverter(uri) : URI.parse(uri);</span><span class="s3">\n                </span><span class="s1">const document = this.langiumDocuments.getDocument(documentUri);</span><span class="s3">\n                </span><span class="s1">if (!document) {</span><span class="s3">\n                    </span><span class="s1">return 'Could not find document for URI: ' + uri;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return document.parseResult.value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : URI.parse(uri.substring(0, fragmentIndex));</span><span class="s3">\n            </span><span class="s1">const document = this.langiumDocuments.getDocument(documentUri);</span><span class="s3">\n            </span><span class="s1">if (!document) {</span><span class="s3">\n                </span><span class="s1">return 'Could not find document for URI: ' + uri;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (fragmentIndex === uri.length - 1) {</span><span class="s3">\n                </span><span class="s1">return document.parseResult.value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));</span><span class="s3">\n            </span><span class="s1">if (!node) {</span><span class="s3">\n                </span><span class="s1">return 'Could not resolve URI: ' + uri;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">return String(err);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=json-serializer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { UriUtils } from './utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DefaultServiceRegistry {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get map() {</span><span class="s3">\n        </span><span class="s1">return this.fileExtensionMap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.languageIdMap = new Map();</span><span class="s3">\n        </span><span class="s1">this.fileExtensionMap = new Map();</span><span class="s3">\n        </span><span class="s1">this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">register(language) {</span><span class="s3">\n        </span><span class="s1">const data = language.LanguageMetaData;</span><span class="s3">\n        </span><span class="s1">for (const ext of data.fileExtensions) {</span><span class="s3">\n            </span><span class="s1">if (this.fileExtensionMap.has(ext)) {</span><span class="s3">\n                </span><span class="s1">console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.fileExtensionMap.set(ext, language);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.languageIdMap.set(data.languageId, language);</span><span class="s3">\n        </span><span class="s1">if (this.languageIdMap.size === 1) {</span><span class="s3">\n            </span><span class="s1">this.singleton = language;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.singleton = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getServices(uri) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">if (this.singleton !== undefined) {</span><span class="s3">\n            </span><span class="s1">return this.singleton;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.languageIdMap.size === 0) {</span><span class="s3">\n            </span><span class="s1">throw new Error('The service registry is empty. Use `register` to register the services of a language.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;</span><span class="s3">\n        </span><span class="s1">if (languageId !== undefined) {</span><span class="s3">\n            </span><span class="s1">const services = this.languageIdMap.get(languageId);</span><span class="s3">\n            </span><span class="s1">if (services) {</span><span class="s3">\n                </span><span class="s1">return services;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const ext = UriUtils.extname(uri);</span><span class="s3">\n        </span><span class="s1">const services = this.fileExtensionMap.get(ext);</span><span class="s3">\n        </span><span class="s1">if (!services) {</span><span class="s3">\n            </span><span class="s1">if (languageId) {</span><span class="s3">\n                </span><span class="s1">throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">throw new Error(`The service registry contains no services for the extension '${ext}'.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return services;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasServices(uri) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">this.getServices(uri);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (_a) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get all() {</span><span class="s3">\n        </span><span class="s1">return Array.from(this.languageIdMap.values());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=service-registry.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { assertUnreachable } from '../index.js';</span><span class="s3">\n</span><span class="s1">import { MultiMap } from '../utils/collections.js';</span><span class="s3">\n</span><span class="s1">import { isOperationCancelled } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function diagnosticData(code) {</span><span class="s3">\n    </span><span class="s1">return { code };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var ValidationCategory;</span><span class="s3">\n</span><span class="s1">(function (ValidationCategory) {</span><span class="s3">\n    </span><span class="s1">ValidationCategory.all = ['fast', 'slow', 'built-in'];</span><span class="s3">\n</span><span class="s1">})(ValidationCategory || (ValidationCategory = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Manages a set of `ValidationCheck`s to be applied when documents are validated.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ValidationRegistry {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.entries = new MultiMap();</span><span class="s3">\n        </span><span class="s1">this.entriesBefore = [];</span><span class="s3">\n        </span><span class="s1">this.entriesAfter = [];</span><span class="s3">\n        </span><span class="s1">this.reflection = services.shared.AstReflection;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)</span><span class="s3">\n     </span><span class="s1">* or an array of validation checks.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param checksRecord Set of validation checks to register.</span><span class="s3">\n     </span><span class="s1">* @param category Optional category for the validation checks (defaults to `'fast'`).</span><span class="s3">\n     </span><span class="s1">* @param thisObj Optional object to be used as `this` when calling the validation check functions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">register(checksRecord, thisObj = this, category = 'fast') {</span><span class="s3">\n        </span><span class="s1">if (category === 'built-in') {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">The 'built-in' category is reserved for lexer, parser, and linker errors.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const [type, ch] of Object.entries(checksRecord)) {</span><span class="s3">\n            </span><span class="s1">const callbacks = ch;</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(callbacks)) {</span><span class="s3">\n                </span><span class="s1">for (const check of callbacks) {</span><span class="s3">\n                    </span><span class="s1">const entry = {</span><span class="s3">\n                        </span><span class="s1">check: this.wrapValidationException(check, thisObj),</span><span class="s3">\n                        </span><span class="s1">category</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">this.addEntry(type, entry);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (typeof callbacks === 'function') {</span><span class="s3">\n                </span><span class="s1">const entry = {</span><span class="s3">\n                    </span><span class="s1">check: this.wrapValidationException(callbacks, thisObj),</span><span class="s3">\n                    </span><span class="s1">category</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this.addEntry(type, entry);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">assertUnreachable(callbacks);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapValidationException(check, thisObj) {</span><span class="s3">\n        </span><span class="s1">return async (node, accept, cancelToken) =&gt; {</span><span class="s3">\n            </span><span class="s1">await this.handleException(() =&gt; check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async handleException(functionality, messageContext, accept, node) {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">await functionality();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">if (isOperationCancelled(err)) {</span><span class="s3">\n                </span><span class="s1">throw err;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">console.error(`${messageContext}:`, err);</span><span class="s3">\n            </span><span class="s1">if (err instanceof Error &amp;&amp; err.stack) {</span><span class="s3">\n                </span><span class="s1">console.error(err.stack);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const messageDetails = err instanceof Error ? err.message : String(err);</span><span class="s3">\n            </span><span class="s1">accept('error', `${messageContext}: ${messageDetails}`, { node });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addEntry(type, entry) {</span><span class="s3">\n        </span><span class="s1">if (type === 'AstNode') {</span><span class="s3">\n            </span><span class="s1">this.entries.add('AstNode', entry);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const subtype of this.reflection.getAllSubTypes(type)) {</span><span class="s3">\n            </span><span class="s1">this.entries.add(subtype, entry);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getChecks(type, categories) {</span><span class="s3">\n        </span><span class="s1">let checks = stream(this.entries.get(type))</span><span class="s3">\n            </span><span class="s1">.concat(this.entries.get('AstNode'));</span><span class="s3">\n        </span><span class="s1">if (categories) {</span><span class="s3">\n            </span><span class="s1">checks = checks.filter(entry =&gt; categories.includes(entry.category));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return checks.map(entry =&gt; entry.check);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Register logic which will be executed once before validating all the nodes of an AST/Langium document.</span><span class="s3">\n     </span><span class="s1">* This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* As an example, for validating unique fully-qualified names of nodes in the AST,</span><span class="s3">\n     </span><span class="s1">* here the map for mapping names to nodes could be established.</span><span class="s3">\n     </span><span class="s1">* During the usual checks on the nodes, they are put into this map with their name.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.</span><span class="s3">\n     </span><span class="s1">* Therefore it is recommended to clear stored information</span><span class="s3">\n     </span><span class="s1">* _before_ validating an AST to validate each AST unaffected from other ASTs</span><span class="s3">\n     </span><span class="s1">* AND _after_ validating the AST to free memory by information which are no longer used.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param checkBefore a set-up function which will be called once before actually validating an AST</span><span class="s3">\n     </span><span class="s1">* @param thisObj Optional object to be used as `this` when calling the validation check functions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">registerBeforeDocument(checkBefore, thisObj = this) {</span><span class="s3">\n        </span><span class="s1">this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Register logic which will be executed once after validating all the nodes of an AST/Langium document.</span><span class="s3">\n     </span><span class="s1">* This helps to finally evaluate information which are collected during the checks on the AstNodes.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* As an example, for validating unique fully-qualified names of nodes in the AST,</span><span class="s3">\n     </span><span class="s1">* here the map with all the collected nodes and their names is checked</span><span class="s3">\n     </span><span class="s1">* and validation hints are created for all nodes with the same name.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.</span><span class="s3">\n     </span><span class="s1">* Therefore it is recommended to clear stored information</span><span class="s3">\n     </span><span class="s1">* _before_ validating an AST to validate each AST unaffected from other ASTs</span><span class="s3">\n     </span><span class="s1">* AND _after_ validating the AST to free memory by information which are no longer used.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param checkBefore a set-up function which will be called once before actually validating an AST</span><span class="s3">\n     </span><span class="s1">* @param thisObj Optional object to be used as `this` when calling the validation check functions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">registerAfterDocument(checkAfter, thisObj = this) {</span><span class="s3">\n        </span><span class="s1">this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">wrapPreparationException(check, messageContext, thisObj) {</span><span class="s3">\n        </span><span class="s1">return async (rootNode, accept, categories, cancelToken) =&gt; {</span><span class="s3">\n            </span><span class="s1">await this.handleException(() =&gt; check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get checksBefore() {</span><span class="s3">\n        </span><span class="s1">return this.entriesBefore;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get checksAfter() {</span><span class="s3">\n        </span><span class="s1">return this.entriesAfter;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=validation-registry.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">import { streamAst } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { tokenToRange } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">import { interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { diagnosticData } from './validation-registry.js';</span><span class="s3">\n</span><span class="s1">export class DefaultDocumentValidator {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.validationRegistry = services.validation.ValidationRegistry;</span><span class="s3">\n        </span><span class="s1">this.metadata = services.LanguageMetaData;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async validateDocument(document, options = {}, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const parseResult = document.parseResult;</span><span class="s3">\n        </span><span class="s1">const diagnostics = [];</span><span class="s3">\n        </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n        </span><span class="s1">if (!options.categories || options.categories.includes('built-in')) {</span><span class="s3">\n            </span><span class="s1">this.processLexingErrors(parseResult, diagnostics, options);</span><span class="s3">\n            </span><span class="s1">if (options.stopAfterLexingErrors &amp;&amp; diagnostics.some(d =&gt; { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {</span><span class="s3">\n                </span><span class="s1">return diagnostics;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.processParsingErrors(parseResult, diagnostics, options);</span><span class="s3">\n            </span><span class="s1">if (options.stopAfterParsingErrors &amp;&amp; diagnostics.some(d =&gt; { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {</span><span class="s3">\n                </span><span class="s1">return diagnostics;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.processLinkingErrors(document, diagnostics, options);</span><span class="s3">\n            </span><span class="s1">if (options.stopAfterLinkingErrors &amp;&amp; diagnostics.some(d =&gt; { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {</span><span class="s3">\n                </span><span class="s1">return diagnostics;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Process custom validations</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">if (isOperationCancelled(err)) {</span><span class="s3">\n                </span><span class="s1">throw err;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">console.error('An error occurred during validation:', err);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n        </span><span class="s1">return diagnostics;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processLexingErrors(parseResult, diagnostics, _options) {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null &amp;&amp; _b !== void 0 ? _b : []];</span><span class="s3">\n        </span><span class="s1">for (const lexerDiagnostic of lexerDiagnostics) {</span><span class="s3">\n            </span><span class="s1">const severity = (_c = lexerDiagnostic.severity) !== null &amp;&amp; _c !== void 0 ? _c : 'error';</span><span class="s3">\n            </span><span class="s1">const diagnostic = {</span><span class="s3">\n                </span><span class="s1">severity: toDiagnosticSeverity(severity),</span><span class="s3">\n                </span><span class="s1">range: {</span><span class="s3">\n                    </span><span class="s1">start: {</span><span class="s3">\n                        </span><span class="s1">line: lexerDiagnostic.line - 1,</span><span class="s3">\n                        </span><span class="s1">character: lexerDiagnostic.column - 1</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">end: {</span><span class="s3">\n                        </span><span class="s1">line: lexerDiagnostic.line - 1,</span><span class="s3">\n                        </span><span class="s1">character: lexerDiagnostic.column + lexerDiagnostic.length - 1</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">message: lexerDiagnostic.message,</span><span class="s3">\n                </span><span class="s1">data: toDiagnosticData(severity),</span><span class="s3">\n                </span><span class="s1">source: this.getSource()</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">diagnostics.push(diagnostic);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processParsingErrors(parseResult, diagnostics, _options) {</span><span class="s3">\n        </span><span class="s1">for (const parserError of parseResult.parserErrors) {</span><span class="s3">\n            </span><span class="s1">let range = undefined;</span><span class="s3">\n            </span><span class="s1">// We can run into the chevrotain error recovery here</span><span class="s3">\n            </span><span class="s1">// The token contained in the parser error might be automatically inserted</span><span class="s3">\n            </span><span class="s1">// In this case every position value will be `NaN`</span><span class="s3">\n            </span><span class="s1">if (isNaN(parserError.token.startOffset)) {</span><span class="s3">\n                </span><span class="s1">// Some special parser error types contain a `previousToken`</span><span class="s3">\n                </span><span class="s1">// We can simply append our diagnostic to that token</span><span class="s3">\n                </span><span class="s1">if ('previousToken' in parserError) {</span><span class="s3">\n                    </span><span class="s1">const token = parserError.previousToken;</span><span class="s3">\n                    </span><span class="s1">if (!isNaN(token.startOffset)) {</span><span class="s3">\n                        </span><span class="s1">const position = { line: token.endLine - 1, character: token.endColumn };</span><span class="s3">\n                        </span><span class="s1">range = { start: position, end: position };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// No valid prev token. Might be empty document or containing only hidden tokens.</span><span class="s3">\n                        </span><span class="s1">// Point to document start</span><span class="s3">\n                        </span><span class="s1">const position = { line: 0, character: 0 };</span><span class="s3">\n                        </span><span class="s1">range = { start: position, end: position };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">range = tokenToRange(parserError.token);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (range) {</span><span class="s3">\n                </span><span class="s1">const diagnostic = {</span><span class="s3">\n                    </span><span class="s1">severity: toDiagnosticSeverity('error'),</span><span class="s3">\n                    </span><span class="s1">range,</span><span class="s3">\n                    </span><span class="s1">message: parserError.message,</span><span class="s3">\n                    </span><span class="s1">data: diagnosticData(DocumentValidator.ParsingError),</span><span class="s3">\n                    </span><span class="s1">source: this.getSource()</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">diagnostics.push(diagnostic);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">processLinkingErrors(document, diagnostics, _options) {</span><span class="s3">\n        </span><span class="s1">for (const reference of document.references) {</span><span class="s3">\n            </span><span class="s1">const linkingError = reference.error;</span><span class="s3">\n            </span><span class="s1">if (linkingError) {</span><span class="s3">\n                </span><span class="s1">const info = {</span><span class="s3">\n                    </span><span class="s1">node: linkingError.container,</span><span class="s3">\n                    </span><span class="s1">property: linkingError.property,</span><span class="s3">\n                    </span><span class="s1">index: linkingError.index,</span><span class="s3">\n                    </span><span class="s1">data: {</span><span class="s3">\n                        </span><span class="s1">code: DocumentValidator.LinkingError,</span><span class="s3">\n                        </span><span class="s1">containerType: linkingError.container.$type,</span><span class="s3">\n                        </span><span class="s1">property: linkingError.property,</span><span class="s3">\n                        </span><span class="s1">refText: linkingError.reference.$refText</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">diagnostics.push(this.toDiagnostic('error', linkingError.message, info));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async validateAst(rootNode, options, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const validationItems = [];</span><span class="s3">\n        </span><span class="s1">const acceptor = (severity, message, info) =&gt; {</span><span class="s3">\n            </span><span class="s1">validationItems.push(this.toDiagnostic(severity, message, info));</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">await this.validateAstBefore(rootNode, options, acceptor, cancelToken);</span><span class="s3">\n        </span><span class="s1">await this.validateAstNodes(rootNode, options, acceptor, cancelToken);</span><span class="s3">\n        </span><span class="s1">await this.validateAstAfter(rootNode, options, acceptor, cancelToken);</span><span class="s3">\n        </span><span class="s1">return validationItems;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async validateAstBefore(rootNode, options, acceptor, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const checksBefore = this.validationRegistry.checksBefore;</span><span class="s3">\n        </span><span class="s1">for (const checkBefore of checksBefore) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">await checkBefore(rootNode, acceptor, (_a = options.categories) !== null &amp;&amp; _a !== void 0 ? _a : [], cancelToken);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async validateAstNodes(rootNode, options, acceptor, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">await Promise.all(streamAst(rootNode).map(async (node) =&gt; {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">const checks = this.validationRegistry.getChecks(node.$type, options.categories);</span><span class="s3">\n            </span><span class="s1">for (const check of checks) {</span><span class="s3">\n                </span><span class="s1">await check(node, acceptor, cancelToken);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async validateAstAfter(rootNode, options, acceptor, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const checksAfter = this.validationRegistry.checksAfter;</span><span class="s3">\n        </span><span class="s1">for (const checkAfter of checksAfter) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">await checkAfter(rootNode, acceptor, (_a = options.categories) !== null &amp;&amp; _a !== void 0 ? _a : [], cancelToken);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toDiagnostic(severity, message, info) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">message,</span><span class="s3">\n            </span><span class="s1">range: getDiagnosticRange(info),</span><span class="s3">\n            </span><span class="s1">severity: toDiagnosticSeverity(severity),</span><span class="s3">\n            </span><span class="s1">code: info.code,</span><span class="s3">\n            </span><span class="s1">codeDescription: info.codeDescription,</span><span class="s3">\n            </span><span class="s1">tags: info.tags,</span><span class="s3">\n            </span><span class="s1">relatedInformation: info.relatedInformation,</span><span class="s3">\n            </span><span class="s1">data: info.data,</span><span class="s3">\n            </span><span class="s1">source: this.getSource()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getSource() {</span><span class="s3">\n        </span><span class="s1">return this.metadata.languageId;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getDiagnosticRange(info) {</span><span class="s3">\n    </span><span class="s1">if (info.range) {</span><span class="s3">\n        </span><span class="s1">return info.range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let cstNode;</span><span class="s3">\n    </span><span class="s1">if (typeof info.property === 'string') {</span><span class="s3">\n        </span><span class="s1">cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (typeof info.keyword === 'string') {</span><span class="s3">\n        </span><span class="s1">cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cstNode !== null &amp;&amp; cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);</span><span class="s3">\n    </span><span class="s1">if (!cstNode) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">start: { line: 0, character: 0 },</span><span class="s3">\n            </span><span class="s1">end: { line: 0, character: 0 }</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cstNode.range;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param severity The lexing diagnostic severity</span><span class="s3">\n </span><span class="s1">* @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function toDiagnosticSeverity(severity) {</span><span class="s3">\n    </span><span class="s1">switch (severity) {</span><span class="s3">\n        </span><span class="s1">case 'error':</span><span class="s3">\n            </span><span class="s1">return 1;</span><span class="s3">\n        </span><span class="s1">case 'warning':</span><span class="s3">\n            </span><span class="s1">return 2;</span><span class="s3">\n        </span><span class="s1">case 'info':</span><span class="s3">\n            </span><span class="s1">return 3;</span><span class="s3">\n        </span><span class="s1">case 'hint':</span><span class="s3">\n            </span><span class="s1">return 4;</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid diagnostic severity: ' + severity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function toDiagnosticData(severity) {</span><span class="s3">\n    </span><span class="s1">switch (severity) {</span><span class="s3">\n        </span><span class="s1">case 'error':</span><span class="s3">\n            </span><span class="s1">return diagnosticData(DocumentValidator.LexingError);</span><span class="s3">\n        </span><span class="s1">case 'warning':</span><span class="s3">\n            </span><span class="s1">return diagnosticData(DocumentValidator.LexingWarning);</span><span class="s3">\n        </span><span class="s1">case 'info':</span><span class="s3">\n            </span><span class="s1">return diagnosticData(DocumentValidator.LexingInfo);</span><span class="s3">\n        </span><span class="s1">case 'hint':</span><span class="s3">\n            </span><span class="s1">return diagnosticData(DocumentValidator.LexingHint);</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid diagnostic severity: ' + severity);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var DocumentValidator;</span><span class="s3">\n</span><span class="s1">(function (DocumentValidator) {</span><span class="s3">\n    </span><span class="s1">DocumentValidator.LexingError = 'lexing-error';</span><span class="s3">\n    </span><span class="s1">DocumentValidator.LexingWarning = 'lexing-warning';</span><span class="s3">\n    </span><span class="s1">DocumentValidator.LexingInfo = 'lexing-info';</span><span class="s3">\n    </span><span class="s1">DocumentValidator.LexingHint = 'lexing-hint';</span><span class="s3">\n    </span><span class="s1">DocumentValidator.ParsingError = 'parsing-error';</span><span class="s3">\n    </span><span class="s1">DocumentValidator.LinkingError = 'linking-error';</span><span class="s3">\n</span><span class="s1">})(DocumentValidator || (DocumentValidator = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=document-validator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { isLinkingError } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { getDocument, streamAst, streamReferences } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { toDocumentSegment } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">import { interruptAndCheck } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { UriUtils } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultAstNodeDescriptionProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.astNodeLocator = services.workspace.AstNodeLocator;</span><span class="s3">\n        </span><span class="s1">this.nameProvider = services.references.NameProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createDescription(node, name, document) {</span><span class="s3">\n        </span><span class="s1">const doc = document !== null &amp;&amp; document !== void 0 ? document : getDocument(node);</span><span class="s3">\n        </span><span class="s1">name !== null &amp;&amp; name !== void 0 ? name : (name = this.nameProvider.getName(node));</span><span class="s3">\n        </span><span class="s1">const path = this.astNodeLocator.getAstNodePath(node);</span><span class="s3">\n        </span><span class="s1">if (!name) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`Node at path ${path} has no name.`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let nameNodeSegment;</span><span class="s3">\n        </span><span class="s1">const nameSegmentGetter = () =&gt; { var _a; return nameNodeSegment !== null &amp;&amp; nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = toDocumentSegment((_a = this.nameProvider.getNameNode(node)) !== null &amp;&amp; _a !== void 0 ? _a : node.$cstNode)); };</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">node,</span><span class="s3">\n            </span><span class="s1">name,</span><span class="s3">\n            </span><span class="s1">get nameSegment() {</span><span class="s3">\n                </span><span class="s1">return nameSegmentGetter();</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">selectionSegment: toDocumentSegment(node.$cstNode),</span><span class="s3">\n            </span><span class="s1">type: node.$type,</span><span class="s3">\n            </span><span class="s1">documentUri: doc.uri,</span><span class="s3">\n            </span><span class="s1">path</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class DefaultReferenceDescriptionProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.nodeLocator = services.workspace.AstNodeLocator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async createDescriptions(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const descr = [];</span><span class="s3">\n        </span><span class="s1">const rootNode = document.parseResult.value;</span><span class="s3">\n        </span><span class="s1">for (const astNode of streamAst(rootNode)) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">streamReferences(astNode).filter(refInfo =&gt; !isLinkingError(refInfo)).forEach(refInfo =&gt; {</span><span class="s3">\n                </span><span class="s1">// TODO: Consider logging a warning or throw an exception when DocumentState is &lt; than Linked</span><span class="s3">\n                </span><span class="s1">const description = this.createDescription(refInfo);</span><span class="s3">\n                </span><span class="s1">if (description) {</span><span class="s3">\n                    </span><span class="s1">descr.push(description);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return descr;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createDescription(refInfo) {</span><span class="s3">\n        </span><span class="s1">const targetNodeDescr = refInfo.reference.$nodeDescription;</span><span class="s3">\n        </span><span class="s1">const refCstNode = refInfo.reference.$refNode;</span><span class="s3">\n        </span><span class="s1">if (!targetNodeDescr || !refCstNode) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const docUri = getDocument(refInfo.container).uri;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">sourceUri: docUri,</span><span class="s3">\n            </span><span class="s1">sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),</span><span class="s3">\n            </span><span class="s1">targetUri: targetNodeDescr.documentUri,</span><span class="s3">\n            </span><span class="s1">targetPath: targetNodeDescr.path,</span><span class="s3">\n            </span><span class="s1">segment: toDocumentSegment(refCstNode),</span><span class="s3">\n            </span><span class="s1">local: UriUtils.equals(targetNodeDescr.documentUri, docUri)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ast-descriptions.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export class DefaultAstNodeLocator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.segmentSeparator = '/';</span><span class="s3">\n        </span><span class="s1">this.indexSeparator = '@';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAstNodePath(node) {</span><span class="s3">\n        </span><span class="s1">if (node.$container) {</span><span class="s3">\n            </span><span class="s1">const containerPath = this.getAstNodePath(node.$container);</span><span class="s3">\n            </span><span class="s1">const newSegment = this.getPathSegment(node);</span><span class="s3">\n            </span><span class="s1">const nodePath = containerPath + this.segmentSeparator + newSegment;</span><span class="s3">\n            </span><span class="s1">return nodePath;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getPathSegment({ $containerProperty, $containerIndex }) {</span><span class="s3">\n        </span><span class="s1">if (!$containerProperty) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Missing '$containerProperty' in AST node.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if ($containerIndex !== undefined) {</span><span class="s3">\n            </span><span class="s1">return $containerProperty + this.indexSeparator + $containerIndex;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return $containerProperty;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAstNode(node, path) {</span><span class="s3">\n        </span><span class="s1">const segments = path.split(this.segmentSeparator);</span><span class="s3">\n        </span><span class="s1">return segments.reduce((previousValue, currentValue) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!previousValue || currentValue.length === 0) {</span><span class="s3">\n                </span><span class="s1">return previousValue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const propertyIndex = currentValue.indexOf(this.indexSeparator);</span><span class="s3">\n            </span><span class="s1">if (propertyIndex &gt; 0) {</span><span class="s3">\n                </span><span class="s1">const property = currentValue.substring(0, propertyIndex);</span><span class="s3">\n                </span><span class="s1">const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));</span><span class="s3">\n                </span><span class="s1">const array = previousValue[property];</span><span class="s3">\n                </span><span class="s1">return array === null || array === void 0 ? void 0 : array[arrayIndex];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return previousValue[currentValue];</span><span class="s3">\n        </span><span class="s1">}, node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ast-node-locator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Emitter } from '../utils/event.js';</span><span class="s3">\n</span><span class="s1">import { Deferred } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Base configuration provider for building up other configuration providers</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DefaultConfigurationProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this._ready = new Deferred();</span><span class="s3">\n        </span><span class="s1">this.settings = {};</span><span class="s3">\n        </span><span class="s1">this.workspaceConfig = false;</span><span class="s3">\n        </span><span class="s1">this.onConfigurationSectionUpdateEmitter = new Emitter();</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get ready() {</span><span class="s3">\n        </span><span class="s1">return this._ready.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initialize(params) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null &amp;&amp; _b !== void 0 ? _b : false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async initialized(params) {</span><span class="s3">\n        </span><span class="s1">if (this.workspaceConfig) {</span><span class="s3">\n            </span><span class="s1">if (params.register) {</span><span class="s3">\n                </span><span class="s1">// params.register(...) is a function to be provided by the calling language server for the sake of</span><span class="s3">\n                </span><span class="s1">//  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection</span><span class="s3">\n                </span><span class="s1">const languages = this.serviceRegistry.all;</span><span class="s3">\n                </span><span class="s1">params.register({</span><span class="s3">\n                    </span><span class="s1">// Listen to configuration changes for all languages</span><span class="s3">\n                    </span><span class="s1">section: languages.map(lang =&gt; this.toSectionName(lang.LanguageMetaData.languageId))</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (params.fetchConfiguration) {</span><span class="s3">\n                </span><span class="s1">// params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of</span><span class="s3">\n                </span><span class="s1">//  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection</span><span class="s3">\n                </span><span class="s1">const configToUpdate = this.serviceRegistry.all.map(lang =&gt; ({</span><span class="s3">\n                    </span><span class="s1">// Fetch the configuration changes for all languages</span><span class="s3">\n                    </span><span class="s1">section: this.toSectionName(lang.LanguageMetaData.languageId)</span><span class="s3">\n                </span><span class="s1">}));</span><span class="s3">\n                </span><span class="s1">// get workspace configurations (default scope URI)</span><span class="s3">\n                </span><span class="s1">const configs = await params.fetchConfiguration(configToUpdate);</span><span class="s3">\n                </span><span class="s1">configToUpdate.forEach((conf, idx) =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.updateSectionConfiguration(conf.section, configs[idx]);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._ready.resolve();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">*  Updates the cached configurations using the `change` notification parameters.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param change The parameters of a change configuration notification.</span><span class="s3">\n     </span><span class="s1">* `settings` property of the change object could be expressed as `Record&lt;string, Record&lt;string, any&gt;&gt;`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateConfiguration(change) {</span><span class="s3">\n        </span><span class="s1">if (!change.settings) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">Object.keys(change.settings).forEach(section =&gt; {</span><span class="s3">\n            </span><span class="s1">const configuration = change.settings[section];</span><span class="s3">\n            </span><span class="s1">this.updateSectionConfiguration(section, configuration);</span><span class="s3">\n            </span><span class="s1">this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateSectionConfiguration(section, configuration) {</span><span class="s3">\n        </span><span class="s1">this.settings[section] = configuration;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">* Returns a configuration value stored for the given language.</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">* @param language The language id</span><span class="s3">\n    </span><span class="s1">* @param configuration Configuration name</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async getConfiguration(language, configuration) {</span><span class="s3">\n        </span><span class="s1">await this.ready;</span><span class="s3">\n        </span><span class="s1">const sectionName = this.toSectionName(language);</span><span class="s3">\n        </span><span class="s1">if (this.settings[sectionName]) {</span><span class="s3">\n            </span><span class="s1">return this.settings[sectionName][configuration];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toSectionName(languageId) {</span><span class="s3">\n        </span><span class="s1">return `${languageId}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onConfigurationSectionUpdate() {</span><span class="s3">\n        </span><span class="s1">return this.onConfigurationSectionUpdateEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=configuration.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export var Disposable;</span><span class="s3">\n</span><span class="s1">(function (Disposable) {</span><span class="s3">\n    </span><span class="s1">function create(callback) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">dispose: async () =&gt; await callback()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Disposable.create = create;</span><span class="s3">\n</span><span class="s1">})(Disposable || (Disposable = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=disposable.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { Disposable } from '../utils/disposable.js';</span><span class="s3">\n</span><span class="s1">import { MultiMap } from '../utils/collections.js';</span><span class="s3">\n</span><span class="s1">import { OperationCancelled, interruptAndCheck, isOperationCancelled } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { ValidationCategory } from '../validation/validation-registry.js';</span><span class="s3">\n</span><span class="s1">import { DocumentState } from './documents.js';</span><span class="s3">\n</span><span class="s1">export class DefaultDocumentBuilder {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.updateBuildOptions = {</span><span class="s3">\n            </span><span class="s1">// Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)</span><span class="s3">\n            </span><span class="s1">validation: {</span><span class="s3">\n                </span><span class="s1">categories: ['built-in', 'fast']</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.updateListeners = [];</span><span class="s3">\n        </span><span class="s1">this.buildPhaseListeners = new MultiMap();</span><span class="s3">\n        </span><span class="s1">this.documentPhaseListeners = new MultiMap();</span><span class="s3">\n        </span><span class="s1">this.buildState = new Map();</span><span class="s3">\n        </span><span class="s1">this.documentBuildWaiters = new Map();</span><span class="s3">\n        </span><span class="s1">this.currentState = DocumentState.Changed;</span><span class="s3">\n        </span><span class="s1">this.langiumDocuments = services.workspace.LangiumDocuments;</span><span class="s3">\n        </span><span class="s1">this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;</span><span class="s3">\n        </span><span class="s1">this.textDocuments = services.workspace.TextDocuments;</span><span class="s3">\n        </span><span class="s1">this.indexManager = services.workspace.IndexManager;</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async build(documents, options = {}, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">for (const document of documents) {</span><span class="s3">\n            </span><span class="s1">const key = document.uri.toString();</span><span class="s3">\n            </span><span class="s1">if (document.state === DocumentState.Validated) {</span><span class="s3">\n                </span><span class="s1">if (typeof options.validation === 'boolean' &amp;&amp; options.validation) {</span><span class="s3">\n                    </span><span class="s1">// Force re-running all validation checks</span><span class="s3">\n                    </span><span class="s1">document.state = DocumentState.IndexedReferences;</span><span class="s3">\n                    </span><span class="s1">document.diagnostics = undefined;</span><span class="s3">\n                    </span><span class="s1">this.buildState.delete(key);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (typeof options.validation === 'object') {</span><span class="s3">\n                    </span><span class="s1">const buildState = this.buildState.get(key);</span><span class="s3">\n                    </span><span class="s1">const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;</span><span class="s3">\n                    </span><span class="s1">if (previousCategories) {</span><span class="s3">\n                        </span><span class="s1">// Validation with explicit options was requested for a document that has already been partly validated.</span><span class="s3">\n                        </span><span class="s1">// In this case, we need to merge the previous validation categories with the new ones.</span><span class="s3">\n                        </span><span class="s1">const newCategories = (_b = options.validation.categories) !== null &amp;&amp; _b !== void 0 ? _b : ValidationCategory.all;</span><span class="s3">\n                        </span><span class="s1">const categories = newCategories.filter(c =&gt; !previousCategories.includes(c));</span><span class="s3">\n                        </span><span class="s1">if (categories.length &gt; 0) {</span><span class="s3">\n                            </span><span class="s1">this.buildState.set(key, {</span><span class="s3">\n                                </span><span class="s1">completed: false,</span><span class="s3">\n                                </span><span class="s1">options: {</span><span class="s3">\n                                    </span><span class="s1">validation: Object.assign(Object.assign({}, options.validation), { categories })</span><span class="s3">\n                                </span><span class="s1">},</span><span class="s3">\n                                </span><span class="s1">result: buildState.result</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                            </span><span class="s1">document.state = DocumentState.IndexedReferences;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// Default: forget any previous build options</span><span class="s3">\n                </span><span class="s1">this.buildState.delete(key);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.currentState = DocumentState.Changed;</span><span class="s3">\n        </span><span class="s1">await this.emitUpdate(documents.map(e =&gt; e.uri), []);</span><span class="s3">\n        </span><span class="s1">await this.buildDocuments(documents, options, cancelToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async update(changed, deleted, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">this.currentState = DocumentState.Changed;</span><span class="s3">\n        </span><span class="s1">// Remove all metadata of documents that are reported as deleted</span><span class="s3">\n        </span><span class="s1">for (const deletedUri of deleted) {</span><span class="s3">\n            </span><span class="s1">this.langiumDocuments.deleteDocument(deletedUri);</span><span class="s3">\n            </span><span class="s1">this.buildState.delete(deletedUri.toString());</span><span class="s3">\n            </span><span class="s1">this.indexManager.remove(deletedUri);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set the state of all changed documents to `Changed` so they are completely rebuilt</span><span class="s3">\n        </span><span class="s1">for (const changedUri of changed) {</span><span class="s3">\n            </span><span class="s1">const invalidated = this.langiumDocuments.invalidateDocument(changedUri);</span><span class="s3">\n            </span><span class="s1">if (!invalidated) {</span><span class="s3">\n                </span><span class="s1">// We create an unparsed, invalid document.</span><span class="s3">\n                </span><span class="s1">// This will be parsed as soon as we reach the first document builder phase.</span><span class="s3">\n                </span><span class="s1">// This allows to cancel the parsing process later in case we need it.</span><span class="s3">\n                </span><span class="s1">const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);</span><span class="s3">\n                </span><span class="s1">newDocument.state = DocumentState.Changed;</span><span class="s3">\n                </span><span class="s1">this.langiumDocuments.addDocument(newDocument);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.buildState.delete(changedUri.toString());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)</span><span class="s3">\n        </span><span class="s1">const allChangedUris = stream(changed).concat(deleted).map(uri =&gt; uri.toString()).toSet();</span><span class="s3">\n        </span><span class="s1">this.langiumDocuments.all</span><span class="s3">\n            </span><span class="s1">.filter(doc =&gt; !allChangedUris.has(doc.uri.toString()) &amp;&amp; this.shouldRelink(doc, allChangedUris))</span><span class="s3">\n            </span><span class="s1">.forEach(doc =&gt; {</span><span class="s3">\n            </span><span class="s1">const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;</span><span class="s3">\n            </span><span class="s1">linker.unlink(doc);</span><span class="s3">\n            </span><span class="s1">doc.state = Math.min(doc.state, DocumentState.ComputedScopes);</span><span class="s3">\n            </span><span class="s1">doc.diagnostics = undefined;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Notify listeners of the update</span><span class="s3">\n        </span><span class="s1">await this.emitUpdate(changed, deleted);</span><span class="s3">\n        </span><span class="s1">// Only allow interrupting the execution after all state changes are done</span><span class="s3">\n        </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n        </span><span class="s1">// Collect and sort all documents that we should rebuild</span><span class="s3">\n        </span><span class="s1">const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all</span><span class="s3">\n            </span><span class="s1">.filter(doc =&gt; {</span><span class="s3">\n            </span><span class="s1">var _a;</span><span class="s3">\n            </span><span class="s1">// This includes those that were reported as changed and those that we selected for relinking</span><span class="s3">\n            </span><span class="s1">return doc.state &lt; DocumentState.Linked</span><span class="s3">\n                </span><span class="s1">// This includes those for which a previous build has been cancelled</span><span class="s3">\n                </span><span class="s1">|| !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n            </span><span class="s1">.toArray());</span><span class="s3">\n        </span><span class="s1">await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async emitUpdate(changed, deleted) {</span><span class="s3">\n        </span><span class="s1">await Promise.all(this.updateListeners.map(listener =&gt; listener(changed, deleted)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Sort the given documents by priority. By default, documents with an open text document are prioritized.</span><span class="s3">\n     </span><span class="s1">* This is useful to ensure that visible documents show their diagnostics before all other documents.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This improves the responsiveness in large workspaces as users usually don't care about diagnostics</span><span class="s3">\n     </span><span class="s1">* in files that are currently not opened in the editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sortDocuments(documents) {</span><span class="s3">\n        </span><span class="s1">let left = 0;</span><span class="s3">\n        </span><span class="s1">let right = documents.length - 1;</span><span class="s3">\n        </span><span class="s1">while (left &lt; right) {</span><span class="s3">\n            </span><span class="s1">while (left &lt; documents.length &amp;&amp; this.hasTextDocument(documents[left])) {</span><span class="s3">\n                </span><span class="s1">left++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">while (right &gt;= 0 &amp;&amp; !this.hasTextDocument(documents[right])) {</span><span class="s3">\n                </span><span class="s1">right--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (left &lt; right) {</span><span class="s3">\n                </span><span class="s1">[documents[left], documents[right]] = [documents[right], documents[left]];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return documents;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasTextDocument(doc) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Check whether the given document should be relinked after changes were found in the given URIs.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">shouldRelink(document, changedUris) {</span><span class="s3">\n        </span><span class="s1">// Relink documents with linking errors -- maybe those references can be resolved now</span><span class="s3">\n        </span><span class="s1">if (document.references.some(ref =&gt; ref.error !== undefined)) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check whether the document is affected by any of the changed URIs</span><span class="s3">\n        </span><span class="s1">return this.indexManager.isAffected(document, changedUris);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onUpdate(callback) {</span><span class="s3">\n        </span><span class="s1">this.updateListeners.push(callback);</span><span class="s3">\n        </span><span class="s1">return Disposable.create(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const index = this.updateListeners.indexOf(callback);</span><span class="s3">\n            </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">this.updateListeners.splice(index, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Build the given documents by stepping through all build phases. If a document's state indicates</span><span class="s3">\n     </span><span class="s1">* that a certain build phase is already done, the phase is skipped for that document.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param documents The documents to build.</span><span class="s3">\n     </span><span class="s1">* @param options the {@link BuildOptions} to use.</span><span class="s3">\n     </span><span class="s1">* @param cancelToken A cancellation token that can be used to cancel the build.</span><span class="s3">\n     </span><span class="s1">* @returns A promise that resolves when the build is done.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async buildDocuments(documents, options, cancelToken) {</span><span class="s3">\n        </span><span class="s1">this.prepareBuild(documents, options);</span><span class="s3">\n        </span><span class="s1">// 0. Parse content</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc =&gt; this.langiumDocumentFactory.update(doc, cancelToken));</span><span class="s3">\n        </span><span class="s1">// 1. Index content</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc =&gt; this.indexManager.updateContent(doc, cancelToken));</span><span class="s3">\n        </span><span class="s1">// 2. Compute scopes</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async (doc) =&gt; {</span><span class="s3">\n            </span><span class="s1">const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;</span><span class="s3">\n            </span><span class="s1">doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// 3. Linking</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc =&gt; {</span><span class="s3">\n            </span><span class="s1">const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;</span><span class="s3">\n            </span><span class="s1">return linker.link(doc, cancelToken);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// 4. Index references</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc =&gt; this.indexManager.updateReferences(doc, cancelToken));</span><span class="s3">\n        </span><span class="s1">// 5. Validation</span><span class="s3">\n        </span><span class="s1">const toBeValidated = documents.filter(doc =&gt; this.shouldValidate(doc));</span><span class="s3">\n        </span><span class="s1">await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc =&gt; this.validate(doc, cancelToken));</span><span class="s3">\n        </span><span class="s1">// If we've made it to this point without being cancelled, we can mark the build state as completed.</span><span class="s3">\n        </span><span class="s1">for (const doc of documents) {</span><span class="s3">\n            </span><span class="s1">const state = this.buildState.get(doc.uri.toString());</span><span class="s3">\n            </span><span class="s1">if (state) {</span><span class="s3">\n                </span><span class="s1">state.completed = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param documents collection of documents to be built</span><span class="s3">\n     </span><span class="s1">* @param options the {@link BuildOptions} to use</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">prepareBuild(documents, options) {</span><span class="s3">\n        </span><span class="s1">for (const doc of documents) {</span><span class="s3">\n            </span><span class="s1">const key = doc.uri.toString();</span><span class="s3">\n            </span><span class="s1">const state = this.buildState.get(key);</span><span class="s3">\n            </span><span class="s1">// If the document has no previous build state, we set it. If it has one, but it's already marked</span><span class="s3">\n            </span><span class="s1">// as completed, we overwrite it. If the previous build was not completed, we keep its state</span><span class="s3">\n            </span><span class="s1">// and continue where it was cancelled.</span><span class="s3">\n            </span><span class="s1">if (!state || state.completed) {</span><span class="s3">\n                </span><span class="s1">this.buildState.set(key, {</span><span class="s3">\n                    </span><span class="s1">completed: false,</span><span class="s3">\n                    </span><span class="s1">options,</span><span class="s3">\n                    </span><span class="s1">result: state === null || state === void 0 ? void 0 : state.result</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param documents The array of documents to process.</span><span class="s3">\n     </span><span class="s1">* @param targetState The target {@link DocumentState} to bring the documents to.</span><span class="s3">\n     </span><span class="s1">* @param cancelToken A token that can be used to cancel the operation.</span><span class="s3">\n     </span><span class="s1">* @param callback A function to be called for each document.</span><span class="s3">\n     </span><span class="s1">* @returns A promise that resolves when all documents have been processed or the operation is canceled.</span><span class="s3">\n     </span><span class="s1">* @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async runCancelable(documents, targetState, cancelToken, callback) {</span><span class="s3">\n        </span><span class="s1">const filtered = documents.filter(doc =&gt; doc.state &lt; targetState);</span><span class="s3">\n        </span><span class="s1">for (const document of filtered) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">await callback(document);</span><span class="s3">\n            </span><span class="s1">document.state = targetState;</span><span class="s3">\n            </span><span class="s1">await this.notifyDocumentPhase(document, targetState, cancelToken);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Do not use `filtered` here, as that will miss documents that have previously reached the current target state</span><span class="s3">\n        </span><span class="s1">// For example, this happens in case the cancellation triggers between the processing of two documents</span><span class="s3">\n        </span><span class="s1">// Or files that were picked up during the workspace initialization</span><span class="s3">\n        </span><span class="s1">const targetStateDocs = documents.filter(doc =&gt; doc.state === targetState);</span><span class="s3">\n        </span><span class="s1">await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);</span><span class="s3">\n        </span><span class="s1">this.currentState = targetState;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onBuildPhase(targetState, callback) {</span><span class="s3">\n        </span><span class="s1">this.buildPhaseListeners.add(targetState, callback);</span><span class="s3">\n        </span><span class="s1">return Disposable.create(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.buildPhaseListeners.delete(targetState, callback);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onDocumentPhase(targetState, callback) {</span><span class="s3">\n        </span><span class="s1">this.documentPhaseListeners.add(targetState, callback);</span><span class="s3">\n        </span><span class="s1">return Disposable.create(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.documentPhaseListeners.delete(targetState, callback);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">waitUntil(state, uriOrToken, cancelToken) {</span><span class="s3">\n        </span><span class="s1">let uri = undefined;</span><span class="s3">\n        </span><span class="s1">if (uriOrToken &amp;&amp; 'path' in uriOrToken) {</span><span class="s3">\n            </span><span class="s1">uri = uriOrToken;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">cancelToken = uriOrToken;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cancelToken !== null &amp;&amp; cancelToken !== void 0 ? cancelToken : (cancelToken = CancellationToken.None);</span><span class="s3">\n        </span><span class="s1">if (uri) {</span><span class="s3">\n            </span><span class="s1">const document = this.langiumDocuments.getDocument(uri);</span><span class="s3">\n            </span><span class="s1">if (document &amp;&amp; document.state &gt; state) {</span><span class="s3">\n                </span><span class="s1">return Promise.resolve(uri);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.currentState &gt;= state) {</span><span class="s3">\n            </span><span class="s1">return Promise.resolve(undefined);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (cancelToken.isCancellationRequested) {</span><span class="s3">\n            </span><span class="s1">return Promise.reject(OperationCancelled);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Promise((resolve, reject) =&gt; {</span><span class="s3">\n            </span><span class="s1">const buildDisposable = this.onBuildPhase(state, () =&gt; {</span><span class="s3">\n                </span><span class="s1">buildDisposable.dispose();</span><span class="s3">\n                </span><span class="s1">cancelDisposable.dispose();</span><span class="s3">\n                </span><span class="s1">if (uri) {</span><span class="s3">\n                    </span><span class="s1">const document = this.langiumDocuments.getDocument(uri);</span><span class="s3">\n                    </span><span class="s1">resolve(document === null || document === void 0 ? void 0 : document.uri);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">resolve(undefined);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">const cancelDisposable = cancelToken.onCancellationRequested(() =&gt; {</span><span class="s3">\n                </span><span class="s1">buildDisposable.dispose();</span><span class="s3">\n                </span><span class="s1">cancelDisposable.dispose();</span><span class="s3">\n                </span><span class="s1">reject(OperationCancelled);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async notifyDocumentPhase(document, state, cancelToken) {</span><span class="s3">\n        </span><span class="s1">const listeners = this.documentPhaseListeners.get(state);</span><span class="s3">\n        </span><span class="s1">const listenersCopy = listeners.slice();</span><span class="s3">\n        </span><span class="s1">for (const listener of listenersCopy) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">await listener(document, cancelToken);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">// Ignore cancellation errors</span><span class="s3">\n                </span><span class="s1">// We want to finish the listeners before throwing</span><span class="s3">\n                </span><span class="s1">if (!isOperationCancelled(err)) {</span><span class="s3">\n                    </span><span class="s1">throw err;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async notifyBuildPhase(documents, state, cancelToken) {</span><span class="s3">\n        </span><span class="s1">if (documents.length === 0) {</span><span class="s3">\n            </span><span class="s1">// Don't notify when no document has been processed</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const listeners = this.buildPhaseListeners.get(state);</span><span class="s3">\n        </span><span class="s1">const listenersCopy = listeners.slice();</span><span class="s3">\n        </span><span class="s1">for (const listener of listenersCopy) {</span><span class="s3">\n            </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n            </span><span class="s1">await listener(documents, cancelToken);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Determine whether the given document should be validated during a build. The default</span><span class="s3">\n     </span><span class="s1">* implementation checks the `validation` property of the build options. If it's set to `true`</span><span class="s3">\n     </span><span class="s1">* or a `ValidationOptions` object, the document is included in the validation phase.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">shouldValidate(document) {</span><span class="s3">\n        </span><span class="s1">return Boolean(this.getBuildOptions(document).validation);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Run validation checks on the given document and store the resulting diagnostics in the document.</span><span class="s3">\n     </span><span class="s1">* If the document already contains diagnostics, the new ones are added to the list.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async validate(document, cancelToken) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;</span><span class="s3">\n        </span><span class="s1">const validationSetting = this.getBuildOptions(document).validation;</span><span class="s3">\n        </span><span class="s1">const options = typeof validationSetting === 'object' ? validationSetting : undefined;</span><span class="s3">\n        </span><span class="s1">const diagnostics = await validator.validateDocument(document, options, cancelToken);</span><span class="s3">\n        </span><span class="s1">if (document.diagnostics) {</span><span class="s3">\n            </span><span class="s1">document.diagnostics.push(...diagnostics);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">document.diagnostics = diagnostics;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Store information about the executed validation in the build state</span><span class="s3">\n        </span><span class="s1">const state = this.buildState.get(document.uri.toString());</span><span class="s3">\n        </span><span class="s1">if (state) {</span><span class="s3">\n            </span><span class="s1">(_a = state.result) !== null &amp;&amp; _a !== void 0 ? _a : (state.result = {});</span><span class="s3">\n            </span><span class="s1">const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null &amp;&amp; _b !== void 0 ? _b : ValidationCategory.all;</span><span class="s3">\n            </span><span class="s1">if (state.result.validationChecks) {</span><span class="s3">\n                </span><span class="s1">state.result.validationChecks.push(...newCategories);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">state.result.validationChecks = [...newCategories];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getBuildOptions(document) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null &amp;&amp; _b !== void 0 ? _b : {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=document-builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { getDocument } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { ContextCache } from '../utils/caching.js';</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">import { UriUtils } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultIndexManager {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The symbol index stores all `AstNodeDescription` items exported by a document.</span><span class="s3">\n         </span><span class="s1">* The key used in this map is the string representation of the specific document URI.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.symbolIndex = new Map();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* This is a cache for the `allElements()` method.</span><span class="s3">\n         </span><span class="s1">* It caches the descriptions from `symbolIndex` grouped by types.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.symbolByTypeIndex = new ContextCache();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* This index keeps track of all `ReferenceDescription` items exported by a document.</span><span class="s3">\n         </span><span class="s1">* This is used to compute which elements are affected by a document change</span><span class="s3">\n         </span><span class="s1">* and for finding references to an AST node.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.referenceIndex = new Map();</span><span class="s3">\n        </span><span class="s1">this.documents = services.workspace.LangiumDocuments;</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n        </span><span class="s1">this.astReflection = services.AstReflection;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findAllReferences(targetNode, astNodePath) {</span><span class="s3">\n        </span><span class="s1">const targetDocUri = getDocument(targetNode).uri;</span><span class="s3">\n        </span><span class="s1">const result = [];</span><span class="s3">\n        </span><span class="s1">this.referenceIndex.forEach(docRefs =&gt; {</span><span class="s3">\n            </span><span class="s1">docRefs.forEach(refDescr =&gt; {</span><span class="s3">\n                </span><span class="s1">if (UriUtils.equals(refDescr.targetUri, targetDocUri) &amp;&amp; refDescr.targetPath === astNodePath) {</span><span class="s3">\n                    </span><span class="s1">result.push(refDescr);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return stream(result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">allElements(nodeType, uris) {</span><span class="s3">\n        </span><span class="s1">let documentUris = stream(this.symbolIndex.keys());</span><span class="s3">\n        </span><span class="s1">if (uris) {</span><span class="s3">\n            </span><span class="s1">documentUris = documentUris.filter(uri =&gt; !uris || uris.has(uri));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return documentUris</span><span class="s3">\n            </span><span class="s1">.map(uri =&gt; this.getFileDescriptions(uri, nodeType))</span><span class="s3">\n            </span><span class="s1">.flat();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getFileDescriptions(uri, nodeType) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!nodeType) {</span><span class="s3">\n            </span><span class="s1">return (_a = this.symbolIndex.get(uri)) !== null &amp;&amp; _a !== void 0 ? _a : [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () =&gt; {</span><span class="s3">\n            </span><span class="s1">var _a;</span><span class="s3">\n            </span><span class="s1">const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null &amp;&amp; _a !== void 0 ? _a : [];</span><span class="s3">\n            </span><span class="s1">return allFileDescriptions.filter(e =&gt; this.astReflection.isSubtype(e.type, nodeType));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return descriptions;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(uri) {</span><span class="s3">\n        </span><span class="s1">const uriString = uri.toString();</span><span class="s3">\n        </span><span class="s1">this.symbolIndex.delete(uriString);</span><span class="s3">\n        </span><span class="s1">this.symbolByTypeIndex.clear(uriString);</span><span class="s3">\n        </span><span class="s1">this.referenceIndex.delete(uriString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async updateContent(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const services = this.serviceRegistry.getServices(document.uri);</span><span class="s3">\n        </span><span class="s1">const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);</span><span class="s3">\n        </span><span class="s1">const uri = document.uri.toString();</span><span class="s3">\n        </span><span class="s1">this.symbolIndex.set(uri, exports);</span><span class="s3">\n        </span><span class="s1">this.symbolByTypeIndex.clear(uri);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async updateReferences(document, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const services = this.serviceRegistry.getServices(document.uri);</span><span class="s3">\n        </span><span class="s1">const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);</span><span class="s3">\n        </span><span class="s1">this.referenceIndex.set(document.uri.toString(), indexData);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isAffected(document, changedUris) {</span><span class="s3">\n        </span><span class="s1">const references = this.referenceIndex.get(document.uri.toString());</span><span class="s3">\n        </span><span class="s1">if (!references) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return references.some(ref =&gt; !ref.local &amp;&amp; changedUris.has(ref.targetUri.toString()));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index-manager.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { Deferred, interruptAndCheck } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { URI, UriUtils } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultWorkspaceManager {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.initialBuildOptions = {};</span><span class="s3">\n        </span><span class="s1">this._ready = new Deferred();</span><span class="s3">\n        </span><span class="s1">this.serviceRegistry = services.ServiceRegistry;</span><span class="s3">\n        </span><span class="s1">this.langiumDocuments = services.workspace.LangiumDocuments;</span><span class="s3">\n        </span><span class="s1">this.documentBuilder = services.workspace.DocumentBuilder;</span><span class="s3">\n        </span><span class="s1">this.fileSystemProvider = services.workspace.FileSystemProvider;</span><span class="s3">\n        </span><span class="s1">this.mutex = services.workspace.WorkspaceLock;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get ready() {</span><span class="s3">\n        </span><span class="s1">return this._ready.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get workspaceFolders() {</span><span class="s3">\n        </span><span class="s1">return this.folders;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initialize(params) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">this.folders = (_a = params.workspaceFolders) !== null &amp;&amp; _a !== void 0 ? _a : undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initialized(_params) {</span><span class="s3">\n        </span><span class="s1">// Initialize the workspace even if there are no workspace folders</span><span class="s3">\n        </span><span class="s1">// We still want to load additional documents (language library or similar) during initialization</span><span class="s3">\n        </span><span class="s1">return this.mutex.write(token =&gt; { var _a; return this.initializeWorkspace((_a = this.folders) !== null &amp;&amp; _a !== void 0 ? _a : [], token); });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async initializeWorkspace(folders, cancelToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const documents = await this.performStartup(folders);</span><span class="s3">\n        </span><span class="s1">// Only after creating all documents do we check whether we need to cancel the initialization</span><span class="s3">\n        </span><span class="s1">// The document builder will later pick up on all unprocessed documents</span><span class="s3">\n        </span><span class="s1">await interruptAndCheck(cancelToken);</span><span class="s3">\n        </span><span class="s1">await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Performs the uninterruptable startup sequence of the workspace manager.</span><span class="s3">\n     </span><span class="s1">* This methods loads all documents in the workspace and other documents and returns them.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async performStartup(folders) {</span><span class="s3">\n        </span><span class="s1">const fileExtensions = this.serviceRegistry.all.flatMap(e =&gt; e.LanguageMetaData.fileExtensions);</span><span class="s3">\n        </span><span class="s1">const documents = [];</span><span class="s3">\n        </span><span class="s1">const collector = (document) =&gt; {</span><span class="s3">\n            </span><span class="s1">documents.push(document);</span><span class="s3">\n            </span><span class="s1">if (!this.langiumDocuments.hasDocument(document.uri)) {</span><span class="s3">\n                </span><span class="s1">this.langiumDocuments.addDocument(document);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Even though we don't await the initialization of the workspace manager,</span><span class="s3">\n        </span><span class="s1">// we can still assume that all library documents and file documents are loaded by the time we start building documents.</span><span class="s3">\n        </span><span class="s1">// The mutex prevents anything from performing a workspace build until we check the cancellation token</span><span class="s3">\n        </span><span class="s1">await this.loadAdditionalDocuments(folders, collector);</span><span class="s3">\n        </span><span class="s1">await Promise.all(folders.map(wf =&gt; [wf, this.getRootFolder(wf)])</span><span class="s3">\n            </span><span class="s1">.map(async (entry) =&gt; this.traverseFolder(...entry, fileExtensions, collector)));</span><span class="s3">\n        </span><span class="s1">this._ready.resolve();</span><span class="s3">\n        </span><span class="s1">return documents;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Load all additional documents that shall be visible in the context of the given workspace</span><span class="s3">\n     </span><span class="s1">* folders and add them to the collector. This can be used to include built-in libraries of</span><span class="s3">\n     </span><span class="s1">* your language, which can be either loaded from provided files or constructed in memory.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">loadAdditionalDocuments(_folders, _collector) {</span><span class="s3">\n        </span><span class="s1">return Promise.resolve();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Determine the root folder of the source documents in the given workspace folder.</span><span class="s3">\n     </span><span class="s1">* The default implementation returns the URI of the workspace folder, but you can override</span><span class="s3">\n     </span><span class="s1">* this to return a subfolder like `src` instead.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getRootFolder(workspaceFolder) {</span><span class="s3">\n        </span><span class="s1">return URI.parse(workspaceFolder.uri);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Traverse the file system folder identified by the given URI and its subfolders. All</span><span class="s3">\n     </span><span class="s1">* contained files that match the file extensions are added to the collector.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {</span><span class="s3">\n        </span><span class="s1">const content = await this.fileSystemProvider.readDirectory(folderPath);</span><span class="s3">\n        </span><span class="s1">await Promise.all(content.map(async (entry) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {</span><span class="s3">\n                </span><span class="s1">if (entry.isDirectory) {</span><span class="s3">\n                    </span><span class="s1">await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (entry.isFile) {</span><span class="s3">\n                    </span><span class="s1">const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);</span><span class="s3">\n                    </span><span class="s1">collector(document);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Determine whether the given folder entry shall be included while indexing the workspace.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">includeEntry(_workspaceFolder, entry, fileExtensions) {</span><span class="s3">\n        </span><span class="s1">const name = UriUtils.basename(entry.uri);</span><span class="s3">\n        </span><span class="s1">if (name.startsWith('.')) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (entry.isDirectory) {</span><span class="s3">\n            </span><span class="s1">return name !== 'node_modules' &amp;&amp; name !== 'out';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (entry.isFile) {</span><span class="s3">\n            </span><span class="s1">const extname = UriUtils.extname(entry.uri);</span><span class="s3">\n            </span><span class="s1">return fileExtensions.includes(extname);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=workspace-manager.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Lexer as ChevrotainLexer, defaultLexerErrorProvider } from 'chevrotain';</span><span class="s3">\n</span><span class="s1">export class DefaultLexerErrorMessageProvider {</span><span class="s3">\n    </span><span class="s1">buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {</span><span class="s3">\n        </span><span class="s1">return defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildUnableToPopLexerModeMessage(token) {</span><span class="s3">\n        </span><span class="s1">return defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };</span><span class="s3">\n</span><span class="s1">export class DefaultLexer {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.errorMessageProvider = services.parser.LexerErrorMessageProvider;</span><span class="s3">\n        </span><span class="s1">this.tokenBuilder = services.parser.TokenBuilder;</span><span class="s3">\n        </span><span class="s1">const tokens = this.tokenBuilder.buildTokens(services.Grammar, {</span><span class="s3">\n            </span><span class="s1">caseInsensitive: services.LanguageMetaData.caseInsensitive</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.tokenTypes = this.toTokenTypeDictionary(tokens);</span><span class="s3">\n        </span><span class="s1">const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;</span><span class="s3">\n        </span><span class="s1">const production = services.LanguageMetaData.mode === 'production';</span><span class="s3">\n        </span><span class="s1">this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {</span><span class="s3">\n            </span><span class="s1">positionTracking: 'full',</span><span class="s3">\n            </span><span class="s1">skipValidations: production,</span><span class="s3">\n            </span><span class="s1">errorMessageProvider: this.errorMessageProvider</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get definition() {</span><span class="s3">\n        </span><span class="s1">return this.tokenTypes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">const chevrotainResult = this.chevrotainLexer.tokenize(text);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">tokens: chevrotainResult.tokens,</span><span class="s3">\n            </span><span class="s1">errors: chevrotainResult.errors,</span><span class="s3">\n            </span><span class="s1">hidden: (_a = chevrotainResult.groups.hidden) !== null &amp;&amp; _a !== void 0 ? _a : [],</span><span class="s3">\n            </span><span class="s1">report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toTokenTypeDictionary(buildTokens) {</span><span class="s3">\n        </span><span class="s1">if (isTokenTypeDictionary(buildTokens))</span><span class="s3">\n            </span><span class="s1">return buildTokens;</span><span class="s3">\n        </span><span class="s1">const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;</span><span class="s3">\n        </span><span class="s1">const res = {};</span><span class="s3">\n        </span><span class="s1">tokens.forEach(token =&gt; res[token.name] = token);</span><span class="s3">\n        </span><span class="s1">return res;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a check whether the given TokenVocabulary is TokenType array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isTokenTypeArray(tokenVocabulary) {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(tokenVocabulary) &amp;&amp; (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isIMultiModeLexerDefinition(tokenVocabulary) {</span><span class="s3">\n    </span><span class="s1">return tokenVocabulary &amp;&amp; 'modes' in tokenVocabulary &amp;&amp; 'defaultMode' in tokenVocabulary;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a check whether the given TokenVocabulary is TokenTypeDictionary</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isTokenTypeDictionary(tokenVocabulary) {</span><span class="s3">\n    </span><span class="s1">return !isTokenTypeArray(tokenVocabulary) &amp;&amp; !isIMultiModeLexerDefinition(tokenVocabulary);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=lexer.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Position, Range } from 'vscode-languageserver-types';</span><span class="s3">\n</span><span class="s1">import { NEWLINE_REGEXP, escapeRegExp } from '../utils/regexp-utils.js';</span><span class="s3">\n</span><span class="s1">import { URI } from '../utils/uri-utils.js';</span><span class="s3">\n</span><span class="s1">export function parseJSDoc(node, start, options) {</span><span class="s3">\n    </span><span class="s1">let opts;</span><span class="s3">\n    </span><span class="s1">let position;</span><span class="s3">\n    </span><span class="s1">if (typeof node === 'string') {</span><span class="s3">\n        </span><span class="s1">position = start;</span><span class="s3">\n        </span><span class="s1">opts = options;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">position = node.range.start;</span><span class="s3">\n        </span><span class="s1">opts = start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!position) {</span><span class="s3">\n        </span><span class="s1">position = Position.create(0, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const lines = getLines(node);</span><span class="s3">\n    </span><span class="s1">const normalizedOptions = normalizeOptions(opts);</span><span class="s3">\n    </span><span class="s1">const tokens = tokenize({</span><span class="s3">\n        </span><span class="s1">lines,</span><span class="s3">\n        </span><span class="s1">position,</span><span class="s3">\n        </span><span class="s1">options: normalizedOptions</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return parseJSDocComment({</span><span class="s3">\n        </span><span class="s1">index: 0,</span><span class="s3">\n        </span><span class="s1">tokens,</span><span class="s3">\n        </span><span class="s1">position</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isJSDoc(node, options) {</span><span class="s3">\n    </span><span class="s1">const normalizedOptions = normalizeOptions(options);</span><span class="s3">\n    </span><span class="s1">const lines = getLines(node);</span><span class="s3">\n    </span><span class="s1">if (lines.length === 0) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const first = lines[0];</span><span class="s3">\n    </span><span class="s1">const last = lines[lines.length - 1];</span><span class="s3">\n    </span><span class="s1">const firstRegex = normalizedOptions.start;</span><span class="s3">\n    </span><span class="s1">const lastRegex = normalizedOptions.end;</span><span class="s3">\n    </span><span class="s1">return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) &amp;&amp; Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getLines(node) {</span><span class="s3">\n    </span><span class="s1">let content = '';</span><span class="s3">\n    </span><span class="s1">if (typeof node === 'string') {</span><span class="s3">\n        </span><span class="s1">content = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">content = node.text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const lines = content.split(NEWLINE_REGEXP);</span><span class="s3">\n    </span><span class="s1">return lines;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const tagRegex = /</span><span class="s3">\\</span><span class="s1">s*(@([</span><span class="s3">\\</span><span class="s1">p{L}][</span><span class="s3">\\</span><span class="s1">p{L}</span><span class="s3">\\</span><span class="s1">p{N}]*)?)/uy;</span><span class="s3">\n</span><span class="s1">const inlineTagRegex = /</span><span class="s3">\\</span><span class="s1">{(@[</span><span class="s3">\\</span><span class="s1">p{L}][</span><span class="s3">\\</span><span class="s1">p{L}</span><span class="s3">\\</span><span class="s1">p{N}]*)(</span><span class="s3">\\</span><span class="s1">s*)([^</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n}]+)?</span><span class="s3">\\</span><span class="s1">}/gu;</span><span class="s3">\n</span><span class="s1">function tokenize(context) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">const tokens = [];</span><span class="s3">\n    </span><span class="s1">let currentLine = context.position.line;</span><span class="s3">\n    </span><span class="s1">let currentCharacter = context.position.character;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; context.lines.length; i++) {</span><span class="s3">\n        </span><span class="s1">const first = i === 0;</span><span class="s3">\n        </span><span class="s1">const last = i === context.lines.length - 1;</span><span class="s3">\n        </span><span class="s1">let line = context.lines[i];</span><span class="s3">\n        </span><span class="s1">let index = 0;</span><span class="s3">\n        </span><span class="s1">if (first &amp;&amp; context.options.start) {</span><span class="s3">\n            </span><span class="s1">const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n                </span><span class="s1">index = match.index + match[0].length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n                </span><span class="s1">index = match.index + match[0].length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (last) {</span><span class="s3">\n            </span><span class="s1">const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n                </span><span class="s1">line = line.substring(0, match.index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">line = line.substring(0, lastCharacter(line));</span><span class="s3">\n        </span><span class="s1">const whitespaceEnd = skipWhitespace(line, index);</span><span class="s3">\n        </span><span class="s1">if (whitespaceEnd &gt;= line.length) {</span><span class="s3">\n            </span><span class="s1">// Only create a break token when we already have previous tokens</span><span class="s3">\n            </span><span class="s1">if (tokens.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">const position = Position.create(currentLine, currentCharacter);</span><span class="s3">\n                </span><span class="s1">tokens.push({</span><span class="s3">\n                    </span><span class="s1">type: 'break',</span><span class="s3">\n                    </span><span class="s1">content: '',</span><span class="s3">\n                    </span><span class="s1">range: Range.create(position, position)</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">tagRegex.lastIndex = index;</span><span class="s3">\n            </span><span class="s1">const tagMatch = tagRegex.exec(line);</span><span class="s3">\n            </span><span class="s1">if (tagMatch) {</span><span class="s3">\n                </span><span class="s1">const fullMatch = tagMatch[0];</span><span class="s3">\n                </span><span class="s1">const value = tagMatch[1];</span><span class="s3">\n                </span><span class="s1">const start = Position.create(currentLine, currentCharacter + index);</span><span class="s3">\n                </span><span class="s1">const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);</span><span class="s3">\n                </span><span class="s1">tokens.push({</span><span class="s3">\n                    </span><span class="s1">type: 'tag',</span><span class="s3">\n                    </span><span class="s1">content: value,</span><span class="s3">\n                    </span><span class="s1">range: Range.create(start, end)</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">index += fullMatch.length;</span><span class="s3">\n                </span><span class="s1">index = skipWhitespace(line, index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (index &lt; line.length) {</span><span class="s3">\n                </span><span class="s1">const rest = line.substring(index);</span><span class="s3">\n                </span><span class="s1">const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));</span><span class="s3">\n                </span><span class="s1">tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">currentLine++;</span><span class="s3">\n        </span><span class="s1">currentCharacter = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Remove last break token if there is one</span><span class="s3">\n    </span><span class="s1">if (tokens.length &gt; 0 &amp;&amp; tokens[tokens.length - 1].type === 'break') {</span><span class="s3">\n        </span><span class="s1">return tokens.slice(0, -1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tokens;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function buildInlineTokens(tags, line, lineIndex, characterIndex) {</span><span class="s3">\n    </span><span class="s1">const tokens = [];</span><span class="s3">\n    </span><span class="s1">if (tags.length === 0) {</span><span class="s3">\n        </span><span class="s1">const start = Position.create(lineIndex, characterIndex);</span><span class="s3">\n        </span><span class="s1">const end = Position.create(lineIndex, characterIndex + line.length);</span><span class="s3">\n        </span><span class="s1">tokens.push({</span><span class="s3">\n            </span><span class="s1">type: 'text',</span><span class="s3">\n            </span><span class="s1">content: line,</span><span class="s3">\n            </span><span class="s1">range: Range.create(start, end)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">let lastIndex = 0;</span><span class="s3">\n        </span><span class="s1">for (const match of tags) {</span><span class="s3">\n            </span><span class="s1">const matchIndex = match.index;</span><span class="s3">\n            </span><span class="s1">const startContent = line.substring(lastIndex, matchIndex);</span><span class="s3">\n            </span><span class="s1">if (startContent.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">tokens.push({</span><span class="s3">\n                    </span><span class="s1">type: 'text',</span><span class="s3">\n                    </span><span class="s1">content: line.substring(lastIndex, matchIndex),</span><span class="s3">\n                    </span><span class="s1">range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, matchIndex + characterIndex))</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let offset = startContent.length + 1;</span><span class="s3">\n            </span><span class="s1">const tagName = match[1];</span><span class="s3">\n            </span><span class="s1">tokens.push({</span><span class="s3">\n                </span><span class="s1">type: 'inline-tag',</span><span class="s3">\n                </span><span class="s1">content: tagName,</span><span class="s3">\n                </span><span class="s1">range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">offset += tagName.length;</span><span class="s3">\n            </span><span class="s1">if (match.length === 4) {</span><span class="s3">\n                </span><span class="s1">offset += match[2].length;</span><span class="s3">\n                </span><span class="s1">const value = match[3];</span><span class="s3">\n                </span><span class="s1">tokens.push({</span><span class="s3">\n                    </span><span class="s1">type: 'text',</span><span class="s3">\n                    </span><span class="s1">content: value,</span><span class="s3">\n                    </span><span class="s1">range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">tokens.push({</span><span class="s3">\n                    </span><span class="s1">type: 'text',</span><span class="s3">\n                    </span><span class="s1">content: '',</span><span class="s3">\n                    </span><span class="s1">range: Range.create(Position.create(lineIndex, lastIndex + offset + characterIndex), Position.create(lineIndex, lastIndex + offset + characterIndex))</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">lastIndex = matchIndex + match[0].length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const endContent = line.substring(lastIndex);</span><span class="s3">\n        </span><span class="s1">if (endContent.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">tokens.push({</span><span class="s3">\n                </span><span class="s1">type: 'text',</span><span class="s3">\n                </span><span class="s1">content: endContent,</span><span class="s3">\n                </span><span class="s1">range: Range.create(Position.create(lineIndex, lastIndex + characterIndex), Position.create(lineIndex, lastIndex + characterIndex + endContent.length))</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tokens;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const nonWhitespaceRegex = /</span><span class="s3">\\</span><span class="s1">S/;</span><span class="s3">\n</span><span class="s1">const whitespaceEndRegex = /</span><span class="s3">\\</span><span class="s1">s*$/;</span><span class="s3">\n</span><span class="s1">function skipWhitespace(line, index) {</span><span class="s3">\n    </span><span class="s1">const match = line.substring(index).match(nonWhitespaceRegex);</span><span class="s3">\n    </span><span class="s1">if (match) {</span><span class="s3">\n        </span><span class="s1">return index + match.index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return line.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function lastCharacter(line) {</span><span class="s3">\n    </span><span class="s1">const match = line.match(whitespaceEndRegex);</span><span class="s3">\n    </span><span class="s1">if (match &amp;&amp; typeof match.index === 'number') {</span><span class="s3">\n        </span><span class="s1">return match.index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Parsing</span><span class="s3">\n</span><span class="s1">function parseJSDocComment(context) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c, _d;</span><span class="s3">\n    </span><span class="s1">const startPosition = Position.create(context.position.line, context.position.character);</span><span class="s3">\n    </span><span class="s1">if (context.tokens.length === 0) {</span><span class="s3">\n        </span><span class="s1">return new JSDocCommentImpl([], Range.create(startPosition, startPosition));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const elements = [];</span><span class="s3">\n    </span><span class="s1">while (context.index &lt; context.tokens.length) {</span><span class="s3">\n        </span><span class="s1">const element = parseJSDocElement(context, elements[elements.length - 1]);</span><span class="s3">\n        </span><span class="s1">if (element) {</span><span class="s3">\n            </span><span class="s1">elements.push(element);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null &amp;&amp; _b !== void 0 ? _b : startPosition;</span><span class="s3">\n    </span><span class="s1">const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null &amp;&amp; _d !== void 0 ? _d : startPosition;</span><span class="s3">\n    </span><span class="s1">return new JSDocCommentImpl(elements, Range.create(start, end));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseJSDocElement(context, last) {</span><span class="s3">\n    </span><span class="s1">const next = context.tokens[context.index];</span><span class="s3">\n    </span><span class="s1">if (next.type === 'tag') {</span><span class="s3">\n        </span><span class="s1">return parseJSDocTag(context, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (next.type === 'text' || next.type === 'inline-tag') {</span><span class="s3">\n        </span><span class="s1">return parseJSDocText(context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">appendEmptyLine(next, last);</span><span class="s3">\n        </span><span class="s1">context.index++;</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function appendEmptyLine(token, element) {</span><span class="s3">\n    </span><span class="s1">if (element) {</span><span class="s3">\n        </span><span class="s1">const line = new JSDocLineImpl('', token.range);</span><span class="s3">\n        </span><span class="s1">if ('inlines' in element) {</span><span class="s3">\n            </span><span class="s1">element.inlines.push(line);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">element.content.inlines.push(line);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseJSDocText(context) {</span><span class="s3">\n    </span><span class="s1">let token = context.tokens[context.index];</span><span class="s3">\n    </span><span class="s1">const firstToken = token;</span><span class="s3">\n    </span><span class="s1">let lastToken = token;</span><span class="s3">\n    </span><span class="s1">const lines = [];</span><span class="s3">\n    </span><span class="s1">while (token &amp;&amp; token.type !== 'break' &amp;&amp; token.type !== 'tag') {</span><span class="s3">\n        </span><span class="s1">lines.push(parseJSDocInline(context));</span><span class="s3">\n        </span><span class="s1">lastToken = token;</span><span class="s3">\n        </span><span class="s1">token = context.tokens[context.index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseJSDocInline(context) {</span><span class="s3">\n    </span><span class="s1">const token = context.tokens[context.index];</span><span class="s3">\n    </span><span class="s1">if (token.type === 'inline-tag') {</span><span class="s3">\n        </span><span class="s1">return parseJSDocTag(context, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return parseJSDocLine(context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseJSDocTag(context, inline) {</span><span class="s3">\n    </span><span class="s1">const tagToken = context.tokens[context.index++];</span><span class="s3">\n    </span><span class="s1">const name = tagToken.content.substring(1);</span><span class="s3">\n    </span><span class="s1">const nextToken = context.tokens[context.index];</span><span class="s3">\n    </span><span class="s1">if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {</span><span class="s3">\n        </span><span class="s1">if (inline) {</span><span class="s3">\n            </span><span class="s1">const docLine = parseJSDocLine(context);</span><span class="s3">\n            </span><span class="s1">return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, Range.create(tagToken.range.start, docLine.range.end));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const textDoc = parseJSDocText(context);</span><span class="s3">\n            </span><span class="s1">return new JSDocTagImpl(name, textDoc, inline, Range.create(tagToken.range.start, textDoc.range.end));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const range = tagToken.range;</span><span class="s3">\n        </span><span class="s1">return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parseJSDocLine(context) {</span><span class="s3">\n    </span><span class="s1">const token = context.tokens[context.index++];</span><span class="s3">\n    </span><span class="s1">return new JSDocLineImpl(token.content, token.range);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeOptions(options) {</span><span class="s3">\n    </span><span class="s1">if (!options) {</span><span class="s3">\n        </span><span class="s1">return normalizeOptions({</span><span class="s3">\n            </span><span class="s1">start: '/**',</span><span class="s3">\n            </span><span class="s1">end: '*/',</span><span class="s3">\n            </span><span class="s1">line: '*'</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { start, end, line } = options;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">start: normalizeOption(start, true),</span><span class="s3">\n        </span><span class="s1">end: normalizeOption(end, false),</span><span class="s3">\n        </span><span class="s1">line: normalizeOption(line, true)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function normalizeOption(option, start) {</span><span class="s3">\n    </span><span class="s1">if (typeof option === 'string' || typeof option === 'object') {</span><span class="s3">\n        </span><span class="s1">const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;</span><span class="s3">\n        </span><span class="s1">if (start) {</span><span class="s3">\n            </span><span class="s1">return new RegExp(`^</span><span class="s3">\\\\</span><span class="s1">s*${escaped}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return new RegExp(`</span><span class="s3">\\\\</span><span class="s1">s*${escaped}</span><span class="s3">\\\\</span><span class="s1">s*$`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return option;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class JSDocCommentImpl {</span><span class="s3">\n    </span><span class="s1">constructor(elements, range) {</span><span class="s3">\n        </span><span class="s1">this.elements = elements;</span><span class="s3">\n        </span><span class="s1">this.range = range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTag(name) {</span><span class="s3">\n        </span><span class="s1">return this.getAllTags().find(e =&gt; e.name === name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTags(name) {</span><span class="s3">\n        </span><span class="s1">return this.getAllTags().filter(e =&gt; e.name === name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAllTags() {</span><span class="s3">\n        </span><span class="s1">return this.elements.filter((e) =&gt; 'name' in e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let value = '';</span><span class="s3">\n        </span><span class="s1">for (const element of this.elements) {</span><span class="s3">\n            </span><span class="s1">if (value.length === 0) {</span><span class="s3">\n                </span><span class="s1">value = element.toString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const text = element.toString();</span><span class="s3">\n                </span><span class="s1">value += fillNewlines(value) + text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value.trim();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMarkdown(options) {</span><span class="s3">\n        </span><span class="s1">let value = '';</span><span class="s3">\n        </span><span class="s1">for (const element of this.elements) {</span><span class="s3">\n            </span><span class="s1">if (value.length === 0) {</span><span class="s3">\n                </span><span class="s1">value = element.toMarkdown(options);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const text = element.toMarkdown(options);</span><span class="s3">\n                </span><span class="s1">value += fillNewlines(value) + text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value.trim();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class JSDocTagImpl {</span><span class="s3">\n    </span><span class="s1">constructor(name, content, inline, range) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.content = content;</span><span class="s3">\n        </span><span class="s1">this.inline = inline;</span><span class="s3">\n        </span><span class="s1">this.range = range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let text = `@${this.name}`;</span><span class="s3">\n        </span><span class="s1">const content = this.content.toString();</span><span class="s3">\n        </span><span class="s1">if (this.content.inlines.length === 1) {</span><span class="s3">\n            </span><span class="s1">text = `${text} ${content}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.content.inlines.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">text = `${text}</span><span class="s3">\\</span><span class="s1">n${content}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.inline) {</span><span class="s3">\n            </span><span class="s1">// Inline tags are surrounded by curly braces</span><span class="s3">\n            </span><span class="s1">return `{${text}}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMarkdown(options) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null &amp;&amp; _b !== void 0 ? _b : this.toMarkdownDefault(options);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMarkdownDefault(options) {</span><span class="s3">\n        </span><span class="s1">const content = this.content.toMarkdown(options);</span><span class="s3">\n        </span><span class="s1">if (this.inline) {</span><span class="s3">\n            </span><span class="s1">const rendered = renderInlineTag(this.name, content, options !== null &amp;&amp; options !== void 0 ? options : {});</span><span class="s3">\n            </span><span class="s1">if (typeof rendered === 'string') {</span><span class="s3">\n                </span><span class="s1">return rendered;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let marker = '';</span><span class="s3">\n        </span><span class="s1">if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {</span><span class="s3">\n            </span><span class="s1">marker = '*';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {</span><span class="s3">\n            </span><span class="s1">marker = '**';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {</span><span class="s3">\n            </span><span class="s1">marker = '***';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let text = `${marker}@${this.name}${marker}`;</span><span class="s3">\n        </span><span class="s1">if (this.content.inlines.length === 1) {</span><span class="s3">\n            </span><span class="s1">text = `${text}  ${content}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.content.inlines.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">text = `${text}</span><span class="s3">\\</span><span class="s1">n${content}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.inline) {</span><span class="s3">\n            </span><span class="s1">// Inline tags are surrounded by curly braces</span><span class="s3">\n            </span><span class="s1">return `{${text}}`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function renderInlineTag(tag, content, options) {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {</span><span class="s3">\n        </span><span class="s1">const index = content.indexOf(' ');</span><span class="s3">\n        </span><span class="s1">let display = content;</span><span class="s3">\n        </span><span class="s1">if (index &gt; 0) {</span><span class="s3">\n            </span><span class="s1">const displayStart = skipWhitespace(content, index);</span><span class="s3">\n            </span><span class="s1">display = content.substring(displayStart);</span><span class="s3">\n            </span><span class="s1">content = content.substring(0, index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (tag === 'linkcode' || (tag === 'link' &amp;&amp; options.link === 'code')) {</span><span class="s3">\n            </span><span class="s1">// Surround the display value in a markdown inline code block</span><span class="s3">\n            </span><span class="s1">display = `</span><span class="s3">\\</span><span class="s1">`${display}</span><span class="s3">\\</span><span class="s1">``;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null &amp;&amp; _b !== void 0 ? _b : renderLinkDefault(content, display);</span><span class="s3">\n        </span><span class="s1">return renderedLink;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function renderLinkDefault(content, display) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">URI.parse(content, true);</span><span class="s3">\n        </span><span class="s1">return `[${display}](${content})`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_a) {</span><span class="s3">\n        </span><span class="s1">return content;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class JSDocTextImpl {</span><span class="s3">\n    </span><span class="s1">constructor(lines, range) {</span><span class="s3">\n        </span><span class="s1">this.inlines = lines;</span><span class="s3">\n        </span><span class="s1">this.range = range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let text = '';</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.inlines.length; i++) {</span><span class="s3">\n            </span><span class="s1">const inline = this.inlines[i];</span><span class="s3">\n            </span><span class="s1">const next = this.inlines[i + 1];</span><span class="s3">\n            </span><span class="s1">text += inline.toString();</span><span class="s3">\n            </span><span class="s1">if (next &amp;&amp; next.range.start.line &gt; inline.range.start.line) {</span><span class="s3">\n                </span><span class="s1">text += '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMarkdown(options) {</span><span class="s3">\n        </span><span class="s1">let text = '';</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.inlines.length; i++) {</span><span class="s3">\n            </span><span class="s1">const inline = this.inlines[i];</span><span class="s3">\n            </span><span class="s1">const next = this.inlines[i + 1];</span><span class="s3">\n            </span><span class="s1">text += inline.toMarkdown(options);</span><span class="s3">\n            </span><span class="s1">if (next &amp;&amp; next.range.start.line &gt; inline.range.start.line) {</span><span class="s3">\n                </span><span class="s1">text += '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class JSDocLineImpl {</span><span class="s3">\n    </span><span class="s1">constructor(text, range) {</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.range = range;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMarkdown() {</span><span class="s3">\n        </span><span class="s1">return this.text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function fillNewlines(text) {</span><span class="s3">\n    </span><span class="s1">if (text.endsWith('</span><span class="s3">\\</span><span class="s1">n')) {</span><span class="s3">\n        </span><span class="s1">return '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return '</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=jsdoc.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { getDocument } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { isJSDoc, parseJSDoc } from './jsdoc.js';</span><span class="s3">\n</span><span class="s1">export class JSDocDocumentationProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.indexManager = services.shared.workspace.IndexManager;</span><span class="s3">\n        </span><span class="s1">this.commentProvider = services.documentation.CommentProvider;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getDocumentation(node) {</span><span class="s3">\n        </span><span class="s1">const comment = this.commentProvider.getComment(node);</span><span class="s3">\n        </span><span class="s1">if (comment &amp;&amp; isJSDoc(comment)) {</span><span class="s3">\n            </span><span class="s1">const parsedJSDoc = parseJSDoc(comment);</span><span class="s3">\n            </span><span class="s1">return parsedJSDoc.toMarkdown({</span><span class="s3">\n                </span><span class="s1">renderLink: (link, display) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return this.documentationLinkRenderer(node, link, display);</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">renderTag: (tag) =&gt; {</span><span class="s3">\n                    </span><span class="s1">return this.documentationTagRenderer(node, tag);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">documentationLinkRenderer(node, name, display) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null &amp;&amp; _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);</span><span class="s3">\n        </span><span class="s1">if (description &amp;&amp; description.nameSegment) {</span><span class="s3">\n            </span><span class="s1">const line = description.nameSegment.range.start.line + 1;</span><span class="s3">\n            </span><span class="s1">const character = description.nameSegment.range.start.character + 1;</span><span class="s3">\n            </span><span class="s1">const uri = description.documentUri.with({ fragment: `L${line},${character}` });</span><span class="s3">\n            </span><span class="s1">return `[${display}](${uri.toString()})`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">documentationTagRenderer(_node, _tag) {</span><span class="s3">\n        </span><span class="s1">// Fall back to the default tag rendering</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findNameInPrecomputedScopes(node, name) {</span><span class="s3">\n        </span><span class="s1">const document = getDocument(node);</span><span class="s3">\n        </span><span class="s1">const precomputed = document.precomputedScopes;</span><span class="s3">\n        </span><span class="s1">if (!precomputed) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let currentNode = node;</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n            </span><span class="s1">const allDescriptions = precomputed.get(currentNode);</span><span class="s3">\n            </span><span class="s1">const description = allDescriptions.find(e =&gt; e.name === name);</span><span class="s3">\n            </span><span class="s1">if (description) {</span><span class="s3">\n                </span><span class="s1">return description;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">currentNode = currentNode.$container;</span><span class="s3">\n        </span><span class="s1">} while (currentNode);</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findNameInGlobalScope(node, name) {</span><span class="s3">\n        </span><span class="s1">const description = this.indexManager.allElements().find(e =&gt; e.name === name);</span><span class="s3">\n        </span><span class="s1">return description;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=documentation-provider.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { isAstNodeWithComment } from '../serializer/json-serializer.js';</span><span class="s3">\n</span><span class="s1">import { findCommentNode } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultCommentProvider {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.grammarConfig = () =&gt; services.parser.GrammarConfig;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getComment(node) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (isAstNodeWithComment(node)) {</span><span class="s3">\n            </span><span class="s1">return node.$comment;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (_a = findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=comment-provider.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Deferred, OperationCancelled } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">import { Emitter } from '../utils/event.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Default implementation of the async parser which simply wraps the sync parser in a promise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @remarks</span><span class="s3">\n </span><span class="s1">* A real implementation would create worker threads or web workers to offload the parsing work.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class DefaultAsyncParser {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.syncParser = services.parser.LangiumParser;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse(text, _cancelToken) {</span><span class="s3">\n        </span><span class="s1">return Promise.resolve(this.syncParser.parse(text));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class AbstractThreadedAsyncParser {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The thread count determines how many threads are used to parse files in parallel.</span><span class="s3">\n         </span><span class="s1">* The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.threadCount = 8;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The termination delay determines how long the parser waits for a thread to finish after a cancellation request.</span><span class="s3">\n         </span><span class="s1">* The default value is 200(ms).</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.terminationDelay = 200;</span><span class="s3">\n        </span><span class="s1">this.workerPool = [];</span><span class="s3">\n        </span><span class="s1">this.queue = [];</span><span class="s3">\n        </span><span class="s1">this.hydrator = services.serializer.Hydrator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">initializeWorkers() {</span><span class="s3">\n        </span><span class="s1">while (this.workerPool.length &lt; this.threadCount) {</span><span class="s3">\n            </span><span class="s1">const worker = this.createWorker();</span><span class="s3">\n            </span><span class="s1">worker.onReady(() =&gt; {</span><span class="s3">\n                </span><span class="s1">if (this.queue.length &gt; 0) {</span><span class="s3">\n                    </span><span class="s1">const deferred = this.queue.shift();</span><span class="s3">\n                    </span><span class="s1">if (deferred) {</span><span class="s3">\n                        </span><span class="s1">worker.lock();</span><span class="s3">\n                        </span><span class="s1">deferred.resolve(worker);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.workerPool.push(worker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async parse(text, cancelToken) {</span><span class="s3">\n        </span><span class="s1">const worker = await this.acquireParserWorker(cancelToken);</span><span class="s3">\n        </span><span class="s1">const deferred = new Deferred();</span><span class="s3">\n        </span><span class="s1">let timeout;</span><span class="s3">\n        </span><span class="s1">// If the cancellation token is requested, we wait for a certain time before terminating the worker.</span><span class="s3">\n        </span><span class="s1">// Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.</span><span class="s3">\n        </span><span class="s1">// Otherwise, we might accidentally terminate the worker after the parsing process has finished.</span><span class="s3">\n        </span><span class="s1">const cancellation = cancelToken.onCancellationRequested(() =&gt; {</span><span class="s3">\n            </span><span class="s1">timeout = setTimeout(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.terminateWorker(worker);</span><span class="s3">\n            </span><span class="s1">}, this.terminationDelay);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">worker.parse(text).then(result =&gt; {</span><span class="s3">\n            </span><span class="s1">const hydrated = this.hydrator.hydrate(result);</span><span class="s3">\n            </span><span class="s1">deferred.resolve(hydrated);</span><span class="s3">\n        </span><span class="s1">}).catch(err =&gt; {</span><span class="s3">\n            </span><span class="s1">deferred.reject(err);</span><span class="s3">\n        </span><span class="s1">}).finally(() =&gt; {</span><span class="s3">\n            </span><span class="s1">cancellation.dispose();</span><span class="s3">\n            </span><span class="s1">clearTimeout(timeout);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return deferred.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">terminateWorker(worker) {</span><span class="s3">\n        </span><span class="s1">worker.terminate();</span><span class="s3">\n        </span><span class="s1">const index = this.workerPool.indexOf(worker);</span><span class="s3">\n        </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">this.workerPool.splice(index, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async acquireParserWorker(cancelToken) {</span><span class="s3">\n        </span><span class="s1">this.initializeWorkers();</span><span class="s3">\n        </span><span class="s1">for (const worker of this.workerPool) {</span><span class="s3">\n            </span><span class="s1">if (worker.ready) {</span><span class="s3">\n                </span><span class="s1">worker.lock();</span><span class="s3">\n                </span><span class="s1">return worker;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const deferred = new Deferred();</span><span class="s3">\n        </span><span class="s1">cancelToken.onCancellationRequested(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const index = this.queue.indexOf(deferred);</span><span class="s3">\n            </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">this.queue.splice(index, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">deferred.reject(OperationCancelled);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.queue.push(deferred);</span><span class="s3">\n        </span><span class="s1">return deferred.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class ParserWorker {</span><span class="s3">\n    </span><span class="s1">get ready() {</span><span class="s3">\n        </span><span class="s1">return this._ready;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onReady() {</span><span class="s3">\n        </span><span class="s1">return this.onReadyEmitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">constructor(sendMessage, onMessage, onError, terminate) {</span><span class="s3">\n        </span><span class="s1">this.onReadyEmitter = new Emitter();</span><span class="s3">\n        </span><span class="s1">this.deferred = new Deferred();</span><span class="s3">\n        </span><span class="s1">this._ready = true;</span><span class="s3">\n        </span><span class="s1">this._parsing = false;</span><span class="s3">\n        </span><span class="s1">this.sendMessage = sendMessage;</span><span class="s3">\n        </span><span class="s1">this._terminate = terminate;</span><span class="s3">\n        </span><span class="s1">onMessage(result =&gt; {</span><span class="s3">\n            </span><span class="s1">const parseResult = result;</span><span class="s3">\n            </span><span class="s1">this.deferred.resolve(parseResult);</span><span class="s3">\n            </span><span class="s1">this.unlock();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">onError(error =&gt; {</span><span class="s3">\n            </span><span class="s1">this.deferred.reject(error);</span><span class="s3">\n            </span><span class="s1">this.unlock();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">terminate() {</span><span class="s3">\n        </span><span class="s1">this.deferred.reject(OperationCancelled);</span><span class="s3">\n        </span><span class="s1">this._terminate();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lock() {</span><span class="s3">\n        </span><span class="s1">this._ready = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">unlock() {</span><span class="s3">\n        </span><span class="s1">this._parsing = false;</span><span class="s3">\n        </span><span class="s1">this._ready = true;</span><span class="s3">\n        </span><span class="s1">this.onReadyEmitter.fire();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parse(text) {</span><span class="s3">\n        </span><span class="s1">if (this._parsing) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Parser worker is busy');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._parsing = true;</span><span class="s3">\n        </span><span class="s1">this.deferred = new Deferred();</span><span class="s3">\n        </span><span class="s1">this.sendMessage(text);</span><span class="s3">\n        </span><span class="s1">return this.deferred.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=async-parser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2023 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CancellationToken, CancellationTokenSource } from '../utils/cancellation.js';</span><span class="s3">\n</span><span class="s1">import { Deferred, isOperationCancelled, startCancelableOperation } from '../utils/promise-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultWorkspaceLock {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.previousTokenSource = new CancellationTokenSource();</span><span class="s3">\n        </span><span class="s1">this.writeQueue = [];</span><span class="s3">\n        </span><span class="s1">this.readQueue = [];</span><span class="s3">\n        </span><span class="s1">this.done = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">write(action) {</span><span class="s3">\n        </span><span class="s1">this.cancelWrite();</span><span class="s3">\n        </span><span class="s1">const tokenSource = startCancelableOperation();</span><span class="s3">\n        </span><span class="s1">this.previousTokenSource = tokenSource;</span><span class="s3">\n        </span><span class="s1">return this.enqueue(this.writeQueue, action, tokenSource.token);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">read(action) {</span><span class="s3">\n        </span><span class="s1">return this.enqueue(this.readQueue, action);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">enqueue(queue, action, cancellationToken = CancellationToken.None) {</span><span class="s3">\n        </span><span class="s1">const deferred = new Deferred();</span><span class="s3">\n        </span><span class="s1">const entry = {</span><span class="s3">\n            </span><span class="s1">action,</span><span class="s3">\n            </span><span class="s1">deferred,</span><span class="s3">\n            </span><span class="s1">cancellationToken</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">queue.push(entry);</span><span class="s3">\n        </span><span class="s1">this.performNextOperation();</span><span class="s3">\n        </span><span class="s1">return deferred.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async performNextOperation() {</span><span class="s3">\n        </span><span class="s1">if (!this.done) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const entries = [];</span><span class="s3">\n        </span><span class="s1">if (this.writeQueue.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">// Just perform the next write action</span><span class="s3">\n            </span><span class="s1">entries.push(this.writeQueue.shift());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.readQueue.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">// Empty the read queue and perform all actions in parallel</span><span class="s3">\n            </span><span class="s1">entries.push(...this.readQueue.splice(0, this.readQueue.length));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) =&gt; {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">// Move the execution of the action to the next event loop tick via `Promise.resolve()`</span><span class="s3">\n                </span><span class="s1">const result = await Promise.resolve().then(() =&gt; action(cancellationToken));</span><span class="s3">\n                </span><span class="s1">deferred.resolve(result);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">if (isOperationCancelled(err)) {</span><span class="s3">\n                    </span><span class="s1">// If the operation was cancelled, we don't want to reject the promise</span><span class="s3">\n                    </span><span class="s1">deferred.resolve(undefined);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">deferred.reject(err);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">this.done = true;</span><span class="s3">\n        </span><span class="s1">this.performNextOperation();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancelWrite() {</span><span class="s3">\n        </span><span class="s1">this.previousTokenSource.cancel();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=workspace-lock.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2024 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { CompositeCstNodeImpl, LeafCstNodeImpl, RootCstNodeImpl } from '../parser/cst-node-builder.js';</span><span class="s3">\n</span><span class="s1">import { isAbstractElement } from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { isRootCstNode, isCompositeCstNode, isLeafCstNode, isAstNode, isReference } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { streamAst } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { BiMap } from '../utils/collections.js';</span><span class="s3">\n</span><span class="s1">import { streamCst } from '../utils/cst-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultHydrator {</span><span class="s3">\n    </span><span class="s1">constructor(services) {</span><span class="s3">\n        </span><span class="s1">this.grammarElementIdMap = new BiMap();</span><span class="s3">\n        </span><span class="s1">this.tokenTypeIdMap = new BiMap();</span><span class="s3">\n        </span><span class="s1">this.grammar = services.Grammar;</span><span class="s3">\n        </span><span class="s1">this.lexer = services.parser.Lexer;</span><span class="s3">\n        </span><span class="s1">this.linker = services.references.Linker;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dehydrate(result) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">lexerErrors: result.lexerErrors,</span><span class="s3">\n            </span><span class="s1">lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,</span><span class="s3">\n            </span><span class="s1">// We need to create shallow copies of the errors</span><span class="s3">\n            </span><span class="s1">// The original errors inherit from the `Error` class, which is not transferable across worker threads</span><span class="s3">\n            </span><span class="s1">parserErrors: result.parserErrors.map(e =&gt; (Object.assign(Object.assign({}, e), { message: e.message }))),</span><span class="s3">\n            </span><span class="s1">value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dehydrateLexerReport(lexerReport) {</span><span class="s3">\n        </span><span class="s1">// By default, lexer reports are serializable</span><span class="s3">\n        </span><span class="s1">return lexerReport;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createDehyrationContext(node) {</span><span class="s3">\n        </span><span class="s1">const astNodes = new Map();</span><span class="s3">\n        </span><span class="s1">const cstNodes = new Map();</span><span class="s3">\n        </span><span class="s1">for (const astNode of streamAst(node)) {</span><span class="s3">\n            </span><span class="s1">astNodes.set(astNode, {});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node.$cstNode) {</span><span class="s3">\n            </span><span class="s1">for (const cstNode of streamCst(node.$cstNode)) {</span><span class="s3">\n                </span><span class="s1">cstNodes.set(cstNode, {});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">astNodes,</span><span class="s3">\n            </span><span class="s1">cstNodes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dehydrateAstNode(node, context) {</span><span class="s3">\n        </span><span class="s1">const obj = context.astNodes.get(node);</span><span class="s3">\n        </span><span class="s1">obj.$type = node.$type;</span><span class="s3">\n        </span><span class="s1">obj.$containerIndex = node.$containerIndex;</span><span class="s3">\n        </span><span class="s1">obj.$containerProperty = node.$containerProperty;</span><span class="s3">\n        </span><span class="s1">if (node.$cstNode !== undefined) {</span><span class="s3">\n            </span><span class="s1">obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const [name, value] of Object.entries(node)) {</span><span class="s3">\n            </span><span class="s1">if (name.startsWith('$')) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">const arr = [];</span><span class="s3">\n                </span><span class="s1">obj[name] = arr;</span><span class="s3">\n                </span><span class="s1">for (const item of value) {</span><span class="s3">\n                    </span><span class="s1">if (isAstNode(item)) {</span><span class="s3">\n                        </span><span class="s1">arr.push(this.dehydrateAstNode(item, context));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (isReference(item)) {</span><span class="s3">\n                        </span><span class="s1">arr.push(this.dehydrateReference(item, context));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">arr.push(item);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isAstNode(value)) {</span><span class="s3">\n                </span><span class="s1">obj[name] = this.dehydrateAstNode(value, context);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isReference(value)) {</span><span class="s3">\n                </span><span class="s1">obj[name] = this.dehydrateReference(value, context);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (value !== undefined) {</span><span class="s3">\n                </span><span class="s1">obj[name] = value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dehydrateReference(reference, context) {</span><span class="s3">\n        </span><span class="s1">const obj = {};</span><span class="s3">\n        </span><span class="s1">obj.$refText = reference.$refText;</span><span class="s3">\n        </span><span class="s1">if (reference.$refNode) {</span><span class="s3">\n            </span><span class="s1">obj.$refNode = context.cstNodes.get(reference.$refNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return obj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dehydrateCstNode(node, context) {</span><span class="s3">\n        </span><span class="s1">const cstNode = context.cstNodes.get(node);</span><span class="s3">\n        </span><span class="s1">if (isRootCstNode(node)) {</span><span class="s3">\n            </span><span class="s1">cstNode.fullText = node.fullText;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Note: This returns undefined for hidden nodes (i.e. comments)</span><span class="s3">\n            </span><span class="s1">cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cstNode.hidden = node.hidden;</span><span class="s3">\n        </span><span class="s1">cstNode.astNode = context.astNodes.get(node.astNode);</span><span class="s3">\n        </span><span class="s1">if (isCompositeCstNode(node)) {</span><span class="s3">\n            </span><span class="s1">cstNode.content = node.content.map(child =&gt; this.dehydrateCstNode(child, context));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isLeafCstNode(node)) {</span><span class="s3">\n            </span><span class="s1">cstNode.tokenType = node.tokenType.name;</span><span class="s3">\n            </span><span class="s1">cstNode.offset = node.offset;</span><span class="s3">\n            </span><span class="s1">cstNode.length = node.length;</span><span class="s3">\n            </span><span class="s1">cstNode.startLine = node.range.start.line;</span><span class="s3">\n            </span><span class="s1">cstNode.startColumn = node.range.start.character;</span><span class="s3">\n            </span><span class="s1">cstNode.endLine = node.range.end.line;</span><span class="s3">\n            </span><span class="s1">cstNode.endColumn = node.range.end.character;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return cstNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hydrate(result) {</span><span class="s3">\n        </span><span class="s1">const node = result.value;</span><span class="s3">\n        </span><span class="s1">const context = this.createHydrationContext(node);</span><span class="s3">\n        </span><span class="s1">if ('$cstNode' in node) {</span><span class="s3">\n            </span><span class="s1">this.hydrateCstNode(node.$cstNode, context);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">lexerErrors: result.lexerErrors,</span><span class="s3">\n            </span><span class="s1">lexerReport: result.lexerReport,</span><span class="s3">\n            </span><span class="s1">parserErrors: result.parserErrors,</span><span class="s3">\n            </span><span class="s1">value: this.hydrateAstNode(node, context)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createHydrationContext(node) {</span><span class="s3">\n        </span><span class="s1">const astNodes = new Map();</span><span class="s3">\n        </span><span class="s1">const cstNodes = new Map();</span><span class="s3">\n        </span><span class="s1">for (const astNode of streamAst(node)) {</span><span class="s3">\n            </span><span class="s1">astNodes.set(astNode, {});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let root;</span><span class="s3">\n        </span><span class="s1">if (node.$cstNode) {</span><span class="s3">\n            </span><span class="s1">for (const cstNode of streamCst(node.$cstNode)) {</span><span class="s3">\n                </span><span class="s1">let cst;</span><span class="s3">\n                </span><span class="s1">if ('fullText' in cstNode) {</span><span class="s3">\n                    </span><span class="s1">cst = new RootCstNodeImpl(cstNode.fullText);</span><span class="s3">\n                    </span><span class="s1">root = cst;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if ('content' in cstNode) {</span><span class="s3">\n                    </span><span class="s1">cst = new CompositeCstNodeImpl();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if ('tokenType' in cstNode) {</span><span class="s3">\n                    </span><span class="s1">cst = this.hydrateCstLeafNode(cstNode);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (cst) {</span><span class="s3">\n                    </span><span class="s1">cstNodes.set(cstNode, cst);</span><span class="s3">\n                    </span><span class="s1">cst.root = root;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">astNodes,</span><span class="s3">\n            </span><span class="s1">cstNodes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hydrateAstNode(node, context) {</span><span class="s3">\n        </span><span class="s1">const astNode = context.astNodes.get(node);</span><span class="s3">\n        </span><span class="s1">astNode.$type = node.$type;</span><span class="s3">\n        </span><span class="s1">astNode.$containerIndex = node.$containerIndex;</span><span class="s3">\n        </span><span class="s1">astNode.$containerProperty = node.$containerProperty;</span><span class="s3">\n        </span><span class="s1">if (node.$cstNode) {</span><span class="s3">\n            </span><span class="s1">astNode.$cstNode = context.cstNodes.get(node.$cstNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const [name, value] of Object.entries(node)) {</span><span class="s3">\n            </span><span class="s1">if (name.startsWith('$')) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">const arr = [];</span><span class="s3">\n                </span><span class="s1">astNode[name] = arr;</span><span class="s3">\n                </span><span class="s1">for (const item of value) {</span><span class="s3">\n                    </span><span class="s1">if (isAstNode(item)) {</span><span class="s3">\n                        </span><span class="s1">arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (isReference(item)) {</span><span class="s3">\n                        </span><span class="s1">arr.push(this.hydrateReference(item, astNode, name, context));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">arr.push(item);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isAstNode(value)) {</span><span class="s3">\n                </span><span class="s1">astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isReference(value)) {</span><span class="s3">\n                </span><span class="s1">astNode[name] = this.hydrateReference(value, astNode, name, context);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (value !== undefined) {</span><span class="s3">\n                </span><span class="s1">astNode[name] = value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return astNode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setParent(node, parent) {</span><span class="s3">\n        </span><span class="s1">node.$container = parent;</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hydrateReference(reference, node, name, context) {</span><span class="s3">\n        </span><span class="s1">return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hydrateCstNode(cstNode, context, num = 0) {</span><span class="s3">\n        </span><span class="s1">const cstNodeObj = context.cstNodes.get(cstNode);</span><span class="s3">\n        </span><span class="s1">if (typeof cstNode.grammarSource === 'number') {</span><span class="s3">\n            </span><span class="s1">cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);</span><span class="s3">\n        </span><span class="s1">if (isCompositeCstNode(cstNodeObj)) {</span><span class="s3">\n            </span><span class="s1">for (const child of cstNode.content) {</span><span class="s3">\n                </span><span class="s1">const hydrated = this.hydrateCstNode(child, context, num++);</span><span class="s3">\n                </span><span class="s1">cstNodeObj.content.push(hydrated);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return cstNodeObj;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hydrateCstLeafNode(cstNode) {</span><span class="s3">\n        </span><span class="s1">const tokenType = this.getTokenType(cstNode.tokenType);</span><span class="s3">\n        </span><span class="s1">const offset = cstNode.offset;</span><span class="s3">\n        </span><span class="s1">const length = cstNode.length;</span><span class="s3">\n        </span><span class="s1">const startLine = cstNode.startLine;</span><span class="s3">\n        </span><span class="s1">const startColumn = cstNode.startColumn;</span><span class="s3">\n        </span><span class="s1">const endLine = cstNode.endLine;</span><span class="s3">\n        </span><span class="s1">const endColumn = cstNode.endColumn;</span><span class="s3">\n        </span><span class="s1">const hidden = cstNode.hidden;</span><span class="s3">\n        </span><span class="s1">const node = new LeafCstNodeImpl(offset, length, {</span><span class="s3">\n            </span><span class="s1">start: {</span><span class="s3">\n                </span><span class="s1">line: startLine,</span><span class="s3">\n                </span><span class="s1">character: startColumn</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">end: {</span><span class="s3">\n                </span><span class="s1">line: endLine,</span><span class="s3">\n                </span><span class="s1">character: endColumn</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}, tokenType, hidden);</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTokenType(name) {</span><span class="s3">\n        </span><span class="s1">return this.lexer.definition[name];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getGrammarElementId(node) {</span><span class="s3">\n        </span><span class="s1">if (!node) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.grammarElementIdMap.size === 0) {</span><span class="s3">\n            </span><span class="s1">this.createGrammarElementIdMap();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.grammarElementIdMap.get(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getGrammarElement(id) {</span><span class="s3">\n        </span><span class="s1">if (this.grammarElementIdMap.size === 0) {</span><span class="s3">\n            </span><span class="s1">this.createGrammarElementIdMap();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const element = this.grammarElementIdMap.getKey(id);</span><span class="s3">\n        </span><span class="s1">return element;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createGrammarElementIdMap() {</span><span class="s3">\n        </span><span class="s1">let id = 0;</span><span class="s3">\n        </span><span class="s1">for (const element of streamAst(this.grammar)) {</span><span class="s3">\n            </span><span class="s1">if (isAbstractElement(element)) {</span><span class="s3">\n                </span><span class="s1">this.grammarElementIdMap.set(element, id++);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=hydrator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n</span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { createGrammarConfig } from './languages/grammar-config.js';</span><span class="s3">\n</span><span class="s1">import { createCompletionParser } from './parser/completion-parser-builder.js';</span><span class="s3">\n</span><span class="s1">import { createLangiumParser } from './parser/langium-parser-builder.js';</span><span class="s3">\n</span><span class="s1">import { DefaultTokenBuilder } from './parser/token-builder.js';</span><span class="s3">\n</span><span class="s1">import { DefaultValueConverter } from './parser/value-converter.js';</span><span class="s3">\n</span><span class="s1">import { DefaultLinker } from './references/linker.js';</span><span class="s3">\n</span><span class="s1">import { DefaultNameProvider } from './references/name-provider.js';</span><span class="s3">\n</span><span class="s1">import { DefaultReferences } from './references/references.js';</span><span class="s3">\n</span><span class="s1">import { DefaultScopeComputation } from './references/scope-computation.js';</span><span class="s3">\n</span><span class="s1">import { DefaultScopeProvider } from './references/scope-provider.js';</span><span class="s3">\n</span><span class="s1">import { DefaultJsonSerializer } from './serializer/json-serializer.js';</span><span class="s3">\n</span><span class="s1">import { DefaultServiceRegistry } from './service-registry.js';</span><span class="s3">\n</span><span class="s1">import { DefaultDocumentValidator } from './validation/document-validator.js';</span><span class="s3">\n</span><span class="s1">import { ValidationRegistry } from './validation/validation-registry.js';</span><span class="s3">\n</span><span class="s1">import { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';</span><span class="s3">\n</span><span class="s1">import { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';</span><span class="s3">\n</span><span class="s1">import { DefaultConfigurationProvider } from './workspace/configuration.js';</span><span class="s3">\n</span><span class="s1">import { DefaultDocumentBuilder } from './workspace/document-builder.js';</span><span class="s3">\n</span><span class="s1">import { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';</span><span class="s3">\n</span><span class="s1">import { DefaultIndexManager } from './workspace/index-manager.js';</span><span class="s3">\n</span><span class="s1">import { DefaultWorkspaceManager } from './workspace/workspace-manager.js';</span><span class="s3">\n</span><span class="s1">import { DefaultLexer, DefaultLexerErrorMessageProvider } from './parser/lexer.js';</span><span class="s3">\n</span><span class="s1">import { JSDocDocumentationProvider } from './documentation/documentation-provider.js';</span><span class="s3">\n</span><span class="s1">import { DefaultCommentProvider } from './documentation/comment-provider.js';</span><span class="s3">\n</span><span class="s1">import { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';</span><span class="s3">\n</span><span class="s1">import { DefaultAsyncParser } from './parser/async-parser.js';</span><span class="s3">\n</span><span class="s1">import { DefaultWorkspaceLock } from './workspace/workspace-lock.js';</span><span class="s3">\n</span><span class="s1">import { DefaultHydrator } from './serializer/hydrator.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a dependency injection module configuring the default core services.</span><span class="s3">\n </span><span class="s1">* This is a set of services that are dedicated to a specific language.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createDefaultCoreModule(context) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">documentation: {</span><span class="s3">\n            </span><span class="s1">CommentProvider: (services) =&gt; new DefaultCommentProvider(services),</span><span class="s3">\n            </span><span class="s1">DocumentationProvider: (services) =&gt; new JSDocDocumentationProvider(services)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">parser: {</span><span class="s3">\n            </span><span class="s1">AsyncParser: (services) =&gt; new DefaultAsyncParser(services),</span><span class="s3">\n            </span><span class="s1">GrammarConfig: (services) =&gt; createGrammarConfig(services),</span><span class="s3">\n            </span><span class="s1">LangiumParser: (services) =&gt; createLangiumParser(services),</span><span class="s3">\n            </span><span class="s1">CompletionParser: (services) =&gt; createCompletionParser(services),</span><span class="s3">\n            </span><span class="s1">ValueConverter: () =&gt; new DefaultValueConverter(),</span><span class="s3">\n            </span><span class="s1">TokenBuilder: () =&gt; new DefaultTokenBuilder(),</span><span class="s3">\n            </span><span class="s1">Lexer: (services) =&gt; new DefaultLexer(services),</span><span class="s3">\n            </span><span class="s1">ParserErrorMessageProvider: () =&gt; new LangiumParserErrorMessageProvider(),</span><span class="s3">\n            </span><span class="s1">LexerErrorMessageProvider: () =&gt; new DefaultLexerErrorMessageProvider()</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">workspace: {</span><span class="s3">\n            </span><span class="s1">AstNodeLocator: () =&gt; new DefaultAstNodeLocator(),</span><span class="s3">\n            </span><span class="s1">AstNodeDescriptionProvider: (services) =&gt; new DefaultAstNodeDescriptionProvider(services),</span><span class="s3">\n            </span><span class="s1">ReferenceDescriptionProvider: (services) =&gt; new DefaultReferenceDescriptionProvider(services)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">references: {</span><span class="s3">\n            </span><span class="s1">Linker: (services) =&gt; new DefaultLinker(services),</span><span class="s3">\n            </span><span class="s1">NameProvider: () =&gt; new DefaultNameProvider(),</span><span class="s3">\n            </span><span class="s1">ScopeProvider: (services) =&gt; new DefaultScopeProvider(services),</span><span class="s3">\n            </span><span class="s1">ScopeComputation: (services) =&gt; new DefaultScopeComputation(services),</span><span class="s3">\n            </span><span class="s1">References: (services) =&gt; new DefaultReferences(services)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">serializer: {</span><span class="s3">\n            </span><span class="s1">Hydrator: (services) =&gt; new DefaultHydrator(services),</span><span class="s3">\n            </span><span class="s1">JsonSerializer: (services) =&gt; new DefaultJsonSerializer(services)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">validation: {</span><span class="s3">\n            </span><span class="s1">DocumentValidator: (services) =&gt; new DefaultDocumentValidator(services),</span><span class="s3">\n            </span><span class="s1">ValidationRegistry: (services) =&gt; new ValidationRegistry(services)</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">shared: () =&gt; context.shared</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a dependency injection module configuring the default shared core services.</span><span class="s3">\n </span><span class="s1">* This is the set of services that are shared between multiple languages.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function createDefaultSharedCoreModule(context) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">ServiceRegistry: (services) =&gt; new DefaultServiceRegistry(services),</span><span class="s3">\n        </span><span class="s1">workspace: {</span><span class="s3">\n            </span><span class="s1">LangiumDocuments: (services) =&gt; new DefaultLangiumDocuments(services),</span><span class="s3">\n            </span><span class="s1">LangiumDocumentFactory: (services) =&gt; new DefaultLangiumDocumentFactory(services),</span><span class="s3">\n            </span><span class="s1">DocumentBuilder: (services) =&gt; new DefaultDocumentBuilder(services),</span><span class="s3">\n            </span><span class="s1">IndexManager: (services) =&gt; new DefaultIndexManager(services),</span><span class="s3">\n            </span><span class="s1">WorkspaceManager: (services) =&gt; new DefaultWorkspaceManager(services),</span><span class="s3">\n            </span><span class="s1">FileSystemProvider: (services) =&gt; context.fileSystemProvider(services),</span><span class="s3">\n            </span><span class="s1">WorkspaceLock: () =&gt; new DefaultWorkspaceLock(),</span><span class="s3">\n            </span><span class="s1">ConfigurationProvider: (services) =&gt; new DefaultConfigurationProvider(services)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=default-module.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export var Module;</span><span class="s3">\n</span><span class="s1">(function (Module) {</span><span class="s3">\n    </span><span class="s1">Module.merge = (m1, m2) =&gt; _merge(_merge({}, m1), m2);</span><span class="s3">\n</span><span class="s1">})(Module || (Module = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Given a set of modules, the inject function returns a lazily evaluated injector</span><span class="s3">\n </span><span class="s1">* that injects dependencies into the requested service when it is requested the</span><span class="s3">\n </span><span class="s1">* first time. Subsequent requests will return the same service.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* In the case of cyclic dependencies, an Error will be thrown. This can be fixed</span><span class="s3">\n </span><span class="s1">* by injecting a provider `() =&gt; T` instead of a `T`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Please note that the arguments may be objects or arrays. However, the result will</span><span class="s3">\n </span><span class="s1">* be an object. Using it with for..of will have no effect.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param module1 first Module</span><span class="s3">\n </span><span class="s1">* @param module2 (optional) second Module</span><span class="s3">\n </span><span class="s1">* @param module3 (optional) third Module</span><span class="s3">\n </span><span class="s1">* @param module4 (optional) fourth Module</span><span class="s3">\n </span><span class="s1">* @param module5 (optional) fifth Module</span><span class="s3">\n </span><span class="s1">* @param module6 (optional) sixth Module</span><span class="s3">\n </span><span class="s1">* @param module7 (optional) seventh Module</span><span class="s3">\n </span><span class="s1">* @param module8 (optional) eighth Module</span><span class="s3">\n </span><span class="s1">* @param module9 (optional) ninth Module</span><span class="s3">\n </span><span class="s1">* @returns a new object of type I</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {</span><span class="s3">\n    </span><span class="s1">const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});</span><span class="s3">\n    </span><span class="s1">return _inject(module);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const isProxy = Symbol('isProxy');</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Eagerly load all services in the given dependency injection container. This is sometimes</span><span class="s3">\n </span><span class="s1">* necessary because services can register event listeners in their constructors.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function eagerLoad(item) {</span><span class="s3">\n    </span><span class="s1">if (item &amp;&amp; item[isProxy]) {</span><span class="s3">\n        </span><span class="s1">for (const value of Object.values(item)) {</span><span class="s3">\n            </span><span class="s1">eagerLoad(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return item;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Helper function that returns an injector by creating a proxy.</span><span class="s3">\n </span><span class="s1">* Invariant: injector is of type I. If injector is undefined, then T = I.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function _inject(module, injector) {</span><span class="s3">\n    </span><span class="s1">const proxy = new Proxy({}, {</span><span class="s3">\n        </span><span class="s1">deleteProperty: () =&gt; false,</span><span class="s3">\n        </span><span class="s1">set: () =&gt; {</span><span class="s3">\n            </span><span class="s1">throw new Error('Cannot set property on injected service container');</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">get: (obj, prop) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (prop === isProxy) {</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return _resolve(obj, prop, module, injector || proxy);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">getOwnPropertyDescriptor: (obj, prop) =&gt; (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in</span><span class="s3">\n        </span><span class="s1">has: (_, prop) =&gt; prop in module, // used by ..in..</span><span class="s3">\n        </span><span class="s1">ownKeys: () =&gt; [...Object.getOwnPropertyNames(module)] // used by for..in</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return proxy;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Internally used to tag a requested dependency, directly before calling the factory.</span><span class="s3">\n </span><span class="s1">* This allows us to find cycles during instance creation.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const __requested__ = Symbol();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from</span><span class="s3">\n </span><span class="s1">* the module description. The result of service factories is cached. Groups are</span><span class="s3">\n </span><span class="s1">* recursively proxied.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param obj an object holding all group proxies and services</span><span class="s3">\n </span><span class="s1">* @param prop the key of a value within obj</span><span class="s3">\n </span><span class="s1">* @param module an object containing groups and service factories</span><span class="s3">\n </span><span class="s1">* @param injector the first level proxy that provides access to all values</span><span class="s3">\n </span><span class="s1">* @returns the requested value `obj[prop]`</span><span class="s3">\n </span><span class="s1">* @throws Error if a dependency cycle is detected</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function _resolve(obj, prop, module, injector) {</span><span class="s3">\n    </span><span class="s1">if (prop in obj) {</span><span class="s3">\n        </span><span class="s1">if (obj[prop] instanceof Error) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (obj[prop] === __requested__) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Cycle detected. Please make </span><span class="s3">\&quot;</span><span class="s1">' + String(prop) + '</span><span class="s3">\&quot; </span><span class="s1">lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return obj[prop];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (prop in module) {</span><span class="s3">\n        </span><span class="s1">const value = module[prop];</span><span class="s3">\n        </span><span class="s1">obj[prop] = __requested__;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">obj[prop] = error instanceof Error ? error : undefined;</span><span class="s3">\n            </span><span class="s1">throw error;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return obj[prop];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a deep-merge of two modules by writing source entries into the target module.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param target the module which is written</span><span class="s3">\n </span><span class="s1">* @param source the module which is read</span><span class="s3">\n </span><span class="s1">* @returns the target module</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function _merge(target, source) {</span><span class="s3">\n    </span><span class="s1">if (source) {</span><span class="s3">\n        </span><span class="s1">for (const [key, value2] of Object.entries(source)) {</span><span class="s3">\n            </span><span class="s1">if (value2 !== undefined) {</span><span class="s3">\n                </span><span class="s1">const value1 = target[key];</span><span class="s3">\n                </span><span class="s1">if (value1 !== null &amp;&amp; value2 !== null &amp;&amp; typeof value1 === 'object' &amp;&amp; typeof value2 === 'object') {</span><span class="s3">\n                    </span><span class="s1">target[key] = _merge(value1, value2);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">target[key] = value2;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=dependency-injection.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* This file was generated by langium-cli 3.3.0.</span><span class="s3">\n </span><span class="s1">* DO NOT EDIT MANUALLY!</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { AbstractAstReflection } from '../../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">export const LangiumGrammarTerminals = {</span><span class="s3">\n    </span><span class="s1">ID: /</span><span class="s3">\\</span><span class="s1">^?[_a-zA-Z][</span><span class="s3">\\</span><span class="s1">w_]*/,</span><span class="s3">\n    </span><span class="s1">STRING: /</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\&quot;\\\\</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">|'(</span><span class="s3">\\\\</span><span class="s1">.|[^'</span><span class="s3">\\\\</span><span class="s1">])*'/,</span><span class="s3">\n    </span><span class="s1">NUMBER: /NaN|-?((</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+|</span><span class="s3">\\</span><span class="s1">d+)([Ee][+-]?</span><span class="s3">\\</span><span class="s1">d+)?|Infinity)/,</span><span class="s3">\n    </span><span class="s1">RegexLiteral: /</span><span class="s3">\\</span><span class="s1">/(?![*+?])(?:[^</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">[/</span><span class="s3">\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.|</span><span class="s3">\\</span><span class="s1">[(?:[^</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.)*</span><span class="s3">\\</span><span class="s1">])+</span><span class="s3">\\</span><span class="s1">/[a-z]*/,</span><span class="s3">\n    </span><span class="s1">WS: /</span><span class="s3">\\</span><span class="s1">s+/,</span><span class="s3">\n    </span><span class="s1">ML_COMMENT: /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">//,</span><span class="s3">\n    </span><span class="s1">SL_COMMENT: /</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/[^</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r]*/,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export const AbstractRule = 'AbstractRule';</span><span class="s3">\n</span><span class="s1">export function isAbstractRule(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, AbstractRule);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const AbstractType = 'AbstractType';</span><span class="s3">\n</span><span class="s1">export function isAbstractType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, AbstractType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Condition = 'Condition';</span><span class="s3">\n</span><span class="s1">export function isCondition(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Condition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isFeatureName(item) {</span><span class="s3">\n    </span><span class="s1">return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' &amp;&amp; (/</span><span class="s3">\\</span><span class="s1">^?[_a-zA-Z][</span><span class="s3">\\</span><span class="s1">w_]*/.test(item)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isPrimitiveType(item) {</span><span class="s3">\n    </span><span class="s1">return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TypeDefinition = 'TypeDefinition';</span><span class="s3">\n</span><span class="s1">export function isTypeDefinition(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TypeDefinition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ValueLiteral = 'ValueLiteral';</span><span class="s3">\n</span><span class="s1">export function isValueLiteral(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ValueLiteral);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const AbstractElement = 'AbstractElement';</span><span class="s3">\n</span><span class="s1">export function isAbstractElement(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, AbstractElement);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ArrayLiteral = 'ArrayLiteral';</span><span class="s3">\n</span><span class="s1">export function isArrayLiteral(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ArrayLiteral);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ArrayType = 'ArrayType';</span><span class="s3">\n</span><span class="s1">export function isArrayType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ArrayType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const BooleanLiteral = 'BooleanLiteral';</span><span class="s3">\n</span><span class="s1">export function isBooleanLiteral(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, BooleanLiteral);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Conjunction = 'Conjunction';</span><span class="s3">\n</span><span class="s1">export function isConjunction(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Conjunction);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Disjunction = 'Disjunction';</span><span class="s3">\n</span><span class="s1">export function isDisjunction(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Disjunction);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Grammar = 'Grammar';</span><span class="s3">\n</span><span class="s1">export function isGrammar(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Grammar);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const GrammarImport = 'GrammarImport';</span><span class="s3">\n</span><span class="s1">export function isGrammarImport(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, GrammarImport);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const InferredType = 'InferredType';</span><span class="s3">\n</span><span class="s1">export function isInferredType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, InferredType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Interface = 'Interface';</span><span class="s3">\n</span><span class="s1">export function isInterface(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Interface);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const NamedArgument = 'NamedArgument';</span><span class="s3">\n</span><span class="s1">export function isNamedArgument(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, NamedArgument);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Negation = 'Negation';</span><span class="s3">\n</span><span class="s1">export function isNegation(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Negation);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const NumberLiteral = 'NumberLiteral';</span><span class="s3">\n</span><span class="s1">export function isNumberLiteral(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, NumberLiteral);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Parameter = 'Parameter';</span><span class="s3">\n</span><span class="s1">export function isParameter(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Parameter);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ParameterReference = 'ParameterReference';</span><span class="s3">\n</span><span class="s1">export function isParameterReference(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ParameterReference);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ParserRule = 'ParserRule';</span><span class="s3">\n</span><span class="s1">export function isParserRule(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ParserRule);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ReferenceType = 'ReferenceType';</span><span class="s3">\n</span><span class="s1">export function isReferenceType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ReferenceType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const ReturnType = 'ReturnType';</span><span class="s3">\n</span><span class="s1">export function isReturnType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, ReturnType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const SimpleType = 'SimpleType';</span><span class="s3">\n</span><span class="s1">export function isSimpleType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, SimpleType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const StringLiteral = 'StringLiteral';</span><span class="s3">\n</span><span class="s1">export function isStringLiteral(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, StringLiteral);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TerminalRule = 'TerminalRule';</span><span class="s3">\n</span><span class="s1">export function isTerminalRule(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TerminalRule);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Type = 'Type';</span><span class="s3">\n</span><span class="s1">export function isType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Type);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TypeAttribute = 'TypeAttribute';</span><span class="s3">\n</span><span class="s1">export function isTypeAttribute(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TypeAttribute);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const UnionType = 'UnionType';</span><span class="s3">\n</span><span class="s1">export function isUnionType(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, UnionType);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Action = 'Action';</span><span class="s3">\n</span><span class="s1">export function isAction(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Action);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Alternatives = 'Alternatives';</span><span class="s3">\n</span><span class="s1">export function isAlternatives(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Alternatives);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Assignment = 'Assignment';</span><span class="s3">\n</span><span class="s1">export function isAssignment(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Assignment);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const CharacterRange = 'CharacterRange';</span><span class="s3">\n</span><span class="s1">export function isCharacterRange(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, CharacterRange);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const CrossReference = 'CrossReference';</span><span class="s3">\n</span><span class="s1">export function isCrossReference(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, CrossReference);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const EndOfFile = 'EndOfFile';</span><span class="s3">\n</span><span class="s1">export function isEndOfFile(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, EndOfFile);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Group = 'Group';</span><span class="s3">\n</span><span class="s1">export function isGroup(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Group);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Keyword = 'Keyword';</span><span class="s3">\n</span><span class="s1">export function isKeyword(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Keyword);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const NegatedToken = 'NegatedToken';</span><span class="s3">\n</span><span class="s1">export function isNegatedToken(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, NegatedToken);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const RegexToken = 'RegexToken';</span><span class="s3">\n</span><span class="s1">export function isRegexToken(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, RegexToken);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const RuleCall = 'RuleCall';</span><span class="s3">\n</span><span class="s1">export function isRuleCall(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, RuleCall);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TerminalAlternatives = 'TerminalAlternatives';</span><span class="s3">\n</span><span class="s1">export function isTerminalAlternatives(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TerminalAlternatives);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TerminalGroup = 'TerminalGroup';</span><span class="s3">\n</span><span class="s1">export function isTerminalGroup(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TerminalGroup);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const TerminalRuleCall = 'TerminalRuleCall';</span><span class="s3">\n</span><span class="s1">export function isTerminalRuleCall(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, TerminalRuleCall);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const UnorderedGroup = 'UnorderedGroup';</span><span class="s3">\n</span><span class="s1">export function isUnorderedGroup(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, UnorderedGroup);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const UntilToken = 'UntilToken';</span><span class="s3">\n</span><span class="s1">export function isUntilToken(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, UntilToken);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const Wildcard = 'Wildcard';</span><span class="s3">\n</span><span class="s1">export function isWildcard(item) {</span><span class="s3">\n    </span><span class="s1">return reflection.isInstance(item, Wildcard);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export class LangiumGrammarAstReflection extends AbstractAstReflection {</span><span class="s3">\n    </span><span class="s1">getAllTypes() {</span><span class="s3">\n        </span><span class="s1">return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">computeIsSubtype(subtype, supertype) {</span><span class="s3">\n        </span><span class="s1">switch (subtype) {</span><span class="s3">\n            </span><span class="s1">case Action:</span><span class="s3">\n            </span><span class="s1">case Alternatives:</span><span class="s3">\n            </span><span class="s1">case Assignment:</span><span class="s3">\n            </span><span class="s1">case CharacterRange:</span><span class="s3">\n            </span><span class="s1">case CrossReference:</span><span class="s3">\n            </span><span class="s1">case EndOfFile:</span><span class="s3">\n            </span><span class="s1">case Group:</span><span class="s3">\n            </span><span class="s1">case Keyword:</span><span class="s3">\n            </span><span class="s1">case NegatedToken:</span><span class="s3">\n            </span><span class="s1">case RegexToken:</span><span class="s3">\n            </span><span class="s1">case RuleCall:</span><span class="s3">\n            </span><span class="s1">case TerminalAlternatives:</span><span class="s3">\n            </span><span class="s1">case TerminalGroup:</span><span class="s3">\n            </span><span class="s1">case TerminalRuleCall:</span><span class="s3">\n            </span><span class="s1">case UnorderedGroup:</span><span class="s3">\n            </span><span class="s1">case UntilToken:</span><span class="s3">\n            </span><span class="s1">case Wildcard: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(AbstractElement, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ArrayLiteral:</span><span class="s3">\n            </span><span class="s1">case NumberLiteral:</span><span class="s3">\n            </span><span class="s1">case StringLiteral: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(ValueLiteral, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ArrayType:</span><span class="s3">\n            </span><span class="s1">case ReferenceType:</span><span class="s3">\n            </span><span class="s1">case SimpleType:</span><span class="s3">\n            </span><span class="s1">case UnionType: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(TypeDefinition, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case BooleanLiteral: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Conjunction:</span><span class="s3">\n            </span><span class="s1">case Disjunction:</span><span class="s3">\n            </span><span class="s1">case Negation:</span><span class="s3">\n            </span><span class="s1">case ParameterReference: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(Condition, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case InferredType:</span><span class="s3">\n            </span><span class="s1">case Interface:</span><span class="s3">\n            </span><span class="s1">case Type: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(AbstractType, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ParserRule: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TerminalRule: {</span><span class="s3">\n                </span><span class="s1">return this.isSubtype(AbstractRule, supertype);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">default: {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getReferenceType(refInfo) {</span><span class="s3">\n        </span><span class="s1">const referenceId = `${refInfo.container.$type}:${refInfo.property}`;</span><span class="s3">\n        </span><span class="s1">switch (referenceId) {</span><span class="s3">\n            </span><span class="s1">case 'Action:type':</span><span class="s3">\n            </span><span class="s1">case 'CrossReference:type':</span><span class="s3">\n            </span><span class="s1">case 'Interface:superTypes':</span><span class="s3">\n            </span><span class="s1">case 'ParserRule:returnType':</span><span class="s3">\n            </span><span class="s1">case 'SimpleType:typeRef': {</span><span class="s3">\n                </span><span class="s1">return AbstractType;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'Grammar:hiddenTokens':</span><span class="s3">\n            </span><span class="s1">case 'ParserRule:hiddenTokens':</span><span class="s3">\n            </span><span class="s1">case 'RuleCall:rule': {</span><span class="s3">\n                </span><span class="s1">return AbstractRule;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'Grammar:usedGrammars': {</span><span class="s3">\n                </span><span class="s1">return Grammar;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'NamedArgument:parameter':</span><span class="s3">\n            </span><span class="s1">case 'ParameterReference:parameter': {</span><span class="s3">\n                </span><span class="s1">return Parameter;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'TerminalRuleCall:rule': {</span><span class="s3">\n                </span><span class="s1">return TerminalRule;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">default: {</span><span class="s3">\n                </span><span class="s1">throw new Error(`${referenceId} is not a valid reference id.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getTypeMetaData(type) {</span><span class="s3">\n        </span><span class="s1">switch (type) {</span><span class="s3">\n            </span><span class="s1">case AbstractElement: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: AbstractElement,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ArrayLiteral: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ArrayLiteral,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ArrayType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ArrayType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'elementType' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case BooleanLiteral: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: BooleanLiteral,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'true', defaultValue: false }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Conjunction: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Conjunction,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'left' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'right' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Disjunction: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Disjunction,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'left' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'right' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Grammar: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Grammar,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'definesHiddenTokens', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'hiddenTokens', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'imports', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'interfaces', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'isDeclared', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'rules', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'types', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'usedGrammars', defaultValue: [] }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case GrammarImport: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: GrammarImport,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'path' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case InferredType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: InferredType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Interface: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Interface,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'attributes', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'superTypes', defaultValue: [] }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case NamedArgument: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: NamedArgument,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'calledByName', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'parameter' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'value' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Negation: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Negation,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'value' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case NumberLiteral: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: NumberLiteral,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'value' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Parameter: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Parameter,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ParameterReference: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ParameterReference,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'parameter' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ParserRule: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ParserRule,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'dataType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'definesHiddenTokens', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'definition' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'entry', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'fragment', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'hiddenTokens', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'inferredType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'parameters', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'returnType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'wildcard', defaultValue: false }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ReferenceType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ReferenceType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'referenceType' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ReturnType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: ReturnType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case SimpleType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: SimpleType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'primitiveType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'stringType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'typeRef' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case StringLiteral: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: StringLiteral,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'value' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TerminalRule: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: TerminalRule,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'definition' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'fragment', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'hidden', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'type' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Type: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Type,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'type' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TypeAttribute: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: TypeAttribute,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'defaultValue' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'isOptional', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'name' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'type' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case UnionType: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: UnionType,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'types', defaultValue: [] }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Action: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Action,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'feature' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'inferredType' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'operator' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'type' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Alternatives: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Alternatives,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Assignment: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Assignment,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'feature' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'operator' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'terminal' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case CharacterRange: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: CharacterRange,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'left' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'right' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case CrossReference: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: CrossReference,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'deprecatedSyntax', defaultValue: false },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'terminal' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'type' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case EndOfFile: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: EndOfFile,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Group: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Group,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'guardCondition' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Keyword: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Keyword,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'value' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case NegatedToken: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: NegatedToken,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'terminal' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case RegexToken: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: RegexToken,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'regex' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case RuleCall: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: RuleCall,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'arguments', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'rule' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TerminalAlternatives: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: TerminalAlternatives,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TerminalGroup: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: TerminalGroup,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case TerminalRuleCall: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: TerminalRuleCall,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'rule' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case UnorderedGroup: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: UnorderedGroup,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'elements', defaultValue: [] },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case UntilToken: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: UntilToken,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'terminal' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case Wildcard: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: Wildcard,</span><span class="s3">\n                    </span><span class="s1">properties: [</span><span class="s3">\n                        </span><span class="s1">{ name: 'cardinality' },</span><span class="s3">\n                        </span><span class="s1">{ name: 'lookahead' }</span><span class="s3">\n                    </span><span class="s1">]</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">default: {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">name: type,</span><span class="s3">\n                    </span><span class="s1">properties: []</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const reflection = new LangiumGrammarAstReflection();</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ast.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { Lexer } from 'chevrotain';</span><span class="s3">\n</span><span class="s1">import { isKeyword, isParserRule, isTerminalRule } from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { streamAllContents } from '../utils/ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { getAllReachableRules, terminalRegex } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">import { getCaseInsensitivePattern, isWhitespace, partialMatches } from '../utils/regexp-utils.js';</span><span class="s3">\n</span><span class="s1">import { stream } from '../utils/stream.js';</span><span class="s3">\n</span><span class="s1">export class DefaultTokenBuilder {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The list of diagnostics stored during the lexing process of a single text.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.diagnostics = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildTokens(grammar, options) {</span><span class="s3">\n        </span><span class="s1">const reachableRules = stream(getAllReachableRules(grammar, false));</span><span class="s3">\n        </span><span class="s1">const terminalTokens = this.buildTerminalTokens(reachableRules);</span><span class="s3">\n        </span><span class="s1">const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);</span><span class="s3">\n        </span><span class="s1">terminalTokens.forEach(terminalToken =&gt; {</span><span class="s3">\n            </span><span class="s1">const pattern = terminalToken.PATTERN;</span><span class="s3">\n            </span><span class="s1">if (typeof pattern === 'object' &amp;&amp; pattern &amp;&amp; 'test' in pattern &amp;&amp; isWhitespace(pattern)) {</span><span class="s3">\n                </span><span class="s1">tokens.unshift(terminalToken);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">tokens.push(terminalToken);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// We don't need to add the EOF token explicitly.</span><span class="s3">\n        </span><span class="s1">// It is automatically available at the end of the token stream.</span><span class="s3">\n        </span><span class="s1">return tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n    </span><span class="s1">flushLexingReport(text) {</span><span class="s3">\n        </span><span class="s1">return { diagnostics: this.popDiagnostics() };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">popDiagnostics() {</span><span class="s3">\n        </span><span class="s1">const diagnostics = [...this.diagnostics];</span><span class="s3">\n        </span><span class="s1">this.diagnostics = [];</span><span class="s3">\n        </span><span class="s1">return diagnostics;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildTerminalTokens(rules) {</span><span class="s3">\n        </span><span class="s1">return rules.filter(isTerminalRule).filter(e =&gt; !e.fragment)</span><span class="s3">\n            </span><span class="s1">.map(terminal =&gt; this.buildTerminalToken(terminal)).toArray();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildTerminalToken(terminal) {</span><span class="s3">\n        </span><span class="s1">const regex = terminalRegex(terminal);</span><span class="s3">\n        </span><span class="s1">const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;</span><span class="s3">\n        </span><span class="s1">const tokenType = {</span><span class="s3">\n            </span><span class="s1">name: terminal.name,</span><span class="s3">\n            </span><span class="s1">PATTERN: pattern,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (typeof pattern === 'function') {</span><span class="s3">\n            </span><span class="s1">tokenType.LINE_BREAKS = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (terminal.hidden) {</span><span class="s3">\n            </span><span class="s1">// Only skip tokens that are able to accept whitespace</span><span class="s3">\n            </span><span class="s1">tokenType.GROUP = isWhitespace(regex) ? Lexer.SKIPPED : 'hidden';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return tokenType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">requiresCustomPattern(regex) {</span><span class="s3">\n        </span><span class="s1">if (regex.flags.includes('u') || regex.flags.includes('s')) {</span><span class="s3">\n            </span><span class="s1">// Unicode and dotall regexes are not supported by Chevrotain.</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (regex.source.includes('?&lt;=') || regex.source.includes('?&lt;!')) {</span><span class="s3">\n            </span><span class="s1">// Negative and positive lookbehind are not supported by Chevrotain yet.</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">regexPatternFunction(regex) {</span><span class="s3">\n        </span><span class="s1">const stickyRegex = new RegExp(regex, regex.flags + 'y');</span><span class="s3">\n        </span><span class="s1">return (text, offset) =&gt; {</span><span class="s3">\n            </span><span class="s1">stickyRegex.lastIndex = offset;</span><span class="s3">\n            </span><span class="s1">const execResult = stickyRegex.exec(text);</span><span class="s3">\n            </span><span class="s1">return execResult;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildKeywordTokens(rules, terminalTokens, options) {</span><span class="s3">\n        </span><span class="s1">return rules</span><span class="s3">\n            </span><span class="s1">// We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens</span><span class="s3">\n            </span><span class="s1">.filter(isParserRule)</span><span class="s3">\n            </span><span class="s1">.flatMap(rule =&gt; streamAllContents(rule).filter(isKeyword))</span><span class="s3">\n            </span><span class="s1">.distinct(e =&gt; e.value).toArray()</span><span class="s3">\n            </span><span class="s1">// Sort keywords by descending length</span><span class="s3">\n            </span><span class="s1">.sort((a, b) =&gt; b.value.length - a.value.length)</span><span class="s3">\n            </span><span class="s1">.map(keyword =&gt; this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildKeywordToken(keyword, terminalTokens, caseInsensitive) {</span><span class="s3">\n        </span><span class="s1">const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);</span><span class="s3">\n        </span><span class="s1">const tokenType = {</span><span class="s3">\n            </span><span class="s1">name: keyword.value,</span><span class="s3">\n            </span><span class="s1">PATTERN: keywordPattern,</span><span class="s3">\n            </span><span class="s1">LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (typeof keywordPattern === 'function') {</span><span class="s3">\n            </span><span class="s1">tokenType.LINE_BREAKS = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return tokenType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildKeywordPattern(keyword, caseInsensitive) {</span><span class="s3">\n        </span><span class="s1">return caseInsensitive ?</span><span class="s3">\n            </span><span class="s1">new RegExp(getCaseInsensitivePattern(keyword.value)) :</span><span class="s3">\n            </span><span class="s1">keyword.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findLongerAlt(keyword, terminalTokens) {</span><span class="s3">\n        </span><span class="s1">return terminalTokens.reduce((longerAlts, token) =&gt; {</span><span class="s3">\n            </span><span class="s1">const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;</span><span class="s3">\n            </span><span class="s1">if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) &amp;&amp; partialMatches('^' + pattern.source + '$', keyword.value)) {</span><span class="s3">\n                </span><span class="s1">longerAlts.push(token);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return longerAlts;</span><span class="s3">\n        </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=token-builder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { isCrossReference, isRuleCall } from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { getCrossReferenceTerminal, getRuleType } from '../utils/grammar-utils.js';</span><span class="s3">\n</span><span class="s1">export class DefaultValueConverter {</span><span class="s3">\n    </span><span class="s1">convert(input, cstNode) {</span><span class="s3">\n        </span><span class="s1">let feature = cstNode.grammarSource;</span><span class="s3">\n        </span><span class="s1">if (isCrossReference(feature)) {</span><span class="s3">\n            </span><span class="s1">feature = getCrossReferenceTerminal(feature);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isRuleCall(feature)) {</span><span class="s3">\n            </span><span class="s1">const rule = feature.rule.ref;</span><span class="s3">\n            </span><span class="s1">if (!rule) {</span><span class="s3">\n                </span><span class="s1">throw new Error('This cst node was not parsed by a rule.');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.runConverter(rule, input, cstNode);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return input;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n    </span><span class="s1">runConverter(rule, input, cstNode) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">switch (rule.name.toUpperCase()) {</span><span class="s3">\n            </span><span class="s1">case 'INT': return ValueConverter.convertInt(input);</span><span class="s3">\n            </span><span class="s1">case 'STRING': return ValueConverter.convertString(input);</span><span class="s3">\n            </span><span class="s1">case 'ID': return ValueConverter.convertID(input);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch ((_a = getRuleType(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {</span><span class="s3">\n            </span><span class="s1">case 'number': return ValueConverter.convertNumber(input);</span><span class="s3">\n            </span><span class="s1">case 'boolean': return ValueConverter.convertBoolean(input);</span><span class="s3">\n            </span><span class="s1">case 'bigint': return ValueConverter.convertBigint(input);</span><span class="s3">\n            </span><span class="s1">case 'date': return ValueConverter.convertDate(input);</span><span class="s3">\n            </span><span class="s1">default: return input;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var ValueConverter;</span><span class="s3">\n</span><span class="s1">(function (ValueConverter) {</span><span class="s3">\n    </span><span class="s1">function convertString(input) {</span><span class="s3">\n        </span><span class="s1">let result = '';</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; input.length - 1; i++) {</span><span class="s3">\n            </span><span class="s1">const c = input.charAt(i);</span><span class="s3">\n            </span><span class="s1">if (c === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n                </span><span class="s1">const c1 = input.charAt(++i);</span><span class="s3">\n                </span><span class="s1">result += convertEscapeCharacter(c1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">result += c;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertString = convertString;</span><span class="s3">\n    </span><span class="s1">function convertEscapeCharacter(char) {</span><span class="s3">\n        </span><span class="s1">switch (char) {</span><span class="s3">\n            </span><span class="s1">case 'b': return '</span><span class="s3">\\</span><span class="s1">b';</span><span class="s3">\n            </span><span class="s1">case 'f': return '</span><span class="s3">\\</span><span class="s1">f';</span><span class="s3">\n            </span><span class="s1">case 'n': return '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n            </span><span class="s1">case 'r': return '</span><span class="s3">\\</span><span class="s1">r';</span><span class="s3">\n            </span><span class="s1">case 't': return '</span><span class="s3">\\</span><span class="s1">t';</span><span class="s3">\n            </span><span class="s1">case 'v': return '</span><span class="s3">\\</span><span class="s1">v';</span><span class="s3">\n            </span><span class="s1">case '0': return '</span><span class="s3">\\</span><span class="s1">0';</span><span class="s3">\n            </span><span class="s1">default: return char;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">function convertID(input) {</span><span class="s3">\n        </span><span class="s1">if (input.charAt(0) === '^') {</span><span class="s3">\n            </span><span class="s1">return input.substring(1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return input;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertID = convertID;</span><span class="s3">\n    </span><span class="s1">function convertInt(input) {</span><span class="s3">\n        </span><span class="s1">return parseInt(input);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertInt = convertInt;</span><span class="s3">\n    </span><span class="s1">function convertBigint(input) {</span><span class="s3">\n        </span><span class="s1">return BigInt(input);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertBigint = convertBigint;</span><span class="s3">\n    </span><span class="s1">function convertDate(input) {</span><span class="s3">\n        </span><span class="s1">return new Date(input);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertDate = convertDate;</span><span class="s3">\n    </span><span class="s1">function convertNumber(input) {</span><span class="s3">\n        </span><span class="s1">return Number(input);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertNumber = convertNumber;</span><span class="s3">\n    </span><span class="s1">function convertBoolean(input) {</span><span class="s3">\n        </span><span class="s1">return input.toLowerCase() === 'true';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ValueConverter.convertBoolean = convertBoolean;</span><span class="s3">\n</span><span class="s1">})(ValueConverter || (ValueConverter = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=value-converter.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export function isAstNode(obj) {</span><span class="s3">\n    </span><span class="s1">return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; typeof obj.$type === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isReference(obj) {</span><span class="s3">\n    </span><span class="s1">return typeof obj === 'object' &amp;&amp; obj !== null &amp;&amp; typeof obj.$refText === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isAstNodeDescription(obj) {</span><span class="s3">\n    </span><span class="s1">return typeof obj === 'object' &amp;&amp; obj !== null</span><span class="s3">\n        </span><span class="s1">&amp;&amp; typeof obj.name === 'string'</span><span class="s3">\n        </span><span class="s1">&amp;&amp; typeof obj.type === 'string'</span><span class="s3">\n        </span><span class="s1">&amp;&amp; typeof obj.path === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isLinkingError(obj) {</span><span class="s3">\n    </span><span class="s1">return typeof obj === 'object' &amp;&amp; obj !== null</span><span class="s3">\n        </span><span class="s1">&amp;&amp; isAstNode(obj.container)</span><span class="s3">\n        </span><span class="s1">&amp;&amp; isReference(obj.reference)</span><span class="s3">\n        </span><span class="s1">&amp;&amp; typeof obj.message === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An abstract implementation of the {@link AstReflection} interface.</span><span class="s3">\n </span><span class="s1">* Serves to cache subtype computation results to improve performance throughout different parts of Langium.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class AbstractAstReflection {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.subtypes = {};</span><span class="s3">\n        </span><span class="s1">this.allSubtypes = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isInstance(node, type) {</span><span class="s3">\n        </span><span class="s1">return isAstNode(node) &amp;&amp; this.isSubtype(node.$type, type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isSubtype(subtype, supertype) {</span><span class="s3">\n        </span><span class="s1">if (subtype === supertype) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let nested = this.subtypes[subtype];</span><span class="s3">\n        </span><span class="s1">if (!nested) {</span><span class="s3">\n            </span><span class="s1">nested = this.subtypes[subtype] = {};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const existing = nested[supertype];</span><span class="s3">\n        </span><span class="s1">if (existing !== undefined) {</span><span class="s3">\n            </span><span class="s1">return existing;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const result = this.computeIsSubtype(subtype, supertype);</span><span class="s3">\n            </span><span class="s1">nested[supertype] = result;</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getAllSubTypes(type) {</span><span class="s3">\n        </span><span class="s1">const existing = this.allSubtypes[type];</span><span class="s3">\n        </span><span class="s1">if (existing) {</span><span class="s3">\n            </span><span class="s1">return existing;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const allTypes = this.getAllTypes();</span><span class="s3">\n            </span><span class="s1">const types = [];</span><span class="s3">\n            </span><span class="s1">for (const possibleSubType of allTypes) {</span><span class="s3">\n                </span><span class="s1">if (this.isSubtype(possibleSubType, type)) {</span><span class="s3">\n                    </span><span class="s1">types.push(possibleSubType);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.allSubtypes[type] = types;</span><span class="s3">\n            </span><span class="s1">return types;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isCompositeCstNode(node) {</span><span class="s3">\n    </span><span class="s1">return typeof node === 'object' &amp;&amp; node !== null &amp;&amp; Array.isArray(node.content);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isLeafCstNode(node) {</span><span class="s3">\n    </span><span class="s1">return typeof node === 'object' &amp;&amp; node !== null &amp;&amp; typeof node.tokenType === 'object';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isRootCstNode(node) {</span><span class="s3">\n    </span><span class="s1">return isCompositeCstNode(node) &amp;&amp; typeof node.fullText === 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=syntax-tree.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { isAstNode, isReference } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from './stream.js';</span><span class="s3">\n</span><span class="s1">import { inRange } from './cst-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Link the `$container` and other related properties of every AST node that is directly contained</span><span class="s3">\n </span><span class="s1">* in the given `node`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function linkContentToContainer(node) {</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of Object.entries(node)) {</span><span class="s3">\n        </span><span class="s1">if (!name.startsWith('$')) {</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">value.forEach((item, index) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (isAstNode(item)) {</span><span class="s3">\n                        </span><span class="s1">item.$container = node;</span><span class="s3">\n                        </span><span class="s1">item.$containerProperty = name;</span><span class="s3">\n                        </span><span class="s1">item.$containerIndex = index;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isAstNode(value)) {</span><span class="s3">\n                </span><span class="s1">value.$container = node;</span><span class="s3">\n                </span><span class="s1">value.$containerProperty = name;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk along the hierarchy of containers from the given AST node to the root and return the first</span><span class="s3">\n </span><span class="s1">* node that matches the type predicate. If the start node itself matches, it is returned.</span><span class="s3">\n </span><span class="s1">* If no container matches, `undefined` is returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getContainerOfType(node, typePredicate) {</span><span class="s3">\n    </span><span class="s1">let item = node;</span><span class="s3">\n    </span><span class="s1">while (item) {</span><span class="s3">\n        </span><span class="s1">if (typePredicate(item)) {</span><span class="s3">\n            </span><span class="s1">return item;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">item = item.$container;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Walk along the hierarchy of containers from the given AST node to the root and check for existence</span><span class="s3">\n </span><span class="s1">* of a container that matches the given predicate. The start node is included in the checks.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function hasContainerOfType(node, predicate) {</span><span class="s3">\n    </span><span class="s1">let item = node;</span><span class="s3">\n    </span><span class="s1">while (item) {</span><span class="s3">\n        </span><span class="s1">if (predicate(item)) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">item = item.$container;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Retrieve the document in which the given AST node is contained. A reference to the document is</span><span class="s3">\n </span><span class="s1">* usually held by the root node of the AST.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @throws an error if the node is not contained in a document.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getDocument(node) {</span><span class="s3">\n    </span><span class="s1">const rootNode = findRootNode(node);</span><span class="s3">\n    </span><span class="s1">const result = rootNode.$document;</span><span class="s3">\n    </span><span class="s1">if (!result) {</span><span class="s3">\n        </span><span class="s1">throw new Error('AST node has no document.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the root node of the given AST node by following the `$container` references.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findRootNode(node) {</span><span class="s3">\n    </span><span class="s1">while (node.$container) {</span><span class="s3">\n        </span><span class="s1">node = node.$container;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all AST nodes that are directly contained in the given node. This includes</span><span class="s3">\n </span><span class="s1">* single-valued as well as multi-valued (array) properties.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function streamContents(node, options) {</span><span class="s3">\n    </span><span class="s1">if (!node) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Node must be an AstNode.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const range = options === null || options === void 0 ? void 0 : options.range;</span><span class="s3">\n    </span><span class="s1">return new StreamImpl(() =&gt; ({</span><span class="s3">\n        </span><span class="s1">keys: Object.keys(node),</span><span class="s3">\n        </span><span class="s1">keyIndex: 0,</span><span class="s3">\n        </span><span class="s1">arrayIndex: 0</span><span class="s3">\n    </span><span class="s1">}), state =&gt; {</span><span class="s3">\n        </span><span class="s1">while (state.keyIndex &lt; state.keys.length) {</span><span class="s3">\n            </span><span class="s1">const property = state.keys[state.keyIndex];</span><span class="s3">\n            </span><span class="s1">if (!property.startsWith('$')) {</span><span class="s3">\n                </span><span class="s1">const value = node[property];</span><span class="s3">\n                </span><span class="s1">if (isAstNode(value)) {</span><span class="s3">\n                    </span><span class="s1">state.keyIndex++;</span><span class="s3">\n                    </span><span class="s1">if (isAstNodeInRange(value, range)) {</span><span class="s3">\n                        </span><span class="s1">return { done: false, value };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (Array.isArray(value)) {</span><span class="s3">\n                    </span><span class="s1">while (state.arrayIndex &lt; value.length) {</span><span class="s3">\n                        </span><span class="s1">const index = state.arrayIndex++;</span><span class="s3">\n                        </span><span class="s1">const element = value[index];</span><span class="s3">\n                        </span><span class="s1">if (isAstNode(element) &amp;&amp; isAstNodeInRange(element, range)) {</span><span class="s3">\n                            </span><span class="s1">return { done: false, value: element };</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">state.arrayIndex = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state.keyIndex++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all AST nodes that are directly and indirectly contained in the given root node.</span><span class="s3">\n </span><span class="s1">* This does not include the root node itself.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function streamAllContents(root, options) {</span><span class="s3">\n    </span><span class="s1">if (!root) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Root node must be an AstNode.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new TreeStreamImpl(root, node =&gt; streamContents(node, options));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all AST nodes that are directly and indirectly contained in the given root node,</span><span class="s3">\n </span><span class="s1">* including the root node itself.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function streamAst(root, options) {</span><span class="s3">\n    </span><span class="s1">if (!root) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Root node must be an AstNode.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if ((options === null || options === void 0 ? void 0 : options.range) &amp;&amp; !isAstNodeInRange(root, options.range)) {</span><span class="s3">\n        </span><span class="s1">// Return an empty stream if the root node isn't in range</span><span class="s3">\n        </span><span class="s1">return new TreeStreamImpl(root, () =&gt; []);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new TreeStreamImpl(root, node =&gt; streamContents(node, options), { includeRoot: true });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isAstNodeInRange(astNode, range) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (!range) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;</span><span class="s3">\n    </span><span class="s1">if (!nodeRange) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return inRange(nodeRange, range);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all cross-references that are held by the given AST node. This includes</span><span class="s3">\n </span><span class="s1">* single-valued as well as multi-valued (array) properties.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function streamReferences(node) {</span><span class="s3">\n    </span><span class="s1">return new StreamImpl(() =&gt; ({</span><span class="s3">\n        </span><span class="s1">keys: Object.keys(node),</span><span class="s3">\n        </span><span class="s1">keyIndex: 0,</span><span class="s3">\n        </span><span class="s1">arrayIndex: 0</span><span class="s3">\n    </span><span class="s1">}), state =&gt; {</span><span class="s3">\n        </span><span class="s1">while (state.keyIndex &lt; state.keys.length) {</span><span class="s3">\n            </span><span class="s1">const property = state.keys[state.keyIndex];</span><span class="s3">\n            </span><span class="s1">if (!property.startsWith('$')) {</span><span class="s3">\n                </span><span class="s1">const value = node[property];</span><span class="s3">\n                </span><span class="s1">if (isReference(value)) {</span><span class="s3">\n                    </span><span class="s1">state.keyIndex++;</span><span class="s3">\n                    </span><span class="s1">return { done: false, value: { reference: value, container: node, property } };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (Array.isArray(value)) {</span><span class="s3">\n                    </span><span class="s1">while (state.arrayIndex &lt; value.length) {</span><span class="s3">\n                        </span><span class="s1">const index = state.arrayIndex++;</span><span class="s3">\n                        </span><span class="s1">const element = value[index];</span><span class="s3">\n                        </span><span class="s1">if (isReference(element)) {</span><span class="s3">\n                            </span><span class="s1">return { done: false, value: { reference: element, container: node, property, index } };</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">state.arrayIndex = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state.keyIndex++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns a Stream of references to the target node from the AstNode tree</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param targetNode AstNode we are looking for</span><span class="s3">\n </span><span class="s1">* @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {</span><span class="s3">\n    </span><span class="s1">const refs = [];</span><span class="s3">\n    </span><span class="s1">streamAst(lookup).forEach(node =&gt; {</span><span class="s3">\n        </span><span class="s1">streamReferences(node).forEach(refInfo =&gt; {</span><span class="s3">\n            </span><span class="s1">if (refInfo.reference.ref === targetNode) {</span><span class="s3">\n                </span><span class="s1">refs.push(refInfo.reference);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return stream(refs);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns all mandatory AST properties to the specified node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param reflection Reflection object used to gather mandatory properties for the node.</span><span class="s3">\n </span><span class="s1">* @param node Specified node is modified in place and properties are directly assigned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function assignMandatoryProperties(reflection, node) {</span><span class="s3">\n    </span><span class="s1">const typeMetaData = reflection.getTypeMetaData(node.$type);</span><span class="s3">\n    </span><span class="s1">const genericNode = node;</span><span class="s3">\n    </span><span class="s1">for (const property of typeMetaData.properties) {</span><span class="s3">\n        </span><span class="s1">// Only set the value if the property is not already set and if it has a default value</span><span class="s3">\n        </span><span class="s1">if (property.defaultValue !== undefined &amp;&amp; genericNode[property.name] === undefined) {</span><span class="s3">\n            </span><span class="s1">genericNode[property.name] = copyDefaultValue(property.defaultValue);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function copyDefaultValue(propertyType) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(propertyType)) {</span><span class="s3">\n        </span><span class="s1">return [...propertyType.map(copyDefaultValue)];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return propertyType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a deep copy of the specified AST node.</span><span class="s3">\n </span><span class="s1">* The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* References are copied without resolved cross reference. The specified function is used to rebuild them.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function copyAstNode(node, buildReference) {</span><span class="s3">\n    </span><span class="s1">const copy = { $type: node.$type };</span><span class="s3">\n    </span><span class="s1">for (const [name, value] of Object.entries(node)) {</span><span class="s3">\n        </span><span class="s1">if (!name.startsWith('$')) {</span><span class="s3">\n            </span><span class="s1">if (isAstNode(value)) {</span><span class="s3">\n                </span><span class="s1">copy[name] = copyAstNode(value, buildReference);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (isReference(value)) {</span><span class="s3">\n                </span><span class="s1">copy[name] = buildReference(copy, name, value.$refNode, value.$refText);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">const copiedArray = [];</span><span class="s3">\n                </span><span class="s1">for (const element of value) {</span><span class="s3">\n                    </span><span class="s1">if (isAstNode(element)) {</span><span class="s3">\n                        </span><span class="s1">copiedArray.push(copyAstNode(element, buildReference));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (isReference(element)) {</span><span class="s3">\n                        </span><span class="s1">copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">copiedArray.push(element);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">copy[name] = copiedArray;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">copy[name] = value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">linkContentToContainer(copy);</span><span class="s3">\n    </span><span class="s1">return copy;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ast-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { TreeStreamImpl } from './stream.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all CST nodes that are directly and indirectly contained in the given root node,</span><span class="s3">\n </span><span class="s1">* including the root node itself.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function streamCst(node) {</span><span class="s3">\n    </span><span class="s1">return new TreeStreamImpl(node, element =&gt; {</span><span class="s3">\n        </span><span class="s1">if (isCompositeCstNode(element)) {</span><span class="s3">\n            </span><span class="s1">return element.content;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, { includeRoot: true });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function flattenCst(node) {</span><span class="s3">\n    </span><span class="s1">return streamCst(node).filter(isLeafCstNode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the specified cst node is a child of the specified parent node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isChildNode(child, parent) {</span><span class="s3">\n    </span><span class="s1">while (child.container) {</span><span class="s3">\n        </span><span class="s1">child = child.container;</span><span class="s3">\n        </span><span class="s1">if (child === parent) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function tokenToRange(token) {</span><span class="s3">\n    </span><span class="s1">// Chevrotain uses 1-based indices everywhere</span><span class="s3">\n    </span><span class="s1">// So we subtract 1 from every value to align with the LSP</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">start: {</span><span class="s3">\n            </span><span class="s1">character: token.startColumn - 1,</span><span class="s3">\n            </span><span class="s1">line: token.startLine - 1</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">end: {</span><span class="s3">\n            </span><span class="s1">character: token.endColumn, // endColumn uses the correct index</span><span class="s3">\n            </span><span class="s1">line: token.endLine - 1</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function toDocumentSegment(node) {</span><span class="s3">\n    </span><span class="s1">if (!node) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { offset, end, range } = node;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">range,</span><span class="s3">\n        </span><span class="s1">offset,</span><span class="s3">\n        </span><span class="s1">end,</span><span class="s3">\n        </span><span class="s1">length: end - offset</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export var RangeComparison;</span><span class="s3">\n</span><span class="s1">(function (RangeComparison) {</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">Before</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Before</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">After</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">After</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">OverlapFront</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">OverlapFront</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">OverlapBack</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">OverlapBack</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">Inside</span><span class="s3">\&quot;</span><span class="s1">] = 4] = </span><span class="s3">\&quot;</span><span class="s1">Inside</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">RangeComparison[RangeComparison[</span><span class="s3">\&quot;</span><span class="s1">Outside</span><span class="s3">\&quot;</span><span class="s1">] = 5] = </span><span class="s3">\&quot;</span><span class="s1">Outside</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(RangeComparison || (RangeComparison = {}));</span><span class="s3">\n</span><span class="s1">export function compareRange(range, to) {</span><span class="s3">\n    </span><span class="s1">if (range.end.line &lt; to.start.line || (range.end.line === to.start.line &amp;&amp; range.end.character &lt;= to.start.character)) {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.Before;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (range.start.line &gt; to.end.line || (range.start.line === to.end.line &amp;&amp; range.start.character &gt;= to.end.character)) {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.After;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const startInside = range.start.line &gt; to.start.line || (range.start.line === to.start.line &amp;&amp; range.start.character &gt;= to.start.character);</span><span class="s3">\n    </span><span class="s1">const endInside = range.end.line &lt; to.end.line || (range.end.line === to.end.line &amp;&amp; range.end.character &lt;= to.end.character);</span><span class="s3">\n    </span><span class="s1">if (startInside &amp;&amp; endInside) {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.Inside;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (startInside) {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.OverlapBack;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (endInside) {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.OverlapFront;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return RangeComparison.Outside;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function inRange(range, to) {</span><span class="s3">\n    </span><span class="s1">const comparison = compareRange(range, to);</span><span class="s3">\n    </span><span class="s1">return comparison &gt; RangeComparison.After;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// The </span><span class="s3">\\</span><span class="s1">p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets</span><span class="s3">\n</span><span class="s1">// Together with </span><span class="s3">\\</span><span class="s1">w it matches any kind of character which can commonly appear in IDs</span><span class="s3">\n</span><span class="s1">export const DefaultNameRegexp = /^[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">p{L}]$/u;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,</span><span class="s3">\n </span><span class="s1">* it will instead return the leaf node at the `offset - 1` position.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {</span><span class="s3">\n    </span><span class="s1">if (cstNode) {</span><span class="s3">\n        </span><span class="s1">if (offset &gt; 0) {</span><span class="s3">\n            </span><span class="s1">const localOffset = offset - cstNode.offset;</span><span class="s3">\n            </span><span class="s1">const textAtOffset = cstNode.text.charAt(localOffset);</span><span class="s3">\n            </span><span class="s1">if (!nameRegexp.test(textAtOffset)) {</span><span class="s3">\n                </span><span class="s1">offset--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return findLeafNodeAtOffset(cstNode, offset);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findCommentNode(cstNode, commentNames) {</span><span class="s3">\n    </span><span class="s1">if (cstNode) {</span><span class="s3">\n        </span><span class="s1">const previous = getPreviousNode(cstNode, true);</span><span class="s3">\n        </span><span class="s1">if (previous &amp;&amp; isCommentNode(previous, commentNames)) {</span><span class="s3">\n            </span><span class="s1">return previous;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isRootCstNode(cstNode)) {</span><span class="s3">\n            </span><span class="s1">// Go from the first non-hidden node through all nodes in reverse order</span><span class="s3">\n            </span><span class="s1">// We do this to find the comment node which directly precedes the root node</span><span class="s3">\n            </span><span class="s1">const endIndex = cstNode.content.findIndex(e =&gt; !e.hidden);</span><span class="s3">\n            </span><span class="s1">for (let i = endIndex - 1; i &gt;= 0; i--) {</span><span class="s3">\n                </span><span class="s1">const child = cstNode.content[i];</span><span class="s3">\n                </span><span class="s1">if (isCommentNode(child, commentNames)) {</span><span class="s3">\n                    </span><span class="s1">return child;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isCommentNode(cstNode, commentNames) {</span><span class="s3">\n    </span><span class="s1">return isLeafCstNode(cstNode) &amp;&amp; commentNames.includes(cstNode.tokenType.name);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds the leaf CST node at the specified 0-based string offset.</span><span class="s3">\n </span><span class="s1">* Note that the given offset will be within the range of the returned leaf node.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If the offset does not point to a CST node (but just white space), this method will return `undefined`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node The CST node to search through.</span><span class="s3">\n </span><span class="s1">* @param offset The specified offset.</span><span class="s3">\n </span><span class="s1">* @returns The CST node at the specified offset.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findLeafNodeAtOffset(node, offset) {</span><span class="s3">\n    </span><span class="s1">if (isLeafCstNode(node)) {</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isCompositeCstNode(node)) {</span><span class="s3">\n        </span><span class="s1">const searchResult = binarySearch(node, offset, false);</span><span class="s3">\n        </span><span class="s1">if (searchResult) {</span><span class="s3">\n            </span><span class="s1">return findLeafNodeAtOffset(searchResult, offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Finds the leaf CST node at the specified 0-based string offset.</span><span class="s3">\n </span><span class="s1">* If no CST node exists at the specified position, it will return the leaf node before it.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If there is no leaf node before the specified offset, this method will return `undefined`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node The CST node to search through.</span><span class="s3">\n </span><span class="s1">* @param offset The specified offset.</span><span class="s3">\n </span><span class="s1">* @returns The CST node closest to the specified offset.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findLeafNodeBeforeOffset(node, offset) {</span><span class="s3">\n    </span><span class="s1">if (isLeafCstNode(node)) {</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isCompositeCstNode(node)) {</span><span class="s3">\n        </span><span class="s1">const searchResult = binarySearch(node, offset, true);</span><span class="s3">\n        </span><span class="s1">if (searchResult) {</span><span class="s3">\n            </span><span class="s1">return findLeafNodeBeforeOffset(searchResult, offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function binarySearch(node, offset, closest) {</span><span class="s3">\n    </span><span class="s1">let left = 0;</span><span class="s3">\n    </span><span class="s1">let right = node.content.length - 1;</span><span class="s3">\n    </span><span class="s1">let closestNode = undefined;</span><span class="s3">\n    </span><span class="s1">while (left &lt;= right) {</span><span class="s3">\n        </span><span class="s1">const middle = Math.floor((left + right) / 2);</span><span class="s3">\n        </span><span class="s1">const middleNode = node.content[middle];</span><span class="s3">\n        </span><span class="s1">if (middleNode.offset &lt;= offset &amp;&amp; middleNode.end &gt; offset) {</span><span class="s3">\n            </span><span class="s1">// Found an exact match</span><span class="s3">\n            </span><span class="s1">return middleNode;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (middleNode.end &lt;= offset) {</span><span class="s3">\n            </span><span class="s1">// Update the closest node (less than offset) and move to the right half</span><span class="s3">\n            </span><span class="s1">closestNode = closest ? middleNode : undefined;</span><span class="s3">\n            </span><span class="s1">left = middle + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Move to the left half</span><span class="s3">\n            </span><span class="s1">right = middle - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return closestNode;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getPreviousNode(node, hidden = true) {</span><span class="s3">\n    </span><span class="s1">while (node.container) {</span><span class="s3">\n        </span><span class="s1">const parent = node.container;</span><span class="s3">\n        </span><span class="s1">let index = parent.content.indexOf(node);</span><span class="s3">\n        </span><span class="s1">while (index &gt; 0) {</span><span class="s3">\n            </span><span class="s1">index--;</span><span class="s3">\n            </span><span class="s1">const previous = parent.content[index];</span><span class="s3">\n            </span><span class="s1">if (hidden || !previous.hidden) {</span><span class="s3">\n                </span><span class="s1">return previous;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getNextNode(node, hidden = true) {</span><span class="s3">\n    </span><span class="s1">while (node.container) {</span><span class="s3">\n        </span><span class="s1">const parent = node.container;</span><span class="s3">\n        </span><span class="s1">let index = parent.content.indexOf(node);</span><span class="s3">\n        </span><span class="s1">const last = parent.content.length - 1;</span><span class="s3">\n        </span><span class="s1">while (index &lt; last) {</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n            </span><span class="s1">const next = parent.content[index];</span><span class="s3">\n            </span><span class="s1">if (hidden || !next.hidden) {</span><span class="s3">\n                </span><span class="s1">return next;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">node = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getStartlineNode(node) {</span><span class="s3">\n    </span><span class="s1">if (node.range.start.character === 0) {</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const line = node.range.start.line;</span><span class="s3">\n    </span><span class="s1">let last = node;</span><span class="s3">\n    </span><span class="s1">let index;</span><span class="s3">\n    </span><span class="s1">while (node.container) {</span><span class="s3">\n        </span><span class="s1">const parent = node.container;</span><span class="s3">\n        </span><span class="s1">const selfIndex = index !== null &amp;&amp; index !== void 0 ? index : parent.content.indexOf(node);</span><span class="s3">\n        </span><span class="s1">if (selfIndex === 0) {</span><span class="s3">\n            </span><span class="s1">node = parent;</span><span class="s3">\n            </span><span class="s1">index = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">index = selfIndex - 1;</span><span class="s3">\n            </span><span class="s1">node = parent.content[index];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node.range.start.line !== line) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">last = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return last;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getInteriorNodes(start, end) {</span><span class="s3">\n    </span><span class="s1">const commonParent = getCommonParent(start, end);</span><span class="s3">\n    </span><span class="s1">if (!commonParent) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getCommonParent(a, b) {</span><span class="s3">\n    </span><span class="s1">const aParents = getParentChain(a);</span><span class="s3">\n    </span><span class="s1">const bParents = getParentChain(b);</span><span class="s3">\n    </span><span class="s1">let current;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; aParents.length &amp;&amp; i &lt; bParents.length; i++) {</span><span class="s3">\n        </span><span class="s1">const aParent = aParents[i];</span><span class="s3">\n        </span><span class="s1">const bParent = bParents[i];</span><span class="s3">\n        </span><span class="s1">if (aParent.parent === bParent.parent) {</span><span class="s3">\n            </span><span class="s1">current = {</span><span class="s3">\n                </span><span class="s1">parent: aParent.parent,</span><span class="s3">\n                </span><span class="s1">a: aParent.index,</span><span class="s3">\n                </span><span class="s1">b: bParent.index</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return current;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getParentChain(node) {</span><span class="s3">\n    </span><span class="s1">const chain = [];</span><span class="s3">\n    </span><span class="s1">while (node.container) {</span><span class="s3">\n        </span><span class="s1">const parent = node.container;</span><span class="s3">\n        </span><span class="s1">const index = parent.content.indexOf(node);</span><span class="s3">\n        </span><span class="s1">chain.push({</span><span class="s3">\n            </span><span class="s1">parent,</span><span class="s3">\n            </span><span class="s1">index</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">node = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return chain.reverse();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=cst-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export class ErrorWithLocation extends Error {</span><span class="s3">\n    </span><span class="s1">constructor(node, message) {</span><span class="s3">\n        </span><span class="s1">super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function assertUnreachable(_) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Error! The input value was not handled.');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=errors.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021-2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { assertUnreachable } from '../utils/errors.js';</span><span class="s3">\n</span><span class="s1">import * as ast from '../languages/generated/ast.js';</span><span class="s3">\n</span><span class="s1">import { isCompositeCstNode } from '../syntax-tree.js';</span><span class="s3">\n</span><span class="s1">import { getContainerOfType, streamAllContents } from './ast-utils.js';</span><span class="s3">\n</span><span class="s1">import { streamCst } from './cst-utils.js';</span><span class="s3">\n</span><span class="s1">import { escapeRegExp, isWhitespace } from './regexp-utils.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,</span><span class="s3">\n </span><span class="s1">* the result is `undefined`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getEntryRule(grammar) {</span><span class="s3">\n    </span><span class="s1">return grammar.rules.find(e =&gt; ast.isParserRule(e) &amp;&amp; e.entry);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns all hidden terminal rules of the given grammar, if any.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getHiddenRules(grammar) {</span><span class="s3">\n    </span><span class="s1">return grammar.rules.filter((e) =&gt; ast.isTerminalRule(e) &amp;&amp; e.hidden);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param grammar The grammar that contains all rules</span><span class="s3">\n </span><span class="s1">* @param allTerminals Whether or not to include terminals that are referenced only by other terminals</span><span class="s3">\n </span><span class="s1">* @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,</span><span class="s3">\n </span><span class="s1">*      this function returns all rules of the specified grammar.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getAllReachableRules(grammar, allTerminals) {</span><span class="s3">\n    </span><span class="s1">const ruleNames = new Set();</span><span class="s3">\n    </span><span class="s1">const entryRule = getEntryRule(grammar);</span><span class="s3">\n    </span><span class="s1">if (!entryRule) {</span><span class="s3">\n        </span><span class="s1">return new Set(grammar.rules);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const topMostRules = [entryRule].concat(getHiddenRules(grammar));</span><span class="s3">\n    </span><span class="s1">for (const rule of topMostRules) {</span><span class="s3">\n        </span><span class="s1">ruleDfs(rule, ruleNames, allTerminals);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const rules = new Set();</span><span class="s3">\n    </span><span class="s1">for (const rule of grammar.rules) {</span><span class="s3">\n        </span><span class="s1">if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) &amp;&amp; rule.hidden)) {</span><span class="s3">\n            </span><span class="s1">rules.add(rule);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return rules;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ruleDfs(rule, visitedSet, allTerminals) {</span><span class="s3">\n    </span><span class="s1">visitedSet.add(rule.name);</span><span class="s3">\n    </span><span class="s1">streamAllContents(rule).forEach(node =&gt; {</span><span class="s3">\n        </span><span class="s1">if (ast.isRuleCall(node) || (allTerminals &amp;&amp; ast.isTerminalRuleCall(node))) {</span><span class="s3">\n            </span><span class="s1">const refRule = node.rule.ref;</span><span class="s3">\n            </span><span class="s1">if (refRule &amp;&amp; !visitedSet.has(refRule.name)) {</span><span class="s3">\n                </span><span class="s1">ruleDfs(refRule, visitedSet, allTerminals);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).</span><span class="s3">\n </span><span class="s1">* A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`</span><span class="s3">\n </span><span class="s1">* is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared</span><span class="s3">\n </span><span class="s1">* and cannot be inferred.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getCrossReferenceTerminal(crossRef) {</span><span class="s3">\n    </span><span class="s1">if (crossRef.terminal) {</span><span class="s3">\n        </span><span class="s1">return crossRef.terminal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (crossRef.type.ref) {</span><span class="s3">\n        </span><span class="s1">const nameAssigment = findNameAssignment(crossRef.type.ref);</span><span class="s3">\n        </span><span class="s1">return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the given terminal rule represents a comment. This is true if the rule is marked</span><span class="s3">\n </span><span class="s1">* as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)</span><span class="s3">\n </span><span class="s1">* that contains visible characters is considered a comment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isCommentTerminal(terminalRule) {</span><span class="s3">\n    </span><span class="s1">return terminalRule.hidden &amp;&amp; !isWhitespace(terminalRegex(terminalRule));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find all CST nodes within the given node that contribute to the specified property.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.</span><span class="s3">\n </span><span class="s1">* @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findNodesForProperty(node, property) {</span><span class="s3">\n    </span><span class="s1">if (!node || !property) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return findNodesForPropertyInternal(node, property, node.astNode, true);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find a single CST node within the given node that contributes to the specified property.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.</span><span class="s3">\n </span><span class="s1">* @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.</span><span class="s3">\n </span><span class="s1">* @param index If no index is specified or the index is less than zero, the first found node is returned. If the</span><span class="s3">\n </span><span class="s1">*        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,</span><span class="s3">\n </span><span class="s1">*        the node with the specified index is returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findNodeForProperty(node, property, index) {</span><span class="s3">\n    </span><span class="s1">if (!node || !property) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);</span><span class="s3">\n    </span><span class="s1">if (nodes.length === 0) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (index !== undefined) {</span><span class="s3">\n        </span><span class="s1">index = Math.max(0, Math.min(index, nodes.length - 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">index = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return nodes[index];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findNodesForPropertyInternal(node, property, element, first) {</span><span class="s3">\n    </span><span class="s1">if (!first) {</span><span class="s3">\n        </span><span class="s1">const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);</span><span class="s3">\n        </span><span class="s1">if (nodeFeature &amp;&amp; nodeFeature.feature === property) {</span><span class="s3">\n            </span><span class="s1">return [node];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isCompositeCstNode(node) &amp;&amp; node.astNode === element) {</span><span class="s3">\n        </span><span class="s1">return node.content.flatMap(e =&gt; findNodesForPropertyInternal(e, property, element, false));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find all CST nodes within the given node that correspond to the specified keyword.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.</span><span class="s3">\n </span><span class="s1">* @param keyword A keyword as specified in the grammar.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findNodesForKeyword(node, keyword) {</span><span class="s3">\n    </span><span class="s1">if (!node) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find a single CST node within the given node that corresponds to the specified keyword.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.</span><span class="s3">\n </span><span class="s1">* @param keyword A keyword as specified in the grammar.</span><span class="s3">\n </span><span class="s1">* @param index If no index is specified or the index is less than zero, the first found node is returned. If the</span><span class="s3">\n </span><span class="s1">*        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,</span><span class="s3">\n </span><span class="s1">*        the node with the specified index is returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findNodeForKeyword(node, keyword, index) {</span><span class="s3">\n    </span><span class="s1">if (!node) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);</span><span class="s3">\n    </span><span class="s1">if (nodes.length === 0) {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (index !== undefined) {</span><span class="s3">\n        </span><span class="s1">index = Math.max(0, Math.min(index, nodes.length - 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">index = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return nodes[index];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function findNodesForKeywordInternal(node, keyword, element) {</span><span class="s3">\n    </span><span class="s1">if (node.astNode !== element) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ast.isKeyword(node.grammarSource) &amp;&amp; node.grammarSource.value === keyword) {</span><span class="s3">\n        </span><span class="s1">return [node];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const treeIterator = streamCst(node).iterator();</span><span class="s3">\n    </span><span class="s1">let result;</span><span class="s3">\n    </span><span class="s1">const keywordNodes = [];</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">result = treeIterator.next();</span><span class="s3">\n        </span><span class="s1">if (!result.done) {</span><span class="s3">\n            </span><span class="s1">const childNode = result.value;</span><span class="s3">\n            </span><span class="s1">if (childNode.astNode === element) {</span><span class="s3">\n                </span><span class="s1">if (ast.isKeyword(childNode.grammarSource) &amp;&amp; childNode.grammarSource.value === keyword) {</span><span class="s3">\n                    </span><span class="s1">keywordNodes.push(childNode);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">treeIterator.prune();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} while (!result.done);</span><span class="s3">\n    </span><span class="s1">return keywordNodes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar</span><span class="s3">\n </span><span class="s1">* node is returned. If no assignment is found, the result is `undefined`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cstNode A CST node for which to find a property assignment.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findAssignment(cstNode) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">const astNode = cstNode.astNode;</span><span class="s3">\n    </span><span class="s1">// Only search until the ast node of the parent cst node is no longer the original ast node</span><span class="s3">\n    </span><span class="s1">// This would make us jump to a preceding rule call, which contains only unrelated assignments</span><span class="s3">\n    </span><span class="s1">while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {</span><span class="s3">\n        </span><span class="s1">const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);</span><span class="s3">\n        </span><span class="s1">if (assignment) {</span><span class="s3">\n            </span><span class="s1">return assignment;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cstNode = cstNode.container;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred</span><span class="s3">\n </span><span class="s1">* from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,</span><span class="s3">\n </span><span class="s1">* this function returns `undefined`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function findNameAssignment(type) {</span><span class="s3">\n    </span><span class="s1">let startNode = type;</span><span class="s3">\n    </span><span class="s1">if (ast.isInferredType(startNode)) {</span><span class="s3">\n        </span><span class="s1">// for inferred types, the location to start searching for the name-assignment is different</span><span class="s3">\n        </span><span class="s1">if (ast.isAction(startNode.$container)) {</span><span class="s3">\n            </span><span class="s1">// a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent</span><span class="s3">\n            </span><span class="s1">startNode = startNode.$container.$container;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ast.isParserRule(startNode.$container)) {</span><span class="s3">\n            </span><span class="s1">// investigate the parser rule with the explicitly inferred type</span><span class="s3">\n            </span><span class="s1">startNode = startNode.$container;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">assertUnreachable(startNode.$container);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return findNameAssignmentInternal(type, startNode, new Map());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findNameAssignmentInternal(type, startNode, cache) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">// the cache is only required to prevent infinite loops</span><span class="s3">\n    </span><span class="s1">function go(node, refType) {</span><span class="s3">\n        </span><span class="s1">let childAssignment = undefined;</span><span class="s3">\n        </span><span class="s1">const parentAssignment = getContainerOfType(node, ast.isAssignment);</span><span class="s3">\n        </span><span class="s1">// No parent assignment implies unassigned rule call</span><span class="s3">\n        </span><span class="s1">if (!parentAssignment) {</span><span class="s3">\n            </span><span class="s1">childAssignment = findNameAssignmentInternal(refType, refType, cache);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">cache.set(type, childAssignment);</span><span class="s3">\n        </span><span class="s1">return childAssignment;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cache.has(type)) {</span><span class="s3">\n        </span><span class="s1">return cache.get(type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cache.set(type, undefined);</span><span class="s3">\n    </span><span class="s1">for (const node of streamAllContents(startNode)) {</span><span class="s3">\n        </span><span class="s1">if (ast.isAssignment(node) &amp;&amp; node.feature.toLowerCase() === 'name') {</span><span class="s3">\n            </span><span class="s1">cache.set(type, node);</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ast.isRuleCall(node) &amp;&amp; ast.isParserRule(node.rule.ref)) {</span><span class="s3">\n            </span><span class="s1">return go(node, node.rule.ref);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ast.isSimpleType(node) &amp;&amp; ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {</span><span class="s3">\n            </span><span class="s1">return go(node, node.typeRef.ref);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getActionAtElement(element) {</span><span class="s3">\n    </span><span class="s1">const parent = element.$container;</span><span class="s3">\n    </span><span class="s1">if (ast.isGroup(parent)) {</span><span class="s3">\n        </span><span class="s1">const elements = parent.elements;</span><span class="s3">\n        </span><span class="s1">const index = elements.indexOf(element);</span><span class="s3">\n        </span><span class="s1">for (let i = index - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">const item = elements[i];</span><span class="s3">\n            </span><span class="s1">if (ast.isAction(item)) {</span><span class="s3">\n                </span><span class="s1">return item;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const action = streamAllContents(elements[i]).find(ast.isAction);</span><span class="s3">\n                </span><span class="s1">if (action) {</span><span class="s3">\n                    </span><span class="s1">return action;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ast.isAbstractElement(parent)) {</span><span class="s3">\n        </span><span class="s1">return getActionAtElement(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isOptionalCardinality(cardinality, element) {</span><span class="s3">\n    </span><span class="s1">return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) &amp;&amp; Boolean(element.guardCondition));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isArrayCardinality(cardinality) {</span><span class="s3">\n    </span><span class="s1">return cardinality === '*' || cardinality === '+';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isArrayOperator(operator) {</span><span class="s3">\n    </span><span class="s1">return operator === '+=';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the given parser rule is a _data type rule_, meaning that it has a</span><span class="s3">\n </span><span class="s1">* primitive return type like `number`, `boolean`, etc.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function isDataTypeRule(rule) {</span><span class="s3">\n    </span><span class="s1">return isDataTypeRuleInternal(rule, new Set());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isDataTypeRuleInternal(rule, visited) {</span><span class="s3">\n    </span><span class="s1">if (visited.has(rule)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">visited.add(rule);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (const node of streamAllContents(rule)) {</span><span class="s3">\n        </span><span class="s1">if (ast.isRuleCall(node)) {</span><span class="s3">\n            </span><span class="s1">if (!node.rule.ref) {</span><span class="s3">\n                </span><span class="s1">// RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (ast.isParserRule(node.rule.ref) &amp;&amp; !isDataTypeRuleInternal(node.rule.ref, visited)) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ast.isAssignment(node)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ast.isAction(node)) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Boolean(rule.definition);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isDataType(type) {</span><span class="s3">\n    </span><span class="s1">return isDataTypeInternal(type.type, new Set());</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isDataTypeInternal(type, visited) {</span><span class="s3">\n    </span><span class="s1">if (visited.has(type)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">visited.add(type);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ast.isArrayType(type)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isReferenceType(type)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isUnionType(type)) {</span><span class="s3">\n        </span><span class="s1">return type.types.every(e =&gt; isDataTypeInternal(e, visited));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isSimpleType(type)) {</span><span class="s3">\n        </span><span class="s1">if (type.primitiveType !== undefined) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type.stringType !== undefined) {</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (type.typeRef !== undefined) {</span><span class="s3">\n            </span><span class="s1">const ref = type.typeRef.ref;</span><span class="s3">\n            </span><span class="s1">if (ast.isType(ref)) {</span><span class="s3">\n                </span><span class="s1">return isDataTypeInternal(ref.type, visited);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getExplicitRuleType(rule) {</span><span class="s3">\n    </span><span class="s1">if (rule.inferredType) {</span><span class="s3">\n        </span><span class="s1">return rule.inferredType.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (rule.dataType) {</span><span class="s3">\n        </span><span class="s1">return rule.dataType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (rule.returnType) {</span><span class="s3">\n        </span><span class="s1">const refType = rule.returnType.ref;</span><span class="s3">\n        </span><span class="s1">if (refType) {</span><span class="s3">\n            </span><span class="s1">// check if we need to check Action as return type</span><span class="s3">\n            </span><span class="s1">if (ast.isParserRule(refType)) {</span><span class="s3">\n                </span><span class="s1">return refType.name;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ast.isInterface(refType) || ast.isType(refType)) {</span><span class="s3">\n                </span><span class="s1">return refType.name;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getTypeName(type) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (ast.isParserRule(type)) {</span><span class="s3">\n        </span><span class="s1">return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null &amp;&amp; _a !== void 0 ? _a : type.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {</span><span class="s3">\n        </span><span class="s1">return type.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isAction(type)) {</span><span class="s3">\n        </span><span class="s1">const actionType = getActionType(type);</span><span class="s3">\n        </span><span class="s1">if (actionType) {</span><span class="s3">\n            </span><span class="s1">return actionType;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isInferredType(type)) {</span><span class="s3">\n        </span><span class="s1">return type.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error('Cannot get name of Unknown Type');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getActionType(action) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (action.inferredType) {</span><span class="s3">\n        </span><span class="s1">return action.inferredType.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {</span><span class="s3">\n        </span><span class="s1">return getTypeName(action.type.ref);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return undefined; // not inferring and not referencing a valid type</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.</span><span class="s3">\n </span><span class="s1">* For data type rules, the name of the rule is returned,</span><span class="s3">\n </span><span class="s1">* e.g. </span><span class="s3">\&quot;</span><span class="s1">INT_value returns number: MY_INT;</span><span class="s3">\&quot; </span><span class="s1">returns </span><span class="s3">\&quot;</span><span class="s1">INT_value</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">* @param rule the given rule</span><span class="s3">\n </span><span class="s1">* @returns the name of the AST node type of the rule</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRuleTypeName(rule) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">if (ast.isTerminalRule(rule)) {</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null &amp;&amp; _b !== void 0 ? _b : 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null &amp;&amp; _c !== void 0 ? _c : rule.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is used at runtime to get the actual type of the values produced by the given rule at runtime.</span><span class="s3">\n </span><span class="s1">* For data type rules, the name of the declared return type of the rule is returned (if any),</span><span class="s3">\n </span><span class="s1">* e.g. </span><span class="s3">\&quot;</span><span class="s1">INT_value returns number: MY_INT;</span><span class="s3">\&quot; </span><span class="s1">returns </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">* @param rule the given rule</span><span class="s3">\n </span><span class="s1">* @returns the name of the type of the produced values of the rule at runtime</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getRuleType(rule) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n    </span><span class="s1">if (ast.isTerminalRule(rule)) {</span><span class="s3">\n        </span><span class="s1">return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null &amp;&amp; _b !== void 0 ? _b : 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return (_c = getExplicitRuleType(rule)) !== null &amp;&amp; _c !== void 0 ? _c : rule.name;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function terminalRegex(terminalRule) {</span><span class="s3">\n    </span><span class="s1">const flags = {</span><span class="s3">\n        </span><span class="s1">s: false,</span><span class="s3">\n        </span><span class="s1">i: false,</span><span class="s3">\n        </span><span class="s1">u: false</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">const source = abstractElementToRegex(terminalRule.definition, flags);</span><span class="s3">\n    </span><span class="s1">const flagText = Object.entries(flags).filter(([, value]) =&gt; value).map(([name]) =&gt; name).join('');</span><span class="s3">\n    </span><span class="s1">return new RegExp(source, flagText);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Using [</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]* allows to match everything, compared to . which doesn't match line terminators</span><span class="s3">\n</span><span class="s1">const WILDCARD = /[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]/.source;</span><span class="s3">\n</span><span class="s1">function abstractElementToRegex(element, flags) {</span><span class="s3">\n    </span><span class="s1">if (ast.isTerminalAlternatives(element)) {</span><span class="s3">\n        </span><span class="s1">return terminalAlternativesToRegex(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isTerminalGroup(element)) {</span><span class="s3">\n        </span><span class="s1">return terminalGroupToRegex(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isCharacterRange(element)) {</span><span class="s3">\n        </span><span class="s1">return characterRangeToRegex(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isTerminalRuleCall(element)) {</span><span class="s3">\n        </span><span class="s1">const rule = element.rule.ref;</span><span class="s3">\n        </span><span class="s1">if (!rule) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Missing rule reference.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return withCardinality(abstractElementToRegex(rule.definition), {</span><span class="s3">\n            </span><span class="s1">cardinality: element.cardinality,</span><span class="s3">\n            </span><span class="s1">lookahead: element.lookahead</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isNegatedToken(element)) {</span><span class="s3">\n        </span><span class="s1">return negateTokenToRegex(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isUntilToken(element)) {</span><span class="s3">\n        </span><span class="s1">return untilTokenToRegex(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isRegexToken(element)) {</span><span class="s3">\n        </span><span class="s1">const lastSlash = element.regex.lastIndexOf('/');</span><span class="s3">\n        </span><span class="s1">const source = element.regex.substring(1, lastSlash);</span><span class="s3">\n        </span><span class="s1">const regexFlags = element.regex.substring(lastSlash + 1);</span><span class="s3">\n        </span><span class="s1">if (flags) {</span><span class="s3">\n            </span><span class="s1">flags.i = regexFlags.includes('i');</span><span class="s3">\n            </span><span class="s1">flags.s = regexFlags.includes('s');</span><span class="s3">\n            </span><span class="s1">flags.u = regexFlags.includes('u');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return withCardinality(source, {</span><span class="s3">\n            </span><span class="s1">cardinality: element.cardinality,</span><span class="s3">\n            </span><span class="s1">lookahead: element.lookahead,</span><span class="s3">\n            </span><span class="s1">wrap: false</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ast.isWildcard(element)) {</span><span class="s3">\n        </span><span class="s1">return withCardinality(WILDCARD, {</span><span class="s3">\n            </span><span class="s1">cardinality: element.cardinality,</span><span class="s3">\n            </span><span class="s1">lookahead: element.lookahead</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function terminalAlternativesToRegex(alternatives) {</span><span class="s3">\n    </span><span class="s1">return withCardinality(alternatives.elements.map(e =&gt; abstractElementToRegex(e)).join('|'), {</span><span class="s3">\n        </span><span class="s1">cardinality: alternatives.cardinality,</span><span class="s3">\n        </span><span class="s1">lookahead: alternatives.lookahead</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function terminalGroupToRegex(group) {</span><span class="s3">\n    </span><span class="s1">return withCardinality(group.elements.map(e =&gt; abstractElementToRegex(e)).join(''), {</span><span class="s3">\n        </span><span class="s1">cardinality: group.cardinality,</span><span class="s3">\n        </span><span class="s1">lookahead: group.lookahead</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function untilTokenToRegex(until) {</span><span class="s3">\n    </span><span class="s1">return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {</span><span class="s3">\n        </span><span class="s1">cardinality: until.cardinality,</span><span class="s3">\n        </span><span class="s1">lookahead: until.lookahead</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function negateTokenToRegex(negate) {</span><span class="s3">\n    </span><span class="s1">return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {</span><span class="s3">\n        </span><span class="s1">cardinality: negate.cardinality,</span><span class="s3">\n        </span><span class="s1">lookahead: negate.lookahead</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function characterRangeToRegex(range) {</span><span class="s3">\n    </span><span class="s1">if (range.right) {</span><span class="s3">\n        </span><span class="s1">return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {</span><span class="s3">\n            </span><span class="s1">cardinality: range.cardinality,</span><span class="s3">\n            </span><span class="s1">lookahead: range.lookahead,</span><span class="s3">\n            </span><span class="s1">wrap: false</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return withCardinality(keywordToRegex(range.left), {</span><span class="s3">\n        </span><span class="s1">cardinality: range.cardinality,</span><span class="s3">\n        </span><span class="s1">lookahead: range.lookahead,</span><span class="s3">\n        </span><span class="s1">wrap: false</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function keywordToRegex(keyword) {</span><span class="s3">\n    </span><span class="s1">return escapeRegExp(keyword.value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function withCardinality(regex, options) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (options.wrap !== false || options.lookahead) {</span><span class="s3">\n        </span><span class="s1">regex = `(${(_a = options.lookahead) !== null &amp;&amp; _a !== void 0 ? _a : ''}${regex})`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options.cardinality) {</span><span class="s3">\n        </span><span class="s1">return `${regex}${options.cardinality}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return regex;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=grammar-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">import { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';</span><span class="s3">\n</span><span class="s1">export const NEWLINE_REGEXP = /</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n/gm;</span><span class="s3">\n</span><span class="s1">const regexpParser = new RegExpParser();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class is in charge of heuristically identifying start/end tokens of terminals.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The way this works is by doing the following:</span><span class="s3">\n </span><span class="s1">* 1. Traverse the regular expression in the </span><span class="s3">\&quot;</span><span class="s1">start state</span><span class="s3">\&quot;\n </span><span class="s1">* 2. Add any encountered sets/single characters to the </span><span class="s3">\&quot;</span><span class="s1">start regexp</span><span class="s3">\&quot;\n </span><span class="s1">* 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the </span><span class="s3">\&quot;</span><span class="s1">end state</span><span class="s3">\&quot;\n </span><span class="s1">* 4. In the end state, any sets/single characters are added to an </span><span class="s3">\&quot;</span><span class="s1">end stack</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">* 5. If we re-encounter any variable-length content we reset the end stack</span><span class="s3">\n </span><span class="s1">* 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TerminalRegExpVisitor extends BaseRegExpVisitor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.isStarting = true;</span><span class="s3">\n        </span><span class="s1">this.endRegexpStack = [];</span><span class="s3">\n        </span><span class="s1">this.multiline = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get endRegex() {</span><span class="s3">\n        </span><span class="s1">return this.endRegexpStack.join('');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reset(regex) {</span><span class="s3">\n        </span><span class="s1">this.multiline = false;</span><span class="s3">\n        </span><span class="s1">this.regex = regex;</span><span class="s3">\n        </span><span class="s1">this.startRegexp = '';</span><span class="s3">\n        </span><span class="s1">this.isStarting = true;</span><span class="s3">\n        </span><span class="s1">this.endRegexpStack = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitGroup(node) {</span><span class="s3">\n        </span><span class="s1">if (node.quantifier) {</span><span class="s3">\n            </span><span class="s1">this.isStarting = false;</span><span class="s3">\n            </span><span class="s1">this.endRegexpStack = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitCharacter(node) {</span><span class="s3">\n        </span><span class="s1">const char = String.fromCharCode(node.value);</span><span class="s3">\n        </span><span class="s1">if (!this.multiline &amp;&amp; char === '</span><span class="s3">\\</span><span class="s1">n') {</span><span class="s3">\n            </span><span class="s1">this.multiline = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node.quantifier) {</span><span class="s3">\n            </span><span class="s1">this.isStarting = false;</span><span class="s3">\n            </span><span class="s1">this.endRegexpStack = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const escapedChar = escapeRegExp(char);</span><span class="s3">\n            </span><span class="s1">this.endRegexpStack.push(escapedChar);</span><span class="s3">\n            </span><span class="s1">if (this.isStarting) {</span><span class="s3">\n                </span><span class="s1">this.startRegexp += escapedChar;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitSet(node) {</span><span class="s3">\n        </span><span class="s1">if (!this.multiline) {</span><span class="s3">\n            </span><span class="s1">const set = this.regex.substring(node.loc.begin, node.loc.end);</span><span class="s3">\n            </span><span class="s1">const regex = new RegExp(set);</span><span class="s3">\n            </span><span class="s1">this.multiline = Boolean('</span><span class="s3">\\</span><span class="s1">n'.match(regex));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (node.quantifier) {</span><span class="s3">\n            </span><span class="s1">this.isStarting = false;</span><span class="s3">\n            </span><span class="s1">this.endRegexpStack = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const set = this.regex.substring(node.loc.begin, node.loc.end);</span><span class="s3">\n            </span><span class="s1">this.endRegexpStack.push(set);</span><span class="s3">\n            </span><span class="s1">if (this.isStarting) {</span><span class="s3">\n                </span><span class="s1">this.startRegexp += set;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">visitChildren(node) {</span><span class="s3">\n        </span><span class="s1">if (node.type === 'Group') {</span><span class="s3">\n            </span><span class="s1">// Ignore children of groups with quantifier (+/*/?)</span><span class="s3">\n            </span><span class="s1">// These groups are unrelated to start/end tokens of terminals</span><span class="s3">\n            </span><span class="s1">const group = node;</span><span class="s3">\n            </span><span class="s1">if (group.quantifier) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">super.visitChildren(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const visitor = new TerminalRegExpVisitor();</span><span class="s3">\n</span><span class="s1">export function getTerminalParts(regexp) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof regexp !== 'string') {</span><span class="s3">\n            </span><span class="s1">regexp = regexp.source;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">regexp = `/${regexp}/`;</span><span class="s3">\n        </span><span class="s1">const pattern = regexpParser.pattern(regexp);</span><span class="s3">\n        </span><span class="s1">const parts = [];</span><span class="s3">\n        </span><span class="s1">for (const alternative of pattern.value.value) {</span><span class="s3">\n            </span><span class="s1">visitor.reset(regexp);</span><span class="s3">\n            </span><span class="s1">visitor.visit(alternative);</span><span class="s3">\n            </span><span class="s1">parts.push({</span><span class="s3">\n                </span><span class="s1">start: visitor.startRegexp,</span><span class="s3">\n                </span><span class="s1">end: visitor.endRegex</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return parts;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_a) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function isMultilineComment(regexp) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof regexp === 'string') {</span><span class="s3">\n            </span><span class="s1">regexp = new RegExp(regexp);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">regexp = regexp.toString();</span><span class="s3">\n        </span><span class="s1">visitor.reset(regexp);</span><span class="s3">\n        </span><span class="s1">// Parsing the pattern might fail (since it's user code)</span><span class="s3">\n        </span><span class="s1">visitor.visit(regexpParser.pattern(regexp));</span><span class="s3">\n        </span><span class="s1">return visitor.multiline;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_a) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of all characters that are considered whitespace by the '</span><span class="s3">\\</span><span class="s1">s' RegExp character class.</span><span class="s3">\n </span><span class="s1">* Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const whitespaceCharacters = ('</span><span class="s3">\\</span><span class="s1">f</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">t</span><span class="s3">\\</span><span class="s1">v</span><span class="s3">\\</span><span class="s1">u0020</span><span class="s3">\\</span><span class="s1">u00a0</span><span class="s3">\\</span><span class="s1">u1680</span><span class="s3">\\</span><span class="s1">u2000</span><span class="s3">\\</span><span class="s1">u2001</span><span class="s3">\\</span><span class="s1">u2002</span><span class="s3">\\</span><span class="s1">u2003</span><span class="s3">\\</span><span class="s1">u2004</span><span class="s3">\\</span><span class="s1">u2005</span><span class="s3">\\</span><span class="s1">u2006</span><span class="s3">\\</span><span class="s1">u2007' +</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\\</span><span class="s1">u2008</span><span class="s3">\\</span><span class="s1">u2009</span><span class="s3">\\</span><span class="s1">u200a</span><span class="s3">\\</span><span class="s1">u2028</span><span class="s3">\\</span><span class="s1">u2029</span><span class="s3">\\</span><span class="s1">u202f</span><span class="s3">\\</span><span class="s1">u205f</span><span class="s3">\\</span><span class="s1">u3000</span><span class="s3">\\</span><span class="s1">ufeff').split('');</span><span class="s3">\n</span><span class="s1">export function isWhitespace(value) {</span><span class="s3">\n    </span><span class="s1">const regexp = typeof value === 'string' ? new RegExp(value) : value;</span><span class="s3">\n    </span><span class="s1">return whitespaceCharacters.some((ws) =&gt; regexp.test(ws));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function escapeRegExp(value) {</span><span class="s3">\n    </span><span class="s1">return value.replace(/[.*+?^${}()|[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">]/g, '</span><span class="s3">\\\\</span><span class="s1">$&amp;');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export function getCaseInsensitivePattern(keyword) {</span><span class="s3">\n    </span><span class="s1">return Array.prototype.map.call(keyword, letter =&gt; /</span><span class="s3">\\</span><span class="s1">w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Determines whether the given input has a partial match with the specified regex.</span><span class="s3">\n </span><span class="s1">* @param regex The regex to partially match against</span><span class="s3">\n </span><span class="s1">* @param input The input string</span><span class="s3">\n </span><span class="s1">* @returns Whether any match exists.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function partialMatches(regex, input) {</span><span class="s3">\n    </span><span class="s1">const partial = partialRegExp(regex);</span><span class="s3">\n    </span><span class="s1">const match = input.match(partial);</span><span class="s3">\n    </span><span class="s1">return !!match &amp;&amp; match[0].length &gt; 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.</span><span class="s3">\n </span><span class="s1">* a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.</span><span class="s3">\n </span><span class="s1">* @param regex The input regex to be converted.</span><span class="s3">\n </span><span class="s1">* @returns A partial regex constructed from the input regex.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function partialRegExp(regex) {</span><span class="s3">\n    </span><span class="s1">if (typeof regex === 'string') {</span><span class="s3">\n        </span><span class="s1">regex = new RegExp(regex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const re = regex, source = regex.source;</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">function process() {</span><span class="s3">\n        </span><span class="s1">let result = '', tmp;</span><span class="s3">\n        </span><span class="s1">function appendRaw(nbChars) {</span><span class="s3">\n            </span><span class="s1">result += source.substr(i, nbChars);</span><span class="s3">\n            </span><span class="s1">i += nbChars;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function appendOptional(nbChars) {</span><span class="s3">\n            </span><span class="s1">result += '(?:' + source.substr(i, nbChars) + '|$)';</span><span class="s3">\n            </span><span class="s1">i += nbChars;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (i &lt; source.length) {</span><span class="s3">\n            </span><span class="s1">switch (source[i]) {</span><span class="s3">\n                </span><span class="s1">case '</span><span class="s3">\\\\</span><span class="s1">':</span><span class="s3">\n                    </span><span class="s1">switch (source[i + 1]) {</span><span class="s3">\n                        </span><span class="s1">case 'c':</span><span class="s3">\n                            </span><span class="s1">appendOptional(3);</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'x':</span><span class="s3">\n                            </span><span class="s1">appendOptional(4);</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'u':</span><span class="s3">\n                            </span><span class="s1">if (re.unicode) {</span><span class="s3">\n                                </span><span class="s1">if (source[i + 2] === '{') {</span><span class="s3">\n                                    </span><span class="s1">appendOptional(source.indexOf('}', i) - i + 1);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">appendOptional(6);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else {</span><span class="s3">\n                                </span><span class="s1">appendOptional(2);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'p':</span><span class="s3">\n                        </span><span class="s1">case 'P':</span><span class="s3">\n                            </span><span class="s1">if (re.unicode) {</span><span class="s3">\n                                </span><span class="s1">appendOptional(source.indexOf('}', i) - i + 1);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else {</span><span class="s3">\n                                </span><span class="s1">appendOptional(2);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'k':</span><span class="s3">\n                            </span><span class="s1">appendOptional(source.indexOf('&gt;', i) - i + 1);</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">default:</span><span class="s3">\n                            </span><span class="s1">appendOptional(2);</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case '[':</span><span class="s3">\n                    </span><span class="s1">tmp = /</span><span class="s3">\\</span><span class="s1">[(?:</span><span class="s3">\\\\</span><span class="s1">.|.)*?</span><span class="s3">\\</span><span class="s1">]/g;</span><span class="s3">\n                    </span><span class="s1">tmp.lastIndex = i;</span><span class="s3">\n                    </span><span class="s1">tmp = tmp.exec(source) || [];</span><span class="s3">\n                    </span><span class="s1">appendOptional(tmp[0].length);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case '|':</span><span class="s3">\n                </span><span class="s1">case '^':</span><span class="s3">\n                </span><span class="s1">case '$':</span><span class="s3">\n                </span><span class="s1">case '*':</span><span class="s3">\n                </span><span class="s1">case '+':</span><span class="s3">\n                </span><span class="s1">case '?':</span><span class="s3">\n                    </span><span class="s1">appendRaw(1);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case '{':</span><span class="s3">\n                    </span><span class="s1">tmp = /</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">d+,?</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">}/g;</span><span class="s3">\n                    </span><span class="s1">tmp.lastIndex = i;</span><span class="s3">\n                    </span><span class="s1">tmp = tmp.exec(source);</span><span class="s3">\n                    </span><span class="s1">if (tmp) {</span><span class="s3">\n                        </span><span class="s1">appendRaw(tmp[0].length);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">appendOptional(1);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case '(':</span><span class="s3">\n                    </span><span class="s1">if (source[i + 1] === '?') {</span><span class="s3">\n                        </span><span class="s1">switch (source[i + 2]) {</span><span class="s3">\n                            </span><span class="s1">case ':':</span><span class="s3">\n                                </span><span class="s1">result += '(?:';</span><span class="s3">\n                                </span><span class="s1">i += 3;</span><span class="s3">\n                                </span><span class="s1">result += process() + '|$)';</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case '=':</span><span class="s3">\n                                </span><span class="s1">result += '(?=';</span><span class="s3">\n                                </span><span class="s1">i += 3;</span><span class="s3">\n                                </span><span class="s1">result += process() + ')';</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case '!':</span><span class="s3">\n                                </span><span class="s1">tmp = i;</span><span class="s3">\n                                </span><span class="s1">i += 3;</span><span class="s3">\n                                </span><span class="s1">process();</span><span class="s3">\n                                </span><span class="s1">result += source.substr(tmp, i - tmp);</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case '&lt;':</span><span class="s3">\n                                </span><span class="s1">switch (source[i + 3]) {</span><span class="s3">\n                                    </span><span class="s1">case '=':</span><span class="s3">\n                                    </span><span class="s1">case '!':</span><span class="s3">\n                                        </span><span class="s1">tmp = i;</span><span class="s3">\n                                        </span><span class="s1">i += 4;</span><span class="s3">\n                                        </span><span class="s1">process();</span><span class="s3">\n                                        </span><span class="s1">result += source.substr(tmp, i - tmp);</span><span class="s3">\n                                        </span><span class="s1">break;</span><span class="s3">\n                                    </span><span class="s1">default:</span><span class="s3">\n                                        </span><span class="s1">appendRaw(source.indexOf('&gt;', i) - i + 1);</span><span class="s3">\n                                        </span><span class="s1">result += process() + '|$)';</span><span class="s3">\n                                        </span><span class="s1">break;</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">appendRaw(1);</span><span class="s3">\n                        </span><span class="s1">result += process() + '|$)';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case ')':</span><span class="s3">\n                    </span><span class="s1">++i;</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">default:</span><span class="s3">\n                    </span><span class="s1">appendOptional(1);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return new RegExp(process(), regex.flags);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=regexp-utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2021 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The default implementation of `Stream` works with two input functions:</span><span class="s3">\n </span><span class="s1">*  - The first function creates the initial state of an iteration.</span><span class="s3">\n </span><span class="s1">*  - The second function gets the current state as argument and returns an `IteratorResult`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class StreamImpl {</span><span class="s3">\n    </span><span class="s1">constructor(startFn, nextFn) {</span><span class="s3">\n        </span><span class="s1">this.startFn = startFn;</span><span class="s3">\n        </span><span class="s1">this.nextFn = nextFn;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterator() {</span><span class="s3">\n        </span><span class="s1">const iterator = {</span><span class="s3">\n            </span><span class="s1">state: this.startFn(),</span><span class="s3">\n            </span><span class="s1">next: () =&gt; this.nextFn(iterator.state),</span><span class="s3">\n            </span><span class="s1">[Symbol.iterator]: () =&gt; iterator</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return iterator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">[Symbol.iterator]() {</span><span class="s3">\n        </span><span class="s1">return this.iterator();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEmpty() {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">return Boolean(iterator.next().done);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">count() {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let count = 0;</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return count;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toArray() {</span><span class="s3">\n        </span><span class="s1">const result = [];</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let next;</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n            </span><span class="s1">if (next.value !== undefined) {</span><span class="s3">\n                </span><span class="s1">result.push(next.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} while (!next.done);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toSet() {</span><span class="s3">\n        </span><span class="s1">return new Set(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toMap(keyFn, valueFn) {</span><span class="s3">\n        </span><span class="s1">const entryStream = this.map(element =&gt; [</span><span class="s3">\n            </span><span class="s1">keyFn ? keyFn(element) : element,</span><span class="s3">\n            </span><span class="s1">valueFn ? valueFn(element) : element</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n        </span><span class="s1">return new Map(entryStream);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return this.join();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">concat(other) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state =&gt; {</span><span class="s3">\n            </span><span class="s1">let result;</span><span class="s3">\n            </span><span class="s1">if (!state.firstDone) {</span><span class="s3">\n                </span><span class="s1">do {</span><span class="s3">\n                    </span><span class="s1">result = this.nextFn(state.first);</span><span class="s3">\n                    </span><span class="s1">if (!result.done) {</span><span class="s3">\n                        </span><span class="s1">return result;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">} while (!result.done);</span><span class="s3">\n                </span><span class="s1">state.firstDone = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">result = state.iterator.next();</span><span class="s3">\n                </span><span class="s1">if (!result.done) {</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (!result.done);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">join(separator = ',') {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let value = '';</span><span class="s3">\n        </span><span class="s1">let result;</span><span class="s3">\n        </span><span class="s1">let addSeparator = false;</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n            </span><span class="s1">result = iterator.next();</span><span class="s3">\n            </span><span class="s1">if (!result.done) {</span><span class="s3">\n                </span><span class="s1">if (addSeparator) {</span><span class="s3">\n                    </span><span class="s1">value += separator;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">value += toString(result.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">addSeparator = true;</span><span class="s3">\n        </span><span class="s1">} while (!result.done);</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">indexOf(searchElement, fromIndex = 0) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let index = 0;</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (index &gt;= fromIndex &amp;&amp; next.value === searchElement) {</span><span class="s3">\n                </span><span class="s1">return index;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">every(predicate) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (!predicate(next.value)) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">some(predicate) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (predicate(next.value)) {</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forEach(callbackfn) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let index = 0;</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">callbackfn(next.value, index);</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(callbackfn) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(this.startFn, (state) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { done, value } = this.nextFn(state);</span><span class="s3">\n            </span><span class="s1">if (done) {</span><span class="s3">\n                </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">return { done: false, value: callbackfn(value) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">filter(predicate) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(this.startFn, state =&gt; {</span><span class="s3">\n            </span><span class="s1">let result;</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">result = this.nextFn(state);</span><span class="s3">\n                </span><span class="s1">if (!result.done &amp;&amp; predicate(result.value)) {</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (!result.done);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nonNullable() {</span><span class="s3">\n        </span><span class="s1">return this.filter(e =&gt; e !== undefined &amp;&amp; e !== null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reduce(callbackfn, initialValue) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let previousValue = initialValue;</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (previousValue === undefined) {</span><span class="s3">\n                </span><span class="s1">previousValue = next.value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">previousValue = callbackfn(previousValue, next.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return previousValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reduceRight(callbackfn, initialValue) {</span><span class="s3">\n        </span><span class="s1">return this.recursiveReduce(this.iterator(), callbackfn, initialValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">recursiveReduce(iterator, callbackfn, initialValue) {</span><span class="s3">\n        </span><span class="s1">const next = iterator.next();</span><span class="s3">\n        </span><span class="s1">if (next.done) {</span><span class="s3">\n            </span><span class="s1">return initialValue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);</span><span class="s3">\n        </span><span class="s1">if (previousValue === undefined) {</span><span class="s3">\n            </span><span class="s1">return next.value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return callbackfn(previousValue, next.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">find(predicate) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (predicate(next.value)) {</span><span class="s3">\n                </span><span class="s1">return next.value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">findIndex(predicate) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let index = 0;</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (predicate(next.value)) {</span><span class="s3">\n                </span><span class="s1">return index;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">includes(searchElement) {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">let next = iterator.next();</span><span class="s3">\n        </span><span class="s1">while (!next.done) {</span><span class="s3">\n            </span><span class="s1">if (next.value === searchElement) {</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">next = iterator.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flatMap(callbackfn) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ this: this.startFn() }), (state) =&gt; {</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">if (state.iterator) {</span><span class="s3">\n                    </span><span class="s1">const next = state.iterator.next();</span><span class="s3">\n                    </span><span class="s1">if (next.done) {</span><span class="s3">\n                        </span><span class="s1">state.iterator = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return next;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { done, value } = this.nextFn(state.this);</span><span class="s3">\n                </span><span class="s1">if (!done) {</span><span class="s3">\n                    </span><span class="s1">const mapped = callbackfn(value);</span><span class="s3">\n                    </span><span class="s1">if (isIterable(mapped)) {</span><span class="s3">\n                        </span><span class="s1">state.iterator = mapped[Symbol.iterator]();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return { done: false, value: mapped };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (state.iterator);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flat(depth) {</span><span class="s3">\n        </span><span class="s1">if (depth === undefined) {</span><span class="s3">\n            </span><span class="s1">depth = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (depth &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const stream = depth &gt; 1 ? this.flat(depth - 1) : this;</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ this: stream.startFn() }), (state) =&gt; {</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">if (state.iterator) {</span><span class="s3">\n                    </span><span class="s1">const next = state.iterator.next();</span><span class="s3">\n                    </span><span class="s1">if (next.done) {</span><span class="s3">\n                        </span><span class="s1">state.iterator = undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return next;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const { done, value } = stream.nextFn(state.this);</span><span class="s3">\n                </span><span class="s1">if (!done) {</span><span class="s3">\n                    </span><span class="s1">if (isIterable(value)) {</span><span class="s3">\n                        </span><span class="s1">state.iterator = value[Symbol.iterator]();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">return { done: false, value: value };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (state.iterator);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">head() {</span><span class="s3">\n        </span><span class="s1">const iterator = this.iterator();</span><span class="s3">\n        </span><span class="s1">const result = iterator.next();</span><span class="s3">\n        </span><span class="s1">if (result.done) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tail(skipCount = 1) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const state = this.startFn();</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; skipCount; i++) {</span><span class="s3">\n                </span><span class="s1">const next = this.nextFn(state);</span><span class="s3">\n                </span><span class="s1">if (next.done) {</span><span class="s3">\n                    </span><span class="s1">return state;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return state;</span><span class="s3">\n        </span><span class="s1">}, this.nextFn);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">limit(maxSize) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ size: 0, state: this.startFn() }), state =&gt; {</span><span class="s3">\n            </span><span class="s1">state.size++;</span><span class="s3">\n            </span><span class="s1">if (state.size &gt; maxSize) {</span><span class="s3">\n                </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this.nextFn(state.state);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">distinct(by) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ set: new Set(), internalState: this.startFn() }), state =&gt; {</span><span class="s3">\n            </span><span class="s1">let result;</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">result = this.nextFn(state.internalState);</span><span class="s3">\n                </span><span class="s1">if (!result.done) {</span><span class="s3">\n                    </span><span class="s1">const value = by ? by(result.value) : result.value;</span><span class="s3">\n                    </span><span class="s1">if (!state.set.has(value)) {</span><span class="s3">\n                        </span><span class="s1">state.set.add(value);</span><span class="s3">\n                        </span><span class="s1">return result;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (!result.done);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">exclude(other, key) {</span><span class="s3">\n        </span><span class="s1">const otherKeySet = new Set();</span><span class="s3">\n        </span><span class="s1">for (const item of other) {</span><span class="s3">\n            </span><span class="s1">const value = key ? key(item) : item;</span><span class="s3">\n            </span><span class="s1">otherKeySet.add(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.filter(e =&gt; {</span><span class="s3">\n            </span><span class="s1">const ownKey = key ? key(e) : e;</span><span class="s3">\n            </span><span class="s1">return !otherKeySet.has(ownKey);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function toString(item) {</span><span class="s3">\n    </span><span class="s1">if (typeof item === 'string') {</span><span class="s3">\n        </span><span class="s1">return item;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof item === 'undefined') {</span><span class="s3">\n        </span><span class="s1">return 'undefined';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span><span class="s3">\n    </span><span class="s1">if (typeof item.toString === 'function') {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span><span class="s3">\n        </span><span class="s1">return item.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Object.prototype.toString.call(item);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isIterable(obj) {</span><span class="s3">\n    </span><span class="s1">return !!obj &amp;&amp; typeof obj[Symbol.iterator] === 'function';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An empty stream of any type.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span><span class="s3">\n</span><span class="s1">export const EMPTY_STREAM = new StreamImpl(() =&gt; undefined, () =&gt; DONE_RESULT);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const DONE_RESULT = Object.freeze({ done: true, value: undefined });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a stream from one or more iterables or array-likes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stream(...collections) {</span><span class="s3">\n    </span><span class="s1">if (collections.length === 1) {</span><span class="s3">\n        </span><span class="s1">const collection = collections[0];</span><span class="s3">\n        </span><span class="s1">if (collection instanceof StreamImpl) {</span><span class="s3">\n            </span><span class="s1">return collection;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isIterable(collection)) {</span><span class="s3">\n            </span><span class="s1">return new StreamImpl(() =&gt; collection[Symbol.iterator](), (iterator) =&gt; iterator.next());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof collection.length === 'number') {</span><span class="s3">\n            </span><span class="s1">return new StreamImpl(() =&gt; ({ index: 0 }), (state) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (state.index &lt; collection.length) {</span><span class="s3">\n                    </span><span class="s1">return { done: false, value: collection[state.index++] };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (collections.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return new StreamImpl(() =&gt; ({ collIndex: 0, arrIndex: 0 }), (state) =&gt; {</span><span class="s3">\n            </span><span class="s1">do {</span><span class="s3">\n                </span><span class="s1">if (state.iterator) {</span><span class="s3">\n                    </span><span class="s1">const next = state.iterator.next();</span><span class="s3">\n                    </span><span class="s1">if (!next.done) {</span><span class="s3">\n                        </span><span class="s1">return next;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">state.iterator = undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (state.array) {</span><span class="s3">\n                    </span><span class="s1">if (state.arrIndex &lt; state.array.length) {</span><span class="s3">\n                        </span><span class="s1">return { done: false, value: state.array[state.arrIndex++] };</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">state.array = undefined;</span><span class="s3">\n                    </span><span class="s1">state.arrIndex = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (state.collIndex &lt; collections.length) {</span><span class="s3">\n                    </span><span class="s1">const collection = collections[state.collIndex++];</span><span class="s3">\n                    </span><span class="s1">if (isIterable(collection)) {</span><span class="s3">\n                        </span><span class="s1">state.iterator = collection[Symbol.iterator]();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (collection &amp;&amp; typeof collection.length === 'number') {</span><span class="s3">\n                        </span><span class="s1">state.array = collection;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} while (state.iterator || state.array || state.collIndex &lt; collections.length);</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return EMPTY_STREAM;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The default implementation of `TreeStream` takes a root element and a function that computes the</span><span class="s3">\n </span><span class="s1">* children of its argument. Whether the root node included in the stream is controlled with the</span><span class="s3">\n </span><span class="s1">* `includeRoot` option, which defaults to `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class TreeStreamImpl extends StreamImpl {</span><span class="s3">\n    </span><span class="s1">constructor(root, children, options) {</span><span class="s3">\n        </span><span class="s1">super(() =&gt; ({</span><span class="s3">\n            </span><span class="s1">iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],</span><span class="s3">\n            </span><span class="s1">pruned: false</span><span class="s3">\n        </span><span class="s1">}), state =&gt; {</span><span class="s3">\n            </span><span class="s1">if (state.pruned) {</span><span class="s3">\n                </span><span class="s1">state.iterators.pop();</span><span class="s3">\n                </span><span class="s1">state.pruned = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">while (state.iterators.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">const iterator = state.iterators[state.iterators.length - 1];</span><span class="s3">\n                </span><span class="s1">const next = iterator.next();</span><span class="s3">\n                </span><span class="s1">if (next.done) {</span><span class="s3">\n                    </span><span class="s1">state.iterators.pop();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">state.iterators.push(children(next.value)[Symbol.iterator]());</span><span class="s3">\n                    </span><span class="s1">return next;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return DONE_RESULT;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterator() {</span><span class="s3">\n        </span><span class="s1">const iterator = {</span><span class="s3">\n            </span><span class="s1">state: this.startFn(),</span><span class="s3">\n            </span><span class="s1">next: () =&gt; this.nextFn(iterator.state),</span><span class="s3">\n            </span><span class="s1">prune: () =&gt; {</span><span class="s3">\n                </span><span class="s1">iterator.state.pruned = true;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">[Symbol.iterator]: () =&gt; iterator</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return iterator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A set of utility functions that reduce a stream to a single value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var Reduction;</span><span class="s3">\n</span><span class="s1">(function (Reduction) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute the sum of a number stream.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function sum(stream) {</span><span class="s3">\n        </span><span class="s1">return stream.reduce((a, b) =&gt; a + b, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Reduction.sum = sum;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute the product of a number stream.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function product(stream) {</span><span class="s3">\n        </span><span class="s1">return stream.reduce((a, b) =&gt; a * b, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Reduction.product = product;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute the minimum of a number stream. Returns `undefined` if the stream is empty.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function min(stream) {</span><span class="s3">\n        </span><span class="s1">return stream.reduce((a, b) =&gt; Math.min(a, b));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Reduction.min = min;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute the maximum of a number stream. Returns `undefined` if the stream is empty.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function max(stream) {</span><span class="s3">\n        </span><span class="s1">return stream.reduce((a, b) =&gt; Math.max(a, b));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Reduction.max = max;</span><span class="s3">\n</span><span class="s1">})(Reduction || (Reduction = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=stream.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/******************************************************************************</span><span class="s3">\n </span><span class="s1">* Copyright 2022 TypeFox GmbH</span><span class="s3">\n </span><span class="s1">* This program and the accompanying materials are made available under the</span><span class="s3">\n </span><span class="s1">* terms of the MIT License, which is available in the project root.</span><span class="s3">\n </span><span class="s1">******************************************************************************/</span><span class="s3">\n</span><span class="s1">export class EmptyFileSystemProvider {</span><span class="s3">\n    </span><span class="s1">readFile() {</span><span class="s3">\n        </span><span class="s1">throw new Error('No file system is available.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">async readDirectory() {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">export const EmptyFileSystem = {</span><span class="s3">\n    </span><span class="s1">fileSystemProvider: () =&gt; new EmptyFileSystemProvider()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=file-system-provider.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isSymbol from './isSymbol.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of methods like `_.max` and `_.min` which accepts a</span><span class="s3">\n </span><span class="s1">* `comparator` to determine the extremum value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The iteratee invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparator The comparator used to compare values.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the extremum value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseExtremum(array, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">current = iteratee(value);</span><span class="s3">\n\n    </span><span class="s1">if (current != null &amp;&amp; (computed === undefined</span><span class="s3">\n          </span><span class="s1">? (current === current &amp;&amp; !isSymbol(current))</span><span class="s3">\n          </span><span class="s1">: comparator(current, computed)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">var computed = current,</span><span class="s3">\n          </span><span class="s1">result = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseExtremum;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.lt` which doesn't coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is less than `other`,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseLt(value, other) {</span><span class="s3">\n  </span><span class="s1">return value &lt; other;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseLt;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseEach from './_baseEach.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.map` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMap(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = isArrayLike(collection) ? Array(collection.length) : [];</span><span class="s3">\n\n  </span><span class="s1">baseEach(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">result[++index] = iteratee(value, key, collection);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseMap;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import assignValue from './_assignValue.js';</span><span class="s3">\n</span><span class="s1">import castPath from './_castPath.js';</span><span class="s3">\n</span><span class="s1">import isIndex from './_isIndex.js';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject.js';</span><span class="s3">\n</span><span class="s1">import toKey from './_toKey.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.set`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path of the property to set.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to set.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize path creation.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSet(object, path, value, customizer) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">path = castPath(path, object);</span><span class="s3">\n\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = path.length,</span><span class="s3">\n      </span><span class="s1">lastIndex = length - 1,</span><span class="s3">\n      </span><span class="s1">nested = object;</span><span class="s3">\n\n  </span><span class="s1">while (nested != null &amp;&amp; ++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var key = toKey(path[index]),</span><span class="s3">\n        </span><span class="s1">newValue = value;</span><span class="s3">\n\n    </span><span class="s1">if (key === '__proto__' || key === 'constructor' || key === 'prototype') {</span><span class="s3">\n      </span><span class="s1">return object;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (index != lastIndex) {</span><span class="s3">\n      </span><span class="s1">var objValue = nested[key];</span><span class="s3">\n      </span><span class="s1">newValue = customizer ? customizer(objValue, key, nested) : undefined;</span><span class="s3">\n      </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n        </span><span class="s1">newValue = isObject(objValue)</span><span class="s3">\n          </span><span class="s1">? objValue</span><span class="s3">\n          </span><span class="s1">: (isIndex(path[index + 1]) ? [] : {});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">assignValue(nested, key, newValue);</span><span class="s3">\n    </span><span class="s1">nested = nested[key];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseSet;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseGet from './_baseGet.js';</span><span class="s3">\n</span><span class="s1">import baseSet from './_baseSet.js';</span><span class="s3">\n</span><span class="s1">import castPath from './_castPath.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of  `_.pickBy` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The source object.</span><span class="s3">\n </span><span class="s1">* @param {string[]} paths The property paths to pick.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per property.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePickBy(object, paths, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = paths.length,</span><span class="s3">\n      </span><span class="s1">result = {};</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var path = paths[index],</span><span class="s3">\n        </span><span class="s1">value = baseGet(object, path);</span><span class="s3">\n\n    </span><span class="s1">if (predicate(value, path)) {</span><span class="s3">\n      </span><span class="s1">baseSet(result, castPath(path, object), value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default basePickBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseClone from './_baseClone.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for cloning. */</span><span class="s3">\n</span><span class="s1">var CLONE_SYMBOLS_FLAG = 4;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a shallow clone of `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on the</span><span class="s3">\n </span><span class="s1">* [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)</span><span class="s3">\n </span><span class="s1">* and supports cloning arrays, array buffers, booleans, date objects, maps,</span><span class="s3">\n </span><span class="s1">* numbers, `Object` objects, regexes, sets, strings, symbols, and typed</span><span class="s3">\n </span><span class="s1">* arrays. The own enumerable properties of `arguments` objects are cloned</span><span class="s3">\n </span><span class="s1">* as plain objects. An empty object is returned for uncloneable values such</span><span class="s3">\n </span><span class="s1">* as error objects, functions, DOM nodes, and WeakMaps.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to clone.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the cloned value.</span><span class="s3">\n </span><span class="s1">* @see _.cloneDeep</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'a': 1 }, { 'b': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var shallow = _.clone(objects);</span><span class="s3">\n </span><span class="s1">* console.log(shallow[0] === objects[0]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function clone(value) {</span><span class="s3">\n  </span><span class="s1">return baseClone(value, CLONE_SYMBOLS_FLAG);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default clone;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseRest from './_baseRest.js';</span><span class="s3">\n</span><span class="s1">import eq from './eq.js';</span><span class="s3">\n</span><span class="s1">import isIterateeCall from './_isIterateeCall.js';</span><span class="s3">\n</span><span class="s1">import keysIn from './keysIn.js';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns own and inherited enumerable string keyed properties of source</span><span class="s3">\n </span><span class="s1">* objects to the destination object for all destination properties that</span><span class="s3">\n </span><span class="s1">* resolve to `undefined`. Source objects are applied from left to right.</span><span class="s3">\n </span><span class="s1">* Once a property is set, additional values of the same property are ignored.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.defaultsDeep</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var defaults = baseRest(function(object, sources) {</span><span class="s3">\n  </span><span class="s1">object = Object(object);</span><span class="s3">\n\n  </span><span class="s1">var index = -1;</span><span class="s3">\n  </span><span class="s1">var length = sources.length;</span><span class="s3">\n  </span><span class="s1">var guard = length &gt; 2 ? sources[2] : undefined;</span><span class="s3">\n\n  </span><span class="s1">if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {</span><span class="s3">\n    </span><span class="s1">length = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var source = sources[index];</span><span class="s3">\n    </span><span class="s1">var props = keysIn(source);</span><span class="s3">\n    </span><span class="s1">var propsIndex = -1;</span><span class="s3">\n    </span><span class="s1">var propsLength = props.length;</span><span class="s3">\n\n    </span><span class="s1">while (++propsIndex &lt; propsLength) {</span><span class="s3">\n      </span><span class="s1">var key = props[propsIndex];</span><span class="s3">\n      </span><span class="s1">var value = object[key];</span><span class="s3">\n\n      </span><span class="s1">if (value === undefined ||</span><span class="s3">\n          </span><span class="s1">(eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) {</span><span class="s3">\n        </span><span class="s1">object[key] = source[key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export default defaults;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import isArrayLike from './isArrayLike.js';</span><span class="s3">\n</span><span class="s1">import keys from './keys.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a `_.find` or `_.findLast` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} findIndexFunc The function to find the collection index.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new find function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createFind(findIndexFunc) {</span><span class="s3">\n  </span><span class="s1">return function(collection, predicate, fromIndex) {</span><span class="s3">\n    </span><span class="s1">var iterable = Object(collection);</span><span class="s3">\n    </span><span class="s1">if (!isArrayLike(collection)) {</span><span class="s3">\n      </span><span class="s1">var iteratee = baseIteratee(predicate, 3);</span><span class="s3">\n      </span><span class="s1">collection = keys(collection);</span><span class="s3">\n      </span><span class="s1">predicate = function(key) { return iteratee(iterable[key], key, iterable); };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var index = findIndexFunc(collection, predicate, fromIndex);</span><span class="s3">\n    </span><span class="s1">return index &gt; -1 ? iterable[iteratee ? collection[index] : index] : undefined;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default createFind;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFindIndex from './_baseFindIndex.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import toInteger from './toInteger.js';</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMax = Math.max;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.find` except that it returns the index of the first</span><span class="s3">\n </span><span class="s1">* element `predicate` returns truthy for instead of the element itself.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 1.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the found element, else `-1`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney',  'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',    'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'pebbles', 'active': true }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, function(o) { return o.user == 'barney'; });</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, { 'user': 'fred', 'active': false });</span><span class="s3">\n </span><span class="s1">* // =&gt; 1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.findIndex(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; 2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findIndex(array, predicate, fromIndex) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = fromIndex == null ? 0 : toInteger(fromIndex);</span><span class="s3">\n  </span><span class="s1">if (index &lt; 0) {</span><span class="s3">\n    </span><span class="s1">index = nativeMax(length + index, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseFindIndex(array, baseIteratee(predicate, 3), index);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default findIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import createFind from './_createFind.js';</span><span class="s3">\n</span><span class="s1">import findIndex from './findIndex.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates over elements of `collection`, returning the first element</span><span class="s3">\n </span><span class="s1">* `predicate` returns truthy for. The predicate is invoked with three</span><span class="s3">\n </span><span class="s1">* arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [predicate=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {number} [fromIndex=0] The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the matched element, else `undefined`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney',  'age': 36, 'active': true },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',    'age': 40, 'active': false },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'pebbles', 'age': 1,  'active': true }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.find(users, function(o) { return o.age &lt; 40; });</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'barney'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matches` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, { 'age': 1, 'active': true });</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'pebbles'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.matchesProperty` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, ['active', false]);</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'fred'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.find(users, 'active');</span><span class="s3">\n </span><span class="s1">* // =&gt; object for 'barney'</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var find = createFind(findIndex);</span><span class="s3">\n\n</span><span class="s1">export default find;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n</span><span class="s1">import map from './map.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a flattened array of values by running each element in `collection`</span><span class="s3">\n </span><span class="s1">* thru `iteratee` and flattening the mapped results. The iteratee is invoked</span><span class="s3">\n </span><span class="s1">* with three arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new flattened array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function duplicate(n) {</span><span class="s3">\n </span><span class="s1">*   return [n, n];</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.flatMap([1, 2], duplicate);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 1, 2, 2]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function flatMap(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">return baseFlatten(map(collection, iteratee), 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default flatMap;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseFlatten from './_baseFlatten.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Flattens `array` a single level deep.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to flatten.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new flattened array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.flatten([1, [2, [3, [4]], 5]]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, [3, [4]], 5]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function flatten(array) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return length ? baseFlatten(array, 1) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default flatten;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.has` without support for deep paths.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} [object] The object to query.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} key The key to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseHas(object, key) {</span><span class="s3">\n  </span><span class="s1">return object != null &amp;&amp; hasOwnProperty.call(object, key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseHas from './_baseHas.js';</span><span class="s3">\n</span><span class="s1">import hasPath from './_hasPath.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `path` is a direct property of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `path` exists, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': { 'b': 2 } };</span><span class="s3">\n </span><span class="s1">* var other = _.create({ 'a': _.create({ 'b': 2 }) });</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, 'a.b');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(object, ['a', 'b']);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.has(other, 'a');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function has(object, path) {</span><span class="s3">\n  </span><span class="s1">return object != null &amp;&amp; hasPath(object, path, baseHas);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default has;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseGetTag from './_baseGetTag.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n</span><span class="s1">import isObjectLike from './isObjectLike.js';</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var stringTag = '[object String]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `String` primitive or object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a string, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString(1);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isString(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'string' ||</span><span class="s3">\n    </span><span class="s1">(!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default isString;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Gets the last element of `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to query.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the last element of `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.last([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function last(array) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return length ? array[length - 1] : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default last;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import arrayMap from './_arrayMap.js';</span><span class="s3">\n</span><span class="s1">import baseIteratee from './_baseIteratee.js';</span><span class="s3">\n</span><span class="s1">import baseMap from './_baseMap.js';</span><span class="s3">\n</span><span class="s1">import isArray from './isArray.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of values by running each element in `collection` thru</span><span class="s3">\n </span><span class="s1">* `iteratee`. The iteratee is invoked with three arguments:</span><span class="s3">\n </span><span class="s1">* (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Many lodash methods are guarded to work as iteratees for methods like</span><span class="s3">\n </span><span class="s1">* `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The guarded methods are:</span><span class="s3">\n </span><span class="s1">* `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,</span><span class="s3">\n </span><span class="s1">* `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,</span><span class="s3">\n </span><span class="s1">* `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,</span><span class="s3">\n </span><span class="s1">* `template`, `trim`, `trimEnd`, `trimStart`, and `words`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function square(n) {</span><span class="s3">\n </span><span class="s1">*   return n * n;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map([4, 8], square);</span><span class="s3">\n </span><span class="s1">* // =&gt; [16, 64]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map({ 'a': 4, 'b': 8 }, square);</span><span class="s3">\n </span><span class="s1">* // =&gt; [16, 64] (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney' },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred' }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* // The `_.property` iteratee shorthand.</span><span class="s3">\n </span><span class="s1">* _.map(users, 'user');</span><span class="s3">\n </span><span class="s1">* // =&gt; ['barney', 'fred']</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function map(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayMap : baseMap;</span><span class="s3">\n  </span><span class="s1">return func(collection, baseIteratee(iteratee, 3));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default map;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseExtremum from './_baseExtremum.js';</span><span class="s3">\n</span><span class="s1">import baseLt from './_baseLt.js';</span><span class="s3">\n</span><span class="s1">import identity from './identity.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Computes the minimum value of `array`. If `array` is empty or falsey,</span><span class="s3">\n </span><span class="s1">* `undefined` is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Math</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the minimum value.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.min([4, 2, 8, 6]);</span><span class="s3">\n </span><span class="s1">* // =&gt; 2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.min([]);</span><span class="s3">\n </span><span class="s1">* // =&gt; undefined</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function min(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length)</span><span class="s3">\n    </span><span class="s1">? baseExtremum(array, identity, baseLt)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default min;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to match a single whitespace character. */</span><span class="s3">\n</span><span class="s1">var reWhitespace = /</span><span class="s3">\\</span><span class="s1">s/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace</span><span class="s3">\n </span><span class="s1">* character of `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the last non-whitespace character.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function trimmedEndIndex(string) {</span><span class="s3">\n  </span><span class="s1">var index = string.length;</span><span class="s3">\n\n  </span><span class="s1">while (index-- &amp;&amp; reWhitespace.test(string.charAt(index))) {}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default trimmedEndIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import trimmedEndIndex from './_trimmedEndIndex.js';</span><span class="s3">\n\n</span><span class="s1">/** Used to match leading whitespace. */</span><span class="s3">\n</span><span class="s1">var reTrimStart = /^</span><span class="s3">\\</span><span class="s1">s+/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.trim`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to trim.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the trimmed string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseTrim(string) {</span><span class="s3">\n  </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')</span><span class="s3">\n    </span><span class="s1">: string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default baseTrim;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import baseTrim from './_baseTrim.js';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject.js';</span><span class="s3">\n</span><span class="s1">import isSymbol from './isSymbol.js';</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var NAN = 0 / 0;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect bad signed hexadecimal string values. */</span><span class="s3">\n</span><span class="s1">var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect binary string values. */</span><span class="s3">\n</span><span class="s1">var reIsBinary = /^0b[01]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect octal string values. */</span><span class="s3">\n</span><span class="s1">var reIsOctal = /^0o[0-7]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Built-in method references without a dependency on `root`. */</span><span class="s3">\n</span><span class="s1">var freeParseInt = parseInt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to process.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; Infinity</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toNumber(value) {</span><span class="s3">\n  </span><span class="s1">if (typeof value == 'number') {</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isSymbol(value)) {</span><span class="s3">\n    </span><span class="s1">return NAN;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isObject(value)) {</span><span class="s3">\n    </span><span class="s1">var other = typeof value.valueOf == 'function' ? value.valueOf() : value;</span><span class="s3">\n    </span><span class="s1">value = isObject(other) ? (other + '') : other;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof value != 'string') {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : +value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = baseTrim(value);</span><span class="s3">\n  </span><span class="s1">var isBinary = reIsBinary.test(value);</span><span class="s3">\n  </span><span class="s1">return (isBinary || reIsOctal.test(value))</span><span class="s3">\n    </span><span class="s1">? freeParseInt(value.slice(2), isBinary ? 2 : 8)</span><span class="s3">\n    </span><span class="s1">: (reIsBadHex.test(value) ? NAN : +value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toNumber;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import toNumber from './toNumber.js';</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var INFINITY = 1 / 0,</span><span class="s3">\n    </span><span class="s1">MAX_INTEGER = 1.7976931348623157e+308;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a finite number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.12.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toFinite(value) {</span><span class="s3">\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = toNumber(value);</span><span class="s3">\n  </span><span class="s1">if (value === INFINITY || value === -INFINITY) {</span><span class="s3">\n    </span><span class="s1">var sign = (value &lt; 0 ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">return sign * MAX_INTEGER;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value === value ? value : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toFinite;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import toFinite from './toFinite.js';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to an integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on</span><span class="s3">\n </span><span class="s1">* [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted integer.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toInteger(value) {</span><span class="s3">\n  </span><span class="s1">var result = toFinite(value),</span><span class="s3">\n      </span><span class="s1">remainder = result % 1;</span><span class="s3">\n\n  </span><span class="s1">return result === result ? (remainder ? result - remainder : result) : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export default toInteger;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// shim for using process in browser</span><span class="s3">\n</span><span class="s1">var process = module.exports = {};</span><span class="s3">\n\n</span><span class="s1">// cached from whatever global is present so that test runners that stub it</span><span class="s3">\n</span><span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span><span class="s3">\n</span><span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span><span class="s3">\n</span><span class="s1">// function because try/catches deoptimize in certain engines.</span><span class="s3">\n\n</span><span class="s1">var cachedSetTimeout;</span><span class="s3">\n</span><span class="s1">var cachedClearTimeout;</span><span class="s3">\n\n</span><span class="s1">function defaultSetTimout() {</span><span class="s3">\n    </span><span class="s1">throw new Error('setTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultClearTimeout () {</span><span class="s3">\n    </span><span class="s1">throw new Error('clearTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof setTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof clearTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} ())</span><span class="s3">\n</span><span class="s1">function runTimeout(fun) {</span><span class="s3">\n    </span><span class="s1">if (cachedSetTimeout === setTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if setTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedSetTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">} catch(e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(null, fun, 0);</span><span class="s3">\n        </span><span class="s1">} catch(e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(this, fun, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function runClearTimeout(marker) {</span><span class="s3">\n    </span><span class="s1">if (cachedClearTimeout === clearTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if clearTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedClearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">} catch (e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(null, marker);</span><span class="s3">\n        </span><span class="s1">} catch (e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span><span class="s3">\n            </span><span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(this, marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var queue = [];</span><span class="s3">\n</span><span class="s1">var draining = false;</span><span class="s3">\n</span><span class="s1">var currentQueue;</span><span class="s3">\n</span><span class="s1">var queueIndex = -1;</span><span class="s3">\n\n</span><span class="s1">function cleanUpNextTick() {</span><span class="s3">\n    </span><span class="s1">if (!draining || !currentQueue) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">if (currentQueue.length) {</span><span class="s3">\n        </span><span class="s1">queue = currentQueue.concat(queue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (queue.length) {</span><span class="s3">\n        </span><span class="s1">drainQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function drainQueue() {</span><span class="s3">\n    </span><span class="s1">if (draining) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeout = runTimeout(cleanUpNextTick);</span><span class="s3">\n    </span><span class="s1">draining = true;</span><span class="s3">\n\n    </span><span class="s1">var len = queue.length;</span><span class="s3">\n    </span><span class="s1">while(len) {</span><span class="s3">\n        </span><span class="s1">currentQueue = queue;</span><span class="s3">\n        </span><span class="s1">queue = [];</span><span class="s3">\n        </span><span class="s1">while (++queueIndex &lt; len) {</span><span class="s3">\n            </span><span class="s1">if (currentQueue) {</span><span class="s3">\n                </span><span class="s1">currentQueue[queueIndex].run();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n        </span><span class="s1">len = queue.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentQueue = null;</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">runClearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">process.nextTick = function (fun) {</span><span class="s3">\n    </span><span class="s1">var args = new Array(arguments.length - 1);</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span><span class="s3">\n            </span><span class="s1">args[i - 1] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">queue.push(new Item(fun, args));</span><span class="s3">\n    </span><span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span><span class="s3">\n        </span><span class="s1">runTimeout(drainQueue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// v8 likes predictible objects</span><span class="s3">\n</span><span class="s1">function Item(fun, array) {</span><span class="s3">\n    </span><span class="s1">this.fun = fun;</span><span class="s3">\n    </span><span class="s1">this.array = array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Item.prototype.run = function () {</span><span class="s3">\n    </span><span class="s1">this.fun.apply(null, this.array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.title = 'browser';</span><span class="s3">\n</span><span class="s1">process.browser = true;</span><span class="s3">\n</span><span class="s1">process.env = {};</span><span class="s3">\n</span><span class="s1">process.argv = [];</span><span class="s3">\n</span><span class="s1">process.version = ''; // empty string to avoid regexp issues</span><span class="s3">\n</span><span class="s1">process.versions = {};</span><span class="s3">\n\n</span><span class="s1">function noop() {}</span><span class="s3">\n\n</span><span class="s1">process.on = noop;</span><span class="s3">\n</span><span class="s1">process.addListener = noop;</span><span class="s3">\n</span><span class="s1">process.once = noop;</span><span class="s3">\n</span><span class="s1">process.off = noop;</span><span class="s3">\n</span><span class="s1">process.removeListener = noop;</span><span class="s3">\n</span><span class="s1">process.removeAllListeners = noop;</span><span class="s3">\n</span><span class="s1">process.emit = noop;</span><span class="s3">\n</span><span class="s1">process.prependListener = noop;</span><span class="s3">\n</span><span class="s1">process.prependOnceListener = noop;</span><span class="s3">\n\n</span><span class="s1">process.listeners = function (name) { return [] }</span><span class="s3">\n\n</span><span class="s1">process.binding = function (name) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.binding is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">process.cwd = function () { return '/' };</span><span class="s3">\n</span><span class="s1">process.chdir = function (dir) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.chdir is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.umask = function() { return 0; };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/*---------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">*  Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">*  Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">*--------------------------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.CancellationTokenSource = exports.CancellationToken = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const Is = require(</span><span class="s3">\&quot;</span><span class="s1">./is</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">const events_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./events</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var CancellationToken;</span><span class="s3">\n</span><span class="s1">(function (CancellationToken) {</span><span class="s3">\n    </span><span class="s1">CancellationToken.None = Object.freeze({</span><span class="s3">\n        </span><span class="s1">isCancellationRequested: false,</span><span class="s3">\n        </span><span class="s1">onCancellationRequested: events_1.Event.None</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">CancellationToken.Cancelled = Object.freeze({</span><span class="s3">\n        </span><span class="s1">isCancellationRequested: true,</span><span class="s3">\n        </span><span class="s1">onCancellationRequested: events_1.Event.None</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">function is(value) {</span><span class="s3">\n        </span><span class="s1">const candidate = value;</span><span class="s3">\n        </span><span class="s1">return candidate &amp;&amp; (candidate === CancellationToken.None</span><span class="s3">\n            </span><span class="s1">|| candidate === CancellationToken.Cancelled</span><span class="s3">\n            </span><span class="s1">|| (Is.boolean(candidate.isCancellationRequested) &amp;&amp; !!candidate.onCancellationRequested));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CancellationToken.is = is;</span><span class="s3">\n</span><span class="s1">})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));</span><span class="s3">\n</span><span class="s1">const shortcutEvent = Object.freeze(function (callback, context) {</span><span class="s3">\n    </span><span class="s1">const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);</span><span class="s3">\n    </span><span class="s1">return { dispose() { handle.dispose(); } };</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class MutableToken {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this._isCancelled = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (!this._isCancelled) {</span><span class="s3">\n            </span><span class="s1">this._isCancelled = true;</span><span class="s3">\n            </span><span class="s1">if (this._emitter) {</span><span class="s3">\n                </span><span class="s1">this._emitter.fire(undefined);</span><span class="s3">\n                </span><span class="s1">this.dispose();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">return this._isCancelled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get onCancellationRequested() {</span><span class="s3">\n        </span><span class="s1">if (this._isCancelled) {</span><span class="s3">\n            </span><span class="s1">return shortcutEvent;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this._emitter) {</span><span class="s3">\n            </span><span class="s1">this._emitter = new events_1.Emitter();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._emitter.event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._emitter) {</span><span class="s3">\n            </span><span class="s1">this._emitter.dispose();</span><span class="s3">\n            </span><span class="s1">this._emitter = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CancellationTokenSource {</span><span class="s3">\n    </span><span class="s1">get token() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// be lazy and create the token only when</span><span class="s3">\n            </span><span class="s1">// actually needed</span><span class="s3">\n            </span><span class="s1">this._token = new MutableToken();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._token;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// save an object by returning the default</span><span class="s3">\n            </span><span class="s1">// cancelled token when cancellation happens</span><span class="s3">\n            </span><span class="s1">// before someone asks for the token</span><span class="s3">\n            </span><span class="s1">this._token = CancellationToken.Cancelled;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._token.cancel();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (!this._token) {</span><span class="s3">\n            </span><span class="s1">// ensure to initialize with an empty token if we had none</span><span class="s3">\n            </span><span class="s1">this._token = CancellationToken.None;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this._token instanceof MutableToken) {</span><span class="s3">\n            </span><span class="s1">// actually dispose</span><span class="s3">\n            </span><span class="s1">this._token.dispose();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.CancellationTokenSource = CancellationTokenSource;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.Emitter = exports.Event = void 0;</span><span class="s3">\n</span><span class="s1">const ral_1 = require(</span><span class="s3">\&quot;</span><span class="s1">./ral</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var Event;</span><span class="s3">\n</span><span class="s1">(function (Event) {</span><span class="s3">\n    </span><span class="s1">const _disposable = { dispose() { } };</span><span class="s3">\n    </span><span class="s1">Event.None = function () { return _disposable; };</span><span class="s3">\n</span><span class="s1">})(Event || (exports.Event = Event = {}));</span><span class="s3">\n</span><span class="s1">class CallbackList {</span><span class="s3">\n    </span><span class="s1">add(callback, context = null, bucket) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks = [];</span><span class="s3">\n            </span><span class="s1">this._contexts = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._callbacks.push(callback);</span><span class="s3">\n        </span><span class="s1">this._contexts.push(context);</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(bucket)) {</span><span class="s3">\n            </span><span class="s1">bucket.push({ dispose: () =&gt; this.remove(callback, context) });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">remove(callback, context = null) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let foundCallbackWithDifferentContext = false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0, len = this._callbacks.length; i &lt; len; i++) {</span><span class="s3">\n            </span><span class="s1">if (this._callbacks[i] === callback) {</span><span class="s3">\n                </span><span class="s1">if (this._contexts[i] === context) {</span><span class="s3">\n                    </span><span class="s1">// callback &amp; context match =&gt; remove it</span><span class="s3">\n                    </span><span class="s1">this._callbacks.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">this._contexts.splice(i, 1);</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">foundCallbackWithDifferentContext = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (foundCallbackWithDifferentContext) {</span><span class="s3">\n            </span><span class="s1">throw new Error('When adding a listener with a context, you should remove it with the same context');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">invoke(...args) {</span><span class="s3">\n        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);</span><span class="s3">\n        </span><span class="s1">for (let i = 0, len = callbacks.length; i &lt; len; i++) {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">ret.push(callbacks[i].apply(contexts[i], args));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">// eslint-disable-next-line no-console</span><span class="s3">\n                </span><span class="s1">(0, ral_1.default)().console.error(e);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ret;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isEmpty() {</span><span class="s3">\n        </span><span class="s1">return !this._callbacks || this._callbacks.length === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this._callbacks = undefined;</span><span class="s3">\n        </span><span class="s1">this._contexts = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Emitter {</span><span class="s3">\n    </span><span class="s1">constructor(_options) {</span><span class="s3">\n        </span><span class="s1">this._options = _options;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* For the public to allow to subscribe</span><span class="s3">\n     </span><span class="s1">* to events from this Emitter</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get event() {</span><span class="s3">\n        </span><span class="s1">if (!this._event) {</span><span class="s3">\n            </span><span class="s1">this._event = (listener, thisArgs, disposables) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n                    </span><span class="s1">this._callbacks = new CallbackList();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this._options &amp;&amp; this._options.onFirstListenerAdd &amp;&amp; this._callbacks.isEmpty()) {</span><span class="s3">\n                    </span><span class="s1">this._options.onFirstListenerAdd(this);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this._callbacks.add(listener, thisArgs);</span><span class="s3">\n                </span><span class="s1">const result = {</span><span class="s3">\n                    </span><span class="s1">dispose: () =&gt; {</span><span class="s3">\n                        </span><span class="s1">if (!this._callbacks) {</span><span class="s3">\n                            </span><span class="s1">// disposable is disposed after emitter is disposed.</span><span class="s3">\n                            </span><span class="s1">return;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">this._callbacks.remove(listener, thisArgs);</span><span class="s3">\n                        </span><span class="s1">result.dispose = Emitter._noop;</span><span class="s3">\n                        </span><span class="s1">if (this._options &amp;&amp; this._options.onLastListenerRemove &amp;&amp; this._callbacks.isEmpty()) {</span><span class="s3">\n                            </span><span class="s1">this._options.onLastListenerRemove(this);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">if (Array.isArray(disposables)) {</span><span class="s3">\n                    </span><span class="s1">disposables.push(result);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return result;</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._event;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* To be kept private to fire an event to</span><span class="s3">\n     </span><span class="s1">* subscribers</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">fire(event) {</span><span class="s3">\n        </span><span class="s1">if (this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks.invoke.call(this._callbacks, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._callbacks) {</span><span class="s3">\n            </span><span class="s1">this._callbacks.dispose();</span><span class="s3">\n            </span><span class="s1">this._callbacks = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.Emitter = Emitter;</span><span class="s3">\n</span><span class="s1">Emitter._noop = function () { };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;</span><span class="s3">\n</span><span class="s1">function boolean(value) {</span><span class="s3">\n    </span><span class="s1">return value === true || value === false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.boolean = boolean;</span><span class="s3">\n</span><span class="s1">function string(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'string' || value instanceof String;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.string = string;</span><span class="s3">\n</span><span class="s1">function number(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'number' || value instanceof Number;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.number = number;</span><span class="s3">\n</span><span class="s1">function error(value) {</span><span class="s3">\n    </span><span class="s1">return value instanceof Error;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.error = error;</span><span class="s3">\n</span><span class="s1">function func(value) {</span><span class="s3">\n    </span><span class="s1">return typeof value === 'function';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.func = func;</span><span class="s3">\n</span><span class="s1">function array(value) {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.array = array;</span><span class="s3">\n</span><span class="s1">function stringArray(value) {</span><span class="s3">\n    </span><span class="s1">return array(value) &amp;&amp; value.every(elem =&gt; string(elem));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">exports.stringArray = stringArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/* --------------------------------------------------------------------------------------------</span><span class="s3">\n </span><span class="s1">* Copyright (c) Microsoft Corporation. All rights reserved.</span><span class="s3">\n </span><span class="s1">* Licensed under the MIT License. See License.txt in the project root for license information.</span><span class="s3">\n </span><span class="s1">* ------------------------------------------------------------------------------------------ */</span><span class="s3">\n</span><span class="s1">Object.defineProperty(exports, </span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">, { value: true });</span><span class="s3">\n</span><span class="s1">let _ral;</span><span class="s3">\n</span><span class="s1">function RAL() {</span><span class="s3">\n    </span><span class="s1">if (_ral === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error(`No runtime abstraction layer installed`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return _ral;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function (RAL) {</span><span class="s3">\n    </span><span class="s1">function install(ral) {</span><span class="s3">\n        </span><span class="s1">if (ral === undefined) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`No runtime abstraction layer provided`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">_ral = ral;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">RAL.install = install;</span><span class="s3">\n</span><span class="s1">})(RAL || (RAL = {}));</span><span class="s3">\n</span><span class="s1">exports.default = RAL;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var LIB;(()=&gt;{</span><span class="s3">\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;var t={470:t=&gt;{function e(t){if(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">!=typeof t)throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Path must be a string. Received </span><span class="s3">\&quot;</span><span class="s1">+JSON.stringify(t))}function r(t,e){for(var r,n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,i=0,o=-1,s=0,h=0;h&lt;=t.length;++h){if(h&lt;t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&amp;&amp;2===s){if(n.length&lt;2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length&gt;2){var a=n.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">);if(a!==n.length-1){-1===a?(n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">),o=h,s=0;continue}}else if(2===n.length||1===n.length){n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,i=0,o=h,s=0;continue}e&amp;&amp;(n.length&gt;0?n+=</span><span class="s3">\&quot;</span><span class="s1">/..</span><span class="s3">\&quot;</span><span class="s1">:n=</span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">,i=2)}else n.length&gt;0?n+=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&amp;&amp;-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,i=!1,o=arguments.length-1;o&gt;=-1&amp;&amp;!i;o--){var s;o&gt;=0?s=arguments[o]:(void 0===t&amp;&amp;(t=process.cwd()),s=t),e(s),0!==s.length&amp;&amp;(n=s+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length&gt;0?</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+n:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:n.length&gt;0?n:</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">},normalize:function(t){if(e(t),0===t.length)return</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t=</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">),t.length&gt;0&amp;&amp;i&amp;&amp;(t+=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">),n?</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+t:t},isAbsolute:function(t){return e(t),t.length&gt;0&amp;&amp;47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;for(var t,r=0;r&lt;arguments.length;++r){var i=arguments[r];e(i),i.length&gt;0&amp;&amp;(void 0===t?t=i:t+=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+i)}return void 0===t?</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return</span><span class="s3">\&quot;\&quot;</span><span class="s1">;if((t=n.resolve(t))===(r=n.resolve(r)))return</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(var i=1;i&lt;t.length&amp;&amp;47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h&lt;r.length&amp;&amp;47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s&lt;a?s:a,f=-1,u=0;u&lt;=c;++u){if(u===c){if(a&gt;c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s&gt;c&amp;&amp;(47===t.charCodeAt(i+u)?f=u:0===u&amp;&amp;(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&amp;&amp;(f=u)}var g=</span><span class="s3">\&quot;\&quot;</span><span class="s1">;for(u=i+f+1;u&lt;=o;++u)u!==o&amp;&amp;47!==t.charCodeAt(u)||(0===g.length?g+=</span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">:g+=</span><span class="s3">\&quot;</span><span class="s1">/..</span><span class="s3">\&quot;</span><span class="s1">);return g.length&gt;0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&amp;&amp;++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s&gt;=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">:n&amp;&amp;1===i?</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">:t.slice(0,i)},basename:function(t,r){if(void 0!==r&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">!=typeof r)throw new TypeError('</span><span class="s3">\&quot;</span><span class="s1">ext</span><span class="s3">\&quot; </span><span class="s1">argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&amp;&amp;r.length&gt;0&amp;&amp;r.length&lt;=t.length){if(r.length===t.length&amp;&amp;r===t)return</span><span class="s3">\&quot;\&quot;</span><span class="s1">;var h=r.length-1,a=-1;for(n=t.length-1;n&gt;=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&amp;&amp;(s=!1,a=n+1),h&gt;=0&amp;&amp;(c===r.charCodeAt(h)?-1==--h&amp;&amp;(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&amp;&amp;(o=t.length),t.slice(i,o)}for(n=t.length-1;n&gt;=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&amp;&amp;(s=!1,o=n+1);return-1===o?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h&gt;=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&amp;&amp;(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&amp;&amp;(s=1):-1!==r&amp;&amp;(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&amp;&amp;r===i-1&amp;&amp;r===n+1?</span><span class="s3">\&quot;\&quot;</span><span class="s1">:t.slice(r,i)},format:function(t){if(null===t||</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">!=typeof t)throw new TypeError('The </span><span class="s3">\&quot;</span><span class="s1">pathObject</span><span class="s3">\&quot; </span><span class="s1">argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||</span><span class="s3">\&quot;\&quot;</span><span class="s1">)+(e.ext||</span><span class="s3">\&quot;\&quot;</span><span class="s1">);return r?r===e.root?r+n:r+</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">+n:n}(0,t)},parse:function(t){e(t);var r={root:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,dir:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,base:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,ext:</span><span class="s3">\&quot;\&quot;</span><span class="s1">,name:</span><span class="s3">\&quot;\&quot;</span><span class="s1">};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f&gt;=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&amp;&amp;(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&amp;&amp;(u=1):-1!==s&amp;&amp;(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&amp;&amp;s===a-1&amp;&amp;s===h+1?-1!==a&amp;&amp;(r.base=r.name=0===h&amp;&amp;o?t.slice(1,a):t.slice(h,a)):(0===h&amp;&amp;o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h&gt;0?r.dir=t.slice(0,h-1):o&amp;&amp;(r.dir=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">),r},sep:</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,delimiter:</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=&gt;{for(var n in e)r.o(e,n)&amp;&amp;!r.o(t,n)&amp;&amp;Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=&gt;Object.prototype.hasOwnProperty.call(t,e),r.r=t=&gt;{</span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">!=typeof Symbol&amp;&amp;Symbol.toStringTag&amp;&amp;Object.defineProperty(t,Symbol.toStringTag,{value:</span><span class="s3">\&quot;</span><span class="s1">Module</span><span class="s3">\&quot;</span><span class="s1">}),Object.defineProperty(t,</span><span class="s3">\&quot;</span><span class="s1">__esModule</span><span class="s3">\&quot;</span><span class="s1">,{value:!0})};var n={};(()=&gt;{let t;if(r.r(n),r.d(n,{URI:()=&gt;f,Utils:()=&gt;P}),</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof process)t=</span><span class="s3">\&quot;</span><span class="s1">win32</span><span class="s3">\&quot;</span><span class="s1">===process.platform;else if(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof navigator){let e=navigator.userAgent;t=e.indexOf(</span><span class="s3">\&quot;</span><span class="s1">Windows</span><span class="s3">\&quot;</span><span class="s1">)&gt;=0}const e=/^</span><span class="s3">\\</span><span class="s1">w[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">d+.-]*$/,i=/^</span><span class="s3">\\</span><span class="s1">//,o=/^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//;function s(t,r){if(!t.scheme&amp;&amp;r)throw new Error(`[UriError]: Scheme is missing: {scheme: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, authority: </span><span class="s3">\&quot;</span><span class="s1">${t.authority}</span><span class="s3">\&quot;</span><span class="s1">, path: </span><span class="s3">\&quot;</span><span class="s1">${t.path}</span><span class="s3">\&quot;</span><span class="s1">, query: </span><span class="s3">\&quot;</span><span class="s1">${t.query}</span><span class="s3">\&quot;</span><span class="s1">, fragment: </span><span class="s3">\&quot;</span><span class="s1">${t.fragment}</span><span class="s3">\&quot;</span><span class="s1">}`);if(t.scheme&amp;&amp;!e.test(t.scheme))throw new Error(</span><span class="s3">\&quot;</span><span class="s1">[UriError]: Scheme contains illegal characters.</span><span class="s3">\&quot;</span><span class="s1">);if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (</span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">)')}const h=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,a=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">,c=/^(([^:/?#]+?):)?(</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/([^/?#]*))?([^?#]*)(</span><span class="s3">\\</span><span class="s1">?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.authority&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.fragment&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.path&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.query&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.scheme&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">==typeof t.fsPath&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof t.with&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:</span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case</span><span class="s3">\&quot;</span><span class="s1">https</span><span class="s3">\&quot;</span><span class="s1">:case</span><span class="s3">\&quot;</span><span class="s1">http</span><span class="s3">\&quot;</span><span class="s1">:case</span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">:e?e[0]!==a&amp;&amp;(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&amp;&amp;(e=h),void 0===r?r=this.authority:null===r&amp;&amp;(r=h),void 0===n?n=this.path:null===n&amp;&amp;(n=h),void 0===i?i=this.query:null===i&amp;&amp;(i=h),void 0===o?o=this.fragment:null===o&amp;&amp;(o=h),e===this.scheme&amp;&amp;r===this.authority&amp;&amp;n===this.path&amp;&amp;i===this.query&amp;&amp;o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&amp;&amp;(e=e.replace(/</span><span class="s3">\\\\</span><span class="s1">/g,a)),e[0]===a&amp;&amp;e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l(</span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">,r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&amp;&amp;(t.fsPath=this._fsPath,t._sep=u),this._formatted&amp;&amp;(t.external=this._formatted),this.path&amp;&amp;(t.path=this.path),this.scheme&amp;&amp;(t.scheme=this.scheme),this.authority&amp;&amp;(t.authority=this.authority),this.query&amp;&amp;(t.query=this.query),this.fragment&amp;&amp;(t.fragment=this.fragment),t}}const g={58:</span><span class="s3">\&quot;</span><span class="s1">%3A</span><span class="s3">\&quot;</span><span class="s1">,47:</span><span class="s3">\&quot;</span><span class="s1">%2F</span><span class="s3">\&quot;</span><span class="s1">,63:</span><span class="s3">\&quot;</span><span class="s1">%3F</span><span class="s3">\&quot;</span><span class="s1">,35:</span><span class="s3">\&quot;</span><span class="s1">%23</span><span class="s3">\&quot;</span><span class="s1">,91:</span><span class="s3">\&quot;</span><span class="s1">%5B</span><span class="s3">\&quot;</span><span class="s1">,93:</span><span class="s3">\&quot;</span><span class="s1">%5D</span><span class="s3">\&quot;</span><span class="s1">,64:</span><span class="s3">\&quot;</span><span class="s1">%40</span><span class="s3">\&quot;</span><span class="s1">,33:</span><span class="s3">\&quot;</span><span class="s1">%21</span><span class="s3">\&quot;</span><span class="s1">,36:</span><span class="s3">\&quot;</span><span class="s1">%24</span><span class="s3">\&quot;</span><span class="s1">,38:</span><span class="s3">\&quot;</span><span class="s1">%26</span><span class="s3">\&quot;</span><span class="s1">,39:</span><span class="s3">\&quot;</span><span class="s1">%27</span><span class="s3">\&quot;</span><span class="s1">,40:</span><span class="s3">\&quot;</span><span class="s1">%28</span><span class="s3">\&quot;</span><span class="s1">,41:</span><span class="s3">\&quot;</span><span class="s1">%29</span><span class="s3">\&quot;</span><span class="s1">,42:</span><span class="s3">\&quot;</span><span class="s1">%2A</span><span class="s3">\&quot;</span><span class="s1">,43:</span><span class="s3">\&quot;</span><span class="s1">%2B</span><span class="s3">\&quot;</span><span class="s1">,44:</span><span class="s3">\&quot;</span><span class="s1">%2C</span><span class="s3">\&quot;</span><span class="s1">,59:</span><span class="s3">\&quot;</span><span class="s1">%3B</span><span class="s3">\&quot;</span><span class="s1">,61:</span><span class="s3">\&quot;</span><span class="s1">%3D</span><span class="s3">\&quot;</span><span class="s1">,32:</span><span class="s3">\&quot;</span><span class="s1">%20</span><span class="s3">\&quot;</span><span class="s1">};function d(t,e,r){let n,i=-1;for(let o=0;o&lt;t.length;o++){const s=t.charCodeAt(o);if(s&gt;=97&amp;&amp;s&lt;=122||s&gt;=65&amp;&amp;s&lt;=90||s&gt;=48&amp;&amp;s&lt;=57||45===s||46===s||95===s||126===s||e&amp;&amp;47===s||r&amp;&amp;91===s||r&amp;&amp;93===s||r&amp;&amp;58===s)-1!==i&amp;&amp;(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&amp;&amp;(n+=t.charAt(o));else{void 0===n&amp;&amp;(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&amp;&amp;(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&amp;&amp;(i=o)}}return-1!==i&amp;&amp;(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r&lt;t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&amp;&amp;(e=t.substr(0,r)),e+=g[n]):void 0!==e&amp;&amp;(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&amp;&amp;e.path.length&gt;1&amp;&amp;</span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&amp;&amp;(e.path.charCodeAt(1)&gt;=65&amp;&amp;e.path.charCodeAt(1)&lt;=90||e.path.charCodeAt(1)&gt;=97&amp;&amp;e.path.charCodeAt(1)&lt;=122)&amp;&amp;58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&amp;&amp;(n=n.replace(/</span><span class="s3">\\</span><span class="s1">//g,</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">)),n}function y(t,e){const r=e?p:d;let n=</span><span class="s3">\&quot;\&quot;</span><span class="s1">,{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&amp;&amp;(n+=i,n+=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">),(o||</span><span class="s3">\&quot;</span><span class="s1">file</span><span class="s3">\&quot;</span><span class="s1">===i)&amp;&amp;(n+=a,n+=a),o){let t=o.indexOf(</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">);if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">,n+=r(e.substr(t+1),!1,!0)),n+=</span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">}o=o.toLowerCase(),t=o.lastIndexOf(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length&gt;=3&amp;&amp;47===s.charCodeAt(0)&amp;&amp;58===s.charCodeAt(2)){const t=s.charCodeAt(1);t&gt;=65&amp;&amp;t&lt;=90&amp;&amp;(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length&gt;=2&amp;&amp;58===s.charCodeAt(1)){const t=s.charCodeAt(0);t&gt;=65&amp;&amp;t&lt;=90&amp;&amp;(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&amp;&amp;(n+=</span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">,n+=r(h,!1,!1)),c&amp;&amp;(n+=</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">,n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length&gt;3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=&gt;v(t))):t}var A=r(470);const w=A.posix||A,x=</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">;var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&amp;&amp;(r=x+r,n=!0);let i=w.resolve(r,...e);return n&amp;&amp;i[0]===x&amp;&amp;!t.authority&amp;&amp;(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&amp;&amp;46===e.charCodeAt(0)&amp;&amp;(e=</span><span class="s3">\&quot;\&quot;</span><span class="s1">),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();export const{URI,Utils}=LIB;</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.mjs.map&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>