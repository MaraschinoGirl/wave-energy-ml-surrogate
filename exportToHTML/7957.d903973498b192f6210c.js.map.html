<html>
<head>
<title>7957.d903973498b192f6210c.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7957.d903973498b192f6210c.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7957.d903973498b192f6210c.js?v=d903973498b192f6210c&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAE+B;;AAE/B;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,YAAY;AACZ;AACO,gCAAgC,UAAU;;AAEjD;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO,6BAA6B,UAAU;;AAE9C;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA,WAAW,KAAK;AAChB,WAAW,qCAAqC;AAChD,YAAY;AACZ;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,WAAW,KAAK;AAChB,WAAW,kCAAkC;AAC7C,YAAY;AACZ;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO,4CAA4C,aAAa;;AAEhE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,oCAAoC;AAC/C;AACO;;AAEA;;AAEP;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gBAAgB;AAC9B,cAAc,uEAAuE;AACrF,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA,kBAAkB,gBAAgB;AAClC,+BAA+B,KAAK,2BAA2B,KAAK;AACpE;AACA,oBAAoB,KAAK;AACzB;;;;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;;AAEmC;AACE;;AAErC;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,YAAY;AACvB;AACO;AACP;AACA,WAAW,eAAe;AAC1B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO,4JAA4J,UAAU;;AAE7K;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAa,QAAQ,wDAAa;AAC5C;AACA;AACA;AACA,aAAa,6DAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,GAAG;AACjB;AACA,WAAW,GAAG;AACd,WAAW,aAAa;AACxB;AACA;AACO;AACP;;AAEO,gBAAgB,wDAAa;;AAEpC;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;AAEP;AACA,cAAc,oCAAoC;AAClD,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA,cAAc,oCAAoC;AAClD,WAAW,MAAM;AACjB;AACO;AACP;AACA,aAAa,KAAK;AAClB,cAAc;AACd;AACA;;;;;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;AACP;AACA,wBAAwB,aAAa;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,WAAW,KAAK;AAChB,WAAW,GAAG;AACd,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEA;;AAEA;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEA;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACO;;;;;;;;;;;;;;;;;;ACzDP;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B;AACO;;AAEP;AACA;AACA,YAAY,eAAe;AAC3B,WAAW,wBAAwB;AACnC;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO;;;;;;;;;;;;;;;;AC3GP;AACA;AACA;AACA;AACA;;AAE+B;AACA;AACI;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA,6BAA6B,KAAK;AAClC;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA,sBAAsB,qDAAU;AAChC;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA,IAAI,6DAAkB,wBAAwB,qDAAU;AACxD;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,YAAY;AACzB;AACA;AACA;AACA,WAAW,qDAAU,+BAA+B,qDAAU;AAC9D;;AAEA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;;;;;;;;;;;;;AC5BP;AACA;AACA;AACA;AACA;;AAEqC;AACJ;;AAEjC;AACA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/CA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvLM;;AAEnC;AACA;AACA;AACA;AACA;;AAEO;AACA;;AAEP;AACA;AACA;AACA;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,2FAA2F,UAAU,EAAE,mBAAmB;;AAEjI;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,wBAAwB,QAAQ;AAChC;AACA;AACA;;AAEA;AACO,mCAAmC,aAAa;;AAEvD;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;;AAEP;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA;AACA;;AAEA;AACO,6FAA6F,8BAA8B;;AAElI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO,4CAA4C,aAAa;;AAEhE;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACO,mBAAmB,yGAAyD;;AAEnF;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO,8BAA8B,yBAAY;;;ACxIjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACO;;;ACZP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACO;;AAEP;AACA,yDAAyD,GAAG;AAC5D;AACA,WAAW,WAAW,iDAAiD,SAAS;AAChF;AACA;AACA;AACO,uFAAuF,KAAK;;AAEnG;AACA,4DAA4D,GAAG;AAC/D;AACA,WAAW,WAAW,iDAAiD,SAAS;AAChF;AACA;AACA;AACO,2FAA2F,KAAK;;;;;;ACvEvG;AACA;AACA;AACA;AACA;;AAE+B;AACM;AACQ;AACN;AACL;;AAElC;AACA;AACO,sBAAsB,OAAO,oBAAoB,OAAO;AAC/D,qBAAqB,OAAO;AAC5B;AACO;AACP;AACO;AACP;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,kBAAU;AACzB,oBAAoB,OAAO;AAC3B;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,eAAe,kBAAU,IAAI;AAC7B;AACA;AACA;AACA,0BAA0B,aAAoB,WAAW;AACzD,yBAAyB,aAAoB,WAAW;AACxD;AACA,OAAO;AACP,MAAM;AACN,eAAe,kBAAU;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;AACP;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;AACP;AACA,MAAM,eAA0B,CAAC,OAAO;AACxC,MAAM,eAA0B,CAAC,UAAkB;;AAEnD;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;AACP;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;AACP;;AAEA;AACO;;AAEP;AACA;AACA,EAAE,6BAAS,CAAC,OAAO;;AAEnB;AACO;AACP,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;;ACjIA;AACA;AACA;AACA;AACA;;AAEqC;AACE;AACJ;AACF;AACQ;AACA;;AAEzC;AACA,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACO;;AAEP;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC,SAAS,YAAmB;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;;AAEA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACO,iBAAiB,SAAa;;AAErC;AACO,mBAAmB,SAAa;;AAEvC;AACA;AACA,WAAW,YAAY;AACvB;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;;AAEP;AACA,qBAAqB,GAAG;AACxB;AACA,WAAW,YAAY;AACvB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;;;ACrKA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uDAAO;;AAE5B;AACA;AACA;AACA,UAAU;AACV;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;AACA,UAAU;AACV;AACO;AACP;AACA,UAAU;AACV;AACO;;;ACzFP;AACA;AACA;AACA;AACA;;AAEiC;AACI;;AAE9B;AACA;;AAEA,qBAAqB,uDAAO;AAC5B,sBAAsB,MAAa;AACnC,uBAAuB,MAAa;;AAE3C;AACO,0FAA0F,uBAAU;AACpG,MAAM,YAAK;AACX,MAAM,eAAQ;;AAErB;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;AACJ;AACI;AACA;AACA;AACF;;AAEnC;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,wBAAwB;AACnC;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO,MAAM,eAAM;AACnB;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,YAAY;AACxB;AACO;AACP,kCAAkC,eAAM;AACxC;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA,eAAe,mCAA0C;AACzD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,sBAAsB,mCAA0C;AAChE,kCAAkC,qBAAQ;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA,kBAAkB,4CAA4C;AAC9D;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO,iBAAiB,mDAAG;;AAE3B;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP,kBAAkB,QAAQ;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP,eAAe,KAAY;AAC3B,mBAAmB,IAAW,IAAI,KAAY;AAC9C,UAAU,uBAAU;AACpB;AACA,iBAAiB,KAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP,qBAAqB,gCAAmB;AACxC;AACA;AACA;AACA;AACA,wBAAwB,KAAY,GAAG,IAAW,sBAAsB,IAAW,SAAS,KAAY;AACxG,QAAQ,uBAAU;AAClB;AACA;AACA;AACA,0BAA0B,KAAY,GAAG,IAAW,SAAS,KAAY;AACzE,UAAU,uBAAU;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA,oBAAoB,eAAsB;AAC1C;AACA,oBAAoB,aAAa;AACjC;AACA;AACA,IAAI;AACJ,gCAAgC,UAAiB;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,8BAA8B,QAAQ;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACO,wBAAwB,eAAsB,eAAe,KAAK,IAAI,eAAsB;;AAEnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACO;;AAEP;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB;AACO;AACP;AACA;AACA,sBAAsB,qBAAQ;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAQ;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB;AACO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO,mDAAmD,KAAK;;AAE/D;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACO,oDAAoD,KAAK;;AAEhE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ,MAAM,QAAQ;AACzF,mEAAmE,QAAQ,MAAM,QAAQ;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,sFAAsF;AACjG;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAgB,UAAU,qBAAQ,UAAU,MAAa;AACnE;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,SAAS,0BAAa;AAC9B;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACO,6BAA6B,uDAAO;AAC3C;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,gCAAgC,uDAAO;AAC9C;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;ACn5BA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACO;;AAEP;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACO;AACP;AACA;;AAEA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACO;AACP;AACA;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEqC;AACA;AACJ;AACI;AACA;AACF;AACM;;AAEzC,kCAAkC,MAAY;AAC9C,+BAA+B,MAAY;;AAE3C;AACA;AACA;AACO;AACP;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO,MAAM,mBAAU;;AAEvB;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP,eAAe,mCAA0C;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAY;AACjC;AACA,YAAY,IAAW;AACvB;AACA;AACA;AACA,cAAc,gBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP;AACA,gBAAgB,KAAY;AAC5B;AACA,oBAAoB,IAAW;AAC/B,WAAW,IAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAY;AACjC;AACA,YAAY,IAAW;AACvB;AACA;AACA;AACA,cAAc,gBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,gCAAgC;AAChC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACO;AACP,oBAAoB,eAAsB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACO,sBAAsB,eAAsB;;AAEnD;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACO;;AAEP;AACA,WAAW,SAAS;AACpB;AACO;;AAEP;AACA,WAAW,SAAS;AACpB;AACO,2CAA2C,KAAK;;AAEvD;AACA,WAAW,SAAS;AACpB;AACO,4CAA4C,KAAK;;AAExD;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA,GAAG;AACH,eAAe;AACf;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACO;;AAEP;AACA;AACA;AACA;AACA;AACO;AACP;AACA,aAAa,YAAY;AACzB,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU,mBAAU;AACpB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;;AAEO,6BAA6B,uDAAO;AAC3C;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEO,gCAAgC,uDAAO;AAC9C;AACA,aAAa,YAAY;AACzB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU,mBAAU;AACpB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEO;AACP;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,gCAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEO,mCAAmC,uDAAO;AACjD;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,QAAQ;AAC9B;AACA;;AAEO;AACP;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uBAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEO;AACP;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AClsBA;;AAEO;AACA,MAAM,yBAAe;;;ACH5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;AACI;AACW;;AAEzC;;AAEA,qBAAqB,yBAAe;;AAEpC;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;;AAEP;AACA;;AAEA;AACA,YAAY;AACZ;AACO,kEAAkE,QAAQ;AACjF;AACA;;;ACpCA;AACA;AACA;AACA;AACA;;AAEiC;;AAEjC;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;;AAEA;AACA;AACA,WAAW,sDAAsD;AACjE,YAAY;AACZ;AACO,MAAM,cAAM,mBAAmB,YAAY;;AAElD;AACA,WAAW,qDAAqD;AAChE,YAAY;AACZ;AACO;;AAEP;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA,WAAW,IAAI;AACf,YAAY,UAAU,2CAA2C;AACjE;AACO,MAAM,WAAG;;AAEhB;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,2DAA2D,cAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,wBAAwB,cAAM;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;;;;ACjGP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACO;AACP;AACA,aAAa,GAAG;AAChB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACO,MAAM,WAAM;;AAEnB;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,oBAAoB;AAC/B;AACO;;AAEP;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACO,MAAM,QAAG;;;ACjDhB;;AAEA;AACA;AACA;AACA;AACA;;AAEiC;AACF;;AAE/B;AACA;AACA,UAAU;AACV;AACO,uBAAuB,UAAU,mDAAmD;;AAE3F;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEA,6BAA6B,WAAW;;AAE/C;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA,WAAW,SAAS;AACpB,WAAW,yCAAyC;AACpD,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,qBAAqB;AAChC,YAAY;AACZ;AACO;AACP,kCAAkC,6BAA6B;AAC/D;AACA;;AAEA;AACA,WAAW,4BAA4B;AACvC,YAAY;AACZ;AACO;AACP;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;AACP;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB;AACO;;AAEP;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACO,MAAM,oBAAgB;;AAE7B;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,WAAW,eAAe;AAC1B;AACO,MAAM,uBAAmB;;AAEhC;AACA,WAAW,MAAM;AACjB,WAAW,wCAAwC;AACnD,YAAY;AACZ;AACO;AACP,uCAAuC,oBAAgB;AACvD;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,wCAAwC;AACnD,YAAY;AACZ;AACO;AACP,uCAAuC,uBAAmB;AAC1D;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,2DAA2D;AACtE,WAAW,aAAa;AACxB,YAAY;AACZ;AACO,MAAM,WAAO;AACpB;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACO;AACP,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,MAAM,QAAI,GAAG,8DAAc;;AAElC;AACA,WAAW,0BAA0B;AACrC;AACO,qCAAqC,UAAU,GAAG,YAAY;;AAErE;AACA,WAAW,iCAAiC;AAC5C,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO,8BAA8B,eAAO,uBAAuB,IAAI,GAAG,OAAO;;AAEjF;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,wBAAwB;AACnC,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,wCAAwC,aAAa;;AAE5D;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA,gEAAgE,KAAK;;AAErE;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,kDAAkD,KAAK;;AAE9D;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,aAAa;AACxB,WAAW,8BAA8B;AACzC;AACO;;AAEP;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,WAAW;AACtB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEP;AACA,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB;AACO;;AAEP;AACA,WAAW,MAAM;AACjB,WAAW,aAAa;AACxB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;ACtQA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACO,MAAM,aAAM;;AAEnB;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;;;;ACjB8B;AACJ;AACM;AACF;;AAE9B,aAAa,aAAa;AAC1B,eAAe,aAAa;AAC5B,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,cAAc,aAAa;AAC3B,YAAY,aAAa;AACzB,eAAe,aAAa;AAC5B,eAAe,aAAa;AAC5B,gBAAgB,aAAa;;AAEpC;AACA;AACA,WAAW,oCAAoC;AAC/C,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,6BAAgB;;AAEtC;AACA;AACA,WAAW,uBAAuB;AAClC,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3EA;AACA;AACA;AACA;AACA;;AAEuC;AACR;AACE;AACF;AACE;AACF;AACY;AACV;AACY;;AAEsD;;AAEnG;AACA,UAAU;AACV;AACA;AACA,GAAG,IAAW,GAAG,WAAW;AAC5B,GAAG,MAAa,GAAG,WAAW;AAC9B,GAAG,IAAW,GAAG,WAAW;AAC5B,GAAG,KAAY,GAAG,WAAW;AAC7B,GAAG,IAAW,GAAG,WAAW;AAC5B,GAAG,GAAU,GAAG,WAAW;AAC3B,GAAG,MAAa,GAAG,WAAW;AAC9B,GAAG,MAAa,GAAG,WAAW;AAC9B,GAAG,OAAc,GAAG,WAAW;AAC/B;;AAEA;AACA,WAAW,oCAAoC;AAC/C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAU;AACjC;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,gBAAoB;AAC1C;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B,aAAiB;AAC5C;AACA,IAAI,yBAAgC;AACpC;;AAEA;AACA,WAAW,oCAAoC;AAC/C;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,oCAAoC;AAC/C;AACO;AACP;AACA,eAAe,MAAa;AAC5B;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACO;AACP;AACA;AACA;AACA,oBAAoB,OAAO,IAAI,0BAA0B,8BAA8B,wBAAwB,IAAI;AACnH;AACA,uDAAuD,OAAO,GAAG,kBAAkB,IAAI,YAAY;AACnG;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACO;AACP,2BAA2B,SAAS,OAAO;;AAE3C;AACA,WAAW,oCAAoC;AAC/C;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,oCAAoC;AAC/C;AACO;AACP;AACA;AACA;AACA;;AAEO;AACP;AACA;AACA;AACA;;AAEA;AACA,WAAW,iBAAiB;AAC5B;AACA;AACO;AACP;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACA;AACO;AACP;;AAEO,kBAAkB,uBAAU;;AAEnC;AACA,WAAW,oCAAoC;AAC/C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS,iBAAiB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,gCAAgC,YAAY;;AAErE;AACO;AACP;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,oCAAoC;AACjD,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW,eAAe,gBAAgB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,oCAAoC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW,eAAe,gBAAgB;AACzD;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,yBAAyB;AAC5D;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,WAAW,SAAS;AACpB;AACA;AACO;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO,MAAM,0BAAkB;;;ACrX/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,aAAa;AACb;AACA,CAAC;;AAED;AACA;AACA,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA,cAAc;AACd;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,CAAC;;AAED;AACA;AACA,WAAW,aAAa;AACxB,WAAW,qBAAqB;AAChC;AACO;AACP;AACA;AACA;AACA,IAAI;AACJ;AACA,CAAC;;AAED;AACA;AACA,WAAW,aAAa;AACxB,WAAW,eAAe;AAC1B;AACO;AACP,UAAU,cAAc;AACxB,WAAW;AACX,CAAC;;;;;AC5D4C;AACT;AACF;AACF;AACU;AACA;AACJ;AACE;AACF;AACF;AACE;AACH;AACK;AACR;AACQ;AACN;AACI;AACI;AACJ;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,gCAAgC,4BAAU;AAC1C;AACA,aAAa,KAAK;AAClB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,WAAW;AACtB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA,GAAG;;AAEH;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,uBAAU;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA,mBAAmB,qBAAQ;AAC3B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,kBAAkB;AAC7B,YAAY,WAAW;AACvB;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,+BAA+B,gBAAgB;AAC/C,UAAU,2BAAc;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,EAAE,0BAAkB,sCAAsC,mBAAmB;AAC7E;;AAEA;;AAEA;AACA,WAAW,aAAa;AACxB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,0CAA0C,wCAAwC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,2BAA2B;AACtC,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA,EAAE,YAAqB;;AAEvB;AACA,EAAE,uBAAU;AACZ;AACA;AACA;AACA,MAAM,YAAqB;AAC3B;AACA,MAAM,YAAqB;AAC3B,sBAAsB,SAAS;AAC/B;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,WAAW,2BAA2B;AACtC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAoB;AACzC,kBAAkB,gBAAgB;AAClC;AACA,mBAAmB,WAAoB;AACvC,4BAA4B,WAAoB;AAChD;AACA,sBAAsB,0BAAkB,sCAAsC,mBAAmB;AACjG,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,iBAAiB,yEAAyE;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAoB;AACzC,kBAAkB,gBAAgB;AAClC;AACA,mBAAmB,WAAoB;AACvC,4BAA4B,WAAoB;AAChD;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAqB,qBAAqB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA,oCAAoC,6CAA6C;AACjF;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,4BAA4B,MAAa;;AAEzC;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,wBAAwB;AACtC,cAAc,QAAQ;AACtB,cAAc,eAAe;AAC7B,cAAc,KAAK;AACnB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,4BAAU;AAC5B;AACA,aAAa,SAAS;AACtB;AACA,iBAAiB,OAAO,MAAa,8GAA8G,IAAI;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,uCAAuC,cAAc;AACrD;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,uBAAU;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yBAAyB;AACtC,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,iBAAiB,0BAAkB;AACnC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,OAAO;AAC7C,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,YAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,8CAA8C,MAAM;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI,uBAAU;AACd;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C,8BAA8B,qDAAqD;AACnF;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,sBAAsB;AACnC;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAoB;AAC/B;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAoB;AAC/B;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,WAAoB,oBAAoB,WAAoB;AAChF;;AAEA;AACA,cAAc;AACd;AACA;AACA,oBAAoB,WAAoB,oBAAoB,WAAoB;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAoB;AAC/B;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,WAAW,SAAkB;AAC7B;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,aAAsB;AACjC;;AAEA;AACA,cAAc,SAAS;AACvB;AACA;AACA,WAAW,WAAoB;AAC/B;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,WAAW,WAAoB;AAC/B;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,WAAW,WAAoB;AAC/B;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,OAAgB;AAC3B;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,cAAqB,CAAC,iBAA0B;AAC3D;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,sBAAsB,aAAsB;AAC5C;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,aAAsB;AACjC;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,sBAAsB,WAAoB;AAC1C;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,iBAAiB,WAAoB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,IAAI,WAAoB,WAAW;AACnC,+BAA+B,oBAA6B,CAAC,iBAA0B;AACvF,6BAA6B,iBAA0B,CAAC,iBAA0B;AAClF,gCAAgC,oBAA6B,CAAC,iBAA0B;AACxF,iCAAiC,oBAA6B,CAAC,iBAA0B;AACzF,2BAA2B,UAAmB,CAAC,iBAA0B,WAAW,SAAkB;AACtG,6BAA6B,aAAsB,CAAC,iBAA0B;AAC9E,iCAAiC,UAAmB,CAAC,iBAA0B,WAAW,SAAkB;AAC5G,8BAA8B,iBAA0B,CAAC,iBAA0B;AACnF,0BAA0B,iBAA0B,CAAC,iBAA0B;AAC/E;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA,sBAAsB,QAAQ;AAC9B;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,OAAgB;AAC3B;;AAEA;AACA,cAAc;AACd;AACA;AACA,WAAW,iBAA0B;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW,OAAgB;AAC3B;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,aAAsB;AAC7C;;AAEA;AACA,WAAW,YAAqB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,YAAqB;AACzB;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,IAAI,YAAqB;AACzB,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,IAAI;AACjB;AACA;AACA,IAAI,YAAqB;AACzB,IAAI,YAAqB;AACzB;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,UAAmB;AACvB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,cAAuB;AAC3B;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA,IAAI,QAAiB;AACrB;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,IAAI,kBAA2B;AAC/B;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA,IAAI,cAAuB;AAC3B;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA,IAAI,cAAuB;AAC3B;AACA;;AAEA;AACA;AACA,uBAAuB,aAAsB,IAAI;AACjD;AACA;;AAEA;AACA,WAAW,YAAqB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,MAAM,cAAoB;AAC1B;AACA,IAAI,YAAqB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,+BAA+B,oBAA6B;AAC5D,6BAA6B,iBAA0B;AACvD,gCAAgC,oBAA6B;AAC7D,iCAAiC,oBAA6B;AAC9D,2BAA2B,UAAmB,CAAC,UAAmB;AAClE,6BAA6B,aAAsB;AACnD,iCAAiC,UAAmB,CAAC,UAAmB;AACxE,8BAA8B,iBAA0B;AACxD,0BAA0B,iBAA0B;AACpD;;AAEA;AACA,oBAAoB,aAAsB;AAC1C,IAAI,YAAqB,cAAc;AACvC,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B,UAAU,YAAqB;AAC9D,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B,UAAU,YAAqB;AAC9D,IAAI,kBAA2B;AAC/B,IAAI,kBAA2B;AAC/B;AACA,IAAI,eAAwB,UAAU,YAAqB;AAC3D,WAAW,YAAqB;AAChC;;AAEA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA,IAAI,QAAiB;AACrB;;AAEA;AACA,aAAa,YAAY;AACzB;AACA;AACA,IAAI,kBAA2B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA,IAAI,QAAiB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,UAAU,qBAAQ,8BAA8B;AAChD;AACA;AACA,EAAE,YAAqB;AACvB;AACA,EAAE,YAAqB;AACvB;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,aAAa;AACxB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,EAAE,YAAqB;AACvB;AACA;AACA,EAAE,uBAAU;AACZ,qCAAqC,gBAAgB;AACrD,GAAG;AACH;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,KAAK;AAChB,YAAY,cAAc,mCAAmC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc,mCAAmC;AAC7D;AACA,qBAAqB,kBAAU;AAC/B,4BAA4B,WAAoB;AAChD,kBAAkB,uBAAuB;AACzC,4BAA4B,WAAoB;AAChD;AACA,cAAc;AACd;AACA;AACA;AACA,gBAAgB,WAAoB;AACpC;AACA,6BAA6B,YAAY;AACzC,oBAAoB,qBAAqB;AACzC;AACA,cAAc,KAAY;AAC1B,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,sBAAsB,WAAoB;AAC1C;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAW,GAAG,IAAW;AACvE;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB,IAAW,MAAM,IAAW;AAChD;AACA,oBAAoB,IAAW,MAAM,IAAW;AAChD;AACA,0CAA0C,IAAW,MAAM,IAAW;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,cAAc,gCAAgC,GAAG;AAC5D,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,6BAA6B,uBAAU;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,6BAA6B,KAAK,sCAAsC,KAAK;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,0BAAkB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,8DAA8D,QAAQ,mBAAmB;AACzF;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,MAAM;AACN,6BAA6B,SAAS;AACtC,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAqB,0BAA0B;AACnD,aAAa;AACb;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,aAAsB;AACxE,MAAM,WAAoB,+BAA+B;AACzD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,YAAY;AACvB,WAAW,KAAK;AAChB,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA,kBAAkB,aAAsB;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,YAAY;AACvB,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,WAAW,KAAK;AAChB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,YAAY;AACvB,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,2BAA2B;AACtC,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;AACA;AACA,mBAAmB,WAAoB;AACvC,kBAAkB,cAAc;AAChC,mBAAmB,WAAoB;AACvC,kBAAkB,WAAoB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,oBAAoB;AAChC;AACA;AACA;AACA,0EAA0E,aAAsB;;AAEhG;AACA,WAAW,2BAA2B;AACtC,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA,EAAE,YAAqB;AACvB,EAAE,uBAAU;AACZ,IAAI,YAAqB,+BAA+B;AACxD,IAAI,YAAqB;AACzB,GAAG;AACH;AACA;;AAEA;AACA,WAAW,2BAA2B;AACtC,WAAW,KAAK;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,WAAW,2BAA2B;AACtC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,uCAAuC;AAC3C;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,0BAA0B;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,0BAA0B;AACrC,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,oCAAoC;AACxC;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA,EAAE,6BAAS;;AAEX;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA,EAAE,YAAqB;AACvB,EAAE,YAAqB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,WAAW,WAAoB,WAAW,WAAoB;;AAE9D;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAoB;AAC5B;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,WAAW;AACtB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA,MAAM,cAAU;AAChB;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,WAAW;AACxB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,QAAQ;AACvB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA,+IAA+I,aAAsB;AACrK;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP,sGAAsG,aAAsB;AAC5H,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,0CAA0C;AACvD;AACA,oDAAoD,sBAAsB,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,IAAI;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA,UAAU,2BAA2B;AACrC;AACA,IAAI,YAAqB;AACzB;AACA,IAAI;AACJ;AACA,IAAI,UAAmB;AACvB,IAAI,cAAuB;AAC3B,IAAI;AACJ;AACA,IAAI,UAAmB;AACvB;AACA,IAAI;AACJ,UAAU,cAAoB;AAC9B;AACA,EAAE,WAAoB;AACtB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA,kBAAkB,aAAsB;AACxC;AACA,SAAS,YAAqB;AAC9B;;AAEA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAoB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB,YAAY,UAAmB;AAClE;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA,kEAAkE,aAAsB;;AAExF;AACA,WAAW,kBAAkB;AAC7B,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN,YAAY,cAAoB;AAChC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,oBAAoB;AACjC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,2BAA2B;AACtC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,2BAA2B;AACtC,YAAY;AACZ;AACA,yDAAyD,aAAsB;AAC/E;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA,oEAAoE,aAAsB;;AAE1F;AACA,WAAW,WAAW;AACtB,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,UAAU;AACrB;AACA;AACA,eAAe,0BAAkB,iDAAiD,uBAAU;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,WAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,UAAU;AACrB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,SAAS;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,YAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAqB;AAC3B;AACA;AACA,MAAM,YAAqB;AAC3B,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB,WAAW,iDAAiD;AAC5D;AACA;AACA,qCAAqC,aAAsB;AAC3D;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,YAAY,cAAoB;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uBAAU,iDAAiD;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,eAAe,uBAAU;AACzB;AACA;AACA;AACA,QAAQ,cAAoB;AAC5B;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+BAA+B;;AAE1D;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,IAAI;AACf,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,gBAAgB;AAC3B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,KAAK;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,aAAa;AACxB,YAAY,SAAS;AACrB;AACA;AACA,mDAAmD,eAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,2BAA2B;AACtC,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA,IAAI,0BAAkB,4BAA4B,uBAAU;AAC5D;AACA;;AAEA;AACA,WAAW,uBAAuB;AAClC,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA,4EAA4E,mBAAmB;AAC/F,qBAAqB,mBAAmB,uDAAuD,MAAM;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA,+BAA+B,gBAAgB;AAC/C,0CAA0C,SAAS;AACnD;AACA;AACA,oCAAoC,qBAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,aAAa;AACxB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,MAAM,iCAAO;AACb;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA,iCAAiC,qBAAQ;AACzC,2CAA2C,oBAAoB;AAC/D;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD,gBAAgB,gBAAgB;AAChC,mCAAmC,gBAAgB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,KAAa,CAAC,MAAc,EAAE,IAAY,YAAY,MAAc,EAAE,GAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,+BAA+B,qEAAqE;AACpG;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA,oDAAoD,GAAG;AACvD;AACA;AACA,WAAW,KAAK;AAChB,WAAW,yBAAyB;AACpC,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,WAAW;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,WAAW;AACtB;AACA;AACA;AACA,sDAAsD,cAAU;AAChE;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;AAC9C;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA,oDAAoD,cAAU,kBAAkB,MAAM;AACtF;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,6BAA6B,cAAU;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA,6CAA6C,wDAAwD;AACrG;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,+BAA+B;AAC7C,cAAc,wBAAwB;AACtC;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,SAAS;AACvB,cAAc,KAAK;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,0BAA0B,4BAAU;AACpC;AACA,aAAa,4CAA4C;AACzD,aAAa,oBAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,KAAK,IAAI,0BAAa;AAC3C,IAAI,IAAI;AACR;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,kBAAkB,6BAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,SAAS;AACrF,4DAA4D,cAAU;AACtE;AACA;AACA,OAAO;AACP,6BAA6B,qJAAqJ;AAClL;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,8CAA8C;AAC3D;AACA;AACA,aAAa,0BAAa;AAC1B;AACA;AACA,oCAAoC,IAAY,8BAA8B;AAC9E;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oEAAoE;AAC1G,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA,4BAA4B,WAAoB;AAChD,kBAAkB,uBAAuB;AACzC,4BAA4B,WAAoB;AAChD;AACA,gBAAgB,WAAoB;AACpC,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,oBAAoB,WAAoB;AACxC;AACA;AACA,QAAQ,UAAU,KAAY;AAC9B,4CAA4C,IAAW,GAAG,IAAW;AACrE;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB,IAAW,MAAM,IAAW;AAC9C;AACA,kBAAkB,IAAW,MAAM,IAAW;AAC9C;AACA;AACA,wCAAwC,IAAW,MAAM,IAAW;AACpE;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA,qCAAqC,aAAsB;AAC3D;AACA,oCAAoC,eAAe;AACnD;AACA;AACA,EAAE,KAAa;AACf;AACA,EAAE,KAAa;AACf;;AAEA;AACA,WAAW,YAAY;AACvB;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA,qCAAqC,aAAsB;AAC3D;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,0CAA0C;AAChE;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,yCAAyC;AACpD,WAAW,iDAAiD;AAC5D,YAAY;AACZ;AACA;AACA;AACA,0DAA0D,aAAsB;AAChF;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,UAAU,YAAqB;AAC/B,UAAU,YAAqB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,YAAqB;AAC3B,MAAM,YAAqB;AAC3B;AACA;AACA,gBAAgB,aAAsB;AACtC,IAAI,YAAqB;AACzB,IAAI,kBAA2B;AAC/B;AACA;AACA,IAAI;AACJ,IAAI,YAAqB;AACzB;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,iDAAiD;AAC5D,cAAc;AACd;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,0DAA0D,aAAsB;AAChF;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA,WAAW,YAAY;AACvB,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA,IAAI;AACJ,YAAY,gBAAgB;AAC5B;AACA,IAAI;AACJ,gCAAgC,MAAM;AACtC,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,iDAAiD;AAC5D,WAAW,iDAAiD;AAC5D,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAsB;AAClF;;AAEA;AACA;AACA,YAAY,SAAS;AACrB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,WAAW;;AAE9C;AACA,4BAA4B,kBAAkB;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,0BAA0B;AAC1B;AACA,UAAU,OAAO;AACjB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN,oBAAoB,mBAAmB,WAAW;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB,WAAW,iDAAiD;AAC5D,WAAW,iDAAiD;AAC5D;AACA;AACA;AACA;AACA;AACA,+BAA+B,aAAsB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAQ;AACpE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,YAAY;AACvB;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA,oCAAoC,0CAA0C,YAAqB,kCAAkC;AACrI,qCAAqC,aAAsB;AAC3D;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,WAAW;AACtB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,YAAqB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,EAAE,YAAqB;;AAEvB,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA,IAAI,YAAqB;AACzB;AACA,IAAI,eAAwB;AAC5B;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,qCAAqC;AAChD,WAAW,iDAAiD;AAC5D,WAAW,kDAAkD;AAC7D;AACA;AACA,qCAAqC,aAAsB;AAC3D;AACA;AACA;AACA,oCAAoC,eAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA,4BAA4B,iDAAiD,IAAI;AACjF;AACA,sBAAsB,kBAAU;AAChC,wBAAwB,kBAAU;AAClC,6BAA6B,kBAAU;AACvC,+BAA+B,kBAAU;AACzC,wCAAwC;AACxC;AACA,aAAa,cAAc;AAC3B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,aAAa;AACnD;AACA,gCAAgC,0BAAkB;AAClD;AACA;AACA,gCAAgC,0BAAkB;AAClD;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA,sBAAsB,0BAAkB;AACxC,wBAAwB,0BAAkB,yCAAyC,GAAG;AACtF;AACA;AACA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,oBAAoB,MAAa;AACjC;AACA;AACA;AACA;AACA,YAAY,cAAoB;AAChC;AACA;AACA,2BAA2B,0BAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,cAAoB;AAC5B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA,WAAW,YAAY;AACvB,WAAW,mBAAmB;AAC9B;AACA;;AAEA;AACA,WAAW,YAAY;AACvB;AACA,wEAAwE,gBAAI;;AAE5E;AACA,WAAW,YAAY;AACvB;AACA,wEAAwE,gBAAI;;AAE5E;;AAEA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc,qBAAqB,mEAAmE;AACtG;AACA;AACA;AACA,cAAc,eAAe,+HAA+H;AAC5J;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD,cAAc;AAChE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,YAAY,cAAc,mEAAmE;AAC7F;AACA;AACA;AACA;AACA,cAAc,MAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,MAAM;AACxC;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAU;AACrC,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B,uBAAU;AACrC,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,yBAAyB,uBAAU,YAAY,MAAM;AACrD,cAAc;AACd;AACA;AACA;AACA,0BAA0B,kBAAkB;AAC5C;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO,8HAA8H;AACjJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAmD,4CAA4C,eAAe,0DAA0D;AACrL;AACA;AACA;AACA;AACA;AACA,cAAc,MAAY;AAC1B;AACA;AACA,oBAAoB,uBAAU;AAC9B,sBAAsB,uBAAU;AAChC;AACA,gBAAgB,OAAO,kBAAkB,EAAE,cAAc,EAAE,cAAc;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,cAAc;AACd,YAAY;AACZ;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,mBAAmB;AAC9B,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA,aAAa,MAAM;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,0BAA0B;AACrC,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,kGAAkG,qBAAQ,oBAAoB,qBAAQ;AACtI;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAQ,qCAAqC,mBAAmB;AACzF;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D;AAC7D,gBAAgB,qBAAQ;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,yBAAyB;AACpC,WAAW,aAAa;AACxB,WAAW,WAAW;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0BAAkB;AACtB;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,mCAAmC,mBAAmB;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,WAAW;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,uCAAuC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,+CAA+C;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,sCAAsC;AACnD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,+CAA+C;AAC5D;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,+BAA+B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,wCAAwC;AACnD,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,4EAA4E;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kMAAkM,YAAY;AAC9M;AACA;AACA;AACA,gLAAgL,KAAK;AACrL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA,6BAA6B,MAAY;;AAEzC;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,oEAAoE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,SAAS,YAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,oEAAoE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA,+IAA+I,4BAA4B;AAC3K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,yBAAyB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,mEAAmE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,YAAY;AAC3D;AACA;AACA,4CAA4C,KAAK;AACjD;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,YAAY;AACZ;AACA;AACA;AACA;AACA,iCAAiC,cAAuB,4BAA4B,KAAK;;AAEzF;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,6DAA6D;AAC7E,aAAa,UAAU;AACvB,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,8CAA8C,WAAW;AACzD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA,oEAAoE,KAAK;AACzE,OAAO;AACP,MAAM;AACN,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE,OAAO;AACP,MAAM;AACN,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,YAAY;AAC7B;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,cAAc,UAAU;AACxB;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;;AAEA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,aAAa;AAC1B,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA,KAAK,WAAW,kBAAkB;AAClC;AACA,KAAK;AACL;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,8DAA8D,cAAc;AAC5E,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAoB,2CAA2C,KAAK;AAC/E;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAoB,2CAA2C,KAAK;AAC/E;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW,WAAoB,2CAA2C,KAAK;AAC/E;;AAEA;AACA;AACA;AACA,aAAa,6CAA6C;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB,cAAc;AACd;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D,OAAO;AACP,MAAM;AACN,iBAAiB,kBAAkB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,MAAM;AACN,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA,qGAAqG,wBAAgB;;AAErH;AACA;AACA,aAAa,WAAW;AACxB,aAAa,WAAW;AACxB,aAAa,QAAQ;AACrB,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,cAAoB;AAC1B;AACA;AACA;AACA;AACA,qEAAqE,eAAe;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,eAAe;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,sBAAsB;AACjC,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,eAAe,4CAA4C,eAAe;AAC9H;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,iBAAiB;AAC5B,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA,WAAW,sBAAsB;AACjC,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4HAA4H,eAAe,qDAAqD,eAAe,sCAAsC;AAC3P;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,sBAAsB;AACjC,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,sBAAsB;AACjC,WAAW,iCAAiC;AAC5C,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,6EAA6E,QAAQ;AACrF,QAAQ,qBAAqB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,mBAAmB;AAC9B,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa,aAAa,eAAe;AAC3D;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,MAAM;AACjB,WAAW,WAAW;AACtB,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA,qBAAqB,kBAAU;AAC/B;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa,aAAa,eAAe;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,+DAA+D,eAAe;AAC9E;AACA;AACA;AACA;AACA;AACA,uBAAuB,MAAM;AAC7B;AACA;AACA;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,eAAe;AAC5C;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B,2BAA2B,MAAM;AACjC;AACA,0BAA0B,kBAAU;AACpC,8BAA8B,gBAAQ;AACtC;AACA;AACA;AACA;AACA,kEAAkE,eAAe;AACjF;AACA;AACA;AACA,8BAA8B,gBAAQ;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA,oCAAoC,MAAM;AAC1C;AACA,uCAAuC,KAAK;AAC5C;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,6CAA6C,OAAO,mEAAmE,OAAO;AAC9H;AACA;AACA,gCAAgC,OAAO;AACvC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,WAAW,aAAa;AACxB,WAAW,sBAAsB;AACjC,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gBAAQ;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mBAAmB,eAAe,MAAM;AACpE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA,WAAW,iCAAiC,cAAc;AAC1D,WAAW,iBAAiB;AAC5B,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,aAAa;AAC1B,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;;AAEA;AACA,aAAa,mDAAmD,4CAA4C,eAAe,0DAA0D;AACrL;AACA;AACA;AACA;AACA,iBAAiB,mDAAmD,4CAA4C,eAAe,mFAAmF;AAClN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA,QAAQ,kDAAkD;AAC1D;AACA,YAAY,OAAO,yGAAyG;AAC5H;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA,gBAAgB,OAAO,yGAAyG;AAChI;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA,+BAA+B;AAC/B;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,uBAAuB,sBAAc;AACrC,oCAAoC,qBAAa,GAAG;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa,aAAa,eAAe;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,sBAAsB,KAAK;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA,iBAAiB,iBAAiB;AAClC,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,aAAa;AAC3B;AACA,aAAa,KAAK;AAClB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB,IAAI;AAC7C;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA,YAAY;AACZ,iFAAiF;AACjF,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB,aAAa,uCAAuC;AACpD,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB;AAClB;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG,iBAAiB;AACzH;AACA,gBAAgB;AAChB;AACA;AACA,sGAAsG,eAAe;AACrH;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gCAAgC,eAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB,MAAM;AACnE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,oBAAoB;AACxE;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,4BAA4B;AACzC,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,gBAAgB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,KAAK;AAChB,YAAY,SAAS;AACrB;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,aAAa,4BAA4B;AACzC,aAAa,qCAAqC;AAClD;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,mCAAmC,MAAM;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,+CAA+C;AAC7D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,4CAA4C,KAAK;AACjD,gFAAgF;AAChF;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd,6BAA6B,mBAAmB;AAChD;AACA;AACA;AACA,QAAQ,4DAA4D,aAAa;AACjF;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,aAAa,kBAAkB,KAAK;AACpC;AACA;;AAEA;AACA,yBAAyB,kBAAkB,MAAM,gBAAgB;AACjE,mCAAmC,kBAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,oCAAoC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,aAAa,cAAc;AAC3B,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,uBAAU;AACrB;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,kBAAkB;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,aAAa,qBAAqB,SAAS;AAC3C;AACA,aAAa,KAAK;AAClB;AACA;AACA,cAAc,MAAM,KAAK;AACzB;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gCAAgC;AAC7C,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,4BAA4B,YAAY;AACxC;AACA;AACA,cAAc,MAAY;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,6BAA6B;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,yDAAyD;AACtE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mEAAmE;AAChF;;AAEA;AACA;AACA,IAAI,2EAA2E;AAC/E;AACA;AACA;AACA;AACA,gBAAgB,6BAA6B,MAAM,uBAAuB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,sBAAsB,eAAe,aAAa;AAC5E;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,sBAAsB,eAAe,aAAa;AAC5E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB,aAAa,MAAM;AACnB;AACA;AACA;AACA,KAAK,YAAY,kBAAkB;AACnC;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,IAAI,sBAAc;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS,EAAE,YAAY,GAAG,iBAAiB,IAAI,SAAS;AACvE;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,iBAAiB;AAClC;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA,aAAa,KAAK;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,iBAAiB,kBAAkB;AACnC;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA,aAAa,KAAK;AAClB;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA;AACA;AACA;AACA,sBAAsB,KAAK;AAC3B;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,aAAa,qBAAqB,SAAS;AAC3C;AACA,aAAa,KAAK;AAClB;AACA;AACA,cAAc,MAAM,KAAK;AACzB;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,kBAAkB;AAC/B;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,aAAa,sBAAsB;AACnC;AACA,aAAa,KAAK;AAClB;AACA;AACA,cAAc,SAAS,KAAK;AAC5B;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,sBAAsB,eAAe,aAAa;AAC5E;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA,0BAA0B,sBAAsB,eAAe,aAAa;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA,aAAa,qBAAqB;AAClC;AACA,aAAa,KAAK;AAClB;AACA;AACA,cAAc,MAAM,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAA6C;AACpE;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA,mBAAmB,cAAc;AACjC,wBAAwB,uBAAuB;AAC/C;AACA,qBAAqB,SAAS,IAAI,WAAW;AAC7C;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD,oBAAoB,wBAAwB;AAC5C;AACA;AACA,KAAK;AACL;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA,UAAU,mBAAyB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,IAAI;AACjB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oCAAoC;AAC/C,YAAY;AACZ;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,gBAAgB;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,oCAAoC;AAC/C,YAAY;AACZ;AACA;;AAEA;AACA,WAAW,QAAQ;AACnB,WAAW,qBAAqB;AAChC;AACA,oDAAoD,sEAAsE;;AAE1H;AACA;AACA;AACA;AACA;AACA,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,YAAY;AACzB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,cAAc;AAC3B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,YAAY;AACzB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,eAAe;AAC5B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc;AACd;AACA;AACA,UAAU,mBAAyB;AACnC;;AAEA;AACA,aAAa,aAAa;AAC1B,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,MAAM;AACnB;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,IAAI;AACf,aAAa;AACb;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,MAAM;AACjB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B,WAAW,IAAI;AACf;AACA,4CAA4C,sBAAU,oBAAoB,WAAW;;AAErF;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,MAAM;AACjB,WAAW,WAAW;AACtB,WAAW,WAAW;AACtB,WAAW,SAAS;AACpB,WAAW,+CAA+C;AAC1D;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,mBAAmB,8BAA8B,aAAa;;AAEpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,8CAA8C,mBAAmB;AACjE;AACA;AACA,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB,aAAa,aAAa;AAC1B,aAAa,WAAW;AACxB,aAAa,aAAa;AAC1B,aAAa,WAAW;AACxB,aAAa,2BAA2B;AACxC,aAAa,eAAe;AAC5B,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,6CAA6C,IAAW;AACxD;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,sBAAsB,IAAW;AACjC,mBAAmB,IAAW;AAC9B;AACA;;AAEA;AACA,wBAAwB,IAAW;AACnC;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,IAAW;AACnC;;AAEA;AACA;AACA,mBAAmB,IAAW;AAC9B;AACA;;AAEA;AACA,wBAAwB,IAAW;AACnC;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA,wBAAwB,IAAW;AACnC;;AAEA;AACA;AACA,mBAAmB,IAAW;AAC9B;AACA;;AAEA;AACA,iBAAiB,IAAW;AAC5B;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;;AAEA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA,UAAU;AACV,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,eAAe,OAAO,KAAK,MAAM,KAAK,KAAK,EAAE;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd,YAAY,iGAAiG;AAC7G;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yBAAyB,mBAAmB;AAC5C;AACA;AACA;AACA,UAAU;AACV,yBAAyB,mBAAmB;AAC5C,WAAW,WAAW,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA,0DAA0D,mBAAmB;AAC7E,sBAAsB,mBAAmB,8CAA8C,mBAAmB;AAC1G;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,aAAa;AAC1B;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,SAAS;AACtB;AACA;AACA;AACA,YAAY,cAAoB;AAChC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA,0CAA0C,KAAY;AACtD,6BAA6B,IAAW;AACxC,kCAAkC,IAAW;AAC7C,gCAAgC,IAAW,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA,UAAU;AACV,0CAA0C;AAC1C;AACA;AACA,QAAQ,0CAA0C;AAClD,uCAAuC;AACvC;AACA,QAAQ;AACR,wCAAwC;AACxC;AACA,QAAQ;AACR,QAAQ,cAAoB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mCAAmC;AAC9C,WAAW,QAAQ;AACnB;AACA,8DAA8D,KAAY;;AAE1E;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,cAAoB,KAAK;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,cAAoB,MAAM;AACpC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,aAAa,MAAM;AACnB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,QAAQ;AACrB;AACA;AACA;AACA,IAAI,cAAoB;AACxB;;AAEA;AACA,aAAa,mCAAmC;AAChD,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA,IAAI,YAAqB;AACzB;;AAEA;AACA,aAAa,aAAa;AAC1B,aAAa,aAAa;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA,aAAa,qBAAM,mBAAmB,qBAAM,KAAK;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEukD;AACvkD&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/array.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/function.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/map.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/math.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/object.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/observable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/set.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/time.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/process/browser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/string.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/conditions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/storage.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/environment.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/buffer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/binary.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/number.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/encoding.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/error.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/decoding.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/webcrypto.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/random.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/promise.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/pair.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/dom.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/symbol.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/logging.common.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/logging.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/iterator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/yjs/dist/yjs.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with Arrays.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as set from './set.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return the last element of an array. The element must exist</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template L</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;L&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {L}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const last = arr =&gt; arr[arr.length - 1]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template C</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;C&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; /** @type {Array&lt;C&gt;} */ ([])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template D</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;D&gt;} a</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;D&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const copy = a =&gt; /** @type {Array&lt;D&gt;} */ (a.slice())</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Append elements from src to dest</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template M</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;M&gt;} dest</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;M&gt;} src</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const appendTo = (dest, src) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; src.length; i++) {</span><span class="s3">\n    </span><span class="s1">dest.push(src[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transforms something array-like to an actual Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;T&gt;|Iterable&lt;T&gt;} arraylike</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const from = Array.from</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* True iff condition holds on every element in the Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template ITEM</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;ITEM&gt;} ARR</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {function(ITEM, number, ARR):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const every = (arr, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!f(arr[i], i, arr)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* True iff condition holds on some element in the Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template S</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;S&gt;} ARR</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {function(S, number, ARR):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const some = (arr, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (f(arr[i], i, arr)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template ELEM</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;ELEM&gt;} a</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;ELEM&gt;} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalFlat = (a, b) =&gt; a.length === b.length &amp;&amp; every(a, (item, index) =&gt; item === b[index])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template ELEM</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Array&lt;ELEM&gt;&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;ELEM&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const flatten = arr =&gt; fold(arr, /** @type {Array&lt;ELEM&gt;} */ ([]), (acc, val) =&gt; acc.concat(val))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">* @param {function(number, Array&lt;T&gt;):T} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unfold = (len, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const array = new Array(len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">array[i] = f(i, array)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @template RESULT</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {RESULT} seed</span><span class="s3">\n </span><span class="s1">* @param {function(RESULT, T, number):RESULT} folder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fold = (arr, seed, folder) =&gt; arr.reduce(folder, seed)</span><span class="s3">\n\n</span><span class="s1">export const isArray = Array.isArray</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unique = arr =&gt; from(set.from(arr))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @template M</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {function(T):M} mapper</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const uniqueBy = (arr, mapper) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Set&lt;M&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const happened = set.create()</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const result = []</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">const el = arr[i]</span><span class="s3">\n    </span><span class="s1">const mapped = mapper(el)</span><span class="s3">\n    </span><span class="s1">if (!happened.has(mapped)) {</span><span class="s3">\n      </span><span class="s1">happened.add(mapped)</span><span class="s3">\n      </span><span class="s1">result.push(el)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;any&gt;} ARR</span><span class="s3">\n </span><span class="s1">* @template {function(ARR extends ArrayLike&lt;infer T&gt; ? T : never, number, ARR):any} MAPPER</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {MAPPER} mapper</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;MAPPER extends function(...any): infer M ? M : never&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (arr, mapper) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const res = Array(arr.length)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return /** @type {any} */ (res)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Common functions and function call helpers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n</span><span class="s1">import * as object from './object.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls all functions in `fs` with args. Only throws after all functions were called.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;function&gt;} fs</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;any&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const callAll = (fs, args, i = 0) =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (; i &lt; fs.length; i++) {</span><span class="s3">\n      </span><span class="s1">fs[i](...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">if (i &lt; fs.length) {</span><span class="s3">\n      </span><span class="s1">callAll(fs, args, i + 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const nop = () =&gt; {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {function():T} f</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const apply = f =&gt; f()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template A</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {A} a</span><span class="s3">\n </span><span class="s1">* @return {A}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const id = a =&gt; a</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {T} a</span><span class="s3">\n </span><span class="s1">* @param {T} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityStrict = (a, b) =&gt; a === b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;|object} a</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;|object} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityFlat = (a, b) =&gt; a === b || (a != null &amp;&amp; b != null &amp;&amp; a.constructor === b.constructor &amp;&amp; ((array.isArray(a) &amp;&amp; array.equalFlat(a, /** @type {Array&lt;T&gt;} */ (b))) || (typeof a === 'object' &amp;&amp; object.equalFlat(a, b))))</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} a</span><span class="s3">\n </span><span class="s1">* @param {any} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityDeep = (a, b) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (a == null || b == null) {</span><span class="s3">\n    </span><span class="s1">return equalityStrict(a, b)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (a.constructor !== b.constructor) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (a === b) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (a.constructor) {</span><span class="s3">\n    </span><span class="s1">case ArrayBuffer:</span><span class="s3">\n      </span><span class="s1">a = new Uint8Array(a)</span><span class="s3">\n      </span><span class="s1">b = new Uint8Array(b)</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line no-fallthrough</span><span class="s3">\n    </span><span class="s1">case Uint8Array: {</span><span class="s3">\n      </span><span class="s1">if (a.byteLength !== b.byteLength) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (a[i] !== b[i]) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Set: {</span><span class="s3">\n      </span><span class="s1">if (a.size !== b.size) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const value of a) {</span><span class="s3">\n        </span><span class="s1">if (!b.has(value)) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Map: {</span><span class="s3">\n      </span><span class="s1">if (a.size !== b.size) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const key of a.keys()) {</span><span class="s3">\n        </span><span class="s1">if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Object:</span><span class="s3">\n      </span><span class="s1">if (object.length(a) !== object.length(b)) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const key in a) {</span><span class="s3">\n        </span><span class="s1">if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case Array:</span><span class="s3">\n      </span><span class="s1">if (a.length !== b.length) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (!equalityDeep(a[i], b[i])) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @template {V} OPTS</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {V} value</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;OPTS&gt;} options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">export const isOneOf = (value, options) =&gt; options.includes(value)</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">export const isArray = array.isArray</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} s</span><span class="s3">\n </span><span class="s1">* @return {s is String}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isString = (s) =&gt; s &amp;&amp; s.constructor === String</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} n</span><span class="s3">\n </span><span class="s1">* @return {n is Number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isNumber = n =&gt; n != null &amp;&amp; n.constructor === Number</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {abstract new (...args: any) =&gt; any} TYPE</span><span class="s3">\n </span><span class="s1">* @param {any} n</span><span class="s3">\n </span><span class="s1">* @param {TYPE} T</span><span class="s3">\n </span><span class="s1">* @return {n is InstanceType&lt;TYPE&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const is = (n, T) =&gt; n &amp;&amp; n.constructor === T</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {abstract new (...args: any) =&gt; any} TYPE</span><span class="s3">\n </span><span class="s1">* @param {TYPE} T</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isTemplate = (T) =&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} n</span><span class="s3">\n   </span><span class="s1">* @return {n is InstanceType&lt;TYPE&gt;}</span><span class="s3">\n   </span><span class="s1">**/</span><span class="s3">\n  </span><span class="s1">n =&gt; n &amp;&amp; n.constructor === T</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with key-value stores.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module map</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a new Map instance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;any, any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; new Map()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copy a Map object into a fresh Map object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template X,Y</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;X,Y&gt;} m</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;X,Y&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const copy = m =&gt; {</span><span class="s3">\n  </span><span class="s1">const r = create()</span><span class="s3">\n  </span><span class="s1">m.forEach((v, k) =&gt; { r.set(k, v) })</span><span class="s3">\n  </span><span class="s1">return r</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get map property. Create T if property is undefined and set T on map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* const listeners = map.setIfUndefined(events, 'eventName', set.create)</span><span class="s3">\n </span><span class="s1">* listeners.add(listener)</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template V,K</span><span class="s3">\n </span><span class="s1">* @template {Map&lt;K,V&gt;} MAP</span><span class="s3">\n </span><span class="s1">* @param {MAP} map</span><span class="s3">\n </span><span class="s1">* @param {K} key</span><span class="s3">\n </span><span class="s1">* @param {function():V} createT</span><span class="s3">\n </span><span class="s1">* @return {V}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setIfUndefined = (map, key, createT) =&gt; {</span><span class="s3">\n  </span><span class="s1">let set = map.get(key)</span><span class="s3">\n  </span><span class="s1">if (set === undefined) {</span><span class="s3">\n    </span><span class="s1">map.set(key, set = createT())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return set</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @template R</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):R} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const res = []</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">res.push(f(value, key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests whether any key-value pairs pass the test implemented by `f(value, key)`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @todo should rename to some - similarly to Array.some</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const any = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">if (f(value, key)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests whether all key-value pairs pass the test implemented by `f(value, key)`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const all = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">if (!f(value, key)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Common Math expressions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module math</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const floor = Math.floor</span><span class="s3">\n</span><span class="s1">export const ceil = Math.ceil</span><span class="s3">\n</span><span class="s1">export const abs = Math.abs</span><span class="s3">\n</span><span class="s1">export const imul = Math.imul</span><span class="s3">\n</span><span class="s1">export const round = Math.round</span><span class="s3">\n</span><span class="s1">export const log10 = Math.log10</span><span class="s3">\n</span><span class="s1">export const log2 = Math.log2</span><span class="s3">\n</span><span class="s1">export const log = Math.log</span><span class="s3">\n</span><span class="s1">export const sqrt = Math.sqrt</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The sum of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const add = (a, b) =&gt; a + b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The smaller element of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const min = (a, b) =&gt; a &lt; b ? a : b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The bigger element of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const max = (a, b) =&gt; a &gt; b ? a : b</span><span class="s3">\n\n</span><span class="s1">export const isNaN = Number.isNaN</span><span class="s3">\n\n</span><span class="s1">export const pow = Math.pow</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Base 10 exponential function. Returns the value of 10 raised to the power of pow.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} exp</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const exp10 = exp =&gt; Math.pow(10, exp)</span><span class="s3">\n\n</span><span class="s1">export const sign = Math.sign</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} n</span><span class="s3">\n </span><span class="s1">* @return {boolean} Wether n is negative. This function also differentiates between -0 and +0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isNegativeZero = n =&gt; n !== 0 ? n &lt; 0 : 1 / n &lt; 0</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility functions for working with EcmaScript objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @return {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; Object.create(null)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Object.assign</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const assign = Object.assign</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const keys = Object.keys</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {{[k:string]:V}} obj</span><span class="s3">\n </span><span class="s1">* @param {function(V,string):any} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const forEach = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">f(obj[key], key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo implement mapToArray &amp; map</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template R</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):R} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const results = []</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">results.push(f(obj[key], key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return results</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const length = obj =&gt; keys(obj).length</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const some = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">if (f(obj[key], key)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object|undefined} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isEmpty = obj =&gt; {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">for (const _k in obj) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const every = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">if (!f(obj[key], key)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls `Object.prototype.hasOwnProperty`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {any} obj</span><span class="s3">\n </span><span class="s1">* @param {string|symbol} key</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const hasProperty = (obj, key) =&gt; Object.prototype.hasOwnProperty.call(obj, key)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} a</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalFlat = (a, b) =&gt; a === b || (length(a) === length(b) &amp;&amp; every(a, (val, key) =&gt; (val !== undefined || hasProperty(b, key)) &amp;&amp; b[key] === val))</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Observable class prototype.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module observable</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as map from './map.js'</span><span class="s3">\n</span><span class="s1">import * as set from './set.js'</span><span class="s3">\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles named events.</span><span class="s3">\n </span><span class="s1">* @experimental</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is basically a (better typed) duplicate of Observable, which will replace Observable in the</span><span class="s3">\n </span><span class="s1">* next release.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template {{[key: string]: function(...any):void}} EVENTS</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ObservableV2 {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Some desc.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string, Set&lt;any&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">on (name, f) {</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)</span><span class="s3">\n    </span><span class="s1">return f</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">once (name, f) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param  {...any} args</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const _f = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.off(name, /** @type {any} */ (_f))</span><span class="s3">\n      </span><span class="s1">f(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.on(name, /** @type {any} */ (_f))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">off (name, f) {</span><span class="s3">\n    </span><span class="s1">const observers = this._observers.get(name)</span><span class="s3">\n    </span><span class="s1">if (observers !== undefined) {</span><span class="s3">\n      </span><span class="s1">observers.delete(f)</span><span class="s3">\n      </span><span class="s1">if (observers.size === 0) {</span><span class="s3">\n        </span><span class="s1">this._observers.delete(name)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Emit a named event. All registered event listeners that listen to the</span><span class="s3">\n   </span><span class="s1">* specified name will receive the event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo This should catch exceptions</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name The event name.</span><span class="s3">\n   </span><span class="s1">* @param {Parameters&lt;EVENTS[NAME]&gt;} args The arguments that are applied to the event listener.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">emit (name, args) {</span><span class="s3">\n    </span><span class="s1">// copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.</span><span class="s3">\n    </span><span class="s1">return array.from((this._observers.get(name) || map.create()).values()).forEach(f =&gt; f(...args))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles named events.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">* @template N</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Observable {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Some desc.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;N, any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">on (name, f) {</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(this._observers, name, set.create).add(f)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">once (name, f) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param  {...any} args</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const _f = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.off(name, _f)</span><span class="s3">\n      </span><span class="s1">f(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.on(name, _f)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">off (name, f) {</span><span class="s3">\n    </span><span class="s1">const observers = this._observers.get(name)</span><span class="s3">\n    </span><span class="s1">if (observers !== undefined) {</span><span class="s3">\n      </span><span class="s1">observers.delete(f)</span><span class="s3">\n      </span><span class="s1">if (observers.size === 0) {</span><span class="s3">\n        </span><span class="s1">this._observers.delete(name)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Emit a named event. All registered event listeners that listen to the</span><span class="s3">\n   </span><span class="s1">* specified name will receive the event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo This should catch exceptions</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {N} name The event name.</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;any&gt;} args The arguments that are applied to the event listener.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">emit (name, args) {</span><span class="s3">\n    </span><span class="s1">// copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.</span><span class="s3">\n    </span><span class="s1">return array.from((this._observers.get(name) || map.create()).values()).forEach(f =&gt; f(...args))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore end */</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with sets.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module set</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const create = () =&gt; new Set()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Set&lt;T&gt;} set</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const toArray = set =&gt; Array.from(set)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Set&lt;T&gt;} set</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const first = set =&gt;</span><span class="s3">\n  </span><span class="s1">set.values().next().value || undefined</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Iterable&lt;T&gt;} entries</span><span class="s3">\n </span><span class="s1">* @return {Set&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const from = entries =&gt; new Set(entries)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module time</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as metric from './metric.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return current time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {Date}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const getDate = () =&gt; new Date()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return current unix time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const getUnixTime = Date.now</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform time (in ms) to a human readable format. E.g. 1100 =&gt; 1.1s. 60s =&gt; 1min. .001 =&gt; 10s.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} d duration in milliseconds</span><span class="s3">\n </span><span class="s1">* @return {string} humanized approximation of time</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const humanizeDuration = d =&gt; {</span><span class="s3">\n  </span><span class="s1">if (d &lt; 60000) {</span><span class="s3">\n    </span><span class="s1">const p = metric.prefix(d, -1)</span><span class="s3">\n    </span><span class="s1">return math.round(p.n * 100) / 100 + p.prefix + 's'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">d = math.floor(d / 1000)</span><span class="s3">\n  </span><span class="s1">const seconds = d % 60</span><span class="s3">\n  </span><span class="s1">const minutes = math.floor(d / 60) % 60</span><span class="s3">\n  </span><span class="s1">const hours = math.floor(d / 3600) % 24</span><span class="s3">\n  </span><span class="s1">const days = math.floor(d / 86400)</span><span class="s3">\n  </span><span class="s1">if (days &gt; 0) {</span><span class="s3">\n    </span><span class="s1">return days + 'd' + ((hours &gt; 0 || minutes &gt; 30) ? ' ' + (minutes &gt; 30 ? hours + 1 : hours) + 'h' : '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (hours &gt; 0) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">return hours + 'h' + ((minutes &gt; 0 || seconds &gt; 30) ? ' ' + (seconds &gt; 30 ? minutes + 1 : minutes) + 'min' : '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return minutes + 'min' + (seconds &gt; 0 ? ' ' + seconds + 's' : '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// shim for using process in browser</span><span class="s3">\n</span><span class="s1">var process = module.exports = {};</span><span class="s3">\n\n</span><span class="s1">// cached from whatever global is present so that test runners that stub it</span><span class="s3">\n</span><span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span><span class="s3">\n</span><span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span><span class="s3">\n</span><span class="s1">// function because try/catches deoptimize in certain engines.</span><span class="s3">\n\n</span><span class="s1">var cachedSetTimeout;</span><span class="s3">\n</span><span class="s1">var cachedClearTimeout;</span><span class="s3">\n\n</span><span class="s1">function defaultSetTimout() {</span><span class="s3">\n    </span><span class="s1">throw new Error('setTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultClearTimeout () {</span><span class="s3">\n    </span><span class="s1">throw new Error('clearTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof setTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof clearTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} ())</span><span class="s3">\n</span><span class="s1">function runTimeout(fun) {</span><span class="s3">\n    </span><span class="s1">if (cachedSetTimeout === setTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if setTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedSetTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">} catch(e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(null, fun, 0);</span><span class="s3">\n        </span><span class="s1">} catch(e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(this, fun, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function runClearTimeout(marker) {</span><span class="s3">\n    </span><span class="s1">if (cachedClearTimeout === clearTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if clearTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedClearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">} catch (e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(null, marker);</span><span class="s3">\n        </span><span class="s1">} catch (e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span><span class="s3">\n            </span><span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(this, marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var queue = [];</span><span class="s3">\n</span><span class="s1">var draining = false;</span><span class="s3">\n</span><span class="s1">var currentQueue;</span><span class="s3">\n</span><span class="s1">var queueIndex = -1;</span><span class="s3">\n\n</span><span class="s1">function cleanUpNextTick() {</span><span class="s3">\n    </span><span class="s1">if (!draining || !currentQueue) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">if (currentQueue.length) {</span><span class="s3">\n        </span><span class="s1">queue = currentQueue.concat(queue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (queue.length) {</span><span class="s3">\n        </span><span class="s1">drainQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function drainQueue() {</span><span class="s3">\n    </span><span class="s1">if (draining) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeout = runTimeout(cleanUpNextTick);</span><span class="s3">\n    </span><span class="s1">draining = true;</span><span class="s3">\n\n    </span><span class="s1">var len = queue.length;</span><span class="s3">\n    </span><span class="s1">while(len) {</span><span class="s3">\n        </span><span class="s1">currentQueue = queue;</span><span class="s3">\n        </span><span class="s1">queue = [];</span><span class="s3">\n        </span><span class="s1">while (++queueIndex &lt; len) {</span><span class="s3">\n            </span><span class="s1">if (currentQueue) {</span><span class="s3">\n                </span><span class="s1">currentQueue[queueIndex].run();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n        </span><span class="s1">len = queue.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentQueue = null;</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">runClearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">process.nextTick = function (fun) {</span><span class="s3">\n    </span><span class="s1">var args = new Array(arguments.length - 1);</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span><span class="s3">\n            </span><span class="s1">args[i - 1] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">queue.push(new Item(fun, args));</span><span class="s3">\n    </span><span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span><span class="s3">\n        </span><span class="s1">runTimeout(drainQueue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// v8 likes predictible objects</span><span class="s3">\n</span><span class="s1">function Item(fun, array) {</span><span class="s3">\n    </span><span class="s1">this.fun = fun;</span><span class="s3">\n    </span><span class="s1">this.array = array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Item.prototype.run = function () {</span><span class="s3">\n    </span><span class="s1">this.fun.apply(null, this.array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.title = 'browser';</span><span class="s3">\n</span><span class="s1">process.browser = true;</span><span class="s3">\n</span><span class="s1">process.env = {};</span><span class="s3">\n</span><span class="s1">process.argv = [];</span><span class="s3">\n</span><span class="s1">process.version = ''; // empty string to avoid regexp issues</span><span class="s3">\n</span><span class="s1">process.versions = {};</span><span class="s3">\n\n</span><span class="s1">function noop() {}</span><span class="s3">\n\n</span><span class="s1">process.on = noop;</span><span class="s3">\n</span><span class="s1">process.addListener = noop;</span><span class="s3">\n</span><span class="s1">process.once = noop;</span><span class="s3">\n</span><span class="s1">process.off = noop;</span><span class="s3">\n</span><span class="s1">process.removeListener = noop;</span><span class="s3">\n</span><span class="s1">process.removeAllListeners = noop;</span><span class="s3">\n</span><span class="s1">process.emit = noop;</span><span class="s3">\n</span><span class="s1">process.prependListener = noop;</span><span class="s3">\n</span><span class="s1">process.prependOnceListener = noop;</span><span class="s3">\n\n</span><span class="s1">process.listeners = function (name) { return [] }</span><span class="s3">\n\n</span><span class="s1">process.binding = function (name) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.binding is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">process.cwd = function () { return '/' };</span><span class="s3">\n</span><span class="s1">process.chdir = function (dir) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.chdir is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.umask = function() { return 0; };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as array from './array.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with strings.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const fromCharCode = String.fromCharCode</span><span class="s3">\n</span><span class="s1">export const fromCodePoint = String.fromCodePoint</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The largest utf16 character.</span><span class="s3">\n </span><span class="s1">* Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const MAX_UTF16_CHARACTER = fromCharCode(65535)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toLowerCase = s =&gt; s.toLowerCase()</span><span class="s3">\n\n</span><span class="s1">const trimLeftRegex = /^</span><span class="s3">\\</span><span class="s1">s*/g</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const trimLeft = s =&gt; s.replace(trimLeftRegex, '')</span><span class="s3">\n\n</span><span class="s1">const fromCamelCaseRegex = /([A-Z])/g</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">* @param {string} separator</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fromCamelCase = (s, separator) =&gt; trimLeft(s.replace(fromCamelCaseRegex, match =&gt; `${separator}${toLowerCase(match)}`))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compute the utf8ByteLength</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const utf8ByteLength = str =&gt; unescape(encodeURIComponent(str)).length</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _encodeUtf8Polyfill = str =&gt; {</span><span class="s3">\n  </span><span class="s1">const encodedString = unescape(encodeURIComponent(str))</span><span class="s3">\n  </span><span class="s1">const len = encodedString.length</span><span class="s3">\n  </span><span class="s1">const buf = new Uint8Array(len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">buf[i] = /** @type {number} */ (encodedString.codePointAt(i))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return buf</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _encodeUtf8Native = str =&gt; utf8TextEncoder.encode(str)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _decodeUtf8Polyfill = buf =&gt; {</span><span class="s3">\n  </span><span class="s1">let remainingLen = buf.length</span><span class="s3">\n  </span><span class="s1">let encodedString = ''</span><span class="s3">\n  </span><span class="s1">let bufPos = 0</span><span class="s3">\n  </span><span class="s1">while (remainingLen &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const nextLen = remainingLen &lt; 10000 ? remainingLen : 10000</span><span class="s3">\n    </span><span class="s1">const bytes = buf.subarray(bufPos, bufPos + nextLen)</span><span class="s3">\n    </span><span class="s1">bufPos += nextLen</span><span class="s3">\n    </span><span class="s1">// Starting with ES5.1 we can supply a generic array-like object as arguments</span><span class="s3">\n    </span><span class="s1">encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))</span><span class="s3">\n    </span><span class="s1">remainingLen -= nextLen</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return decodeURIComponent(escape(encodedString))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">if (utf8TextDecoder &amp;&amp; utf8TextDecoder.decode(new Uint8Array()).length === 1) {</span><span class="s3">\n  </span><span class="s1">// Safari doesn't handle BOM correctly.</span><span class="s3">\n  </span><span class="s1">// This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.</span><span class="s3">\n  </span><span class="s1">// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and</span><span class="s3">\n  </span><span class="s1">// utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call</span><span class="s3">\n  </span><span class="s1">// Another issue is that from then on no BOM chars are recognized anymore</span><span class="s3">\n  </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n  </span><span class="s1">utf8TextDecoder = null</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _decodeUtf8Native = buf =&gt; /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} str The initial string</span><span class="s3">\n </span><span class="s1">* @param {number} index Starting position</span><span class="s3">\n </span><span class="s1">* @param {number} remove Number of characters to remove</span><span class="s3">\n </span><span class="s1">* @param {string} insert New content to insert</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const splice = (str, index, remove, insert = '') =&gt; str.slice(0, index) + insert + str.slice(index + remove)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} source</span><span class="s3">\n </span><span class="s1">* @param {number} n</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const repeat = (source, n) =&gt; array.unfold(n, () =&gt; source).join('')</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Often used conditions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module conditions</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {T|null|undefined} v</span><span class="s3">\n </span><span class="s1">* @return {T|null}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const undefinedToNull = v =&gt; v === undefined ? null : v</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-env browser */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Isomorphic variable storage.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Uses LocalStorage in the browser and falls back to in-memory storage.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module storage</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">class VarStoragePolyfill {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.map = new Map()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">* @param {any} newValue</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setItem (key, newValue) {</span><span class="s3">\n    </span><span class="s1">this.map.set(key, newValue)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getItem (key) {</span><span class="s3">\n    </span><span class="s1">return this.map.get(key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {any}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let _localStorage = new VarStoragePolyfill()</span><span class="s3">\n</span><span class="s1">let usePolyfill = true</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n  </span><span class="s1">// if the same-origin rule is violated, accessing localStorage might thrown an error</span><span class="s3">\n  </span><span class="s1">if (typeof localStorage !== 'undefined') {</span><span class="s3">\n    </span><span class="s1">_localStorage = localStorage</span><span class="s3">\n    </span><span class="s1">usePolyfill = false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} catch (e) { }</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is basically localStorage in browser, or a polyfill in nodejs</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const varStorage = _localStorage</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A polyfill for `addEventListener('storage', event =&gt; {..})` that does nothing if the polyfill is being used.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const onChange = eventHandler =&gt; usePolyfill || addEventListener('storage', /** @type {any} */ (eventHandler))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A polyfill for `removeEventListener('storage', event =&gt; {..})` that does nothing if the polyfill is being used.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const offChange = eventHandler =&gt; usePolyfill || removeEventListener('storage', /** @type {any} */ (eventHandler))</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Isomorphic module to work access the environment (query params, env variables).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module map</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as map from './map.js'</span><span class="s3">\n</span><span class="s1">import * as string from './string.js'</span><span class="s3">\n</span><span class="s1">import * as conditions from './conditions.js'</span><span class="s3">\n</span><span class="s1">import * as storage from './storage.js'</span><span class="s3">\n</span><span class="s1">import * as f from './function.js'</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">export const isNode = typeof process !== 'undefined' &amp;&amp; process.release &amp;&amp;</span><span class="s3">\n  </span><span class="s1">/node|io</span><span class="s3">\\</span><span class="s1">.js/.test(process.release.name)</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const isBrowser = typeof window !== 'undefined' &amp;&amp; typeof document !== 'undefined' &amp;&amp; !isNode</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n</span><span class="s1">export const isMac = typeof navigator !== 'undefined'</span><span class="s3">\n  </span><span class="s1">? /Mac/.test(navigator.platform)</span><span class="s3">\n  </span><span class="s1">: false</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Map&lt;string,string&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let params</span><span class="s3">\n</span><span class="s1">const args = []</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const computeParams = () =&gt; {</span><span class="s3">\n  </span><span class="s1">if (params === undefined) {</span><span class="s3">\n    </span><span class="s1">if (isNode) {</span><span class="s3">\n      </span><span class="s1">params = map.create()</span><span class="s3">\n      </span><span class="s1">const pargs = process.argv</span><span class="s3">\n      </span><span class="s1">let currParamName = null</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; pargs.length; i++) {</span><span class="s3">\n        </span><span class="s1">const parg = pargs[i]</span><span class="s3">\n        </span><span class="s1">if (parg[0] === '-') {</span><span class="s3">\n          </span><span class="s1">if (currParamName !== null) {</span><span class="s3">\n            </span><span class="s1">params.set(currParamName, '')</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">currParamName = parg</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (currParamName !== null) {</span><span class="s3">\n            </span><span class="s1">params.set(currParamName, parg)</span><span class="s3">\n            </span><span class="s1">currParamName = null</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">args.push(parg)</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (currParamName !== null) {</span><span class="s3">\n        </span><span class="s1">params.set(currParamName, '')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// in ReactNative for example this would not be true (unless connected to the Remote Debugger)</span><span class="s3">\n    </span><span class="s1">} else if (typeof location === 'object') {</span><span class="s3">\n      </span><span class="s1">params = map.create(); // eslint-disable-next-line no-undef</span><span class="s3">\n      </span><span class="s1">(location.search || '?').slice(1).split('&amp;').forEach((kv) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (kv.length !== 0) {</span><span class="s3">\n          </span><span class="s1">const [key, value] = kv.split('=')</span><span class="s3">\n          </span><span class="s1">params.set(`--${string.fromCamelCase(key, '-')}`, value)</span><span class="s3">\n          </span><span class="s1">params.set(`-${string.fromCamelCase(key, '-')}`, value)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">params = map.create()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return params</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const hasParam = (name) =&gt; computeParams().has(name)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @param {string} defaultVal</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const getParam = (name, defaultVal) =&gt;</span><span class="s3">\n  </span><span class="s1">computeParams().get(name) || defaultVal</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @return {string|null}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 4 */</span><span class="s3">\n</span><span class="s1">export const getVariable = (name) =&gt;</span><span class="s3">\n  </span><span class="s1">isNode</span><span class="s3">\n    </span><span class="s1">? conditions.undefinedToNull(process.env[name.toUpperCase()])</span><span class="s3">\n    </span><span class="s1">: conditions.undefinedToNull(storage.varStorage.getItem(name))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @return {string|null}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const getConf = (name) =&gt;</span><span class="s3">\n  </span><span class="s1">computeParams().get('--' + name) || getVariable(name)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const hasConf = (name) =&gt;</span><span class="s3">\n  </span><span class="s1">hasParam('--' + name) || getVariable(name) !== null</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const production = hasConf('production')</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">const forceColor = isNode &amp;&amp;</span><span class="s3">\n  </span><span class="s1">f.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2'])</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">export const supportsColor = !hasParam('no-colors') &amp;&amp;</span><span class="s3">\n  </span><span class="s1">(!isNode || process.stdout.isTTY || forceColor) &amp;&amp; (</span><span class="s3">\n  </span><span class="s1">!isNode || hasParam('color') || forceColor ||</span><span class="s3">\n    </span><span class="s1">getVariable('COLORTERM') !== null ||</span><span class="s3">\n    </span><span class="s1">(getVariable('TERM') || '').includes('color')</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility functions to work with buffers (Uint8Array).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module buffer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as string from './string.js'</span><span class="s3">\n</span><span class="s1">import * as env from './environment.js'</span><span class="s3">\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as encoding from './encoding.js'</span><span class="s3">\n</span><span class="s1">import * as decoding from './decoding.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createUint8ArrayFromLen = len =&gt; new Uint8Array(len)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create Uint8Array with initial content from buffer</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ArrayBuffer} buffer</span><span class="s3">\n </span><span class="s1">* @param {number} byteOffset</span><span class="s3">\n </span><span class="s1">* @param {number} length</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) =&gt; new Uint8Array(buffer, byteOffset, length)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create Uint8Array with initial content from buffer</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ArrayBuffer} buffer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createUint8ArrayFromArrayBuffer = buffer =&gt; new Uint8Array(buffer)</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} bytes</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toBase64Browser = bytes =&gt; {</span><span class="s3">\n  </span><span class="s1">let s = ''</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; bytes.byteLength; i++) {</span><span class="s3">\n    </span><span class="s1">s += string.fromCharCode(bytes[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n  </span><span class="s1">return btoa(s)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} bytes</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toBase64Node = bytes =&gt; Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const fromBase64Browser = s =&gt; {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-undef</span><span class="s3">\n  </span><span class="s1">const a = atob(s)</span><span class="s3">\n  </span><span class="s1">const bytes = createUint8ArrayFromLen(a.length)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n    </span><span class="s1">bytes[i] = a.charCodeAt(i)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return bytes</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const fromBase64Node = s =&gt; {</span><span class="s3">\n  </span><span class="s1">const buf = Buffer.from(s, 'base64')</span><span class="s3">\n  </span><span class="s1">return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const toBase64UrlEncoded = buf =&gt; toBase64(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} base64</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fromBase64UrlEncoded = base64 =&gt; fromBase64(base64.replaceAll('-', '+').replaceAll('_', '/'))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Base64 is always a more efficient choice. This exists for utility purposes only.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const toHexString = buf =&gt; array.map(buf, b =&gt; b.toString(16).padStart(2, '0')).join('')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Note: This function expects that the hex doesn't start with 0x..</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {string} hex</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fromHexString = hex =&gt; {</span><span class="s3">\n  </span><span class="s1">const hlen = hex.length</span><span class="s3">\n  </span><span class="s1">const buf = new Uint8Array(math.ceil(hlen / 2))</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; hlen; i += 2) {</span><span class="s3">\n    </span><span class="s1">buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return buf</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copy the content of an Uint8Array view to a new ArrayBuffer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const copyUint8Array = uint8Array =&gt; {</span><span class="s3">\n  </span><span class="s1">const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)</span><span class="s3">\n  </span><span class="s1">newBuf.set(uint8Array)</span><span class="s3">\n  </span><span class="s1">return newBuf</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.</span><span class="s3">\n </span><span class="s1">* See encoding.writeAny for more information.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {any} data</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const encodeAny = data =&gt; {</span><span class="s3">\n  </span><span class="s1">const encoder = encoding.createEncoder()</span><span class="s3">\n  </span><span class="s1">encoding.writeAny(encoder, data)</span><span class="s3">\n  </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Decode an any-encoded value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @return {any}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const decodeAny = buf =&gt; decoding.readAny(decoding.createDecoder(buf))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shift Byte Array {N} bits to the left. Does not expand byte array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} bs</span><span class="s3">\n </span><span class="s1">* @param {number} N should be in the range of [0-7]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const shiftNBitsLeft = (bs, N) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (N === 0) return bs</span><span class="s3">\n  </span><span class="s1">bs = new Uint8Array(bs)</span><span class="s3">\n  </span><span class="s1">bs[0] &lt;&lt;= N</span><span class="s3">\n  </span><span class="s1">for (let i = 1; i &lt; bs.length; i++) {</span><span class="s3">\n    </span><span class="s1">bs[i - 1] |= bs[i] &gt;&gt;&gt; (8 - N)</span><span class="s3">\n    </span><span class="s1">bs[i] &lt;&lt;= N</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return bs</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-env browser */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Binary data constants.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module binary</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* n-th bit activated.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const BIT1 = 1</span><span class="s3">\n</span><span class="s1">export const BIT2 = 2</span><span class="s3">\n</span><span class="s1">export const BIT3 = 4</span><span class="s3">\n</span><span class="s1">export const BIT4 = 8</span><span class="s3">\n</span><span class="s1">export const BIT5 = 16</span><span class="s3">\n</span><span class="s1">export const BIT6 = 32</span><span class="s3">\n</span><span class="s1">export const BIT7 = 64</span><span class="s3">\n</span><span class="s1">export const BIT8 = 128</span><span class="s3">\n</span><span class="s1">export const BIT9 = 256</span><span class="s3">\n</span><span class="s1">export const BIT10 = 512</span><span class="s3">\n</span><span class="s1">export const BIT11 = 1024</span><span class="s3">\n</span><span class="s1">export const BIT12 = 2048</span><span class="s3">\n</span><span class="s1">export const BIT13 = 4096</span><span class="s3">\n</span><span class="s1">export const BIT14 = 8192</span><span class="s3">\n</span><span class="s1">export const BIT15 = 16384</span><span class="s3">\n</span><span class="s1">export const BIT16 = 32768</span><span class="s3">\n</span><span class="s1">export const BIT17 = 65536</span><span class="s3">\n</span><span class="s1">export const BIT18 = 1 &lt;&lt; 17</span><span class="s3">\n</span><span class="s1">export const BIT19 = 1 &lt;&lt; 18</span><span class="s3">\n</span><span class="s1">export const BIT20 = 1 &lt;&lt; 19</span><span class="s3">\n</span><span class="s1">export const BIT21 = 1 &lt;&lt; 20</span><span class="s3">\n</span><span class="s1">export const BIT22 = 1 &lt;&lt; 21</span><span class="s3">\n</span><span class="s1">export const BIT23 = 1 &lt;&lt; 22</span><span class="s3">\n</span><span class="s1">export const BIT24 = 1 &lt;&lt; 23</span><span class="s3">\n</span><span class="s1">export const BIT25 = 1 &lt;&lt; 24</span><span class="s3">\n</span><span class="s1">export const BIT26 = 1 &lt;&lt; 25</span><span class="s3">\n</span><span class="s1">export const BIT27 = 1 &lt;&lt; 26</span><span class="s3">\n</span><span class="s1">export const BIT28 = 1 &lt;&lt; 27</span><span class="s3">\n</span><span class="s1">export const BIT29 = 1 &lt;&lt; 28</span><span class="s3">\n</span><span class="s1">export const BIT30 = 1 &lt;&lt; 29</span><span class="s3">\n</span><span class="s1">export const BIT31 = 1 &lt;&lt; 30</span><span class="s3">\n</span><span class="s1">export const BIT32 = 1 &lt;&lt; 31</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* First n bits activated.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const BITS0 = 0</span><span class="s3">\n</span><span class="s1">export const BITS1 = 1</span><span class="s3">\n</span><span class="s1">export const BITS2 = 3</span><span class="s3">\n</span><span class="s1">export const BITS3 = 7</span><span class="s3">\n</span><span class="s1">export const BITS4 = 15</span><span class="s3">\n</span><span class="s1">export const BITS5 = 31</span><span class="s3">\n</span><span class="s1">export const BITS6 = 63</span><span class="s3">\n</span><span class="s1">export const BITS7 = 127</span><span class="s3">\n</span><span class="s1">export const BITS8 = 255</span><span class="s3">\n</span><span class="s1">export const BITS9 = 511</span><span class="s3">\n</span><span class="s1">export const BITS10 = 1023</span><span class="s3">\n</span><span class="s1">export const BITS11 = 2047</span><span class="s3">\n</span><span class="s1">export const BITS12 = 4095</span><span class="s3">\n</span><span class="s1">export const BITS13 = 8191</span><span class="s3">\n</span><span class="s1">export const BITS14 = 16383</span><span class="s3">\n</span><span class="s1">export const BITS15 = 32767</span><span class="s3">\n</span><span class="s1">export const BITS16 = 65535</span><span class="s3">\n</span><span class="s1">export const BITS17 = BIT18 - 1</span><span class="s3">\n</span><span class="s1">export const BITS18 = BIT19 - 1</span><span class="s3">\n</span><span class="s1">export const BITS19 = BIT20 - 1</span><span class="s3">\n</span><span class="s1">export const BITS20 = BIT21 - 1</span><span class="s3">\n</span><span class="s1">export const BITS21 = BIT22 - 1</span><span class="s3">\n</span><span class="s1">export const BITS22 = BIT23 - 1</span><span class="s3">\n</span><span class="s1">export const BITS23 = BIT24 - 1</span><span class="s3">\n</span><span class="s1">export const BITS24 = BIT25 - 1</span><span class="s3">\n</span><span class="s1">export const BITS25 = BIT26 - 1</span><span class="s3">\n</span><span class="s1">export const BITS26 = BIT27 - 1</span><span class="s3">\n</span><span class="s1">export const BITS27 = BIT28 - 1</span><span class="s3">\n</span><span class="s1">export const BITS28 = BIT29 - 1</span><span class="s3">\n</span><span class="s1">export const BITS29 = BIT30 - 1</span><span class="s3">\n</span><span class="s1">export const BITS30 = BIT31 - 1</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const BITS31 = 0x7FFFFFFF</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const BITS32 = 0xFFFFFFFF</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility helpers for working with numbers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module number</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as binary from './binary.js'</span><span class="s3">\n\n</span><span class="s1">export const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER</span><span class="s3">\n</span><span class="s1">export const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER</span><span class="s3">\n\n</span><span class="s1">export const LOWEST_INT32 = 1 &lt;&lt; 31</span><span class="s3">\n</span><span class="s1">export const HIGHEST_INT32 = binary.BITS31</span><span class="s3">\n</span><span class="s1">export const HIGHEST_UINT32 = binary.BITS32</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const isInteger = Number.isInteger || (num =&gt; typeof num === 'number' &amp;&amp; isFinite(num) &amp;&amp; math.floor(num) === num)</span><span class="s3">\n</span><span class="s1">export const isNaN = Number.isNaN</span><span class="s3">\n</span><span class="s1">export const parseInt = Number.parseInt</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Count the number of </span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">bits in an unsigned 32bit number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Super fun bitcount algorithm by Brian Kernighan.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} n</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const countBits = n =&gt; {</span><span class="s3">\n  </span><span class="s1">n &amp;= binary.BITS32</span><span class="s3">\n  </span><span class="s1">let count = 0</span><span class="s3">\n  </span><span class="s1">while (n) {</span><span class="s3">\n    </span><span class="s1">n &amp;= (n - 1)</span><span class="s3">\n    </span><span class="s1">count++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return count</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Efficient schema-less binary encoding with support for variable length encoding.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes numbers in little-endian order (least to most significant byte order)</span><span class="s3">\n </span><span class="s1">* and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)</span><span class="s3">\n </span><span class="s1">* which is also used in Protocol Buffers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* // encoding step</span><span class="s3">\n </span><span class="s1">* const encoder = encoding.createEncoder()</span><span class="s3">\n </span><span class="s1">* encoding.writeVarUint(encoder, 256)</span><span class="s3">\n </span><span class="s1">* encoding.writeVarString(encoder, 'Hello world!')</span><span class="s3">\n </span><span class="s1">* const buf = encoding.toUint8Array(encoder)</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* // decoding step</span><span class="s3">\n </span><span class="s1">* const decoder = decoding.createDecoder(buf)</span><span class="s3">\n </span><span class="s1">* decoding.readVarUint(decoder) // =&gt; 256</span><span class="s3">\n </span><span class="s1">* decoding.readVarString(decoder) // =&gt; 'Hello world!'</span><span class="s3">\n </span><span class="s1">* decoding.hasContent(decoder) // =&gt; false - all data is read</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module encoding</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as buffer from './buffer.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as number from './number.js'</span><span class="s3">\n</span><span class="s1">import * as binary from './binary.js'</span><span class="s3">\n</span><span class="s1">import * as string from './string.js'</span><span class="s3">\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A BinaryEncoder handles the encoding to an Uint8Array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Encoder {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.cpos = 0</span><span class="s3">\n    </span><span class="s1">this.cbuf = new Uint8Array(100)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;Uint8Array&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.bufs = []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @return {Encoder}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createEncoder = () =&gt; new Encoder()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {function(Encoder):void} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const encode = (f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const encoder = createEncoder()</span><span class="s3">\n  </span><span class="s1">f(encoder)</span><span class="s3">\n  </span><span class="s1">return toUint8Array(encoder)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The current length of the encoded data.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const length = encoder =&gt; {</span><span class="s3">\n  </span><span class="s1">let len = encoder.cpos</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; encoder.bufs.length; i++) {</span><span class="s3">\n    </span><span class="s1">len += encoder.bufs[i].length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return len</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check whether encoder is empty.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const hasContent = encoder =&gt; encoder.cpos &gt; 0 || encoder.bufs.length &gt; 0</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform to Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array} The created ArrayBuffer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const toUint8Array = encoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const uint8arr = new Uint8Array(length(encoder))</span><span class="s3">\n  </span><span class="s1">let curPos = 0</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; encoder.bufs.length; i++) {</span><span class="s3">\n    </span><span class="s1">const d = encoder.bufs[i]</span><span class="s3">\n    </span><span class="s1">uint8arr.set(d, curPos)</span><span class="s3">\n    </span><span class="s1">curPos += d.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)</span><span class="s3">\n  </span><span class="s1">return uint8arr</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Verify that it is possible to write `len` bytes wtihout checking. If</span><span class="s3">\n </span><span class="s1">* necessary, a new Buffer with the required length is attached.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const verifyLen = (encoder, len) =&gt; {</span><span class="s3">\n  </span><span class="s1">const bufferLen = encoder.cbuf.length</span><span class="s3">\n  </span><span class="s1">if (bufferLen - encoder.cpos &lt; len) {</span><span class="s3">\n    </span><span class="s1">encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))</span><span class="s3">\n    </span><span class="s1">encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)</span><span class="s3">\n    </span><span class="s1">encoder.cpos = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write one byte to the encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The byte that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const write = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">const bufferLen = encoder.cbuf.length</span><span class="s3">\n  </span><span class="s1">if (encoder.cpos === bufferLen) {</span><span class="s3">\n    </span><span class="s1">encoder.bufs.push(encoder.cbuf)</span><span class="s3">\n    </span><span class="s1">encoder.cbuf = new Uint8Array(bufferLen * 2)</span><span class="s3">\n    </span><span class="s1">encoder.cpos = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">encoder.cbuf[encoder.cpos++] = num</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write one byte at a specific position.</span><span class="s3">\n </span><span class="s1">* Position must already be written (i.e. encoder.length &gt; pos)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} pos Position to which to write data</span><span class="s3">\n </span><span class="s1">* @param {number} num Unsigned 8-bit integer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const set = (encoder, pos, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">let buffer = null</span><span class="s3">\n  </span><span class="s1">// iterate all buffers and adjust position</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; encoder.bufs.length &amp;&amp; buffer === null; i++) {</span><span class="s3">\n    </span><span class="s1">const b = encoder.bufs[i]</span><span class="s3">\n    </span><span class="s1">if (pos &lt; b.length) {</span><span class="s3">\n      </span><span class="s1">buffer = b // found buffer</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">pos -= b.length</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (buffer === null) {</span><span class="s3">\n    </span><span class="s1">// use current buffer</span><span class="s3">\n    </span><span class="s1">buffer = encoder.cbuf</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">buffer[pos] = num</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write one byte as an unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeUint8 = write</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write one byte as an unsigned Integer at a specific location.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} pos The location where the data will be written.</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setUint8 = set</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write two bytes as an unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeUint16 = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">write(encoder, num &amp; binary.BITS8)</span><span class="s3">\n  </span><span class="s1">write(encoder, (num &gt;&gt;&gt; 8) &amp; binary.BITS8)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write two bytes as an unsigned integer at a specific location.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} pos The location where the data will be written.</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setUint16 = (encoder, pos, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">set(encoder, pos, num &amp; binary.BITS8)</span><span class="s3">\n  </span><span class="s1">set(encoder, pos + 1, (num &gt;&gt;&gt; 8) &amp; binary.BITS8)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write two bytes as an unsigned integer</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeUint32 = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; 4; i++) {</span><span class="s3">\n    </span><span class="s1">write(encoder, num &amp; binary.BITS8)</span><span class="s3">\n    </span><span class="s1">num &gt;&gt;&gt;= 8</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write two bytes as an unsigned integer in big endian order.</span><span class="s3">\n </span><span class="s1">* (most significant byte first)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeUint32BigEndian = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 3; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">write(encoder, (num &gt;&gt;&gt; (8 * i)) &amp; binary.BITS8)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write two bytes as an unsigned integer at a specific location.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} pos The location where the data will be written.</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setUint32 = (encoder, pos, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; 4; i++) {</span><span class="s3">\n    </span><span class="s1">set(encoder, pos + i, num &amp; binary.BITS8)</span><span class="s3">\n    </span><span class="s1">num &gt;&gt;&gt;= 8</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a variable length unsigned integer. Max encodable integer is 2^53.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeVarUint = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">while (num &gt; binary.BITS7) {</span><span class="s3">\n    </span><span class="s1">write(encoder, binary.BIT8 | (binary.BITS7 &amp; num))</span><span class="s3">\n    </span><span class="s1">num = math.floor(num / 128) // shift &gt;&gt;&gt; 7</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">write(encoder, binary.BITS7 &amp; num)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a variable length integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* We use the 7th bit instead for signaling that this is a negative number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num The number that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeVarInt = (encoder, num) =&gt; {</span><span class="s3">\n  </span><span class="s1">const isNegative = math.isNegativeZero(num)</span><span class="s3">\n  </span><span class="s1">if (isNegative) {</span><span class="s3">\n    </span><span class="s1">num = -num</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//             |- whether to continue reading         |- whether is negative     |- number</span><span class="s3">\n  </span><span class="s1">write(encoder, (num &gt; binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 &amp; num))</span><span class="s3">\n  </span><span class="s1">num = math.floor(num / 64) // shift &gt;&gt;&gt; 6</span><span class="s3">\n  </span><span class="s1">// We don't need to consider the case of num === 0 so we can use a different</span><span class="s3">\n  </span><span class="s1">// pattern here than above.</span><span class="s3">\n  </span><span class="s1">while (num &gt; 0) {</span><span class="s3">\n    </span><span class="s1">write(encoder, (num &gt; binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 &amp; num))</span><span class="s3">\n    </span><span class="s1">num = math.floor(num / 128) // shift &gt;&gt;&gt; 7</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cache to store strings temporarily</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const _strBuffer = new Uint8Array(30000)</span><span class="s3">\n</span><span class="s1">const _maxStrBSize = _strBuffer.length / 3</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a variable length string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {String} str The string that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _writeVarStringNative = (encoder, str) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (str.length &lt; _maxStrBSize) {</span><span class="s3">\n    </span><span class="s1">// We can encode the string into the existing buffer</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">const written = string.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0</span><span class="s3">\n    </span><span class="s1">writeVarUint(encoder, written)</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; written; i++) {</span><span class="s3">\n      </span><span class="s1">write(encoder, _strBuffer[i])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">writeVarUint8Array(encoder, string.encodeUtf8(str))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a variable length string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {String} str The string that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _writeVarStringPolyfill = (encoder, str) =&gt; {</span><span class="s3">\n  </span><span class="s1">const encodedString = unescape(encodeURIComponent(str))</span><span class="s3">\n  </span><span class="s1">const len = encodedString.length</span><span class="s3">\n  </span><span class="s1">writeVarUint(encoder, len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a variable length string.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {String} str The string that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const writeVarString = (string.utf8TextEncoder &amp;&amp; /** @type {any} */ (string.utf8TextEncoder).encodeInto) ? _writeVarStringNative : _writeVarStringPolyfill</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a string terminated by a special byte sequence. This is not very performant and is</span><span class="s3">\n </span><span class="s1">* generally discouraged. However, the resulting byte arrays are lexiographically ordered which</span><span class="s3">\n </span><span class="s1">* makes this a nice feature for databases.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {String} str The string that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeTerminatedString = (encoder, str) =&gt;</span><span class="s3">\n  </span><span class="s1">writeTerminatedUint8Array(encoder, string.encodeUtf8(str))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write a terminating Uint8Array. Note that this is not performant and is generally</span><span class="s3">\n </span><span class="s1">* discouraged. There are few situations when this is needed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then</span><span class="s3">\n </span><span class="s1">* the result is terminated using the 0x0 character.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is basically how many systems implement null terminated strings. However, we use an escape</span><span class="s3">\n </span><span class="s1">* character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key</span><span class="s3">\n </span><span class="s1">* encoder for NoSql databases).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf The string that is to be encoded.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeTerminatedUint8Array = (encoder, buf) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; buf.length; i++) {</span><span class="s3">\n    </span><span class="s1">const b = buf[i]</span><span class="s3">\n    </span><span class="s1">if (b === 0 || b === 1) {</span><span class="s3">\n      </span><span class="s1">write(encoder, 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">write(encoder, buf[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">write(encoder, 0)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write the content of another Encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @TODO: can be improved!</span><span class="s3">\n </span><span class="s1">*        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.</span><span class="s3">\n </span><span class="s1">*                Encoders start with a rather big initial buffer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder The enUint8Arr</span><span class="s3">\n </span><span class="s1">* @param {Encoder} append The BinaryEncoder to be written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeBinaryEncoder = (encoder, append) =&gt; writeUint8Array(encoder, toUint8Array(append))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Append fixed-length Uint8Array to the encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeUint8Array = (encoder, uint8Array) =&gt; {</span><span class="s3">\n  </span><span class="s1">const bufferLen = encoder.cbuf.length</span><span class="s3">\n  </span><span class="s1">const cpos = encoder.cpos</span><span class="s3">\n  </span><span class="s1">const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)</span><span class="s3">\n  </span><span class="s1">const rightCopyLen = uint8Array.length - leftCopyLen</span><span class="s3">\n  </span><span class="s1">encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)</span><span class="s3">\n  </span><span class="s1">encoder.cpos += leftCopyLen</span><span class="s3">\n  </span><span class="s1">if (rightCopyLen &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// Still something to write, write right half..</span><span class="s3">\n    </span><span class="s1">// Append new buffer</span><span class="s3">\n    </span><span class="s1">encoder.bufs.push(encoder.cbuf)</span><span class="s3">\n    </span><span class="s1">// must have at least size of remaining buffer</span><span class="s3">\n    </span><span class="s1">encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))</span><span class="s3">\n    </span><span class="s1">// copy array</span><span class="s3">\n    </span><span class="s1">encoder.cbuf.set(uint8Array.subarray(leftCopyLen))</span><span class="s3">\n    </span><span class="s1">encoder.cpos = rightCopyLen</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Append an Uint8Array to Encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeVarUint8Array = (encoder, uint8Array) =&gt; {</span><span class="s3">\n  </span><span class="s1">writeVarUint(encoder, uint8Array.byteLength)</span><span class="s3">\n  </span><span class="s1">writeUint8Array(encoder, uint8Array)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create an DataView of the next `len` bytes. Use it to write data after</span><span class="s3">\n </span><span class="s1">* calling this function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* // write float32 using DataView</span><span class="s3">\n </span><span class="s1">* const dv = writeOnDataView(encoder, 4)</span><span class="s3">\n </span><span class="s1">* dv.setFloat32(0, 1.1)</span><span class="s3">\n </span><span class="s1">* // read float32 using DataView</span><span class="s3">\n </span><span class="s1">* const dv = readFromDataView(encoder, 4)</span><span class="s3">\n </span><span class="s1">* dv.getFloat32(0) // =&gt; 1.100000023841858 (leaving it to the reader to find out why this is the correct result)</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">* @return {DataView}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeOnDataView = (encoder, len) =&gt; {</span><span class="s3">\n  </span><span class="s1">verifyLen(encoder, len)</span><span class="s3">\n  </span><span class="s1">const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)</span><span class="s3">\n  </span><span class="s1">encoder.cpos += len</span><span class="s3">\n  </span><span class="s1">return dview</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeFloat32 = (encoder, num) =&gt; writeOnDataView(encoder, 4).setFloat32(0, num, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {number} num</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeFloat64 = (encoder, num) =&gt; writeOnDataView(encoder, 8).setFloat64(0, num, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {bigint} num</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeBigInt64 = (encoder, num) =&gt; /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {bigint} num</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeBigUint64 = (encoder, num) =&gt; /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num, false)</span><span class="s3">\n\n</span><span class="s1">const floatTestBed = new DataView(new ArrayBuffer(4))</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if a number can be encoded as a 32 bit float.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} num</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isFloat32 = num =&gt; {</span><span class="s3">\n  </span><span class="s1">floatTestBed.setFloat32(0, num)</span><span class="s3">\n  </span><span class="s1">return floatTestBed.getFloat32(0) === num</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encode data with efficient binary format.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Differences to JSON:</span><span class="s3">\n </span><span class="s1">*  Transforms data to a binary format (not to a string)</span><span class="s3">\n </span><span class="s1">*  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)</span><span class="s3">\n </span><span class="s1">*  Numbers are efficiently encoded either as a variable length integer, as a</span><span class="s3">\n </span><span class="s1">*   32 bit float, as a 64 bit float, or as a 64 bit bigint.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encoding table:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* | Data Type           | Prefix   | Encoding Method    | Comment |</span><span class="s3">\n </span><span class="s1">* | ------------------- | -------- | ------------------ | ------- |</span><span class="s3">\n </span><span class="s1">* | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |</span><span class="s3">\n </span><span class="s1">* | null                | 126      |                    | |</span><span class="s3">\n </span><span class="s1">* | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |</span><span class="s3">\n </span><span class="s1">* | float32             | 124      | writeFloat32       | |</span><span class="s3">\n </span><span class="s1">* | float64             | 123      | writeFloat64       | |</span><span class="s3">\n </span><span class="s1">* | bigint              | 122      | writeBigInt64      | |</span><span class="s3">\n </span><span class="s1">* | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |</span><span class="s3">\n </span><span class="s1">* | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |</span><span class="s3">\n </span><span class="s1">* | string              | 119      | writeVarString     | |</span><span class="s3">\n </span><span class="s1">* | object&lt;string,any&gt;  | 118      | custom             | Writes {length} then {length} key-value pairs |</span><span class="s3">\n </span><span class="s1">* | array&lt;any&gt;          | 117      | custom             | Writes {length} then {length} json values |</span><span class="s3">\n </span><span class="s1">* | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Reasons for the decreasing prefix:</span><span class="s3">\n </span><span class="s1">* We need the first bit for extendability (later we may want to encode the</span><span class="s3">\n </span><span class="s1">* prefix with writeVarUint). The remaining 7 bits are divided as follows:</span><span class="s3">\n </span><span class="s1">* [0-30]   the beginning of the data range is used for custom purposes</span><span class="s3">\n </span><span class="s1">*          (defined by the function that uses this library)</span><span class="s3">\n </span><span class="s1">* [31-127] the end of the data range is used for data encoding by</span><span class="s3">\n </span><span class="s1">*          lib0/encoding.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {undefined|null|number|bigint|boolean|string|Object&lt;string,any&gt;|Array&lt;any&gt;|Uint8Array} data</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const writeAny = (encoder, data) =&gt; {</span><span class="s3">\n  </span><span class="s1">switch (typeof data) {</span><span class="s3">\n    </span><span class="s1">case 'string':</span><span class="s3">\n      </span><span class="s1">// TYPE 119: STRING</span><span class="s3">\n      </span><span class="s1">write(encoder, 119)</span><span class="s3">\n      </span><span class="s1">writeVarString(encoder, data)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'number':</span><span class="s3">\n      </span><span class="s1">if (number.isInteger(data) &amp;&amp; math.abs(data) &lt;= binary.BITS31) {</span><span class="s3">\n        </span><span class="s1">// TYPE 125: INTEGER</span><span class="s3">\n        </span><span class="s1">write(encoder, 125)</span><span class="s3">\n        </span><span class="s1">writeVarInt(encoder, data)</span><span class="s3">\n      </span><span class="s1">} else if (isFloat32(data)) {</span><span class="s3">\n        </span><span class="s1">// TYPE 124: FLOAT32</span><span class="s3">\n        </span><span class="s1">write(encoder, 124)</span><span class="s3">\n        </span><span class="s1">writeFloat32(encoder, data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TYPE 123: FLOAT64</span><span class="s3">\n        </span><span class="s1">write(encoder, 123)</span><span class="s3">\n        </span><span class="s1">writeFloat64(encoder, data)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'bigint':</span><span class="s3">\n      </span><span class="s1">// TYPE 122: BigInt</span><span class="s3">\n      </span><span class="s1">write(encoder, 122)</span><span class="s3">\n      </span><span class="s1">writeBigInt64(encoder, data)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'object':</span><span class="s3">\n      </span><span class="s1">if (data === null) {</span><span class="s3">\n        </span><span class="s1">// TYPE 126: null</span><span class="s3">\n        </span><span class="s1">write(encoder, 126)</span><span class="s3">\n      </span><span class="s1">} else if (array.isArray(data)) {</span><span class="s3">\n        </span><span class="s1">// TYPE 117: Array</span><span class="s3">\n        </span><span class="s1">write(encoder, 117)</span><span class="s3">\n        </span><span class="s1">writeVarUint(encoder, data.length)</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; data.length; i++) {</span><span class="s3">\n          </span><span class="s1">writeAny(encoder, data[i])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (data instanceof Uint8Array) {</span><span class="s3">\n        </span><span class="s1">// TYPE 116: ArrayBuffer</span><span class="s3">\n        </span><span class="s1">write(encoder, 116)</span><span class="s3">\n        </span><span class="s1">writeVarUint8Array(encoder, data)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// TYPE 118: Object</span><span class="s3">\n        </span><span class="s1">write(encoder, 118)</span><span class="s3">\n        </span><span class="s1">const keys = Object.keys(data)</span><span class="s3">\n        </span><span class="s1">writeVarUint(encoder, keys.length)</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; keys.length; i++) {</span><span class="s3">\n          </span><span class="s1">const key = keys[i]</span><span class="s3">\n          </span><span class="s1">writeVarString(encoder, key)</span><span class="s3">\n          </span><span class="s1">writeAny(encoder, data[key])</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 'boolean':</span><span class="s3">\n      </span><span class="s1">// TYPE 120/121: boolean (true/false)</span><span class="s3">\n      </span><span class="s1">write(encoder, data ? 120 : 121)</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">// TYPE 127: undefined</span><span class="s3">\n      </span><span class="s1">write(encoder, 127)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Now come a few stateful encoder that have their own classes.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Basic Run Length Encoder - a basic compression implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @note T must not be null!</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RleEncoder extends Encoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {function(Encoder, T):void} writer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (writer) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The writer</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.w = writer</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {T|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = null</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {T} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">if (this.s === v) {</span><span class="s3">\n      </span><span class="s1">this.count++</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (this.count &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// flush counter, unless this is the first value (count = 0)</span><span class="s3">\n        </span><span class="s1">writeVarUint(this, this.count - 1) // since count is always &gt; 0, we can decrement by one. non-standard encoding ftw</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">// write first value</span><span class="s3">\n      </span><span class="s1">this.w(this, v)</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Basic diff decoder using variable length encoding.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class IntDiffEncoder extends Encoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} start</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (start) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = start</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">writeVarInt(this, v - this.s)</span><span class="s3">\n    </span><span class="s1">this.s = v</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A combination of IntDiffEncoder and RleEncoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RleIntDiffEncoder extends Encoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} start</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (start) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = start</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">if (this.s === v &amp;&amp; this.count &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.count++</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (this.count &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// flush counter, unless this is the first value (count = 0)</span><span class="s3">\n        </span><span class="s1">writeVarUint(this, this.count - 1) // since count is always &gt; 0, we can decrement by one. non-standard encoding ftw</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">// write first value</span><span class="s3">\n      </span><span class="s1">writeVarInt(this, v - this.s)</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UintOptRleEncoder} encoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const flushUintOptRleEncoder = encoder =&gt; {</span><span class="s3">\n  </span><span class="s1">if (encoder.count &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// flush counter, unless this is the first value (count = 0)</span><span class="s3">\n    </span><span class="s1">// case 1: just a single value. set sign to positive</span><span class="s3">\n    </span><span class="s1">// case 2: write several values. set sign to negative to indicate that there is a length coming</span><span class="s3">\n    </span><span class="s1">writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)</span><span class="s3">\n    </span><span class="s1">if (encoder.count &gt; 1) {</span><span class="s3">\n      </span><span class="s1">writeVarUint(encoder.encoder, encoder.count - 2) // since count is always &gt; 1, we can decrement by one. non-standard encoding ftw</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write</span><span class="s3">\n </span><span class="s1">* write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class UintOptRleEncoder {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.encoder = new Encoder()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">if (this.s === v) {</span><span class="s3">\n      </span><span class="s1">this.count++</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">flushUintOptRleEncoder(this)</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">flushUintOptRleEncoder(this)</span><span class="s3">\n    </span><span class="s1">return toUint8Array(this.encoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Increasing Uint Optimized RLE Encoder</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The RLE encoder counts the number of same occurences of the same value.</span><span class="s3">\n </span><span class="s1">* The IncUintOptRle encoder counts if the value increases.</span><span class="s3">\n </span><span class="s1">* I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded</span><span class="s3">\n </span><span class="s1">* as [1, 3, 5].</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class IncUintOptRleEncoder {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.encoder = new Encoder()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">if (this.s + this.count === v) {</span><span class="s3">\n      </span><span class="s1">this.count++</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">flushUintOptRleEncoder(this)</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">flushUintOptRleEncoder(this)</span><span class="s3">\n    </span><span class="s1">return toUint8Array(this.encoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {IntDiffOptRleEncoder} encoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const flushIntDiffOptRleEncoder = encoder =&gt; {</span><span class="s3">\n  </span><span class="s1">if (encoder.count &gt; 0) {</span><span class="s3">\n    </span><span class="s1">//          31 bit making up the diff | wether to write the counter</span><span class="s3">\n    </span><span class="s1">// const encodedDiff = encoder.diff &lt;&lt; 1 | (encoder.count === 1 ? 0 : 1)</span><span class="s3">\n    </span><span class="s1">const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1)</span><span class="s3">\n    </span><span class="s1">// flush counter, unless this is the first value (count = 0)</span><span class="s3">\n    </span><span class="s1">// case 1: just a single value. set first bit to positive</span><span class="s3">\n    </span><span class="s1">// case 2: write several values. set first bit to negative to indicate that there is a length coming</span><span class="s3">\n    </span><span class="s1">writeVarInt(encoder.encoder, encodedDiff)</span><span class="s3">\n    </span><span class="s1">if (encoder.count &gt; 1) {</span><span class="s3">\n      </span><span class="s1">writeVarUint(encoder.encoder, encoder.count - 2) // since count is always &gt; 1, we can decrement by one. non-standard encoding ftw</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A combination of the IntDiffEncoder and the UintOptRleEncoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes</span><span class="s3">\n </span><span class="s1">* in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 &lt;&lt; 1) | 1, (3 &lt;&lt; 0) | 0, -1])</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:</span><span class="s3">\n </span><span class="s1">* * 1 bit that denotes whether the next value is a count (LSB)</span><span class="s3">\n </span><span class="s1">* * 1 bit that denotes whether this value is negative (MSB - 1)</span><span class="s3">\n </span><span class="s1">* * 1 bit that denotes whether to continue reading the variable length integer (MSB)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Therefore, only five bits remain to encode diff ranges.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Use this Encoder only when appropriate. In most cases, this is probably a bad idea.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class IntDiffOptRleEncoder {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.encoder = new Encoder()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n    </span><span class="s1">this.diff = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} v</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (v) {</span><span class="s3">\n    </span><span class="s1">if (this.diff === v - this.s) {</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n      </span><span class="s1">this.count++</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">flushIntDiffOptRleEncoder(this)</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">this.diff = v - this.s</span><span class="s3">\n      </span><span class="s1">this.s = v</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">flushIntDiffOptRleEncoder(this)</span><span class="s3">\n    </span><span class="s1">return toUint8Array(this.encoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Optimized String Encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.</span><span class="s3">\n </span><span class="s1">* In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The lengths are encoded using a UintOptRleEncoder.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class StringEncoder {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;string&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.sarr = []</span><span class="s3">\n    </span><span class="s1">this.s = ''</span><span class="s3">\n    </span><span class="s1">this.lensE = new UintOptRleEncoder()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} string</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (string) {</span><span class="s3">\n    </span><span class="s1">this.s += string</span><span class="s3">\n    </span><span class="s1">if (this.s.length &gt; 19) {</span><span class="s3">\n      </span><span class="s1">this.sarr.push(this.s)</span><span class="s3">\n      </span><span class="s1">this.s = ''</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.lensE.write(string.length)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">const encoder = new Encoder()</span><span class="s3">\n    </span><span class="s1">this.sarr.push(this.s)</span><span class="s3">\n    </span><span class="s1">this.s = ''</span><span class="s3">\n    </span><span class="s1">writeVarString(encoder, this.sarr.join(''))</span><span class="s3">\n    </span><span class="s1">writeUint8Array(encoder, this.lensE.toUint8Array())</span><span class="s3">\n    </span><span class="s1">return toUint8Array(encoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Error helpers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module error</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} s</span><span class="s3">\n </span><span class="s1">* @return {Error}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const create = s =&gt; new Error(s)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @throws {Error}</span><span class="s3">\n </span><span class="s1">* @return {never}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n</span><span class="s1">export const methodUnimplemented = () =&gt; {</span><span class="s3">\n  </span><span class="s1">throw create('Method unimplemented')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @throws {Error}</span><span class="s3">\n </span><span class="s1">* @return {never}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 3 */</span><span class="s3">\n</span><span class="s1">export const unexpectedCase = () =&gt; {</span><span class="s3">\n  </span><span class="s1">throw create('Unexpected case')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Efficient schema-less binary decoding with support for variable length encoding.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Encodes numbers in little-endian order (least to most significant byte order)</span><span class="s3">\n </span><span class="s1">* and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)</span><span class="s3">\n </span><span class="s1">* which is also used in Protocol Buffers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* // encoding step</span><span class="s3">\n </span><span class="s1">* const encoder = encoding.createEncoder()</span><span class="s3">\n </span><span class="s1">* encoding.writeVarUint(encoder, 256)</span><span class="s3">\n </span><span class="s1">* encoding.writeVarString(encoder, 'Hello world!')</span><span class="s3">\n </span><span class="s1">* const buf = encoding.toUint8Array(encoder)</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* // decoding step</span><span class="s3">\n </span><span class="s1">* const decoder = decoding.createDecoder(buf)</span><span class="s3">\n </span><span class="s1">* decoding.readVarUint(decoder) // =&gt; 256</span><span class="s3">\n </span><span class="s1">* decoding.readVarString(decoder) // =&gt; 'Hello world!'</span><span class="s3">\n </span><span class="s1">* decoding.hasContent(decoder) // =&gt; false - all data is read</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module decoding</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as buffer from './buffer.js'</span><span class="s3">\n</span><span class="s1">import * as binary from './binary.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as number from './number.js'</span><span class="s3">\n</span><span class="s1">import * as string from './string.js'</span><span class="s3">\n</span><span class="s1">import * as error from './error.js'</span><span class="s3">\n</span><span class="s1">import * as encoding from './encoding.js'</span><span class="s3">\n\n</span><span class="s1">const errorUnexpectedEndOfArray = error.create('Unexpected end of array')</span><span class="s3">\n</span><span class="s1">const errorIntegerOutOfRange = error.create('Integer out of Range')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A Decoder handles the decoding of an Uint8Array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array Binary data to decode</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Decoding target.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {Uint8Array}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.arr = uint8Array</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current decoding position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.pos = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n </span><span class="s1">* @return {Decoder}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createDecoder = uint8Array =&gt; new Decoder(uint8Array)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const hasContent = decoder =&gt; decoder.pos !== decoder.arr.length</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Clone a decoder instance.</span><span class="s3">\n </span><span class="s1">* Optionally set a new position parameter.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder The decoder instance</span><span class="s3">\n </span><span class="s1">* @param {number} [newPos] Defaults to current position</span><span class="s3">\n </span><span class="s1">* @return {Decoder} A clone of `decoder`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const clone = (decoder, newPos = decoder.pos) =&gt; {</span><span class="s3">\n  </span><span class="s1">const _decoder = createDecoder(decoder.arr)</span><span class="s3">\n  </span><span class="s1">_decoder.pos = newPos</span><span class="s3">\n  </span><span class="s1">return _decoder</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create an Uint8Array view of the next `len` bytes and advance the position by `len`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.</span><span class="s3">\n </span><span class="s1">*            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder The decoder instance</span><span class="s3">\n </span><span class="s1">* @param {number} len The length of bytes to read</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readUint8Array = (decoder, len) =&gt; {</span><span class="s3">\n  </span><span class="s1">const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)</span><span class="s3">\n  </span><span class="s1">decoder.pos += len</span><span class="s3">\n  </span><span class="s1">return view</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read variable length Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.</span><span class="s3">\n </span><span class="s1">*            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readVarUint8Array = decoder =&gt; readUint8Array(decoder, readVarUint(decoder))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read the rest of the content as an ArrayBuffer</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readTailAsUint8Array = decoder =&gt; readUint8Array(decoder, decoder.arr.length - decoder.pos)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Skip one byte, jump to the next position.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder The decoder instance</span><span class="s3">\n </span><span class="s1">* @return {number} The next position</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const skip8 = decoder =&gt; decoder.pos++</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read one byte as unsigned integer.</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder The decoder instance</span><span class="s3">\n </span><span class="s1">* @return {number} Unsigned 8-bit integer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readUint8 = decoder =&gt; decoder.arr[decoder.pos++]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read 2 bytes as unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readUint16 = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const uint =</span><span class="s3">\n    </span><span class="s1">decoder.arr[decoder.pos] +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 1] &lt;&lt; 8)</span><span class="s3">\n  </span><span class="s1">decoder.pos += 2</span><span class="s3">\n  </span><span class="s1">return uint</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read 4 bytes as unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readUint32 = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const uint =</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos] +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 1] &lt;&lt; 8) +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 2] &lt;&lt; 16) +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 3] &lt;&lt; 24)) &gt;&gt;&gt; 0</span><span class="s3">\n  </span><span class="s1">decoder.pos += 4</span><span class="s3">\n  </span><span class="s1">return uint</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read 4 bytes as unsigned integer in big endian order.</span><span class="s3">\n </span><span class="s1">* (most significant byte first)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readUint32BigEndian = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const uint =</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 3] +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 2] &lt;&lt; 8) +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos + 1] &lt;&lt; 16) +</span><span class="s3">\n    </span><span class="s1">(decoder.arr[decoder.pos] &lt;&lt; 24)) &gt;&gt;&gt; 0</span><span class="s3">\n  </span><span class="s1">decoder.pos += 4</span><span class="s3">\n  </span><span class="s1">return uint</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead without incrementing the position</span><span class="s3">\n </span><span class="s1">* to the next byte and read it as unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekUint8 = decoder =&gt; decoder.arr[decoder.pos]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead without incrementing the position</span><span class="s3">\n </span><span class="s1">* to the next byte and read it as unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekUint16 = decoder =&gt;</span><span class="s3">\n  </span><span class="s1">decoder.arr[decoder.pos] +</span><span class="s3">\n  </span><span class="s1">(decoder.arr[decoder.pos + 1] &lt;&lt; 8)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead without incrementing the position</span><span class="s3">\n </span><span class="s1">* to the next byte and read it as unsigned integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekUint32 = decoder =&gt; (</span><span class="s3">\n  </span><span class="s1">decoder.arr[decoder.pos] +</span><span class="s3">\n  </span><span class="s1">(decoder.arr[decoder.pos + 1] &lt;&lt; 8) +</span><span class="s3">\n  </span><span class="s1">(decoder.arr[decoder.pos + 2] &lt;&lt; 16) +</span><span class="s3">\n  </span><span class="s1">(decoder.arr[decoder.pos + 3] &lt;&lt; 24)</span><span class="s3">\n</span><span class="s1">) &gt;&gt;&gt; 0</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read unsigned integer (32bit) with variable length.</span><span class="s3">\n </span><span class="s1">* 1/8th of the storage is used as encoding overhead.</span><span class="s3">\n </span><span class="s1">*  * numbers &lt; 2^7 is stored in one bytlength</span><span class="s3">\n </span><span class="s1">*  * numbers &lt; 2^14 is stored in two bylength</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.length</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readVarUint = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">let num = 0</span><span class="s3">\n  </span><span class="s1">let mult = 1</span><span class="s3">\n  </span><span class="s1">const len = decoder.arr.length</span><span class="s3">\n  </span><span class="s1">while (decoder.pos &lt; len) {</span><span class="s3">\n    </span><span class="s1">const r = decoder.arr[decoder.pos++]</span><span class="s3">\n    </span><span class="s1">// num = num | ((r &amp; binary.BITS7) &lt;&lt; len)</span><span class="s3">\n    </span><span class="s1">num = num + (r &amp; binary.BITS7) * mult // shift $r &lt;&lt; (7*#iterations) and add it to num</span><span class="s3">\n    </span><span class="s1">mult *= 128 // next iteration, shift 7 </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot; </span><span class="s1">to the left</span><span class="s3">\n    </span><span class="s1">if (r &lt; binary.BIT8) {</span><span class="s3">\n      </span><span class="s1">return num</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (num &gt; number.MAX_SAFE_INTEGER) {</span><span class="s3">\n      </span><span class="s1">throw errorIntegerOutOfRange</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw errorUnexpectedEndOfArray</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read signed integer (32bit) with variable length.</span><span class="s3">\n </span><span class="s1">* 1/8th of the storage is used as encoding overhead.</span><span class="s3">\n </span><span class="s1">*  * numbers &lt; 2^7 is stored in one bytlength</span><span class="s3">\n </span><span class="s1">*  * numbers &lt; 2^14 is stored in two bylength</span><span class="s3">\n </span><span class="s1">* @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number} An unsigned integer.length</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readVarInt = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">let r = decoder.arr[decoder.pos++]</span><span class="s3">\n  </span><span class="s1">let num = r &amp; binary.BITS6</span><span class="s3">\n  </span><span class="s1">let mult = 64</span><span class="s3">\n  </span><span class="s1">const sign = (r &amp; binary.BIT7) &gt; 0 ? -1 : 1</span><span class="s3">\n  </span><span class="s1">if ((r &amp; binary.BIT8) === 0) {</span><span class="s3">\n    </span><span class="s1">// don't continue reading</span><span class="s3">\n    </span><span class="s1">return sign * num</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const len = decoder.arr.length</span><span class="s3">\n  </span><span class="s1">while (decoder.pos &lt; len) {</span><span class="s3">\n    </span><span class="s1">r = decoder.arr[decoder.pos++]</span><span class="s3">\n    </span><span class="s1">// num = num | ((r &amp; binary.BITS7) &lt;&lt; len)</span><span class="s3">\n    </span><span class="s1">num = num + (r &amp; binary.BITS7) * mult</span><span class="s3">\n    </span><span class="s1">mult *= 128</span><span class="s3">\n    </span><span class="s1">if (r &lt; binary.BIT8) {</span><span class="s3">\n      </span><span class="s1">return sign * num</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore start */</span><span class="s3">\n    </span><span class="s1">if (num &gt; number.MAX_SAFE_INTEGER) {</span><span class="s3">\n      </span><span class="s1">throw errorIntegerOutOfRange</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw errorUnexpectedEndOfArray</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead and read varUint without incrementing position</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekVarUint = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const pos = decoder.pos</span><span class="s3">\n  </span><span class="s1">const s = readVarUint(decoder)</span><span class="s3">\n  </span><span class="s1">decoder.pos = pos</span><span class="s3">\n  </span><span class="s1">return s</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead and read varUint without incrementing position</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekVarInt = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const pos = decoder.pos</span><span class="s3">\n  </span><span class="s1">const s = readVarInt(decoder)</span><span class="s3">\n  </span><span class="s1">decoder.pos = pos</span><span class="s3">\n  </span><span class="s1">return s</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We don't test this function anymore as we use native decoding/encoding by default now.</span><span class="s3">\n </span><span class="s1">* Better not modify this anymore..</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Transforming utf8 to a string is pretty expensive. The code performs 10x better</span><span class="s3">\n </span><span class="s1">* when String.fromCodePoint is fed with all characters as arguments.</span><span class="s3">\n </span><span class="s1">* But most environments have a maximum number of arguments per functions.</span><span class="s3">\n </span><span class="s1">* For effiency reasons we apply a maximum of 10000 characters at once.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {String} The read String.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">export const _readVarStringPolyfill = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">let remainingLen = readVarUint(decoder)</span><span class="s3">\n  </span><span class="s1">if (remainingLen === 0) {</span><span class="s3">\n    </span><span class="s1">return ''</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen</span><span class="s3">\n    </span><span class="s1">if (--remainingLen &lt; 100) { // do not create a Uint8Array for small strings</span><span class="s3">\n      </span><span class="s1">while (remainingLen--) {</span><span class="s3">\n        </span><span class="s1">encodedString += String.fromCodePoint(readUint8(decoder))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">while (remainingLen &gt; 0) {</span><span class="s3">\n        </span><span class="s1">const nextLen = remainingLen &lt; 10000 ? remainingLen : 10000</span><span class="s3">\n        </span><span class="s1">// this is dangerous, we create a fresh array view from the existing buffer</span><span class="s3">\n        </span><span class="s1">const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)</span><span class="s3">\n        </span><span class="s1">decoder.pos += nextLen</span><span class="s3">\n        </span><span class="s1">// Starting with ES5.1 we can supply a generic array-like object as arguments</span><span class="s3">\n        </span><span class="s1">encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))</span><span class="s3">\n        </span><span class="s1">remainingLen -= nextLen</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return decodeURIComponent(escape(encodedString))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {String} The read String</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const _readVarStringNative = decoder =&gt;</span><span class="s3">\n  </span><span class="s1">/** @type any */ (string.utf8TextDecoder).decode(readVarUint8Array(decoder))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read string of variable length</span><span class="s3">\n </span><span class="s1">* * varUint is used to store the length of the string</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {String} The read String</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const readVarString = string.utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readTerminatedUint8Array = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const encoder = encoding.createEncoder()</span><span class="s3">\n  </span><span class="s1">let b</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">b = readUint8(decoder)</span><span class="s3">\n    </span><span class="s1">if (b === 0) {</span><span class="s3">\n      </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (b === 1) {</span><span class="s3">\n      </span><span class="s1">b = readUint8(decoder)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">encoding.write(encoder, b)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readTerminatedString = decoder =&gt; string.decodeUtf8(readTerminatedUint8Array(decoder))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Look ahead and read varString without incrementing position</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const peekVarString = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const pos = decoder.pos</span><span class="s3">\n  </span><span class="s1">const s = readVarString(decoder)</span><span class="s3">\n  </span><span class="s1">decoder.pos = pos</span><span class="s3">\n  </span><span class="s1">return s</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">* @return {DataView}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readFromDataView = (decoder, len) =&gt; {</span><span class="s3">\n  </span><span class="s1">const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)</span><span class="s3">\n  </span><span class="s1">decoder.pos += len</span><span class="s3">\n  </span><span class="s1">return dv</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readFloat32 = decoder =&gt; readFromDataView(decoder, 4).getFloat32(0, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readFloat64 = decoder =&gt; readFromDataView(decoder, 8).getFloat64(0, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readBigInt64 = decoder =&gt; /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readBigUint64 = decoder =&gt; /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0, false)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Array&lt;function(Decoder):any&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readAnyLookupTable = [</span><span class="s3">\n  </span><span class="s1">decoder =&gt; undefined, // CASE 127: undefined</span><span class="s3">\n  </span><span class="s1">decoder =&gt; null, // CASE 126: null</span><span class="s3">\n  </span><span class="s1">readVarInt, // CASE 125: integer</span><span class="s3">\n  </span><span class="s1">readFloat32, // CASE 124: float32</span><span class="s3">\n  </span><span class="s1">readFloat64, // CASE 123: float64</span><span class="s3">\n  </span><span class="s1">readBigInt64, // CASE 122: bigint</span><span class="s3">\n  </span><span class="s1">decoder =&gt; false, // CASE 121: boolean (false)</span><span class="s3">\n  </span><span class="s1">decoder =&gt; true, // CASE 120: boolean (true)</span><span class="s3">\n  </span><span class="s1">readVarString, // CASE 119: string</span><span class="s3">\n  </span><span class="s1">decoder =&gt; { // CASE 118: object&lt;string,any&gt;</span><span class="s3">\n    </span><span class="s1">const len = readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const obj = {}</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const key = readVarString(decoder)</span><span class="s3">\n      </span><span class="s1">obj[key] = readAny(decoder)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return obj</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">decoder =&gt; { // CASE 117: array&lt;any&gt;</span><span class="s3">\n    </span><span class="s1">const len = readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">const arr = []</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">arr.push(readAny(decoder))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return arr</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">readVarUint8Array // CASE 116: Uint8Array</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Decoder} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const readAny = decoder =&gt; readAnyLookupTable[127 - readUint8(decoder)](decoder)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* T must not be null.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class RleDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">* @param {function(Decoder):T} reader</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array, reader) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The reader</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.reader = reader</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {T|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = null</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.s = this.reader(this)</span><span class="s3">\n      </span><span class="s1">if (hasContent(this)) {</span><span class="s3">\n        </span><span class="s1">this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.count = -1 // read the current value forever</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">return /** @type {T} */ (this.s)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IntDiffDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">* @param {number} start</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array, start) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = start</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">this.s += readVarInt(this)</span><span class="s3">\n    </span><span class="s1">return this.s</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class RleIntDiffDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">* @param {number} start</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array, start) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Current state</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = start</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.s += readVarInt(this)</span><span class="s3">\n      </span><span class="s1">if (hasContent(this)) {</span><span class="s3">\n        </span><span class="s1">this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.count = -1 // read the current value forever</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">return /** @type {number} */ (this.s)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class UintOptRleDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.s = readVarInt(this)</span><span class="s3">\n      </span><span class="s1">// if the sign is negative, we read the count too, otherwise count is 1</span><span class="s3">\n      </span><span class="s1">const isNegative = math.isNegativeZero(this.s)</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">if (isNegative) {</span><span class="s3">\n        </span><span class="s1">this.s = -this.s</span><span class="s3">\n        </span><span class="s1">this.count = readVarUint(this) + 2</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">return /** @type {number} */ (this.s)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IncUintOptRleDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">this.s = readVarInt(this)</span><span class="s3">\n      </span><span class="s1">// if the sign is negative, we read the count too, otherwise count is 1</span><span class="s3">\n      </span><span class="s1">const isNegative = math.isNegativeZero(this.s)</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">if (isNegative) {</span><span class="s3">\n        </span><span class="s1">this.s = -this.s</span><span class="s3">\n        </span><span class="s1">this.count = readVarUint(this) + 2</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">return /** @type {number} */ (this.s++)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class IntDiffOptRleDecoder extends Decoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array) {</span><span class="s3">\n    </span><span class="s1">super(uint8Array)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.s = 0</span><span class="s3">\n    </span><span class="s1">this.count = 0</span><span class="s3">\n    </span><span class="s1">this.diff = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">if (this.count === 0) {</span><span class="s3">\n      </span><span class="s1">const diff = readVarInt(this)</span><span class="s3">\n      </span><span class="s1">// if the first bit is set, we read more data</span><span class="s3">\n      </span><span class="s1">const hasCount = diff &amp; 1</span><span class="s3">\n      </span><span class="s1">this.diff = math.floor(diff / 2) // shift &gt;&gt; 1</span><span class="s3">\n      </span><span class="s1">this.count = 1</span><span class="s3">\n      </span><span class="s1">if (hasCount) {</span><span class="s3">\n        </span><span class="s1">this.count = readVarUint(this) + 2</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.s += this.diff</span><span class="s3">\n    </span><span class="s1">this.count--</span><span class="s3">\n    </span><span class="s1">return this.s</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export class StringDecoder {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (uint8Array) {</span><span class="s3">\n    </span><span class="s1">this.decoder = new UintOptRleDecoder(uint8Array)</span><span class="s3">\n    </span><span class="s1">this.str = readVarString(this.decoder)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.spos = 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">read () {</span><span class="s3">\n    </span><span class="s1">const end = this.spos + this.decoder.read()</span><span class="s3">\n    </span><span class="s1">const res = this.str.slice(this.spos, end)</span><span class="s3">\n    </span><span class="s1">this.spos = end</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-env browser */</span><span class="s3">\n\n</span><span class="s1">export const subtle = crypto.subtle</span><span class="s3">\n</span><span class="s1">export const getRandomValues = crypto.getRandomValues.bind(crypto)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Isomorphic module for true random numbers / buffers / uuids.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Attention: falls back to Math.random if the browser does not support crypto.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module random</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as binary from './binary.js'</span><span class="s3">\n</span><span class="s1">import { getRandomValues } from 'lib0/webcrypto'</span><span class="s3">\n\n</span><span class="s1">export const rand = Math.random</span><span class="s3">\n\n</span><span class="s1">export const uint32 = () =&gt; getRandomValues(new Uint32Array(1))[0]</span><span class="s3">\n\n</span><span class="s1">export const uint53 = () =&gt; {</span><span class="s3">\n  </span><span class="s1">const arr = getRandomValues(new Uint32Array(8))</span><span class="s3">\n  </span><span class="s1">return (arr[0] &amp; binary.BITS21) * (binary.BITS32 + 1) + (arr[1] &gt;&gt;&gt; 0)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const oneOf = arr =&gt; arr[math.floor(rand() * arr.length)]</span><span class="s3">\n\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">const uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const uuidv4 = () =&gt; uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =&gt;</span><span class="s3">\n  </span><span class="s1">(c ^ uint32() &amp; 15 &gt;&gt; c / 4).toString(16)</span><span class="s3">\n</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility helpers to work with promises.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module promise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as time from './time.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @callback PromiseResolve</span><span class="s3">\n </span><span class="s1">* @param {T|PromiseLike&lt;T&gt;} [result]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {function(PromiseResolve&lt;T&gt;,function(Error):void):any} f</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = f =&gt; /** @type {Promise&lt;T&gt;} */ (new Promise(f))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {function(function():void,function(Error):void):void} f</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;void&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createEmpty = f =&gt; new Promise(f)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* `Promise.all` wait for all promises in the array to resolve and return the result</span><span class="s3">\n </span><span class="s1">* @template {unknown[] | []} PS</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {PS} ps</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;{ -readonly [P in keyof PS]: Awaited&lt;PS[P]&gt; }&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const all = Promise.all.bind(Promise)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Error} [reason]</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;never&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const reject = reason =&gt; Promise.reject(reason)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {T|void} res</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;T|void&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const resolve = res =&gt; Promise.resolve(res)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {T} res</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const resolveWith = res =&gt; Promise.resolve(res)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} timeout</span><span class="s3">\n </span><span class="s1">* @param {function():boolean} check</span><span class="s3">\n </span><span class="s1">* @param {number} [intervalResolution]</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;void&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const until = (timeout, check, intervalResolution = 10) =&gt; create((resolve, reject) =&gt; {</span><span class="s3">\n  </span><span class="s1">const startTime = time.getUnixTime()</span><span class="s3">\n  </span><span class="s1">const hasTimeout = timeout &gt; 0</span><span class="s3">\n  </span><span class="s1">const untilInterval = () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (check()) {</span><span class="s3">\n      </span><span class="s1">clearInterval(intervalHandle)</span><span class="s3">\n      </span><span class="s1">resolve()</span><span class="s3">\n    </span><span class="s1">} else if (hasTimeout) {</span><span class="s3">\n      </span><span class="s1">/* c8 ignore else */</span><span class="s3">\n      </span><span class="s1">if (time.getUnixTime() - startTime &gt; timeout) {</span><span class="s3">\n        </span><span class="s1">clearInterval(intervalHandle)</span><span class="s3">\n        </span><span class="s1">reject(new Error('Timeout'))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const intervalHandle = setInterval(untilInterval, intervalResolution)</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} timeout</span><span class="s3">\n </span><span class="s1">* @return {Promise&lt;undefined&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const wait = timeout =&gt; create((resolve, reject) =&gt; setTimeout(resolve, timeout))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if an object is a promise using ducktyping.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this</span><span class="s3">\n </span><span class="s1">* library has some insane environment where global Promise objects are overwritten.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {any} p</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isPromise = p =&gt; p instanceof Promise || (p &amp;&amp; p.then &amp;&amp; p.catch &amp;&amp; p.finally)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Working with value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module pair</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template L,R</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Pair {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {L} left</span><span class="s3">\n   </span><span class="s1">* @param {R} right</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (left, right) {</span><span class="s3">\n    </span><span class="s1">this.left = left</span><span class="s3">\n    </span><span class="s1">this.right = right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template L,R</span><span class="s3">\n </span><span class="s1">* @param {L} left</span><span class="s3">\n </span><span class="s1">* @param {R} right</span><span class="s3">\n </span><span class="s1">* @return {Pair&lt;L,R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = (left, right) =&gt; new Pair(left, right)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template L,R</span><span class="s3">\n </span><span class="s1">* @param {R} right</span><span class="s3">\n </span><span class="s1">* @param {L} left</span><span class="s3">\n </span><span class="s1">* @return {Pair&lt;L,R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createReversed = (right, left) =&gt; new Pair(left, right)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template L,R</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Pair&lt;L,R&gt;&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {function(L, R):any} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const forEach = (arr, f) =&gt; arr.forEach(p =&gt; f(p.left, p.right))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template L,R,X</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Pair&lt;L,R&gt;&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {function(L, R):X} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;X&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (arr, f) =&gt; arr.map(p =&gt; f(p.left, p.right))</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* eslint-env browser */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with the DOM.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module dom</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as pair from './pair.js'</span><span class="s3">\n</span><span class="s1">import * as map from './map.js'</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Document}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createElement = name =&gt; doc.createElement(name)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @return {DocumentFragment}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createDocumentFragment = () =&gt; doc.createDocumentFragment()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} text</span><span class="s3">\n </span><span class="s1">* @return {Text}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createTextNode = text =&gt; doc.createTextNode(text)</span><span class="s3">\n\n</span><span class="s1">export const domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} el</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @param {Object} opts</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const emitCustomEvent = (el, name, opts) =&gt; el.dispatchEvent(new CustomEvent(name, opts))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Element} el</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;pair.Pair&lt;string,string|boolean&gt;&gt;} attrs Array of key-value pairs</span><span class="s3">\n </span><span class="s1">* @return {Element}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setAttributes = (el, attrs) =&gt; {</span><span class="s3">\n  </span><span class="s1">pair.forEach(attrs, (key, value) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (value === false) {</span><span class="s3">\n      </span><span class="s1">el.removeAttribute(key)</span><span class="s3">\n    </span><span class="s1">} else if (value === true) {</span><span class="s3">\n      </span><span class="s1">el.setAttribute(key, '')</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore</span><span class="s3">\n      </span><span class="s1">el.setAttribute(key, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">return el</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Element} el</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string, string&gt;} attrs Array of key-value pairs</span><span class="s3">\n </span><span class="s1">* @return {Element}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setAttributesMap = (el, attrs) =&gt; {</span><span class="s3">\n  </span><span class="s1">attrs.forEach((value, key) =&gt; { el.setAttribute(key, value) })</span><span class="s3">\n  </span><span class="s1">return el</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Node&gt;|HTMLCollection} children</span><span class="s3">\n </span><span class="s1">* @return {DocumentFragment}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fragment = children =&gt; {</span><span class="s3">\n  </span><span class="s1">const fragment = createDocumentFragment()</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">appendChild(fragment, children[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return fragment</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Element} parent</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Node&gt;} nodes</span><span class="s3">\n </span><span class="s1">* @return {Element}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const append = (parent, nodes) =&gt; {</span><span class="s3">\n  </span><span class="s1">appendChild(parent, fragment(nodes))</span><span class="s3">\n  </span><span class="s1">return parent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} el</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const remove = el =&gt; el.remove()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {EventTarget} el</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @param {EventListener} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const addEventListener = (el, name, f) =&gt; el.addEventListener(name, f)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {EventTarget} el</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @param {EventListener} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const removeEventListener = (el, name, f) =&gt; el.removeEventListener(name, f)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Node} node</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;pair.Pair&lt;string,EventListener&gt;&gt;} listeners</span><span class="s3">\n </span><span class="s1">* @return {Node}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const addEventListeners = (node, listeners) =&gt; {</span><span class="s3">\n  </span><span class="s1">pair.forEach(listeners, (name, f) =&gt; addEventListener(node, name, f))</span><span class="s3">\n  </span><span class="s1">return node</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Node} node</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;pair.Pair&lt;string,EventListener&gt;&gt;} listeners</span><span class="s3">\n </span><span class="s1">* @return {Node}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const removeEventListeners = (node, listeners) =&gt; {</span><span class="s3">\n  </span><span class="s1">pair.forEach(listeners, (name, f) =&gt; removeEventListener(node, name, f))</span><span class="s3">\n  </span><span class="s1">return node</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} name</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;pair.Pair&lt;string,string&gt;|pair.Pair&lt;string,boolean&gt;&gt;} attrs Array of key-value pairs</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Node&gt;} children</span><span class="s3">\n </span><span class="s1">* @return {Element}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const element = (name, attrs = [], children = []) =&gt;</span><span class="s3">\n  </span><span class="s1">append(setAttributes(createElement(name), attrs), children)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} width</span><span class="s3">\n </span><span class="s1">* @param {number} height</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const canvas = (width, height) =&gt; {</span><span class="s3">\n  </span><span class="s1">const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))</span><span class="s3">\n  </span><span class="s1">c.height = height</span><span class="s3">\n  </span><span class="s1">c.width = width</span><span class="s3">\n  </span><span class="s1">return c</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} t</span><span class="s3">\n </span><span class="s1">* @return {Text}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const text = createTextNode</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {pair.Pair&lt;string,string&gt;} pair</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const pairToStyleString = pair =&gt; `${pair.left}:${pair.right};`</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;pair.Pair&lt;string,string&gt;&gt;} pairs</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const pairsToStyleString = pairs =&gt; pairs.map(pairToStyleString).join('')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,string&gt;} m</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const mapToStyleString = m =&gt; map.map(m, (value, key) =&gt; `${key}:${value};`).join('')</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo should always query on a dom element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement|ShadowRoot} el</span><span class="s3">\n </span><span class="s1">* @param {string} query</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement | null}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const querySelector = (el, query) =&gt; el.querySelector(query)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement|ShadowRoot} el</span><span class="s3">\n </span><span class="s1">* @param {string} query</span><span class="s3">\n </span><span class="s1">* @return {NodeListOf&lt;HTMLElement&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const querySelectorAll = (el, query) =&gt; el.querySelectorAll(query)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} id</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const getElementById = id =&gt; /** @type {HTMLElement} */ (doc.getElementById(id))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} html</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const _parse = html =&gt; domParser.parseFromString(`&lt;html&gt;&lt;body&gt;${html}&lt;/body&gt;&lt;/html&gt;`, 'text/html').body</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} html</span><span class="s3">\n </span><span class="s1">* @return {DocumentFragment}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const parseFragment = html =&gt; fragment(/** @type {any} */ (_parse(html).childNodes))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} html</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const parseElement = html =&gt; /** @type HTMLElement */ (_parse(html).firstElementChild)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} oldEl</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement|DocumentFragment} newEl</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const replaceWith = (oldEl, newEl) =&gt; oldEl.replaceWith(newEl)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} parent</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} el</span><span class="s3">\n </span><span class="s1">* @param {Node|null} ref</span><span class="s3">\n </span><span class="s1">* @return {HTMLElement}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const insertBefore = (parent, el, ref) =&gt; parent.insertBefore(el, ref)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Node} parent</span><span class="s3">\n </span><span class="s1">* @param {Node} child</span><span class="s3">\n </span><span class="s1">* @return {Node}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const appendChild = (parent, child) =&gt; parent.appendChild(child)</span><span class="s3">\n\n</span><span class="s1">export const ELEMENT_NODE = doc.ELEMENT_NODE</span><span class="s3">\n</span><span class="s1">export const TEXT_NODE = doc.TEXT_NODE</span><span class="s3">\n</span><span class="s1">export const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE</span><span class="s3">\n</span><span class="s1">export const COMMENT_NODE = doc.COMMENT_NODE</span><span class="s3">\n</span><span class="s1">export const DOCUMENT_NODE = doc.DOCUMENT_NODE</span><span class="s3">\n</span><span class="s1">export const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE</span><span class="s3">\n</span><span class="s1">export const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} node</span><span class="s3">\n </span><span class="s1">* @param {number} type</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const checkNodeType = (node, type) =&gt; node.nodeType === type</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Node} parent</span><span class="s3">\n </span><span class="s1">* @param {HTMLElement} child</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isParentOf = (parent, child) =&gt; {</span><span class="s3">\n  </span><span class="s1">let p = child.parentNode</span><span class="s3">\n  </span><span class="s1">while (p &amp;&amp; p !== parent) {</span><span class="s3">\n    </span><span class="s1">p = p.parentNode</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return p === parent</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with EcmaScript Symbols.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module symbol</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return fresh symbol.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {Symbol}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = Symbol</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} s</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isSymbol = s =&gt; typeof s === 'symbol'</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import * as symbol from './symbol.js'</span><span class="s3">\n</span><span class="s1">import * as time from './time.js'</span><span class="s3">\n</span><span class="s1">import * as env from './environment.js'</span><span class="s3">\n</span><span class="s1">import * as func from './function.js'</span><span class="s3">\n\n</span><span class="s1">export const BOLD = symbol.create()</span><span class="s3">\n</span><span class="s1">export const UNBOLD = symbol.create()</span><span class="s3">\n</span><span class="s1">export const BLUE = symbol.create()</span><span class="s3">\n</span><span class="s1">export const GREY = symbol.create()</span><span class="s3">\n</span><span class="s1">export const GREEN = symbol.create()</span><span class="s3">\n</span><span class="s1">export const RED = symbol.create()</span><span class="s3">\n</span><span class="s1">export const PURPLE = symbol.create()</span><span class="s3">\n</span><span class="s1">export const ORANGE = symbol.create()</span><span class="s3">\n</span><span class="s1">export const UNCOLOR = symbol.create()</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;string|object|number&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const computeNoColorLoggingArgs = args =&gt; {</span><span class="s3">\n  </span><span class="s1">const strBuilder = []</span><span class="s3">\n  </span><span class="s1">const logArgs = []</span><span class="s3">\n  </span><span class="s1">// try with formatting until we find something unsupported</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">for (; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">const arg = args[i]</span><span class="s3">\n    </span><span class="s1">if (arg.constructor === String || arg.constructor === Number) {</span><span class="s3">\n      </span><span class="s1">strBuilder.push(arg)</span><span class="s3">\n    </span><span class="s1">} else if (arg.constructor === Object) {</span><span class="s3">\n      </span><span class="s1">logArgs.push(JSON.stringify(arg))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return logArgs</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">const loggingColors = [GREEN, PURPLE, ORANGE, BLUE]</span><span class="s3">\n</span><span class="s1">let nextColor = 0</span><span class="s3">\n</span><span class="s1">let lastLoggingTime = time.getUnixTime()</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {function(...any):void} _print</span><span class="s3">\n </span><span class="s1">* @param {string} moduleName</span><span class="s3">\n </span><span class="s1">* @return {function(...any):void}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createModuleLogger = (_print, moduleName) =&gt; {</span><span class="s3">\n  </span><span class="s1">const color = loggingColors[nextColor]</span><span class="s3">\n  </span><span class="s1">const debugRegexVar = env.getVariable('log')</span><span class="s3">\n  </span><span class="s1">const doLogging = debugRegexVar !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(debugRegexVar === '*' || debugRegexVar === 'true' ||</span><span class="s3">\n      </span><span class="s1">new RegExp(debugRegexVar, 'gi').test(moduleName))</span><span class="s3">\n  </span><span class="s1">nextColor = (nextColor + 1) % loggingColors.length</span><span class="s3">\n  </span><span class="s1">moduleName += ': '</span><span class="s3">\n  </span><span class="s1">return !doLogging</span><span class="s3">\n    </span><span class="s1">? func.nop</span><span class="s3">\n    </span><span class="s1">: (...args) =&gt; {</span><span class="s3">\n        </span><span class="s1">const timeNow = time.getUnixTime()</span><span class="s3">\n        </span><span class="s1">const timeDiff = timeNow - lastLoggingTime</span><span class="s3">\n        </span><span class="s1">lastLoggingTime = timeNow</span><span class="s3">\n        </span><span class="s1">_print(</span><span class="s3">\n          </span><span class="s1">color,</span><span class="s3">\n          </span><span class="s1">moduleName,</span><span class="s3">\n          </span><span class="s1">UNCOLOR,</span><span class="s3">\n          </span><span class="s1">...args.map((arg) =&gt;</span><span class="s3">\n            </span><span class="s1">(typeof arg === 'string' || typeof arg === 'symbol')</span><span class="s3">\n              </span><span class="s1">? arg</span><span class="s3">\n              </span><span class="s1">: JSON.stringify(arg)</span><span class="s3">\n          </span><span class="s1">),</span><span class="s3">\n          </span><span class="s1">color,</span><span class="s3">\n          </span><span class="s1">' +' + timeDiff + 'ms'</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Isomorphic logging module with support for colors!</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module logging</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as env from './environment.js'</span><span class="s3">\n</span><span class="s1">import * as set from './set.js'</span><span class="s3">\n</span><span class="s1">import * as pair from './pair.js'</span><span class="s3">\n</span><span class="s1">import * as dom from './dom.js'</span><span class="s3">\n</span><span class="s1">import * as json from './json.js'</span><span class="s3">\n</span><span class="s1">import * as map from './map.js'</span><span class="s3">\n</span><span class="s1">import * as eventloop from './eventloop.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n</span><span class="s1">import * as common from './logging.common.js'</span><span class="s3">\n\n</span><span class="s1">export { BOLD, UNBOLD, BLUE, GREY, GREEN, RED, PURPLE, ORANGE, UNCOLOR } from './logging.common.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Object&lt;Symbol,pair.Pair&lt;string,string&gt;&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const _browserStyleMap = {</span><span class="s3">\n  </span><span class="s1">[common.BOLD]: pair.create('font-weight', 'bold'),</span><span class="s3">\n  </span><span class="s1">[common.UNBOLD]: pair.create('font-weight', 'normal'),</span><span class="s3">\n  </span><span class="s1">[common.BLUE]: pair.create('color', 'blue'),</span><span class="s3">\n  </span><span class="s1">[common.GREEN]: pair.create('color', 'green'),</span><span class="s3">\n  </span><span class="s1">[common.GREY]: pair.create('color', 'grey'),</span><span class="s3">\n  </span><span class="s1">[common.RED]: pair.create('color', 'red'),</span><span class="s3">\n  </span><span class="s1">[common.PURPLE]: pair.create('color', 'purple'),</span><span class="s3">\n  </span><span class="s1">[common.ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate</span><span class="s3">\n  </span><span class="s1">[common.UNCOLOR]: pair.create('color', 'black')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;string|object|number&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const computeBrowserLoggingArgs = (args) =&gt; {</span><span class="s3">\n  </span><span class="s1">const strBuilder = []</span><span class="s3">\n  </span><span class="s1">const styles = []</span><span class="s3">\n  </span><span class="s1">const currentStyle = map.create()</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;string|Object|number&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let logArgs = []</span><span class="s3">\n  </span><span class="s1">// try with formatting until we find something unsupported</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">for (; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">const arg = args[i]</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">const style = _browserStyleMap[arg]</span><span class="s3">\n    </span><span class="s1">if (style !== undefined) {</span><span class="s3">\n      </span><span class="s1">currentStyle.set(style.left, style.right)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (arg.constructor === String || arg.constructor === Number) {</span><span class="s3">\n        </span><span class="s1">const style = dom.mapToStyleString(currentStyle)</span><span class="s3">\n        </span><span class="s1">if (i &gt; 0 || style.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">strBuilder.push('%c' + arg)</span><span class="s3">\n          </span><span class="s1">styles.push(style)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">strBuilder.push(arg)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (i &gt; 0) {</span><span class="s3">\n    </span><span class="s1">// create logArgs with what we have so far</span><span class="s3">\n    </span><span class="s1">logArgs = styles</span><span class="s3">\n    </span><span class="s1">logArgs.unshift(strBuilder.join(''))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// append the rest</span><span class="s3">\n  </span><span class="s1">for (; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">const arg = args[i]</span><span class="s3">\n    </span><span class="s1">if (!(arg instanceof Symbol)) {</span><span class="s3">\n      </span><span class="s1">logArgs.push(arg)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return logArgs</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const computeLoggingArgs = env.supportsColor</span><span class="s3">\n  </span><span class="s1">? computeBrowserLoggingArgs</span><span class="s3">\n  </span><span class="s1">: common.computeNoColorLoggingArgs</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const print = (...args) =&gt; {</span><span class="s3">\n  </span><span class="s1">console.log(...computeLoggingArgs(args))</span><span class="s3">\n  </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.print(args))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const warn = (...args) =&gt; {</span><span class="s3">\n  </span><span class="s1">console.warn(...computeLoggingArgs(args))</span><span class="s3">\n  </span><span class="s1">args.unshift(common.ORANGE)</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.print(args))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Error} err</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">export const printError = (err) =&gt; {</span><span class="s3">\n  </span><span class="s1">console.error(err)</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.printError(err))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} url image location</span><span class="s3">\n </span><span class="s1">* @param {number} height height of the image in pixel</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">export const printImg = (url, height) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (env.isBrowser) {</span><span class="s3">\n    </span><span class="s1">console.log(</span><span class="s3">\n      </span><span class="s1">'%c                      ',</span><span class="s3">\n      </span><span class="s1">`font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">// console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.printImg(url, height))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} base64</span><span class="s3">\n </span><span class="s1">* @param {number} height</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const printImgBase64 = (base64, height) =&gt;</span><span class="s3">\n  </span><span class="s1">printImg(`data:image/gif;base64,${base64}`, height)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const group = (...args) =&gt; {</span><span class="s3">\n  </span><span class="s1">console.group(...computeLoggingArgs(args))</span><span class="s3">\n  </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.group(args))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const groupCollapsed = (...args) =&gt; {</span><span class="s3">\n  </span><span class="s1">console.groupCollapsed(...computeLoggingArgs(args))</span><span class="s3">\n  </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.groupCollapsed(args))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const groupEnd = () =&gt; {</span><span class="s3">\n  </span><span class="s1">console.groupEnd()</span><span class="s3">\n  </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.groupEnd())</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {function():Node} createNode</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const printDom = (createNode) =&gt;</span><span class="s3">\n  </span><span class="s1">vconsoles.forEach((vc) =&gt; vc.printDom(createNode()))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {HTMLCanvasElement} canvas</span><span class="s3">\n </span><span class="s1">* @param {number} height</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next 2 */</span><span class="s3">\n</span><span class="s1">export const printCanvas = (canvas, height) =&gt;</span><span class="s3">\n  </span><span class="s1">printImg(canvas.toDataURL(), height)</span><span class="s3">\n\n</span><span class="s1">export const vconsoles = set.create()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;Element&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">const _computeLineSpans = (args) =&gt; {</span><span class="s3">\n  </span><span class="s1">const spans = []</span><span class="s3">\n  </span><span class="s1">const currentStyle = new Map()</span><span class="s3">\n  </span><span class="s1">// try with formatting until we find something unsupported</span><span class="s3">\n  </span><span class="s1">let i = 0</span><span class="s3">\n  </span><span class="s1">for (; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">const arg = args[i]</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">const style = _browserStyleMap[arg]</span><span class="s3">\n    </span><span class="s1">if (style !== undefined) {</span><span class="s3">\n      </span><span class="s1">currentStyle.set(style.left, style.right)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (arg.constructor === String || arg.constructor === Number) {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">const span = dom.element('span', [</span><span class="s3">\n          </span><span class="s1">pair.create('style', dom.mapToStyleString(currentStyle))</span><span class="s3">\n        </span><span class="s1">], [dom.text(arg.toString())])</span><span class="s3">\n        </span><span class="s1">if (span.innerHTML === '') {</span><span class="s3">\n          </span><span class="s1">span.innerHTML = '&amp;nbsp;'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">spans.push(span)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// append the rest</span><span class="s3">\n  </span><span class="s1">for (; i &lt; args.length; i++) {</span><span class="s3">\n    </span><span class="s1">let content = args[i]</span><span class="s3">\n    </span><span class="s1">if (!(content instanceof Symbol)) {</span><span class="s3">\n      </span><span class="s1">if (content.constructor !== String &amp;&amp; content.constructor !== Number) {</span><span class="s3">\n        </span><span class="s1">content = ' ' + json.stringify(content) + ' '</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">spans.push(</span><span class="s3">\n        </span><span class="s1">dom.element('span', [], [dom.text(/** @type {string} */ (content))])</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return spans</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">const lineStyle =</span><span class="s3">\n  </span><span class="s1">'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">export class VConsole {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Element} dom</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (dom) {</span><span class="s3">\n    </span><span class="s1">this.dom = dom</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Element}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.ccontainer = this.dom</span><span class="s3">\n    </span><span class="s1">this.depth = 0</span><span class="s3">\n    </span><span class="s1">vconsoles.add(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n   </span><span class="s1">* @param {boolean} collapsed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">group (args, collapsed = false) {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const triangleDown = dom.element('span', [</span><span class="s3">\n        </span><span class="s1">pair.create('hidden', collapsed),</span><span class="s3">\n        </span><span class="s1">pair.create('style', 'color:grey;font-size:120%;')</span><span class="s3">\n      </span><span class="s1">], [dom.text('')])</span><span class="s3">\n      </span><span class="s1">const triangleRight = dom.element('span', [</span><span class="s3">\n        </span><span class="s1">pair.create('hidden', !collapsed),</span><span class="s3">\n        </span><span class="s1">pair.create('style', 'color:grey;font-size:125%;')</span><span class="s3">\n      </span><span class="s1">], [dom.text('')])</span><span class="s3">\n      </span><span class="s1">const content = dom.element(</span><span class="s3">\n        </span><span class="s1">'div',</span><span class="s3">\n        </span><span class="s1">[pair.create(</span><span class="s3">\n          </span><span class="s1">'style',</span><span class="s3">\n          </span><span class="s1">`${lineStyle};padding-left:${this.depth * 10}px`</span><span class="s3">\n        </span><span class="s1">)],</span><span class="s3">\n        </span><span class="s1">[triangleDown, triangleRight, dom.text(' ')].concat(</span><span class="s3">\n          </span><span class="s1">_computeLineSpans(args)</span><span class="s3">\n        </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">const nextContainer = dom.element('div', [</span><span class="s3">\n        </span><span class="s1">pair.create('hidden', collapsed)</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n      </span><span class="s1">const nextLine = dom.element('div', [], [content, nextContainer])</span><span class="s3">\n      </span><span class="s1">dom.append(this.ccontainer, [nextLine])</span><span class="s3">\n      </span><span class="s1">this.ccontainer = nextContainer</span><span class="s3">\n      </span><span class="s1">this.depth++</span><span class="s3">\n      </span><span class="s1">// when header is clicked, collapse/uncollapse container</span><span class="s3">\n      </span><span class="s1">dom.addEventListener(content, 'click', (_event) =&gt; {</span><span class="s3">\n        </span><span class="s1">nextContainer.toggleAttribute('hidden')</span><span class="s3">\n        </span><span class="s1">triangleDown.toggleAttribute('hidden')</span><span class="s3">\n        </span><span class="s1">triangleRight.toggleAttribute('hidden')</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">groupCollapsed (args) {</span><span class="s3">\n    </span><span class="s1">this.group(args, true)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">groupEnd () {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">if (this.depth &gt; 0) {</span><span class="s3">\n        </span><span class="s1">this.depth--</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">this.ccontainer = this.ccontainer.parentElement.parentElement</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;string|Symbol|Object|number&gt;} args</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">print (args) {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dom.append(this.ccontainer, [</span><span class="s3">\n        </span><span class="s1">dom.element('div', [</span><span class="s3">\n          </span><span class="s1">pair.create(</span><span class="s3">\n            </span><span class="s1">'style',</span><span class="s3">\n            </span><span class="s1">`${lineStyle};padding-left:${this.depth * 10}px`</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">], _computeLineSpans(args))</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Error} err</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">printError (err) {</span><span class="s3">\n    </span><span class="s1">this.print([common.RED, common.BOLD, err.toString()])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} url</span><span class="s3">\n   </span><span class="s1">* @param {number} height</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">printImg (url, height) {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dom.append(this.ccontainer, [</span><span class="s3">\n        </span><span class="s1">dom.element('img', [</span><span class="s3">\n          </span><span class="s1">pair.create('src', url),</span><span class="s3">\n          </span><span class="s1">pair.create('height', `${math.round(height * 1.5)}px`)</span><span class="s3">\n        </span><span class="s1">])</span><span class="s3">\n      </span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Node} node</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">printDom (node) {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">dom.append(this.ccontainer, [node])</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">eventloop.enqueue(() =&gt; {</span><span class="s3">\n      </span><span class="s1">vconsoles.delete(this)</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Element} dom</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/* c8 ignore next */</span><span class="s3">\n</span><span class="s1">export const createVConsole = (dom) =&gt; new VConsole(dom)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} moduleName</span><span class="s3">\n </span><span class="s1">* @return {function(...any):void}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createModuleLogger = (moduleName) =&gt; common.createModuleLogger(print, moduleName)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to create and manipulate Iterators.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module iterator</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T,R</span><span class="s3">\n </span><span class="s1">* @param {Iterator&lt;T&gt;} iterator</span><span class="s3">\n </span><span class="s1">* @param {function(T):R} f</span><span class="s3">\n </span><span class="s1">* @return {IterableIterator&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const mapIterator = (iterator, f) =&gt; ({</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">next () {</span><span class="s3">\n    </span><span class="s1">const r = iterator.next()</span><span class="s3">\n    </span><span class="s1">return { value: r.done ? undefined : f(r.value), done: r.done }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {function():IteratorResult&lt;T&gt;} next</span><span class="s3">\n </span><span class="s1">* @return {IterableIterator&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createIterator = next =&gt; ({</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">next</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Iterator&lt;T&gt;} iterator</span><span class="s3">\n </span><span class="s1">* @param {function(T):boolean} filter</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const iteratorFilter = (iterator, filter) =&gt; createIterator(() =&gt; {</span><span class="s3">\n  </span><span class="s1">let res</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">res = iterator.next()</span><span class="s3">\n  </span><span class="s1">} while (!res.done &amp;&amp; !filter(res.value))</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T,M</span><span class="s3">\n </span><span class="s1">* @param {Iterator&lt;T&gt;} iterator</span><span class="s3">\n </span><span class="s1">* @param {function(T):M} fmap</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const iteratorMap = (iterator, fmap) =&gt; createIterator(() =&gt; {</span><span class="s3">\n  </span><span class="s1">const { done, value } = iterator.next()</span><span class="s3">\n  </span><span class="s1">return { done, value: done ? undefined : fmap(value) }</span><span class="s3">\n</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { Observable } from 'lib0/observable';</span><span class="s3">\n</span><span class="s1">import * as array from 'lib0/array';</span><span class="s3">\n</span><span class="s1">import * as math from 'lib0/math';</span><span class="s3">\n</span><span class="s1">import * as map from 'lib0/map';</span><span class="s3">\n</span><span class="s1">import * as encoding from 'lib0/encoding';</span><span class="s3">\n</span><span class="s1">import * as decoding from 'lib0/decoding';</span><span class="s3">\n</span><span class="s1">import * as random from 'lib0/random';</span><span class="s3">\n</span><span class="s1">import * as promise from 'lib0/promise';</span><span class="s3">\n</span><span class="s1">import * as buffer from 'lib0/buffer';</span><span class="s3">\n</span><span class="s1">import * as error from 'lib0/error';</span><span class="s3">\n</span><span class="s1">import * as binary from 'lib0/binary';</span><span class="s3">\n</span><span class="s1">import * as f from 'lib0/function';</span><span class="s3">\n</span><span class="s1">import { callAll } from 'lib0/function';</span><span class="s3">\n</span><span class="s1">import * as set from 'lib0/set';</span><span class="s3">\n</span><span class="s1">import * as logging from 'lib0/logging';</span><span class="s3">\n</span><span class="s1">import * as time from 'lib0/time';</span><span class="s3">\n</span><span class="s1">import * as string from 'lib0/string';</span><span class="s3">\n</span><span class="s1">import * as iterator from 'lib0/iterator';</span><span class="s3">\n</span><span class="s1">import * as object from 'lib0/object';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is an abstract interface that all Connectors should implement to keep them interchangeable.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @note This interface is experimental and it is not advised to actually inherit this class.</span><span class="s3">\n </span><span class="s1">*       It just serves as typing information.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends {Observable&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AbstractConnector extends Observable {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} ydoc</span><span class="s3">\n   </span><span class="s1">* @param {any} awareness</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (ydoc, awareness) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">this.doc = ydoc;</span><span class="s3">\n    </span><span class="s1">this.awareness = awareness;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DeleteItem {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} clock</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (clock, len) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clock = clock;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.len = len;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.</span><span class="s3">\n </span><span class="s1">* - When created in a transaction, it must only be accessed after sorting, and merging</span><span class="s3">\n </span><span class="s1">*   - This DeleteSet is send to other clients</span><span class="s3">\n </span><span class="s1">* - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore</span><span class="s3">\n </span><span class="s1">* - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DeleteSet {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number,Array&lt;DeleteItem&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clients = new Map();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterate over all structs that the DeleteSet gc's.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {function(GC|Item):void} f</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const iterateDeletedStructs = (transaction, ds, f) =&gt;</span><span class="s3">\n  </span><span class="s1">ds.clients.forEach((deletes, clientid) =&gt; {</span><span class="s3">\n    </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (transaction.doc.store.clients.get(clientid));</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; deletes.length; i++) {</span><span class="s3">\n      </span><span class="s1">const del = deletes[i];</span><span class="s3">\n      </span><span class="s1">iterateStructs(transaction, structs, del.clock, del.len, f);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;DeleteItem&gt;} dis</span><span class="s3">\n </span><span class="s1">* @param {number} clock</span><span class="s3">\n </span><span class="s1">* @return {number|null}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findIndexDS = (dis, clock) =&gt; {</span><span class="s3">\n  </span><span class="s1">let left = 0;</span><span class="s3">\n  </span><span class="s1">let right = dis.length - 1;</span><span class="s3">\n  </span><span class="s1">while (left &lt;= right) {</span><span class="s3">\n    </span><span class="s1">const midindex = math.floor((left + right) / 2);</span><span class="s3">\n    </span><span class="s1">const mid = dis[midindex];</span><span class="s3">\n    </span><span class="s1">const midclock = mid.clock;</span><span class="s3">\n    </span><span class="s1">if (midclock &lt;= clock) {</span><span class="s3">\n      </span><span class="s1">if (clock &lt; midclock + mid.len) {</span><span class="s3">\n        </span><span class="s1">return midindex</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">left = midindex + 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">right = midindex - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isDeleted = (ds, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">const dis = ds.clients.get(id.client);</span><span class="s3">\n  </span><span class="s1">return dis !== undefined &amp;&amp; findIndexDS(dis, id.clock) !== null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const sortAndMergeDeleteSet = ds =&gt; {</span><span class="s3">\n  </span><span class="s1">ds.clients.forEach(dels =&gt; {</span><span class="s3">\n    </span><span class="s1">dels.sort((a, b) =&gt; a.clock - b.clock);</span><span class="s3">\n    </span><span class="s1">// merge items without filtering or splicing the array</span><span class="s3">\n    </span><span class="s1">// i is the current pointer</span><span class="s3">\n    </span><span class="s1">// j refers to the current insert position for the pointed item</span><span class="s3">\n    </span><span class="s1">// try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]</span><span class="s3">\n    </span><span class="s1">let i, j;</span><span class="s3">\n    </span><span class="s1">for (i = 1, j = 1; i &lt; dels.length; i++) {</span><span class="s3">\n      </span><span class="s1">const left = dels[j - 1];</span><span class="s3">\n      </span><span class="s1">const right = dels[i];</span><span class="s3">\n      </span><span class="s1">if (left.clock + left.len &gt;= right.clock) {</span><span class="s3">\n        </span><span class="s1">left.len = math.max(left.len, right.clock + right.len - left.clock);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (j &lt; i) {</span><span class="s3">\n          </span><span class="s1">dels[j] = right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">j++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dels.length = j;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;DeleteSet&gt;} dss</span><span class="s3">\n </span><span class="s1">* @return {DeleteSet} A fresh DeleteSet</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const mergeDeleteSets = dss =&gt; {</span><span class="s3">\n  </span><span class="s1">const merged = new DeleteSet();</span><span class="s3">\n  </span><span class="s1">for (let dssI = 0; dssI &lt; dss.length; dssI++) {</span><span class="s3">\n    </span><span class="s1">dss[dssI].clients.forEach((delsLeft, client) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!merged.clients.has(client)) {</span><span class="s3">\n        </span><span class="s1">// Write all missing keys from current ds and all following.</span><span class="s3">\n        </span><span class="s1">// If merged already contains `client` current ds has already been added.</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Array&lt;DeleteItem&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const dels = delsLeft.slice();</span><span class="s3">\n        </span><span class="s1">for (let i = dssI + 1; i &lt; dss.length; i++) {</span><span class="s3">\n          </span><span class="s1">array.appendTo(dels, dss[i].clients.get(client) || []);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">merged.clients.set(client, dels);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">sortAndMergeDeleteSet(merged);</span><span class="s3">\n  </span><span class="s1">return merged</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {number} client</span><span class="s3">\n </span><span class="s1">* @param {number} clock</span><span class="s3">\n </span><span class="s1">* @param {number} length</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const addToDeleteSet = (ds, client, clock, length) =&gt; {</span><span class="s3">\n  </span><span class="s1">map.setIfUndefined(ds.clients, client, () =&gt; /** @type {Array&lt;DeleteItem&gt;} */ ([])).push(new DeleteItem(clock, length));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const createDeleteSet = () =&gt; new DeleteSet();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {StructStore} ss</span><span class="s3">\n </span><span class="s1">* @return {DeleteSet} Merged and sorted DeleteSet</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createDeleteSetFromStructStore = ss =&gt; {</span><span class="s3">\n  </span><span class="s1">const ds = createDeleteSet();</span><span class="s3">\n  </span><span class="s1">ss.clients.forEach((structs, client) =&gt; {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;DeleteItem&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const dsitems = [];</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; structs.length; i++) {</span><span class="s3">\n      </span><span class="s1">const struct = structs[i];</span><span class="s3">\n      </span><span class="s1">if (struct.deleted) {</span><span class="s3">\n        </span><span class="s1">const clock = struct.id.clock;</span><span class="s3">\n        </span><span class="s1">let len = struct.length;</span><span class="s3">\n        </span><span class="s1">if (i + 1 &lt; structs.length) {</span><span class="s3">\n          </span><span class="s1">for (let next = structs[i + 1]; i + 1 &lt; structs.length &amp;&amp; next.deleted; next = structs[++i + 1]) {</span><span class="s3">\n            </span><span class="s1">len += next.length;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">dsitems.push(new DeleteItem(clock, len));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (dsitems.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">ds.clients.set(client, dsitems);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return ds</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DSEncoderV1 | DSEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeDeleteSet = (encoder, ds) =&gt; {</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, ds.clients.size);</span><span class="s3">\n\n  </span><span class="s1">// Ensure that the delete set is written in a deterministic order</span><span class="s3">\n  </span><span class="s1">array.from(ds.clients.entries())</span><span class="s3">\n    </span><span class="s1">.sort((a, b) =&gt; b[0] - a[0])</span><span class="s3">\n    </span><span class="s1">.forEach(([client, dsitems]) =&gt; {</span><span class="s3">\n      </span><span class="s1">encoder.resetDsCurVal();</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, client);</span><span class="s3">\n      </span><span class="s1">const len = dsitems.length;</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, len);</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n        </span><span class="s1">const item = dsitems[i];</span><span class="s3">\n        </span><span class="s1">encoder.writeDsClock(item.clock);</span><span class="s3">\n        </span><span class="s1">encoder.writeDsLen(item.len);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DSDecoderV1 | DSDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {DeleteSet}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readDeleteSet = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const ds = new DeleteSet();</span><span class="s3">\n  </span><span class="s1">const numClients = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; numClients; i++) {</span><span class="s3">\n    </span><span class="s1">decoder.resetDsCurVal();</span><span class="s3">\n    </span><span class="s1">const client = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">if (numberOfDeletes &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const dsField = map.setIfUndefined(ds.clients, client, () =&gt; /** @type {Array&lt;DeleteItem&gt;} */ ([]));</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; numberOfDeletes; i++) {</span><span class="s3">\n        </span><span class="s1">dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ds</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DSDecoderV1 | DSDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readAndApplyDeleteSet = (decoder, transaction, store) =&gt; {</span><span class="s3">\n  </span><span class="s1">const unappliedDS = new DeleteSet();</span><span class="s3">\n  </span><span class="s1">const numClients = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; numClients; i++) {</span><span class="s3">\n    </span><span class="s1">decoder.resetDsCurVal();</span><span class="s3">\n    </span><span class="s1">const client = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">const numberOfDeletes = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">const structs = store.clients.get(client) || [];</span><span class="s3">\n    </span><span class="s1">const state = getState(store, client);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numberOfDeletes; i++) {</span><span class="s3">\n      </span><span class="s1">const clock = decoder.readDsClock();</span><span class="s3">\n      </span><span class="s1">const clockEnd = clock + decoder.readDsLen();</span><span class="s3">\n      </span><span class="s1">if (clock &lt; state) {</span><span class="s3">\n        </span><span class="s1">if (state &lt; clockEnd) {</span><span class="s3">\n          </span><span class="s1">addToDeleteSet(unappliedDS, client, state, clockEnd - state);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let index = findIndexSS(structs, clock);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* We can ignore the case of GC and Delete structs, because we are going to skip them</span><span class="s3">\n         </span><span class="s1">* @type {Item}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">let struct = structs[index];</span><span class="s3">\n        </span><span class="s1">// split the first item if necessary</span><span class="s3">\n        </span><span class="s1">if (!struct.deleted &amp;&amp; struct.id.clock &lt; clock) {</span><span class="s3">\n          </span><span class="s1">structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));</span><span class="s3">\n          </span><span class="s1">index++; // increase we now want to use the next struct</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (index &lt; structs.length) {</span><span class="s3">\n          </span><span class="s1">// @ts-ignore</span><span class="s3">\n          </span><span class="s1">struct = structs[index++];</span><span class="s3">\n          </span><span class="s1">if (struct.id.clock &lt; clockEnd) {</span><span class="s3">\n            </span><span class="s1">if (!struct.deleted) {</span><span class="s3">\n              </span><span class="s1">if (clockEnd &lt; struct.id.clock + struct.length) {</span><span class="s3">\n                </span><span class="s1">structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">struct.delete(transaction);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (unappliedDS.clients.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const ds = new UpdateEncoderV2();</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(ds.restEncoder, 0); // encode 0 structs</span><span class="s3">\n    </span><span class="s1">writeDeleteSet(ds, unappliedDS);</span><span class="s3">\n    </span><span class="s1">return ds.toUint8Array()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds1</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const equalDeleteSets = (ds1, ds2) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (ds1.clients.size !== ds2.clients.size) return false</span><span class="s3">\n  </span><span class="s1">for (const [client, deleteItems1] of ds1.clients.entries()) {</span><span class="s3">\n    </span><span class="s1">const deleteItems2 = /** @type {Array&lt;import('../internals.js').DeleteItem&gt;} */ (ds2.clients.get(client));</span><span class="s3">\n    </span><span class="s1">if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; deleteItems1.length; i++) {</span><span class="s3">\n      </span><span class="s1">const di1 = deleteItems1[i];</span><span class="s3">\n      </span><span class="s1">const di2 = deleteItems2[i];</span><span class="s3">\n      </span><span class="s1">if (di1.clock !== di2.clock || di1.len !== di2.len) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @module Y</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">const generateNewClientId = random.uint32;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {Object} DocOpts</span><span class="s3">\n </span><span class="s1">* @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)</span><span class="s3">\n </span><span class="s1">* @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.</span><span class="s3">\n </span><span class="s1">* @property {string} [DocOpts.guid] Define a globally unique identifier for this document</span><span class="s3">\n </span><span class="s1">* @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.</span><span class="s3">\n </span><span class="s1">* @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.</span><span class="s3">\n </span><span class="s1">* @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.</span><span class="s3">\n </span><span class="s1">* @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A Yjs instance handles the state of shared data.</span><span class="s3">\n </span><span class="s1">* @extends Observable&lt;string&gt;</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Doc extends Observable {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {DocOpts} opts configuration</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor ({ guid = random.uuidv4(), collectionid = null, gc = true, gcFilter = () =&gt; true, meta = null, autoLoad = false, shouldLoad = true } = {}) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">this.gc = gc;</span><span class="s3">\n    </span><span class="s1">this.gcFilter = gcFilter;</span><span class="s3">\n    </span><span class="s1">this.clientID = generateNewClientId();</span><span class="s3">\n    </span><span class="s1">this.guid = guid;</span><span class="s3">\n    </span><span class="s1">this.collectionid = collectionid;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string, AbstractType&lt;YEvent&lt;any&gt;&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.share = new Map();</span><span class="s3">\n    </span><span class="s1">this.store = new StructStore();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Transaction | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._transaction = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;Transaction&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._transactionCleanups = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;Doc&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.subdocs = new Set();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If this document is a subdocument - a document integrated into another document - then _item is defined.</span><span class="s3">\n     </span><span class="s1">* @type {Item?}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._item = null;</span><span class="s3">\n    </span><span class="s1">this.shouldLoad = shouldLoad;</span><span class="s3">\n    </span><span class="s1">this.autoLoad = autoLoad;</span><span class="s3">\n    </span><span class="s1">this.meta = meta;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.</span><span class="s3">\n     </span><span class="s1">* Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.isLoaded = false;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* This is set to true when the connection provider has successfully synced with a backend.</span><span class="s3">\n     </span><span class="s1">* Note that when using peer-to-peer providers this event may not provide very useful.</span><span class="s3">\n     </span><span class="s1">* Also note that not all providers implement this feature. Provider authors are encouraged to fire</span><span class="s3">\n     </span><span class="s1">* the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is</span><span class="s3">\n     </span><span class="s1">* lost (with false as a parameter).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.isSynced = false;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Promise that resolves once the document has been loaded from a presistence provider.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.whenLoaded = promise.create(resolve =&gt; {</span><span class="s3">\n      </span><span class="s1">this.on('load', () =&gt; {</span><span class="s3">\n        </span><span class="s1">this.isLoaded = true;</span><span class="s3">\n        </span><span class="s1">resolve(this);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const provideSyncedPromise = () =&gt; promise.create(resolve =&gt; {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @param {boolean} isSynced</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const eventHandler = (isSynced) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (isSynced === undefined || isSynced === true) {</span><span class="s3">\n          </span><span class="s1">this.off('sync', eventHandler);</span><span class="s3">\n          </span><span class="s1">resolve();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">this.on('sync', eventHandler);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">this.on('sync', isSynced =&gt; {</span><span class="s3">\n      </span><span class="s1">if (isSynced === false &amp;&amp; this.isSynced) {</span><span class="s3">\n        </span><span class="s1">this.whenSynced = provideSyncedPromise();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.isSynced = isSynced === undefined || isSynced === true;</span><span class="s3">\n      </span><span class="s1">if (!this.isLoaded) {</span><span class="s3">\n        </span><span class="s1">this.emit('load', []);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Promise that resolves once the document has been synced with a backend.</span><span class="s3">\n     </span><span class="s1">* This promise is recreated when the connection is lost.</span><span class="s3">\n     </span><span class="s1">* Note the documentation about the `isSynced` property.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.whenSynced = provideSyncedPromise();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Notify the parent document that you request to load data into this subdocument (if it is a subdocument).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* `load()` might be used in the future to request any provider to load the most current data.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* It is safe to call `load()` multiple times.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">load () {</span><span class="s3">\n    </span><span class="s1">const item = this._item;</span><span class="s3">\n    </span><span class="s1">if (item !== null &amp;&amp; !this.shouldLoad) {</span><span class="s3">\n      </span><span class="s1">transact(/** @type {any} */ (item.parent).doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">transaction.subdocsLoaded.add(this);</span><span class="s3">\n      </span><span class="s1">}, null, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.shouldLoad = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getSubdocs () {</span><span class="s3">\n    </span><span class="s1">return this.subdocs</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">getSubdocGuids () {</span><span class="s3">\n    </span><span class="s1">return new Set(array.from(this.subdocs).map(doc =&gt; doc.guid))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Changes that happen inside of a transaction are bundled. This means that</span><span class="s3">\n   </span><span class="s1">* the observer fires _after_ the transaction is finished and that all changes</span><span class="s3">\n   </span><span class="s1">* that happened inside of the transaction are sent as one message to the</span><span class="s3">\n   </span><span class="s1">* other peers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template T</span><span class="s3">\n   </span><span class="s1">* @param {function(Transaction):T} f The function that should be executed as a transaction</span><span class="s3">\n   </span><span class="s1">* @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin</span><span class="s3">\n   </span><span class="s1">* @return T</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">transact (f, origin = null) {</span><span class="s3">\n    </span><span class="s1">return transact(this, f, origin)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Define a shared data type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Multiple calls of `y.get(name, TypeConstructor)` yield the same result</span><span class="s3">\n   </span><span class="s1">* and do not overwrite each other. I.e.</span><span class="s3">\n   </span><span class="s1">* `y.define(name, Y.Array) === y.define(name, Y.Array)`</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* After this method is called, the type is also available on `y.share.get(name)`.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* *Best Practices:*</span><span class="s3">\n   </span><span class="s1">* Define all types right after the Yjs instance is created and store them in a separate object.</span><span class="s3">\n   </span><span class="s1">* Also use the typed methods `getText(name)`, `getArray(name)`, ..</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*   const y = new Y(..)</span><span class="s3">\n   </span><span class="s1">*   const appState = {</span><span class="s3">\n   </span><span class="s1">*     document: y.getText('document')</span><span class="s3">\n   </span><span class="s1">*     comments: y.getArray('comments')</span><span class="s3">\n   </span><span class="s1">*   }</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} name</span><span class="s3">\n   </span><span class="s1">* @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...</span><span class="s3">\n   </span><span class="s1">* @return {AbstractType&lt;any&gt;} The created type. Constructed with TypeConstructor</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get (name, TypeConstructor = AbstractType) {</span><span class="s3">\n    </span><span class="s1">const type = map.setIfUndefined(this.share, name, () =&gt; {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore</span><span class="s3">\n      </span><span class="s1">const t = new TypeConstructor();</span><span class="s3">\n      </span><span class="s1">t._integrate(this, null);</span><span class="s3">\n      </span><span class="s1">return t</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const Constr = type.constructor;</span><span class="s3">\n    </span><span class="s1">if (TypeConstructor !== AbstractType &amp;&amp; Constr !== TypeConstructor) {</span><span class="s3">\n      </span><span class="s1">if (Constr === AbstractType) {</span><span class="s3">\n        </span><span class="s1">// @ts-ignore</span><span class="s3">\n        </span><span class="s1">const t = new TypeConstructor();</span><span class="s3">\n        </span><span class="s1">t._map = type._map;</span><span class="s3">\n        </span><span class="s1">type._map.forEach(/** @param {Item?} n */ n =&gt; {</span><span class="s3">\n          </span><span class="s1">for (; n !== null; n = n.left) {</span><span class="s3">\n            </span><span class="s1">// @ts-ignore</span><span class="s3">\n            </span><span class="s1">n.parent = t;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">t._start = type._start;</span><span class="s3">\n        </span><span class="s1">for (let n = t._start; n !== null; n = n.right) {</span><span class="s3">\n          </span><span class="s1">n.parent = t;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">t._length = type._length;</span><span class="s3">\n        </span><span class="s1">this.share.set(name, t);</span><span class="s3">\n        </span><span class="s1">t._integrate(this, null);</span><span class="s3">\n        </span><span class="s1">return t</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Type with the name ${name} has already been defined with a different constructor`)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return type</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template T</span><span class="s3">\n   </span><span class="s1">* @param {string} [name]</span><span class="s3">\n   </span><span class="s1">* @return {YArray&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getArray (name = '') {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return this.get(name, YArray)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} [name]</span><span class="s3">\n   </span><span class="s1">* @return {YText}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getText (name = '') {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return this.get(name, YText)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template T</span><span class="s3">\n   </span><span class="s1">* @param {string} [name]</span><span class="s3">\n   </span><span class="s1">* @return {YMap&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getMap (name = '') {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return this.get(name, YMap)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} [name]</span><span class="s3">\n   </span><span class="s1">* @return {YXmlFragment}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getXmlFragment (name = '') {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return this.get(name, YXmlFragment)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Converts the entire document into a js object, recursively traversing each yjs type</span><span class="s3">\n   </span><span class="s1">* Doesn't log types that have not been defined (using ydoc.getType(..)).</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @deprecated Do not use this method and rather call toJSON directly on the shared types.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Object&lt;string, any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Object&lt;string, any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const doc = {};</span><span class="s3">\n\n    </span><span class="s1">this.share.forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">doc[key] = value.toJSON();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return doc</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Emit `destroy` event and unregister all event handlers.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">array.from(this.subdocs).forEach(subdoc =&gt; subdoc.destroy());</span><span class="s3">\n    </span><span class="s1">const item = this._item;</span><span class="s3">\n    </span><span class="s1">if (item !== null) {</span><span class="s3">\n      </span><span class="s1">this._item = null;</span><span class="s3">\n      </span><span class="s1">const content = /** @type {ContentDoc} */ (item.content);</span><span class="s3">\n      </span><span class="s1">content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });</span><span class="s3">\n      </span><span class="s1">content.doc._item = item;</span><span class="s3">\n      </span><span class="s1">transact(/** @type {any} */ (item).parent.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const doc = content.doc;</span><span class="s3">\n        </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n          </span><span class="s1">transaction.subdocsAdded.add(doc);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">transaction.subdocsRemoved.add(this);</span><span class="s3">\n      </span><span class="s1">}, null, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.emit('destroyed', [true]);</span><span class="s3">\n    </span><span class="s1">this.emit('destroy', [this]);</span><span class="s3">\n    </span><span class="s1">super.destroy();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} eventName</span><span class="s3">\n   </span><span class="s1">* @param {function(...any):any} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">on (eventName, f) {</span><span class="s3">\n    </span><span class="s1">super.on(eventName, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} eventName</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">off (eventName, f) {</span><span class="s3">\n    </span><span class="s1">super.off(eventName, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DSDecoderV1 {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (decoder) {</span><span class="s3">\n    </span><span class="s1">this.restDecoder = decoder;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetDsCurVal () {</span><span class="s3">\n    </span><span class="s1">// nop</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readDsClock () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readDsLen () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class UpdateDecoderV1 extends DSDecoderV1 {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ID}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readLeftID () {</span><span class="s3">\n    </span><span class="s1">return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ID}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readRightID () {</span><span class="s3">\n    </span><span class="s1">return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Read the next client id.</span><span class="s3">\n   </span><span class="s1">* Use this in favor of readID whenever possible to reduce the number of objects created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readClient () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readInfo () {</span><span class="s3">\n    </span><span class="s1">return decoding.readUint8(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readString () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarString(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean} isKey</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readParentInfo () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder) === 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readTypeRef () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Write len of a struct - well suited for Opt RLE encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readLen () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readAny () {</span><span class="s3">\n    </span><span class="s1">return decoding.readAny(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readBuf () {</span><span class="s3">\n    </span><span class="s1">return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Legacy implementation uses JSON parse. We use any-decoding in v2.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readJSON () {</span><span class="s3">\n    </span><span class="s1">return JSON.parse(decoding.readVarString(this.restDecoder))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readKey () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarString(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DSDecoderV2 {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (decoder) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal = 0;</span><span class="s3">\n    </span><span class="s1">this.restDecoder = decoder;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetDsCurVal () {</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readDsClock () {</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal += decoding.readVarUint(this.restDecoder);</span><span class="s3">\n    </span><span class="s1">return this.dsCurrVal</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readDsLen () {</span><span class="s3">\n    </span><span class="s1">const diff = decoding.readVarUint(this.restDecoder) + 1;</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal += diff;</span><span class="s3">\n    </span><span class="s1">return diff</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class UpdateDecoderV2 extends DSDecoderV2 {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (decoder) {</span><span class="s3">\n    </span><span class="s1">super(decoder);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* List of cached keys. If the keys[id] does not exist, we read a new key</span><span class="s3">\n     </span><span class="s1">* from stringEncoder and push it to keys.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;string&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.keys = [];</span><span class="s3">\n    </span><span class="s1">decoding.readVarUint(decoder); // read feature flag - currently unused</span><span class="s3">\n    </span><span class="s1">this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);</span><span class="s3">\n    </span><span class="s1">this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8);</span><span class="s3">\n    </span><span class="s1">this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n    </span><span class="s1">this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ID}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readLeftID () {</span><span class="s3">\n    </span><span class="s1">return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ID}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readRightID () {</span><span class="s3">\n    </span><span class="s1">return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Read the next client id.</span><span class="s3">\n   </span><span class="s1">* Use this in favor of readID whenever possible to reduce the number of objects created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readClient () {</span><span class="s3">\n    </span><span class="s1">return this.clientDecoder.read()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readInfo () {</span><span class="s3">\n    </span><span class="s1">return /** @type {number} */ (this.infoDecoder.read())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readString () {</span><span class="s3">\n    </span><span class="s1">return this.stringDecoder.read()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readParentInfo () {</span><span class="s3">\n    </span><span class="s1">return this.parentInfoDecoder.read() === 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number} An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readTypeRef () {</span><span class="s3">\n    </span><span class="s1">return this.typeRefDecoder.read()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Write len of a struct - well suited for Opt RLE encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readLen () {</span><span class="s3">\n    </span><span class="s1">return this.lenDecoder.read()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readAny () {</span><span class="s3">\n    </span><span class="s1">return decoding.readAny(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readBuf () {</span><span class="s3">\n    </span><span class="s1">return decoding.readVarUint8Array(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is mainly here for legacy purposes.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readJSON () {</span><span class="s3">\n    </span><span class="s1">return decoding.readAny(this.restDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">readKey () {</span><span class="s3">\n    </span><span class="s1">const keyClock = this.keyClockDecoder.read();</span><span class="s3">\n    </span><span class="s1">if (keyClock &lt; this.keys.length) {</span><span class="s3">\n      </span><span class="s1">return this.keys[keyClock]</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const key = this.stringDecoder.read();</span><span class="s3">\n      </span><span class="s1">this.keys.push(key);</span><span class="s3">\n      </span><span class="s1">return key</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DSEncoderV1 {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.restEncoder = encoding.createEncoder();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">return encoding.toUint8Array(this.restEncoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetDsCurVal () {</span><span class="s3">\n    </span><span class="s1">// nop</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} clock</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeDsClock (clock) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeDsLen (len) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, len);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class UpdateEncoderV1 extends DSEncoderV1 {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeLeftID (id) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, id.client);</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, id.clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeRightID (id) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, id.client);</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, id.clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Use writeClient and writeClock instead of writeID if possible.</span><span class="s3">\n   </span><span class="s1">* @param {number} client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeClient (client) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, client);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeInfo (info) {</span><span class="s3">\n    </span><span class="s1">encoding.writeUint8(this.restEncoder, info);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} s</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeString (s) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(this.restEncoder, s);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {boolean} isYKey</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeParentInfo (isYKey) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeTypeRef (info) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, info);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Write len of a struct - well suited for Opt RLE encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeLen (len) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, len);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} any</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeAny (any) {</span><span class="s3">\n    </span><span class="s1">encoding.writeAny(this.restEncoder, any);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeBuf (buf) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(this.restEncoder, buf);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} embed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeJSON (embed) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(this.restEncoder, JSON.stringify(embed));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeKey (key) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(this.restEncoder, key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class DSEncoderV2 {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">this.restEncoder = encoding.createEncoder(); // encodes all the rest / non-optimized</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">return encoding.toUint8Array(this.restEncoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">resetDsCurVal () {</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} clock</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeDsClock (clock) {</span><span class="s3">\n    </span><span class="s1">const diff = clock - this.dsCurrVal;</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal = clock;</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, diff);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeDsLen (len) {</span><span class="s3">\n    </span><span class="s1">if (len === 0) {</span><span class="s3">\n      </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(this.restEncoder, len - 1);</span><span class="s3">\n    </span><span class="s1">this.dsCurrVal += len;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class UpdateEncoderV2 extends DSEncoderV2 {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string,number&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.keyMap = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Refers to the next uniqe key-identifier to me used.</span><span class="s3">\n     </span><span class="s1">* See writeKey method for more information.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.keyClock = 0;</span><span class="s3">\n    </span><span class="s1">this.keyClockEncoder = new encoding.IntDiffOptRleEncoder();</span><span class="s3">\n    </span><span class="s1">this.clientEncoder = new encoding.UintOptRleEncoder();</span><span class="s3">\n    </span><span class="s1">this.leftClockEncoder = new encoding.IntDiffOptRleEncoder();</span><span class="s3">\n    </span><span class="s1">this.rightClockEncoder = new encoding.IntDiffOptRleEncoder();</span><span class="s3">\n    </span><span class="s1">this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8);</span><span class="s3">\n    </span><span class="s1">this.stringEncoder = new encoding.StringEncoder();</span><span class="s3">\n    </span><span class="s1">this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8);</span><span class="s3">\n    </span><span class="s1">this.typeRefEncoder = new encoding.UintOptRleEncoder();</span><span class="s3">\n    </span><span class="s1">this.lenEncoder = new encoding.UintOptRleEncoder();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toUint8Array () {</span><span class="s3">\n    </span><span class="s1">const encoder = encoding.createEncoder();</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder));</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder));</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());</span><span class="s3">\n    </span><span class="s1">// @note The rest encoder is appended! (note the missing var)</span><span class="s3">\n    </span><span class="s1">encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder));</span><span class="s3">\n    </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeLeftID (id) {</span><span class="s3">\n    </span><span class="s1">this.clientEncoder.write(id.client);</span><span class="s3">\n    </span><span class="s1">this.leftClockEncoder.write(id.clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeRightID (id) {</span><span class="s3">\n    </span><span class="s1">this.clientEncoder.write(id.client);</span><span class="s3">\n    </span><span class="s1">this.rightClockEncoder.write(id.clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} client</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeClient (client) {</span><span class="s3">\n    </span><span class="s1">this.clientEncoder.write(client);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeInfo (info) {</span><span class="s3">\n    </span><span class="s1">this.infoEncoder.write(info);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} s</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeString (s) {</span><span class="s3">\n    </span><span class="s1">this.stringEncoder.write(s);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {boolean} isYKey</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeParentInfo (isYKey) {</span><span class="s3">\n    </span><span class="s1">this.parentInfoEncoder.write(isYKey ? 1 : 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} info An unsigned 8-bit integer</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeTypeRef (info) {</span><span class="s3">\n    </span><span class="s1">this.typeRefEncoder.write(info);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Write len of a struct - well suited for Opt RLE encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeLen (len) {</span><span class="s3">\n    </span><span class="s1">this.lenEncoder.write(len);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} any</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeAny (any) {</span><span class="s3">\n    </span><span class="s1">encoding.writeAny(this.restEncoder, any);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeBuf (buf) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint8Array(this.restEncoder, buf);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is mainly here for legacy purposes.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {any} embed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeJSON (embed) {</span><span class="s3">\n    </span><span class="s1">encoding.writeAny(this.restEncoder, embed);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Property keys are often reused. For example, in y-prosemirror the key `bold` might</span><span class="s3">\n   </span><span class="s1">* occur very often. For a 3d application, the key `position` might occur very often.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* We cache these keys in a Map and refer to them via a unique number.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">writeKey (key) {</span><span class="s3">\n    </span><span class="s1">const clock = this.keyMap.get(key);</span><span class="s3">\n    </span><span class="s1">if (clock === undefined) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @todo uncomment to introduce this feature finally</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.</span><span class="s3">\n       </span><span class="s1">* Furthermore, I forgot to set the keyclock. So everything was working fine.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* I don't know yet how to reintroduce this feature..</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">// this.keyMap.set(key, this.keyClock)</span><span class="s3">\n      </span><span class="s1">this.keyClockEncoder.write(this.keyClock++);</span><span class="s3">\n      </span><span class="s1">this.stringEncoder.write(key);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.keyClockEncoder.write(clock);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;GC|Item&gt;} structs All structs by `client`</span><span class="s3">\n </span><span class="s1">* @param {number} client</span><span class="s3">\n </span><span class="s1">* @param {number} clock write structs starting with `ID(client,clock)`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeStructs = (encoder, structs, client, clock) =&gt; {</span><span class="s3">\n  </span><span class="s1">// write first id</span><span class="s3">\n  </span><span class="s1">clock = math.max(clock, structs[0].id.clock); // make sure the first id exists</span><span class="s3">\n  </span><span class="s1">const startNewStructs = findIndexSS(structs, clock);</span><span class="s3">\n  </span><span class="s1">// write # encoded structs</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);</span><span class="s3">\n  </span><span class="s1">encoder.writeClient(client);</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, clock);</span><span class="s3">\n  </span><span class="s1">const firstStruct = structs[startNewStructs];</span><span class="s3">\n  </span><span class="s1">// write first struct with an offset</span><span class="s3">\n  </span><span class="s1">firstStruct.write(encoder, clock - firstStruct.id.clock);</span><span class="s3">\n  </span><span class="s1">for (let i = startNewStructs + 1; i &lt; structs.length; i++) {</span><span class="s3">\n    </span><span class="s1">structs[i].write(encoder, 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;number,number&gt;} _sm</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeClientsStructs = (encoder, store, _sm) =&gt; {</span><span class="s3">\n  </span><span class="s1">// we filter all valid _sm entries into sm</span><span class="s3">\n  </span><span class="s1">const sm = new Map();</span><span class="s3">\n  </span><span class="s1">_sm.forEach((clock, client) =&gt; {</span><span class="s3">\n    </span><span class="s1">// only write if new structs are available</span><span class="s3">\n    </span><span class="s1">if (getState(store, client) &gt; clock) {</span><span class="s3">\n      </span><span class="s1">sm.set(client, clock);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">getStateVector(store).forEach((_clock, client) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!_sm.has(client)) {</span><span class="s3">\n      </span><span class="s1">sm.set(client, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">// write # states that were updated</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, sm.size);</span><span class="s3">\n  </span><span class="s1">// Write items with higher client ids first</span><span class="s3">\n  </span><span class="s1">// This heavily improves the conflict algorithm.</span><span class="s3">\n  </span><span class="s1">array.from(sm.entries()).sort((a, b) =&gt; b[0] - a[0]).forEach(([client, clock]) =&gt; {</span><span class="s3">\n    </span><span class="s1">writeStructs(encoder, /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(client)), client, clock);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;number, { i: number, refs: Array&lt;Item | GC&gt; }&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readClientsStructRefs = (decoder, doc) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Map&lt;number, { i: number, refs: Array&lt;Item | GC&gt; }&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const clientRefs = map.create();</span><span class="s3">\n  </span><span class="s1">const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; numOfStateUpdates; i++) {</span><span class="s3">\n    </span><span class="s1">const numberOfStructs = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;GC|Item&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const refs = new Array(numberOfStructs);</span><span class="s3">\n    </span><span class="s1">const client = decoder.readClient();</span><span class="s3">\n    </span><span class="s1">let clock = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">// const start = performance.now()</span><span class="s3">\n    </span><span class="s1">clientRefs.set(client, { i: 0, refs });</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numberOfStructs; i++) {</span><span class="s3">\n      </span><span class="s1">const info = decoder.readInfo();</span><span class="s3">\n      </span><span class="s1">switch (binary.BITS5 &amp; info) {</span><span class="s3">\n        </span><span class="s1">case 0: { // GC</span><span class="s3">\n          </span><span class="s1">const len = decoder.readLen();</span><span class="s3">\n          </span><span class="s1">refs[i] = new GC(createID(client, clock), len);</span><span class="s3">\n          </span><span class="s1">clock += len;</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 10: { // Skip Struct (nothing to apply)</span><span class="s3">\n          </span><span class="s1">// @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.</span><span class="s3">\n          </span><span class="s1">const len = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n          </span><span class="s1">refs[i] = new Skip(createID(client, clock), len);</span><span class="s3">\n          </span><span class="s1">clock += len;</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">default: { // Item with content</span><span class="s3">\n          </span><span class="s1">/**</span><span class="s3">\n           </span><span class="s1">* The optimized implementation doesn't use any variables because inlining variables is faster.</span><span class="s3">\n           </span><span class="s1">* Below a non-optimized version is shown that implements the basic algorithm with</span><span class="s3">\n           </span><span class="s1">* a few comments</span><span class="s3">\n           </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">const cantCopyParentInfo = (info &amp; (binary.BIT7 | binary.BIT8)) === 0;</span><span class="s3">\n          </span><span class="s1">// If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`</span><span class="s3">\n          </span><span class="s1">// and we read the next string as parentYKey.</span><span class="s3">\n          </span><span class="s1">// It indicates how we store/retrieve parent from `y.share`</span><span class="s3">\n          </span><span class="s1">// @type {string|null}</span><span class="s3">\n          </span><span class="s1">const struct = new Item(</span><span class="s3">\n            </span><span class="s1">createID(client, clock),</span><span class="s3">\n            </span><span class="s1">null, // leftd</span><span class="s3">\n            </span><span class="s1">(info &amp; binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin</span><span class="s3">\n            </span><span class="s1">null, // right</span><span class="s3">\n            </span><span class="s1">(info &amp; binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin</span><span class="s3">\n            </span><span class="s1">cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent</span><span class="s3">\n            </span><span class="s1">cantCopyParentInfo &amp;&amp; (info &amp; binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub</span><span class="s3">\n            </span><span class="s1">readItemContent(decoder, info) // item content</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">/* A non-optimized implementation of the above algorithm:</span><span class="s3">\n\n          </span><span class="s1">// The item that was originally to the left of this item.</span><span class="s3">\n          </span><span class="s1">const origin = (info &amp; binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null</span><span class="s3">\n          </span><span class="s1">// The item that was originally to the right of this item.</span><span class="s3">\n          </span><span class="s1">const rightOrigin = (info &amp; binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null</span><span class="s3">\n          </span><span class="s1">const cantCopyParentInfo = (info &amp; (binary.BIT7 | binary.BIT8)) === 0</span><span class="s3">\n          </span><span class="s1">const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false</span><span class="s3">\n          </span><span class="s1">// If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`</span><span class="s3">\n          </span><span class="s1">// and we read the next string as parentYKey.</span><span class="s3">\n          </span><span class="s1">// It indicates how we store/retrieve parent from `y.share`</span><span class="s3">\n          </span><span class="s1">// @type {string|null}</span><span class="s3">\n          </span><span class="s1">const parentYKey = cantCopyParentInfo &amp;&amp; hasParentYKey ? decoder.readString() : null</span><span class="s3">\n\n          </span><span class="s1">const struct = new Item(</span><span class="s3">\n            </span><span class="s1">createID(client, clock),</span><span class="s3">\n            </span><span class="s1">null, // leftd</span><span class="s3">\n            </span><span class="s1">origin, // origin</span><span class="s3">\n            </span><span class="s1">null, // right</span><span class="s3">\n            </span><span class="s1">rightOrigin, // right origin</span><span class="s3">\n            </span><span class="s1">cantCopyParentInfo &amp;&amp; !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent</span><span class="s3">\n            </span><span class="s1">cantCopyParentInfo &amp;&amp; (info &amp; binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub</span><span class="s3">\n            </span><span class="s1">readItemContent(decoder, info) // item content</span><span class="s3">\n          </span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">refs[i] = struct;</span><span class="s3">\n          </span><span class="s1">clock += struct.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// console.log('time to read: ', performance.now() - start) // @todo remove</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return clientRefs</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resume computing structs generated by struct readers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* While there is something to do, we integrate structs in this order</span><span class="s3">\n </span><span class="s1">* 1. top element on stack, if stack is not empty</span><span class="s3">\n </span><span class="s1">* 2. next element from current struct reader (if empty, use next struct reader)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If struct causally depends on another struct (ref.missing), we put next reader of</span><span class="s3">\n </span><span class="s1">* `ref.id.client` on top of stack.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* At some point we find a struct that has no causal dependencies,</span><span class="s3">\n </span><span class="s1">* then we start emptying the stack.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)</span><span class="s3">\n </span><span class="s1">* depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This method is implemented in a way so that we can resume computation if this update</span><span class="s3">\n </span><span class="s1">* causally depends on another update.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;number, { i: number, refs: (GC | Item)[] }&gt;} clientsStructRefs</span><span class="s3">\n </span><span class="s1">* @return { null | { update: Uint8Array, missing: Map&lt;number,number&gt; } }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const integrateStructs = (transaction, store, clientsStructRefs) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;Item | GC&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const stack = [];</span><span class="s3">\n  </span><span class="s1">// sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.</span><span class="s3">\n  </span><span class="s1">let clientsStructRefsIds = array.from(clientsStructRefs.keys()).sort((a, b) =&gt; a - b);</span><span class="s3">\n  </span><span class="s1">if (clientsStructRefsIds.length === 0) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const getNextStructTarget = () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (clientsStructRefsIds.length === 0) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let nextStructsTarget = /** @type {{i:number,refs:Array&lt;GC|Item&gt;}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));</span><span class="s3">\n    </span><span class="s1">while (nextStructsTarget.refs.length === nextStructsTarget.i) {</span><span class="s3">\n      </span><span class="s1">clientsStructRefsIds.pop();</span><span class="s3">\n      </span><span class="s1">if (clientsStructRefsIds.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">nextStructsTarget = /** @type {{i:number,refs:Array&lt;GC|Item&gt;}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]));</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return nextStructsTarget</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">let curStructsTarget = getNextStructTarget();</span><span class="s3">\n  </span><span class="s1">if (curStructsTarget === null &amp;&amp; stack.length === 0) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {StructStore}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const restStructs = new StructStore();</span><span class="s3">\n  </span><span class="s1">const missingSV = new Map();</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} client</span><span class="s3">\n   </span><span class="s1">* @param {number} clock</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const updateMissingSv = (client, clock) =&gt; {</span><span class="s3">\n    </span><span class="s1">const mclock = missingSV.get(client);</span><span class="s3">\n    </span><span class="s1">if (mclock == null || mclock &gt; clock) {</span><span class="s3">\n      </span><span class="s1">missingSV.set(client, clock);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {GC|Item}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++];</span><span class="s3">\n  </span><span class="s1">// caching the state because it is used very often</span><span class="s3">\n  </span><span class="s1">const state = new Map();</span><span class="s3">\n\n  </span><span class="s1">const addStackToRestSS = () =&gt; {</span><span class="s3">\n    </span><span class="s1">for (const item of stack) {</span><span class="s3">\n      </span><span class="s1">const client = item.id.client;</span><span class="s3">\n      </span><span class="s1">const unapplicableItems = clientsStructRefs.get(client);</span><span class="s3">\n      </span><span class="s1">if (unapplicableItems) {</span><span class="s3">\n        </span><span class="s1">// decrement because we weren't able to apply previous operation</span><span class="s3">\n        </span><span class="s1">unapplicableItems.i--;</span><span class="s3">\n        </span><span class="s1">restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));</span><span class="s3">\n        </span><span class="s1">clientsStructRefs.delete(client);</span><span class="s3">\n        </span><span class="s1">unapplicableItems.i = 0;</span><span class="s3">\n        </span><span class="s1">unapplicableItems.refs = [];</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue</span><span class="s3">\n        </span><span class="s1">restStructs.clients.set(client, [item]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// remove client from clientsStructRefsIds to prevent users from applying the same update again</span><span class="s3">\n      </span><span class="s1">clientsStructRefsIds = clientsStructRefsIds.filter(c =&gt; c !== client);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stack.length = 0;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// iterate over all struct readers until we are done</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">if (stackHead.constructor !== Skip) {</span><span class="s3">\n      </span><span class="s1">const localClock = map.setIfUndefined(state, stackHead.id.client, () =&gt; getState(store, stackHead.id.client));</span><span class="s3">\n      </span><span class="s1">const offset = localClock - stackHead.id.clock;</span><span class="s3">\n      </span><span class="s1">if (offset &lt; 0) {</span><span class="s3">\n        </span><span class="s1">// update from the same client is missing</span><span class="s3">\n        </span><span class="s1">stack.push(stackHead);</span><span class="s3">\n        </span><span class="s1">updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);</span><span class="s3">\n        </span><span class="s1">// hid a dead wall, add all items from stack to restSS</span><span class="s3">\n        </span><span class="s1">addStackToRestSS();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const missing = stackHead.getMissing(transaction, store);</span><span class="s3">\n        </span><span class="s1">if (missing !== null) {</span><span class="s3">\n          </span><span class="s1">stack.push(stackHead);</span><span class="s3">\n          </span><span class="s1">// get the struct reader that has the missing struct</span><span class="s3">\n          </span><span class="s1">/**</span><span class="s3">\n           </span><span class="s1">* @type {{ refs: Array&lt;GC|Item&gt;, i: number }}</span><span class="s3">\n           </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 };</span><span class="s3">\n          </span><span class="s1">if (structRefs.refs.length === structRefs.i) {</span><span class="s3">\n            </span><span class="s1">// This update message causally depends on another update message that doesn't exist yet</span><span class="s3">\n            </span><span class="s1">updateMissingSv(/** @type {number} */ (missing), getState(store, missing));</span><span class="s3">\n            </span><span class="s1">addStackToRestSS();</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">stackHead = structRefs.refs[structRefs.i++];</span><span class="s3">\n            </span><span class="s1">continue</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (offset === 0 || offset &lt; stackHead.length) {</span><span class="s3">\n          </span><span class="s1">// all fine, apply the stackhead</span><span class="s3">\n          </span><span class="s1">stackHead.integrate(transaction, offset);</span><span class="s3">\n          </span><span class="s1">state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// iterate to next stackHead</span><span class="s3">\n    </span><span class="s1">if (stack.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">stackHead = /** @type {GC|Item} */ (stack.pop());</span><span class="s3">\n    </span><span class="s1">} else if (curStructsTarget !== null &amp;&amp; curStructsTarget.i &lt; curStructsTarget.refs.length) {</span><span class="s3">\n      </span><span class="s1">stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">curStructsTarget = getNextStructTarget();</span><span class="s3">\n      </span><span class="s1">if (curStructsTarget === null) {</span><span class="s3">\n        </span><span class="s1">// we are done!</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (restStructs.clients.size &gt; 0) {</span><span class="s3">\n    </span><span class="s1">const encoder = new UpdateEncoderV2();</span><span class="s3">\n    </span><span class="s1">writeClientsStructs(encoder, restStructs, new Map());</span><span class="s3">\n    </span><span class="s1">// write empty deleteset</span><span class="s3">\n    </span><span class="s1">// writeDeleteSet(encoder, new DeleteSet())</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, 0); // =&gt; no need for an extra function call, just write 0 deletes</span><span class="s3">\n    </span><span class="s1">return { missing: missingSV, update: encoder.toUint8Array() }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeStructsFromTransaction = (encoder, transaction) =&gt; writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read and apply a document update.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function has the same effect as `applyUpdate` but accepts an decoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @param {Doc} ydoc</span><span class="s3">\n </span><span class="s1">* @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =&gt;</span><span class="s3">\n  </span><span class="s1">transact(ydoc, transaction =&gt; {</span><span class="s3">\n    </span><span class="s1">// force that transaction.local is set to non-local</span><span class="s3">\n    </span><span class="s1">transaction.local = false;</span><span class="s3">\n    </span><span class="s1">let retry = false;</span><span class="s3">\n    </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n    </span><span class="s1">const store = doc.store;</span><span class="s3">\n    </span><span class="s1">// let start = performance.now()</span><span class="s3">\n    </span><span class="s1">const ss = readClientsStructRefs(structDecoder, doc);</span><span class="s3">\n    </span><span class="s1">// console.log('time to read structs: ', performance.now() - start) // @todo remove</span><span class="s3">\n    </span><span class="s1">// start = performance.now()</span><span class="s3">\n    </span><span class="s1">// console.log('time to merge: ', performance.now() - start) // @todo remove</span><span class="s3">\n    </span><span class="s1">// start = performance.now()</span><span class="s3">\n    </span><span class="s1">const restStructs = integrateStructs(transaction, store, ss);</span><span class="s3">\n    </span><span class="s1">const pending = store.pendingStructs;</span><span class="s3">\n    </span><span class="s1">if (pending) {</span><span class="s3">\n      </span><span class="s1">// check if we can apply something</span><span class="s3">\n      </span><span class="s1">for (const [client, clock] of pending.missing) {</span><span class="s3">\n        </span><span class="s1">if (clock &lt; getState(store, client)) {</span><span class="s3">\n          </span><span class="s1">retry = true;</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (restStructs) {</span><span class="s3">\n        </span><span class="s1">// merge restStructs into store.pending</span><span class="s3">\n        </span><span class="s1">for (const [client, clock] of restStructs.missing) {</span><span class="s3">\n          </span><span class="s1">const mclock = pending.missing.get(client);</span><span class="s3">\n          </span><span class="s1">if (mclock == null || mclock &gt; clock) {</span><span class="s3">\n            </span><span class="s1">pending.missing.set(client, clock);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pending.update = mergeUpdatesV2([pending.update, restStructs.update]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">store.pendingStructs = restStructs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// console.log('time to integrate: ', performance.now() - start) // @todo remove</span><span class="s3">\n    </span><span class="s1">// start = performance.now()</span><span class="s3">\n    </span><span class="s1">const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);</span><span class="s3">\n    </span><span class="s1">if (store.pendingDs) {</span><span class="s3">\n      </span><span class="s1">// @todo we could make a lower-bound state-vector check as we do above</span><span class="s3">\n      </span><span class="s1">const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs));</span><span class="s3">\n      </span><span class="s1">decoding.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate</span><span class="s3">\n      </span><span class="s1">const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);</span><span class="s3">\n      </span><span class="s1">if (dsRest &amp;&amp; dsRest2) {</span><span class="s3">\n        </span><span class="s1">// case 1: ds1 != null &amp;&amp; ds2 != null</span><span class="s3">\n        </span><span class="s1">store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// case 2: ds1 != null</span><span class="s3">\n        </span><span class="s1">// case 3: ds2 != null</span><span class="s3">\n        </span><span class="s1">// case 4: ds1 == null &amp;&amp; ds2 == null</span><span class="s3">\n        </span><span class="s1">store.pendingDs = dsRest || dsRest2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// Either dsRest == null &amp;&amp; pendingDs == null OR dsRest != null</span><span class="s3">\n      </span><span class="s1">store.pendingDs = dsRest;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// console.log('time to cleanup: ', performance.now() - start) // @todo remove</span><span class="s3">\n    </span><span class="s1">// start = performance.now()</span><span class="s3">\n\n    </span><span class="s1">// console.log('time to resume delete readers: ', performance.now() - start) // @todo remove</span><span class="s3">\n    </span><span class="s1">// start = performance.now()</span><span class="s3">\n    </span><span class="s1">if (retry) {</span><span class="s3">\n      </span><span class="s1">const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update;</span><span class="s3">\n      </span><span class="s1">store.pendingStructs = null;</span><span class="s3">\n      </span><span class="s1">applyUpdateV2(transaction.doc, update);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, transactionOrigin, false);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read and apply a document update.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function has the same effect as `applyUpdate` but accepts an decoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @param {Doc} ydoc</span><span class="s3">\n </span><span class="s1">* @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readUpdate = (decoder, ydoc, transactionOrigin) =&gt; readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply a document update created by, for example, `y.on('update', update =&gt; ..)` or `update = encodeStateAsUpdate()`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc} ydoc</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = decoding.createDecoder(update);</span><span class="s3">\n  </span><span class="s1">readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Apply a document update created by, for example, `y.on('update', update =&gt; ..)` or `update = encodeStateAsUpdate()`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc} ydoc</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const applyUpdate = (ydoc, update, transactionOrigin) =&gt; applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will</span><span class="s3">\n </span><span class="s1">* only write the operations that are missing.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;number,number&gt;} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) =&gt; {</span><span class="s3">\n  </span><span class="s1">writeClientsStructs(encoder, doc.store, targetStateVector);</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will</span><span class="s3">\n </span><span class="s1">* only write the operations that are missing.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) =&gt; {</span><span class="s3">\n  </span><span class="s1">const targetStateVector = decodeStateVector(encodedTargetStateVector);</span><span class="s3">\n  </span><span class="s1">writeStateAsUpdate(encoder, doc, targetStateVector);</span><span class="s3">\n  </span><span class="s1">const updates = [encoder.toUint8Array()];</span><span class="s3">\n  </span><span class="s1">// also add the pending updates (if there are any)</span><span class="s3">\n  </span><span class="s1">if (doc.store.pendingDs) {</span><span class="s3">\n    </span><span class="s1">updates.push(doc.store.pendingDs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (doc.store.pendingStructs) {</span><span class="s3">\n    </span><span class="s1">updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (updates.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">if (encoder.constructor === UpdateEncoderV1) {</span><span class="s3">\n      </span><span class="s1">return mergeUpdates(updates.map((update, i) =&gt; i === 0 ? update : convertUpdateFormatV2ToV1(update)))</span><span class="s3">\n    </span><span class="s1">} else if (encoder.constructor === UpdateEncoderV2) {</span><span class="s3">\n      </span><span class="s1">return mergeUpdatesV2(updates)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return updates[0]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will</span><span class="s3">\n </span><span class="s1">* only write the operations that are missing.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateAsUpdate = (doc, encodedTargetStateVector) =&gt; encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read state vector from Decoder and return as Map</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {DSDecoderV1 | DSDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;number,number&gt;} Maps `client` to the number next expected `clock` from that client.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readStateVector = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const ss = new Map();</span><span class="s3">\n  </span><span class="s1">const ssLength = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; ssLength; i++) {</span><span class="s3">\n    </span><span class="s1">const client = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">const clock = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">ss.set(client, clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ss</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read decodedState and return State as Map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} decodedState</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;number,number&gt;} Maps `client` to the number next expected `clock` from that client.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// export const decodeStateVectorV2 = decodedState =&gt; readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read decodedState and return State as Map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} decodedState</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;number,number&gt;} Maps `client` to the number next expected `clock` from that client.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeStateVector = decodedState =&gt; readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DSEncoderV1 | DSEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;number,number&gt;} sv</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeStateVector = (encoder, sv) =&gt; {</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, sv.size);</span><span class="s3">\n  </span><span class="s1">array.from(sv.entries()).sort((a, b) =&gt; b[0] - a[0]).forEach(([client, clock]) =&gt; {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, clock);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return encoder</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DSEncoderV1 | DSEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeDocumentStateVector = (encoder, doc) =&gt; writeStateVector(encoder, getStateVector(doc.store));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encode State as Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc|Map&lt;number,number&gt;} doc</span><span class="s3">\n </span><span class="s1">* @param {DSEncoderV1 | DSEncoderV2} [encoder]</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (doc instanceof Map) {</span><span class="s3">\n    </span><span class="s1">writeStateVector(encoder, doc);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">writeDocumentStateVector(encoder, doc);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return encoder.toUint8Array()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Encode State as Uint8Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc|Map&lt;number,number&gt;} doc</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateVector = doc =&gt; encodeStateVectorV2(doc, new DSEncoderV1());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* General event handler implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template ARG0, ARG1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class EventHandler {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;function(ARG0, ARG1):void&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.l = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template ARG0,ARG1</span><span class="s3">\n </span><span class="s1">* @returns {EventHandler&lt;ARG0,ARG1&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createEventHandler = () =&gt; new EventHandler();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds an event listener that is called when</span><span class="s3">\n </span><span class="s1">* {@link EventHandler#callEventListeners} is called.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template ARG0,ARG1</span><span class="s3">\n </span><span class="s1">* @param {EventHandler&lt;ARG0,ARG1&gt;} eventHandler</span><span class="s3">\n </span><span class="s1">* @param {function(ARG0,ARG1):void} f The event handler.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const addEventHandlerListener = (eventHandler, f) =&gt;</span><span class="s3">\n  </span><span class="s1">eventHandler.l.push(f);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Removes an event listener.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template ARG0,ARG1</span><span class="s3">\n </span><span class="s1">* @param {EventHandler&lt;ARG0,ARG1&gt;} eventHandler</span><span class="s3">\n </span><span class="s1">* @param {function(ARG0,ARG1):void} f The event handler that was added with</span><span class="s3">\n </span><span class="s1">*                     {@link EventHandler#addEventListener}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const removeEventHandlerListener = (eventHandler, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const l = eventHandler.l;</span><span class="s3">\n  </span><span class="s1">const len = l.length;</span><span class="s3">\n  </span><span class="s1">eventHandler.l = l.filter(g =&gt; f !== g);</span><span class="s3">\n  </span><span class="s1">if (len === eventHandler.l.length) {</span><span class="s3">\n    </span><span class="s1">console.error('[yjs] Tried to remove event handler that doesn</span><span class="s3">\\</span><span class="s1">'t exist.');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Call all event listeners that were added via</span><span class="s3">\n </span><span class="s1">* {@link EventHandler#addEventListener}.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template ARG0,ARG1</span><span class="s3">\n </span><span class="s1">* @param {EventHandler&lt;ARG0,ARG1&gt;} eventHandler</span><span class="s3">\n </span><span class="s1">* @param {ARG0} arg0</span><span class="s3">\n </span><span class="s1">* @param {ARG1} arg1</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const callEventHandlerListeners = (eventHandler, arg0, arg1) =&gt;</span><span class="s3">\n  </span><span class="s1">f.callAll(eventHandler.l, [arg0, arg1]);</span><span class="s3">\n\n</span><span class="s1">class ID {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} client client id</span><span class="s3">\n   </span><span class="s1">* @param {number} clock unique per client id, continuous number</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (client, clock) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Client id</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.client = client;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* unique per client id, continuous number</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clock = clock;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {ID | null} a</span><span class="s3">\n </span><span class="s1">* @param {ID | null} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const compareIDs = (a, b) =&gt; a === b || (a !== null &amp;&amp; b !== null &amp;&amp; a.client === b.client &amp;&amp; a.clock === b.clock);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} client</span><span class="s3">\n </span><span class="s1">* @param {number} clock</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createID = (client, clock) =&gt; new ID(client, clock);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {encoding.Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeID = (encoder, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder, id.client);</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder, id.clock);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Read ID.</span><span class="s3">\n </span><span class="s1">* * If first varUint read is 0xFFFFFF a RootID is returned.</span><span class="s3">\n </span><span class="s1">* * Otherwise an ID is returned</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {ID}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readID = decoder =&gt;</span><span class="s3">\n  </span><span class="s1">createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The top types are mapped from y.share.get(keyname) =&gt; type.</span><span class="s3">\n </span><span class="s1">* `type` does not store any information about the `keyname`.</span><span class="s3">\n </span><span class="s1">* This function finds the correct `keyname` for `type` and throws otherwise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @return {string}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findRootTypeKey = type =&gt; {</span><span class="s3">\n  </span><span class="s1">// @ts-ignore _y must be defined, otherwise unexpected case</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of type.doc.share.entries()) {</span><span class="s3">\n    </span><span class="s1">if (value === type) {</span><span class="s3">\n      </span><span class="s1">return key</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Check if `parent` is a parent of `child`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {Item|null} child</span><span class="s3">\n </span><span class="s1">* @return {Boolean} Whether `parent` is a parent of `child`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isParentOf = (parent, child) =&gt; {</span><span class="s3">\n  </span><span class="s1">while (child !== null) {</span><span class="s3">\n    </span><span class="s1">if (child.parent === parent) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">child = /** @type {AbstractType&lt;any&gt;} */ (child.parent)._item;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Convenient helper to log type information.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Do not use in productive systems as the output can be immense!</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const logType = type =&gt; {</span><span class="s3">\n  </span><span class="s1">const res = [];</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">while (n) {</span><span class="s3">\n    </span><span class="s1">res.push(n);</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">console.log('Children: ', res);</span><span class="s3">\n  </span><span class="s1">console.log('Children content: ', res.filter(m =&gt; !m.deleted).map(m =&gt; m.content));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">class PermanentUserData {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n   </span><span class="s1">* @param {YMap&lt;any&gt;} [storeType]</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (doc, storeType = doc.getMap('users')) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string,DeleteSet&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const dss = new Map();</span><span class="s3">\n    </span><span class="s1">this.yusers = storeType;</span><span class="s3">\n    </span><span class="s1">this.doc = doc;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Maps from clientid to userDescription</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number,string&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clients = new Map();</span><span class="s3">\n    </span><span class="s1">this.dss = dss;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param {YMap&lt;any&gt;} user</span><span class="s3">\n     </span><span class="s1">* @param {string} userDescription</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const initUser = (user, userDescription) =&gt; {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {YArray&lt;Uint8Array&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const ds = user.get('ds');</span><span class="s3">\n      </span><span class="s1">const ids = user.get('ids');</span><span class="s3">\n      </span><span class="s1">const addClientId = /** @param {number} clientid */ clientid =&gt; this.clients.set(clientid, userDescription);</span><span class="s3">\n      </span><span class="s1">ds.observe(/** @param {YArrayEvent&lt;any&gt;} event */ event =&gt; {</span><span class="s3">\n        </span><span class="s1">event.changes.added.forEach(item =&gt; {</span><span class="s3">\n          </span><span class="s1">item.content.getContent().forEach(encodedDs =&gt; {</span><span class="s3">\n            </span><span class="s1">if (encodedDs instanceof Uint8Array) {</span><span class="s3">\n              </span><span class="s1">this.dss.set(userDescription, mergeDeleteSets([this.dss.get(userDescription) || createDeleteSet(), readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs)))]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">this.dss.set(userDescription, mergeDeleteSets(ds.map(encodedDs =&gt; readDeleteSet(new DSDecoderV1(decoding.createDecoder(encodedDs))))));</span><span class="s3">\n      </span><span class="s1">ids.observe(/** @param {YArrayEvent&lt;any&gt;} event */ event =&gt;</span><span class="s3">\n        </span><span class="s1">event.changes.added.forEach(item =&gt; item.content.getContent().forEach(addClientId))</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">ids.forEach(addClientId);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">// observe users</span><span class="s3">\n    </span><span class="s1">storeType.observe(event =&gt; {</span><span class="s3">\n      </span><span class="s1">event.keysChanged.forEach(userDescription =&gt;</span><span class="s3">\n        </span><span class="s1">initUser(storeType.get(userDescription), userDescription)</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// add intial data</span><span class="s3">\n    </span><span class="s1">storeType.forEach(initUser);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n   </span><span class="s1">* @param {number} clientid</span><span class="s3">\n   </span><span class="s1">* @param {string} userDescription</span><span class="s3">\n   </span><span class="s1">* @param {Object} conf</span><span class="s3">\n   </span><span class="s1">* @param {function(Transaction, DeleteSet):boolean} [conf.filter]</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setUserMapping (doc, clientid, userDescription, { filter = () =&gt; true } = {}) {</span><span class="s3">\n    </span><span class="s1">const users = this.yusers;</span><span class="s3">\n    </span><span class="s1">let user = users.get(userDescription);</span><span class="s3">\n    </span><span class="s1">if (!user) {</span><span class="s3">\n      </span><span class="s1">user = new YMap();</span><span class="s3">\n      </span><span class="s1">user.set('ids', new YArray());</span><span class="s3">\n      </span><span class="s1">user.set('ds', new YArray());</span><span class="s3">\n      </span><span class="s1">users.set(userDescription, user);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">user.get('ids').push([clientid]);</span><span class="s3">\n    </span><span class="s1">users.observe(_event =&gt; {</span><span class="s3">\n      </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const userOverwrite = users.get(userDescription);</span><span class="s3">\n        </span><span class="s1">if (userOverwrite !== user) {</span><span class="s3">\n          </span><span class="s1">// user was overwritten, port all data over to the next user object</span><span class="s3">\n          </span><span class="s1">// @todo Experiment with Y.Sets here</span><span class="s3">\n          </span><span class="s1">user = userOverwrite;</span><span class="s3">\n          </span><span class="s1">// @todo iterate over old type</span><span class="s3">\n          </span><span class="s1">this.clients.forEach((_userDescription, clientid) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (userDescription === _userDescription) {</span><span class="s3">\n              </span><span class="s1">user.get('ids').push([clientid]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">const encoder = new DSEncoderV1();</span><span class="s3">\n          </span><span class="s1">const ds = this.dss.get(userDescription);</span><span class="s3">\n          </span><span class="s1">if (ds) {</span><span class="s3">\n            </span><span class="s1">writeDeleteSet(encoder, ds);</span><span class="s3">\n            </span><span class="s1">user.get('ds').push([encoder.toUint8Array()]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, 0);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">doc.on('afterTransaction', /** @param {Transaction} transaction */ transaction =&gt; {</span><span class="s3">\n      </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n        </span><span class="s1">const yds = user.get('ds');</span><span class="s3">\n        </span><span class="s1">const ds = transaction.deleteSet;</span><span class="s3">\n        </span><span class="s1">if (transaction.local &amp;&amp; ds.clients.size &gt; 0 &amp;&amp; filter(transaction, ds)) {</span><span class="s3">\n          </span><span class="s1">const encoder = new DSEncoderV1();</span><span class="s3">\n          </span><span class="s1">writeDeleteSet(encoder, ds);</span><span class="s3">\n          </span><span class="s1">yds.push([encoder.toUint8Array()]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} clientid</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getUserByClientId (clientid) {</span><span class="s3">\n    </span><span class="s1">return this.clients.get(clientid) || null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">* @return {string | null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getUserByDeletedId (id) {</span><span class="s3">\n    </span><span class="s1">for (const [userDescription, ds] of this.dss.entries()) {</span><span class="s3">\n      </span><span class="s1">if (isDeleted(ds, id)) {</span><span class="s3">\n        </span><span class="s1">return userDescription</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A relative position is based on the Yjs model and is not affected by document changes.</span><span class="s3">\n </span><span class="s1">* E.g. If you place a relative position before a certain character, it will always point to this character.</span><span class="s3">\n </span><span class="s1">* If you place a relative position at the end of a type, it will always point to the end of the type.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* A numeric position is often unsuited for user selections, because it does not change when content is inserted</span><span class="s3">\n </span><span class="s1">* before or after.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* One of the properties must be defined.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*   // Current cursor position is at position 10</span><span class="s3">\n </span><span class="s1">*   const relativePosition = createRelativePositionFromIndex(yText, 10)</span><span class="s3">\n </span><span class="s1">*   // modify yText</span><span class="s3">\n </span><span class="s1">*   yText.insert(0, 'abc')</span><span class="s3">\n </span><span class="s1">*   yText.delete(3, 10)</span><span class="s3">\n </span><span class="s1">*   // Compute the cursor position</span><span class="s3">\n </span><span class="s1">*   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)</span><span class="s3">\n </span><span class="s1">*   absolutePosition.type === yText // =&gt; true</span><span class="s3">\n </span><span class="s1">*   console.log('cursor location is ' + absolutePosition.index) // =&gt; cursor location is 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RelativePosition {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID|null} type</span><span class="s3">\n   </span><span class="s1">* @param {string|null} tname</span><span class="s3">\n   </span><span class="s1">* @param {ID|null} item</span><span class="s3">\n   </span><span class="s1">* @param {number} assoc</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (type, tname, item, assoc = 0) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {ID|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {string|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.tname = tname;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {ID | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.item = item;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A relative position is associated to a specific character. By default</span><span class="s3">\n     </span><span class="s1">* assoc &gt;= 0, the relative position is associated to the character</span><span class="s3">\n     </span><span class="s1">* after the meant position.</span><span class="s3">\n     </span><span class="s1">* I.e. position 1 in 'ab' is associated to character 'b'.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If assoc &lt; 0, then the relative position is associated to the caharacter</span><span class="s3">\n     </span><span class="s1">* before the meant position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.assoc = assoc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition} rpos</span><span class="s3">\n </span><span class="s1">* @return {any}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const relativePositionToJSON = rpos =&gt; {</span><span class="s3">\n  </span><span class="s1">const json = {};</span><span class="s3">\n  </span><span class="s1">if (rpos.type) {</span><span class="s3">\n    </span><span class="s1">json.type = rpos.type;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rpos.tname) {</span><span class="s3">\n    </span><span class="s1">json.tname = rpos.tname;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rpos.item) {</span><span class="s3">\n    </span><span class="s1">json.item = rpos.item;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rpos.assoc != null) {</span><span class="s3">\n    </span><span class="s1">json.assoc = rpos.assoc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return json</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} json</span><span class="s3">\n </span><span class="s1">* @return {RelativePosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createRelativePositionFromJSON = json =&gt; new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);</span><span class="s3">\n\n</span><span class="s1">class AbsolutePosition {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n   </span><span class="s1">* @param {number} index</span><span class="s3">\n   </span><span class="s1">* @param {number} [assoc]</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (type, index, assoc = 0) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {AbstractType&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.index = index;</span><span class="s3">\n    </span><span class="s1">this.assoc = assoc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @param {number} [assoc]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createAbsolutePosition = (type, index, assoc = 0) =&gt; new AbsolutePosition(type, index, assoc);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {ID|null} item</span><span class="s3">\n </span><span class="s1">* @param {number} [assoc]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createRelativePosition = (type, item, assoc) =&gt; {</span><span class="s3">\n  </span><span class="s1">let typeid = null;</span><span class="s3">\n  </span><span class="s1">let tname = null;</span><span class="s3">\n  </span><span class="s1">if (type._item === null) {</span><span class="s3">\n    </span><span class="s1">tname = findRootTypeKey(type);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">typeid = createID(type._item.id.client, type._item.id.clock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new RelativePosition(typeid, tname, item, assoc)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a relativePosition based on a absolute position.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type The base type (e.g. YText or YArray).</span><span class="s3">\n </span><span class="s1">* @param {number} index The absolute position.</span><span class="s3">\n </span><span class="s1">* @param {number} [assoc]</span><span class="s3">\n </span><span class="s1">* @return {RelativePosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createRelativePositionFromTypeIndex = (type, index, assoc = 0) =&gt; {</span><span class="s3">\n  </span><span class="s1">let t = type._start;</span><span class="s3">\n  </span><span class="s1">if (assoc &lt; 0) {</span><span class="s3">\n    </span><span class="s1">// associated to the left character or the beginning of a type, increment index if possible.</span><span class="s3">\n    </span><span class="s1">if (index === 0) {</span><span class="s3">\n      </span><span class="s1">return createRelativePosition(type, null, assoc)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">index--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (t !== null) {</span><span class="s3">\n    </span><span class="s1">if (!t.deleted &amp;&amp; t.countable) {</span><span class="s3">\n      </span><span class="s1">if (t.length &gt; index) {</span><span class="s3">\n        </span><span class="s1">// case 1: found position somewhere in the linked list</span><span class="s3">\n        </span><span class="s1">return createRelativePosition(type, createID(t.id.client, t.id.clock + index), assoc)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">index -= t.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (t.right === null &amp;&amp; assoc &lt; 0) {</span><span class="s3">\n      </span><span class="s1">// left-associated position, return last available id</span><span class="s3">\n      </span><span class="s1">return createRelativePosition(type, t.lastId, assoc)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">t = t.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return createRelativePosition(type, null, assoc)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {encoding.Encoder} encoder</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition} rpos</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeRelativePosition = (encoder, rpos) =&gt; {</span><span class="s3">\n  </span><span class="s1">const { type, tname, item, assoc } = rpos;</span><span class="s3">\n  </span><span class="s1">if (item !== null) {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, 0);</span><span class="s3">\n    </span><span class="s1">writeID(encoder, item);</span><span class="s3">\n  </span><span class="s1">} else if (tname !== null) {</span><span class="s3">\n    </span><span class="s1">// case 2: found position at the end of the list and type is stored in y.share</span><span class="s3">\n    </span><span class="s1">encoding.writeUint8(encoder, 1);</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(encoder, tname);</span><span class="s3">\n  </span><span class="s1">} else if (type !== null) {</span><span class="s3">\n    </span><span class="s1">// case 3: found position at the end of the list and type is attached to an item</span><span class="s3">\n    </span><span class="s1">encoding.writeUint8(encoder, 2);</span><span class="s3">\n    </span><span class="s1">writeID(encoder, type);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">encoding.writeVarInt(encoder, assoc);</span><span class="s3">\n  </span><span class="s1">return encoder</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition} rpos</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeRelativePosition = rpos =&gt; {</span><span class="s3">\n  </span><span class="s1">const encoder = encoding.createEncoder();</span><span class="s3">\n  </span><span class="s1">writeRelativePosition(encoder, rpos);</span><span class="s3">\n  </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {decoding.Decoder} decoder</span><span class="s3">\n </span><span class="s1">* @return {RelativePosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readRelativePosition = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">let type = null;</span><span class="s3">\n  </span><span class="s1">let tname = null;</span><span class="s3">\n  </span><span class="s1">let itemID = null;</span><span class="s3">\n  </span><span class="s1">switch (decoding.readVarUint(decoder)) {</span><span class="s3">\n    </span><span class="s1">case 0:</span><span class="s3">\n      </span><span class="s1">// case 1: found position somewhere in the linked list</span><span class="s3">\n      </span><span class="s1">itemID = readID(decoder);</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 1:</span><span class="s3">\n      </span><span class="s1">// case 2: found position at the end of the list and type is stored in y.share</span><span class="s3">\n      </span><span class="s1">tname = decoding.readVarString(decoder);</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case 2: {</span><span class="s3">\n      </span><span class="s1">// case 3: found position at the end of the list and type is attached to an item</span><span class="s3">\n      </span><span class="s1">type = readID(decoder);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const assoc = decoding.hasContent(decoder) ? decoding.readVarInt(decoder) : 0;</span><span class="s3">\n  </span><span class="s1">return new RelativePosition(type, tname, itemID, assoc)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} uint8Array</span><span class="s3">\n </span><span class="s1">* @return {RelativePosition}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeRelativePosition = uint8Array =&gt; readRelativePosition(decoding.createDecoder(uint8Array));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition} rpos</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @return {AbsolutePosition|null}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createAbsolutePositionFromRelativePosition = (rpos, doc) =&gt; {</span><span class="s3">\n  </span><span class="s1">const store = doc.store;</span><span class="s3">\n  </span><span class="s1">const rightID = rpos.item;</span><span class="s3">\n  </span><span class="s1">const typeID = rpos.type;</span><span class="s3">\n  </span><span class="s1">const tname = rpos.tname;</span><span class="s3">\n  </span><span class="s1">const assoc = rpos.assoc;</span><span class="s3">\n  </span><span class="s1">let type = null;</span><span class="s3">\n  </span><span class="s1">let index = 0;</span><span class="s3">\n  </span><span class="s1">if (rightID !== null) {</span><span class="s3">\n    </span><span class="s1">if (getState(store, rightID.client) &lt;= rightID.clock) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const res = followRedone(store, rightID);</span><span class="s3">\n    </span><span class="s1">const right = res.item;</span><span class="s3">\n    </span><span class="s1">if (!(right instanceof Item)) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">type = /** @type {AbstractType&lt;any&gt;} */ (right.parent);</span><span class="s3">\n    </span><span class="s1">if (type._item === null || !type._item.deleted) {</span><span class="s3">\n      </span><span class="s1">index = (right.deleted || !right.countable) ? 0 : (res.diff + (assoc &gt;= 0 ? 0 : 1)); // adjust position based on left association if necessary</span><span class="s3">\n      </span><span class="s1">let n = right.left;</span><span class="s3">\n      </span><span class="s1">while (n !== null) {</span><span class="s3">\n        </span><span class="s1">if (!n.deleted &amp;&amp; n.countable) {</span><span class="s3">\n          </span><span class="s1">index += n.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">n = n.left;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (tname !== null) {</span><span class="s3">\n      </span><span class="s1">type = doc.get(tname);</span><span class="s3">\n    </span><span class="s1">} else if (typeID !== null) {</span><span class="s3">\n      </span><span class="s1">if (getState(store, typeID.client) &lt;= typeID.clock) {</span><span class="s3">\n        </span><span class="s1">// type does not exist yet</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { item } = followRedone(store, typeID);</span><span class="s3">\n      </span><span class="s1">if (item instanceof Item &amp;&amp; item.content instanceof ContentType) {</span><span class="s3">\n        </span><span class="s1">type = item.content.type;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// struct is garbage collected</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (assoc &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">index = type._length;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">index = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return createAbsolutePosition(type, index, rpos.assoc)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition|null} a</span><span class="s3">\n </span><span class="s1">* @param {RelativePosition|null} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const compareRelativePositions = (a, b) =&gt; a === b || (</span><span class="s3">\n  </span><span class="s1">a !== null &amp;&amp; b !== null &amp;&amp; a.tname === b.tname &amp;&amp; compareIDs(a.item, b.item) &amp;&amp; compareIDs(a.type, b.type) &amp;&amp; a.assoc === b.assoc</span><span class="s3">\n</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">class Snapshot {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n   </span><span class="s1">* @param {Map&lt;number,number&gt;} sv state map</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (ds, sv) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {DeleteSet}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.ds = ds;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* State Map</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number,number&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.sv = sv;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snap1</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snap2</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const equalSnapshots = (snap1, snap2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const ds1 = snap1.ds.clients;</span><span class="s3">\n  </span><span class="s1">const ds2 = snap2.ds.clients;</span><span class="s3">\n  </span><span class="s1">const sv1 = snap1.sv;</span><span class="s3">\n  </span><span class="s1">const sv2 = snap2.sv;</span><span class="s3">\n  </span><span class="s1">if (sv1.size !== sv2.size || ds1.size !== ds2.size) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of sv1.entries()) {</span><span class="s3">\n    </span><span class="s1">if (sv2.get(key) !== value) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (const [client, dsitems1] of ds1.entries()) {</span><span class="s3">\n    </span><span class="s1">const dsitems2 = ds2.get(client) || [];</span><span class="s3">\n    </span><span class="s1">if (dsitems1.length !== dsitems2.length) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; dsitems1.length; i++) {</span><span class="s3">\n      </span><span class="s1">const dsitem1 = dsitems1[i];</span><span class="s3">\n      </span><span class="s1">const dsitem2 = dsitems2[i];</span><span class="s3">\n      </span><span class="s1">if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @param {DSEncoderV1 | DSEncoderV2} [encoder]</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) =&gt; {</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(encoder, snapshot.ds);</span><span class="s3">\n  </span><span class="s1">writeStateVector(encoder, snapshot.sv);</span><span class="s3">\n  </span><span class="s1">return encoder.toUint8Array()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeSnapshot = snapshot =&gt; encodeSnapshotV2(snapshot, new DSEncoderV1());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @param {DSDecoderV1 | DSDecoderV2} [decoder]</span><span class="s3">\n </span><span class="s1">* @return {Snapshot}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) =&gt; {</span><span class="s3">\n  </span><span class="s1">return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} buf</span><span class="s3">\n </span><span class="s1">* @return {Snapshot}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeSnapshot = buf =&gt; decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;number,number&gt;} sm</span><span class="s3">\n </span><span class="s1">* @return {Snapshot}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createSnapshot = (ds, sm) =&gt; new Snapshot(ds, sm);</span><span class="s3">\n\n</span><span class="s1">const emptySnapshot = createSnapshot(createDeleteSet(), new Map());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @return {Snapshot}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const snapshot = doc =&gt; createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Item} item</span><span class="s3">\n </span><span class="s1">* @param {Snapshot|undefined} snapshot</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @protected</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isVisible = (item, snapshot) =&gt; snapshot === undefined</span><span class="s3">\n  </span><span class="s1">? !item.deleted</span><span class="s3">\n  </span><span class="s1">: snapshot.sv.has(item.id.client) &amp;&amp; (snapshot.sv.get(item.id.client) || 0) &gt; item.id.clock &amp;&amp; !isDeleted(snapshot.ds, item.id);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const splitSnapshotAffectedStructs = (transaction, snapshot) =&gt; {</span><span class="s3">\n  </span><span class="s1">const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create);</span><span class="s3">\n  </span><span class="s1">const store = transaction.doc.store;</span><span class="s3">\n  </span><span class="s1">// check if we already split for this snapshot</span><span class="s3">\n  </span><span class="s1">if (!meta.has(snapshot)) {</span><span class="s3">\n    </span><span class="s1">snapshot.sv.forEach((clock, client) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (clock &lt; getState(store, client)) {</span><span class="s3">\n        </span><span class="s1">getItemCleanStart(transaction, createID(client, clock));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">iterateDeletedStructs(transaction, snapshot.ds, _item =&gt; {});</span><span class="s3">\n    </span><span class="s1">meta.add(snapshot);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*  const ydoc = new Y.Doc({ gc: false })</span><span class="s3">\n </span><span class="s1">*  ydoc.getText().insert(0, 'world!')</span><span class="s3">\n </span><span class="s1">*  const snapshot = Y.snapshot(ydoc)</span><span class="s3">\n </span><span class="s1">*  ydoc.getText().insert(0, 'hello ')</span><span class="s3">\n </span><span class="s1">*  const restored = Y.createDocFromSnapshot(ydoc, snapshot)</span><span class="s3">\n </span><span class="s1">*  assert(restored.getText().toString() === 'world!')</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Doc} originDoc</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc</span><span class="s3">\n </span><span class="s1">* @return {Doc}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (originDoc.gc) {</span><span class="s3">\n    </span><span class="s1">// we should not try to restore a GC-ed document, because some of the restored items might have their content deleted</span><span class="s3">\n    </span><span class="s1">throw new Error('Garbage-collection must be disabled in `originDoc`!')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const { sv, ds } = snapshot;</span><span class="s3">\n\n  </span><span class="s1">const encoder = new UpdateEncoderV2();</span><span class="s3">\n  </span><span class="s1">originDoc.transact(transaction =&gt; {</span><span class="s3">\n    </span><span class="s1">let size = 0;</span><span class="s3">\n    </span><span class="s1">sv.forEach(clock =&gt; {</span><span class="s3">\n      </span><span class="s1">if (clock &gt; 0) {</span><span class="s3">\n        </span><span class="s1">size++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, size);</span><span class="s3">\n    </span><span class="s1">// splitting the structs before writing them to the encoder</span><span class="s3">\n    </span><span class="s1">for (const [client, clock] of sv) {</span><span class="s3">\n      </span><span class="s1">if (clock === 0) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (clock &lt; getState(originDoc.store, client)) {</span><span class="s3">\n        </span><span class="s1">getItemCleanStart(transaction, createID(client, clock));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const structs = originDoc.store.clients.get(client) || [];</span><span class="s3">\n      </span><span class="s1">const lastStructIndex = findIndexSS(structs, clock - 1);</span><span class="s3">\n      </span><span class="s1">// write # encoded structs</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1);</span><span class="s3">\n      </span><span class="s1">encoder.writeClient(client);</span><span class="s3">\n      </span><span class="s1">// first clock written is 0</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, 0);</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt;= lastStructIndex; i++) {</span><span class="s3">\n        </span><span class="s1">structs[i].write(encoder, 0);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">writeDeleteSet(encoder, ds);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot');</span><span class="s3">\n  </span><span class="s1">return newDoc</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const snapshotContainsUpdateV2 = (snapshot, update, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new YDecoder(decoding.createDecoder(update));</span><span class="s3">\n  </span><span class="s1">const lazyDecoder = new LazyStructReader(updateDecoder, false);</span><span class="s3">\n  </span><span class="s1">for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {</span><span class="s3">\n    </span><span class="s1">if ((snapshot.sv.get(curr.id.client) || 0) &lt; curr.id.clock + curr.length) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const mergedDS = mergeDeleteSets([snapshot.ds, readDeleteSet(updateDecoder)]);</span><span class="s3">\n  </span><span class="s1">return equalDeleteSets(snapshot.ds, mergedDS)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const snapshotContainsUpdate = (snapshot, update) =&gt; snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">class StructStore {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number,Array&lt;GC|Item&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clients = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | { missing: Map&lt;number, number&gt;, update: Uint8Array }}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.pendingStructs = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | Uint8Array}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.pendingDs = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return the states as a Map&lt;client,clock&gt;.</span><span class="s3">\n </span><span class="s1">* Note that clock refers to the next expected clock id.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;number,number&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getStateVector = store =&gt; {</span><span class="s3">\n  </span><span class="s1">const sm = new Map();</span><span class="s3">\n  </span><span class="s1">store.clients.forEach((structs, client) =&gt; {</span><span class="s3">\n    </span><span class="s1">const struct = structs[structs.length - 1];</span><span class="s3">\n    </span><span class="s1">sm.set(client, struct.id.clock + struct.length);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return sm</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {number} client</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getState = (store, client) =&gt; {</span><span class="s3">\n  </span><span class="s1">const structs = store.clients.get(client);</span><span class="s3">\n  </span><span class="s1">if (structs === undefined) {</span><span class="s3">\n    </span><span class="s1">return 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const lastStruct = structs[structs.length - 1];</span><span class="s3">\n  </span><span class="s1">return lastStruct.id.clock + lastStruct.length</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {GC|Item} struct</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const addStruct = (store, struct) =&gt; {</span><span class="s3">\n  </span><span class="s1">let structs = store.clients.get(struct.id.client);</span><span class="s3">\n  </span><span class="s1">if (structs === undefined) {</span><span class="s3">\n    </span><span class="s1">structs = [];</span><span class="s3">\n    </span><span class="s1">store.clients.set(struct.id.client, structs);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const lastStruct = structs[structs.length - 1];</span><span class="s3">\n    </span><span class="s1">if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {</span><span class="s3">\n      </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">structs.push(struct);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Perform a binary search on a sorted array</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Item|GC&gt;} structs</span><span class="s3">\n </span><span class="s1">* @param {number} clock</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findIndexSS = (structs, clock) =&gt; {</span><span class="s3">\n  </span><span class="s1">let left = 0;</span><span class="s3">\n  </span><span class="s1">let right = structs.length - 1;</span><span class="s3">\n  </span><span class="s1">let mid = structs[right];</span><span class="s3">\n  </span><span class="s1">let midclock = mid.id.clock;</span><span class="s3">\n  </span><span class="s1">if (midclock === clock) {</span><span class="s3">\n    </span><span class="s1">return right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// @todo does it even make sense to pivot the search?</span><span class="s3">\n  </span><span class="s1">// If a good split misses, it might actually increase the time to find the correct item.</span><span class="s3">\n  </span><span class="s1">// Currently, the only advantage is that search with pivoting might find the item on the first try.</span><span class="s3">\n  </span><span class="s1">let midindex = math.floor((clock / (midclock + mid.length - 1)) * right); // pivoting the search</span><span class="s3">\n  </span><span class="s1">while (left &lt;= right) {</span><span class="s3">\n    </span><span class="s1">mid = structs[midindex];</span><span class="s3">\n    </span><span class="s1">midclock = mid.id.clock;</span><span class="s3">\n    </span><span class="s1">if (midclock &lt;= clock) {</span><span class="s3">\n      </span><span class="s1">if (clock &lt; midclock + mid.length) {</span><span class="s3">\n        </span><span class="s1">return midindex</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">left = midindex + 1;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">right = midindex - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">midindex = math.floor((left + right) / 2);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Always check state before looking for a struct in StructStore</span><span class="s3">\n  </span><span class="s1">// Therefore the case of not finding a struct is unexpected</span><span class="s3">\n  </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Expects that id is actually in store. This function throws or is an infinite loop otherwise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">* @return {GC|Item}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const find = (store, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;GC|Item&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">const structs = store.clients.get(id.client);</span><span class="s3">\n  </span><span class="s1">return structs[findIndexSS(structs, id.clock)]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Expects that id is actually in store. This function throws or is an infinite loop otherwise.</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getItem = /** @type {function(StructStore,ID):Item} */ (find);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Item|GC&gt;} structs</span><span class="s3">\n </span><span class="s1">* @param {number} clock</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findIndexCleanStart = (transaction, structs, clock) =&gt; {</span><span class="s3">\n  </span><span class="s1">const index = findIndexSS(structs, clock);</span><span class="s3">\n  </span><span class="s1">const struct = structs[index];</span><span class="s3">\n  </span><span class="s1">if (struct.id.clock &lt; clock &amp;&amp; struct instanceof Item) {</span><span class="s3">\n    </span><span class="s1">structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));</span><span class="s3">\n    </span><span class="s1">return index + 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return index</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Expects that id is actually in store. This function throws or is an infinite loop otherwise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">* @return {Item}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getItemCleanStart = (transaction, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">const structs = /** @type {Array&lt;Item&gt;} */ (transaction.doc.store.clients.get(id.client));</span><span class="s3">\n  </span><span class="s1">return structs[findIndexCleanStart(transaction, structs, id.clock)]</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Expects that id is actually in store. This function throws or is an infinite loop otherwise.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">* @return {Item}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getItemCleanEnd = (transaction, store, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;Item&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">// @ts-ignore</span><span class="s3">\n  </span><span class="s1">const structs = store.clients.get(id.client);</span><span class="s3">\n  </span><span class="s1">const index = findIndexSS(structs, id.clock);</span><span class="s3">\n  </span><span class="s1">const struct = structs[index];</span><span class="s3">\n  </span><span class="s1">if (id.clock !== struct.id.clock + struct.length - 1 &amp;&amp; struct.constructor !== GC) {</span><span class="s3">\n    </span><span class="s1">structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return struct</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Replace `item` with `newitem` in store</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {GC|Item} struct</span><span class="s3">\n </span><span class="s1">* @param {GC|Item} newStruct</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const replaceStruct = (store, struct, newStruct) =&gt; {</span><span class="s3">\n  </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(struct.id.client));</span><span class="s3">\n  </span><span class="s1">structs[findIndexSS(structs, struct.id.clock)] = newStruct;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterate over a range of structs</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Item|GC&gt;} structs</span><span class="s3">\n </span><span class="s1">* @param {number} clockStart Inclusive start</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">* @param {function(GC|Item):void} f</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const iterateStructs = (transaction, structs, clockStart, len, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (len === 0) {</span><span class="s3">\n    </span><span class="s1">return</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const clockEnd = clockStart + len;</span><span class="s3">\n  </span><span class="s1">let index = findIndexCleanStart(transaction, structs, clockStart);</span><span class="s3">\n  </span><span class="s1">let struct;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">struct = structs[index++];</span><span class="s3">\n    </span><span class="s1">if (clockEnd &lt; struct.id.clock + struct.length) {</span><span class="s3">\n      </span><span class="s1">findIndexCleanStart(transaction, structs, clockEnd);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">f(struct);</span><span class="s3">\n  </span><span class="s1">} while (index &lt; structs.length &amp;&amp; structs[index].id.clock &lt; clockEnd)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A transaction is created for every change on the Yjs model. It is possible</span><span class="s3">\n </span><span class="s1">* to bundle changes on the Yjs model in a single transaction to</span><span class="s3">\n </span><span class="s1">* minimize the number on messages sent and the number of observer calls.</span><span class="s3">\n </span><span class="s1">* If possible the user of this library should bundle as many changes as</span><span class="s3">\n </span><span class="s1">* possible. Here is an example to illustrate the advantages of bundling:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">* const map = y.define('map', YMap)</span><span class="s3">\n </span><span class="s1">* // Log content when change is triggered</span><span class="s3">\n </span><span class="s1">* map.observe(() =&gt; {</span><span class="s3">\n </span><span class="s1">*   console.log('change triggered')</span><span class="s3">\n </span><span class="s1">* })</span><span class="s3">\n </span><span class="s1">* // Each change on the map type triggers a log message:</span><span class="s3">\n </span><span class="s1">* map.set('a', 0) // =&gt; </span><span class="s3">\&quot;</span><span class="s1">change triggered</span><span class="s3">\&quot;\n </span><span class="s1">* map.set('b', 0) // =&gt; </span><span class="s3">\&quot;</span><span class="s1">change triggered</span><span class="s3">\&quot;\n </span><span class="s1">* // When put in a transaction, it will trigger the log after the transaction:</span><span class="s3">\n </span><span class="s1">* y.transact(() =&gt; {</span><span class="s3">\n </span><span class="s1">*   map.set('a', 1)</span><span class="s3">\n </span><span class="s1">*   map.set('b', 1)</span><span class="s3">\n </span><span class="s1">* }) // =&gt; </span><span class="s3">\&quot;</span><span class="s1">change triggered</span><span class="s3">\&quot;\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Transaction {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n   </span><span class="s1">* @param {any} origin</span><span class="s3">\n   </span><span class="s1">* @param {boolean} local</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (doc, origin, local) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The Yjs instance.</span><span class="s3">\n     </span><span class="s1">* @type {Doc}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.doc = doc;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Describes the set of deleted items by ids</span><span class="s3">\n     </span><span class="s1">* @type {DeleteSet}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.deleteSet = new DeleteSet();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Holds the state before the transaction started.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;Number,Number&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.beforeState = getStateVector(doc.store);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Holds the state after the transaction.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;Number,Number&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.afterState = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* All types that were directly modified (property added or child</span><span class="s3">\n     </span><span class="s1">* inserted/deleted). New types are not included in this Set.</span><span class="s3">\n     </span><span class="s1">* Maps from type to parentSubs (`item.parentSub = null` for YArray)</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;AbstractType&lt;YEvent&lt;any&gt;&gt;,Set&lt;String|null&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.changed = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Stores the events for the types that observe also child elements.</span><span class="s3">\n     </span><span class="s1">* It is mainly used by `observeDeep`.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;AbstractType&lt;YEvent&lt;any&gt;&gt;,Array&lt;YEvent&lt;any&gt;&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.changedParentTypes = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;AbstractStruct&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._mergeStructs = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {any}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.origin = origin;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Stores meta information on the transaction</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;any,any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.meta = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether this change originates from this doc.</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.local = local;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;Doc&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.subdocsAdded = new Set();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;Doc&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.subdocsRemoved = new Set();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;Doc&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.subdocsLoaded = new Set();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._needFormattingCleanup = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @return {boolean} Whether data was written.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeUpdateMessageFromTransaction = (encoder, transaction) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (transaction.deleteSet.clients.size === 0 &amp;&amp; !map.any(transaction.afterState, (clock, client) =&gt; transaction.beforeState.get(client) !== clock)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">sortAndMergeDeleteSet(transaction.deleteSet);</span><span class="s3">\n  </span><span class="s1">writeStructsFromTransaction(encoder, transaction);</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(encoder, transaction.deleteSet);</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* If `type.parent` was added in current transaction, `type` technically</span><span class="s3">\n </span><span class="s1">* did not change, it was just added and we should not fire events for `type`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;YEvent&lt;any&gt;&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {string|null} parentSub</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const addChangedTypeToTransaction = (transaction, type, parentSub) =&gt; {</span><span class="s3">\n  </span><span class="s1">const item = type._item;</span><span class="s3">\n  </span><span class="s1">if (item === null || (item.id.clock &lt; (transaction.beforeState.get(item.id.client) || 0) &amp;&amp; !item.deleted)) {</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(transaction.changed, type, set.create).add(parentSub);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;AbstractStruct&gt;} structs</span><span class="s3">\n </span><span class="s1">* @param {number} pos</span><span class="s3">\n </span><span class="s1">* @return {number} # of merged structs</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const tryToMergeWithLefts = (structs, pos) =&gt; {</span><span class="s3">\n  </span><span class="s1">let right = structs[pos];</span><span class="s3">\n  </span><span class="s1">let left = structs[pos - 1];</span><span class="s3">\n  </span><span class="s1">let i = pos;</span><span class="s3">\n  </span><span class="s1">for (; i &gt; 0; right = left, left = structs[--i - 1]) {</span><span class="s3">\n    </span><span class="s1">if (left.deleted === right.deleted &amp;&amp; left.constructor === right.constructor) {</span><span class="s3">\n      </span><span class="s1">if (left.mergeWith(right)) {</span><span class="s3">\n        </span><span class="s1">if (right instanceof Item &amp;&amp; right.parentSub !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (right.parent)._map.get(right.parentSub) === right) {</span><span class="s3">\n          </span><span class="s1">/** @type {AbstractType&lt;any&gt;} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">break</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const merged = pos - i;</span><span class="s3">\n  </span><span class="s1">if (merged) {</span><span class="s3">\n    </span><span class="s1">// remove all merged structs from the array</span><span class="s3">\n    </span><span class="s1">structs.splice(pos + 1 - merged, merged);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return merged</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {function(Item):boolean} gcFilter</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const tryGcDeleteSet = (ds, store, gcFilter) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [client, deleteItems] of ds.clients.entries()) {</span><span class="s3">\n    </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(client));</span><span class="s3">\n    </span><span class="s1">for (let di = deleteItems.length - 1; di &gt;= 0; di--) {</span><span class="s3">\n      </span><span class="s1">const deleteItem = deleteItems[di];</span><span class="s3">\n      </span><span class="s1">const endDeleteItemClock = deleteItem.clock + deleteItem.len;</span><span class="s3">\n      </span><span class="s1">for (</span><span class="s3">\n        </span><span class="s1">let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];</span><span class="s3">\n        </span><span class="s1">si &lt; structs.length &amp;&amp; struct.id.clock &lt; endDeleteItemClock;</span><span class="s3">\n        </span><span class="s1">struct = structs[++si]</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const struct = structs[si];</span><span class="s3">\n        </span><span class="s1">if (deleteItem.clock + deleteItem.len &lt;= struct.id.clock) {</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (struct instanceof Item &amp;&amp; struct.deleted &amp;&amp; !struct.keep &amp;&amp; gcFilter(struct)) {</span><span class="s3">\n          </span><span class="s1">struct.gc(store, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const tryMergeDeleteSet = (ds, store) =&gt; {</span><span class="s3">\n  </span><span class="s1">// try to merge deleted / gc'd items</span><span class="s3">\n  </span><span class="s1">// merge from right to left for better efficiecy and so we don't miss any merge targets</span><span class="s3">\n  </span><span class="s1">ds.clients.forEach((deleteItems, client) =&gt; {</span><span class="s3">\n    </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(client));</span><span class="s3">\n    </span><span class="s1">for (let di = deleteItems.length - 1; di &gt;= 0; di--) {</span><span class="s3">\n      </span><span class="s1">const deleteItem = deleteItems[di];</span><span class="s3">\n      </span><span class="s1">// start with merging the item next to the last deleted item</span><span class="s3">\n      </span><span class="s1">const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));</span><span class="s3">\n      </span><span class="s1">for (</span><span class="s3">\n        </span><span class="s1">let si = mostRightIndexToCheck, struct = structs[si];</span><span class="s3">\n        </span><span class="s1">si &gt; 0 &amp;&amp; struct.id.clock &gt;= deleteItem.clock;</span><span class="s3">\n        </span><span class="s1">struct = structs[si]</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">si -= 1 + tryToMergeWithLefts(structs, si);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} ds</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {function(Item):boolean} gcFilter</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const tryGc = (ds, store, gcFilter) =&gt; {</span><span class="s3">\n  </span><span class="s1">tryGcDeleteSet(ds, store, gcFilter);</span><span class="s3">\n  </span><span class="s1">tryMergeDeleteSet(ds, store);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Transaction&gt;} transactionCleanups</span><span class="s3">\n </span><span class="s1">* @param {number} i</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cleanupTransactions = (transactionCleanups, i) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (i &lt; transactionCleanups.length) {</span><span class="s3">\n    </span><span class="s1">const transaction = transactionCleanups[i];</span><span class="s3">\n    </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n    </span><span class="s1">const store = doc.store;</span><span class="s3">\n    </span><span class="s1">const ds = transaction.deleteSet;</span><span class="s3">\n    </span><span class="s1">const mergeStructs = transaction._mergeStructs;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">sortAndMergeDeleteSet(ds);</span><span class="s3">\n      </span><span class="s1">transaction.afterState = getStateVector(transaction.doc.store);</span><span class="s3">\n      </span><span class="s1">doc.emit('beforeObserverCalls', [transaction, doc]);</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* An array of event callbacks.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* Each callback is called even if the other ones throw errors.</span><span class="s3">\n       </span><span class="s1">*</span><span class="s3">\n       </span><span class="s1">* @type {Array&lt;function():void&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const fs = [];</span><span class="s3">\n      </span><span class="s1">// observe events on changed types</span><span class="s3">\n      </span><span class="s1">transaction.changed.forEach((subs, itemtype) =&gt;</span><span class="s3">\n        </span><span class="s1">fs.push(() =&gt; {</span><span class="s3">\n          </span><span class="s1">if (itemtype._item === null || !itemtype._item.deleted) {</span><span class="s3">\n            </span><span class="s1">itemtype._callObserver(transaction, subs);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">fs.push(() =&gt; {</span><span class="s3">\n        </span><span class="s1">// deep observe events</span><span class="s3">\n        </span><span class="s1">transaction.changedParentTypes.forEach((events, type) =&gt; {</span><span class="s3">\n          </span><span class="s1">// We need to think about the possibility that the user transforms the</span><span class="s3">\n          </span><span class="s1">// Y.Doc in the event.</span><span class="s3">\n          </span><span class="s1">if (type._dEH.l.length &gt; 0 &amp;&amp; (type._item === null || !type._item.deleted)) {</span><span class="s3">\n            </span><span class="s1">events = events</span><span class="s3">\n              </span><span class="s1">.filter(event =&gt;</span><span class="s3">\n                </span><span class="s1">event.target._item === null || !event.target._item.deleted</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">events</span><span class="s3">\n              </span><span class="s1">.forEach(event =&gt; {</span><span class="s3">\n                </span><span class="s1">event.currentTarget = type;</span><span class="s3">\n                </span><span class="s1">// path is relative to the current target</span><span class="s3">\n                </span><span class="s1">event._path = null;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">// sort events by path length so that top-level events are fired first.</span><span class="s3">\n            </span><span class="s1">events</span><span class="s3">\n              </span><span class="s1">.sort((event1, event2) =&gt; event1.path.length - event2.path.length);</span><span class="s3">\n            </span><span class="s1">// We don't need to check for events.length</span><span class="s3">\n            </span><span class="s1">// because we know it has at least one element</span><span class="s3">\n            </span><span class="s1">callEventHandlerListeners(type._dEH, events, transaction);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">fs.push(() =&gt; doc.emit('afterTransaction', [transaction, doc]));</span><span class="s3">\n      </span><span class="s1">callAll(fs, []);</span><span class="s3">\n      </span><span class="s1">if (transaction._needFormattingCleanup) {</span><span class="s3">\n        </span><span class="s1">cleanupYTextAfterTransaction(transaction);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">// Replace deleted items with ItemDeleted / GC.</span><span class="s3">\n      </span><span class="s1">// This is where content is actually remove from the Yjs Doc.</span><span class="s3">\n      </span><span class="s1">if (doc.gc) {</span><span class="s3">\n        </span><span class="s1">tryGcDeleteSet(ds, store, doc.gcFilter);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">tryMergeDeleteSet(ds, store);</span><span class="s3">\n\n      </span><span class="s1">// on all affected store.clients props, try to merge</span><span class="s3">\n      </span><span class="s1">transaction.afterState.forEach((clock, client) =&gt; {</span><span class="s3">\n        </span><span class="s1">const beforeClock = transaction.beforeState.get(client) || 0;</span><span class="s3">\n        </span><span class="s1">if (beforeClock !== clock) {</span><span class="s3">\n          </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(client));</span><span class="s3">\n          </span><span class="s1">// we iterate from right to left so we can safely remove entries</span><span class="s3">\n          </span><span class="s1">const firstChangePos = math.max(findIndexSS(structs, beforeClock), 1);</span><span class="s3">\n          </span><span class="s1">for (let i = structs.length - 1; i &gt;= firstChangePos;) {</span><span class="s3">\n            </span><span class="s1">i -= 1 + tryToMergeWithLefts(structs, i);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">// try to merge mergeStructs</span><span class="s3">\n      </span><span class="s1">// @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left</span><span class="s3">\n      </span><span class="s1">//        but at the moment DS does not handle duplicates</span><span class="s3">\n      </span><span class="s1">for (let i = mergeStructs.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">const { client, clock } = mergeStructs[i].id;</span><span class="s3">\n        </span><span class="s1">const structs = /** @type {Array&lt;GC|Item&gt;} */ (store.clients.get(client));</span><span class="s3">\n        </span><span class="s1">const replacedStructPos = findIndexSS(structs, clock);</span><span class="s3">\n        </span><span class="s1">if (replacedStructPos + 1 &lt; structs.length) {</span><span class="s3">\n          </span><span class="s1">if (tryToMergeWithLefts(structs, replacedStructPos + 1) &gt; 1) {</span><span class="s3">\n            </span><span class="s1">continue // no need to perform next check, both are already merged</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (replacedStructPos &gt; 0) {</span><span class="s3">\n          </span><span class="s1">tryToMergeWithLefts(structs, replacedStructPos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!transaction.local &amp;&amp; transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {</span><span class="s3">\n        </span><span class="s1">logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.');</span><span class="s3">\n        </span><span class="s1">doc.clientID = generateNewClientId();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// @todo Merge all the transactions into one and provide send the data as a single update message</span><span class="s3">\n      </span><span class="s1">doc.emit('afterTransactionCleanup', [transaction, doc]);</span><span class="s3">\n      </span><span class="s1">if (doc._observers.has('update')) {</span><span class="s3">\n        </span><span class="s1">const encoder = new UpdateEncoderV1();</span><span class="s3">\n        </span><span class="s1">const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);</span><span class="s3">\n        </span><span class="s1">if (hasContent) {</span><span class="s3">\n          </span><span class="s1">doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (doc._observers.has('updateV2')) {</span><span class="s3">\n        </span><span class="s1">const encoder = new UpdateEncoderV2();</span><span class="s3">\n        </span><span class="s1">const hasContent = writeUpdateMessageFromTransaction(encoder, transaction);</span><span class="s3">\n        </span><span class="s1">if (hasContent) {</span><span class="s3">\n          </span><span class="s1">doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;</span><span class="s3">\n      </span><span class="s1">if (subdocsAdded.size &gt; 0 || subdocsRemoved.size &gt; 0 || subdocsLoaded.size &gt; 0) {</span><span class="s3">\n        </span><span class="s1">subdocsAdded.forEach(subdoc =&gt; {</span><span class="s3">\n          </span><span class="s1">subdoc.clientID = doc.clientID;</span><span class="s3">\n          </span><span class="s1">if (subdoc.collectionid == null) {</span><span class="s3">\n            </span><span class="s1">subdoc.collectionid = doc.collectionid;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">doc.subdocs.add(subdoc);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">subdocsRemoved.forEach(subdoc =&gt; doc.subdocs.delete(subdoc));</span><span class="s3">\n        </span><span class="s1">doc.emit('subdocs', [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc, transaction]);</span><span class="s3">\n        </span><span class="s1">subdocsRemoved.forEach(subdoc =&gt; subdoc.destroy());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (transactionCleanups.length &lt;= i + 1) {</span><span class="s3">\n        </span><span class="s1">doc._transactionCleanups = [];</span><span class="s3">\n        </span><span class="s1">doc.emit('afterAllTransactions', [doc, transactionCleanups]);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">cleanupTransactions(transactionCleanups, i + 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Implements the functionality of `y.transact(()=&gt;{..})`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n </span><span class="s1">* @param {function(Transaction):T} f</span><span class="s3">\n </span><span class="s1">* @param {any} [origin=true]</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const transact = (doc, f, origin = null, local = true) =&gt; {</span><span class="s3">\n  </span><span class="s1">const transactionCleanups = doc._transactionCleanups;</span><span class="s3">\n  </span><span class="s1">let initialCall = false;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let result = null;</span><span class="s3">\n  </span><span class="s1">if (doc._transaction === null) {</span><span class="s3">\n    </span><span class="s1">initialCall = true;</span><span class="s3">\n    </span><span class="s1">doc._transaction = new Transaction(doc, origin, local);</span><span class="s3">\n    </span><span class="s1">transactionCleanups.push(doc._transaction);</span><span class="s3">\n    </span><span class="s1">if (transactionCleanups.length === 1) {</span><span class="s3">\n      </span><span class="s1">doc.emit('beforeAllTransactions', [doc]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">doc.emit('beforeTransaction', [doc._transaction, doc]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">result = f(doc._transaction);</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">if (initialCall) {</span><span class="s3">\n      </span><span class="s1">const finishCleanup = doc._transaction === transactionCleanups[0];</span><span class="s3">\n      </span><span class="s1">doc._transaction = null;</span><span class="s3">\n      </span><span class="s1">if (finishCleanup) {</span><span class="s3">\n        </span><span class="s1">// The first transaction ended, now process observer calls.</span><span class="s3">\n        </span><span class="s1">// Observer call may create new transactions for which we need to call the observers and do cleanup.</span><span class="s3">\n        </span><span class="s1">// We don't want to nest these calls, so we execute these calls one after</span><span class="s3">\n        </span><span class="s1">// another.</span><span class="s3">\n        </span><span class="s1">// Also we need to ensure that all cleanups are called, even if the</span><span class="s3">\n        </span><span class="s1">// observes throw errors.</span><span class="s3">\n        </span><span class="s1">// This file is full of hacky try {} finally {} blocks to ensure that an</span><span class="s3">\n        </span><span class="s1">// event can throw errors and also that the cleanup is called.</span><span class="s3">\n        </span><span class="s1">cleanupTransactions(transactionCleanups, 0);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">class StackItem {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {DeleteSet} deletions</span><span class="s3">\n   </span><span class="s1">* @param {DeleteSet} insertions</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (deletions, insertions) {</span><span class="s3">\n    </span><span class="s1">this.insertions = insertions;</span><span class="s3">\n    </span><span class="s1">this.deletions = deletions;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Use this to save and restore metadata like selection range</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.meta = new Map();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} tr</span><span class="s3">\n </span><span class="s1">* @param {UndoManager} um</span><span class="s3">\n </span><span class="s1">* @param {StackItem} stackItem</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const clearUndoManagerStackItem = (tr, um, stackItem) =&gt; {</span><span class="s3">\n  </span><span class="s1">iterateDeletedStructs(tr, stackItem.deletions, item =&gt; {</span><span class="s3">\n    </span><span class="s1">if (item instanceof Item &amp;&amp; um.scope.some(type =&gt; isParentOf(type, item))) {</span><span class="s3">\n      </span><span class="s1">keepItem(item, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UndoManager} undoManager</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;StackItem&gt;} stack</span><span class="s3">\n </span><span class="s1">* @param {string} eventType</span><span class="s3">\n </span><span class="s1">* @return {StackItem?}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const popStackItem = (undoManager, stack, eventType) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether a change happened</span><span class="s3">\n   </span><span class="s1">* @type {StackItem?}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let result = null;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Keep a reference to the transaction so we can fire the event with the changedParentTypes</span><span class="s3">\n   </span><span class="s1">* @type {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let _tr = null;</span><span class="s3">\n  </span><span class="s1">const doc = undoManager.doc;</span><span class="s3">\n  </span><span class="s1">const scope = undoManager.scope;</span><span class="s3">\n  </span><span class="s1">transact(doc, transaction =&gt; {</span><span class="s3">\n    </span><span class="s1">while (stack.length &gt; 0 &amp;&amp; result === null) {</span><span class="s3">\n      </span><span class="s1">const store = doc.store;</span><span class="s3">\n      </span><span class="s1">const stackItem = /** @type {StackItem} */ (stack.pop());</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Set&lt;Item&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const itemsToRedo = new Set();</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Array&lt;Item&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const itemsToDelete = [];</span><span class="s3">\n      </span><span class="s1">let performedChange = false;</span><span class="s3">\n      </span><span class="s1">iterateDeletedStructs(transaction, stackItem.insertions, struct =&gt; {</span><span class="s3">\n        </span><span class="s1">if (struct instanceof Item) {</span><span class="s3">\n          </span><span class="s1">if (struct.redone !== null) {</span><span class="s3">\n            </span><span class="s1">let { item, diff } = followRedone(store, struct.id);</span><span class="s3">\n            </span><span class="s1">if (diff &gt; 0) {</span><span class="s3">\n              </span><span class="s1">item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">struct = item;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!struct.deleted &amp;&amp; scope.some(type =&gt; isParentOf(type, /** @type {Item} */ (struct)))) {</span><span class="s3">\n            </span><span class="s1">itemsToDelete.push(struct);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">iterateDeletedStructs(transaction, stackItem.deletions, struct =&gt; {</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n          </span><span class="s1">struct instanceof Item &amp;&amp;</span><span class="s3">\n          </span><span class="s1">scope.some(type =&gt; isParentOf(type, struct)) &amp;&amp;</span><span class="s3">\n          </span><span class="s1">// Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.</span><span class="s3">\n          </span><span class="s1">!isDeleted(stackItem.insertions, struct.id)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">itemsToRedo.add(struct);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">itemsToRedo.forEach(struct =&gt; {</span><span class="s3">\n        </span><span class="s1">performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">// We want to delete in reverse order so that children are deleted before</span><span class="s3">\n      </span><span class="s1">// parents, so we have more information available when items are filtered.</span><span class="s3">\n      </span><span class="s1">for (let i = itemsToDelete.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">const item = itemsToDelete[i];</span><span class="s3">\n        </span><span class="s1">if (undoManager.deleteFilter(item)) {</span><span class="s3">\n          </span><span class="s1">item.delete(transaction);</span><span class="s3">\n          </span><span class="s1">performedChange = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result = performedChange ? stackItem : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">transaction.changed.forEach((subProps, type) =&gt; {</span><span class="s3">\n      </span><span class="s1">// destroy search marker if necessary</span><span class="s3">\n      </span><span class="s1">if (subProps.has(null) &amp;&amp; type._searchMarker) {</span><span class="s3">\n        </span><span class="s1">type._searchMarker.length = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">_tr = transaction;</span><span class="s3">\n  </span><span class="s1">}, undoManager);</span><span class="s3">\n  </span><span class="s1">if (result != null) {</span><span class="s3">\n    </span><span class="s1">const changedParentTypes = _tr.changedParentTypes;</span><span class="s3">\n    </span><span class="s1">undoManager.emit('stack-item-popped', [{ stackItem: result, type: eventType, changedParentTypes }, undoManager]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {Object} UndoManagerOptions</span><span class="s3">\n </span><span class="s1">* @property {number} [UndoManagerOptions.captureTimeout=500]</span><span class="s3">\n </span><span class="s1">* @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.</span><span class="s3">\n </span><span class="s1">* @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=&gt;true] Sometimes</span><span class="s3">\n </span><span class="s1">* it is necessary to filter what an Undo/Redo operation can delete. If this</span><span class="s3">\n </span><span class="s1">* filter returns false, the type/item won't be deleted even it is in the</span><span class="s3">\n </span><span class="s1">* undo/redo scope.</span><span class="s3">\n </span><span class="s1">* @property {Set&lt;any&gt;} [UndoManagerOptions.trackedOrigins=new Set([null])]</span><span class="s3">\n </span><span class="s1">* @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).</span><span class="s3">\n </span><span class="s1">* @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Fires 'stack-item-added' event when a stack item was added to either the undo- or</span><span class="s3">\n </span><span class="s1">* the redo-stack. You may store additional stack information via the</span><span class="s3">\n </span><span class="s1">* metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).</span><span class="s3">\n </span><span class="s1">* Fires 'stack-item-popped' event when a stack item was popped from either the</span><span class="s3">\n </span><span class="s1">* undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends {Observable&lt;'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class UndoManager extends Observable {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {AbstractType&lt;any&gt;|Array&lt;AbstractType&lt;any&gt;&gt;} typeScope Accepts either a single type, or an array of types</span><span class="s3">\n   </span><span class="s1">* @param {UndoManagerOptions} options</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (typeScope, {</span><span class="s3">\n    </span><span class="s1">captureTimeout = 500,</span><span class="s3">\n    </span><span class="s1">captureTransaction = _tr =&gt; true,</span><span class="s3">\n    </span><span class="s1">deleteFilter = () =&gt; true,</span><span class="s3">\n    </span><span class="s1">trackedOrigins = new Set([null]),</span><span class="s3">\n    </span><span class="s1">ignoreRemoteMapChanges = false,</span><span class="s3">\n    </span><span class="s1">doc = /** @type {Doc} */ (array.isArray(typeScope) ? typeScope[0].doc : typeScope.doc)</span><span class="s3">\n  </span><span class="s1">} = {}) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;AbstractType&lt;any&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.scope = [];</span><span class="s3">\n    </span><span class="s1">this.doc = doc;</span><span class="s3">\n    </span><span class="s1">this.addToScope(typeScope);</span><span class="s3">\n    </span><span class="s1">this.deleteFilter = deleteFilter;</span><span class="s3">\n    </span><span class="s1">trackedOrigins.add(this);</span><span class="s3">\n    </span><span class="s1">this.trackedOrigins = trackedOrigins;</span><span class="s3">\n    </span><span class="s1">this.captureTransaction = captureTransaction;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;StackItem&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.undoStack = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;StackItem&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.redoStack = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the client is currently undoing (calling UndoManager.undo)</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {boolean}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.undoing = false;</span><span class="s3">\n    </span><span class="s1">this.redoing = false;</span><span class="s3">\n    </span><span class="s1">this.lastChange = 0;</span><span class="s3">\n    </span><span class="s1">this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;</span><span class="s3">\n    </span><span class="s1">this.captureTimeout = captureTimeout;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.afterTransactionHandler = transaction =&gt; {</span><span class="s3">\n      </span><span class="s1">// Only track certain transactions</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!this.captureTransaction(transaction) ||</span><span class="s3">\n        </span><span class="s1">!this.scope.some(type =&gt; transaction.changedParentTypes.has(type)) ||</span><span class="s3">\n        </span><span class="s1">(!this.trackedOrigins.has(transaction.origin) &amp;&amp; (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor)))</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const undoing = this.undoing;</span><span class="s3">\n      </span><span class="s1">const redoing = this.redoing;</span><span class="s3">\n      </span><span class="s1">const stack = undoing ? this.redoStack : this.undoStack;</span><span class="s3">\n      </span><span class="s1">if (undoing) {</span><span class="s3">\n        </span><span class="s1">this.stopCapturing(); // next undo should not be appended to last stack item</span><span class="s3">\n      </span><span class="s1">} else if (!redoing) {</span><span class="s3">\n        </span><span class="s1">// neither undoing nor redoing: delete redoStack</span><span class="s3">\n        </span><span class="s1">this.clear(false, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const insertions = new DeleteSet();</span><span class="s3">\n      </span><span class="s1">transaction.afterState.forEach((endClock, client) =&gt; {</span><span class="s3">\n        </span><span class="s1">const startClock = transaction.beforeState.get(client) || 0;</span><span class="s3">\n        </span><span class="s1">const len = endClock - startClock;</span><span class="s3">\n        </span><span class="s1">if (len &gt; 0) {</span><span class="s3">\n          </span><span class="s1">addToDeleteSet(insertions, client, startClock, len);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const now = time.getUnixTime();</span><span class="s3">\n      </span><span class="s1">let didAdd = false;</span><span class="s3">\n      </span><span class="s1">if (this.lastChange &gt; 0 &amp;&amp; now - this.lastChange &lt; this.captureTimeout &amp;&amp; stack.length &gt; 0 &amp;&amp; !undoing &amp;&amp; !redoing) {</span><span class="s3">\n        </span><span class="s1">// append change to last stack op</span><span class="s3">\n        </span><span class="s1">const lastOp = stack[stack.length - 1];</span><span class="s3">\n        </span><span class="s1">lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);</span><span class="s3">\n        </span><span class="s1">lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// create a new stack op</span><span class="s3">\n        </span><span class="s1">stack.push(new StackItem(transaction.deleteSet, insertions));</span><span class="s3">\n        </span><span class="s1">didAdd = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!undoing &amp;&amp; !redoing) {</span><span class="s3">\n        </span><span class="s1">this.lastChange = now;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// make sure that deleted structs are not gc'd</span><span class="s3">\n      </span><span class="s1">iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */ item =&gt; {</span><span class="s3">\n        </span><span class="s1">if (item instanceof Item &amp;&amp; this.scope.some(type =&gt; isParentOf(type, item))) {</span><span class="s3">\n          </span><span class="s1">keepItem(item, true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? 'redo' : 'undo', changedParentTypes: transaction.changedParentTypes }, this];</span><span class="s3">\n      </span><span class="s1">if (didAdd) {</span><span class="s3">\n        </span><span class="s1">this.emit('stack-item-added', changeEvent);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.emit('stack-item-updated', changeEvent);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">this.doc.on('afterTransaction', this.afterTransactionHandler);</span><span class="s3">\n    </span><span class="s1">this.doc.on('destroy', () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.destroy();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;AbstractType&lt;any&gt;&gt; | AbstractType&lt;any&gt;} ytypes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">addToScope (ytypes) {</span><span class="s3">\n    </span><span class="s1">ytypes = array.isArray(ytypes) ? ytypes : [ytypes];</span><span class="s3">\n    </span><span class="s1">ytypes.forEach(ytype =&gt; {</span><span class="s3">\n      </span><span class="s1">if (this.scope.every(yt =&gt; yt !== ytype)) {</span><span class="s3">\n        </span><span class="s1">if (ytype.doc !== this.doc) logging.warn('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509</span><span class="s3">\n        </span><span class="s1">this.scope.push(ytype);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} origin</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">addTrackedOrigin (origin) {</span><span class="s3">\n    </span><span class="s1">this.trackedOrigins.add(origin);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} origin</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeTrackedOrigin (origin) {</span><span class="s3">\n    </span><span class="s1">this.trackedOrigins.delete(origin);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">clear (clearUndoStack = true, clearRedoStack = true) {</span><span class="s3">\n    </span><span class="s1">if ((clearUndoStack &amp;&amp; this.canUndo()) || (clearRedoStack &amp;&amp; this.canRedo())) {</span><span class="s3">\n      </span><span class="s1">this.doc.transact(tr =&gt; {</span><span class="s3">\n        </span><span class="s1">if (clearUndoStack) {</span><span class="s3">\n          </span><span class="s1">this.undoStack.forEach(item =&gt; clearUndoManagerStackItem(tr, this, item));</span><span class="s3">\n          </span><span class="s1">this.undoStack = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (clearRedoStack) {</span><span class="s3">\n          </span><span class="s1">this.redoStack.forEach(item =&gt; clearUndoManagerStackItem(tr, this, item));</span><span class="s3">\n          </span><span class="s1">this.redoStack = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.emit('stack-cleared', [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* UndoManager merges Undo-StackItem if they are created within time-gap</span><span class="s3">\n   </span><span class="s1">* smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next</span><span class="s3">\n   </span><span class="s1">* StackItem won't be merged.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*     // without stopCapturing</span><span class="s3">\n   </span><span class="s1">*     ytext.insert(0, 'a')</span><span class="s3">\n   </span><span class="s1">*     ytext.insert(1, 'b')</span><span class="s3">\n   </span><span class="s1">*     um.undo()</span><span class="s3">\n   </span><span class="s1">*     ytext.toString() // =&gt; '' (note that 'ab' was removed)</span><span class="s3">\n   </span><span class="s1">*     // with stopCapturing</span><span class="s3">\n   </span><span class="s1">*     ytext.insert(0, 'a')</span><span class="s3">\n   </span><span class="s1">*     um.stopCapturing()</span><span class="s3">\n   </span><span class="s1">*     ytext.insert(0, 'b')</span><span class="s3">\n   </span><span class="s1">*     um.undo()</span><span class="s3">\n   </span><span class="s1">*     ytext.toString() // =&gt; 'a' (note that only 'b' was removed)</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">stopCapturing () {</span><span class="s3">\n    </span><span class="s1">this.lastChange = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Undo last changes on type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {StackItem?} Returns StackItem if a change was applied</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">undo () {</span><span class="s3">\n    </span><span class="s1">this.undoing = true;</span><span class="s3">\n    </span><span class="s1">let res;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">res = popStackItem(this, this.undoStack, 'undo');</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">this.undoing = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Redo last undo operation.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {StackItem?} Returns StackItem if a change was applied</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">redo () {</span><span class="s3">\n    </span><span class="s1">this.redoing = true;</span><span class="s3">\n    </span><span class="s1">let res;</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">res = popStackItem(this, this.redoStack, 'redo');</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">this.redoing = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return res</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Are undo steps available?</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {boolean} `true` if undo is possible</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">canUndo () {</span><span class="s3">\n    </span><span class="s1">return this.undoStack.length &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Are redo steps available?</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {boolean} `true` if redo is possible</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">canRedo () {</span><span class="s3">\n    </span><span class="s1">return this.redoStack.length &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this.trackedOrigins.delete(this);</span><span class="s3">\n    </span><span class="s1">this.doc.off('afterTransaction', this.afterTransactionHandler);</span><span class="s3">\n    </span><span class="s1">super.destroy();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function * lazyStructReaderGenerator (decoder) {</span><span class="s3">\n  </span><span class="s1">const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; numOfStateUpdates; i++) {</span><span class="s3">\n    </span><span class="s1">const numberOfStructs = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">const client = decoder.readClient();</span><span class="s3">\n    </span><span class="s1">let clock = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; numberOfStructs; i++) {</span><span class="s3">\n      </span><span class="s1">const info = decoder.readInfo();</span><span class="s3">\n      </span><span class="s1">// @todo use switch instead of ifs</span><span class="s3">\n      </span><span class="s1">if (info === 10) {</span><span class="s3">\n        </span><span class="s1">const len = decoding.readVarUint(decoder.restDecoder);</span><span class="s3">\n        </span><span class="s1">yield new Skip(createID(client, clock), len);</span><span class="s3">\n        </span><span class="s1">clock += len;</span><span class="s3">\n      </span><span class="s1">} else if ((binary.BITS5 &amp; info) !== 0) {</span><span class="s3">\n        </span><span class="s1">const cantCopyParentInfo = (info &amp; (binary.BIT7 | binary.BIT8)) === 0;</span><span class="s3">\n        </span><span class="s1">// If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`</span><span class="s3">\n        </span><span class="s1">// and we read the next string as parentYKey.</span><span class="s3">\n        </span><span class="s1">// It indicates how we store/retrieve parent from `y.share`</span><span class="s3">\n        </span><span class="s1">// @type {string|null}</span><span class="s3">\n        </span><span class="s1">const struct = new Item(</span><span class="s3">\n          </span><span class="s1">createID(client, clock),</span><span class="s3">\n          </span><span class="s1">null, // left</span><span class="s3">\n          </span><span class="s1">(info &amp; binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin</span><span class="s3">\n          </span><span class="s1">null, // right</span><span class="s3">\n          </span><span class="s1">(info &amp; binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin</span><span class="s3">\n          </span><span class="s1">// @ts-ignore Force writing a string here.</span><span class="s3">\n          </span><span class="s1">cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent</span><span class="s3">\n          </span><span class="s1">cantCopyParentInfo &amp;&amp; (info &amp; binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub</span><span class="s3">\n          </span><span class="s1">readItemContent(decoder, info) // item content</span><span class="s3">\n        </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">yield struct;</span><span class="s3">\n        </span><span class="s1">clock += struct.length;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const len = decoder.readLen();</span><span class="s3">\n        </span><span class="s1">yield new GC(createID(client, clock), len);</span><span class="s3">\n        </span><span class="s1">clock += len;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class LazyStructReader {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n   </span><span class="s1">* @param {boolean} filterSkips</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (decoder, filterSkips) {</span><span class="s3">\n    </span><span class="s1">this.gen = lazyStructReaderGenerator(decoder);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | Item | Skip | GC}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.curr = null;</span><span class="s3">\n    </span><span class="s1">this.done = false;</span><span class="s3">\n    </span><span class="s1">this.filterSkips = filterSkips;</span><span class="s3">\n    </span><span class="s1">this.next();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Item | GC | Skip |null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">next () {</span><span class="s3">\n    </span><span class="s1">// ignore </span><span class="s3">\&quot;</span><span class="s1">Skip</span><span class="s3">\&quot; </span><span class="s1">structs</span><span class="s3">\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">this.curr = this.gen.next().value || null;</span><span class="s3">\n    </span><span class="s1">} while (this.filterSkips &amp;&amp; this.curr !== null &amp;&amp; this.curr.constructor === Skip)</span><span class="s3">\n    </span><span class="s1">return this.curr</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const logUpdate = update =&gt; logUpdateV2(update, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const logUpdateV2 = (update, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const structs = [];</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new YDecoder(decoding.createDecoder(update));</span><span class="s3">\n  </span><span class="s1">const lazyDecoder = new LazyStructReader(updateDecoder, false);</span><span class="s3">\n  </span><span class="s1">for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {</span><span class="s3">\n    </span><span class="s1">structs.push(curr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">logging.print('Structs: ', structs);</span><span class="s3">\n  </span><span class="s1">const ds = readDeleteSet(updateDecoder);</span><span class="s3">\n  </span><span class="s1">logging.print('DeleteSet: ', ds);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeUpdate = (update) =&gt; decodeUpdateV2(update, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const decodeUpdateV2 = (update, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const structs = [];</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new YDecoder(decoding.createDecoder(update));</span><span class="s3">\n  </span><span class="s1">const lazyDecoder = new LazyStructReader(updateDecoder, false);</span><span class="s3">\n  </span><span class="s1">for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {</span><span class="s3">\n    </span><span class="s1">structs.push(curr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">structs,</span><span class="s3">\n    </span><span class="s1">ds: readDeleteSet(updateDecoder)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">class LazyStructWriter {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (encoder) {</span><span class="s3">\n    </span><span class="s1">this.currClient = 0;</span><span class="s3">\n    </span><span class="s1">this.startClock = 0;</span><span class="s3">\n    </span><span class="s1">this.written = 0;</span><span class="s3">\n    </span><span class="s1">this.encoder = encoder;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.</span><span class="s3">\n     </span><span class="s1">* When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;{ written: number, restEncoder: Uint8Array }&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clientStructs = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Uint8Array&gt;} updates</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const mergeUpdates = updates =&gt; mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const encoder = new YEncoder();</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);</span><span class="s3">\n  </span><span class="s1">let curr = updateDecoder.curr;</span><span class="s3">\n  </span><span class="s1">if (curr !== null) {</span><span class="s3">\n    </span><span class="s1">let size = 0;</span><span class="s3">\n    </span><span class="s1">let currClient = curr.id.client;</span><span class="s3">\n    </span><span class="s1">let stopCounting = curr.id.clock !== 0; // must start at 0</span><span class="s3">\n    </span><span class="s1">let currClock = stopCounting ? 0 : curr.id.clock + curr.length;</span><span class="s3">\n    </span><span class="s1">for (; curr !== null; curr = updateDecoder.next()) {</span><span class="s3">\n      </span><span class="s1">if (currClient !== curr.id.client) {</span><span class="s3">\n        </span><span class="s1">if (currClock !== 0) {</span><span class="s3">\n          </span><span class="s1">size++;</span><span class="s3">\n          </span><span class="s1">// We found a new client</span><span class="s3">\n          </span><span class="s1">// write what we have to the encoder</span><span class="s3">\n          </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, currClient);</span><span class="s3">\n          </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, currClock);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">currClient = curr.id.client;</span><span class="s3">\n        </span><span class="s1">currClock = 0;</span><span class="s3">\n        </span><span class="s1">stopCounting = curr.id.clock !== 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// we ignore skips</span><span class="s3">\n      </span><span class="s1">if (curr.constructor === Skip) {</span><span class="s3">\n        </span><span class="s1">stopCounting = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!stopCounting) {</span><span class="s3">\n        </span><span class="s1">currClock = curr.id.clock + curr.length;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// write what we have</span><span class="s3">\n    </span><span class="s1">if (currClock !== 0) {</span><span class="s3">\n      </span><span class="s1">size++;</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, currClient);</span><span class="s3">\n      </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, currClock);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// prepend the size of the state vector</span><span class="s3">\n    </span><span class="s1">const enc = encoding.createEncoder();</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(enc, size);</span><span class="s3">\n    </span><span class="s1">encoding.writeBinaryEncoder(enc, encoder.restEncoder);</span><span class="s3">\n    </span><span class="s1">encoder.restEncoder = enc;</span><span class="s3">\n    </span><span class="s1">return encoder.toUint8Array()</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, 0);</span><span class="s3">\n    </span><span class="s1">return encoder.toUint8Array()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const encodeStateVectorFromUpdate = update =&gt; encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder</span><span class="s3">\n </span><span class="s1">* @return {{ from: Map&lt;number,number&gt;, to: Map&lt;number,number&gt; }}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Map&lt;number, number&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const from = new Map();</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Map&lt;number, number&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const to = new Map();</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false);</span><span class="s3">\n  </span><span class="s1">let curr = updateDecoder.curr;</span><span class="s3">\n  </span><span class="s1">if (curr !== null) {</span><span class="s3">\n    </span><span class="s1">let currClient = curr.id.client;</span><span class="s3">\n    </span><span class="s1">let currClock = curr.id.clock;</span><span class="s3">\n    </span><span class="s1">// write the beginning to `from`</span><span class="s3">\n    </span><span class="s1">from.set(currClient, currClock);</span><span class="s3">\n    </span><span class="s1">for (; curr !== null; curr = updateDecoder.next()) {</span><span class="s3">\n      </span><span class="s1">if (currClient !== curr.id.client) {</span><span class="s3">\n        </span><span class="s1">// We found a new client</span><span class="s3">\n        </span><span class="s1">// write the end to `to`</span><span class="s3">\n        </span><span class="s1">to.set(currClient, currClock);</span><span class="s3">\n        </span><span class="s1">// write the beginning to `from`</span><span class="s3">\n        </span><span class="s1">from.set(curr.id.client, curr.id.clock);</span><span class="s3">\n        </span><span class="s1">// update currClient</span><span class="s3">\n        </span><span class="s1">currClient = curr.id.client;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">currClock = curr.id.clock + curr.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// write the end to `to`</span><span class="s3">\n    </span><span class="s1">to.set(currClient, currClock);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return { from, to }</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @return {{ from: Map&lt;number,number&gt;, to: Map&lt;number,number&gt; }}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const parseUpdateMeta = update =&gt; parseUpdateMetaV2(update, UpdateDecoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is intended to slice any kind of struct and retrieve the right part.</span><span class="s3">\n </span><span class="s1">* It does not handle side-effects, so it should only be used by the lazy-encoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Item | GC | Skip} left</span><span class="s3">\n </span><span class="s1">* @param {number} diff</span><span class="s3">\n </span><span class="s1">* @return {Item | GC}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const sliceStruct = (left, diff) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (left.constructor === GC) {</span><span class="s3">\n    </span><span class="s1">const { client, clock } = left.id;</span><span class="s3">\n    </span><span class="s1">return new GC(createID(client, clock + diff), left.length - diff)</span><span class="s3">\n  </span><span class="s1">} else if (left.constructor === Skip) {</span><span class="s3">\n    </span><span class="s1">const { client, clock } = left.id;</span><span class="s3">\n    </span><span class="s1">return new Skip(createID(client, clock + diff), left.length - diff)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const leftItem = /** @type {Item} */ (left);</span><span class="s3">\n    </span><span class="s1">const { client, clock } = leftItem.id;</span><span class="s3">\n    </span><span class="s1">return new Item(</span><span class="s3">\n      </span><span class="s1">createID(client, clock + diff),</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">createID(client, clock + diff - 1),</span><span class="s3">\n      </span><span class="s1">null,</span><span class="s3">\n      </span><span class="s1">leftItem.rightOrigin,</span><span class="s3">\n      </span><span class="s1">leftItem.parent,</span><span class="s3">\n      </span><span class="s1">leftItem.parentSub,</span><span class="s3">\n      </span><span class="s1">leftItem.content.splice(diff)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function works similarly to `readUpdateV2`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Uint8Array&gt;} updates</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (updates.length === 1) {</span><span class="s3">\n    </span><span class="s1">return updates[0]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const updateDecoders = updates.map(update =&gt; new YDecoder(decoding.createDecoder(update)));</span><span class="s3">\n  </span><span class="s1">let lazyStructDecoders = updateDecoders.map(decoder =&gt; new LazyStructReader(decoder, true));</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @todo we don't need offset because we always slice before</span><span class="s3">\n   </span><span class="s1">* @type {null | { struct: Item | GC | Skip, offset: number }}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let currWrite = null;</span><span class="s3">\n\n  </span><span class="s1">const updateEncoder = new YEncoder();</span><span class="s3">\n  </span><span class="s1">// write structs lazily</span><span class="s3">\n  </span><span class="s1">const lazyStructEncoder = new LazyStructWriter(updateEncoder);</span><span class="s3">\n\n  </span><span class="s1">// Note: We need to ensure that all lazyStructDecoders are fully consumed</span><span class="s3">\n  </span><span class="s1">// Note: Should merge document updates whenever possible - even from different updates</span><span class="s3">\n  </span><span class="s1">// Note: Should handle that some operations cannot be applied yet ()</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">// Write higher clients first  sort by clientID &amp; clock and remove decoders without content</span><span class="s3">\n    </span><span class="s1">lazyStructDecoders = lazyStructDecoders.filter(dec =&gt; dec.curr !== null);</span><span class="s3">\n    </span><span class="s1">lazyStructDecoders.sort(</span><span class="s3">\n      </span><span class="s1">/** @type {function(any,any):number} */ (dec1, dec2) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (dec1.curr.id.client === dec2.curr.id.client) {</span><span class="s3">\n          </span><span class="s1">const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;</span><span class="s3">\n          </span><span class="s1">if (clockDiff === 0) {</span><span class="s3">\n            </span><span class="s1">// @todo remove references to skip since the structDecoders must filter Skips.</span><span class="s3">\n            </span><span class="s1">return dec1.curr.constructor === dec2.curr.constructor</span><span class="s3">\n              </span><span class="s1">? 0</span><span class="s3">\n              </span><span class="s1">: dec1.curr.constructor === Skip ? 1 : -1 // we are filtering skips anyway.</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">return clockDiff</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return dec2.curr.id.client - dec1.curr.id.client</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (lazyStructDecoders.length === 0) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const currDecoder = lazyStructDecoders[0];</span><span class="s3">\n    </span><span class="s1">// write from currDecoder until the next operation is from another client or if filler-struct</span><span class="s3">\n    </span><span class="s1">// then we need to reorder the decoders and find the next operation to write</span><span class="s3">\n    </span><span class="s1">const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client;</span><span class="s3">\n\n    </span><span class="s1">if (currWrite !== null) {</span><span class="s3">\n      </span><span class="s1">let curr = /** @type {Item | GC | null} */ (currDecoder.curr);</span><span class="s3">\n      </span><span class="s1">let iterated = false;</span><span class="s3">\n\n      </span><span class="s1">// iterate until we find something that we haven't written already</span><span class="s3">\n      </span><span class="s1">// remember: first the high client-ids are written</span><span class="s3">\n      </span><span class="s1">while (curr !== null &amp;&amp; curr.id.clock + curr.length &lt;= currWrite.struct.id.clock + currWrite.struct.length &amp;&amp; curr.id.client &gt;= currWrite.struct.id.client) {</span><span class="s3">\n        </span><span class="s1">curr = currDecoder.next();</span><span class="s3">\n        </span><span class="s1">iterated = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">curr === null || // current decoder is empty</span><span class="s3">\n        </span><span class="s1">curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`</span><span class="s3">\n        </span><span class="s1">(iterated &amp;&amp; curr.id.clock &gt; currWrite.struct.id.clock + currWrite.struct.length) // the above while loop was used and we are potentially missing updates</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (firstClient !== currWrite.struct.id.client) {</span><span class="s3">\n        </span><span class="s1">writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);</span><span class="s3">\n        </span><span class="s1">currWrite = { struct: curr, offset: 0 };</span><span class="s3">\n        </span><span class="s1">currDecoder.next();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (currWrite.struct.id.clock + currWrite.struct.length &lt; curr.id.clock) {</span><span class="s3">\n          </span><span class="s1">// @todo write currStruct &amp; set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)</span><span class="s3">\n          </span><span class="s1">if (currWrite.struct.constructor === Skip) {</span><span class="s3">\n            </span><span class="s1">// extend existing skip</span><span class="s3">\n            </span><span class="s1">currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);</span><span class="s3">\n            </span><span class="s1">const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* @type {Skip}</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);</span><span class="s3">\n            </span><span class="s1">currWrite = { struct, offset: 0 };</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else { // if (currWrite.struct.id.clock + currWrite.struct.length &gt;= curr.id.clock) {</span><span class="s3">\n          </span><span class="s1">const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;</span><span class="s3">\n          </span><span class="s1">if (diff &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (currWrite.struct.constructor === Skip) {</span><span class="s3">\n              </span><span class="s1">// prefer to slice Skip because the other struct might contain more information</span><span class="s3">\n              </span><span class="s1">currWrite.struct.length -= diff;</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">curr = sliceStruct(curr, diff);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {</span><span class="s3">\n            </span><span class="s1">writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);</span><span class="s3">\n            </span><span class="s1">currWrite = { struct: curr, offset: 0 };</span><span class="s3">\n            </span><span class="s1">currDecoder.next();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 };</span><span class="s3">\n      </span><span class="s1">currDecoder.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (</span><span class="s3">\n      </span><span class="s1">let next = currDecoder.curr;</span><span class="s3">\n      </span><span class="s1">next !== null &amp;&amp; next.id.client === firstClient &amp;&amp; next.id.clock === currWrite.struct.id.clock + currWrite.struct.length &amp;&amp; next.constructor !== Skip;</span><span class="s3">\n      </span><span class="s1">next = currDecoder.next()</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);</span><span class="s3">\n      </span><span class="s1">currWrite = { struct: next, offset: 0 };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (currWrite !== null) {</span><span class="s3">\n    </span><span class="s1">writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);</span><span class="s3">\n    </span><span class="s1">currWrite = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">finishLazyStructWriting(lazyStructEncoder);</span><span class="s3">\n\n  </span><span class="s1">const dss = updateDecoders.map(decoder =&gt; readDeleteSet(decoder));</span><span class="s3">\n  </span><span class="s1">const ds = mergeDeleteSets(dss);</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(updateEncoder, ds);</span><span class="s3">\n  </span><span class="s1">return updateEncoder.toUint8Array()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} sv</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) =&gt; {</span><span class="s3">\n  </span><span class="s1">const state = decodeStateVector(sv);</span><span class="s3">\n  </span><span class="s1">const encoder = new YEncoder();</span><span class="s3">\n  </span><span class="s1">const lazyStructWriter = new LazyStructWriter(encoder);</span><span class="s3">\n  </span><span class="s1">const decoder = new YDecoder(decoding.createDecoder(update));</span><span class="s3">\n  </span><span class="s1">const reader = new LazyStructReader(decoder, false);</span><span class="s3">\n  </span><span class="s1">while (reader.curr) {</span><span class="s3">\n    </span><span class="s1">const curr = reader.curr;</span><span class="s3">\n    </span><span class="s1">const currClient = curr.id.client;</span><span class="s3">\n    </span><span class="s1">const svClock = state.get(currClient) || 0;</span><span class="s3">\n    </span><span class="s1">if (reader.curr.constructor === Skip) {</span><span class="s3">\n      </span><span class="s1">// the first written struct shouldn't be a skip</span><span class="s3">\n      </span><span class="s1">reader.next();</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (curr.id.clock + curr.length &gt; svClock) {</span><span class="s3">\n      </span><span class="s1">writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0));</span><span class="s3">\n      </span><span class="s1">reader.next();</span><span class="s3">\n      </span><span class="s1">while (reader.curr &amp;&amp; reader.curr.id.client === currClient) {</span><span class="s3">\n        </span><span class="s1">writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);</span><span class="s3">\n        </span><span class="s1">reader.next();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// read until something new comes up</span><span class="s3">\n      </span><span class="s1">while (reader.curr &amp;&amp; reader.curr.id.client === currClient &amp;&amp; reader.curr.id.clock + reader.curr.length &lt;= svClock) {</span><span class="s3">\n        </span><span class="s1">reader.next();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">finishLazyStructWriting(lazyStructWriter);</span><span class="s3">\n  </span><span class="s1">// write ds</span><span class="s3">\n  </span><span class="s1">const ds = readDeleteSet(decoder);</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(encoder, ds);</span><span class="s3">\n  </span><span class="s1">return encoder.toUint8Array()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} sv</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const diffUpdate = (update, sv) =&gt; diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {LazyStructWriter} lazyWriter</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const flushLazyStructWriter = lazyWriter =&gt; {</span><span class="s3">\n  </span><span class="s1">if (lazyWriter.written &gt; 0) {</span><span class="s3">\n    </span><span class="s1">lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) });</span><span class="s3">\n    </span><span class="s1">lazyWriter.encoder.restEncoder = encoding.createEncoder();</span><span class="s3">\n    </span><span class="s1">lazyWriter.written = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {LazyStructWriter} lazyWriter</span><span class="s3">\n </span><span class="s1">* @param {Item | GC} struct</span><span class="s3">\n </span><span class="s1">* @param {number} offset</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const writeStructToLazyStructWriter = (lazyWriter, struct, offset) =&gt; {</span><span class="s3">\n  </span><span class="s1">// flush curr if we start another client</span><span class="s3">\n  </span><span class="s1">if (lazyWriter.written &gt; 0 &amp;&amp; lazyWriter.currClient !== struct.id.client) {</span><span class="s3">\n    </span><span class="s1">flushLazyStructWriter(lazyWriter);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (lazyWriter.written === 0) {</span><span class="s3">\n    </span><span class="s1">lazyWriter.currClient = struct.id.client;</span><span class="s3">\n    </span><span class="s1">// write next client</span><span class="s3">\n    </span><span class="s1">lazyWriter.encoder.writeClient(struct.id.client);</span><span class="s3">\n    </span><span class="s1">// write startClock</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">struct.write(lazyWriter.encoder, offset);</span><span class="s3">\n  </span><span class="s1">lazyWriter.written++;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Call this function when we collected all parts and want to</span><span class="s3">\n </span><span class="s1">* put all the parts together. After calling this method,</span><span class="s3">\n </span><span class="s1">* you can continue using the UpdateEncoder.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {LazyStructWriter} lazyWriter</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const finishLazyStructWriting = (lazyWriter) =&gt; {</span><span class="s3">\n  </span><span class="s1">flushLazyStructWriter(lazyWriter);</span><span class="s3">\n\n  </span><span class="s1">// this is a fresh encoder because we called flushCurr</span><span class="s3">\n  </span><span class="s1">const restEncoder = lazyWriter.encoder.restEncoder;</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Now we put all the fragments together.</span><span class="s3">\n   </span><span class="s1">* This works similarly to `writeClientsStructs`</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n\n  </span><span class="s1">// write # states that were updated - i.e. the clients</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length);</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; lazyWriter.clientStructs.length; i++) {</span><span class="s3">\n    </span><span class="s1">const partStructs = lazyWriter.clientStructs[i];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Works similarly to `writeStructs`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">// write # encoded structs</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(restEncoder, partStructs.written);</span><span class="s3">\n    </span><span class="s1">// write the rest of the fragment</span><span class="s3">\n    </span><span class="s1">encoding.writeUint8Array(restEncoder, partStructs.restEncoder);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder</span><span class="s3">\n </span><span class="s1">* @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) =&gt; {</span><span class="s3">\n  </span><span class="s1">const updateDecoder = new YDecoder(decoding.createDecoder(update));</span><span class="s3">\n  </span><span class="s1">const lazyDecoder = new LazyStructReader(updateDecoder, false);</span><span class="s3">\n  </span><span class="s1">const updateEncoder = new YEncoder();</span><span class="s3">\n  </span><span class="s1">const lazyWriter = new LazyStructWriter(updateEncoder);</span><span class="s3">\n  </span><span class="s1">for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {</span><span class="s3">\n    </span><span class="s1">writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">finishLazyStructWriting(lazyWriter);</span><span class="s3">\n  </span><span class="s1">const ds = readDeleteSet(updateDecoder);</span><span class="s3">\n  </span><span class="s1">writeDeleteSet(updateEncoder, ds);</span><span class="s3">\n  </span><span class="s1">return updateEncoder.toUint8Array()</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {Object} ObfuscatorOptions</span><span class="s3">\n </span><span class="s1">* @property {boolean} [ObfuscatorOptions.formatting=true]</span><span class="s3">\n </span><span class="s1">* @property {boolean} [ObfuscatorOptions.subdocs=true]</span><span class="s3">\n </span><span class="s1">* @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {ObfuscatorOptions} obfuscator</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createObfuscator = ({ formatting = true, subdocs = true, yxml = true } = {}) =&gt; {</span><span class="s3">\n  </span><span class="s1">let i = 0;</span><span class="s3">\n  </span><span class="s1">const mapKeyCache = map.create();</span><span class="s3">\n  </span><span class="s1">const nodeNameCache = map.create();</span><span class="s3">\n  </span><span class="s1">const formattingKeyCache = map.create();</span><span class="s3">\n  </span><span class="s1">const formattingValueCache = map.create();</span><span class="s3">\n  </span><span class="s1">formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Item|GC|Skip} block</span><span class="s3">\n   </span><span class="s1">* @return {Item|GC|Skip}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">return block =&gt; {</span><span class="s3">\n    </span><span class="s1">switch (block.constructor) {</span><span class="s3">\n      </span><span class="s1">case GC:</span><span class="s3">\n      </span><span class="s1">case Skip:</span><span class="s3">\n        </span><span class="s1">return block</span><span class="s3">\n      </span><span class="s1">case Item: {</span><span class="s3">\n        </span><span class="s1">const item = /** @type {Item} */ (block);</span><span class="s3">\n        </span><span class="s1">const content = item.content;</span><span class="s3">\n        </span><span class="s1">switch (content.constructor) {</span><span class="s3">\n          </span><span class="s1">case ContentDeleted:</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">case ContentType: {</span><span class="s3">\n            </span><span class="s1">if (yxml) {</span><span class="s3">\n              </span><span class="s1">const type = /** @type {ContentType} */ (content).type;</span><span class="s3">\n              </span><span class="s1">if (type instanceof YXmlElement) {</span><span class="s3">\n                </span><span class="s1">type.nodeName = map.setIfUndefined(nodeNameCache, type.nodeName, () =&gt; 'node-' + i);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (type instanceof YXmlHook) {</span><span class="s3">\n                </span><span class="s1">type.hookName = map.setIfUndefined(nodeNameCache, type.hookName, () =&gt; 'hook-' + i);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentAny: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentAny} */ (content);</span><span class="s3">\n            </span><span class="s1">c.arr = c.arr.map(() =&gt; i);</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentBinary: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentBinary} */ (content);</span><span class="s3">\n            </span><span class="s1">c.content = new Uint8Array([i]);</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentDoc: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentDoc} */ (content);</span><span class="s3">\n            </span><span class="s1">if (subdocs) {</span><span class="s3">\n              </span><span class="s1">c.opts = {};</span><span class="s3">\n              </span><span class="s1">c.doc.guid = i + '';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentEmbed: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentEmbed} */ (content);</span><span class="s3">\n            </span><span class="s1">c.embed = {};</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentFormat: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentFormat} */ (content);</span><span class="s3">\n            </span><span class="s1">if (formatting) {</span><span class="s3">\n              </span><span class="s1">c.key = map.setIfUndefined(formattingKeyCache, c.key, () =&gt; i + '');</span><span class="s3">\n              </span><span class="s1">c.value = map.setIfUndefined(formattingValueCache, c.value, () =&gt; ({ i }));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentJSON: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentJSON} */ (content);</span><span class="s3">\n            </span><span class="s1">c.arr = c.arr.map(() =&gt; i);</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">case ContentString: {</span><span class="s3">\n            </span><span class="s1">const c = /** @type {ContentString} */ (content);</span><span class="s3">\n            </span><span class="s1">c.str = string.repeat((i % 10) + '', c.str.length);</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">// unknown content type</span><span class="s3">\n            </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (item.parentSub) {</span><span class="s3">\n          </span><span class="s1">item.parentSub = map.setIfUndefined(mapKeyCache, item.parentSub, () =&gt; i + '');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">return block</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">// unknown block-type</span><span class="s3">\n        </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function obfuscates the content of a Yjs update. This is useful to share</span><span class="s3">\n </span><span class="s1">* buggy Yjs documents while significantly limiting the possibility that a</span><span class="s3">\n </span><span class="s1">* developer can on the user. Note that it might still be possible to deduce</span><span class="s3">\n </span><span class="s1">* some information by analyzing the </span><span class="s3">\&quot;</span><span class="s1">structure</span><span class="s3">\&quot; </span><span class="s1">of the document or by analyzing</span><span class="s3">\n </span><span class="s1">* the typing behavior using the CRDT-related metadata that is still kept fully</span><span class="s3">\n </span><span class="s1">* intact.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {ObfuscatorOptions} [opts]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const obfuscateUpdate = (update, opts) =&gt; convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, UpdateEncoderV1);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {ObfuscatorOptions} [opts]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const obfuscateUpdateV2 = (update, opts) =&gt; convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const convertUpdateFormatV1ToV2 = update =&gt; convertUpdateFormat(update, f.id, UpdateDecoderV1, UpdateEncoderV2);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const convertUpdateFormatV2ToV1 = update =&gt; convertUpdateFormat(update, f.id, UpdateDecoderV2, UpdateEncoderV1);</span><span class="s3">\n\n</span><span class="s1">const errorComputeChanges = 'You must not compute changes after the event-handler fired.';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {AbstractType&lt;any&gt;} T</span><span class="s3">\n </span><span class="s1">* YEvent describes the changes on a YType.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YEvent {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {T} target The changed type.</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (target, transaction) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The type on which this event was created on.</span><span class="s3">\n     </span><span class="s1">* @type {T}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.target = target;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The current target on which the observe callback is called.</span><span class="s3">\n     </span><span class="s1">* @type {AbstractType&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.currentTarget = target;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The transaction that triggered this event.</span><span class="s3">\n     </span><span class="s1">* @type {Transaction}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.transaction = transaction;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Object|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._changes = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | Map&lt;string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._keys = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | Array&lt;{ insert?: string | Array&lt;any&gt; | object | AbstractType&lt;any&gt;, retain?: number, delete?: number, attributes?: Object&lt;string, any&gt; }&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._delta = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;string|number&gt;|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._path = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Computes the path from `y` to the changed type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo v14 should standardize on path: Array&lt;{parent, index}&gt; because that is easier to work with.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* The following property holds:</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*   let type = y</span><span class="s3">\n   </span><span class="s1">*   event.path.forEach(dir =&gt; {</span><span class="s3">\n   </span><span class="s1">*     type = type.get(dir)</span><span class="s3">\n   </span><span class="s1">*   })</span><span class="s3">\n   </span><span class="s1">*   type === event.target // =&gt; true</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get path () {</span><span class="s3">\n    </span><span class="s1">return this._path || (this._path = getPathTo(this.currentTarget, this.target))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Check if a struct is deleted by this event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* In contrast to change.deleted, this method also returns true if the struct was added and then deleted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {AbstractStruct} struct</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">deletes (struct) {</span><span class="s3">\n    </span><span class="s1">return isDeleted(this.transaction.deleteSet, struct.id)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Map&lt;string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get keys () {</span><span class="s3">\n    </span><span class="s1">if (this._keys === null) {</span><span class="s3">\n      </span><span class="s1">if (this.transaction.doc._transactionCleanups.length === 0) {</span><span class="s3">\n        </span><span class="s1">throw error.create(errorComputeChanges)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const keys = new Map();</span><span class="s3">\n      </span><span class="s1">const target = this.target;</span><span class="s3">\n      </span><span class="s1">const changed = /** @type Set&lt;string|null&gt; */ (this.transaction.changed.get(target));</span><span class="s3">\n      </span><span class="s1">changed.forEach(key =&gt; {</span><span class="s3">\n        </span><span class="s1">if (key !== null) {</span><span class="s3">\n          </span><span class="s1">const item = /** @type {Item} */ (target._map.get(key));</span><span class="s3">\n          </span><span class="s1">/**</span><span class="s3">\n           </span><span class="s1">* @type {'delete' | 'add' | 'update'}</span><span class="s3">\n           </span><span class="s1">*/</span><span class="s3">\n          </span><span class="s1">let action;</span><span class="s3">\n          </span><span class="s1">let oldValue;</span><span class="s3">\n          </span><span class="s1">if (this.adds(item)) {</span><span class="s3">\n            </span><span class="s1">let prev = item.left;</span><span class="s3">\n            </span><span class="s1">while (prev !== null &amp;&amp; this.adds(prev)) {</span><span class="s3">\n              </span><span class="s1">prev = prev.left;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.deletes(item)) {</span><span class="s3">\n              </span><span class="s1">if (prev !== null &amp;&amp; this.deletes(prev)) {</span><span class="s3">\n                </span><span class="s1">action = 'delete';</span><span class="s3">\n                </span><span class="s1">oldValue = array.last(prev.content.getContent());</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">return</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">if (prev !== null &amp;&amp; this.deletes(prev)) {</span><span class="s3">\n                </span><span class="s1">action = 'update';</span><span class="s3">\n                </span><span class="s1">oldValue = array.last(prev.content.getContent());</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">action = 'add';</span><span class="s3">\n                </span><span class="s1">oldValue = undefined;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">if (this.deletes(item)) {</span><span class="s3">\n              </span><span class="s1">action = 'delete';</span><span class="s3">\n              </span><span class="s1">oldValue = array.last(/** @type {Item} */ item.content.getContent());</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">return // nop</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">keys.set(key, { action, oldValue });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">this._keys = keys;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return this._keys</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is a computed property. Note that this can only be safely computed during the</span><span class="s3">\n   </span><span class="s1">* event call. Computing this property after other changes happened might result in</span><span class="s3">\n   </span><span class="s1">* unexpected behavior (incorrect computation of deltas). A safe way to collect changes</span><span class="s3">\n   </span><span class="s1">* is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;{insert?: string | Array&lt;any&gt; | object | AbstractType&lt;any&gt;, retain?: number, delete?: number, attributes?: Object&lt;string, any&gt;}&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get delta () {</span><span class="s3">\n    </span><span class="s1">return this.changes.delta</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Check if a struct is added by this event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* In contrast to change.deleted, this method also returns true if the struct was added and then deleted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {AbstractStruct} struct</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">adds (struct) {</span><span class="s3">\n    </span><span class="s1">return struct.id.clock &gt;= (this.transaction.beforeState.get(struct.id.client) || 0)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is a computed property. Note that this can only be safely computed during the</span><span class="s3">\n   </span><span class="s1">* event call. Computing this property after other changes happened might result in</span><span class="s3">\n   </span><span class="s1">* unexpected behavior (incorrect computation of deltas). A safe way to collect changes</span><span class="s3">\n   </span><span class="s1">* is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @type {{added:Set&lt;Item&gt;,deleted:Set&lt;Item&gt;,keys:Map&lt;string,{action:'add'|'update'|'delete',oldValue:any}&gt;,delta:Array&lt;{insert?:Array&lt;any&gt;|string, delete?:number, retain?:number}&gt;}}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get changes () {</span><span class="s3">\n    </span><span class="s1">let changes = this._changes;</span><span class="s3">\n    </span><span class="s1">if (changes === null) {</span><span class="s3">\n      </span><span class="s1">if (this.transaction.doc._transactionCleanups.length === 0) {</span><span class="s3">\n        </span><span class="s1">throw error.create(errorComputeChanges)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const target = this.target;</span><span class="s3">\n      </span><span class="s1">const added = set.create();</span><span class="s3">\n      </span><span class="s1">const deleted = set.create();</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Array&lt;{insert:Array&lt;any&gt;}|{delete:number}|{retain:number}&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const delta = [];</span><span class="s3">\n      </span><span class="s1">changes = {</span><span class="s3">\n        </span><span class="s1">added,</span><span class="s3">\n        </span><span class="s1">deleted,</span><span class="s3">\n        </span><span class="s1">delta,</span><span class="s3">\n        </span><span class="s1">keys: this.keys</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">const changed = /** @type Set&lt;string|null&gt; */ (this.transaction.changed.get(target));</span><span class="s3">\n      </span><span class="s1">if (changed.has(null)) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {any}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let lastOp = null;</span><span class="s3">\n        </span><span class="s1">const packOp = () =&gt; {</span><span class="s3">\n          </span><span class="s1">if (lastOp) {</span><span class="s3">\n            </span><span class="s1">delta.push(lastOp);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (let item = target._start; item !== null; item = item.right) {</span><span class="s3">\n          </span><span class="s1">if (item.deleted) {</span><span class="s3">\n            </span><span class="s1">if (this.deletes(item) &amp;&amp; !this.adds(item)) {</span><span class="s3">\n              </span><span class="s1">if (lastOp === null || lastOp.delete === undefined) {</span><span class="s3">\n                </span><span class="s1">packOp();</span><span class="s3">\n                </span><span class="s1">lastOp = { delete: 0 };</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">lastOp.delete += item.length;</span><span class="s3">\n              </span><span class="s1">deleted.add(item);</span><span class="s3">\n            </span><span class="s1">} // else nop</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">if (this.adds(item)) {</span><span class="s3">\n              </span><span class="s1">if (lastOp === null || lastOp.insert === undefined) {</span><span class="s3">\n                </span><span class="s1">packOp();</span><span class="s3">\n                </span><span class="s1">lastOp = { insert: [] };</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">lastOp.insert = lastOp.insert.concat(item.content.getContent());</span><span class="s3">\n              </span><span class="s1">added.add(item);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">if (lastOp === null || lastOp.retain === undefined) {</span><span class="s3">\n                </span><span class="s1">packOp();</span><span class="s3">\n                </span><span class="s1">lastOp = { retain: 0 };</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">lastOp.retain += item.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (lastOp !== null &amp;&amp; lastOp.retain === undefined) {</span><span class="s3">\n          </span><span class="s1">packOp();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this._changes = changes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (changes)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compute the path from this type to the specified target.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*   // `child` should be accessible via `type.get(path[0]).get(path[1])..`</span><span class="s3">\n </span><span class="s1">*   const path = type.getPathTo(child)</span><span class="s3">\n </span><span class="s1">*   // assuming `type instanceof YArray`</span><span class="s3">\n </span><span class="s1">*   console.log(path) // might look like =&gt; [2, 'key1']</span><span class="s3">\n </span><span class="s1">*   child === type.get(path[0]).get(path[1])</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} child target</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;string|number&gt;} Path to the target</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getPathTo = (parent, child) =&gt; {</span><span class="s3">\n  </span><span class="s1">const path = [];</span><span class="s3">\n  </span><span class="s1">while (child._item !== null &amp;&amp; child !== parent) {</span><span class="s3">\n    </span><span class="s1">if (child._item.parentSub !== null) {</span><span class="s3">\n      </span><span class="s1">// parent is map-ish</span><span class="s3">\n      </span><span class="s1">path.unshift(child._item.parentSub);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// parent is array-ish</span><span class="s3">\n      </span><span class="s1">let i = 0;</span><span class="s3">\n      </span><span class="s1">let c = /** @type {AbstractType&lt;any&gt;} */ (child._item.parent)._start;</span><span class="s3">\n      </span><span class="s1">while (c !== child._item &amp;&amp; c !== null) {</span><span class="s3">\n        </span><span class="s1">if (!c.deleted) {</span><span class="s3">\n          </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">c = c.right;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">path.unshift(i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">child = /** @type {AbstractType&lt;any&gt;} */ (child._item.parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return path</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const maxSearchMarker = 80;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A unique timestamp that identifies each marker.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Time is relative,.. this is more like an ever-increasing clock.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @type {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">let globalSearchMarkerTimestamp = 0;</span><span class="s3">\n\n</span><span class="s1">class ArraySearchMarker {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Item} p</span><span class="s3">\n   </span><span class="s1">* @param {number} index</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (p, index) {</span><span class="s3">\n    </span><span class="s1">p.marker = true;</span><span class="s3">\n    </span><span class="s1">this.p = p;</span><span class="s3">\n    </span><span class="s1">this.index = index;</span><span class="s3">\n    </span><span class="s1">this.timestamp = globalSearchMarkerTimestamp++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {ArraySearchMarker} marker</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const refreshMarkerTimestamp = marker =&gt; { marker.timestamp = globalSearchMarkerTimestamp++; };</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This is rather complex so this function is the only thing that should overwrite a marker</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ArraySearchMarker} marker</span><span class="s3">\n </span><span class="s1">* @param {Item} p</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const overwriteMarker = (marker, p, index) =&gt; {</span><span class="s3">\n  </span><span class="s1">marker.p.marker = false;</span><span class="s3">\n  </span><span class="s1">marker.p = p;</span><span class="s3">\n  </span><span class="s1">p.marker = true;</span><span class="s3">\n  </span><span class="s1">marker.index = index;</span><span class="s3">\n  </span><span class="s1">marker.timestamp = globalSearchMarkerTimestamp++;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;ArraySearchMarker&gt;} searchMarker</span><span class="s3">\n </span><span class="s1">* @param {Item} p</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const markPosition = (searchMarker, p, index) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (searchMarker.length &gt;= maxSearchMarker) {</span><span class="s3">\n    </span><span class="s1">// override oldest marker (we don't want to create more objects)</span><span class="s3">\n    </span><span class="s1">const marker = searchMarker.reduce((a, b) =&gt; a.timestamp &lt; b.timestamp ? a : b);</span><span class="s3">\n    </span><span class="s1">overwriteMarker(marker, p, index);</span><span class="s3">\n    </span><span class="s1">return marker</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// create new marker</span><span class="s3">\n    </span><span class="s1">const pm = new ArraySearchMarker(p, index);</span><span class="s3">\n    </span><span class="s1">searchMarker.push(pm);</span><span class="s3">\n    </span><span class="s1">return pm</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Search marker help us to find positions in the associative array faster.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* They speed up the process of finding a position without much bookkeeping.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* A maximum of `maxSearchMarker` objects are created.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function always returns a refreshed marker (updated timestamp)</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} yarray</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findMarker = (yarray, index) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (yarray._start === null || index === 0 || yarray._searchMarker === null) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) =&gt; math.abs(index - a.index) &lt; math.abs(index - b.index) ? a : b);</span><span class="s3">\n  </span><span class="s1">let p = yarray._start;</span><span class="s3">\n  </span><span class="s1">let pindex = 0;</span><span class="s3">\n  </span><span class="s1">if (marker !== null) {</span><span class="s3">\n    </span><span class="s1">p = marker.p;</span><span class="s3">\n    </span><span class="s1">pindex = marker.index;</span><span class="s3">\n    </span><span class="s1">refreshMarkerTimestamp(marker); // we used it, we might need to use it again</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// iterate to right if possible</span><span class="s3">\n  </span><span class="s1">while (p.right !== null &amp;&amp; pindex &lt; index) {</span><span class="s3">\n    </span><span class="s1">if (!p.deleted &amp;&amp; p.countable) {</span><span class="s3">\n      </span><span class="s1">if (index &lt; pindex + p.length) {</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">pindex += p.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">p = p.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// iterate to left if necessary (might be that pindex &gt; index)</span><span class="s3">\n  </span><span class="s1">while (p.left !== null &amp;&amp; pindex &gt; index) {</span><span class="s3">\n    </span><span class="s1">p = p.left;</span><span class="s3">\n    </span><span class="s1">if (!p.deleted &amp;&amp; p.countable) {</span><span class="s3">\n      </span><span class="s1">pindex -= p.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// we want to make sure that p can't be merged with left, because that would screw up everything</span><span class="s3">\n  </span><span class="s1">// in that cas just return what we have (it is most likely the best marker anyway)</span><span class="s3">\n  </span><span class="s1">// iterate to left until p can't be merged with left</span><span class="s3">\n  </span><span class="s1">while (p.left !== null &amp;&amp; p.left.id.client === p.id.client &amp;&amp; p.left.id.clock + p.left.length === p.id.clock) {</span><span class="s3">\n    </span><span class="s1">p = p.left;</span><span class="s3">\n    </span><span class="s1">if (!p.deleted &amp;&amp; p.countable) {</span><span class="s3">\n      </span><span class="s1">pindex -= p.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// @todo remove!</span><span class="s3">\n  </span><span class="s1">// assure position</span><span class="s3">\n  </span><span class="s1">// {</span><span class="s3">\n  </span><span class="s1">//   let start = yarray._start</span><span class="s3">\n  </span><span class="s1">//   let pos = 0</span><span class="s3">\n  </span><span class="s1">//   while (start !== p) {</span><span class="s3">\n  </span><span class="s1">//     if (!start.deleted &amp;&amp; start.countable) {</span><span class="s3">\n  </span><span class="s1">//       pos += start.length</span><span class="s3">\n  </span><span class="s1">//     }</span><span class="s3">\n  </span><span class="s1">//     start = /** @type {Item} */ (start.right)</span><span class="s3">\n  </span><span class="s1">//   }</span><span class="s3">\n  </span><span class="s1">//   if (pos !== pindex) {</span><span class="s3">\n  </span><span class="s1">//     debugger</span><span class="s3">\n  </span><span class="s1">//     throw new Error('Gotcha position fail!')</span><span class="s3">\n  </span><span class="s1">//   }</span><span class="s3">\n  </span><span class="s1">// }</span><span class="s3">\n  </span><span class="s1">// if (marker) {</span><span class="s3">\n  </span><span class="s1">//   if (window.lengthes == null) {</span><span class="s3">\n  </span><span class="s1">//     window.lengthes = []</span><span class="s3">\n  </span><span class="s1">//     window.getLengthes = () =&gt; window.lengthes.sort((a, b) =&gt; a - b)</span><span class="s3">\n  </span><span class="s1">//   }</span><span class="s3">\n  </span><span class="s1">//   window.lengthes.push(marker.index - pindex)</span><span class="s3">\n  </span><span class="s1">//   console.log('distance', marker.index - pindex, 'len', p &amp;&amp; p.parent.length)</span><span class="s3">\n  </span><span class="s1">// }</span><span class="s3">\n  </span><span class="s1">if (marker !== null &amp;&amp; math.abs(marker.index - pindex) &lt; /** @type {YText|YArray&lt;any&gt;} */ (p.parent).length / maxSearchMarker) {</span><span class="s3">\n    </span><span class="s1">// adjust existing marker</span><span class="s3">\n    </span><span class="s1">overwriteMarker(marker, p, pindex);</span><span class="s3">\n    </span><span class="s1">return marker</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// create new marker</span><span class="s3">\n    </span><span class="s1">return markPosition(yarray._searchMarker, p, pindex)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Update markers when a change happened.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This should be called before doing a deletion!</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;ArraySearchMarker&gt;} searchMarker</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @param {number} len If insertion, len is positive. If deletion, len is negative.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const updateMarkerChanges = (searchMarker, index, len) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = searchMarker.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">const m = searchMarker[i];</span><span class="s3">\n    </span><span class="s1">if (len &gt; 0) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Item|null}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">let p = m.p;</span><span class="s3">\n      </span><span class="s1">p.marker = false;</span><span class="s3">\n      </span><span class="s1">// Ideally we just want to do a simple position comparison, but this will only work if</span><span class="s3">\n      </span><span class="s1">// search markers don't point to deleted items for formats.</span><span class="s3">\n      </span><span class="s1">// Iterate marker to prev undeleted countable position so we know what to do when updating a position</span><span class="s3">\n      </span><span class="s1">while (p &amp;&amp; (p.deleted || !p.countable)) {</span><span class="s3">\n        </span><span class="s1">p = p.left;</span><span class="s3">\n        </span><span class="s1">if (p &amp;&amp; !p.deleted &amp;&amp; p.countable) {</span><span class="s3">\n          </span><span class="s1">// adjust position. the loop should break now</span><span class="s3">\n          </span><span class="s1">m.index -= p.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (p === null || p.marker === true) {</span><span class="s3">\n        </span><span class="s1">// remove search marker if updated position is null or if position is already marked</span><span class="s3">\n        </span><span class="s1">searchMarker.splice(i, 1);</span><span class="s3">\n        </span><span class="s1">continue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">m.p = p;</span><span class="s3">\n      </span><span class="s1">p.marker = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (index &lt; m.index || (len &gt; 0 &amp;&amp; index === m.index)) { // a simple index &lt;= m.index check would actually suffice</span><span class="s3">\n      </span><span class="s1">m.index = math.max(index, m.index + len);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Accumulate all (list) children of a type and return them as an Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} t</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;Item&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const getTypeChildren = t =&gt; {</span><span class="s3">\n  </span><span class="s1">let s = t._start;</span><span class="s3">\n  </span><span class="s1">const arr = [];</span><span class="s3">\n  </span><span class="s1">while (s) {</span><span class="s3">\n    </span><span class="s1">arr.push(s);</span><span class="s3">\n    </span><span class="s1">s = s.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return arr</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Call event listeners with an event. This will also add an event to all</span><span class="s3">\n </span><span class="s1">* parents (for `.observeDeep` handlers).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template EventType</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;EventType&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {EventType} event</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const callTypeObservers = (type, transaction, event) =&gt; {</span><span class="s3">\n  </span><span class="s1">const changedType = type;</span><span class="s3">\n  </span><span class="s1">const changedParentTypes = transaction.changedParentTypes;</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(changedParentTypes, type, () =&gt; []).push(event);</span><span class="s3">\n    </span><span class="s1">if (type._item === null) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">type = /** @type {AbstractType&lt;any&gt;} */ (type._item.parent);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">callEventHandlerListeners(changedType._eH, event, transaction);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template EventType</span><span class="s3">\n </span><span class="s1">* Abstract Yjs Type class</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AbstractType {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Item|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._item = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string,Item&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._map = new Map();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Item|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._start = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Doc|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.doc = null;</span><span class="s3">\n    </span><span class="s1">this._length = 0;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Event handlers</span><span class="s3">\n     </span><span class="s1">* @type {EventHandler&lt;EventType,Transaction&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._eH = createEventHandler();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Deep event handlers</span><span class="s3">\n     </span><span class="s1">* @type {EventHandler&lt;Array&lt;YEvent&lt;any&gt;&gt;,Transaction&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._dEH = createEventHandler();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {null | Array&lt;ArraySearchMarker&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._searchMarker = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {AbstractType&lt;any&gt;|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get parent () {</span><span class="s3">\n    </span><span class="s1">return this._item ? /** @type {AbstractType&lt;any&gt;} */ (this._item.parent) : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Integrate this type into the Yjs instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * Save this struct in the os</span><span class="s3">\n   </span><span class="s1">* * This type is sent to other client</span><span class="s3">\n   </span><span class="s1">* * Observer functions are fired</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y The Yjs instance</span><span class="s3">\n   </span><span class="s1">* @param {Item|null} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">this.doc = y;</span><span class="s3">\n    </span><span class="s1">this._item = item;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {AbstractType&lt;EventType&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {AbstractType&lt;EventType&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (_encoder) { }</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* The first non-deleted item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get _first () {</span><span class="s3">\n    </span><span class="s1">let n = this._start;</span><span class="s3">\n    </span><span class="s1">while (n !== null &amp;&amp; n.deleted) {</span><span class="s3">\n      </span><span class="s1">n = n.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return n</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates YEvent and calls all type observers.</span><span class="s3">\n   </span><span class="s1">* Must be implemented by each type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;null|string&gt;} _parentSubs Keys changed on this type. `null` if list was modified.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_callObserver (transaction, _parentSubs) {</span><span class="s3">\n    </span><span class="s1">if (!transaction.local &amp;&amp; this._searchMarker) {</span><span class="s3">\n      </span><span class="s1">this._searchMarker.length = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Observe all events that are created on this type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(EventType, Transaction):void} f Observer function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">observe (f) {</span><span class="s3">\n    </span><span class="s1">addEventHandlerListener(this._eH, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Observe all events that are created by this type and its children.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(Array&lt;YEvent&lt;any&gt;&gt;,Transaction):void} f Observer function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">observeDeep (f) {</span><span class="s3">\n    </span><span class="s1">addEventHandlerListener(this._dEH, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unregister an observer function.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(EventType,Transaction):void} f Observer function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">unobserve (f) {</span><span class="s3">\n    </span><span class="s1">removeEventHandlerListener(this._eH, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Unregister an observer function.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(Array&lt;YEvent&lt;any&gt;&gt;,Transaction):void} f Observer function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">unobserveDeep (f) {</span><span class="s3">\n    </span><span class="s1">removeEventHandlerListener(this._dEH, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @abstract</span><span class="s3">\n   </span><span class="s1">* @return {any}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {number} start</span><span class="s3">\n </span><span class="s1">* @param {number} end</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListSlice = (type, start, end) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (start &lt; 0) {</span><span class="s3">\n    </span><span class="s1">start = type._length + start;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (end &lt; 0) {</span><span class="s3">\n    </span><span class="s1">end = type._length + end;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let len = end - start;</span><span class="s3">\n  </span><span class="s1">const cs = [];</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">while (n !== null &amp;&amp; len &gt; 0) {</span><span class="s3">\n    </span><span class="s1">if (n.countable &amp;&amp; !n.deleted) {</span><span class="s3">\n      </span><span class="s1">const c = n.content.getContent();</span><span class="s3">\n      </span><span class="s1">if (c.length &lt;= start) {</span><span class="s3">\n        </span><span class="s1">start -= c.length;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (let i = start; i &lt; c.length &amp;&amp; len &gt; 0; i++) {</span><span class="s3">\n          </span><span class="s1">cs.push(c[i]);</span><span class="s3">\n          </span><span class="s1">len--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">start = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cs</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListToArray = type =&gt; {</span><span class="s3">\n  </span><span class="s1">const cs = [];</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">while (n !== null) {</span><span class="s3">\n    </span><span class="s1">if (n.countable &amp;&amp; !n.deleted) {</span><span class="s3">\n      </span><span class="s1">const c = n.content.getContent();</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; c.length; i++) {</span><span class="s3">\n        </span><span class="s1">cs.push(c[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cs</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListToArraySnapshot = (type, snapshot) =&gt; {</span><span class="s3">\n  </span><span class="s1">const cs = [];</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">while (n !== null) {</span><span class="s3">\n    </span><span class="s1">if (n.countable &amp;&amp; isVisible(n, snapshot)) {</span><span class="s3">\n      </span><span class="s1">const c = n.content.getContent();</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; c.length; i++) {</span><span class="s3">\n        </span><span class="s1">cs.push(c[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cs</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Executes a provided function on once on overy element of this YArray.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {function(any,number,any):void} f A function to execute on every element of this YArray.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListForEach = (type, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">let index = 0;</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">while (n !== null) {</span><span class="s3">\n    </span><span class="s1">if (n.countable &amp;&amp; !n.deleted) {</span><span class="s3">\n      </span><span class="s1">const c = n.content.getContent();</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; c.length; i++) {</span><span class="s3">\n        </span><span class="s1">f(c[i], index++, type);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template C,R</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {function(C,number,AbstractType&lt;any&gt;):R} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListMap = (type, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const result = [];</span><span class="s3">\n  </span><span class="s1">typeListForEach(type, (c, i) =&gt; {</span><span class="s3">\n    </span><span class="s1">result.push(f(c, i, type));</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @return {IterableIterator&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListCreateIterator = type =&gt; {</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;any&gt;|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let currentContent = null;</span><span class="s3">\n  </span><span class="s1">let currentContentIndex = 0;</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n      </span><span class="s1">return this</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">next: () =&gt; {</span><span class="s3">\n      </span><span class="s1">// find some content</span><span class="s3">\n      </span><span class="s1">if (currentContent === null) {</span><span class="s3">\n        </span><span class="s1">while (n !== null &amp;&amp; n.deleted) {</span><span class="s3">\n          </span><span class="s1">n = n.right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// check if we reached the end, no need to check currentContent, because it does not exist</span><span class="s3">\n        </span><span class="s1">if (n === null) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">done: true,</span><span class="s3">\n            </span><span class="s1">value: undefined</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// we found n, so we can set currentContent</span><span class="s3">\n        </span><span class="s1">currentContent = n.content.getContent();</span><span class="s3">\n        </span><span class="s1">currentContentIndex = 0;</span><span class="s3">\n        </span><span class="s1">n = n.right; // we used the content of n, now iterate to next</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const value = currentContent[currentContentIndex++];</span><span class="s3">\n      </span><span class="s1">// check if we need to empty currentContent</span><span class="s3">\n      </span><span class="s1">if (currentContent.length &lt;= currentContentIndex) {</span><span class="s3">\n        </span><span class="s1">currentContent = null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">done: false,</span><span class="s3">\n        </span><span class="s1">value</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @return {any}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListGet = (type, index) =&gt; {</span><span class="s3">\n  </span><span class="s1">const marker = findMarker(type, index);</span><span class="s3">\n  </span><span class="s1">let n = type._start;</span><span class="s3">\n  </span><span class="s1">if (marker !== null) {</span><span class="s3">\n    </span><span class="s1">n = marker.p;</span><span class="s3">\n    </span><span class="s1">index -= marker.index;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (; n !== null; n = n.right) {</span><span class="s3">\n    </span><span class="s1">if (!n.deleted &amp;&amp; n.countable) {</span><span class="s3">\n      </span><span class="s1">if (index &lt; n.length) {</span><span class="s3">\n        </span><span class="s1">return n.content.getContent()[index]</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">index -= n.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {Item?} referenceItem</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Object&lt;string,any&gt;|Array&lt;any&gt;|boolean|number|null|string|Uint8Array&gt;} content</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) =&gt; {</span><span class="s3">\n  </span><span class="s1">let left = referenceItem;</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">const store = doc.store;</span><span class="s3">\n  </span><span class="s1">const right = referenceItem === null ? parent._start : referenceItem.right;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;Object|Array&lt;any&gt;|number|null&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let jsonContent = [];</span><span class="s3">\n  </span><span class="s1">const packJsonContent = () =&gt; {</span><span class="s3">\n    </span><span class="s1">if (jsonContent.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentAny(jsonContent));</span><span class="s3">\n      </span><span class="s1">left.integrate(transaction, 0);</span><span class="s3">\n      </span><span class="s1">jsonContent = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">content.forEach(c =&gt; {</span><span class="s3">\n    </span><span class="s1">if (c === null) {</span><span class="s3">\n      </span><span class="s1">jsonContent.push(c);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">switch (c.constructor) {</span><span class="s3">\n        </span><span class="s1">case Number:</span><span class="s3">\n        </span><span class="s1">case Object:</span><span class="s3">\n        </span><span class="s1">case Boolean:</span><span class="s3">\n        </span><span class="s1">case Array:</span><span class="s3">\n        </span><span class="s1">case String:</span><span class="s3">\n          </span><span class="s1">jsonContent.push(c);</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">packJsonContent();</span><span class="s3">\n          </span><span class="s1">switch (c.constructor) {</span><span class="s3">\n            </span><span class="s1">case Uint8Array:</span><span class="s3">\n            </span><span class="s1">case ArrayBuffer:</span><span class="s3">\n              </span><span class="s1">left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))));</span><span class="s3">\n              </span><span class="s1">left.integrate(transaction, 0);</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case Doc:</span><span class="s3">\n              </span><span class="s1">left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)));</span><span class="s3">\n              </span><span class="s1">left.integrate(transaction, 0);</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n              </span><span class="s1">if (c instanceof AbstractType) {</span><span class="s3">\n                </span><span class="s1">left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentType(c));</span><span class="s3">\n                </span><span class="s1">left.integrate(transaction, 0);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">throw new Error('Unexpected content type in insert operation')</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">packJsonContent();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const lengthExceeded = () =&gt; error.create('Length exceeded!');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Object&lt;string,any&gt;|Array&lt;any&gt;|number|null|string|Uint8Array&gt;} content</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListInsertGenerics = (transaction, parent, index, content) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (index &gt; parent._length) {</span><span class="s3">\n    </span><span class="s1">throw lengthExceeded()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (index === 0) {</span><span class="s3">\n    </span><span class="s1">if (parent._searchMarker) {</span><span class="s3">\n      </span><span class="s1">updateMarkerChanges(parent._searchMarker, index, content.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return typeListInsertGenericsAfter(transaction, parent, null, content)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const startIndex = index;</span><span class="s3">\n  </span><span class="s1">const marker = findMarker(parent, index);</span><span class="s3">\n  </span><span class="s1">let n = parent._start;</span><span class="s3">\n  </span><span class="s1">if (marker !== null) {</span><span class="s3">\n    </span><span class="s1">n = marker.p;</span><span class="s3">\n    </span><span class="s1">index -= marker.index;</span><span class="s3">\n    </span><span class="s1">// we need to iterate one to the left so that the algorithm works</span><span class="s3">\n    </span><span class="s1">if (index === 0) {</span><span class="s3">\n      </span><span class="s1">// @todo refactor this as it actually doesn't consider formats</span><span class="s3">\n      </span><span class="s1">n = n.prev; // important! get the left undeleted item so that we can actually decrease index</span><span class="s3">\n      </span><span class="s1">index += (n &amp;&amp; n.countable &amp;&amp; !n.deleted) ? n.length : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (; n !== null; n = n.right) {</span><span class="s3">\n    </span><span class="s1">if (!n.deleted &amp;&amp; n.countable) {</span><span class="s3">\n      </span><span class="s1">if (index &lt;= n.length) {</span><span class="s3">\n        </span><span class="s1">if (index &lt; n.length) {</span><span class="s3">\n          </span><span class="s1">// insert in-between</span><span class="s3">\n          </span><span class="s1">getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">index -= n.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parent._searchMarker) {</span><span class="s3">\n    </span><span class="s1">updateMarkerChanges(parent._searchMarker, startIndex, content.length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return typeListInsertGenericsAfter(transaction, parent, n, content)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Pushing content is special as we generally want to push after the last item. So we don't have to update</span><span class="s3">\n </span><span class="s1">* the serach marker.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Object&lt;string,any&gt;|Array&lt;any&gt;|number|null|string|Uint8Array&gt;} content</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListPushGenerics = (transaction, parent, content) =&gt; {</span><span class="s3">\n  </span><span class="s1">// Use the marker with the highest index and iterate to the right.</span><span class="s3">\n  </span><span class="s1">const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) =&gt; currMarker.index &gt; maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });</span><span class="s3">\n  </span><span class="s1">let n = marker.p;</span><span class="s3">\n  </span><span class="s1">if (n) {</span><span class="s3">\n    </span><span class="s1">while (n.right) {</span><span class="s3">\n      </span><span class="s1">n = n.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return typeListInsertGenericsAfter(transaction, parent, n, content)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @param {number} length</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeListDelete = (transaction, parent, index, length) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (length === 0) { return }</span><span class="s3">\n  </span><span class="s1">const startIndex = index;</span><span class="s3">\n  </span><span class="s1">const startLength = length;</span><span class="s3">\n  </span><span class="s1">const marker = findMarker(parent, index);</span><span class="s3">\n  </span><span class="s1">let n = parent._start;</span><span class="s3">\n  </span><span class="s1">if (marker !== null) {</span><span class="s3">\n    </span><span class="s1">n = marker.p;</span><span class="s3">\n    </span><span class="s1">index -= marker.index;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// compute the first item to be deleted</span><span class="s3">\n  </span><span class="s1">for (; n !== null &amp;&amp; index &gt; 0; n = n.right) {</span><span class="s3">\n    </span><span class="s1">if (!n.deleted &amp;&amp; n.countable) {</span><span class="s3">\n      </span><span class="s1">if (index &lt; n.length) {</span><span class="s3">\n        </span><span class="s1">getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">index -= n.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// delete all items until done</span><span class="s3">\n  </span><span class="s1">while (length &gt; 0 &amp;&amp; n !== null) {</span><span class="s3">\n    </span><span class="s1">if (!n.deleted) {</span><span class="s3">\n      </span><span class="s1">if (length &lt; n.length) {</span><span class="s3">\n        </span><span class="s1">getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">n.delete(transaction);</span><span class="s3">\n      </span><span class="s1">length -= n.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">n = n.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">throw lengthExceeded()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parent._searchMarker) {</span><span class="s3">\n    </span><span class="s1">updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {string} key</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapDelete = (transaction, parent, key) =&gt; {</span><span class="s3">\n  </span><span class="s1">const c = parent._map.get(key);</span><span class="s3">\n  </span><span class="s1">if (c !== undefined) {</span><span class="s3">\n    </span><span class="s1">c.delete(transaction);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {string} key</span><span class="s3">\n </span><span class="s1">* @param {Object|number|null|Array&lt;any&gt;|string|Uint8Array|AbstractType&lt;any&gt;} value</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapSet = (transaction, parent, key, value) =&gt; {</span><span class="s3">\n  </span><span class="s1">const left = parent._map.get(key) || null;</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">let content;</span><span class="s3">\n  </span><span class="s1">if (value == null) {</span><span class="s3">\n    </span><span class="s1">content = new ContentAny([value]);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">switch (value.constructor) {</span><span class="s3">\n      </span><span class="s1">case Number:</span><span class="s3">\n      </span><span class="s1">case Object:</span><span class="s3">\n      </span><span class="s1">case Boolean:</span><span class="s3">\n      </span><span class="s1">case Array:</span><span class="s3">\n      </span><span class="s1">case String:</span><span class="s3">\n        </span><span class="s1">content = new ContentAny([value]);</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case Uint8Array:</span><span class="s3">\n        </span><span class="s1">content = new ContentBinary(/** @type {Uint8Array} */ (value));</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">case Doc:</span><span class="s3">\n        </span><span class="s1">content = new ContentDoc(/** @type {Doc} */ (value));</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (value instanceof AbstractType) {</span><span class="s3">\n          </span><span class="s1">content = new ContentType(value);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error('Unexpected content type')</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left &amp;&amp; left.lastId, null, null, parent, key, content).integrate(transaction, 0);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {string} key</span><span class="s3">\n </span><span class="s1">* @return {Object&lt;string,any&gt;|number|null|Array&lt;any&gt;|string|Uint8Array|AbstractType&lt;any&gt;|undefined}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapGet = (parent, key) =&gt; {</span><span class="s3">\n  </span><span class="s1">const val = parent._map.get(key);</span><span class="s3">\n  </span><span class="s1">return val !== undefined &amp;&amp; !val.deleted ? val.content.getContent()[val.length - 1] : undefined</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @return {Object&lt;string,Object&lt;string,any&gt;|number|null|Array&lt;any&gt;|string|Uint8Array|AbstractType&lt;any&gt;|undefined&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapGetAll = (parent) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const res = {};</span><span class="s3">\n  </span><span class="s1">parent._map.forEach((value, key) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!value.deleted) {</span><span class="s3">\n      </span><span class="s1">res[key] = value.content.getContent()[value.length - 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {string} key</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapHas = (parent, key) =&gt; {</span><span class="s3">\n  </span><span class="s1">const val = parent._map.get(key);</span><span class="s3">\n  </span><span class="s1">return val !== undefined &amp;&amp; !val.deleted</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {string} key</span><span class="s3">\n </span><span class="s1">* @param {Snapshot} snapshot</span><span class="s3">\n </span><span class="s1">* @return {Object&lt;string,any&gt;|number|null|Array&lt;any&gt;|string|Uint8Array|AbstractType&lt;any&gt;|undefined}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeMapGetSnapshot = (parent, key, snapshot) =&gt; {</span><span class="s3">\n  </span><span class="s1">let v = parent._map.get(key) || null;</span><span class="s3">\n  </span><span class="s1">while (v !== null &amp;&amp; (!snapshot.sv.has(v.id.client) || v.id.clock &gt;= (snapshot.sv.get(v.id.client) || 0))) {</span><span class="s3">\n    </span><span class="s1">v = v.left;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return v !== null &amp;&amp; isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,Item&gt;} map</span><span class="s3">\n </span><span class="s1">* @return {IterableIterator&lt;Array&lt;any&gt;&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createMapIterator = map =&gt; iterator.iteratorFilter(map.entries(), /** @param {any} entry */ entry =&gt; !entry[1].deleted);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @module YArray</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Event that describes the changes on a YArray</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @extends YEvent&lt;YArray&lt;T&gt;&gt;</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YArrayEvent extends YEvent {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {YArray&lt;T&gt;} yarray The changed type</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction The transaction object</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (yarray, transaction) {</span><span class="s3">\n    </span><span class="s1">super(yarray, transaction);</span><span class="s3">\n    </span><span class="s1">this._transaction = transaction;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A shared Array implementation.</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @extends AbstractType&lt;YArrayEvent&lt;T&gt;&gt;</span><span class="s3">\n </span><span class="s1">* @implements {Iterable&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YArray extends AbstractType {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;any&gt;?}</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._prelimContent = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;ArraySearchMarker&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._searchMarker = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Construct a new YArray containing the specified items.</span><span class="s3">\n   </span><span class="s1">* @template {Object&lt;string,any&gt;|Array&lt;any&gt;|number|null|string|Uint8Array} T</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;T&gt;} items</span><span class="s3">\n   </span><span class="s1">* @return {YArray&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">static from (items) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {YArray&lt;T&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const a = new YArray();</span><span class="s3">\n    </span><span class="s1">a.push(items);</span><span class="s3">\n    </span><span class="s1">return a</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Integrate this type into the Yjs instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * Save this struct in the os</span><span class="s3">\n   </span><span class="s1">* * This type is sent to other client</span><span class="s3">\n   </span><span class="s1">* * Observer functions are fired</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y The Yjs instance</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">super._integrate(y, item);</span><span class="s3">\n    </span><span class="s1">this.insert(0, /** @type {Array&lt;any&gt;} */ (this._prelimContent));</span><span class="s3">\n    </span><span class="s1">this._prelimContent = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YArray&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YArray()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YArray&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {YArray&lt;T&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const arr = new YArray();</span><span class="s3">\n    </span><span class="s1">arr.insert(0, this.toArray().map(el =&gt;</span><span class="s3">\n      </span><span class="s1">el instanceof AbstractType ? /** @type {typeof el} */ (el.clone()) : el</span><span class="s3">\n    </span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">return arr</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get length () {</span><span class="s3">\n    </span><span class="s1">return this._prelimContent === null ? this._length : this._prelimContent.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates YArrayEvent and calls observers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;null|string&gt;} parentSubs Keys changed on this type. `null` if list was modified.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_callObserver (transaction, parentSubs) {</span><span class="s3">\n    </span><span class="s1">super._callObserver(transaction, parentSubs);</span><span class="s3">\n    </span><span class="s1">callTypeObservers(this, transaction, new YArrayEvent(this, transaction));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Inserts new content at an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Important: This function expects an array of content. Not just a content</span><span class="s3">\n   </span><span class="s1">* object. The reason for this </span><span class="s3">\&quot;</span><span class="s1">weirdness</span><span class="s3">\&quot; </span><span class="s1">is that inserting several elements</span><span class="s3">\n   </span><span class="s1">* is very efficient when it is done as a single operation.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*  // Insert character 'a' at position 0</span><span class="s3">\n   </span><span class="s1">*  yarray.insert(0, ['a'])</span><span class="s3">\n   </span><span class="s1">*  // Insert numbers 1, 2 at position 1</span><span class="s3">\n   </span><span class="s1">*  yarray.insert(1, [1, 2])</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index to insert content at.</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;T&gt;} content The array of content</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">insert (index, content) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeListInsertGenerics(transaction, this, index, /** @type {any} */ (content));</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;any&gt;} */ (this._prelimContent).splice(index, 0, ...content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends content to this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;T&gt;} content Array of content to append.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo Use the following implementation in all types.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">push (content) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeListPushGenerics(transaction, this, /** @type {any} */ (content));</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;any&gt;} */ (this._prelimContent).push(...content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preppends content to this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;T&gt;} content Array of content to preppend.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">unshift (content) {</span><span class="s3">\n    </span><span class="s1">this.insert(0, content);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Deletes elements starting from an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index Index at which to start deleting elements</span><span class="s3">\n   </span><span class="s1">* @param {number} length The number of elements to remove. Defaults to 1.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (index, length = 1) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeListDelete(transaction, this, index, length);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;any&gt;} */ (this._prelimContent).splice(index, length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the i-th element from a YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index of the element to return from the YArray</span><span class="s3">\n   </span><span class="s1">* @return {T}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get (index) {</span><span class="s3">\n    </span><span class="s1">return typeListGet(this, index)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this YArray to a JavaScript Array.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toArray () {</span><span class="s3">\n    </span><span class="s1">return typeListToArray(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this YArray to a JavaScript Array.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} [start]</span><span class="s3">\n   </span><span class="s1">* @param {number} [end]</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">slice (start = 0, end = this.length) {</span><span class="s3">\n    </span><span class="s1">return typeListSlice(this, start, end)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this Shared Type to a JSON object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">return this.map(c =&gt; c instanceof AbstractType ? c.toJSON() : c)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an Array with the result of calling a provided function on every</span><span class="s3">\n   </span><span class="s1">* element of this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template M</span><span class="s3">\n   </span><span class="s1">* @param {function(T,number,YArray&lt;T&gt;):M} f Function that produces an element of the new Array</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;M&gt;} A new array with each element being the result of the</span><span class="s3">\n   </span><span class="s1">*                 callback function</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">map (f) {</span><span class="s3">\n    </span><span class="s1">return typeListMap(this, /** @type {any} */ (f))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Executes a provided function once on overy element of this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(T,number,YArray&lt;T&gt;):void} f A function to execute on every element of this YArray.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forEach (f) {</span><span class="s3">\n    </span><span class="s1">typeListForEach(this, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n    </span><span class="s1">return typeListCreateIterator(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YArrayRefID);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYArray = _decoder =&gt; new YArray();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @extends YEvent&lt;YMap&lt;T&gt;&gt;</span><span class="s3">\n </span><span class="s1">* Event that describes the changes on a YMap.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YMapEvent extends YEvent {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {YMap&lt;T&gt;} ymap The YArray that changed.</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;any&gt;} subs The keys that changed.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (ymap, transaction, subs) {</span><span class="s3">\n    </span><span class="s1">super(ymap, transaction);</span><span class="s3">\n    </span><span class="s1">this.keysChanged = subs;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template MapType</span><span class="s3">\n </span><span class="s1">* A shared Map implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends AbstractType&lt;YMapEvent&lt;MapType&gt;&gt;</span><span class="s3">\n </span><span class="s1">* @implements {Iterable&lt;MapType&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YMap extends AbstractType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Iterable&lt;readonly [string, any]&gt;=} entries - an optional iterable to initialize the YMap</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (entries) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string,any&gt;?}</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._prelimContent = null;</span><span class="s3">\n\n    </span><span class="s1">if (entries === undefined) {</span><span class="s3">\n      </span><span class="s1">this._prelimContent = new Map();</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this._prelimContent = new Map(entries);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Integrate this type into the Yjs instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * Save this struct in the os</span><span class="s3">\n   </span><span class="s1">* * This type is sent to other client</span><span class="s3">\n   </span><span class="s1">* * Observer functions are fired</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y The Yjs instance</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">super._integrate(y, item)</span><span class="s3">\n    </span><span class="s1">;/** @type {Map&lt;string, any&gt;} */ (this._prelimContent).forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.set(key, value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">this._prelimContent = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YMap&lt;MapType&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YMap()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YMap&lt;MapType&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {YMap&lt;MapType&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const map = new YMap();</span><span class="s3">\n    </span><span class="s1">this.forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">map.set(key, value instanceof AbstractType ? /** @type {typeof value} */ (value.clone()) : value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return map</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates YMapEvent and calls observers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;null|string&gt;} parentSubs Keys changed on this type. `null` if list was modified.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_callObserver (transaction, parentSubs) {</span><span class="s3">\n    </span><span class="s1">callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this Shared Type to a JSON object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Object&lt;string,any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Object&lt;string,MapType&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const map = {};</span><span class="s3">\n    </span><span class="s1">this._map.forEach((item, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n        </span><span class="s1">const v = item.content.getContent()[item.length - 1];</span><span class="s3">\n        </span><span class="s1">map[key] = v instanceof AbstractType ? v.toJSON() : v;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return map</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the size of the YMap (count of key/value pairs)</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get size () {</span><span class="s3">\n    </span><span class="s1">return [...createMapIterator(this._map)].length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the keys for each element in the YMap Type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;string&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">keys () {</span><span class="s3">\n    </span><span class="s1">return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v =&gt; v[0])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the values for each element in the YMap Type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">values () {</span><span class="s3">\n    </span><span class="s1">return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v =&gt; v[1].content.getContent()[v[1].length - 1])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an Iterator of [key, value] pairs</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">entries () {</span><span class="s3">\n    </span><span class="s1">return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v =&gt; [v[0], v[1].content.getContent()[v[1].length - 1]])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Executes a provided function on once on every key-value pair.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(MapType,string,YMap&lt;MapType&gt;):void} f A function to execute on every element of this YArray.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forEach (f) {</span><span class="s3">\n    </span><span class="s1">this._map.forEach((item, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n        </span><span class="s1">f(item.content.getContent()[item.length - 1], key, this);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an Iterator of [key, value] pairs</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {IterableIterator&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n    </span><span class="s1">return this.entries()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Remove a specified element from this YMap.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} key The key of the element to remove.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (key) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapDelete(transaction, this, key);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Map&lt;string, any&gt;} */ (this._prelimContent).delete(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Adds or updates an element with a specified key and value.</span><span class="s3">\n   </span><span class="s1">* @template {MapType} VAL</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} key The key of the element to add to this YMap</span><span class="s3">\n   </span><span class="s1">* @param {VAL} value The value of the element to add</span><span class="s3">\n   </span><span class="s1">* @return {VAL}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set (key, value) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapSet(transaction, this, key, /** @type {any} */ (value));</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Map&lt;string, any&gt;} */ (this._prelimContent).set(key, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return value</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a specified element from this YMap.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">* @return {MapType|undefined}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get (key) {</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (typeMapGet(this, key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns a boolean indicating whether the specified key exists or not.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} key The key to test.</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">has (key) {</span><span class="s3">\n    </span><span class="s1">return typeMapHas(this, key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes all elements from this YMap.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clear () {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">this.forEach(function (_value, key, map) {</span><span class="s3">\n          </span><span class="s1">typeMapDelete(transaction, map, key);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Map&lt;string, any&gt;} */ (this._prelimContent).clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YMapRefID);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYMap = _decoder =&gt; new YMap();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} a</span><span class="s3">\n </span><span class="s1">* @param {any} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const equalAttrs = (a, b) =&gt; a === b || (typeof a === 'object' &amp;&amp; typeof b === 'object' &amp;&amp; a &amp;&amp; b &amp;&amp; object.equalFlat(a, b));</span><span class="s3">\n\n</span><span class="s1">class ItemTextListPosition {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Item|null} left</span><span class="s3">\n   </span><span class="s1">* @param {Item|null} right</span><span class="s3">\n   </span><span class="s1">* @param {number} index</span><span class="s3">\n   </span><span class="s1">* @param {Map&lt;string,any&gt;} currentAttributes</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (left, right, index, currentAttributes) {</span><span class="s3">\n    </span><span class="s1">this.left = left;</span><span class="s3">\n    </span><span class="s1">this.right = right;</span><span class="s3">\n    </span><span class="s1">this.index = index;</span><span class="s3">\n    </span><span class="s1">this.currentAttributes = currentAttributes;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Only call this if you know that this.right is defined</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forward () {</span><span class="s3">\n    </span><span class="s1">if (this.right === null) {</span><span class="s3">\n      </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">switch (this.right.content.constructor) {</span><span class="s3">\n      </span><span class="s1">case ContentFormat:</span><span class="s3">\n        </span><span class="s1">if (!this.right.deleted) {</span><span class="s3">\n          </span><span class="s1">updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (!this.right.deleted) {</span><span class="s3">\n          </span><span class="s1">this.index += this.right.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.left = this.right;</span><span class="s3">\n    </span><span class="s1">this.right = this.right.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} pos</span><span class="s3">\n </span><span class="s1">* @param {number} count steps to move forward</span><span class="s3">\n </span><span class="s1">* @return {ItemTextListPosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findNextPosition = (transaction, pos, count) =&gt; {</span><span class="s3">\n  </span><span class="s1">while (pos.right !== null &amp;&amp; count &gt; 0) {</span><span class="s3">\n    </span><span class="s1">switch (pos.right.content.constructor) {</span><span class="s3">\n      </span><span class="s1">case ContentFormat:</span><span class="s3">\n        </span><span class="s1">if (!pos.right.deleted) {</span><span class="s3">\n          </span><span class="s1">updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">default:</span><span class="s3">\n        </span><span class="s1">if (!pos.right.deleted) {</span><span class="s3">\n          </span><span class="s1">if (count &lt; pos.right.length) {</span><span class="s3">\n            </span><span class="s1">// split right</span><span class="s3">\n            </span><span class="s1">getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">pos.index += pos.right.length;</span><span class="s3">\n          </span><span class="s1">count -= pos.right.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">pos.left = pos.right;</span><span class="s3">\n    </span><span class="s1">pos.right = pos.right.right;</span><span class="s3">\n    </span><span class="s1">// pos.forward() - we don't forward because that would halve the performance because we already do the checks above</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pos</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {number} index</span><span class="s3">\n </span><span class="s1">* @return {ItemTextListPosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findPosition = (transaction, parent, index) =&gt; {</span><span class="s3">\n  </span><span class="s1">const currentAttributes = new Map();</span><span class="s3">\n  </span><span class="s1">const marker = findMarker(parent, index);</span><span class="s3">\n  </span><span class="s1">if (marker) {</span><span class="s3">\n    </span><span class="s1">const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);</span><span class="s3">\n    </span><span class="s1">return findNextPosition(transaction, pos, index - marker.index)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);</span><span class="s3">\n    </span><span class="s1">return findNextPosition(transaction, pos, index)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Negate applied formats</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,any&gt;} negatedAttributes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">// check if we really need to remove attributes</span><span class="s3">\n  </span><span class="s1">while (</span><span class="s3">\n    </span><span class="s1">currPos.right !== null &amp;&amp; (</span><span class="s3">\n      </span><span class="s1">currPos.right.deleted === true || (</span><span class="s3">\n        </span><span class="s1">currPos.right.content.constructor === ContentFormat &amp;&amp;</span><span class="s3">\n        </span><span class="s1">equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!currPos.right.deleted) {</span><span class="s3">\n      </span><span class="s1">negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">negatedAttributes.forEach((val, key) =&gt; {</span><span class="s3">\n    </span><span class="s1">const left = currPos.left;</span><span class="s3">\n    </span><span class="s1">const right = currPos.right;</span><span class="s3">\n    </span><span class="s1">const nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentFormat(key, val));</span><span class="s3">\n    </span><span class="s1">nextFormat.integrate(transaction, 0);</span><span class="s3">\n    </span><span class="s1">currPos.right = nextFormat;</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,any&gt;} currentAttributes</span><span class="s3">\n </span><span class="s1">* @param {ContentFormat} format</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const updateCurrentAttributes = (currentAttributes, format) =&gt; {</span><span class="s3">\n  </span><span class="s1">const { key, value } = format;</span><span class="s3">\n  </span><span class="s1">if (value === null) {</span><span class="s3">\n    </span><span class="s1">currentAttributes.delete(key);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">currentAttributes.set(key, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} attributes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const minimizeAttributeChanges = (currPos, attributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">// go right while attributes[right.key] === right.value (or right is deleted)</span><span class="s3">\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">if (currPos.right === null) {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">} else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat &amp;&amp; equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) ; else {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} attributes</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;string,any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n</span><span class="s1">const insertAttributes = (transaction, parent, currPos, attributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">const negatedAttributes = new Map();</span><span class="s3">\n  </span><span class="s1">// insert format-start items</span><span class="s3">\n  </span><span class="s1">for (const key in attributes) {</span><span class="s3">\n    </span><span class="s1">const val = attributes[key];</span><span class="s3">\n    </span><span class="s1">const currentVal = currPos.currentAttributes.get(key) || null;</span><span class="s3">\n    </span><span class="s1">if (!equalAttrs(currentVal, val)) {</span><span class="s3">\n      </span><span class="s1">// save negated attribute (set null if currentVal undefined)</span><span class="s3">\n      </span><span class="s1">negatedAttributes.set(key, currentVal);</span><span class="s3">\n      </span><span class="s1">const { left, right } = currPos;</span><span class="s3">\n      </span><span class="s1">currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, new ContentFormat(key, val));</span><span class="s3">\n      </span><span class="s1">currPos.right.integrate(transaction, 0);</span><span class="s3">\n      </span><span class="s1">currPos.forward();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return negatedAttributes</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {string|object|AbstractType&lt;any&gt;} text</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} attributes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">**/</span><span class="s3">\n</span><span class="s1">const insertText = (transaction, parent, currPos, text, attributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">currPos.currentAttributes.forEach((_val, key) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (attributes[key] === undefined) {</span><span class="s3">\n      </span><span class="s1">attributes[key] = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">minimizeAttributeChanges(currPos, attributes);</span><span class="s3">\n  </span><span class="s1">const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);</span><span class="s3">\n  </span><span class="s1">// insert content</span><span class="s3">\n  </span><span class="s1">const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : (text instanceof AbstractType ? new ContentType(text) : new ContentEmbed(text));</span><span class="s3">\n  </span><span class="s1">let { left, right, index } = currPos;</span><span class="s3">\n  </span><span class="s1">if (parent._searchMarker) {</span><span class="s3">\n    </span><span class="s1">updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left &amp;&amp; left.lastId, right, right &amp;&amp; right.id, parent, null, content);</span><span class="s3">\n  </span><span class="s1">right.integrate(transaction, 0);</span><span class="s3">\n  </span><span class="s1">currPos.right = right;</span><span class="s3">\n  </span><span class="s1">currPos.index = index;</span><span class="s3">\n  </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {AbstractType&lt;any&gt;} parent</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {number} length</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} attributes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const formatText = (transaction, parent, currPos, length, attributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const ownClientId = doc.clientID;</span><span class="s3">\n  </span><span class="s1">minimizeAttributeChanges(currPos, attributes);</span><span class="s3">\n  </span><span class="s1">const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);</span><span class="s3">\n  </span><span class="s1">// iterate until first non-format or null is found</span><span class="s3">\n  </span><span class="s1">// delete all formats with attributes[format.key] != null</span><span class="s3">\n  </span><span class="s1">// also check the attributes after the first non-format as we do not want to insert redundant negated attributes there</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line no-labels</span><span class="s3">\n  </span><span class="s1">iterationLoop: while (</span><span class="s3">\n    </span><span class="s1">currPos.right !== null &amp;&amp;</span><span class="s3">\n    </span><span class="s1">(length &gt; 0 ||</span><span class="s3">\n      </span><span class="s1">(</span><span class="s3">\n        </span><span class="s1">negatedAttributes.size &gt; 0 &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(currPos.right.deleted || currPos.right.content.constructor === ContentFormat)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (!currPos.right.deleted) {</span><span class="s3">\n      </span><span class="s1">switch (currPos.right.content.constructor) {</span><span class="s3">\n        </span><span class="s1">case ContentFormat: {</span><span class="s3">\n          </span><span class="s1">const { key, value } = /** @type {ContentFormat} */ (currPos.right.content);</span><span class="s3">\n          </span><span class="s1">const attr = attributes[key];</span><span class="s3">\n          </span><span class="s1">if (attr !== undefined) {</span><span class="s3">\n            </span><span class="s1">if (equalAttrs(attr, value)) {</span><span class="s3">\n              </span><span class="s1">negatedAttributes.delete(key);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">if (length === 0) {</span><span class="s3">\n                </span><span class="s1">// no need to further extend negatedAttributes</span><span class="s3">\n                </span><span class="s1">// eslint-disable-next-line no-labels</span><span class="s3">\n                </span><span class="s1">break iterationLoop</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">negatedAttributes.set(key, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">currPos.right.delete(transaction);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">currPos.currentAttributes.set(key, value);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n          </span><span class="s1">if (length &lt; currPos.right.length) {</span><span class="s3">\n            </span><span class="s1">getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">length -= currPos.right.length;</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Quill just assumes that the editor starts with a newline and that it always</span><span class="s3">\n  </span><span class="s1">// ends with a newline. We only insert that newline when a new newline is</span><span class="s3">\n  </span><span class="s1">// inserted - i.e when length is bigger than type.length</span><span class="s3">\n  </span><span class="s1">if (length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">let newlines = '';</span><span class="s3">\n    </span><span class="s1">for (; length &gt; 0; length--) {</span><span class="s3">\n      </span><span class="s1">newlines += '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left &amp;&amp; currPos.left.lastId, currPos.right, currPos.right &amp;&amp; currPos.right.id, parent, null, new ContentString(newlines));</span><span class="s3">\n    </span><span class="s1">currPos.right.integrate(transaction, 0);</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Call this function after string content has been deleted in order to</span><span class="s3">\n </span><span class="s1">* clean up formatting Items.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Item} start</span><span class="s3">\n </span><span class="s1">* @param {Item|null} curr exclusive end, automatically iterates to the next Content Item</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,any&gt;} startAttributes</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;string,any&gt;} currAttributes</span><span class="s3">\n </span><span class="s1">* @return {number} The amount of formatting Items deleted.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Item|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let end = start;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Map&lt;string,ContentFormat&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const endFormats = map.create();</span><span class="s3">\n  </span><span class="s1">while (end &amp;&amp; (!end.countable || end.deleted)) {</span><span class="s3">\n    </span><span class="s1">if (!end.deleted &amp;&amp; end.content.constructor === ContentFormat) {</span><span class="s3">\n      </span><span class="s1">const cf = /** @type {ContentFormat} */ (end.content);</span><span class="s3">\n      </span><span class="s1">endFormats.set(cf.key, cf);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">end = end.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let cleanups = 0;</span><span class="s3">\n  </span><span class="s1">let reachedCurr = false;</span><span class="s3">\n  </span><span class="s1">while (start !== end) {</span><span class="s3">\n    </span><span class="s1">if (curr === start) {</span><span class="s3">\n      </span><span class="s1">reachedCurr = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!start.deleted) {</span><span class="s3">\n      </span><span class="s1">const content = start.content;</span><span class="s3">\n      </span><span class="s1">switch (content.constructor) {</span><span class="s3">\n        </span><span class="s1">case ContentFormat: {</span><span class="s3">\n          </span><span class="s1">const { key, value } = /** @type {ContentFormat} */ (content);</span><span class="s3">\n          </span><span class="s1">const startAttrValue = startAttributes.get(key) || null;</span><span class="s3">\n          </span><span class="s1">if (endFormats.get(key) !== content || startAttrValue === value) {</span><span class="s3">\n            </span><span class="s1">// Either this format is overwritten or it is not necessary because the attribute already existed.</span><span class="s3">\n            </span><span class="s1">start.delete(transaction);</span><span class="s3">\n            </span><span class="s1">cleanups++;</span><span class="s3">\n            </span><span class="s1">if (!reachedCurr &amp;&amp; (currAttributes.get(key) || null) === value &amp;&amp; startAttrValue !== value) {</span><span class="s3">\n              </span><span class="s1">if (startAttrValue === null) {</span><span class="s3">\n                </span><span class="s1">currAttributes.delete(key);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">currAttributes.set(key, startAttrValue);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!reachedCurr &amp;&amp; !start.deleted) {</span><span class="s3">\n            </span><span class="s1">updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */ (content));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">start = /** @type {Item} */ (start.right);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return cleanups</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Item | null} item</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cleanupContextlessFormattingGap = (transaction, item) =&gt; {</span><span class="s3">\n  </span><span class="s1">// iterate until item.right is null or content</span><span class="s3">\n  </span><span class="s1">while (item &amp;&amp; item.right &amp;&amp; (item.right.deleted || !item.right.countable)) {</span><span class="s3">\n    </span><span class="s1">item = item.right;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const attrs = new Set();</span><span class="s3">\n  </span><span class="s1">// iterate back until a content item is found</span><span class="s3">\n  </span><span class="s1">while (item &amp;&amp; (item.deleted || !item.countable)) {</span><span class="s3">\n    </span><span class="s1">if (!item.deleted &amp;&amp; item.content.constructor === ContentFormat) {</span><span class="s3">\n      </span><span class="s1">const key = /** @type {ContentFormat} */ (item.content).key;</span><span class="s3">\n      </span><span class="s1">if (attrs.has(key)) {</span><span class="s3">\n        </span><span class="s1">item.delete(transaction);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">attrs.add(key);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">item = item.left;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is experimental and subject to change / be removed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Ideally, we don't need this function at all. Formatting attributes should be cleaned up</span><span class="s3">\n </span><span class="s1">* automatically after each change. This function iterates twice over the complete YText type</span><span class="s3">\n </span><span class="s1">* and removes unnecessary formatting attributes. This is also helpful for testing.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This function won't be exported anymore as soon as there is confidence that the YText type works as intended.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {YText} type</span><span class="s3">\n </span><span class="s1">* @return {number} How many formatting attributes have been cleaned up.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cleanupYTextFormatting = type =&gt; {</span><span class="s3">\n  </span><span class="s1">let res = 0;</span><span class="s3">\n  </span><span class="s1">transact(/** @type {Doc} */ (type.doc), transaction =&gt; {</span><span class="s3">\n    </span><span class="s1">let start = /** @type {Item} */ (type._start);</span><span class="s3">\n    </span><span class="s1">let end = type._start;</span><span class="s3">\n    </span><span class="s1">let startAttributes = map.create();</span><span class="s3">\n    </span><span class="s1">const currentAttributes = map.copy(startAttributes);</span><span class="s3">\n    </span><span class="s1">while (end) {</span><span class="s3">\n      </span><span class="s1">if (end.deleted === false) {</span><span class="s3">\n        </span><span class="s1">switch (end.content.constructor) {</span><span class="s3">\n          </span><span class="s1">case ContentFormat:</span><span class="s3">\n            </span><span class="s1">updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content));</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);</span><span class="s3">\n            </span><span class="s1">startAttributes = map.copy(currentAttributes);</span><span class="s3">\n            </span><span class="s1">start = end;</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">end = end.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This will be called by the transction once the event handlers are called to potentially cleanup</span><span class="s3">\n </span><span class="s1">* formatting attributes.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const cleanupYTextAfterTransaction = transaction =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Set&lt;YText&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const needFullCleanup = new Set();</span><span class="s3">\n  </span><span class="s1">// check if another formatting item was inserted</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">for (const [client, afterClock] of transaction.afterState.entries()) {</span><span class="s3">\n    </span><span class="s1">const clock = transaction.beforeState.get(client) || 0;</span><span class="s3">\n    </span><span class="s1">if (afterClock === clock) {</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">iterateStructs(transaction, /** @type {Array&lt;Item|GC&gt;} */ (doc.store.clients.get(client)), clock, afterClock, item =&gt; {</span><span class="s3">\n      </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">!item.deleted &amp;&amp; /** @type {Item} */ (item).content.constructor === ContentFormat &amp;&amp; item.constructor !== GC</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">needFullCleanup.add(/** @type {any} */ (item).parent);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// cleanup in a new transaction</span><span class="s3">\n  </span><span class="s1">transact(doc, (t) =&gt; {</span><span class="s3">\n    </span><span class="s1">iterateDeletedStructs(transaction, transaction.deleteSet, item =&gt; {</span><span class="s3">\n      </span><span class="s1">if (item instanceof GC || !(/** @type {YText} */ (item.parent)._hasFormatting) || needFullCleanup.has(/** @type {YText} */ (item.parent))) {</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">const parent = /** @type {YText} */ (item.parent);</span><span class="s3">\n      </span><span class="s1">if (item.content.constructor === ContentFormat) {</span><span class="s3">\n        </span><span class="s1">needFullCleanup.add(parent);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// If no formatting attribute was inserted or deleted, we can make due with contextless</span><span class="s3">\n        </span><span class="s1">// formatting cleanups.</span><span class="s3">\n        </span><span class="s1">// Contextless: it is not necessary to compute currentAttributes for the affected position.</span><span class="s3">\n        </span><span class="s1">cleanupContextlessFormattingGap(t, item);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// If a formatting item was inserted, we simply clean the whole type.</span><span class="s3">\n    </span><span class="s1">// We need to compute currentAttributes for the current position anyway.</span><span class="s3">\n    </span><span class="s1">for (const yText of needFullCleanup) {</span><span class="s3">\n      </span><span class="s1">cleanupYTextFormatting(yText);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {ItemTextListPosition} currPos</span><span class="s3">\n </span><span class="s1">* @param {number} length</span><span class="s3">\n </span><span class="s1">* @return {ItemTextListPosition}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteText = (transaction, currPos, length) =&gt; {</span><span class="s3">\n  </span><span class="s1">const startLength = length;</span><span class="s3">\n  </span><span class="s1">const startAttrs = map.copy(currPos.currentAttributes);</span><span class="s3">\n  </span><span class="s1">const start = currPos.right;</span><span class="s3">\n  </span><span class="s1">while (length &gt; 0 &amp;&amp; currPos.right !== null) {</span><span class="s3">\n    </span><span class="s1">if (currPos.right.deleted === false) {</span><span class="s3">\n      </span><span class="s1">switch (currPos.right.content.constructor) {</span><span class="s3">\n        </span><span class="s1">case ContentType:</span><span class="s3">\n        </span><span class="s1">case ContentEmbed:</span><span class="s3">\n        </span><span class="s1">case ContentString:</span><span class="s3">\n          </span><span class="s1">if (length &lt; currPos.right.length) {</span><span class="s3">\n            </span><span class="s1">getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">length -= currPos.right.length;</span><span class="s3">\n          </span><span class="s1">currPos.right.delete(transaction);</span><span class="s3">\n          </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currPos.forward();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (start) {</span><span class="s3">\n    </span><span class="s1">cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const parent = /** @type {AbstractType&lt;any&gt;} */ (/** @type {Item} */ (currPos.left || currPos.right).parent);</span><span class="s3">\n  </span><span class="s1">if (parent._searchMarker) {</span><span class="s3">\n    </span><span class="s1">updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return currPos</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Quill Delta format represents changes on a text document with</span><span class="s3">\n </span><span class="s1">* formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*   {</span><span class="s3">\n </span><span class="s1">*     ops: [</span><span class="s3">\n </span><span class="s1">*       { insert: 'Gandalf', attributes: { bold: true } },</span><span class="s3">\n </span><span class="s1">*       { insert: ' the ' },</span><span class="s3">\n </span><span class="s1">*       { insert: 'Grey', attributes: { color: '#cccccc' } }</span><span class="s3">\n </span><span class="s1">*     ]</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n  </span><span class="s1">* Attributes that can be assigned to a selection of text.</span><span class="s3">\n  </span><span class="s1">*</span><span class="s3">\n  </span><span class="s1">* @example</span><span class="s3">\n  </span><span class="s1">*   {</span><span class="s3">\n  </span><span class="s1">*     bold: true,</span><span class="s3">\n  </span><span class="s1">*     font-size: '40px'</span><span class="s3">\n  </span><span class="s1">*   }</span><span class="s3">\n  </span><span class="s1">*</span><span class="s3">\n  </span><span class="s1">* @typedef {Object} TextAttributes</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @extends YEvent&lt;YText&gt;</span><span class="s3">\n </span><span class="s1">* Event that describes the changes on a YText type.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YTextEvent extends YEvent {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {YText} ytext</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;any&gt;} subs The keys that changed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (ytext, transaction, subs) {</span><span class="s3">\n    </span><span class="s1">super(ytext, transaction);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the children changed.</span><span class="s3">\n     </span><span class="s1">* @type {Boolean}</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.childListChanged = false;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set of all changed attributes.</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;string&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.keysChanged = new Set();</span><span class="s3">\n    </span><span class="s1">subs.forEach((sub) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (sub === null) {</span><span class="s3">\n        </span><span class="s1">this.childListChanged = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.keysChanged.add(sub);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {{added:Set&lt;Item&gt;,deleted:Set&lt;Item&gt;,keys:Map&lt;string,{action:'add'|'update'|'delete',oldValue:any}&gt;,delta:Array&lt;{insert?:Array&lt;any&gt;|string, delete?:number, retain?:number}&gt;}}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get changes () {</span><span class="s3">\n    </span><span class="s1">if (this._changes === null) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {{added:Set&lt;Item&gt;,deleted:Set&lt;Item&gt;,keys:Map&lt;string,{action:'add'|'update'|'delete',oldValue:any}&gt;,delta:Array&lt;{insert?:Array&lt;any&gt;|string|AbstractType&lt;any&gt;|object, delete?:number, retain?:number}&gt;}}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const changes = {</span><span class="s3">\n        </span><span class="s1">keys: this.keys,</span><span class="s3">\n        </span><span class="s1">delta: this.delta,</span><span class="s3">\n        </span><span class="s1">added: new Set(),</span><span class="s3">\n        </span><span class="s1">deleted: new Set()</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">this._changes = changes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (this._changes)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Compute the changes in the delta format.</span><span class="s3">\n   </span><span class="s1">* A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;{insert?:string|object|AbstractType&lt;any&gt;, delete?:number, retain?:number, attributes?: Object&lt;string,any&gt;}&gt;}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get delta () {</span><span class="s3">\n    </span><span class="s1">if (this._delta === null) {</span><span class="s3">\n      </span><span class="s1">const y = /** @type {Doc} */ (this.target.doc);</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Array&lt;{insert?:string|object|AbstractType&lt;any&gt;, delete?:number, retain?:number, attributes?: Object&lt;string,any&gt;}&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const delta = [];</span><span class="s3">\n      </span><span class="s1">transact(y, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const currentAttributes = new Map(); // saves all current attributes for insert</span><span class="s3">\n        </span><span class="s1">const oldAttributes = new Map();</span><span class="s3">\n        </span><span class="s1">let item = this.target._start;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {string?}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let action = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const attributes = {}; // counts added or removed new attributes for retain</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {string|object}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let insert = '';</span><span class="s3">\n        </span><span class="s1">let retain = 0;</span><span class="s3">\n        </span><span class="s1">let deleteLen = 0;</span><span class="s3">\n        </span><span class="s1">const addOp = () =&gt; {</span><span class="s3">\n          </span><span class="s1">if (action !== null) {</span><span class="s3">\n            </span><span class="s1">/**</span><span class="s3">\n             </span><span class="s1">* @type {any}</span><span class="s3">\n             </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">let op = null;</span><span class="s3">\n            </span><span class="s1">switch (action) {</span><span class="s3">\n              </span><span class="s1">case 'delete':</span><span class="s3">\n                </span><span class="s1">if (deleteLen &gt; 0) {</span><span class="s3">\n                  </span><span class="s1">op = { delete: deleteLen };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">deleteLen = 0;</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">case 'insert':</span><span class="s3">\n                </span><span class="s1">if (typeof insert === 'object' || insert.length &gt; 0) {</span><span class="s3">\n                  </span><span class="s1">op = { insert };</span><span class="s3">\n                  </span><span class="s1">if (currentAttributes.size &gt; 0) {</span><span class="s3">\n                    </span><span class="s1">op.attributes = {};</span><span class="s3">\n                    </span><span class="s1">currentAttributes.forEach((value, key) =&gt; {</span><span class="s3">\n                      </span><span class="s1">if (value !== null) {</span><span class="s3">\n                        </span><span class="s1">op.attributes[key] = value;</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">insert = '';</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n              </span><span class="s1">case 'retain':</span><span class="s3">\n                </span><span class="s1">if (retain &gt; 0) {</span><span class="s3">\n                  </span><span class="s1">op = { retain };</span><span class="s3">\n                  </span><span class="s1">if (!object.isEmpty(attributes)) {</span><span class="s3">\n                    </span><span class="s1">op.attributes = object.assign({}, attributes);</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">retain = 0;</span><span class="s3">\n                </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (op) delta.push(op);</span><span class="s3">\n            </span><span class="s1">action = null;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">while (item !== null) {</span><span class="s3">\n          </span><span class="s1">switch (item.content.constructor) {</span><span class="s3">\n            </span><span class="s1">case ContentType:</span><span class="s3">\n            </span><span class="s1">case ContentEmbed:</span><span class="s3">\n              </span><span class="s1">if (this.adds(item)) {</span><span class="s3">\n                </span><span class="s1">if (!this.deletes(item)) {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">action = 'insert';</span><span class="s3">\n                  </span><span class="s1">insert = item.content.getContent()[0];</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (this.deletes(item)) {</span><span class="s3">\n                </span><span class="s1">if (action !== 'delete') {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">action = 'delete';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">deleteLen += 1;</span><span class="s3">\n              </span><span class="s1">} else if (!item.deleted) {</span><span class="s3">\n                </span><span class="s1">if (action !== 'retain') {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">action = 'retain';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">retain += 1;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case ContentString:</span><span class="s3">\n              </span><span class="s1">if (this.adds(item)) {</span><span class="s3">\n                </span><span class="s1">if (!this.deletes(item)) {</span><span class="s3">\n                  </span><span class="s1">if (action !== 'insert') {</span><span class="s3">\n                    </span><span class="s1">addOp();</span><span class="s3">\n                    </span><span class="s1">action = 'insert';</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">insert += /** @type {ContentString} */ (item.content).str;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (this.deletes(item)) {</span><span class="s3">\n                </span><span class="s1">if (action !== 'delete') {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">action = 'delete';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">deleteLen += item.length;</span><span class="s3">\n              </span><span class="s1">} else if (!item.deleted) {</span><span class="s3">\n                </span><span class="s1">if (action !== 'retain') {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">action = 'retain';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">retain += item.length;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">case ContentFormat: {</span><span class="s3">\n              </span><span class="s1">const { key, value } = /** @type {ContentFormat} */ (item.content);</span><span class="s3">\n              </span><span class="s1">if (this.adds(item)) {</span><span class="s3">\n                </span><span class="s1">if (!this.deletes(item)) {</span><span class="s3">\n                  </span><span class="s1">const curVal = currentAttributes.get(key) || null;</span><span class="s3">\n                  </span><span class="s1">if (!equalAttrs(curVal, value)) {</span><span class="s3">\n                    </span><span class="s1">if (action === 'retain') {</span><span class="s3">\n                      </span><span class="s1">addOp();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (equalAttrs(value, (oldAttributes.get(key) || null))) {</span><span class="s3">\n                      </span><span class="s1">delete attributes[key];</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">attributes[key] = value;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">} else if (value !== null) {</span><span class="s3">\n                    </span><span class="s1">item.delete(transaction);</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (this.deletes(item)) {</span><span class="s3">\n                </span><span class="s1">oldAttributes.set(key, value);</span><span class="s3">\n                </span><span class="s1">const curVal = currentAttributes.get(key) || null;</span><span class="s3">\n                </span><span class="s1">if (!equalAttrs(curVal, value)) {</span><span class="s3">\n                  </span><span class="s1">if (action === 'retain') {</span><span class="s3">\n                    </span><span class="s1">addOp();</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">attributes[key] = curVal;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (!item.deleted) {</span><span class="s3">\n                </span><span class="s1">oldAttributes.set(key, value);</span><span class="s3">\n                </span><span class="s1">const attr = attributes[key];</span><span class="s3">\n                </span><span class="s1">if (attr !== undefined) {</span><span class="s3">\n                  </span><span class="s1">if (!equalAttrs(attr, value)) {</span><span class="s3">\n                    </span><span class="s1">if (action === 'retain') {</span><span class="s3">\n                      </span><span class="s1">addOp();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (value === null) {</span><span class="s3">\n                      </span><span class="s1">delete attributes[key];</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">attributes[key] = value;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">} else if (attr !== null) { // this will be cleaned up automatically by the contextless cleanup function</span><span class="s3">\n                    </span><span class="s1">item.delete(transaction);</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n                </span><span class="s1">if (action === 'insert') {</span><span class="s3">\n                  </span><span class="s1">addOp();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content));</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">item = item.right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">addOp();</span><span class="s3">\n        </span><span class="s1">while (delta.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">const lastOp = delta[delta.length - 1];</span><span class="s3">\n          </span><span class="s1">if (lastOp.retain !== undefined &amp;&amp; lastOp.attributes === undefined) {</span><span class="s3">\n            </span><span class="s1">// retain delta's if they don't assign attributes</span><span class="s3">\n            </span><span class="s1">delta.pop();</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">this._delta = delta;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (this._delta)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Type that represents text with formatting information.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This type replaces y-richtext as this implementation is able to handle</span><span class="s3">\n </span><span class="s1">* block formats (format information on a paragraph), embeds (complex elements</span><span class="s3">\n </span><span class="s1">* like pictures and videos), and text formats (**bold**, *italic*).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends AbstractType&lt;YTextEvent&gt;</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YText extends AbstractType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {String} [string] The initial value of the YText.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (string) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Array of pending operations on this type</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;function():void&gt;?}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._pending = string !== undefined ? [() =&gt; this.insert(0, string)] : [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;ArraySearchMarker&gt;|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._searchMarker = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether this YText contains formatting attributes.</span><span class="s3">\n     </span><span class="s1">* This flag is updated when a formatting item is integrated (see ContentFormat.integrate)</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._hasFormatting = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Number of characters of this text type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @type {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get length () {</span><span class="s3">\n    </span><span class="s1">return this._length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">super._integrate(y, item);</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).forEach(f =&gt; f());</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n      </span><span class="s1">console.error(e);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._pending = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YText()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YText}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">const text = new YText();</span><span class="s3">\n    </span><span class="s1">text.applyDelta(this.toDelta());</span><span class="s3">\n    </span><span class="s1">return text</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates YTextEvent and calls observers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;null|string&gt;} parentSubs Keys changed on this type. `null` if list was modified.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_callObserver (transaction, parentSubs) {</span><span class="s3">\n    </span><span class="s1">super._callObserver(transaction, parentSubs);</span><span class="s3">\n    </span><span class="s1">const event = new YTextEvent(this, transaction, parentSubs);</span><span class="s3">\n    </span><span class="s1">callTypeObservers(this, transaction, event);</span><span class="s3">\n    </span><span class="s1">// If a remote change happened, we try to cleanup potential formatting duplicates.</span><span class="s3">\n    </span><span class="s1">if (!transaction.local &amp;&amp; this._hasFormatting) {</span><span class="s3">\n      </span><span class="s1">transaction._needFormattingCleanup = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the unformatted string representation of this YText type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">let str = '';</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Item|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">let n = this._start;</span><span class="s3">\n    </span><span class="s1">while (n !== null) {</span><span class="s3">\n      </span><span class="s1">if (!n.deleted &amp;&amp; n.countable &amp;&amp; n.content.constructor === ContentString) {</span><span class="s3">\n        </span><span class="s1">str += /** @type {ContentString} */ (n.content).str;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">n = n.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return str</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the unformatted string representation of this YText type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">return this.toString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Apply a {@link Delta} on this shared YText type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {any} delta The changes to apply on this element.</span><span class="s3">\n   </span><span class="s1">* @param {object}  opts</span><span class="s3">\n   </span><span class="s1">* @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">applyDelta (delta, { sanitize = true } = {}) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const currPos = new ItemTextListPosition(null, this._start, 0, new Map());</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; delta.length; i++) {</span><span class="s3">\n          </span><span class="s1">const op = delta[i];</span><span class="s3">\n          </span><span class="s1">if (op.insert !== undefined) {</span><span class="s3">\n            </span><span class="s1">// Quill assumes that the content starts with an empty paragraph.</span><span class="s3">\n            </span><span class="s1">// Yjs/Y.Text assumes that it starts empty. We always hide that</span><span class="s3">\n            </span><span class="s1">// there is a newline at the end of the content.</span><span class="s3">\n            </span><span class="s1">// If we omit this step, clients will see a different number of</span><span class="s3">\n            </span><span class="s1">// paragraphs, but nothing bad will happen.</span><span class="s3">\n            </span><span class="s1">const ins = (!sanitize &amp;&amp; typeof op.insert === 'string' &amp;&amp; i === delta.length - 1 &amp;&amp; currPos.right === null &amp;&amp; op.insert.slice(-1) === '</span><span class="s3">\\</span><span class="s1">n') ? op.insert.slice(0, -1) : op.insert;</span><span class="s3">\n            </span><span class="s1">if (typeof ins !== 'string' || ins.length &gt; 0) {</span><span class="s3">\n              </span><span class="s1">insertText(transaction, this, currPos, ins, op.attributes || {});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else if (op.retain !== undefined) {</span><span class="s3">\n            </span><span class="s1">formatText(transaction, this, currPos, op.retain, op.attributes || {});</span><span class="s3">\n          </span><span class="s1">} else if (op.delete !== undefined) {</span><span class="s3">\n            </span><span class="s1">deleteText(transaction, currPos, op.delete);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.applyDelta(delta));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the Delta representation of this YText type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Snapshot} [snapshot]</span><span class="s3">\n   </span><span class="s1">* @param {Snapshot} [prevSnapshot]</span><span class="s3">\n   </span><span class="s1">* @param {function('removed' | 'added', ID):any} [computeYChange]</span><span class="s3">\n   </span><span class="s1">* @return {any} The Delta representation of this type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toDelta (snapshot, prevSnapshot, computeYChange) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type{Array&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const ops = [];</span><span class="s3">\n    </span><span class="s1">const currentAttributes = new Map();</span><span class="s3">\n    </span><span class="s1">const doc = /** @type {Doc} */ (this.doc);</span><span class="s3">\n    </span><span class="s1">let str = '';</span><span class="s3">\n    </span><span class="s1">let n = this._start;</span><span class="s3">\n    </span><span class="s1">function packStr () {</span><span class="s3">\n      </span><span class="s1">if (str.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// pack str with attributes to ops</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const attributes = {};</span><span class="s3">\n        </span><span class="s1">let addAttributes = false;</span><span class="s3">\n        </span><span class="s1">currentAttributes.forEach((value, key) =&gt; {</span><span class="s3">\n          </span><span class="s1">addAttributes = true;</span><span class="s3">\n          </span><span class="s1">attributes[key] = value;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const op = { insert: str };</span><span class="s3">\n        </span><span class="s1">if (addAttributes) {</span><span class="s3">\n          </span><span class="s1">op.attributes = attributes;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">ops.push(op);</span><span class="s3">\n        </span><span class="s1">str = '';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const computeDelta = () =&gt; {</span><span class="s3">\n      </span><span class="s1">while (n !== null) {</span><span class="s3">\n        </span><span class="s1">if (isVisible(n, snapshot) || (prevSnapshot !== undefined &amp;&amp; isVisible(n, prevSnapshot))) {</span><span class="s3">\n          </span><span class="s1">switch (n.content.constructor) {</span><span class="s3">\n            </span><span class="s1">case ContentString: {</span><span class="s3">\n              </span><span class="s1">const cur = currentAttributes.get('ychange');</span><span class="s3">\n              </span><span class="s1">if (snapshot !== undefined &amp;&amp; !isVisible(n, snapshot)) {</span><span class="s3">\n                </span><span class="s1">if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {</span><span class="s3">\n                  </span><span class="s1">packStr();</span><span class="s3">\n                  </span><span class="s1">currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (prevSnapshot !== undefined &amp;&amp; !isVisible(n, prevSnapshot)) {</span><span class="s3">\n                </span><span class="s1">if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {</span><span class="s3">\n                  </span><span class="s1">packStr();</span><span class="s3">\n                  </span><span class="s1">currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">} else if (cur !== undefined) {</span><span class="s3">\n                </span><span class="s1">packStr();</span><span class="s3">\n                </span><span class="s1">currentAttributes.delete('ychange');</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">str += /** @type {ContentString} */ (n.content).str;</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ContentType:</span><span class="s3">\n            </span><span class="s1">case ContentEmbed: {</span><span class="s3">\n              </span><span class="s1">packStr();</span><span class="s3">\n              </span><span class="s1">/**</span><span class="s3">\n               </span><span class="s1">* @type {Object&lt;string,any&gt;}</span><span class="s3">\n               </span><span class="s1">*/</span><span class="s3">\n              </span><span class="s1">const op = {</span><span class="s3">\n                </span><span class="s1">insert: n.content.getContent()[0]</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n              </span><span class="s1">if (currentAttributes.size &gt; 0) {</span><span class="s3">\n                </span><span class="s1">const attrs = /** @type {Object&lt;string,any&gt;} */ ({});</span><span class="s3">\n                </span><span class="s1">op.attributes = attrs;</span><span class="s3">\n                </span><span class="s1">currentAttributes.forEach((value, key) =&gt; {</span><span class="s3">\n                  </span><span class="s1">attrs[key] = value;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">ops.push(op);</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case ContentFormat:</span><span class="s3">\n              </span><span class="s1">if (isVisible(n, snapshot)) {</span><span class="s3">\n                </span><span class="s1">packStr();</span><span class="s3">\n                </span><span class="s1">updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content));</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">n = n.right;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">packStr();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (snapshot || prevSnapshot) {</span><span class="s3">\n      </span><span class="s1">// snapshots are merged again after the transaction, so we need to keep the</span><span class="s3">\n      </span><span class="s1">// transaction alive until we are done</span><span class="s3">\n      </span><span class="s1">transact(doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">if (snapshot) {</span><span class="s3">\n          </span><span class="s1">splitSnapshotAffectedStructs(transaction, snapshot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (prevSnapshot) {</span><span class="s3">\n          </span><span class="s1">splitSnapshotAffectedStructs(transaction, prevSnapshot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">computeDelta();</span><span class="s3">\n      </span><span class="s1">}, 'cleanup');</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">computeDelta();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ops</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Insert text at a given index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index at which to start inserting.</span><span class="s3">\n   </span><span class="s1">* @param {String} text The text to insert at the specified position.</span><span class="s3">\n   </span><span class="s1">* @param {TextAttributes} [attributes] Optionally define some formatting</span><span class="s3">\n   </span><span class="s1">*                                    information to apply on the inserted</span><span class="s3">\n   </span><span class="s1">*                                    Text.</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">insert (index, text, attributes) {</span><span class="s3">\n    </span><span class="s1">if (text.length &lt;= 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const y = this.doc;</span><span class="s3">\n    </span><span class="s1">if (y !== null) {</span><span class="s3">\n      </span><span class="s1">transact(y, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const pos = findPosition(transaction, this, index);</span><span class="s3">\n        </span><span class="s1">if (!attributes) {</span><span class="s3">\n          </span><span class="s1">attributes = {};</span><span class="s3">\n          </span><span class="s1">// @ts-ignore</span><span class="s3">\n          </span><span class="s1">pos.currentAttributes.forEach((v, k) =&gt; { attributes[k] = v; });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">insertText(transaction, this, pos, text, attributes);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.insert(index, text, attributes));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Inserts an embed at a index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index to insert the embed at.</span><span class="s3">\n   </span><span class="s1">* @param {Object | AbstractType&lt;any&gt;} embed The Object that represents the embed.</span><span class="s3">\n   </span><span class="s1">* @param {TextAttributes} attributes Attribute information to apply on the</span><span class="s3">\n   </span><span class="s1">*                                    embed</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">insertEmbed (index, embed, attributes = {}) {</span><span class="s3">\n    </span><span class="s1">const y = this.doc;</span><span class="s3">\n    </span><span class="s1">if (y !== null) {</span><span class="s3">\n      </span><span class="s1">transact(y, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const pos = findPosition(transaction, this, index);</span><span class="s3">\n        </span><span class="s1">insertText(transaction, this, pos, embed, attributes);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.insertEmbed(index, embed, attributes));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Deletes text starting from an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index Index at which to start deleting.</span><span class="s3">\n   </span><span class="s1">* @param {number} length The number of characters to remove. Defaults to 1.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (index, length) {</span><span class="s3">\n    </span><span class="s1">if (length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const y = this.doc;</span><span class="s3">\n    </span><span class="s1">if (y !== null) {</span><span class="s3">\n      </span><span class="s1">transact(y, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">deleteText(transaction, findPosition(transaction, this, index), length);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.delete(index, length));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Assigns properties to a range of text.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The position where to start formatting.</span><span class="s3">\n   </span><span class="s1">* @param {number} length The amount of characters to assign properties to.</span><span class="s3">\n   </span><span class="s1">* @param {TextAttributes} attributes Attribute information to apply on the</span><span class="s3">\n   </span><span class="s1">*                                    text.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">format (index, length, attributes) {</span><span class="s3">\n    </span><span class="s1">if (length === 0) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const y = this.doc;</span><span class="s3">\n    </span><span class="s1">if (y !== null) {</span><span class="s3">\n      </span><span class="s1">transact(y, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const pos = findPosition(transaction, this, index);</span><span class="s3">\n        </span><span class="s1">if (pos.right === null) {</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">formatText(transaction, this, pos, length, attributes);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.format(index, length, attributes));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes an attribute.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {String} attributeName The attribute name that is to be removed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeAttribute (attributeName) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapDelete(transaction, this, attributeName);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.removeAttribute(attributeName));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets or updates an attribute.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {String} attributeName The attribute name that is to be set.</span><span class="s3">\n   </span><span class="s1">* @param {any} attributeValue The attribute value that is to be set.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setAttribute (attributeName, attributeValue) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapSet(transaction, this, attributeName, attributeValue);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Array&lt;function&gt;} */ (this._pending).push(() =&gt; this.setAttribute(attributeName, attributeValue));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an attribute value that belongs to the attribute name.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {String} attributeName The attribute name that identifies the</span><span class="s3">\n   </span><span class="s1">*                               queried value.</span><span class="s3">\n   </span><span class="s1">* @return {any} The queried attribute value.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAttribute (attributeName) {</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (typeMapGet(this, attributeName))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns all attribute name/value pairs in a JSON Object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Object&lt;string, any&gt;} A JSON Object that describes the attributes.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAttributes () {</span><span class="s3">\n    </span><span class="s1">return typeMapGetAll(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YTextRefID);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder</span><span class="s3">\n </span><span class="s1">* @return {YText}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYText = _decoder =&gt; new YText();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @module YXml</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Define the elements to which a set of CSS queries apply.</span><span class="s3">\n </span><span class="s1">* {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*   query = '.classSelector'</span><span class="s3">\n </span><span class="s1">*   query = 'nodeSelector'</span><span class="s3">\n </span><span class="s1">*   query = '#idSelector'</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @typedef {string} CSS_Selector</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Dom filter function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @callback domFilter</span><span class="s3">\n </span><span class="s1">* @param {string} nodeName The nodeName of the element</span><span class="s3">\n </span><span class="s1">* @param {Map} attributes The map of attributes.</span><span class="s3">\n </span><span class="s1">* @return {boolean} Whether to include the Dom node in the YXmlElement.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a subset of the nodes of a YXmlElement / YXmlFragment and a</span><span class="s3">\n </span><span class="s1">* position within them.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Can be created with {@link YXmlFragment#createTreeWalker}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">* @implements {Iterable&lt;YXmlElement|YXmlText|YXmlElement|YXmlHook&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlTreeWalker {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {YXmlFragment | YXmlElement} root</span><span class="s3">\n   </span><span class="s1">* @param {function(AbstractType&lt;any&gt;):boolean} [f]</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (root, f = () =&gt; true) {</span><span class="s3">\n    </span><span class="s1">this._filter = f;</span><span class="s3">\n    </span><span class="s1">this._root = root;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Item}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._currentNode = /** @type {Item} */ (root._start);</span><span class="s3">\n    </span><span class="s1">this._firstCall = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">[Symbol.iterator] () {</span><span class="s3">\n    </span><span class="s1">return this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the next node.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {IteratorResult&lt;YXmlElement|YXmlText|YXmlHook&gt;} The next node.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">next () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Item|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">let n = this._currentNode;</span><span class="s3">\n    </span><span class="s1">let type = n &amp;&amp; n.content &amp;&amp; /** @type {any} */ (n.content).type;</span><span class="s3">\n    </span><span class="s1">if (n !== null &amp;&amp; (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item</span><span class="s3">\n      </span><span class="s1">do {</span><span class="s3">\n        </span><span class="s1">type = /** @type {any} */ (n.content).type;</span><span class="s3">\n        </span><span class="s1">if (!n.deleted &amp;&amp; (type.constructor === YXmlElement || type.constructor === YXmlFragment) &amp;&amp; type._start !== null) {</span><span class="s3">\n          </span><span class="s1">// walk down in the tree</span><span class="s3">\n          </span><span class="s1">n = type._start;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// walk right or up in the tree</span><span class="s3">\n          </span><span class="s1">while (n !== null) {</span><span class="s3">\n            </span><span class="s1">if (n.right !== null) {</span><span class="s3">\n              </span><span class="s1">n = n.right;</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">} else if (n.parent === this._root) {</span><span class="s3">\n              </span><span class="s1">n = null;</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">n = /** @type {AbstractType&lt;any&gt;} */ (n.parent)._item;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} while (n !== null &amp;&amp; (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._firstCall = false;</span><span class="s3">\n    </span><span class="s1">if (n === null) {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore</span><span class="s3">\n      </span><span class="s1">return { value: undefined, done: true }</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this._currentNode = n;</span><span class="s3">\n    </span><span class="s1">return { value: /** @type {any} */ (n.content).type, done: false }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents a list of {@link YXmlElement}.and {@link YXmlText} types.</span><span class="s3">\n </span><span class="s1">* A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a</span><span class="s3">\n </span><span class="s1">* nodeName and it does not have attributes. Though it can be bound to a DOM</span><span class="s3">\n </span><span class="s1">* element - in this case the attributes and the nodeName are not shared.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @public</span><span class="s3">\n </span><span class="s1">* @extends AbstractType&lt;YXmlEvent&gt;</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlFragment extends AbstractType {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;any&gt;|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._prelimContent = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {YXmlElement|YXmlText|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get firstChild () {</span><span class="s3">\n    </span><span class="s1">const first = this._first;</span><span class="s3">\n    </span><span class="s1">return first ? first.content.getContent()[0] : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Integrate this type into the Yjs instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * Save this struct in the os</span><span class="s3">\n   </span><span class="s1">* * This type is sent to other client</span><span class="s3">\n   </span><span class="s1">* * Observer functions are fired</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y The Yjs instance</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">super._integrate(y, item);</span><span class="s3">\n    </span><span class="s1">this.insert(0, /** @type {Array&lt;any&gt;} */ (this._prelimContent));</span><span class="s3">\n    </span><span class="s1">this._prelimContent = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YXmlFragment()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YXmlFragment}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">const el = new YXmlFragment();</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">el.insert(0, this.toArray().map(item =&gt; item instanceof AbstractType ? item.clone() : item));</span><span class="s3">\n    </span><span class="s1">return el</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get length () {</span><span class="s3">\n    </span><span class="s1">return this._prelimContent === null ? this._length : this._prelimContent.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Create a subtree of childNodes.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">* const walker = elem.createTreeWalker(dom =&gt; dom.nodeName === 'div')</span><span class="s3">\n   </span><span class="s1">* for (let node in walker) {</span><span class="s3">\n   </span><span class="s1">*   // `node` is a div node</span><span class="s3">\n   </span><span class="s1">*   nop(node)</span><span class="s3">\n   </span><span class="s1">* }</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(AbstractType&lt;any&gt;):boolean} filter Function that is called on each child element and</span><span class="s3">\n   </span><span class="s1">*                          returns a Boolean indicating whether the child</span><span class="s3">\n   </span><span class="s1">*                          is to be included in the subtree.</span><span class="s3">\n   </span><span class="s1">* @return {YXmlTreeWalker} A subtree and a position within it.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">createTreeWalker (filter) {</span><span class="s3">\n    </span><span class="s1">return new YXmlTreeWalker(this, filter)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the first YXmlElement that matches the query.</span><span class="s3">\n   </span><span class="s1">* Similar to DOM's {@link querySelector}.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* Query support:</span><span class="s3">\n   </span><span class="s1">*   - tagname</span><span class="s3">\n   </span><span class="s1">* TODO:</span><span class="s3">\n   </span><span class="s1">*   - id</span><span class="s3">\n   </span><span class="s1">*   - attribute</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {CSS_Selector} query The query on the children.</span><span class="s3">\n   </span><span class="s1">* @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">querySelector (query) {</span><span class="s3">\n    </span><span class="s1">query = query.toUpperCase();</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">const iterator = new YXmlTreeWalker(this, element =&gt; element.nodeName &amp;&amp; element.nodeName.toUpperCase() === query);</span><span class="s3">\n    </span><span class="s1">const next = iterator.next();</span><span class="s3">\n    </span><span class="s1">if (next.done) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return next.value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns all YXmlElements that match the query.</span><span class="s3">\n   </span><span class="s1">* Similar to Dom's {@link querySelectorAll}.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo Does not yet support all queries. Currently only query by tagName.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {CSS_Selector} query The query on the children</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;YXmlElement|YXmlText|YXmlHook|null&gt;} The elements that match this query.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">querySelectorAll (query) {</span><span class="s3">\n    </span><span class="s1">query = query.toUpperCase();</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return array.from(new YXmlTreeWalker(this, element =&gt; element.nodeName &amp;&amp; element.nodeName.toUpperCase() === query))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates YXmlEvent and calls observers.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;null|string&gt;} parentSubs Keys changed on this type. `null` if list was modified.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_callObserver (transaction, parentSubs) {</span><span class="s3">\n    </span><span class="s1">callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Get the string representation of all the children of this YXmlFragment.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {string} The string representation of all children.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">return typeListMap(this, xml =&gt; xml.toString()).join('')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">return this.toString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Dom Element that mirrors this YXmlElement.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Document} [_document=document] The document object (you must define</span><span class="s3">\n   </span><span class="s1">*                                        this when calling this method in</span><span class="s3">\n   </span><span class="s1">*                                        nodejs)</span><span class="s3">\n   </span><span class="s1">* @param {Object&lt;string, any&gt;} [hooks={}] Optional property to customize how hooks</span><span class="s3">\n   </span><span class="s1">*                                             are presented in the DOM</span><span class="s3">\n   </span><span class="s1">* @param {any} [binding] You should not set this property. This is</span><span class="s3">\n   </span><span class="s1">*                               used if DomBinding wants to create a</span><span class="s3">\n   </span><span class="s1">*                               association to the created DOM type.</span><span class="s3">\n   </span><span class="s1">* @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toDOM (_document = document, hooks = {}, binding) {</span><span class="s3">\n    </span><span class="s1">const fragment = _document.createDocumentFragment();</span><span class="s3">\n    </span><span class="s1">if (binding !== undefined) {</span><span class="s3">\n      </span><span class="s1">binding._createAssociation(fragment, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">typeListForEach(this, xmlType =&gt; {</span><span class="s3">\n      </span><span class="s1">fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return fragment</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Inserts new content at an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*  // Insert character 'a' at position 0</span><span class="s3">\n   </span><span class="s1">*  xml.insert(0, [new Y.XmlText('text')])</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index to insert content at</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;YXmlElement|YXmlText&gt;} content The array of content</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">insert (index, content) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeListInsertGenerics(transaction, this, index, content);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore _prelimContent is defined because this is not yet integrated</span><span class="s3">\n      </span><span class="s1">this._prelimContent.splice(index, 0, ...content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Inserts new content at an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @example</span><span class="s3">\n   </span><span class="s1">*  // Insert character 'a' at position 0</span><span class="s3">\n   </span><span class="s1">*  xml.insert(0, [new Y.XmlText('text')])</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;YXmlElement|YXmlText&gt;} content The array of content</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">insertAfter (ref, content) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">const refItem = (ref &amp;&amp; ref instanceof AbstractType) ? ref._item : ref;</span><span class="s3">\n        </span><span class="s1">typeListInsertGenericsAfter(transaction, this, refItem, content);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const pc = /** @type {Array&lt;any&gt;} */ (this._prelimContent);</span><span class="s3">\n      </span><span class="s1">const index = ref === null ? 0 : pc.findIndex(el =&gt; el === ref) + 1;</span><span class="s3">\n      </span><span class="s1">if (index === 0 &amp;&amp; ref !== null) {</span><span class="s3">\n        </span><span class="s1">throw error.create('Reference item not found')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">pc.splice(index, 0, ...content);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Deletes elements starting from an index.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index Index at which to start deleting elements</span><span class="s3">\n   </span><span class="s1">* @param {number} [length=1] The number of elements to remove. Defaults to 1.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (index, length = 1) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeListDelete(transaction, this, index, length);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// @ts-ignore _prelimContent is defined because this is not yet integrated</span><span class="s3">\n      </span><span class="s1">this._prelimContent.splice(index, length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this YArray to a JavaScript Array.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;YXmlElement|YXmlText|YXmlHook&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toArray () {</span><span class="s3">\n    </span><span class="s1">return typeListToArray(this)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Appends content to this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;YXmlElement|YXmlText&gt;} content Array of content to append.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">push (content) {</span><span class="s3">\n    </span><span class="s1">this.insert(this.length, content);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Preppends content to this YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;YXmlElement|YXmlText&gt;} content Array of content to preppend.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">unshift (content) {</span><span class="s3">\n    </span><span class="s1">this.insert(0, content);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the i-th element from a YArray.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} index The index of the element to return from the YArray</span><span class="s3">\n   </span><span class="s1">* @return {YXmlElement|YXmlText}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get (index) {</span><span class="s3">\n    </span><span class="s1">return typeListGet(this, index)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transforms this YArray to a JavaScript Array.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {number} [start]</span><span class="s3">\n   </span><span class="s1">* @param {number} [end]</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;YXmlElement|YXmlText&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">slice (start = 0, end = this.length) {</span><span class="s3">\n    </span><span class="s1">return typeListSlice(this, start, end)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Executes a provided function on once on overy child element.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">forEach (f) {</span><span class="s3">\n    </span><span class="s1">typeListForEach(this, f);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transform the properties of this type to binary and write it to an</span><span class="s3">\n   </span><span class="s1">* BinaryEncoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This is called when this Item is sent to a remote peer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YXmlFragmentRefID);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder</span><span class="s3">\n </span><span class="s1">* @return {YXmlFragment}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYXmlFragment = _decoder =&gt; new YXmlFragment();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {Object|number|null|Array&lt;any&gt;|string|Uint8Array|AbstractType&lt;any&gt;} ValueTypes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An YXmlElement imitates the behavior of a</span><span class="s3">\n </span><span class="s1">* {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* * An YXmlElement has attributes (key value pairs)</span><span class="s3">\n </span><span class="s1">* * An YXmlElement has childElements that must inherit from YXmlElement</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlElement extends YXmlFragment {</span><span class="s3">\n  </span><span class="s1">constructor (nodeName = 'UNDEFINED') {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">this.nodeName = nodeName;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string, any&gt;|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._prelimAttrs = new Map();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {YXmlElement|YXmlText|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get nextSibling () {</span><span class="s3">\n    </span><span class="s1">const n = this._item ? this._item.next : null;</span><span class="s3">\n    </span><span class="s1">return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {YXmlElement|YXmlText|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get prevSibling () {</span><span class="s3">\n    </span><span class="s1">const n = this._item ? this._item.prev : null;</span><span class="s3">\n    </span><span class="s1">return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Integrate this type into the Yjs instance.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* * Save this struct in the os</span><span class="s3">\n   </span><span class="s1">* * This type is sent to other client</span><span class="s3">\n   </span><span class="s1">* * Observer functions are fired</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Doc} y The Yjs instance</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_integrate (y, item) {</span><span class="s3">\n    </span><span class="s1">super._integrate(y, item)</span><span class="s3">\n    </span><span class="s1">;(/** @type {Map&lt;string, any&gt;} */ (this._prelimAttrs)).forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.setAttribute(key, value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">this._prelimAttrs = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates an Item with the same effect as this Item (without position effect)</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {YXmlElement}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YXmlElement(this.nodeName)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YXmlElement&lt;KV&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {YXmlElement&lt;KV&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const el = new YXmlElement(this.nodeName);</span><span class="s3">\n    </span><span class="s1">const attrs = this.getAttributes();</span><span class="s3">\n    </span><span class="s1">object.forEach(attrs, (value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n        </span><span class="s1">el.setAttribute(key, value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">el.insert(0, this.toArray().map(item =&gt; item instanceof AbstractType ? item.clone() : item));</span><span class="s3">\n    </span><span class="s1">return el</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the XML serialization of this YXmlElement.</span><span class="s3">\n   </span><span class="s1">* The attributes are ordered by attribute-name, so you can easily use this</span><span class="s3">\n   </span><span class="s1">* method to compare YXmlElements</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {string} The string representation of this type.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">const attrs = this.getAttributes();</span><span class="s3">\n    </span><span class="s1">const stringBuilder = [];</span><span class="s3">\n    </span><span class="s1">const keys = [];</span><span class="s3">\n    </span><span class="s1">for (const key in attrs) {</span><span class="s3">\n      </span><span class="s1">keys.push(key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">keys.sort();</span><span class="s3">\n    </span><span class="s1">const keysLen = keys.length;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; keysLen; i++) {</span><span class="s3">\n      </span><span class="s1">const key = keys[i];</span><span class="s3">\n      </span><span class="s1">stringBuilder.push(key + '=</span><span class="s3">\&quot;</span><span class="s1">' + attrs[key] + '</span><span class="s3">\&quot;</span><span class="s1">');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const nodeName = this.nodeName.toLocaleLowerCase();</span><span class="s3">\n    </span><span class="s1">const attrsString = stringBuilder.length &gt; 0 ? ' ' + stringBuilder.join(' ') : '';</span><span class="s3">\n    </span><span class="s1">return `&lt;${nodeName}${attrsString}&gt;${super.toString()}&lt;/${nodeName}&gt;`</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Removes an attribute from this YXmlElement.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} attributeName The attribute name that is to be removed.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">removeAttribute (attributeName) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapDelete(transaction, this, attributeName);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Map&lt;string,any&gt;} */ (this._prelimAttrs).delete(attributeName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Sets or updates an attribute.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template {keyof KV &amp; string} KEY</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {KEY} attributeName The attribute name that is to be set.</span><span class="s3">\n   </span><span class="s1">* @param {KV[KEY]} attributeValue The attribute value that is to be set.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setAttribute (attributeName, attributeValue) {</span><span class="s3">\n    </span><span class="s1">if (this.doc !== null) {</span><span class="s3">\n      </span><span class="s1">transact(this.doc, transaction =&gt; {</span><span class="s3">\n        </span><span class="s1">typeMapSet(transaction, this, attributeName, attributeValue);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">/** @type {Map&lt;string, any&gt;} */ (this._prelimAttrs).set(attributeName, attributeValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns an attribute value that belongs to the attribute name.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template {keyof KV &amp; string} KEY</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {KEY} attributeName The attribute name that identifies the</span><span class="s3">\n   </span><span class="s1">*                               queried value.</span><span class="s3">\n   </span><span class="s1">* @return {KV[KEY]|undefined} The queried attribute value.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAttribute (attributeName) {</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (typeMapGet(this, attributeName))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns whether an attribute exists</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {string} attributeName The attribute name to check for existence.</span><span class="s3">\n   </span><span class="s1">* @return {boolean} whether the attribute exists.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">hasAttribute (attributeName) {</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (typeMapHas(this, attributeName))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns all attribute name/value pairs in a JSON Object.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @return {{ [Key in Extract&lt;keyof KV,string&gt;]?: KV[Key]}} A JSON Object that describes the attributes.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getAttributes () {</span><span class="s3">\n    </span><span class="s1">return /** @type {any} */ (typeMapGetAll(this))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Dom Element that mirrors this YXmlElement.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Document} [_document=document] The document object (you must define</span><span class="s3">\n   </span><span class="s1">*                                        this when calling this method in</span><span class="s3">\n   </span><span class="s1">*                                        nodejs)</span><span class="s3">\n   </span><span class="s1">* @param {Object&lt;string, any&gt;} [hooks={}] Optional property to customize how hooks</span><span class="s3">\n   </span><span class="s1">*                                             are presented in the DOM</span><span class="s3">\n   </span><span class="s1">* @param {any} [binding] You should not set this property. This is</span><span class="s3">\n   </span><span class="s1">*                               used if DomBinding wants to create a</span><span class="s3">\n   </span><span class="s1">*                               association to the created DOM type.</span><span class="s3">\n   </span><span class="s1">* @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toDOM (_document = document, hooks = {}, binding) {</span><span class="s3">\n    </span><span class="s1">const dom = _document.createElement(this.nodeName);</span><span class="s3">\n    </span><span class="s1">const attrs = this.getAttributes();</span><span class="s3">\n    </span><span class="s1">for (const key in attrs) {</span><span class="s3">\n      </span><span class="s1">const value = attrs[key];</span><span class="s3">\n      </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n        </span><span class="s1">dom.setAttribute(key, value);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">typeListForEach(this, yxml =&gt; {</span><span class="s3">\n      </span><span class="s1">dom.appendChild(yxml.toDOM(_document, hooks, binding));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (binding !== undefined) {</span><span class="s3">\n      </span><span class="s1">binding._createAssociation(dom, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dom</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transform the properties of this type to binary and write it to an</span><span class="s3">\n   </span><span class="s1">* BinaryEncoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This is called when this Item is sent to a remote peer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YXmlElementRefID);</span><span class="s3">\n    </span><span class="s1">encoder.writeKey(this.nodeName);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {YXmlElement}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYXmlElement = decoder =&gt; new YXmlElement(decoder.readKey());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @extends YEvent&lt;YXmlElement|YXmlText|YXmlFragment&gt;</span><span class="s3">\n </span><span class="s1">* An Event that describes changes on a YXml Element or Yxml Fragment</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlEvent extends YEvent {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.</span><span class="s3">\n   </span><span class="s1">* @param {Set&lt;string|null&gt;} subs The set of changed attributes. `null` is included if the</span><span class="s3">\n   </span><span class="s1">*                   child list changed.</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction The transaction instance with wich the</span><span class="s3">\n   </span><span class="s1">*                                  change was created.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (target, subs, transaction) {</span><span class="s3">\n    </span><span class="s1">super(target, transaction);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the children changed.</span><span class="s3">\n     </span><span class="s1">* @type {Boolean}</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.childListChanged = false;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set of all changed attributes.</span><span class="s3">\n     </span><span class="s1">* @type {Set&lt;string&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.attributesChanged = new Set();</span><span class="s3">\n    </span><span class="s1">subs.forEach((sub) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (sub === null) {</span><span class="s3">\n        </span><span class="s1">this.childListChanged = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.attributesChanged.add(sub);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* You can manage binding to a custom type with YXmlHook.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends {YMap&lt;any&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlHook extends YMap {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} hookName nodeName of the Dom Node.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (hookName) {</span><span class="s3">\n    </span><span class="s1">super();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {string}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.hookName = hookName;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates an Item with the same effect as this Item (without position effect)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YXmlHook(this.hookName)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YXmlHook}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">const el = new YXmlHook(this.hookName);</span><span class="s3">\n    </span><span class="s1">this.forEach((value, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">el.set(key, value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return el</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Dom Element that mirrors this YXmlElement.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Document} [_document=document] The document object (you must define</span><span class="s3">\n   </span><span class="s1">*                                        this when calling this method in</span><span class="s3">\n   </span><span class="s1">*                                        nodejs)</span><span class="s3">\n   </span><span class="s1">* @param {Object.&lt;string, any&gt;} [hooks] Optional property to customize how hooks</span><span class="s3">\n   </span><span class="s1">*                                             are presented in the DOM</span><span class="s3">\n   </span><span class="s1">* @param {any} [binding] You should not set this property. This is</span><span class="s3">\n   </span><span class="s1">*                               used if DomBinding wants to create a</span><span class="s3">\n   </span><span class="s1">*                               association to the created DOM type</span><span class="s3">\n   </span><span class="s1">* @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toDOM (_document = document, hooks = {}, binding) {</span><span class="s3">\n    </span><span class="s1">const hook = hooks[this.hookName];</span><span class="s3">\n    </span><span class="s1">let dom;</span><span class="s3">\n    </span><span class="s1">if (hook !== undefined) {</span><span class="s3">\n      </span><span class="s1">dom = hook.createDom(this);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">dom = document.createElement(this.hookName);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dom.setAttribute('data-yjs-hook', this.hookName);</span><span class="s3">\n    </span><span class="s1">if (binding !== undefined) {</span><span class="s3">\n      </span><span class="s1">binding._createAssociation(dom, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dom</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transform the properties of this type to binary and write it to an</span><span class="s3">\n   </span><span class="s1">* BinaryEncoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This is called when this Item is sent to a remote peer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YXmlHookRefID);</span><span class="s3">\n    </span><span class="s1">encoder.writeKey(this.hookName);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {YXmlHook}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYXmlHook = decoder =&gt;</span><span class="s3">\n  </span><span class="s1">new YXmlHook(decoder.readKey());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Represents text in a Dom Element. In the future this type will also handle</span><span class="s3">\n </span><span class="s1">* simple formatting information like bold and italic.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class YXmlText extends YText {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {YXmlElement|YXmlText|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get nextSibling () {</span><span class="s3">\n    </span><span class="s1">const n = this._item ? this._item.next : null;</span><span class="s3">\n    </span><span class="s1">return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {YXmlElement|YXmlText|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get prevSibling () {</span><span class="s3">\n    </span><span class="s1">const n = this._item ? this._item.prev : null;</span><span class="s3">\n    </span><span class="s1">return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_copy () {</span><span class="s3">\n    </span><span class="s1">return new YXmlText()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {YXmlText}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">clone () {</span><span class="s3">\n    </span><span class="s1">const text = new YXmlText();</span><span class="s3">\n    </span><span class="s1">text.applyDelta(this.toDelta());</span><span class="s3">\n    </span><span class="s1">return text</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Creates a Dom Element that mirrors this YXmlText.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Document} [_document=document] The document object (you must define</span><span class="s3">\n   </span><span class="s1">*                                        this when calling this method in</span><span class="s3">\n   </span><span class="s1">*                                        nodejs)</span><span class="s3">\n   </span><span class="s1">* @param {Object&lt;string, any&gt;} [hooks] Optional property to customize how hooks</span><span class="s3">\n   </span><span class="s1">*                                             are presented in the DOM</span><span class="s3">\n   </span><span class="s1">* @param {any} [binding] You should not set this property. This is</span><span class="s3">\n   </span><span class="s1">*                               used if DomBinding wants to create a</span><span class="s3">\n   </span><span class="s1">*                               association to the created DOM type.</span><span class="s3">\n   </span><span class="s1">* @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @public</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toDOM (_document = document, hooks, binding) {</span><span class="s3">\n    </span><span class="s1">const dom = _document.createTextNode(this.toString());</span><span class="s3">\n    </span><span class="s1">if (binding !== undefined) {</span><span class="s3">\n      </span><span class="s1">binding._createAssociation(dom, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dom</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">toString () {</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">return this.toDelta().map(delta =&gt; {</span><span class="s3">\n      </span><span class="s1">const nestedNodes = [];</span><span class="s3">\n      </span><span class="s1">for (const nodeName in delta.attributes) {</span><span class="s3">\n        </span><span class="s1">const attrs = [];</span><span class="s3">\n        </span><span class="s1">for (const key in delta.attributes[nodeName]) {</span><span class="s3">\n          </span><span class="s1">attrs.push({ key, value: delta.attributes[nodeName][key] });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// sort attributes to get a unique order</span><span class="s3">\n        </span><span class="s1">attrs.sort((a, b) =&gt; a.key &lt; b.key ? -1 : 1);</span><span class="s3">\n        </span><span class="s1">nestedNodes.push({ nodeName, attrs });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// sort node order to get a unique order</span><span class="s3">\n      </span><span class="s1">nestedNodes.sort((a, b) =&gt; a.nodeName &lt; b.nodeName ? -1 : 1);</span><span class="s3">\n      </span><span class="s1">// now convert to dom string</span><span class="s3">\n      </span><span class="s1">let str = '';</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; nestedNodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">const node = nestedNodes[i];</span><span class="s3">\n        </span><span class="s1">str += `&lt;${node.nodeName}`;</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; node.attrs.length; j++) {</span><span class="s3">\n          </span><span class="s1">const attr = node.attrs[j];</span><span class="s3">\n          </span><span class="s1">str += ` ${attr.key}=</span><span class="s3">\&quot;</span><span class="s1">${attr.value}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">str += '&gt;';</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">str += delta.insert;</span><span class="s3">\n      </span><span class="s1">for (let i = nestedNodes.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">str += `&lt;/${nestedNodes[i].nodeName}&gt;`;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return str</span><span class="s3">\n    </span><span class="s1">}).join('')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {string}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">toJSON () {</span><span class="s3">\n    </span><span class="s1">return this.toString()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">_write (encoder) {</span><span class="s3">\n    </span><span class="s1">encoder.writeTypeRef(YXmlTextRefID);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {YXmlText}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readYXmlText = decoder =&gt; new YXmlText();</span><span class="s3">\n\n</span><span class="s1">class AbstractStruct {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">* @param {number} length</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (id, length) {</span><span class="s3">\n    </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">this.length = length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get deleted () {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Merge this struct with the item to the right.</span><span class="s3">\n   </span><span class="s1">* This method is already assuming that `this.id.clock + this.length === this.id.clock`.</span><span class="s3">\n   </span><span class="s1">* Also this method does *not* remove right from StructStore!</span><span class="s3">\n   </span><span class="s1">* @param {AbstractStruct} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean} wether this merged with right</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @param {number} encodingRef</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset, encodingRef) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const structGCRefNumber = 0;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class GC extends AbstractStruct {</span><span class="s3">\n  </span><span class="s1">get deleted () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">delete () {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {GC} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">if (this.constructor !== right.constructor) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.length += right.length;</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, offset) {</span><span class="s3">\n    </span><span class="s1">if (offset &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.id.clock += offset;</span><span class="s3">\n      </span><span class="s1">this.length -= offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addStruct(transaction.doc.store, this);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeInfo(structGCRefNumber);</span><span class="s3">\n    </span><span class="s1">encoder.writeLen(this.length - offset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">* @return {null | number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getMissing (transaction, store) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class ContentBinary {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Uint8Array} content</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (content) {</span><span class="s3">\n    </span><span class="s1">this.content = content;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return [this.content]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentBinary}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentBinary(this.content)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentBinary}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentBinary} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeBuf(this.content);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 3</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentBinary}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentBinary = decoder =&gt; new ContentBinary(decoder.readBuf());</span><span class="s3">\n\n</span><span class="s1">class ContentDeleted {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} len</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (len) {</span><span class="s3">\n    </span><span class="s1">this.len = len;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return this.len</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentDeleted}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentDeleted(this.len)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentDeleted}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">const right = new ContentDeleted(this.len - offset);</span><span class="s3">\n    </span><span class="s1">this.len = offset;</span><span class="s3">\n    </span><span class="s1">return right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentDeleted} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">this.len += right.len;</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {</span><span class="s3">\n    </span><span class="s1">addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);</span><span class="s3">\n    </span><span class="s1">item.markDeleted();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeLen(this.len - offset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentDeleted}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentDeleted = decoder =&gt; new ContentDeleted(decoder.readLen());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string} guid</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string, any&gt;} opts</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const createDocFromOpts = (guid, opts) =&gt; new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentDoc {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Doc} doc</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (doc) {</span><span class="s3">\n    </span><span class="s1">if (doc._item) {</span><span class="s3">\n      </span><span class="s1">console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Doc}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.doc = doc;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {any}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const opts = {};</span><span class="s3">\n    </span><span class="s1">this.opts = opts;</span><span class="s3">\n    </span><span class="s1">if (!doc.gc) {</span><span class="s3">\n      </span><span class="s1">opts.gc = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (doc.autoLoad) {</span><span class="s3">\n      </span><span class="s1">opts.autoLoad = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (doc.meta !== null) {</span><span class="s3">\n      </span><span class="s1">opts.meta = doc.meta;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return [this.doc]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentDoc}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentDoc}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentDoc} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {</span><span class="s3">\n    </span><span class="s1">// this needs to be reflected in doc.destroy as well</span><span class="s3">\n    </span><span class="s1">this.doc._item = item;</span><span class="s3">\n    </span><span class="s1">transaction.subdocsAdded.add(this.doc);</span><span class="s3">\n    </span><span class="s1">if (this.doc.shouldLoad) {</span><span class="s3">\n      </span><span class="s1">transaction.subdocsLoaded.add(this.doc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {</span><span class="s3">\n    </span><span class="s1">if (transaction.subdocsAdded.has(this.doc)) {</span><span class="s3">\n      </span><span class="s1">transaction.subdocsAdded.delete(this.doc);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">transaction.subdocsRemoved.add(this.doc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) { }</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeString(this.doc.guid);</span><span class="s3">\n    </span><span class="s1">encoder.writeAny(this.opts);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 9</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentDoc}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentDoc = decoder =&gt; new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentEmbed {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Object} embed</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (embed) {</span><span class="s3">\n    </span><span class="s1">this.embed = embed;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return [this.embed]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentEmbed}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentEmbed(this.embed)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentEmbed}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentEmbed} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeJSON(this.embed);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 5</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentEmbed}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentEmbed = decoder =&gt; new ContentEmbed(decoder.readJSON());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentFormat {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} key</span><span class="s3">\n   </span><span class="s1">* @param {Object} value</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (key, value) {</span><span class="s3">\n    </span><span class="s1">this.key = key;</span><span class="s3">\n    </span><span class="s1">this.value = value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentFormat}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentFormat(this.key, this.value)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} _offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentFormat}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (_offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentFormat} _right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (_right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} _transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (_transaction, item) {</span><span class="s3">\n    </span><span class="s1">// @todo searchmarker are currently unsupported for rich text documents</span><span class="s3">\n    </span><span class="s1">const p = /** @type {YText} */ (item.parent);</span><span class="s3">\n    </span><span class="s1">p._searchMarker = null;</span><span class="s3">\n    </span><span class="s1">p._hasFormatting = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeKey(this.key);</span><span class="s3">\n    </span><span class="s1">encoder.writeJSON(this.value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 6</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentFormat}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentFormat = decoder =&gt; new ContentFormat(decoder.readKey(), decoder.readJSON());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentJSON {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;any&gt;} arr</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (arr) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.arr = arr;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return this.arr.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return this.arr</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentJSON}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentJSON(this.arr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentJSON}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">const right = new ContentJSON(this.arr.slice(offset));</span><span class="s3">\n    </span><span class="s1">this.arr = this.arr.slice(0, offset);</span><span class="s3">\n    </span><span class="s1">return right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentJSON} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">this.arr = this.arr.concat(right.arr);</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">const len = this.arr.length;</span><span class="s3">\n    </span><span class="s1">encoder.writeLen(len - offset);</span><span class="s3">\n    </span><span class="s1">for (let i = offset; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const c = this.arr[i];</span><span class="s3">\n      </span><span class="s1">encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 2</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentJSON}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentJSON = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const len = decoder.readLen();</span><span class="s3">\n  </span><span class="s1">const cs = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">const c = decoder.readString();</span><span class="s3">\n    </span><span class="s1">if (c === 'undefined') {</span><span class="s3">\n      </span><span class="s1">cs.push(undefined);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">cs.push(JSON.parse(c));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new ContentJSON(cs)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">class ContentAny {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;any&gt;} arr</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (arr) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Array&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.arr = arr;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return this.arr.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return this.arr</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentAny}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentAny(this.arr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentAny}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">const right = new ContentAny(this.arr.slice(offset));</span><span class="s3">\n    </span><span class="s1">this.arr = this.arr.slice(0, offset);</span><span class="s3">\n    </span><span class="s1">return right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentAny} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">this.arr = this.arr.concat(right.arr);</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">const len = this.arr.length;</span><span class="s3">\n    </span><span class="s1">encoder.writeLen(len - offset);</span><span class="s3">\n    </span><span class="s1">for (let i = offset; i &lt; len; i++) {</span><span class="s3">\n      </span><span class="s1">const c = this.arr[i];</span><span class="s3">\n      </span><span class="s1">encoder.writeAny(c);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 8</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentAny}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentAny = decoder =&gt; {</span><span class="s3">\n  </span><span class="s1">const len = decoder.readLen();</span><span class="s3">\n  </span><span class="s1">const cs = [];</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">cs.push(decoder.readAny());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return new ContentAny(cs)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentString {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} str</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (str) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {string}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.str = str;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return this.str.length</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return this.str.split('')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentString}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentString(this.str)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentString}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">const right = new ContentString(this.str.slice(offset));</span><span class="s3">\n    </span><span class="s1">this.str = this.str.slice(0, offset);</span><span class="s3">\n\n    </span><span class="s1">// Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248</span><span class="s3">\n    </span><span class="s1">const firstCharCode = this.str.charCodeAt(offset - 1);</span><span class="s3">\n    </span><span class="s1">if (firstCharCode &gt;= 0xD800 &amp;&amp; firstCharCode &lt;= 0xDBFF) {</span><span class="s3">\n      </span><span class="s1">// Last character of the left split is the start of a surrogate utf16/ucs2 pair.</span><span class="s3">\n      </span><span class="s1">// We don't support splitting of surrogate pairs because this may lead to invalid documents.</span><span class="s3">\n      </span><span class="s1">// Replace the invalid character with a unicode replacement character ( / U+FFFD)</span><span class="s3">\n      </span><span class="s1">this.str = this.str.slice(0, offset - 1) + '';</span><span class="s3">\n      </span><span class="s1">// replace right as well</span><span class="s3">\n      </span><span class="s1">right.str = '' + right.str.slice(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return right</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentString} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">this.str += right.str;</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {}</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 4</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentString}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentString = decoder =&gt; new ContentString(decoder.readString());</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @type {Array&lt;function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType&lt;any&gt;&gt;}</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const typeRefs = [</span><span class="s3">\n  </span><span class="s1">readYArray,</span><span class="s3">\n  </span><span class="s1">readYMap,</span><span class="s3">\n  </span><span class="s1">readYText,</span><span class="s3">\n  </span><span class="s1">readYXmlElement,</span><span class="s3">\n  </span><span class="s1">readYXmlFragment,</span><span class="s3">\n  </span><span class="s1">readYXmlHook,</span><span class="s3">\n  </span><span class="s1">readYXmlText</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">const YArrayRefID = 0;</span><span class="s3">\n</span><span class="s1">const YMapRefID = 1;</span><span class="s3">\n</span><span class="s1">const YTextRefID = 2;</span><span class="s3">\n</span><span class="s1">const YXmlElementRefID = 3;</span><span class="s3">\n</span><span class="s1">const YXmlFragmentRefID = 4;</span><span class="s3">\n</span><span class="s1">const YXmlHookRefID = 5;</span><span class="s3">\n</span><span class="s1">const YXmlTextRefID = 6;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContentType {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {AbstractType&lt;any&gt;} type</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (type) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {AbstractType&lt;any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLength () {</span><span class="s3">\n    </span><span class="s1">return 1</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getContent () {</span><span class="s3">\n    </span><span class="s1">return [this.type]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">isCountable () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {ContentType}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">copy () {</span><span class="s3">\n    </span><span class="s1">return new ContentType(this.type._copy())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">* @return {ContentType}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">splice (offset) {</span><span class="s3">\n    </span><span class="s1">throw error.methodUnimplemented()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ContentType} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {Item} item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, item) {</span><span class="s3">\n    </span><span class="s1">this.type._integrate(transaction.doc, item);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {</span><span class="s3">\n    </span><span class="s1">let item = this.type._start;</span><span class="s3">\n    </span><span class="s1">while (item !== null) {</span><span class="s3">\n      </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n        </span><span class="s1">item.delete(transaction);</span><span class="s3">\n      </span><span class="s1">} else if (item.id.clock &lt; (transaction.beforeState.get(item.id.client) || 0)) {</span><span class="s3">\n        </span><span class="s1">// This will be gc'd later and we want to merge it if possible</span><span class="s3">\n        </span><span class="s1">// We try to merge all deleted items after each transaction,</span><span class="s3">\n        </span><span class="s1">// but we have no knowledge about that this needs to be merged</span><span class="s3">\n        </span><span class="s1">// since it is not in transaction.ds. Hence we add it to transaction._mergeStructs</span><span class="s3">\n        </span><span class="s1">transaction._mergeStructs.push(item);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">item = item.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.type._map.forEach(item =&gt; {</span><span class="s3">\n      </span><span class="s1">if (!item.deleted) {</span><span class="s3">\n        </span><span class="s1">item.delete(transaction);</span><span class="s3">\n      </span><span class="s1">} else if (item.id.clock &lt; (transaction.beforeState.get(item.id.client) || 0)) {</span><span class="s3">\n        </span><span class="s1">// same as above</span><span class="s3">\n        </span><span class="s1">transaction._mergeStructs.push(item);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">transaction.changed.delete(this.type);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store) {</span><span class="s3">\n    </span><span class="s1">let item = this.type._start;</span><span class="s3">\n    </span><span class="s1">while (item !== null) {</span><span class="s3">\n      </span><span class="s1">item.gc(store, true);</span><span class="s3">\n      </span><span class="s1">item = item.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.type._start = null;</span><span class="s3">\n    </span><span class="s1">this.type._map.forEach(/** @param {Item | null} item */ (item) =&gt; {</span><span class="s3">\n      </span><span class="s1">while (item !== null) {</span><span class="s3">\n        </span><span class="s1">item.gc(store, true);</span><span class="s3">\n        </span><span class="s1">item = item.left;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">this.type._map = new Map();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">this.type._write(encoder);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getRef () {</span><span class="s3">\n    </span><span class="s1">return 7</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @return {ContentType}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readContentType = decoder =&gt; new ContentType(typeRefs[decoder.readTypeRef()](decoder));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo This should return several items</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">* @return {{item:Item, diff:number}}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const followRedone = (store, id) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {ID|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let nextID = id;</span><span class="s3">\n  </span><span class="s1">let diff = 0;</span><span class="s3">\n  </span><span class="s1">let item;</span><span class="s3">\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">if (diff &gt; 0) {</span><span class="s3">\n      </span><span class="s1">nextID = createID(nextID.client, nextID.clock + diff);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">item = getItem(store, nextID);</span><span class="s3">\n    </span><span class="s1">diff = nextID.clock - item.id.clock;</span><span class="s3">\n    </span><span class="s1">nextID = item.redone;</span><span class="s3">\n  </span><span class="s1">} while (nextID !== null &amp;&amp; item instanceof Item)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">item, diff</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Make sure that neither item nor any of its parents is ever deleted.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This property does not persist when storing it into a database or when</span><span class="s3">\n </span><span class="s1">* sending it to other peers</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Item|null} item</span><span class="s3">\n </span><span class="s1">* @param {boolean} keep</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const keepItem = (item, keep) =&gt; {</span><span class="s3">\n  </span><span class="s1">while (item !== null &amp;&amp; item.keep !== keep) {</span><span class="s3">\n    </span><span class="s1">item.keep = keep;</span><span class="s3">\n    </span><span class="s1">item = /** @type {AbstractType&lt;any&gt;} */ (item.parent)._item;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Split leftItem into two items</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n </span><span class="s1">* @param {Item} leftItem</span><span class="s3">\n </span><span class="s1">* @param {number} diff</span><span class="s3">\n </span><span class="s1">* @return {Item}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const splitItem = (transaction, leftItem, diff) =&gt; {</span><span class="s3">\n  </span><span class="s1">// create rightItem</span><span class="s3">\n  </span><span class="s1">const { client, clock } = leftItem.id;</span><span class="s3">\n  </span><span class="s1">const rightItem = new Item(</span><span class="s3">\n    </span><span class="s1">createID(client, clock + diff),</span><span class="s3">\n    </span><span class="s1">leftItem,</span><span class="s3">\n    </span><span class="s1">createID(client, clock + diff - 1),</span><span class="s3">\n    </span><span class="s1">leftItem.right,</span><span class="s3">\n    </span><span class="s1">leftItem.rightOrigin,</span><span class="s3">\n    </span><span class="s1">leftItem.parent,</span><span class="s3">\n    </span><span class="s1">leftItem.parentSub,</span><span class="s3">\n    </span><span class="s1">leftItem.content.splice(diff)</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (leftItem.deleted) {</span><span class="s3">\n    </span><span class="s1">rightItem.markDeleted();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (leftItem.keep) {</span><span class="s3">\n    </span><span class="s1">rightItem.keep = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (leftItem.redone !== null) {</span><span class="s3">\n    </span><span class="s1">rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)</span><span class="s3">\n  </span><span class="s1">leftItem.right = rightItem;</span><span class="s3">\n  </span><span class="s1">// update right</span><span class="s3">\n  </span><span class="s1">if (rightItem.right !== null) {</span><span class="s3">\n    </span><span class="s1">rightItem.right.left = rightItem;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// right is more specific.</span><span class="s3">\n  </span><span class="s1">transaction._mergeStructs.push(rightItem);</span><span class="s3">\n  </span><span class="s1">// update parent._map</span><span class="s3">\n  </span><span class="s1">if (rightItem.parentSub !== null &amp;&amp; rightItem.right === null) {</span><span class="s3">\n    </span><span class="s1">/** @type {AbstractType&lt;any&gt;} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">leftItem.length = diff;</span><span class="s3">\n  </span><span class="s1">return rightItem</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;StackItem&gt;} stack</span><span class="s3">\n </span><span class="s1">* @param {ID} id</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const isDeletedByUndoStack = (stack, id) =&gt; array.some(stack, /** @param {StackItem} s */ s =&gt; isDeleted(s.deletions, id));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Redoes the effect of this operation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Transaction} transaction The Yjs instance.</span><span class="s3">\n </span><span class="s1">* @param {Item} item</span><span class="s3">\n </span><span class="s1">* @param {Set&lt;Item&gt;} redoitems</span><span class="s3">\n </span><span class="s1">* @param {DeleteSet} itemsToDelete</span><span class="s3">\n </span><span class="s1">* @param {boolean} ignoreRemoteMapChanges</span><span class="s3">\n </span><span class="s1">* @param {import('../utils/UndoManager.js').UndoManager} um</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {Item|null}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) =&gt; {</span><span class="s3">\n  </span><span class="s1">const doc = transaction.doc;</span><span class="s3">\n  </span><span class="s1">const store = doc.store;</span><span class="s3">\n  </span><span class="s1">const ownClientID = doc.clientID;</span><span class="s3">\n  </span><span class="s1">const redone = item.redone;</span><span class="s3">\n  </span><span class="s1">if (redone !== null) {</span><span class="s3">\n    </span><span class="s1">return getItemCleanStart(transaction, redone)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">let parentItem = /** @type {AbstractType&lt;any&gt;} */ (item.parent)._item;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Item|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let left = null;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Item|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">let right;</span><span class="s3">\n  </span><span class="s1">// make sure that parent is redone</span><span class="s3">\n  </span><span class="s1">if (parentItem !== null &amp;&amp; parentItem.deleted === true) {</span><span class="s3">\n    </span><span class="s1">// try to undo parent if it will be undone anyway</span><span class="s3">\n    </span><span class="s1">if (parentItem.redone === null &amp;&amp; (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (parentItem.redone !== null) {</span><span class="s3">\n      </span><span class="s1">parentItem = getItemCleanStart(transaction, parentItem.redone);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const parentType = parentItem === null ? /** @type {AbstractType&lt;any&gt;} */ (item.parent) : /** @type {ContentType} */ (parentItem.content).type;</span><span class="s3">\n\n  </span><span class="s1">if (item.parentSub === null) {</span><span class="s3">\n    </span><span class="s1">// Is an array item. Insert at the old position</span><span class="s3">\n    </span><span class="s1">left = item.left;</span><span class="s3">\n    </span><span class="s1">right = item;</span><span class="s3">\n    </span><span class="s1">// find next cloned_redo items</span><span class="s3">\n    </span><span class="s1">while (left !== null) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Item|null}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">let leftTrace = left;</span><span class="s3">\n      </span><span class="s1">// trace redone until parent matches</span><span class="s3">\n      </span><span class="s1">while (leftTrace !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (leftTrace.parent)._item !== parentItem) {</span><span class="s3">\n        </span><span class="s1">leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (leftTrace !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (leftTrace.parent)._item === parentItem) {</span><span class="s3">\n        </span><span class="s1">left = leftTrace;</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">left = left.left;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (right !== null) {</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Item|null}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">let rightTrace = right;</span><span class="s3">\n      </span><span class="s1">// trace redone until parent matches</span><span class="s3">\n      </span><span class="s1">while (rightTrace !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (rightTrace.parent)._item !== parentItem) {</span><span class="s3">\n        </span><span class="s1">rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (rightTrace !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (rightTrace.parent)._item === parentItem) {</span><span class="s3">\n        </span><span class="s1">right = rightTrace;</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">right = right.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">right = null;</span><span class="s3">\n    </span><span class="s1">if (item.right &amp;&amp; !ignoreRemoteMapChanges) {</span><span class="s3">\n      </span><span class="s1">left = item;</span><span class="s3">\n      </span><span class="s1">// Iterate right while right is in itemsToDelete</span><span class="s3">\n      </span><span class="s1">// If it is intended to delete right while item is redone, we can expect that item should replace right.</span><span class="s3">\n      </span><span class="s1">while (left !== null &amp;&amp; left.right !== null &amp;&amp; (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {</span><span class="s3">\n        </span><span class="s1">left = left.right;</span><span class="s3">\n        </span><span class="s1">// follow redone</span><span class="s3">\n        </span><span class="s1">while (left.redone) left = getItemCleanStart(transaction, left.redone);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (left &amp;&amp; left.right !== null) {</span><span class="s3">\n        </span><span class="s1">// It is not possible to redo this item because it conflicts with a</span><span class="s3">\n        </span><span class="s1">// change from another client</span><span class="s3">\n        </span><span class="s1">return null</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">left = parentType._map.get(item.parentSub) || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const nextClock = getState(store, ownClientID);</span><span class="s3">\n  </span><span class="s1">const nextId = createID(ownClientID, nextClock);</span><span class="s3">\n  </span><span class="s1">const redoneItem = new Item(</span><span class="s3">\n    </span><span class="s1">nextId,</span><span class="s3">\n    </span><span class="s1">left, left &amp;&amp; left.lastId,</span><span class="s3">\n    </span><span class="s1">right, right &amp;&amp; right.id,</span><span class="s3">\n    </span><span class="s1">parentType,</span><span class="s3">\n    </span><span class="s1">item.parentSub,</span><span class="s3">\n    </span><span class="s1">item.content.copy()</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">item.redone = nextId;</span><span class="s3">\n  </span><span class="s1">keepItem(redoneItem, true);</span><span class="s3">\n  </span><span class="s1">redoneItem.integrate(transaction, 0);</span><span class="s3">\n  </span><span class="s1">return redoneItem</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Abstract class that represents any content.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Item extends AbstractStruct {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {ID} id</span><span class="s3">\n   </span><span class="s1">* @param {Item | null} left</span><span class="s3">\n   </span><span class="s1">* @param {ID | null} origin</span><span class="s3">\n   </span><span class="s1">* @param {Item | null} right</span><span class="s3">\n   </span><span class="s1">* @param {ID | null} rightOrigin</span><span class="s3">\n   </span><span class="s1">* @param {AbstractType&lt;any&gt;|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.</span><span class="s3">\n   </span><span class="s1">* @param {string | null} parentSub</span><span class="s3">\n   </span><span class="s1">* @param {AbstractContent} content</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {</span><span class="s3">\n    </span><span class="s1">super(id, content.getLength());</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The item that was originally to the left of this item.</span><span class="s3">\n     </span><span class="s1">* @type {ID | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.origin = origin;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The item that is currently to the left of this item.</span><span class="s3">\n     </span><span class="s1">* @type {Item | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.left = left;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The item that is currently to the right of this item.</span><span class="s3">\n     </span><span class="s1">* @type {Item | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.right = right;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The item that was originally to the right of this item.</span><span class="s3">\n     </span><span class="s1">* @type {ID | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.rightOrigin = rightOrigin;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {AbstractType&lt;any&gt;|ID|null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.parent = parent;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If the parent refers to this item with some kind of key (e.g. YMap, the</span><span class="s3">\n     </span><span class="s1">* key is specified here. The key is then used to refer to the list in which</span><span class="s3">\n     </span><span class="s1">* to insert this item. If `parentSub = null` type._start is the list in</span><span class="s3">\n     </span><span class="s1">* which to insert to. Otherwise it is `parent._map`.</span><span class="s3">\n     </span><span class="s1">* @type {String | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.parentSub = parentSub;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* If this type's effect is redone this type refers to the type that undid</span><span class="s3">\n     </span><span class="s1">* this operation.</span><span class="s3">\n     </span><span class="s1">* @type {ID | null}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.redone = null;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {AbstractContent}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.content = content;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* bit1: keep</span><span class="s3">\n     </span><span class="s1">* bit2: countable</span><span class="s3">\n     </span><span class="s1">* bit3: deleted</span><span class="s3">\n     </span><span class="s1">* bit4: mark - mark node as fast-search-marker</span><span class="s3">\n     </span><span class="s1">* @type {number} byte</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.info = this.content.isCountable() ? binary.BIT2 : 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* This is used to mark the item as an indexed fast-search marker</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @type {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">set marker (isMarked) {</span><span class="s3">\n    </span><span class="s1">if (((this.info &amp; binary.BIT4) &gt; 0) !== isMarked) {</span><span class="s3">\n      </span><span class="s1">this.info ^= binary.BIT4;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get marker () {</span><span class="s3">\n    </span><span class="s1">return (this.info &amp; binary.BIT4) &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* If true, do not garbage collect this Item.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get keep () {</span><span class="s3">\n    </span><span class="s1">return (this.info &amp; binary.BIT1) &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set keep (doKeep) {</span><span class="s3">\n    </span><span class="s1">if (this.keep !== doKeep) {</span><span class="s3">\n      </span><span class="s1">this.info ^= binary.BIT1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">get countable () {</span><span class="s3">\n    </span><span class="s1">return (this.info &amp; binary.BIT2) &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Whether this item was deleted or not.</span><span class="s3">\n   </span><span class="s1">* @type {Boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get deleted () {</span><span class="s3">\n    </span><span class="s1">return (this.info &amp; binary.BIT3) &gt; 0</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">set deleted (doDelete) {</span><span class="s3">\n    </span><span class="s1">if (this.deleted !== doDelete) {</span><span class="s3">\n      </span><span class="s1">this.info ^= binary.BIT3;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">markDeleted () {</span><span class="s3">\n    </span><span class="s1">this.info |= binary.BIT3;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Return the creator clientID of the missing op or define missing items and return null.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">* @return {null | number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getMissing (transaction, store) {</span><span class="s3">\n    </span><span class="s1">if (this.origin &amp;&amp; this.origin.client !== this.id.client &amp;&amp; this.origin.clock &gt;= getState(store, this.origin.client)) {</span><span class="s3">\n      </span><span class="s1">return this.origin.client</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.rightOrigin &amp;&amp; this.rightOrigin.client !== this.id.client &amp;&amp; this.rightOrigin.clock &gt;= getState(store, this.rightOrigin.client)) {</span><span class="s3">\n      </span><span class="s1">return this.rightOrigin.client</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.parent &amp;&amp; this.parent.constructor === ID &amp;&amp; this.id.client !== this.parent.client &amp;&amp; this.parent.clock &gt;= getState(store, this.parent.client)) {</span><span class="s3">\n      </span><span class="s1">return this.parent.client</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// We have all missing ids, now find the items</span><span class="s3">\n\n    </span><span class="s1">if (this.origin) {</span><span class="s3">\n      </span><span class="s1">this.left = getItemCleanEnd(transaction, store, this.origin);</span><span class="s3">\n      </span><span class="s1">this.origin = this.left.lastId;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.rightOrigin) {</span><span class="s3">\n      </span><span class="s1">this.right = getItemCleanStart(transaction, this.rightOrigin);</span><span class="s3">\n      </span><span class="s1">this.rightOrigin = this.right.id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ((this.left &amp;&amp; this.left.constructor === GC) || (this.right &amp;&amp; this.right.constructor === GC)) {</span><span class="s3">\n      </span><span class="s1">this.parent = null;</span><span class="s3">\n    </span><span class="s1">} else if (!this.parent) {</span><span class="s3">\n      </span><span class="s1">// only set parent if this shouldn't be garbage collected</span><span class="s3">\n      </span><span class="s1">if (this.left &amp;&amp; this.left.constructor === Item) {</span><span class="s3">\n        </span><span class="s1">this.parent = this.left.parent;</span><span class="s3">\n        </span><span class="s1">this.parentSub = this.left.parentSub;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.right &amp;&amp; this.right.constructor === Item) {</span><span class="s3">\n        </span><span class="s1">this.parent = this.right.parent;</span><span class="s3">\n        </span><span class="s1">this.parentSub = this.right.parentSub;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (this.parent.constructor === ID) {</span><span class="s3">\n      </span><span class="s1">const parentItem = getItem(store, this.parent);</span><span class="s3">\n      </span><span class="s1">if (parentItem.constructor === GC) {</span><span class="s3">\n        </span><span class="s1">this.parent = null;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.parent = /** @type {ContentType} */ (parentItem.content).type;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, offset) {</span><span class="s3">\n    </span><span class="s1">if (offset &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.id.clock += offset;</span><span class="s3">\n      </span><span class="s1">this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));</span><span class="s3">\n      </span><span class="s1">this.origin = this.left.lastId;</span><span class="s3">\n      </span><span class="s1">this.content = this.content.splice(offset);</span><span class="s3">\n      </span><span class="s1">this.length -= offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (this.parent) {</span><span class="s3">\n      </span><span class="s1">if ((!this.left &amp;&amp; (!this.right || this.right.left !== null)) || (this.left &amp;&amp; this.left.right !== this.right)) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Item|null}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let left = this.left;</span><span class="s3">\n\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Item|null}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">let o;</span><span class="s3">\n        </span><span class="s1">// set o to the first conflicting item</span><span class="s3">\n        </span><span class="s1">if (left !== null) {</span><span class="s3">\n          </span><span class="s1">o = left.right;</span><span class="s3">\n        </span><span class="s1">} else if (this.parentSub !== null) {</span><span class="s3">\n          </span><span class="s1">o = /** @type {AbstractType&lt;any&gt;} */ (this.parent)._map.get(this.parentSub) || null;</span><span class="s3">\n          </span><span class="s1">while (o !== null &amp;&amp; o.left !== null) {</span><span class="s3">\n            </span><span class="s1">o = o.left;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">o = /** @type {AbstractType&lt;any&gt;} */ (this.parent)._start;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// TODO: use something like DeleteSet here (a tree implementation would be best)</span><span class="s3">\n        </span><span class="s1">// @todo use global set definitions</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Set&lt;Item&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const conflictingItems = new Set();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* @type {Set&lt;Item&gt;}</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const itemsBeforeOrigin = new Set();</span><span class="s3">\n        </span><span class="s1">// Let c in conflictingItems, b in itemsBeforeOrigin</span><span class="s3">\n        </span><span class="s1">// ***{origin}bbbb{this}{c,b}{c,b}{o}***</span><span class="s3">\n        </span><span class="s1">// Note that conflictingItems is a subset of itemsBeforeOrigin</span><span class="s3">\n        </span><span class="s1">while (o !== null &amp;&amp; o !== this.right) {</span><span class="s3">\n          </span><span class="s1">itemsBeforeOrigin.add(o);</span><span class="s3">\n          </span><span class="s1">conflictingItems.add(o);</span><span class="s3">\n          </span><span class="s1">if (compareIDs(this.origin, o.origin)) {</span><span class="s3">\n            </span><span class="s1">// case 1</span><span class="s3">\n            </span><span class="s1">if (o.id.client &lt; this.id.client) {</span><span class="s3">\n              </span><span class="s1">left = o;</span><span class="s3">\n              </span><span class="s1">conflictingItems.clear();</span><span class="s3">\n            </span><span class="s1">} else if (compareIDs(this.rightOrigin, o.rightOrigin)) {</span><span class="s3">\n              </span><span class="s1">// this and o are conflicting and point to the same integration points. The id decides which item comes first.</span><span class="s3">\n              </span><span class="s1">// Since this is to the left of o, we can break here</span><span class="s3">\n              </span><span class="s1">break</span><span class="s3">\n            </span><span class="s1">} // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations</span><span class="s3">\n          </span><span class="s1">} else if (o.origin !== null &amp;&amp; itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.</span><span class="s3">\n            </span><span class="s1">// case 2</span><span class="s3">\n            </span><span class="s1">if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {</span><span class="s3">\n              </span><span class="s1">left = o;</span><span class="s3">\n              </span><span class="s1">conflictingItems.clear();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">break</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">o = o.right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.left = left;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// reconnect left/right + update parent map/start if necessary</span><span class="s3">\n      </span><span class="s1">if (this.left !== null) {</span><span class="s3">\n        </span><span class="s1">const right = this.left.right;</span><span class="s3">\n        </span><span class="s1">this.right = right;</span><span class="s3">\n        </span><span class="s1">this.left.right = this;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">let r;</span><span class="s3">\n        </span><span class="s1">if (this.parentSub !== null) {</span><span class="s3">\n          </span><span class="s1">r = /** @type {AbstractType&lt;any&gt;} */ (this.parent)._map.get(this.parentSub) || null;</span><span class="s3">\n          </span><span class="s1">while (r !== null &amp;&amp; r.left !== null) {</span><span class="s3">\n            </span><span class="s1">r = r.left;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">r = /** @type {AbstractType&lt;any&gt;} */ (this.parent)._start</span><span class="s3">\n          </span><span class="s1">;/** @type {AbstractType&lt;any&gt;} */ (this.parent)._start = this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.right = r;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.right !== null) {</span><span class="s3">\n        </span><span class="s1">this.right.left = this;</span><span class="s3">\n      </span><span class="s1">} else if (this.parentSub !== null) {</span><span class="s3">\n        </span><span class="s1">// set as current parent value if right === null and this is parentSub</span><span class="s3">\n        </span><span class="s1">/** @type {AbstractType&lt;any&gt;} */ (this.parent)._map.set(this.parentSub, this);</span><span class="s3">\n        </span><span class="s1">if (this.left !== null) {</span><span class="s3">\n          </span><span class="s1">// this is the current attribute value of parent. delete right</span><span class="s3">\n          </span><span class="s1">this.left.delete(transaction);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// adjust length of parent</span><span class="s3">\n      </span><span class="s1">if (this.parentSub === null &amp;&amp; this.countable &amp;&amp; !this.deleted) {</span><span class="s3">\n        </span><span class="s1">/** @type {AbstractType&lt;any&gt;} */ (this.parent)._length += this.length;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">addStruct(transaction.doc.store, this);</span><span class="s3">\n      </span><span class="s1">this.content.integrate(transaction, this);</span><span class="s3">\n      </span><span class="s1">// add parent to transaction.changed</span><span class="s3">\n      </span><span class="s1">addChangedTypeToTransaction(transaction, /** @type {AbstractType&lt;any&gt;} */ (this.parent), this.parentSub);</span><span class="s3">\n      </span><span class="s1">if ((/** @type {AbstractType&lt;any&gt;} */ (this.parent)._item !== null &amp;&amp; /** @type {AbstractType&lt;any&gt;} */ (this.parent)._item.deleted) || (this.parentSub !== null &amp;&amp; this.right !== null)) {</span><span class="s3">\n        </span><span class="s1">// delete if parent is deleted or if this is not the current attribute value of parent</span><span class="s3">\n        </span><span class="s1">this.delete(transaction);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// parent is not defined. Integrate GC struct instead</span><span class="s3">\n      </span><span class="s1">new GC(this.id, this.length).integrate(transaction, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the next non-deleted item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get next () {</span><span class="s3">\n    </span><span class="s1">let n = this.right;</span><span class="s3">\n    </span><span class="s1">while (n !== null &amp;&amp; n.deleted) {</span><span class="s3">\n      </span><span class="s1">n = n.right;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return n</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Returns the previous non-deleted item</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get prev () {</span><span class="s3">\n    </span><span class="s1">let n = this.left;</span><span class="s3">\n    </span><span class="s1">while (n !== null &amp;&amp; n.deleted) {</span><span class="s3">\n      </span><span class="s1">n = n.left;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return n</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Computes the last content address of this Item.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">get lastId () {</span><span class="s3">\n    </span><span class="s1">// allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible</span><span class="s3">\n    </span><span class="s1">return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Try to merge two items</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Item} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">if (</span><span class="s3">\n      </span><span class="s1">this.constructor === right.constructor &amp;&amp;</span><span class="s3">\n      </span><span class="s1">compareIDs(right.origin, this.lastId) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.right === right &amp;&amp;</span><span class="s3">\n      </span><span class="s1">compareIDs(this.rightOrigin, right.rightOrigin) &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.id.client === right.id.client &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.id.clock + this.length === right.id.clock &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.deleted === right.deleted &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.redone === null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">right.redone === null &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.content.constructor === right.content.constructor &amp;&amp;</span><span class="s3">\n      </span><span class="s1">this.content.mergeWith(right.content)</span><span class="s3">\n    </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">const searchMarker = /** @type {AbstractType&lt;any&gt;} */ (this.parent)._searchMarker;</span><span class="s3">\n      </span><span class="s1">if (searchMarker) {</span><span class="s3">\n        </span><span class="s1">searchMarker.forEach(marker =&gt; {</span><span class="s3">\n          </span><span class="s1">if (marker.p === right) {</span><span class="s3">\n            </span><span class="s1">// right is going to be </span><span class="s3">\&quot;</span><span class="s1">forgotten</span><span class="s3">\&quot; </span><span class="s1">so we need to update the marker</span><span class="s3">\n            </span><span class="s1">marker.p = this;</span><span class="s3">\n            </span><span class="s1">// adjust marker index</span><span class="s3">\n            </span><span class="s1">if (!this.deleted &amp;&amp; this.countable) {</span><span class="s3">\n              </span><span class="s1">marker.index -= this.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (right.keep) {</span><span class="s3">\n        </span><span class="s1">this.keep = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.right = right.right;</span><span class="s3">\n      </span><span class="s1">if (this.right !== null) {</span><span class="s3">\n        </span><span class="s1">this.right.left = this;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.length += right.length;</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Mark this Item as deleted.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">delete (transaction) {</span><span class="s3">\n    </span><span class="s1">if (!this.deleted) {</span><span class="s3">\n      </span><span class="s1">const parent = /** @type {AbstractType&lt;any&gt;} */ (this.parent);</span><span class="s3">\n      </span><span class="s1">// adjust the length of parent</span><span class="s3">\n      </span><span class="s1">if (this.countable &amp;&amp; this.parentSub === null) {</span><span class="s3">\n        </span><span class="s1">parent._length -= this.length;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.markDeleted();</span><span class="s3">\n      </span><span class="s1">addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);</span><span class="s3">\n      </span><span class="s1">addChangedTypeToTransaction(transaction, parent, this.parentSub);</span><span class="s3">\n      </span><span class="s1">this.content.delete(transaction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">* @param {boolean} parentGCd</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">gc (store, parentGCd) {</span><span class="s3">\n    </span><span class="s1">if (!this.deleted) {</span><span class="s3">\n      </span><span class="s1">throw error.unexpectedCase()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.content.gc(store);</span><span class="s3">\n    </span><span class="s1">if (parentGCd) {</span><span class="s3">\n      </span><span class="s1">replaceStruct(store, this, new GC(this.id, this.length));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.content = new ContentDeleted(this.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Transform the properties of this type to binary and write it to an</span><span class="s3">\n   </span><span class="s1">* BinaryEncoder.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This is called when this Item is sent to a remote peer.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">const origin = offset &gt; 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;</span><span class="s3">\n    </span><span class="s1">const rightOrigin = this.rightOrigin;</span><span class="s3">\n    </span><span class="s1">const parentSub = this.parentSub;</span><span class="s3">\n    </span><span class="s1">const info = (this.content.getRef() &amp; binary.BITS5) |</span><span class="s3">\n      </span><span class="s1">(origin === null ? 0 : binary.BIT8) | // origin is defined</span><span class="s3">\n      </span><span class="s1">(rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined</span><span class="s3">\n      </span><span class="s1">(parentSub === null ? 0 : binary.BIT6); // parentSub is non-null</span><span class="s3">\n    </span><span class="s1">encoder.writeInfo(info);</span><span class="s3">\n    </span><span class="s1">if (origin !== null) {</span><span class="s3">\n      </span><span class="s1">encoder.writeLeftID(origin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (rightOrigin !== null) {</span><span class="s3">\n      </span><span class="s1">encoder.writeRightID(rightOrigin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (origin === null &amp;&amp; rightOrigin === null) {</span><span class="s3">\n      </span><span class="s1">const parent = /** @type {AbstractType&lt;any&gt;} */ (this.parent);</span><span class="s3">\n      </span><span class="s1">if (parent._item !== undefined) {</span><span class="s3">\n        </span><span class="s1">const parentItem = parent._item;</span><span class="s3">\n        </span><span class="s1">if (parentItem === null) {</span><span class="s3">\n          </span><span class="s1">// parent type on y._map</span><span class="s3">\n          </span><span class="s1">// find the correct key</span><span class="s3">\n          </span><span class="s1">const ykey = findRootTypeKey(parent);</span><span class="s3">\n          </span><span class="s1">encoder.writeParentInfo(true); // write parentYKey</span><span class="s3">\n          </span><span class="s1">encoder.writeString(ykey);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">encoder.writeParentInfo(false); // write parent id</span><span class="s3">\n          </span><span class="s1">encoder.writeLeftID(parentItem.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (parent.constructor === String) { // this edge case was added by differential updates</span><span class="s3">\n        </span><span class="s1">encoder.writeParentInfo(true); // write parentYKey</span><span class="s3">\n        </span><span class="s1">encoder.writeString(parent);</span><span class="s3">\n      </span><span class="s1">} else if (parent.constructor === ID) {</span><span class="s3">\n        </span><span class="s1">encoder.writeParentInfo(false); // write parent id</span><span class="s3">\n        </span><span class="s1">encoder.writeLeftID(parent);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (parentSub !== null) {</span><span class="s3">\n        </span><span class="s1">encoder.writeString(parentSub);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.content.write(encoder, offset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {UpdateDecoderV1 | UpdateDecoderV2} decoder</span><span class="s3">\n </span><span class="s1">* @param {number} info</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const readItemContent = (decoder, info) =&gt; contentRefs[info &amp; binary.BITS5](decoder);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A lookup map for reading Item content.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @type {Array&lt;function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const contentRefs = [</span><span class="s3">\n  </span><span class="s1">() =&gt; { error.unexpectedCase(); }, // GC is not ItemContent</span><span class="s3">\n  </span><span class="s1">readContentDeleted, // 1</span><span class="s3">\n  </span><span class="s1">readContentJSON, // 2</span><span class="s3">\n  </span><span class="s1">readContentBinary, // 3</span><span class="s3">\n  </span><span class="s1">readContentString, // 4</span><span class="s3">\n  </span><span class="s1">readContentEmbed, // 5</span><span class="s3">\n  </span><span class="s1">readContentFormat, // 6</span><span class="s3">\n  </span><span class="s1">readContentType, // 7</span><span class="s3">\n  </span><span class="s1">readContentAny, // 8</span><span class="s3">\n  </span><span class="s1">readContentDoc, // 9</span><span class="s3">\n  </span><span class="s1">() =&gt; { error.unexpectedCase(); } // 10 - Skip is not ItemContent</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">const structSkipRefNumber = 10;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Skip extends AbstractStruct {</span><span class="s3">\n  </span><span class="s1">get deleted () {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">delete () {}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Skip} right</span><span class="s3">\n   </span><span class="s1">* @return {boolean}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">mergeWith (right) {</span><span class="s3">\n    </span><span class="s1">if (this.constructor !== right.constructor) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.length += right.length;</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">integrate (transaction, offset) {</span><span class="s3">\n    </span><span class="s1">// skip structs cannot be integrated</span><span class="s3">\n    </span><span class="s1">error.unexpectedCase();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {UpdateEncoderV1 | UpdateEncoderV2} encoder</span><span class="s3">\n   </span><span class="s1">* @param {number} offset</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">write (encoder, offset) {</span><span class="s3">\n    </span><span class="s1">encoder.writeInfo(structSkipRefNumber);</span><span class="s3">\n    </span><span class="s1">// write as VarUint because Skips can't make use of predictable length-encoding</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder.restEncoder, this.length - offset);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Transaction} transaction</span><span class="s3">\n   </span><span class="s1">* @param {StructStore} store</span><span class="s3">\n   </span><span class="s1">* @return {null | number}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getMissing (transaction, store) {</span><span class="s3">\n    </span><span class="s1">return null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/** eslint-env browser */</span><span class="s3">\n\n</span><span class="s1">const glo = /** @type {any} */ (typeof globalThis !== 'undefined'</span><span class="s3">\n  </span><span class="s1">? globalThis</span><span class="s3">\n  </span><span class="s1">: typeof window !== 'undefined'</span><span class="s3">\n    </span><span class="s1">? window</span><span class="s3">\n    </span><span class="s1">// @ts-ignore</span><span class="s3">\n    </span><span class="s1">: typeof global !== 'undefined' ? global : {});</span><span class="s3">\n\n</span><span class="s1">const importIdentifier = '__ $YJS$ __';</span><span class="s3">\n\n</span><span class="s1">if (glo[importIdentifier] === true) {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Dear reader of this message. Please take this seriously.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* If you see this message, make sure that you only import one version of Yjs. In many cases,</span><span class="s3">\n   </span><span class="s1">* your package manager installs two versions of Yjs that are used by different packages within your project.</span><span class="s3">\n   </span><span class="s1">* Another reason for this message is that some parts of your project use the commonjs version of Yjs</span><span class="s3">\n   </span><span class="s1">* and others use the EcmaScript version of Yjs.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* This often leads to issues that are hard to debug. We often need to perform constructor checks,</span><span class="s3">\n   </span><span class="s1">* e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to</span><span class="s3">\n   </span><span class="s1">* do the constructor checks anymore - which might break the CRDT algorithm.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* https://github.com/yjs/yjs/issues/438</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">glo[importIdentifier] = true;</span><span class="s3">\n\n</span><span class="s1">export { AbsolutePosition, AbstractConnector, AbstractStruct, AbstractType, YArray as Array, ContentAny, ContentBinary, ContentDeleted, ContentEmbed, ContentFormat, ContentJSON, ContentString, ContentType, Doc, GC, ID, Item, YMap as Map, PermanentUserData, RelativePosition, Snapshot, YText as Text, Transaction, UndoManager, UpdateEncoderV1, YXmlElement as XmlElement, YXmlFragment as XmlFragment, YXmlHook as XmlHook, YXmlText as XmlText, YArrayEvent, YEvent, YMapEvent, YTextEvent, YXmlEvent, applyUpdate, applyUpdateV2, cleanupYTextFormatting, compareIDs, compareRelativePositions, convertUpdateFormatV1ToV2, convertUpdateFormatV2ToV1, createAbsolutePositionFromRelativePosition, createDeleteSet, createDeleteSetFromStructStore, createDocFromSnapshot, createID, createRelativePositionFromJSON, createRelativePositionFromTypeIndex, createSnapshot, decodeRelativePosition, decodeSnapshot, decodeSnapshotV2, decodeStateVector, decodeUpdate, decodeUpdateV2, diffUpdate, diffUpdateV2, emptySnapshot, encodeRelativePosition, encodeSnapshot, encodeSnapshotV2, encodeStateAsUpdate, encodeStateAsUpdateV2, encodeStateVector, encodeStateVectorFromUpdate, encodeStateVectorFromUpdateV2, equalDeleteSets, equalSnapshots, findIndexSS, findRootTypeKey, getItem, getState, getTypeChildren, isDeleted, isParentOf, iterateDeletedStructs, logType, logUpdate, logUpdateV2, mergeUpdates, mergeUpdatesV2, obfuscateUpdate, obfuscateUpdateV2, parseUpdateMeta, parseUpdateMetaV2, readUpdate, readUpdateV2, relativePositionToJSON, snapshot, snapshotContainsUpdate, transact, tryGc, typeListToArraySnapshot, typeMapGetSnapshot };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=yjs.mjs.map</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>