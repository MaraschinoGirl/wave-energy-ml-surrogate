<html>
<head>
<title>5448.a9016133a2b9389ac102.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
5448.a9016133a2b9389ac102.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;5448.a9016133a2b9389ac102.js?v=a9016133a2b9389ac102&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;AAAa;;AAEb;;;;AAIA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;AC7CY;;AAEZ,QAAQ,kGAAkG,EAAE,mBAAO,CAAC,KAAa;AACjI,gBAAgB,mBAAO,CAAC,KAAe;;AAEvC;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA,4CAA4C,gBAAgB;AAC5D;AACA,+BAA+B,wCAAwC;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;AACA,+EAA+E,8BAA8B;AAC7G,IAAI;AACJ,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,aAAa,8BAA8B,QAAQ;;AAElF;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAsB;AACtB,sBAAsB;;;;;;;;AC9SV;;AAEZ,2BAA2B,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,EAAE,SAAS,GAAG;AAC1E,mCAAmC,KAAK,sBAAsB,aAAa,EAAE;;AAE7E;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO,GAAG,iCAAiC;AACpE;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,OAAO,GAAG,mBAAmB;AACpD;;AAEA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,mBAAmB,GAAG,IAAI;;AAEpD;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3LY;;AAEZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC7BY;;AAEZ,QAAQ,MAAM,EAAE,mBAAO,CAAC,KAAe;;AAEvC,8CAA8C,EAAE,gBAAgB,EAAE,wBAAwB,EAAE;;AAE5F;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,wBAAwB;AACxB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,IAAI;AACJ,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB,oBAAoB;AACvC,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnPa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/fast-deep-equal/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/fast-uri/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/fast-uri/lib/schemes.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/fast-uri/lib/scopedChars.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/fast-uri/lib/utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-traverse/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">// do not edit .js files directly - edit src/index.jst</span><span class="s3">\n\n\n\n</span><span class="s1">module.exports = function equal(a, b) {</span><span class="s3">\n  </span><span class="s1">if (a === b) return true;</span><span class="s3">\n\n  </span><span class="s1">if (a &amp;&amp; b &amp;&amp; typeof a == 'object' &amp;&amp; typeof b == 'object') {</span><span class="s3">\n    </span><span class="s1">if (a.constructor !== b.constructor) return false;</span><span class="s3">\n\n    </span><span class="s1">var length, i, keys;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(a)) {</span><span class="s3">\n      </span><span class="s1">length = a.length;</span><span class="s3">\n      </span><span class="s1">if (length != b.length) return false;</span><span class="s3">\n      </span><span class="s1">for (i = length; i-- !== 0;)</span><span class="s3">\n        </span><span class="s1">if (!equal(a[i], b[i])) return false;</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n    </span><span class="s1">if (a.constructor === RegExp) return a.source === b.source &amp;&amp; a.flags === b.flags;</span><span class="s3">\n    </span><span class="s1">if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();</span><span class="s3">\n    </span><span class="s1">if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();</span><span class="s3">\n\n    </span><span class="s1">keys = Object.keys(a);</span><span class="s3">\n    </span><span class="s1">length = keys.length;</span><span class="s3">\n    </span><span class="s1">if (length !== Object.keys(b).length) return false;</span><span class="s3">\n\n    </span><span class="s1">for (i = length; i-- !== 0;)</span><span class="s3">\n      </span><span class="s1">if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;</span><span class="s3">\n\n    </span><span class="s1">for (i = length; i-- !== 0;) {</span><span class="s3">\n      </span><span class="s1">var key = keys[i];</span><span class="s3">\n\n      </span><span class="s1">if (!equal(a[key], b[key])) return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// true if both NaN, false otherwise</span><span class="s3">\n  </span><span class="s1">return a!==a &amp;&amp; b!==b;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict'</span><span class="s3">\n\n</span><span class="s1">const { normalizeIPv6, normalizeIPv4, removeDotSegments, recomposeAuthority, normalizeComponentEncoding } = require('./lib/utils')</span><span class="s3">\n</span><span class="s1">const SCHEMES = require('./lib/schemes')</span><span class="s3">\n\n</span><span class="s1">function normalize (uri, options) {</span><span class="s3">\n  </span><span class="s1">if (typeof uri === 'string') {</span><span class="s3">\n    </span><span class="s1">uri = serialize(parse(uri, options), options)</span><span class="s3">\n  </span><span class="s1">} else if (typeof uri === 'object') {</span><span class="s3">\n    </span><span class="s1">uri = parse(serialize(uri, options), options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return uri</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolve (baseURI, relativeURI, options) {</span><span class="s3">\n  </span><span class="s1">const schemelessOptions = Object.assign({ scheme: 'null' }, options)</span><span class="s3">\n  </span><span class="s1">const resolved = resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true)</span><span class="s3">\n  </span><span class="s1">return serialize(resolved, { ...schemelessOptions, skipEscape: true })</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function resolveComponents (base, relative, options, skipNormalization) {</span><span class="s3">\n  </span><span class="s1">const target = {}</span><span class="s3">\n  </span><span class="s1">if (!skipNormalization) {</span><span class="s3">\n    </span><span class="s1">base = parse(serialize(base, options), options) // normalize base components</span><span class="s3">\n    </span><span class="s1">relative = parse(serialize(relative, options), options) // normalize relative components</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">options = options || {}</span><span class="s3">\n\n  </span><span class="s1">if (!options.tolerant &amp;&amp; relative.scheme) {</span><span class="s3">\n    </span><span class="s1">target.scheme = relative.scheme</span><span class="s3">\n    </span><span class="s1">// target.authority = relative.authority;</span><span class="s3">\n    </span><span class="s1">target.userinfo = relative.userinfo</span><span class="s3">\n    </span><span class="s1">target.host = relative.host</span><span class="s3">\n    </span><span class="s1">target.port = relative.port</span><span class="s3">\n    </span><span class="s1">target.path = removeDotSegments(relative.path || '')</span><span class="s3">\n    </span><span class="s1">target.query = relative.query</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {</span><span class="s3">\n      </span><span class="s1">// target.authority = relative.authority;</span><span class="s3">\n      </span><span class="s1">target.userinfo = relative.userinfo</span><span class="s3">\n      </span><span class="s1">target.host = relative.host</span><span class="s3">\n      </span><span class="s1">target.port = relative.port</span><span class="s3">\n      </span><span class="s1">target.path = removeDotSegments(relative.path || '')</span><span class="s3">\n      </span><span class="s1">target.query = relative.query</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (!relative.path) {</span><span class="s3">\n        </span><span class="s1">target.path = base.path</span><span class="s3">\n        </span><span class="s1">if (relative.query !== undefined) {</span><span class="s3">\n          </span><span class="s1">target.query = relative.query</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">target.query = base.query</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (relative.path.charAt(0) === '/') {</span><span class="s3">\n          </span><span class="s1">target.path = removeDotSegments(relative.path)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) &amp;&amp; !base.path) {</span><span class="s3">\n            </span><span class="s1">target.path = '/' + relative.path</span><span class="s3">\n          </span><span class="s1">} else if (!base.path) {</span><span class="s3">\n            </span><span class="s1">target.path = relative.path</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">target.path = base.path.slice(0, base.path.lastIndexOf('/') + 1) + relative.path</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">target.path = removeDotSegments(target.path)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">target.query = relative.query</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// target.authority = base.authority;</span><span class="s3">\n      </span><span class="s1">target.userinfo = base.userinfo</span><span class="s3">\n      </span><span class="s1">target.host = base.host</span><span class="s3">\n      </span><span class="s1">target.port = base.port</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">target.scheme = base.scheme</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">target.fragment = relative.fragment</span><span class="s3">\n\n  </span><span class="s1">return target</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function equal (uriA, uriB, options) {</span><span class="s3">\n  </span><span class="s1">if (typeof uriA === 'string') {</span><span class="s3">\n    </span><span class="s1">uriA = unescape(uriA)</span><span class="s3">\n    </span><span class="s1">uriA = serialize(normalizeComponentEncoding(parse(uriA, options), true), { ...options, skipEscape: true })</span><span class="s3">\n  </span><span class="s1">} else if (typeof uriA === 'object') {</span><span class="s3">\n    </span><span class="s1">uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof uriB === 'string') {</span><span class="s3">\n    </span><span class="s1">uriB = unescape(uriB)</span><span class="s3">\n    </span><span class="s1">uriB = serialize(normalizeComponentEncoding(parse(uriB, options), true), { ...options, skipEscape: true })</span><span class="s3">\n  </span><span class="s1">} else if (typeof uriB === 'object') {</span><span class="s3">\n    </span><span class="s1">uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return uriA.toLowerCase() === uriB.toLowerCase()</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function serialize (cmpts, opts) {</span><span class="s3">\n  </span><span class="s1">const components = {</span><span class="s3">\n    </span><span class="s1">host: cmpts.host,</span><span class="s3">\n    </span><span class="s1">scheme: cmpts.scheme,</span><span class="s3">\n    </span><span class="s1">userinfo: cmpts.userinfo,</span><span class="s3">\n    </span><span class="s1">port: cmpts.port,</span><span class="s3">\n    </span><span class="s1">path: cmpts.path,</span><span class="s3">\n    </span><span class="s1">query: cmpts.query,</span><span class="s3">\n    </span><span class="s1">nid: cmpts.nid,</span><span class="s3">\n    </span><span class="s1">nss: cmpts.nss,</span><span class="s3">\n    </span><span class="s1">uuid: cmpts.uuid,</span><span class="s3">\n    </span><span class="s1">fragment: cmpts.fragment,</span><span class="s3">\n    </span><span class="s1">reference: cmpts.reference,</span><span class="s3">\n    </span><span class="s1">resourceName: cmpts.resourceName,</span><span class="s3">\n    </span><span class="s1">secure: cmpts.secure,</span><span class="s3">\n    </span><span class="s1">error: ''</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const options = Object.assign({}, opts)</span><span class="s3">\n  </span><span class="s1">const uriTokens = []</span><span class="s3">\n\n  </span><span class="s1">// find scheme handler</span><span class="s3">\n  </span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || components.scheme || '').toLowerCase()]</span><span class="s3">\n\n  </span><span class="s1">// perform scheme specific serialization</span><span class="s3">\n  </span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.serialize) schemeHandler.serialize(components, options)</span><span class="s3">\n\n  </span><span class="s1">if (components.path !== undefined) {</span><span class="s3">\n    </span><span class="s1">if (!options.skipEscape) {</span><span class="s3">\n      </span><span class="s1">components.path = escape(components.path)</span><span class="s3">\n\n      </span><span class="s1">if (components.scheme !== undefined) {</span><span class="s3">\n        </span><span class="s1">components.path = components.path.split('%3A').join(':')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">components.path = unescape(components.path)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.reference !== 'suffix' &amp;&amp; components.scheme) {</span><span class="s3">\n    </span><span class="s1">uriTokens.push(components.scheme, ':')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const authority = recomposeAuthority(components)</span><span class="s3">\n  </span><span class="s1">if (authority !== undefined) {</span><span class="s3">\n    </span><span class="s1">if (options.reference !== 'suffix') {</span><span class="s3">\n      </span><span class="s1">uriTokens.push('//')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">uriTokens.push(authority)</span><span class="s3">\n\n    </span><span class="s1">if (components.path &amp;&amp; components.path.charAt(0) !== '/') {</span><span class="s3">\n      </span><span class="s1">uriTokens.push('/')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.path !== undefined) {</span><span class="s3">\n    </span><span class="s1">let s = components.path</span><span class="s3">\n\n    </span><span class="s1">if (!options.absolutePath &amp;&amp; (!schemeHandler || !schemeHandler.absolutePath)) {</span><span class="s3">\n      </span><span class="s1">s = removeDotSegments(s)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (authority === undefined) {</span><span class="s3">\n      </span><span class="s1">s = s.replace(/^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">//u, '/%2F') // don't allow the path to start with </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">uriTokens.push(s)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (components.query !== undefined) {</span><span class="s3">\n    </span><span class="s1">uriTokens.push('?', components.query)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (components.fragment !== undefined) {</span><span class="s3">\n    </span><span class="s1">uriTokens.push('#', components.fragment)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return uriTokens.join('')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const hexLookUp = Array.from({ length: 127 }, (_v, k) =&gt; /[^!</span><span class="s3">\&quot;</span><span class="s1">$&amp;'()*+,</span><span class="s3">\\</span><span class="s1">-.;=_`a-z{}~]/u.test(String.fromCharCode(k)))</span><span class="s3">\n\n</span><span class="s1">function nonSimpleDomain (value) {</span><span class="s3">\n  </span><span class="s1">let code = 0</span><span class="s3">\n  </span><span class="s1">for (let i = 0, len = value.length; i &lt; len; ++i) {</span><span class="s3">\n    </span><span class="s1">code = value.charCodeAt(i)</span><span class="s3">\n    </span><span class="s1">if (code &gt; 126 || hexLookUp[code]) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const URI_PARSE = /^(?:([^#/:?]+):)?(?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/((?:([^#/?@]*)@)?(</span><span class="s3">\\</span><span class="s1">[[^#/?</span><span class="s3">\\</span><span class="s1">]]+</span><span class="s3">\\</span><span class="s1">]|[^#/:?]*)(?::(</span><span class="s3">\\</span><span class="s1">d*))?))?([^#?]*)(?:</span><span class="s3">\\</span><span class="s1">?([^#]*))?(?:#((?:.|[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">r])*))?/u</span><span class="s3">\n\n</span><span class="s1">function parse (uri, opts) {</span><span class="s3">\n  </span><span class="s1">const options = Object.assign({}, opts)</span><span class="s3">\n  </span><span class="s1">const parsed = {</span><span class="s3">\n    </span><span class="s1">scheme: undefined,</span><span class="s3">\n    </span><span class="s1">userinfo: undefined,</span><span class="s3">\n    </span><span class="s1">host: '',</span><span class="s3">\n    </span><span class="s1">port: undefined,</span><span class="s3">\n    </span><span class="s1">path: '',</span><span class="s3">\n    </span><span class="s1">query: undefined,</span><span class="s3">\n    </span><span class="s1">fragment: undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const gotEncoding = uri.indexOf('%') !== -1</span><span class="s3">\n  </span><span class="s1">let isIP = false</span><span class="s3">\n  </span><span class="s1">if (options.reference === 'suffix') uri = (options.scheme ? options.scheme + ':' : '') + '//' + uri</span><span class="s3">\n\n  </span><span class="s1">const matches = uri.match(URI_PARSE)</span><span class="s3">\n\n  </span><span class="s1">if (matches) {</span><span class="s3">\n    </span><span class="s1">// store each component</span><span class="s3">\n    </span><span class="s1">parsed.scheme = matches[1]</span><span class="s3">\n    </span><span class="s1">parsed.userinfo = matches[3]</span><span class="s3">\n    </span><span class="s1">parsed.host = matches[4]</span><span class="s3">\n    </span><span class="s1">parsed.port = parseInt(matches[5], 10)</span><span class="s3">\n    </span><span class="s1">parsed.path = matches[6] || ''</span><span class="s3">\n    </span><span class="s1">parsed.query = matches[7]</span><span class="s3">\n    </span><span class="s1">parsed.fragment = matches[8]</span><span class="s3">\n\n    </span><span class="s1">// fix port number</span><span class="s3">\n    </span><span class="s1">if (isNaN(parsed.port)) {</span><span class="s3">\n      </span><span class="s1">parsed.port = matches[5]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parsed.host) {</span><span class="s3">\n      </span><span class="s1">const ipv4result = normalizeIPv4(parsed.host)</span><span class="s3">\n      </span><span class="s1">if (ipv4result.isIPV4 === false) {</span><span class="s3">\n        </span><span class="s1">const ipv6result = normalizeIPv6(ipv4result.host)</span><span class="s3">\n        </span><span class="s1">parsed.host = ipv6result.host.toLowerCase()</span><span class="s3">\n        </span><span class="s1">isIP = ipv6result.isIPV6</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">parsed.host = ipv4result.host</span><span class="s3">\n        </span><span class="s1">isIP = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parsed.scheme === undefined &amp;&amp; parsed.userinfo === undefined &amp;&amp; parsed.host === undefined &amp;&amp; parsed.port === undefined &amp;&amp; parsed.query === undefined &amp;&amp; !parsed.path) {</span><span class="s3">\n      </span><span class="s1">parsed.reference = 'same-document'</span><span class="s3">\n    </span><span class="s1">} else if (parsed.scheme === undefined) {</span><span class="s3">\n      </span><span class="s1">parsed.reference = 'relative'</span><span class="s3">\n    </span><span class="s1">} else if (parsed.fragment === undefined) {</span><span class="s3">\n      </span><span class="s1">parsed.reference = 'absolute'</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">parsed.reference = 'uri'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check for reference errors</span><span class="s3">\n    </span><span class="s1">if (options.reference &amp;&amp; options.reference !== 'suffix' &amp;&amp; options.reference !== parsed.reference) {</span><span class="s3">\n      </span><span class="s1">parsed.error = parsed.error || 'URI is not a ' + options.reference + ' reference.'</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// find scheme handler</span><span class="s3">\n    </span><span class="s1">const schemeHandler = SCHEMES[(options.scheme || parsed.scheme || '').toLowerCase()]</span><span class="s3">\n\n    </span><span class="s1">// check if scheme can't handle IRIs</span><span class="s3">\n    </span><span class="s1">if (!options.unicodeSupport &amp;&amp; (!schemeHandler || !schemeHandler.unicodeSupport)) {</span><span class="s3">\n      </span><span class="s1">// if host component is a domain name</span><span class="s3">\n      </span><span class="s1">if (parsed.host &amp;&amp; (options.domainHost || (schemeHandler &amp;&amp; schemeHandler.domainHost)) &amp;&amp; isIP === false &amp;&amp; nonSimpleDomain(parsed.host)) {</span><span class="s3">\n        </span><span class="s1">// convert Unicode IDN -&gt; ASCII IDN</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">parsed.host = URL.domainToASCII(parsed.host.toLowerCase())</span><span class="s3">\n        </span><span class="s1">} catch (e) {</span><span class="s3">\n          </span><span class="s1">parsed.error = parsed.error || </span><span class="s3">\&quot;</span><span class="s1">Host's domain name can not be converted to ASCII: </span><span class="s3">\&quot; </span><span class="s1">+ e</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// convert IRI -&gt; URI</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!schemeHandler || (schemeHandler &amp;&amp; !schemeHandler.skipNormalize)) {</span><span class="s3">\n      </span><span class="s1">if (gotEncoding &amp;&amp; parsed.scheme !== undefined) {</span><span class="s3">\n        </span><span class="s1">parsed.scheme = unescape(parsed.scheme)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (gotEncoding &amp;&amp; parsed.host !== undefined) {</span><span class="s3">\n        </span><span class="s1">parsed.host = unescape(parsed.host)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (parsed.path) {</span><span class="s3">\n        </span><span class="s1">parsed.path = escape(unescape(parsed.path))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (parsed.fragment) {</span><span class="s3">\n        </span><span class="s1">parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment))</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// perform scheme specific parsing</span><span class="s3">\n    </span><span class="s1">if (schemeHandler &amp;&amp; schemeHandler.parse) {</span><span class="s3">\n      </span><span class="s1">schemeHandler.parse(parsed, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">parsed.error = parsed.error || 'URI can not be parsed.'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return parsed</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const fastUri = {</span><span class="s3">\n  </span><span class="s1">SCHEMES,</span><span class="s3">\n  </span><span class="s1">normalize,</span><span class="s3">\n  </span><span class="s1">resolve,</span><span class="s3">\n  </span><span class="s1">resolveComponents,</span><span class="s3">\n  </span><span class="s1">equal,</span><span class="s3">\n  </span><span class="s1">serialize,</span><span class="s3">\n  </span><span class="s1">parse</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = fastUri</span><span class="s3">\n</span><span class="s1">module.exports.default = fastUri</span><span class="s3">\n</span><span class="s1">module.exports.fastUri = fastUri</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict'</span><span class="s3">\n\n</span><span class="s1">const UUID_REG = /^[</span><span class="s3">\\</span><span class="s1">da-f]{8}-[</span><span class="s3">\\</span><span class="s1">da-f]{4}-[</span><span class="s3">\\</span><span class="s1">da-f]{4}-[</span><span class="s3">\\</span><span class="s1">da-f]{4}-[</span><span class="s3">\\</span><span class="s1">da-f]{12}$/iu</span><span class="s3">\n</span><span class="s1">const URN_REG = /([</span><span class="s3">\\</span><span class="s1">da-z][</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">-a-z]{0,31}):((?:[</span><span class="s3">\\</span><span class="s1">w!$'()*+,</span><span class="s3">\\</span><span class="s1">-.:;=@]|%[</span><span class="s3">\\</span><span class="s1">da-f]{2})+)/iu</span><span class="s3">\n\n</span><span class="s1">function isSecure (wsComponents) {</span><span class="s3">\n  </span><span class="s1">return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === 'wss'</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function httpParse (components) {</span><span class="s3">\n  </span><span class="s1">if (!components.host) {</span><span class="s3">\n    </span><span class="s1">components.error = components.error || 'HTTP URIs must have a host.'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return components</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function httpSerialize (components) {</span><span class="s3">\n  </span><span class="s1">const secure = String(components.scheme).toLowerCase() === 'https'</span><span class="s3">\n\n  </span><span class="s1">// normalize the default port</span><span class="s3">\n  </span><span class="s1">if (components.port === (secure ? 443 : 80) || components.port === '') {</span><span class="s3">\n    </span><span class="s1">components.port = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// normalize the empty path</span><span class="s3">\n  </span><span class="s1">if (!components.path) {</span><span class="s3">\n    </span><span class="s1">components.path = '/'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// NOTE: We do not parse query strings for HTTP URIs</span><span class="s3">\n  </span><span class="s1">// as WWW Form Url Encoded query strings are part of the HTML4+ spec,</span><span class="s3">\n  </span><span class="s1">// and not the HTTP spec.</span><span class="s3">\n\n  </span><span class="s1">return components</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wsParse (wsComponents) {</span><span class="s3">\n</span><span class="s1">// indicate if the secure flag is set</span><span class="s3">\n  </span><span class="s1">wsComponents.secure = isSecure(wsComponents)</span><span class="s3">\n\n  </span><span class="s1">// construct resouce name</span><span class="s3">\n  </span><span class="s1">wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '')</span><span class="s3">\n  </span><span class="s1">wsComponents.path = undefined</span><span class="s3">\n  </span><span class="s1">wsComponents.query = undefined</span><span class="s3">\n\n  </span><span class="s1">return wsComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function wsSerialize (wsComponents) {</span><span class="s3">\n</span><span class="s1">// normalize the default port</span><span class="s3">\n  </span><span class="s1">if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === '') {</span><span class="s3">\n    </span><span class="s1">wsComponents.port = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ensure scheme matches secure flag</span><span class="s3">\n  </span><span class="s1">if (typeof wsComponents.secure === 'boolean') {</span><span class="s3">\n    </span><span class="s1">wsComponents.scheme = (wsComponents.secure ? 'wss' : 'ws')</span><span class="s3">\n    </span><span class="s1">wsComponents.secure = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// reconstruct path from resource name</span><span class="s3">\n  </span><span class="s1">if (wsComponents.resourceName) {</span><span class="s3">\n    </span><span class="s1">const [path, query] = wsComponents.resourceName.split('?')</span><span class="s3">\n    </span><span class="s1">wsComponents.path = (path &amp;&amp; path !== '/' ? path : undefined)</span><span class="s3">\n    </span><span class="s1">wsComponents.query = query</span><span class="s3">\n    </span><span class="s1">wsComponents.resourceName = undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// forbid fragment component</span><span class="s3">\n  </span><span class="s1">wsComponents.fragment = undefined</span><span class="s3">\n\n  </span><span class="s1">return wsComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function urnParse (urnComponents, options) {</span><span class="s3">\n  </span><span class="s1">if (!urnComponents.path) {</span><span class="s3">\n    </span><span class="s1">urnComponents.error = 'URN can not be parsed'</span><span class="s3">\n    </span><span class="s1">return urnComponents</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const matches = urnComponents.path.match(URN_REG)</span><span class="s3">\n  </span><span class="s1">if (matches) {</span><span class="s3">\n    </span><span class="s1">const scheme = options.scheme || urnComponents.scheme || 'urn'</span><span class="s3">\n    </span><span class="s1">urnComponents.nid = matches[1].toLowerCase()</span><span class="s3">\n    </span><span class="s1">urnComponents.nss = matches[2]</span><span class="s3">\n    </span><span class="s1">const urnScheme = `${scheme}:${options.nid || urnComponents.nid}`</span><span class="s3">\n    </span><span class="s1">const schemeHandler = SCHEMES[urnScheme]</span><span class="s3">\n    </span><span class="s1">urnComponents.path = undefined</span><span class="s3">\n\n    </span><span class="s1">if (schemeHandler) {</span><span class="s3">\n      </span><span class="s1">urnComponents = schemeHandler.parse(urnComponents, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">urnComponents.error = urnComponents.error || 'URN can not be parsed.'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return urnComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function urnSerialize (urnComponents, options) {</span><span class="s3">\n  </span><span class="s1">const scheme = options.scheme || urnComponents.scheme || 'urn'</span><span class="s3">\n  </span><span class="s1">const nid = urnComponents.nid.toLowerCase()</span><span class="s3">\n  </span><span class="s1">const urnScheme = `${scheme}:${options.nid || nid}`</span><span class="s3">\n  </span><span class="s1">const schemeHandler = SCHEMES[urnScheme]</span><span class="s3">\n\n  </span><span class="s1">if (schemeHandler) {</span><span class="s3">\n    </span><span class="s1">urnComponents = schemeHandler.serialize(urnComponents, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const uriComponents = urnComponents</span><span class="s3">\n  </span><span class="s1">const nss = urnComponents.nss</span><span class="s3">\n  </span><span class="s1">uriComponents.path = `${nid || options.nid}:${nss}`</span><span class="s3">\n\n  </span><span class="s1">options.skipEscape = true</span><span class="s3">\n  </span><span class="s1">return uriComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function urnuuidParse (urnComponents, options) {</span><span class="s3">\n  </span><span class="s1">const uuidComponents = urnComponents</span><span class="s3">\n  </span><span class="s1">uuidComponents.uuid = uuidComponents.nss</span><span class="s3">\n  </span><span class="s1">uuidComponents.nss = undefined</span><span class="s3">\n\n  </span><span class="s1">if (!options.tolerant &amp;&amp; (!uuidComponents.uuid || !UUID_REG.test(uuidComponents.uuid))) {</span><span class="s3">\n    </span><span class="s1">uuidComponents.error = uuidComponents.error || 'UUID is not valid.'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return uuidComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function urnuuidSerialize (uuidComponents) {</span><span class="s3">\n  </span><span class="s1">const urnComponents = uuidComponents</span><span class="s3">\n  </span><span class="s1">// normalize UUID</span><span class="s3">\n  </span><span class="s1">urnComponents.nss = (uuidComponents.uuid || '').toLowerCase()</span><span class="s3">\n  </span><span class="s1">return urnComponents</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const http = {</span><span class="s3">\n  </span><span class="s1">scheme: 'http',</span><span class="s3">\n  </span><span class="s1">domainHost: true,</span><span class="s3">\n  </span><span class="s1">parse: httpParse,</span><span class="s3">\n  </span><span class="s1">serialize: httpSerialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const https = {</span><span class="s3">\n  </span><span class="s1">scheme: 'https',</span><span class="s3">\n  </span><span class="s1">domainHost: http.domainHost,</span><span class="s3">\n  </span><span class="s1">parse: httpParse,</span><span class="s3">\n  </span><span class="s1">serialize: httpSerialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ws = {</span><span class="s3">\n  </span><span class="s1">scheme: 'ws',</span><span class="s3">\n  </span><span class="s1">domainHost: true,</span><span class="s3">\n  </span><span class="s1">parse: wsParse,</span><span class="s3">\n  </span><span class="s1">serialize: wsSerialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const wss = {</span><span class="s3">\n  </span><span class="s1">scheme: 'wss',</span><span class="s3">\n  </span><span class="s1">domainHost: ws.domainHost,</span><span class="s3">\n  </span><span class="s1">parse: ws.parse,</span><span class="s3">\n  </span><span class="s1">serialize: ws.serialize</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const urn = {</span><span class="s3">\n  </span><span class="s1">scheme: 'urn',</span><span class="s3">\n  </span><span class="s1">parse: urnParse,</span><span class="s3">\n  </span><span class="s1">serialize: urnSerialize,</span><span class="s3">\n  </span><span class="s1">skipNormalize: true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const urnuuid = {</span><span class="s3">\n  </span><span class="s1">scheme: 'urn:uuid',</span><span class="s3">\n  </span><span class="s1">parse: urnuuidParse,</span><span class="s3">\n  </span><span class="s1">serialize: urnuuidSerialize,</span><span class="s3">\n  </span><span class="s1">skipNormalize: true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const SCHEMES = {</span><span class="s3">\n  </span><span class="s1">http,</span><span class="s3">\n  </span><span class="s1">https,</span><span class="s3">\n  </span><span class="s1">ws,</span><span class="s3">\n  </span><span class="s1">wss,</span><span class="s3">\n  </span><span class="s1">urn,</span><span class="s3">\n  </span><span class="s1">'urn:uuid': urnuuid</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = SCHEMES</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict'</span><span class="s3">\n\n</span><span class="s1">const HEX = {</span><span class="s3">\n  </span><span class="s1">0: 0,</span><span class="s3">\n  </span><span class="s1">1: 1,</span><span class="s3">\n  </span><span class="s1">2: 2,</span><span class="s3">\n  </span><span class="s1">3: 3,</span><span class="s3">\n  </span><span class="s1">4: 4,</span><span class="s3">\n  </span><span class="s1">5: 5,</span><span class="s3">\n  </span><span class="s1">6: 6,</span><span class="s3">\n  </span><span class="s1">7: 7,</span><span class="s3">\n  </span><span class="s1">8: 8,</span><span class="s3">\n  </span><span class="s1">9: 9,</span><span class="s3">\n  </span><span class="s1">a: 10,</span><span class="s3">\n  </span><span class="s1">A: 10,</span><span class="s3">\n  </span><span class="s1">b: 11,</span><span class="s3">\n  </span><span class="s1">B: 11,</span><span class="s3">\n  </span><span class="s1">c: 12,</span><span class="s3">\n  </span><span class="s1">C: 12,</span><span class="s3">\n  </span><span class="s1">d: 13,</span><span class="s3">\n  </span><span class="s1">D: 13,</span><span class="s3">\n  </span><span class="s1">e: 14,</span><span class="s3">\n  </span><span class="s1">E: 14,</span><span class="s3">\n  </span><span class="s1">f: 15,</span><span class="s3">\n  </span><span class="s1">F: 15</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">HEX</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict'</span><span class="s3">\n\n</span><span class="s1">const { HEX } = require('./scopedChars')</span><span class="s3">\n\n</span><span class="s1">const IPV4_REG = /^(?:(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d{2}|[1-9]</span><span class="s3">\\</span><span class="s1">d|</span><span class="s3">\\</span><span class="s1">d)</span><span class="s3">\\</span><span class="s1">.){3}(?:25[0-5]|2[0-4]</span><span class="s3">\\</span><span class="s1">d|1</span><span class="s3">\\</span><span class="s1">d{2}|[1-9]</span><span class="s3">\\</span><span class="s1">d|</span><span class="s3">\\</span><span class="s1">d)$/u</span><span class="s3">\n\n</span><span class="s1">function normalizeIPv4 (host) {</span><span class="s3">\n  </span><span class="s1">if (findToken(host, '.') &lt; 3) { return { host, isIPV4: false } }</span><span class="s3">\n  </span><span class="s1">const matches = host.match(IPV4_REG) || []</span><span class="s3">\n  </span><span class="s1">const [address] = matches</span><span class="s3">\n  </span><span class="s1">if (address) {</span><span class="s3">\n    </span><span class="s1">return { host: stripLeadingZeros(address, '.'), isIPV4: true }</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return { host, isIPV4: false }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {string[]} input</span><span class="s3">\n </span><span class="s1">* @param {boolean} [keepZero=false]</span><span class="s3">\n </span><span class="s1">* @returns {string|undefined}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function stringArrayToHexStripped (input, keepZero = false) {</span><span class="s3">\n  </span><span class="s1">let acc = ''</span><span class="s3">\n  </span><span class="s1">let strip = true</span><span class="s3">\n  </span><span class="s1">for (const c of input) {</span><span class="s3">\n    </span><span class="s1">if (HEX[c] === undefined) return undefined</span><span class="s3">\n    </span><span class="s1">if (c !== '0' &amp;&amp; strip === true) strip = false</span><span class="s3">\n    </span><span class="s1">if (!strip) acc += c</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (keepZero &amp;&amp; acc.length === 0) acc = '0'</span><span class="s3">\n  </span><span class="s1">return acc</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getIPV6 (input) {</span><span class="s3">\n  </span><span class="s1">let tokenCount = 0</span><span class="s3">\n  </span><span class="s1">const output = { error: false, address: '', zone: '' }</span><span class="s3">\n  </span><span class="s1">const address = []</span><span class="s3">\n  </span><span class="s1">const buffer = []</span><span class="s3">\n  </span><span class="s1">let isZone = false</span><span class="s3">\n  </span><span class="s1">let endipv6Encountered = false</span><span class="s3">\n  </span><span class="s1">let endIpv6 = false</span><span class="s3">\n\n  </span><span class="s1">function consume () {</span><span class="s3">\n    </span><span class="s1">if (buffer.length) {</span><span class="s3">\n      </span><span class="s1">if (isZone === false) {</span><span class="s3">\n        </span><span class="s1">const hex = stringArrayToHexStripped(buffer)</span><span class="s3">\n        </span><span class="s1">if (hex !== undefined) {</span><span class="s3">\n          </span><span class="s1">address.push(hex)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">output.error = true</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">buffer.length = 0</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (let i = 0; i &lt; input.length; i++) {</span><span class="s3">\n    </span><span class="s1">const cursor = input[i]</span><span class="s3">\n    </span><span class="s1">if (cursor === '[' || cursor === ']') { continue }</span><span class="s3">\n    </span><span class="s1">if (cursor === ':') {</span><span class="s3">\n      </span><span class="s1">if (endipv6Encountered === true) {</span><span class="s3">\n        </span><span class="s1">endIpv6 = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!consume()) { break }</span><span class="s3">\n      </span><span class="s1">tokenCount++</span><span class="s3">\n      </span><span class="s1">address.push(':')</span><span class="s3">\n      </span><span class="s1">if (tokenCount &gt; 7) {</span><span class="s3">\n        </span><span class="s1">// not valid</span><span class="s3">\n        </span><span class="s1">output.error = true</span><span class="s3">\n        </span><span class="s1">break</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (i - 1 &gt;= 0 &amp;&amp; input[i - 1] === ':') {</span><span class="s3">\n        </span><span class="s1">endipv6Encountered = true</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">} else if (cursor === '%') {</span><span class="s3">\n      </span><span class="s1">if (!consume()) { break }</span><span class="s3">\n      </span><span class="s1">// switch to zone detection</span><span class="s3">\n      </span><span class="s1">isZone = true</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">buffer.push(cursor)</span><span class="s3">\n      </span><span class="s1">continue</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (buffer.length) {</span><span class="s3">\n    </span><span class="s1">if (isZone) {</span><span class="s3">\n      </span><span class="s1">output.zone = buffer.join('')</span><span class="s3">\n    </span><span class="s1">} else if (endIpv6) {</span><span class="s3">\n      </span><span class="s1">address.push(buffer.join(''))</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">address.push(stringArrayToHexStripped(buffer))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">output.address = address.join('')</span><span class="s3">\n  </span><span class="s1">return output</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeIPv6 (host) {</span><span class="s3">\n  </span><span class="s1">if (findToken(host, ':') &lt; 2) { return { host, isIPV6: false } }</span><span class="s3">\n  </span><span class="s1">const ipv6 = getIPV6(host)</span><span class="s3">\n\n  </span><span class="s1">if (!ipv6.error) {</span><span class="s3">\n    </span><span class="s1">let newHost = ipv6.address</span><span class="s3">\n    </span><span class="s1">let escapedHost = ipv6.address</span><span class="s3">\n    </span><span class="s1">if (ipv6.zone) {</span><span class="s3">\n      </span><span class="s1">newHost += '%' + ipv6.zone</span><span class="s3">\n      </span><span class="s1">escapedHost += '%25' + ipv6.zone</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { host: newHost, escapedHost, isIPV6: true }</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return { host, isIPV6: false }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function stripLeadingZeros (str, token) {</span><span class="s3">\n  </span><span class="s1">let out = ''</span><span class="s3">\n  </span><span class="s1">let skip = true</span><span class="s3">\n  </span><span class="s1">const l = str.length</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; l; i++) {</span><span class="s3">\n    </span><span class="s1">const c = str[i]</span><span class="s3">\n    </span><span class="s1">if (c === '0' &amp;&amp; skip) {</span><span class="s3">\n      </span><span class="s1">if ((i + 1 &lt;= l &amp;&amp; str[i + 1] === token) || i + 1 === l) {</span><span class="s3">\n        </span><span class="s1">out += c</span><span class="s3">\n        </span><span class="s1">skip = false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (c === token) {</span><span class="s3">\n        </span><span class="s1">skip = true</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">skip = false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">out += c</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return out</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function findToken (str, token) {</span><span class="s3">\n  </span><span class="s1">let ind = 0</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; str.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (str[i] === token) ind++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return ind</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const RDS1 = /^</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">//u</span><span class="s3">\n</span><span class="s1">const RDS2 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.(?:</span><span class="s3">\\</span><span class="s1">/|$)/u</span><span class="s3">\n</span><span class="s1">const RDS3 = /^</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.(?:</span><span class="s3">\\</span><span class="s1">/|$)/u</span><span class="s3">\n</span><span class="s1">const RDS5 = /^</span><span class="s3">\\</span><span class="s1">/?(?:.|</span><span class="s3">\\</span><span class="s1">n)*?(?=</span><span class="s3">\\</span><span class="s1">/|$)/u</span><span class="s3">\n\n</span><span class="s1">function removeDotSegments (input) {</span><span class="s3">\n  </span><span class="s1">const output = []</span><span class="s3">\n\n  </span><span class="s1">while (input.length) {</span><span class="s3">\n    </span><span class="s1">if (input.match(RDS1)) {</span><span class="s3">\n      </span><span class="s1">input = input.replace(RDS1, '')</span><span class="s3">\n    </span><span class="s1">} else if (input.match(RDS2)) {</span><span class="s3">\n      </span><span class="s1">input = input.replace(RDS2, '/')</span><span class="s3">\n    </span><span class="s1">} else if (input.match(RDS3)) {</span><span class="s3">\n      </span><span class="s1">input = input.replace(RDS3, '/')</span><span class="s3">\n      </span><span class="s1">output.pop()</span><span class="s3">\n    </span><span class="s1">} else if (input === '.' || input === '..') {</span><span class="s3">\n      </span><span class="s1">input = ''</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const im = input.match(RDS5)</span><span class="s3">\n      </span><span class="s1">if (im) {</span><span class="s3">\n        </span><span class="s1">const s = im[0]</span><span class="s3">\n        </span><span class="s1">input = input.slice(s.length)</span><span class="s3">\n        </span><span class="s1">output.push(s)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpected dot segment condition')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return output.join('')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function normalizeComponentEncoding (components, esc) {</span><span class="s3">\n  </span><span class="s1">const func = esc !== true ? escape : unescape</span><span class="s3">\n  </span><span class="s1">if (components.scheme !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.scheme = func(components.scheme)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.userinfo !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.userinfo = func(components.userinfo)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.host !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.host = func(components.host)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.path !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.path = func(components.path)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.query !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.query = func(components.query)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (components.fragment !== undefined) {</span><span class="s3">\n    </span><span class="s1">components.fragment = func(components.fragment)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return components</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function recomposeAuthority (components) {</span><span class="s3">\n  </span><span class="s1">const uriTokens = []</span><span class="s3">\n\n  </span><span class="s1">if (components.userinfo !== undefined) {</span><span class="s3">\n    </span><span class="s1">uriTokens.push(components.userinfo)</span><span class="s3">\n    </span><span class="s1">uriTokens.push('@')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (components.host !== undefined) {</span><span class="s3">\n    </span><span class="s1">let host = unescape(components.host)</span><span class="s3">\n    </span><span class="s1">const ipV4res = normalizeIPv4(host)</span><span class="s3">\n\n    </span><span class="s1">if (ipV4res.isIPV4) {</span><span class="s3">\n      </span><span class="s1">host = ipV4res.host</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const ipV6res = normalizeIPv6(ipV4res.host)</span><span class="s3">\n      </span><span class="s1">if (ipV6res.isIPV6 === true) {</span><span class="s3">\n        </span><span class="s1">host = `[${ipV6res.escapedHost}]`</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">host = components.host</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">uriTokens.push(host)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (typeof components.port === 'number' || typeof components.port === 'string') {</span><span class="s3">\n    </span><span class="s1">uriTokens.push(':')</span><span class="s3">\n    </span><span class="s1">uriTokens.push(String(components.port))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return uriTokens.length ? uriTokens.join('') : undefined</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">recomposeAuthority,</span><span class="s3">\n  </span><span class="s1">normalizeComponentEncoding,</span><span class="s3">\n  </span><span class="s1">removeDotSegments,</span><span class="s3">\n  </span><span class="s1">normalizeIPv4,</span><span class="s3">\n  </span><span class="s1">normalizeIPv6,</span><span class="s3">\n  </span><span class="s1">stringArrayToHexStripped</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">var traverse = module.exports = function (schema, opts, cb) {</span><span class="s3">\n  </span><span class="s1">// Legacy support for v0.3.1 and earlier.</span><span class="s3">\n  </span><span class="s1">if (typeof opts == 'function') {</span><span class="s3">\n    </span><span class="s1">cb = opts;</span><span class="s3">\n    </span><span class="s1">opts = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">cb = opts.cb || cb;</span><span class="s3">\n  </span><span class="s1">var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};</span><span class="s3">\n  </span><span class="s1">var post = cb.post || function() {};</span><span class="s3">\n\n  </span><span class="s1">_traverse(opts, pre, post, schema, '', schema);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">traverse.keywords = {</span><span class="s3">\n  </span><span class="s1">additionalItems: true,</span><span class="s3">\n  </span><span class="s1">items: true,</span><span class="s3">\n  </span><span class="s1">contains: true,</span><span class="s3">\n  </span><span class="s1">additionalProperties: true,</span><span class="s3">\n  </span><span class="s1">propertyNames: true,</span><span class="s3">\n  </span><span class="s1">not: true,</span><span class="s3">\n  </span><span class="s1">if: true,</span><span class="s3">\n  </span><span class="s1">then: true,</span><span class="s3">\n  </span><span class="s1">else: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">traverse.arrayKeywords = {</span><span class="s3">\n  </span><span class="s1">items: true,</span><span class="s3">\n  </span><span class="s1">allOf: true,</span><span class="s3">\n  </span><span class="s1">anyOf: true,</span><span class="s3">\n  </span><span class="s1">oneOf: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">traverse.propsKeywords = {</span><span class="s3">\n  </span><span class="s1">$defs: true,</span><span class="s3">\n  </span><span class="s1">definitions: true,</span><span class="s3">\n  </span><span class="s1">properties: true,</span><span class="s3">\n  </span><span class="s1">patternProperties: true,</span><span class="s3">\n  </span><span class="s1">dependencies: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">traverse.skipKeywords = {</span><span class="s3">\n  </span><span class="s1">default: true,</span><span class="s3">\n  </span><span class="s1">enum: true,</span><span class="s3">\n  </span><span class="s1">const: true,</span><span class="s3">\n  </span><span class="s1">required: true,</span><span class="s3">\n  </span><span class="s1">maximum: true,</span><span class="s3">\n  </span><span class="s1">minimum: true,</span><span class="s3">\n  </span><span class="s1">exclusiveMaximum: true,</span><span class="s3">\n  </span><span class="s1">exclusiveMinimum: true,</span><span class="s3">\n  </span><span class="s1">multipleOf: true,</span><span class="s3">\n  </span><span class="s1">maxLength: true,</span><span class="s3">\n  </span><span class="s1">minLength: true,</span><span class="s3">\n  </span><span class="s1">pattern: true,</span><span class="s3">\n  </span><span class="s1">format: true,</span><span class="s3">\n  </span><span class="s1">maxItems: true,</span><span class="s3">\n  </span><span class="s1">minItems: true,</span><span class="s3">\n  </span><span class="s1">uniqueItems: true,</span><span class="s3">\n  </span><span class="s1">maxProperties: true,</span><span class="s3">\n  </span><span class="s1">minProperties: true</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n\n</span><span class="s1">function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {</span><span class="s3">\n  </span><span class="s1">if (schema &amp;&amp; typeof schema == 'object' &amp;&amp; !Array.isArray(schema)) {</span><span class="s3">\n    </span><span class="s1">pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);</span><span class="s3">\n    </span><span class="s1">for (var key in schema) {</span><span class="s3">\n      </span><span class="s1">var sch = schema[key];</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(sch)) {</span><span class="s3">\n        </span><span class="s1">if (key in traverse.arrayKeywords) {</span><span class="s3">\n          </span><span class="s1">for (var i=0; i&lt;sch.length; i++)</span><span class="s3">\n            </span><span class="s1">_traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (key in traverse.propsKeywords) {</span><span class="s3">\n        </span><span class="s1">if (sch &amp;&amp; typeof sch == 'object') {</span><span class="s3">\n          </span><span class="s1">for (var prop in sch)</span><span class="s3">\n            </span><span class="s1">_traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (key in traverse.keywords || (opts.allKeys &amp;&amp; !(key in traverse.skipKeywords))) {</span><span class="s3">\n        </span><span class="s1">_traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">function escapeJsonPtr(str) {</span><span class="s3">\n  </span><span class="s1">return str.replace(/~/g, '~0').replace(/</span><span class="s3">\\</span><span class="s1">//g, '~1');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>