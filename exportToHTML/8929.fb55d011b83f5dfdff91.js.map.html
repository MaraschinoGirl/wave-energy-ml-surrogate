<html>
<head>
<title>8929.fb55d011b83f5dfdff91.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
8929.fb55d011b83f5dfdff91.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;8929.fb55d011b83f5dfdff91.js?v=fb55d011b83f5dfdff91&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAsE;AACjB;AACb;AACW;AACR;AACqB;AACI;AAChB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mEAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,wDAAwD;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,UAAU;AAC5C,sCAAsC,UAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,sDAAQ;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,OAAO;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAI;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gDAAgD;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAI;AAC/B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAI;AAC/B;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kDAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gDAAgD;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAiD;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,gBAAgB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,eAAe;AAC5E;AACA;AACA;AACA;AACA;AACA,0DAA0D,eAAe;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,SAAS;AAChE;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,qDAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,IAAI;AACxG;AACA;AACA,4EAA4E,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,EAAE,aAAa,GAAG;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA,uCAAuC,mBAAmB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,EAAE,GAAG,EAAE,GAAG,EAAE;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iCAAiC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mEAAiB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mDAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iCAAiC;AACrD;AACA;AACA,yBAAyB,mDAAM;AAC/B;AACA;AACA;AACA,YAAY,mDAAM;AAClB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,yEAAyE;AAC9E,CAAC,gCAAgC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,IAAI,GAAG,yBAAyB;AAC1D;AACA;AACA,2BAA2B,IAAI,GAAG,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qDAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B,qDAAM;AAClC,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,yBAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAQ,6BAA6B,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAQ,6BAA6B,qBAAqB;AACtE;AACA;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uDAAQ;AACxB;AACA,gBAAgB,uDAAQ;AACxB;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,OAAO;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uDAAQ;AACzB;AACA;AACA,YAAY,uDAAQ;AACpB;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,mDAAM;AACnC;AACA;AACA,+BAA+B,sDAAS,GAAG,yBAAyB;AACpE,+BAA+B,sDAAS,GAAG,2BAA2B;AACtE,iCAAiC,mDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,uDAAU,iCAAiC,mBAAmB;AACtE,QAAQ,uDAAU,mCAAmC,mBAAmB;AACxE,QAAQ,uDAAU,mCAAmC,mBAAmB;AACxE,QAAQ,uDAAU,qCAAqC,mBAAmB;AAC1E;AACA,yBAAyB,uDAAU;AACnC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAY;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wDAAU;AACtC,4BAA4B,wDAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oCAAoC;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA,2CAA2C,sBAAsB;AACjE;AACA;AACA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA,4CAA4C,sBAAsB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0DAAW,mBAAmB,mDAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,0DAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2CAA2C;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sDAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,oCAAoC;AAC1E,uCAAuC,qCAAqC;AAC5E;AACA,uCAAuC,qCAAqC;AAC5E,wCAAwC,sCAAsC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,aAAa;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,OAAO;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8FAA8F,oCAAoC;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,SAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F,0DAA0D;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAkB;AAClD;AACA;AACA;AACA,sCAAsC,iEAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iEAAkB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0BAA0B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8DAAe;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsiB;AACtiB&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/datagrid/dist/index.es6.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Platform, ClipboardExt, ElementExt } from '@lumino/domutils';</span><span class="s3">\n</span><span class="s1">import { getKeyboardLayout } from '@lumino/keyboard';</span><span class="s3">\n</span><span class="s1">import { Drag } from '@lumino/dragdrop';</span><span class="s3">\n</span><span class="s1">import { some, ArrayExt } from '@lumino/algorithm';</span><span class="s3">\n</span><span class="s1">import { Signal } from '@lumino/signaling';</span><span class="s3">\n</span><span class="s1">import { Widget, ScrollBar, GridLayout } from '@lumino/widgets';</span><span class="s3">\n</span><span class="s1">import { ConflatableMessage, MessageLoop } from '@lumino/messaging';</span><span class="s3">\n</span><span class="s1">import { PromiseDelegate } from '@lumino/coreutils';</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A basic implementation of a data grid key handler.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This class may be subclassed and customized as needed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BasicKeyHandler {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this._disposed = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the key handler is disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by the key handler.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">this._disposed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the key down event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keydown event of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This will not be called if the mouse button is pressed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onKeyDown(grid, event) {</span><span class="s3">\n        </span><span class="s1">// if grid is editable and cell selection available, start cell editing</span><span class="s3">\n        </span><span class="s1">// on key press (letters, numbers and space only)</span><span class="s3">\n        </span><span class="s1">if (grid.editable &amp;&amp;</span><span class="s3">\n            </span><span class="s1">grid.selectionModel.cursorRow !== -1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">grid.selectionModel.cursorColumn !== -1) {</span><span class="s3">\n            </span><span class="s1">const input = String.fromCharCode(event.keyCode);</span><span class="s3">\n            </span><span class="s1">if (/[a-zA-Z0-9-_ ]/.test(input)) {</span><span class="s3">\n                </span><span class="s1">const row = grid.selectionModel.cursorRow;</span><span class="s3">\n                </span><span class="s1">const column = grid.selectionModel.cursorColumn;</span><span class="s3">\n                </span><span class="s1">const cell = {</span><span class="s3">\n                    </span><span class="s1">grid: grid,</span><span class="s3">\n                    </span><span class="s1">row: row,</span><span class="s3">\n                    </span><span class="s1">column: column</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">grid.editorController.edit(cell);</span><span class="s3">\n                </span><span class="s1">if (getKeyboardLayout().keyForKeydownEvent(event) === 'Space') {</span><span class="s3">\n                    </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'ArrowLeft':</span><span class="s3">\n                </span><span class="s1">this.onArrowLeft(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'ArrowRight':</span><span class="s3">\n                </span><span class="s1">this.onArrowRight(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'ArrowUp':</span><span class="s3">\n                </span><span class="s1">this.onArrowUp(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'ArrowDown':</span><span class="s3">\n                </span><span class="s1">this.onArrowDown(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'PageUp':</span><span class="s3">\n                </span><span class="s1">this.onPageUp(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'PageDown':</span><span class="s3">\n                </span><span class="s1">this.onPageDown(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.onEscape(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Delete':</span><span class="s3">\n                </span><span class="s1">this.onDelete(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'C':</span><span class="s3">\n                </span><span class="s1">this.onKeyC(grid, event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">if (grid.selectionModel) {</span><span class="s3">\n                    </span><span class="s1">grid.moveCursor(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                    </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">if (grid.selectionModel) {</span><span class="s3">\n                    </span><span class="s1">grid.moveCursor(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                    </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n                    </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'ArrowLeft'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onArrowLeft(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Fetch the modifier flags.</span><span class="s3">\n        </span><span class="s1">let shift = event.shiftKey;</span><span class="s3">\n        </span><span class="s1">let accel = Platform.accelKey(event);</span><span class="s3">\n        </span><span class="s1">// Handle no model with the accel modifier.</span><span class="s3">\n        </span><span class="s1">if (!model &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(0, grid.scrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle no model and no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('left');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Handle the row selection mode with accel key.</span><span class="s3">\n        </span><span class="s1">if (mode === 'row' &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(0, grid.scrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the row selection mode with no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (mode === 'row') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('left');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Dispatch based on the modifier keys.</span><span class="s3">\n        </span><span class="s1">if (accel &amp;&amp; shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 - 1 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (accel) {</span><span class="s3">\n            </span><span class="s1">r1 = r;</span><span class="s3">\n            </span><span class="s1">r2 = r;</span><span class="s3">\n            </span><span class="s1">c1 = 0;</span><span class="s3">\n            </span><span class="s1">c2 = 0;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = r;</span><span class="s3">\n            </span><span class="s1">r2 = r;</span><span class="s3">\n            </span><span class="s1">c1 = c - 1;</span><span class="s3">\n            </span><span class="s1">c2 = c - 1;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">if (shift || mode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToColumn(cs.c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'ArrowRight'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onArrowRight(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Fetch the modifier flags.</span><span class="s3">\n        </span><span class="s1">let shift = event.shiftKey;</span><span class="s3">\n        </span><span class="s1">let accel = Platform.accelKey(event);</span><span class="s3">\n        </span><span class="s1">// Handle no model with the accel modifier.</span><span class="s3">\n        </span><span class="s1">if (!model &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.maxScrollX, grid.scrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle no model and no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('right');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Handle the row selection model with accel key.</span><span class="s3">\n        </span><span class="s1">if (mode === 'row' &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.maxScrollX, grid.scrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the row selection mode with no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (mode === 'row') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('right');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Dispatch based on the modifier keys.</span><span class="s3">\n        </span><span class="s1">if (accel &amp;&amp; shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = Infinity;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 + 1 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (accel) {</span><span class="s3">\n            </span><span class="s1">r1 = r;</span><span class="s3">\n            </span><span class="s1">r2 = r;</span><span class="s3">\n            </span><span class="s1">c1 = Infinity;</span><span class="s3">\n            </span><span class="s1">c2 = Infinity;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = r;</span><span class="s3">\n            </span><span class="s1">r2 = r;</span><span class="s3">\n            </span><span class="s1">c1 = c + 1;</span><span class="s3">\n            </span><span class="s1">c2 = c + 1;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">if (shift || mode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToColumn(cs.c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'ArrowUp'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onArrowUp(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Fetch the modifier flags.</span><span class="s3">\n        </span><span class="s1">let shift = event.shiftKey;</span><span class="s3">\n        </span><span class="s1">let accel = Platform.accelKey(event);</span><span class="s3">\n        </span><span class="s1">// Handle no model with the accel modifier.</span><span class="s3">\n        </span><span class="s1">if (!model &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.scrollX, 0);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle no model and no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('up');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Handle the column selection mode with accel key.</span><span class="s3">\n        </span><span class="s1">if (mode === 'column' &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.scrollX, 0);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the column selection mode with no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (mode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('up');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Dispatch based on the modifier keys.</span><span class="s3">\n        </span><span class="s1">if (accel &amp;&amp; shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 - 1 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (accel) {</span><span class="s3">\n            </span><span class="s1">r1 = 0;</span><span class="s3">\n            </span><span class="s1">r2 = 0;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = r - 1;</span><span class="s3">\n            </span><span class="s1">r2 = r - 1;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">if (shift || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToRow(cs.r2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'ArrowDown'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onArrowDown(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Fetch the modifier flags.</span><span class="s3">\n        </span><span class="s1">let shift = event.shiftKey;</span><span class="s3">\n        </span><span class="s1">let accel = Platform.accelKey(event);</span><span class="s3">\n        </span><span class="s1">// Handle no model with the accel modifier.</span><span class="s3">\n        </span><span class="s1">if (!model &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.scrollX, grid.maxScrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle no model and no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('down');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Handle the column selection mode with accel key.</span><span class="s3">\n        </span><span class="s1">if (mode === 'column' &amp;&amp; accel) {</span><span class="s3">\n            </span><span class="s1">grid.scrollTo(grid.scrollX, grid.maxScrollY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the column selection mode with no modifier. (ignore shift)</span><span class="s3">\n        </span><span class="s1">if (mode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByStep('down');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Dispatch based on the modifier keys.</span><span class="s3">\n        </span><span class="s1">if (accel &amp;&amp; shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = Infinity;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (shift) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 + 1 : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (accel) {</span><span class="s3">\n            </span><span class="s1">r1 = Infinity;</span><span class="s3">\n            </span><span class="s1">r2 = Infinity;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = r + 1;</span><span class="s3">\n            </span><span class="s1">r2 = r + 1;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">if (shift || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToRow(cs.r2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'PageUp'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onPageUp(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Ignore the event if the accel key is pressed.</span><span class="s3">\n        </span><span class="s1">if (Platform.accelKey(event)) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Scroll by page if there is no selection model.</span><span class="s3">\n        </span><span class="s1">if (!model || model.selectionMode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByPage('up');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the normal number of cells in the page height.</span><span class="s3">\n        </span><span class="s1">let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Select or resize as needed.</span><span class="s3">\n        </span><span class="s1">if (event.shiftKey) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 - n : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 - n : 0;</span><span class="s3">\n            </span><span class="s1">r2 = r1;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">grid.scrollToRow(cs.r2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'PageDown'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onPageDown(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Ignore the event if the accel key is pressed.</span><span class="s3">\n        </span><span class="s1">if (Platform.accelKey(event)) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Scroll by page if there is no selection model.</span><span class="s3">\n        </span><span class="s1">if (!model || model.selectionMode === 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollByPage('down');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the normal number of cells in the page height.</span><span class="s3">\n        </span><span class="s1">let n = Math.floor(grid.pageHeight / grid.defaultSizes.rowHeight);</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor and selection.</span><span class="s3">\n        </span><span class="s1">let r = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let c = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cr;</span><span class="s3">\n        </span><span class="s1">let cc;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Select or resize as needed.</span><span class="s3">\n        </span><span class="s1">if (event.shiftKey) {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 : 0;</span><span class="s3">\n            </span><span class="s1">r2 = cs ? cs.r2 + n : 0;</span><span class="s3">\n            </span><span class="s1">c1 = cs ? cs.c1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 = cs ? cs.c2 : 0;</span><span class="s3">\n            </span><span class="s1">cr = r;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'current';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = cs ? cs.r1 + n : 0;</span><span class="s3">\n            </span><span class="s1">r2 = r1;</span><span class="s3">\n            </span><span class="s1">c1 = c;</span><span class="s3">\n            </span><span class="s1">c2 = c;</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n            </span><span class="s1">cc = c;</span><span class="s3">\n            </span><span class="s1">clear = 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the new selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow: cr, cursorColumn: cc, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid appropriately.</span><span class="s3">\n        </span><span class="s1">grid.scrollToRow(cs.r2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'Escape'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onEscape(grid, event) {</span><span class="s3">\n        </span><span class="s1">if (grid.selectionModel) {</span><span class="s3">\n            </span><span class="s1">grid.selectionModel.clear();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'Delete'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onDelete(grid, event) {</span><span class="s3">\n        </span><span class="s1">if (grid.editable &amp;&amp; !grid.selectionModel.isEmpty) {</span><span class="s3">\n            </span><span class="s1">const dataModel = grid.dataModel;</span><span class="s3">\n            </span><span class="s1">// Fetch the max row and column.</span><span class="s3">\n            </span><span class="s1">let maxRow = dataModel.rowCount('body') - 1;</span><span class="s3">\n            </span><span class="s1">let maxColumn = dataModel.columnCount('body') - 1;</span><span class="s3">\n            </span><span class="s1">for (let s of grid.selectionModel.selections()) {</span><span class="s3">\n                </span><span class="s1">// Clamp the cell to the model bounds.</span><span class="s3">\n                </span><span class="s1">let sr1 = Math.max(0, Math.min(s.r1, maxRow));</span><span class="s3">\n                </span><span class="s1">let sc1 = Math.max(0, Math.min(s.c1, maxColumn));</span><span class="s3">\n                </span><span class="s1">let sr2 = Math.max(0, Math.min(s.r2, maxRow));</span><span class="s3">\n                </span><span class="s1">let sc2 = Math.max(0, Math.min(s.c2, maxColumn));</span><span class="s3">\n                </span><span class="s1">for (let r = sr1; r &lt;= sr2; ++r) {</span><span class="s3">\n                    </span><span class="s1">for (let c = sc1; c &lt;= sc2; ++c) {</span><span class="s3">\n                        </span><span class="s1">dataModel.setData('body', r, c, null);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'C'` key press for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The keyboard event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onKeyC(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the modifiers aren't correct for copy.</span><span class="s3">\n        </span><span class="s1">if (event.shiftKey || !Platform.accelKey(event)) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Copy the current selection to the clipboard.</span><span class="s3">\n        </span><span class="s1">grid.copyToClipboard();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which renders the cells of a data grid.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* If the predefined cell renderers are insufficient for a particular</span><span class="s3">\n </span><span class="s1">* use case, a custom cell renderer can be defined which derives from</span><span class="s3">\n </span><span class="s1">* this class.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The data grid renders cells in column-major order, by region. The</span><span class="s3">\n </span><span class="s1">* region order is: body, row header, column header, corner header.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class CellRenderer {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the `CellRenderer` class statics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">(function (CellRenderer) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resolve a config option for a cell renderer.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param option - The config option to resolve.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The cell config object.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The resolved value for the option.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function resolveOption(option, config) {</span><span class="s3">\n        </span><span class="s1">return typeof option === 'function'</span><span class="s3">\n            </span><span class="s1">? option(config)</span><span class="s3">\n            </span><span class="s1">: option;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellRenderer.resolveOption = resolveOption;</span><span class="s3">\n</span><span class="s1">})(CellRenderer || (CellRenderer = {}));</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cell renderer which renders data values as text.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TextRenderer extends CellRenderer {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new text renderer.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the renderer.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options = {}) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.font = options.font || '12px sans-serif';</span><span class="s3">\n        </span><span class="s1">this.textColor = options.textColor || '#000000';</span><span class="s3">\n        </span><span class="s1">this.backgroundColor = options.backgroundColor || '';</span><span class="s3">\n        </span><span class="s1">this.verticalAlignment = options.verticalAlignment || 'center';</span><span class="s3">\n        </span><span class="s1">this.horizontalAlignment = options.horizontalAlignment || 'left';</span><span class="s3">\n        </span><span class="s1">this.horizontalPadding = options.horizontalPadding || 8;</span><span class="s3">\n        </span><span class="s1">this.format = options.format || TextRenderer.formatGeneric();</span><span class="s3">\n        </span><span class="s1">this.elideDirection = options.elideDirection || 'none';</span><span class="s3">\n        </span><span class="s1">this.wrapText = options.wrapText || false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint the content for a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">paint(gc, config) {</span><span class="s3">\n        </span><span class="s1">this.drawBackground(gc, config);</span><span class="s3">\n        </span><span class="s1">this.drawText(gc, config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the background for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawBackground(gc, config) {</span><span class="s3">\n        </span><span class="s1">// Resolve the background color for the cell.</span><span class="s3">\n        </span><span class="s1">let color = CellRenderer.resolveOption(this.backgroundColor, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no background color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fill the cell with the background color.</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">gc.fillRect(config.x, config.y, config.width, config.height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the full text to be rendered by the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getText(config) {</span><span class="s3">\n        </span><span class="s1">return this.format(config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the text for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawText(gc, config) {</span><span class="s3">\n        </span><span class="s1">// Resolve the font for the cell.</span><span class="s3">\n        </span><span class="s1">let font = CellRenderer.resolveOption(this.font, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no font to draw.</span><span class="s3">\n        </span><span class="s1">if (!font) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resolve the text color for the cell.</span><span class="s3">\n        </span><span class="s1">let color = CellRenderer.resolveOption(this.textColor, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no text color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Format the cell value to text.</span><span class="s3">\n        </span><span class="s1">let text = this.getText(config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no text to draw.</span><span class="s3">\n        </span><span class="s1">if (!text) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resolve the vertical and horizontal alignment.</span><span class="s3">\n        </span><span class="s1">let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);</span><span class="s3">\n        </span><span class="s1">let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);</span><span class="s3">\n        </span><span class="s1">// Resolve the elision direction</span><span class="s3">\n        </span><span class="s1">let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);</span><span class="s3">\n        </span><span class="s1">// Resolve the text wrapping flag</span><span class="s3">\n        </span><span class="s1">let wrapText = CellRenderer.resolveOption(this.wrapText, config);</span><span class="s3">\n        </span><span class="s1">// Compute the padded text box height for the specified alignment.</span><span class="s3">\n        </span><span class="s1">let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);</span><span class="s3">\n        </span><span class="s1">// Bail if the text box has no effective size.</span><span class="s3">\n        </span><span class="s1">if (boxHeight &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the text height for the gc font.</span><span class="s3">\n        </span><span class="s1">let textHeight = TextRenderer.measureFontHeight(font);</span><span class="s3">\n        </span><span class="s1">// Set up the text position variables.</span><span class="s3">\n        </span><span class="s1">let textX;</span><span class="s3">\n        </span><span class="s1">let textY;</span><span class="s3">\n        </span><span class="s1">let boxWidth;</span><span class="s3">\n        </span><span class="s1">// Compute the Y position for the text.</span><span class="s3">\n        </span><span class="s1">switch (vAlign) {</span><span class="s3">\n            </span><span class="s1">case 'top':</span><span class="s3">\n                </span><span class="s1">textY = config.y + 2 + textHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'center':</span><span class="s3">\n                </span><span class="s1">textY = config.y + config.height / 2 + textHeight / 2;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'bottom':</span><span class="s3">\n                </span><span class="s1">textY = config.y + config.height - 2;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the X position for the text.</span><span class="s3">\n        </span><span class="s1">switch (hAlign) {</span><span class="s3">\n            </span><span class="s1">case 'left':</span><span class="s3">\n                </span><span class="s1">textX = config.x + this.horizontalPadding;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width - 14;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'center':</span><span class="s3">\n                </span><span class="s1">textX = config.x + config.width / 2;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'right':</span><span class="s3">\n                </span><span class="s1">textX = config.x + config.width - this.horizontalPadding;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width - 14;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clip the cell if the text is taller than the text box height.</span><span class="s3">\n        </span><span class="s1">if (textHeight &gt; boxHeight) {</span><span class="s3">\n            </span><span class="s1">gc.beginPath();</span><span class="s3">\n            </span><span class="s1">gc.rect(config.x, config.y, config.width, config.height - 1);</span><span class="s3">\n            </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set the gc state.</span><span class="s3">\n        </span><span class="s1">gc.font = font;</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">gc.textAlign = hAlign;</span><span class="s3">\n        </span><span class="s1">gc.textBaseline = 'bottom';</span><span class="s3">\n        </span><span class="s1">// Terminate call here if we're not eliding or wrapping text</span><span class="s3">\n        </span><span class="s1">if (elideDirection === 'none' &amp;&amp; !wrapText) {</span><span class="s3">\n            </span><span class="s1">gc.fillText(text, textX, textY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The current text width in pixels.</span><span class="s3">\n        </span><span class="s1">let textWidth = gc.measureText(text).width;</span><span class="s3">\n        </span><span class="s1">// Apply text wrapping if enabled.</span><span class="s3">\n        </span><span class="s1">if (wrapText &amp;&amp; textWidth &gt; boxWidth) {</span><span class="s3">\n            </span><span class="s1">// Make sure box clipping happens.</span><span class="s3">\n            </span><span class="s1">gc.beginPath();</span><span class="s3">\n            </span><span class="s1">gc.rect(config.x, config.y, config.width, config.height - 1);</span><span class="s3">\n            </span><span class="s1">gc.clip();</span><span class="s3">\n            </span><span class="s1">// Split column name to words based on</span><span class="s3">\n            </span><span class="s1">// whitespace preceding a word boundary.</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Hello  world</span><span class="s3">\&quot; </span><span class="s1">--&gt; [</span><span class="s3">\&quot;</span><span class="s1">Hello  </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">world</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n            </span><span class="s1">const wordsInColumn = text.split(/</span><span class="s3">\\</span><span class="s1">s(?=</span><span class="s3">\\</span><span class="s1">b)/);</span><span class="s3">\n            </span><span class="s1">// Y-coordinate offset for any additional lines</span><span class="s3">\n            </span><span class="s1">let curY = textY;</span><span class="s3">\n            </span><span class="s1">let textInCurrentLine = wordsInColumn.shift();</span><span class="s3">\n            </span><span class="s1">// Single word. Applying text wrap on word by splitting</span><span class="s3">\n            </span><span class="s1">// it into characters and fitting the maximum number of</span><span class="s3">\n            </span><span class="s1">// characters possible per line (box width).</span><span class="s3">\n            </span><span class="s1">if (wordsInColumn.length === 0) {</span><span class="s3">\n                </span><span class="s1">let curLineTextWidth = gc.measureText(textInCurrentLine).width;</span><span class="s3">\n                </span><span class="s1">while (curLineTextWidth &gt; boxWidth &amp;&amp; textInCurrentLine !== '') {</span><span class="s3">\n                    </span><span class="s1">// Iterating from the end of the string until we find a</span><span class="s3">\n                    </span><span class="s1">// substring (0,i) which has a width less than the box width.</span><span class="s3">\n                    </span><span class="s1">for (let i = textInCurrentLine.length; i &gt; 0; i--) {</span><span class="s3">\n                        </span><span class="s1">const curSubString = textInCurrentLine.substring(0, i);</span><span class="s3">\n                        </span><span class="s1">const curSubStringWidth = gc.measureText(curSubString).width;</span><span class="s3">\n                        </span><span class="s1">if (curSubStringWidth &lt; boxWidth || curSubString.length === 1) {</span><span class="s3">\n                            </span><span class="s1">// Found a substring which has a width less than the current</span><span class="s3">\n                            </span><span class="s1">// box width. Rendering that substring on the current line</span><span class="s3">\n                            </span><span class="s1">// and setting the remainder of the parent string as the next</span><span class="s3">\n                            </span><span class="s1">// string to iterate on for the next line.</span><span class="s3">\n                            </span><span class="s1">const nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);</span><span class="s3">\n                            </span><span class="s1">textInCurrentLine = nextLineText;</span><span class="s3">\n                            </span><span class="s1">curLineTextWidth = gc.measureText(textInCurrentLine).width;</span><span class="s3">\n                            </span><span class="s1">gc.fillText(curSubString, textX, curY);</span><span class="s3">\n                            </span><span class="s1">curY += textHeight;</span><span class="s3">\n                            </span><span class="s1">// No need to continue iterating after we identified</span><span class="s3">\n                            </span><span class="s1">// an index to break the string on.</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Multiple words in column header. Fitting maximum</span><span class="s3">\n            </span><span class="s1">// number of words possible per line (box width).</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">while (wordsInColumn.length !== 0) {</span><span class="s3">\n                    </span><span class="s1">// Processing the next word in the queue.</span><span class="s3">\n                    </span><span class="s1">const curWord = wordsInColumn.shift();</span><span class="s3">\n                    </span><span class="s1">// Joining that word with the existing text for</span><span class="s3">\n                    </span><span class="s1">// the current line.</span><span class="s3">\n                    </span><span class="s1">const incrementedText = [textInCurrentLine, curWord].join(' ');</span><span class="s3">\n                    </span><span class="s1">const incrementedTextWidth = gc.measureText(incrementedText).width;</span><span class="s3">\n                    </span><span class="s1">if (incrementedTextWidth &gt; boxWidth) {</span><span class="s3">\n                        </span><span class="s1">// If the newly combined text has a width larger than</span><span class="s3">\n                        </span><span class="s1">// the box width, we render the line before the current</span><span class="s3">\n                        </span><span class="s1">// word was added. We set the current word as the next</span><span class="s3">\n                        </span><span class="s1">// line.</span><span class="s3">\n                        </span><span class="s1">gc.fillText(textInCurrentLine, textX, curY);</span><span class="s3">\n                        </span><span class="s1">curY += textHeight;</span><span class="s3">\n                        </span><span class="s1">textInCurrentLine = curWord;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// The combined text hasd a width less than the box width. We</span><span class="s3">\n                        </span><span class="s1">// set the the current line text to be the new combined text.</span><span class="s3">\n                        </span><span class="s1">textInCurrentLine = incrementedText;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">gc.fillText(textInCurrentLine, textX, curY);</span><span class="s3">\n            </span><span class="s1">// Terminating the call here as we don't want</span><span class="s3">\n            </span><span class="s1">// to apply text eliding when wrapping is active.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Elide text that is too long</span><span class="s3">\n        </span><span class="s1">const elide = '</span><span class="s3">\\</span><span class="s1">u2026';</span><span class="s3">\n        </span><span class="s1">// Loop until text width fits box or only one character remains</span><span class="s3">\n        </span><span class="s1">while (textWidth &gt; boxWidth &amp;&amp; text.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">// Convert text string to array for dealing with astral symbols</span><span class="s3">\n            </span><span class="s1">const textArr = [...text];</span><span class="s3">\n            </span><span class="s1">if (elideDirection === 'right') {</span><span class="s3">\n                </span><span class="s1">// If text width is substantially bigger, take half the string</span><span class="s3">\n                </span><span class="s1">if (textArr.length &gt; 4 &amp;&amp; textWidth &gt;= 2 * boxWidth) {</span><span class="s3">\n                    </span><span class="s1">text =</span><span class="s3">\n                        </span><span class="s1">textArr.slice(0, Math.floor(textArr.length / 2 + 1)).join('') +</span><span class="s3">\n                            </span><span class="s1">elide;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Otherwise incrementally remove the last character</span><span class="s3">\n                    </span><span class="s1">text = textArr.slice(0, textArr.length - 2).join('') + elide;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// If text width is substantially bigger, take half the string</span><span class="s3">\n                </span><span class="s1">if (textArr.length &gt; 4 &amp;&amp; textWidth &gt;= 2 * boxWidth) {</span><span class="s3">\n                    </span><span class="s1">text = elide + textArr.slice(Math.floor(textArr.length / 2)).join('');</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Otherwise incrementally remove the last character</span><span class="s3">\n                    </span><span class="s1">text = elide + textArr.slice(2).join('');</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Measure new text width</span><span class="s3">\n            </span><span class="s1">textWidth = gc.measureText(text).width;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the text for the cell.</span><span class="s3">\n        </span><span class="s1">gc.fillText(text, textX, textY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the `TextRenderer` class statics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">(function (TextRenderer) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a generic text format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new generic text format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `String()` to coerce any value</span><span class="s3">\n     </span><span class="s1">* to a string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatGeneric(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return String(value);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatGeneric = formatGeneric;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a fixed decimal format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new fixed decimal format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `Number()` and `toFixed()` to</span><span class="s3">\n     </span><span class="s1">* coerce values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlNumber()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatFixed(options = {}) {</span><span class="s3">\n        </span><span class="s1">let digits = options.digits;</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return Number(value).toFixed(digits);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatFixed = formatFixed;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a significant figure format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new significant figure format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `Number()` and `toPrecision()`</span><span class="s3">\n     </span><span class="s1">* to coerce values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlNumber()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatPrecision(options = {}) {</span><span class="s3">\n        </span><span class="s1">let digits = options.digits;</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return Number(value).toPrecision(digits);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatPrecision = formatPrecision;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a scientific notation format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new scientific notation format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `Number()` and `toExponential()`</span><span class="s3">\n     </span><span class="s1">* to coerce values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlNumber()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatExponential(options = {}) {</span><span class="s3">\n        </span><span class="s1">let digits = options.digits;</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return Number(value).toExponential(digits);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatExponential = formatExponential;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create an international number format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new international number format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `Intl.NumberFormat` object to</span><span class="s3">\n     </span><span class="s1">* coerce values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is the most flexible (but slowest) number formatter.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatIntlNumber(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">let nft = new Intl.NumberFormat(options.locales, options.options);</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return nft.format(value);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatIntlNumber = formatIntlNumber;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a date format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new date format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses `Date.toDateString()` to format the values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If a value is not a `Date` object, `new Date(value)` is used to</span><span class="s3">\n     </span><span class="s1">* coerce the value to a date.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlDateTime()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatDate(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (value instanceof Date) {</span><span class="s3">\n                </span><span class="s1">return value.toDateString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new Date(value).toDateString();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatDate = formatDate;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a time format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new time format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses `Date.toTimeString()` to format the values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If a value is not a `Date` object, `new Date(value)` is used to</span><span class="s3">\n     </span><span class="s1">* coerce the value to a date.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlDateTime()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatTime(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (value instanceof Date) {</span><span class="s3">\n                </span><span class="s1">return value.toTimeString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new Date(value).toTimeString();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatTime = formatTime;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create an ISO datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new ISO datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses `Date.toISOString()` to format the values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If a value is not a `Date` object, `new Date(value)` is used to</span><span class="s3">\n     </span><span class="s1">* coerce the value to a date.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlDateTime()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatISODateTime(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (value instanceof Date) {</span><span class="s3">\n                </span><span class="s1">return value.toISOString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new Date(value).toISOString();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatISODateTime = formatISODateTime;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a UTC datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new UTC datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses `Date.toUTCString()` to format the values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If a value is not a `Date` object, `new Date(value)` is used to</span><span class="s3">\n     </span><span class="s1">* coerce the value to a date.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The `formatIntlDateTime()` formatter is more flexible, but slower.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatUTCDateTime(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (value instanceof Date) {</span><span class="s3">\n                </span><span class="s1">return value.toUTCString();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return new Date(value).toUTCString();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatUTCDateTime = formatUTCDateTime;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create an international datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for creating the format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new international datetime format function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This formatter uses the builtin `Intl.DateTimeFormat` object to</span><span class="s3">\n     </span><span class="s1">* coerce values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is the most flexible (but slowest) datetime formatter.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function formatIntlDateTime(options = {}) {</span><span class="s3">\n        </span><span class="s1">let missing = options.missing || '';</span><span class="s3">\n        </span><span class="s1">let dtf = new Intl.DateTimeFormat(options.locales, options.options);</span><span class="s3">\n        </span><span class="s1">return ({ value }) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n                </span><span class="s1">return missing;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return dtf.format(value);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.formatIntlDateTime = formatIntlDateTime;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Measure the height of a font.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param font - The CSS font string of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The height of the font bounding box.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This function uses a temporary DOM node to measure the text box</span><span class="s3">\n     </span><span class="s1">* height for the specified font. The first call for a given font</span><span class="s3">\n     </span><span class="s1">* will incur a DOM reflow, but the return value is cached, so any</span><span class="s3">\n     </span><span class="s1">* subsequent call for the same font will return the cached value.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function measureFontHeight(font) {</span><span class="s3">\n        </span><span class="s1">// Look up the cached font height.</span><span class="s3">\n        </span><span class="s1">let height = Private$6.fontHeightCache[font];</span><span class="s3">\n        </span><span class="s1">// Return the cached font height if it exists.</span><span class="s3">\n        </span><span class="s1">if (height !== undefined) {</span><span class="s3">\n            </span><span class="s1">return height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Normalize the font.</span><span class="s3">\n        </span><span class="s1">Private$6.fontMeasurementGC.font = font;</span><span class="s3">\n        </span><span class="s1">let normFont = Private$6.fontMeasurementGC.font;</span><span class="s3">\n        </span><span class="s1">// Set the font on the measurement node.</span><span class="s3">\n        </span><span class="s1">Private$6.fontMeasurementNode.style.font = normFont;</span><span class="s3">\n        </span><span class="s1">// Add the measurement node to the document.</span><span class="s3">\n        </span><span class="s1">document.body.appendChild(Private$6.fontMeasurementNode);</span><span class="s3">\n        </span><span class="s1">// Measure the node height.</span><span class="s3">\n        </span><span class="s1">height = Private$6.fontMeasurementNode.offsetHeight;</span><span class="s3">\n        </span><span class="s1">// Remove the measurement node from the document.</span><span class="s3">\n        </span><span class="s1">document.body.removeChild(Private$6.fontMeasurementNode);</span><span class="s3">\n        </span><span class="s1">// Cache the measured height for the font and norm font.</span><span class="s3">\n        </span><span class="s1">Private$6.fontHeightCache[font] = height;</span><span class="s3">\n        </span><span class="s1">Private$6.fontHeightCache[normFont] = height;</span><span class="s3">\n        </span><span class="s1">// Return the measured height.</span><span class="s3">\n        </span><span class="s1">return height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">TextRenderer.measureFontHeight = measureFontHeight;</span><span class="s3">\n</span><span class="s1">})(TextRenderer || (TextRenderer = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$6;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A cache of measured font heights.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.fontHeightCache = Object.create(null);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The DOM node used for font height measurement.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.fontMeasurementNode = (() =&gt; {</span><span class="s3">\n        </span><span class="s1">let node = document.createElement('div');</span><span class="s3">\n        </span><span class="s1">node.style.position = 'absolute';</span><span class="s3">\n        </span><span class="s1">node.style.top = '-99999px';</span><span class="s3">\n        </span><span class="s1">node.style.left = '-99999px';</span><span class="s3">\n        </span><span class="s1">node.style.visibility = 'hidden';</span><span class="s3">\n        </span><span class="s1">node.textContent = 'M';</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">})();</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The GC used for font measurement.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.fontMeasurementGC = (() =&gt; {</span><span class="s3">\n        </span><span class="s1">let canvas = document.createElement('canvas');</span><span class="s3">\n        </span><span class="s1">canvas.width = 0;</span><span class="s3">\n        </span><span class="s1">canvas.height = 0;</span><span class="s3">\n        </span><span class="s1">return canvas.getContext('2d');</span><span class="s3">\n    </span><span class="s1">})();</span><span class="s3">\n</span><span class="s1">})(Private$6 || (Private$6 = {}));</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cell renderer which renders data values as text.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class HyperlinkRenderer extends TextRenderer {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new text renderer.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the renderer.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options = {}) {</span><span class="s3">\n        </span><span class="s1">// Set default parameters before passing over the super.</span><span class="s3">\n        </span><span class="s1">options.textColor = options.textColor || 'navy';</span><span class="s3">\n        </span><span class="s1">options.font = options.font || 'bold 12px sans-serif';</span><span class="s3">\n        </span><span class="s1">super(options);</span><span class="s3">\n        </span><span class="s1">this.url = options.url;</span><span class="s3">\n        </span><span class="s1">this.urlName = options.urlName;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the full text to be rendered by the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getText(config) {</span><span class="s3">\n        </span><span class="s1">let urlName = CellRenderer.resolveOption(this.urlName, config);</span><span class="s3">\n        </span><span class="s1">// If we have a friendly URL name, use that.</span><span class="s3">\n        </span><span class="s1">if (urlName) {</span><span class="s3">\n            </span><span class="s1">return this.format({</span><span class="s3">\n                </span><span class="s1">...config,</span><span class="s3">\n                </span><span class="s1">value: urlName</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise use the raw value attribute.</span><span class="s3">\n        </span><span class="s1">return this.format(config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the text for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawText(gc, config) {</span><span class="s3">\n        </span><span class="s1">// Resolve the font for the cell.</span><span class="s3">\n        </span><span class="s1">let font = CellRenderer.resolveOption(this.font, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no font to draw.</span><span class="s3">\n        </span><span class="s1">if (!font) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resolve the text color for the cell.</span><span class="s3">\n        </span><span class="s1">let color = CellRenderer.resolveOption(this.textColor, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no text color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let text = this.getText(config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no text to draw.</span><span class="s3">\n        </span><span class="s1">if (!text) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resolve the vertical and horizontal alignment.</span><span class="s3">\n        </span><span class="s1">let vAlign = CellRenderer.resolveOption(this.verticalAlignment, config);</span><span class="s3">\n        </span><span class="s1">let hAlign = CellRenderer.resolveOption(this.horizontalAlignment, config);</span><span class="s3">\n        </span><span class="s1">// Resolve the elision direction</span><span class="s3">\n        </span><span class="s1">let elideDirection = CellRenderer.resolveOption(this.elideDirection, config);</span><span class="s3">\n        </span><span class="s1">// Resolve the text wrapping flag</span><span class="s3">\n        </span><span class="s1">let wrapText = CellRenderer.resolveOption(this.wrapText, config);</span><span class="s3">\n        </span><span class="s1">// Compute the padded text box height for the specified alignment.</span><span class="s3">\n        </span><span class="s1">let boxHeight = config.height - (vAlign === 'center' ? 1 : 2);</span><span class="s3">\n        </span><span class="s1">// Bail if the text box has no effective size.</span><span class="s3">\n        </span><span class="s1">if (boxHeight &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the text height for the gc font.</span><span class="s3">\n        </span><span class="s1">let textHeight = HyperlinkRenderer.measureFontHeight(font);</span><span class="s3">\n        </span><span class="s1">// Set up the text position variables.</span><span class="s3">\n        </span><span class="s1">let textX;</span><span class="s3">\n        </span><span class="s1">let textY;</span><span class="s3">\n        </span><span class="s1">let boxWidth;</span><span class="s3">\n        </span><span class="s1">// Compute the Y position for the text.</span><span class="s3">\n        </span><span class="s1">switch (vAlign) {</span><span class="s3">\n            </span><span class="s1">case 'top':</span><span class="s3">\n                </span><span class="s1">textY = config.y + 2 + textHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'center':</span><span class="s3">\n                </span><span class="s1">textY = config.y + config.height / 2 + textHeight / 2;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'bottom':</span><span class="s3">\n                </span><span class="s1">textY = config.y + config.height - 2;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the X position for the text.</span><span class="s3">\n        </span><span class="s1">switch (hAlign) {</span><span class="s3">\n            </span><span class="s1">case 'left':</span><span class="s3">\n                </span><span class="s1">textX = config.x + 8;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width - 14;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'center':</span><span class="s3">\n                </span><span class="s1">textX = config.x + config.width / 2;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'right':</span><span class="s3">\n                </span><span class="s1">textX = config.x + config.width - 8;</span><span class="s3">\n                </span><span class="s1">boxWidth = config.width - 14;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clip the cell if the text is taller than the text box height.</span><span class="s3">\n        </span><span class="s1">if (textHeight &gt; boxHeight) {</span><span class="s3">\n            </span><span class="s1">gc.beginPath();</span><span class="s3">\n            </span><span class="s1">gc.rect(config.x, config.y, config.width, config.height - 1);</span><span class="s3">\n            </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set the gc state.</span><span class="s3">\n        </span><span class="s1">gc.font = font;</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">gc.textAlign = hAlign;</span><span class="s3">\n        </span><span class="s1">gc.textBaseline = 'bottom';</span><span class="s3">\n        </span><span class="s1">// Terminate call here if we're not eliding or wrapping text</span><span class="s3">\n        </span><span class="s1">if (elideDirection === 'none' &amp;&amp; !wrapText) {</span><span class="s3">\n            </span><span class="s1">gc.fillText(text, textX, textY);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The current text width in pixels.</span><span class="s3">\n        </span><span class="s1">let textWidth = gc.measureText(text).width;</span><span class="s3">\n        </span><span class="s1">// Apply text wrapping if enabled.</span><span class="s3">\n        </span><span class="s1">if (wrapText &amp;&amp; textWidth &gt; boxWidth) {</span><span class="s3">\n            </span><span class="s1">// Make sure box clipping happens.</span><span class="s3">\n            </span><span class="s1">gc.beginPath();</span><span class="s3">\n            </span><span class="s1">gc.rect(config.x, config.y, config.width, config.height - 1);</span><span class="s3">\n            </span><span class="s1">gc.clip();</span><span class="s3">\n            </span><span class="s1">// Split column name to words based on</span><span class="s3">\n            </span><span class="s1">// whitespace preceding a word boundary.</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">Hello  world</span><span class="s3">\&quot; </span><span class="s1">--&gt; [</span><span class="s3">\&quot;</span><span class="s1">Hello  </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">world</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n            </span><span class="s1">const wordsInColumn = text.split(/</span><span class="s3">\\</span><span class="s1">s(?=</span><span class="s3">\\</span><span class="s1">b)/);</span><span class="s3">\n            </span><span class="s1">// Y-coordinate offset for any additional lines</span><span class="s3">\n            </span><span class="s1">let curY = textY;</span><span class="s3">\n            </span><span class="s1">let textInCurrentLine = wordsInColumn.shift();</span><span class="s3">\n            </span><span class="s1">// Single word. Applying text wrap on word by splitting</span><span class="s3">\n            </span><span class="s1">// it into characters and fitting the maximum number of</span><span class="s3">\n            </span><span class="s1">// characters possible per line (box width).</span><span class="s3">\n            </span><span class="s1">if (wordsInColumn.length === 0) {</span><span class="s3">\n                </span><span class="s1">let curLineTextWidth = gc.measureText(textInCurrentLine).width;</span><span class="s3">\n                </span><span class="s1">while (curLineTextWidth &gt; boxWidth &amp;&amp; textInCurrentLine !== '') {</span><span class="s3">\n                    </span><span class="s1">// Iterating from the end of the string until we find a</span><span class="s3">\n                    </span><span class="s1">// substring (0,i) which has a width less than the box width.</span><span class="s3">\n                    </span><span class="s1">for (let i = textInCurrentLine.length; i &gt; 0; i--) {</span><span class="s3">\n                        </span><span class="s1">const curSubString = textInCurrentLine.substring(0, i);</span><span class="s3">\n                        </span><span class="s1">const curSubStringWidth = gc.measureText(curSubString).width;</span><span class="s3">\n                        </span><span class="s1">if (curSubStringWidth &lt; boxWidth || curSubString.length === 1) {</span><span class="s3">\n                            </span><span class="s1">// Found a substring which has a width less than the current</span><span class="s3">\n                            </span><span class="s1">// box width. Rendering that substring on the current line</span><span class="s3">\n                            </span><span class="s1">// and setting the remainder of the parent string as the next</span><span class="s3">\n                            </span><span class="s1">// string to iterate on for the next line.</span><span class="s3">\n                            </span><span class="s1">const nextLineText = textInCurrentLine.substring(i, textInCurrentLine.length);</span><span class="s3">\n                            </span><span class="s1">textInCurrentLine = nextLineText;</span><span class="s3">\n                            </span><span class="s1">curLineTextWidth = gc.measureText(textInCurrentLine).width;</span><span class="s3">\n                            </span><span class="s1">gc.fillText(curSubString, textX, curY);</span><span class="s3">\n                            </span><span class="s1">curY += textHeight;</span><span class="s3">\n                            </span><span class="s1">// No need to continue iterating after we identified</span><span class="s3">\n                            </span><span class="s1">// an index to break the string on.</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Multiple words in column header. Fitting maximum</span><span class="s3">\n            </span><span class="s1">// number of words possible per line (box width).</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">while (wordsInColumn.length !== 0) {</span><span class="s3">\n                    </span><span class="s1">// Processing the next word in the queue.</span><span class="s3">\n                    </span><span class="s1">const curWord = wordsInColumn.shift();</span><span class="s3">\n                    </span><span class="s1">// Joining that word with the existing text for</span><span class="s3">\n                    </span><span class="s1">// the current line.</span><span class="s3">\n                    </span><span class="s1">const incrementedText = [textInCurrentLine, curWord].join(' ');</span><span class="s3">\n                    </span><span class="s1">const incrementedTextWidth = gc.measureText(incrementedText).width;</span><span class="s3">\n                    </span><span class="s1">if (incrementedTextWidth &gt; boxWidth) {</span><span class="s3">\n                        </span><span class="s1">// If the newly combined text has a width larger than</span><span class="s3">\n                        </span><span class="s1">// the box width, we render the line before the current</span><span class="s3">\n                        </span><span class="s1">// word was added. We set the current word as the next</span><span class="s3">\n                        </span><span class="s1">// line.</span><span class="s3">\n                        </span><span class="s1">gc.fillText(textInCurrentLine, textX, curY);</span><span class="s3">\n                        </span><span class="s1">curY += textHeight;</span><span class="s3">\n                        </span><span class="s1">textInCurrentLine = curWord;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// The combined text hasd a width less than the box width. We</span><span class="s3">\n                        </span><span class="s1">// set the the current line text to be the new combined text.</span><span class="s3">\n                        </span><span class="s1">textInCurrentLine = incrementedText;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">gc.fillText(textInCurrentLine, textX, curY);</span><span class="s3">\n            </span><span class="s1">// Terminating the call here as we don't want</span><span class="s3">\n            </span><span class="s1">// to apply text eliding when wrapping is active.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Elide text that is too long</span><span class="s3">\n        </span><span class="s1">let elide = '</span><span class="s3">\\</span><span class="s1">u2026';</span><span class="s3">\n        </span><span class="s1">// Compute elided text</span><span class="s3">\n        </span><span class="s1">if (elideDirection === 'right') {</span><span class="s3">\n            </span><span class="s1">while (textWidth &gt; boxWidth &amp;&amp; text.length &gt; 1) {</span><span class="s3">\n                </span><span class="s1">if (text.length &gt; 4 &amp;&amp; textWidth &gt;= 2 * boxWidth) {</span><span class="s3">\n                    </span><span class="s1">// If text width is substantially bigger, take half the string</span><span class="s3">\n                    </span><span class="s1">text = text.substring(0, text.length / 2 + 1) + elide;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Otherwise incrementally remove the last character</span><span class="s3">\n                    </span><span class="s1">text = text.substring(0, text.length - 2) + elide;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">textWidth = gc.measureText(text).width;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">while (textWidth &gt; boxWidth &amp;&amp; text.length &gt; 1) {</span><span class="s3">\n                </span><span class="s1">if (text.length &gt; 4 &amp;&amp; textWidth &gt;= 2 * boxWidth) {</span><span class="s3">\n                    </span><span class="s1">// If text width is substantially bigger, take half the string</span><span class="s3">\n                    </span><span class="s1">text = elide + text.substring(text.length / 2);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Otherwise incrementally remove the last character</span><span class="s3">\n                    </span><span class="s1">text = elide + text.substring(2);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">textWidth = gc.measureText(text).width;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the text for the cell.</span><span class="s3">\n        </span><span class="s1">gc.fillText(text, textX, textY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Jupyter Development Team.</span><span class="s3">\n </span><span class="s1">* Distributed under the terms of the Modified BSD License.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A collection of helper functions relating to merged cell groups</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var CellGroup;</span><span class="s3">\n</span><span class="s1">(function (CellGroup) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks if two cell-groups are intersecting</span><span class="s3">\n     </span><span class="s1">* in the given axis.</span><span class="s3">\n     </span><span class="s1">* @param group1</span><span class="s3">\n     </span><span class="s1">* @param group2</span><span class="s3">\n     </span><span class="s1">* @param axis</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function areCellGroupsIntersectingAtAxis(group1, group2, axis) {</span><span class="s3">\n        </span><span class="s1">if (axis === 'row') {</span><span class="s3">\n            </span><span class="s1">return ((group1.r1 &gt;= group2.r1 &amp;&amp; group1.r1 &lt;= group2.r2) ||</span><span class="s3">\n                </span><span class="s1">(group1.r2 &gt;= group2.r1 &amp;&amp; group1.r2 &lt;= group2.r2) ||</span><span class="s3">\n                </span><span class="s1">(group2.r1 &gt;= group1.r1 &amp;&amp; group2.r1 &lt;= group1.r2) ||</span><span class="s3">\n                </span><span class="s1">(group2.r2 &gt;= group1.r1 &amp;&amp; group2.r2 &lt;= group1.r2));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ((group1.c1 &gt;= group2.c1 &amp;&amp; group1.c1 &lt;= group2.c2) ||</span><span class="s3">\n            </span><span class="s1">(group1.c2 &gt;= group2.c1 &amp;&amp; group1.c2 &lt;= group2.c2) ||</span><span class="s3">\n            </span><span class="s1">(group2.c1 &gt;= group1.c1 &amp;&amp; group2.c1 &lt;= group1.c2) ||</span><span class="s3">\n            </span><span class="s1">(group2.c2 &gt;= group1.c1 &amp;&amp; group2.c2 &lt;= group1.c2));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.areCellGroupsIntersectingAtAxis = areCellGroupsIntersectingAtAxis;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks if cell-groups are intersecting.</span><span class="s3">\n     </span><span class="s1">* @param group1</span><span class="s3">\n     </span><span class="s1">* @param group2</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function areCellGroupsIntersecting(group1, group2) {</span><span class="s3">\n        </span><span class="s1">return (((group1.r1 &gt;= group2.r1 &amp;&amp; group1.r1 &lt;= group2.r2) ||</span><span class="s3">\n            </span><span class="s1">(group1.r2 &gt;= group2.r1 &amp;&amp; group1.r2 &lt;= group2.r2) ||</span><span class="s3">\n            </span><span class="s1">(group2.r1 &gt;= group1.r1 &amp;&amp; group2.r1 &lt;= group1.r2) ||</span><span class="s3">\n            </span><span class="s1">(group2.r2 &gt;= group1.r1 &amp;&amp; group2.r2 &lt;= group1.r2)) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">((group1.c1 &gt;= group2.c1 &amp;&amp; group1.c1 &lt;= group2.c2) ||</span><span class="s3">\n                </span><span class="s1">(group1.c2 &gt;= group2.c1 &amp;&amp; group1.c2 &lt;= group2.c2) ||</span><span class="s3">\n                </span><span class="s1">(group2.c1 &gt;= group1.c1 &amp;&amp; group2.c1 &lt;= group1.c2) ||</span><span class="s3">\n                </span><span class="s1">(group2.c2 &gt;= group1.c1 &amp;&amp; group2.c2 &lt;= group1.c2)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.areCellGroupsIntersecting = areCellGroupsIntersecting;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Retrieves the index of the cell-group to which</span><span class="s3">\n     </span><span class="s1">* the cell at the given row, column belongs.</span><span class="s3">\n     </span><span class="s1">* @param dataModel</span><span class="s3">\n     </span><span class="s1">* @param rgn</span><span class="s3">\n     </span><span class="s1">* @param row</span><span class="s3">\n     </span><span class="s1">* @param column</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function getGroupIndex(dataModel, rgn, row, column) {</span><span class="s3">\n        </span><span class="s1">const numGroups = dataModel.groupCount(rgn);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numGroups; i++) {</span><span class="s3">\n            </span><span class="s1">const group = dataModel.group(rgn, i);</span><span class="s3">\n            </span><span class="s1">if (row &gt;= group.r1 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">row &lt;= group.r2 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">column &gt;= group.c1 &amp;&amp;</span><span class="s3">\n                </span><span class="s1">column &lt;= group.c2) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.getGroupIndex = getGroupIndex;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns a cell-group for the given row/index coordinates.</span><span class="s3">\n     </span><span class="s1">* @param dataModel</span><span class="s3">\n     </span><span class="s1">* @param rgn</span><span class="s3">\n     </span><span class="s1">* @param row</span><span class="s3">\n     </span><span class="s1">* @param column</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function getGroup(dataModel, rgn, row, column) {</span><span class="s3">\n        </span><span class="s1">const groupIndex = getGroupIndex(dataModel, rgn, row, column);</span><span class="s3">\n        </span><span class="s1">if (groupIndex === -1) {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return dataModel.group(rgn, groupIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.getGroup = getGroup;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns all cell groups which belong to</span><span class="s3">\n     </span><span class="s1">* a given cell cell region.</span><span class="s3">\n     </span><span class="s1">* @param dataModel</span><span class="s3">\n     </span><span class="s1">* @param rgn</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function getCellGroupsAtRegion(dataModel, rgn) {</span><span class="s3">\n        </span><span class="s1">let groupsAtRegion = [];</span><span class="s3">\n        </span><span class="s1">const numGroups = dataModel.groupCount(rgn);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numGroups; i++) {</span><span class="s3">\n            </span><span class="s1">const group = dataModel.group(rgn, i);</span><span class="s3">\n            </span><span class="s1">groupsAtRegion.push(group);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return groupsAtRegion;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.getCellGroupsAtRegion = getCellGroupsAtRegion;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Calculates and returns a merged cell-group from</span><span class="s3">\n     </span><span class="s1">* two cell-group objects.</span><span class="s3">\n     </span><span class="s1">* @param groups</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function joinCellGroups(groups) {</span><span class="s3">\n        </span><span class="s1">let startRow = Number.MAX_VALUE;</span><span class="s3">\n        </span><span class="s1">let endRow = Number.MIN_VALUE;</span><span class="s3">\n        </span><span class="s1">let startColumn = Number.MAX_VALUE;</span><span class="s3">\n        </span><span class="s1">let endColumn = Number.MIN_VALUE;</span><span class="s3">\n        </span><span class="s1">for (const group of groups) {</span><span class="s3">\n            </span><span class="s1">startRow = Math.min(startRow, group.r1);</span><span class="s3">\n            </span><span class="s1">endRow = Math.max(endRow, group.r2);</span><span class="s3">\n            </span><span class="s1">startColumn = Math.min(startColumn, group.c1);</span><span class="s3">\n            </span><span class="s1">endColumn = Math.max(endColumn, group.c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.joinCellGroups = joinCellGroups;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Merges a cell group with other cells groups in the</span><span class="s3">\n     </span><span class="s1">* same region if they intersect.</span><span class="s3">\n     </span><span class="s1">* @param dataModel the data model of the grid.</span><span class="s3">\n     </span><span class="s1">* @param group the target cell group.</span><span class="s3">\n     </span><span class="s1">* @param region the region of the cell group.</span><span class="s3">\n     </span><span class="s1">* @returns a new cell group after merging has happened.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function joinCellGroupWithMergedCellGroups(dataModel, group, region) {</span><span class="s3">\n        </span><span class="s1">let joinedGroup = { ...group };</span><span class="s3">\n        </span><span class="s1">const mergedCellGroups = getCellGroupsAtRegion(dataModel, region);</span><span class="s3">\n        </span><span class="s1">for (let g = 0; g &lt; mergedCellGroups.length; g++) {</span><span class="s3">\n            </span><span class="s1">const mergedGroup = mergedCellGroups[g];</span><span class="s3">\n            </span><span class="s1">if (areCellGroupsIntersecting(joinedGroup, mergedGroup)) {</span><span class="s3">\n                </span><span class="s1">joinedGroup = joinCellGroups([joinedGroup, mergedGroup]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return joinedGroup;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.joinCellGroupWithMergedCellGroups = joinCellGroupWithMergedCellGroups;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Retrieves a list of cell groups intersecting at</span><span class="s3">\n     </span><span class="s1">* a given row.</span><span class="s3">\n     </span><span class="s1">* @param dataModel data model of the grid.</span><span class="s3">\n     </span><span class="s1">* @param rgn the cell region.</span><span class="s3">\n     </span><span class="s1">* @param row the target row to look for intersections at.</span><span class="s3">\n     </span><span class="s1">* @returns all cell groups intersecting with the row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function getCellGroupsAtRow(dataModel, rgn, row) {</span><span class="s3">\n        </span><span class="s1">let groupsAtRow = [];</span><span class="s3">\n        </span><span class="s1">const numGroups = dataModel.groupCount(rgn);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numGroups; i++) {</span><span class="s3">\n            </span><span class="s1">const group = dataModel.group(rgn, i);</span><span class="s3">\n            </span><span class="s1">if (row &gt;= group.r1 &amp;&amp; row &lt;= group.r2) {</span><span class="s3">\n                </span><span class="s1">groupsAtRow.push(group);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return groupsAtRow;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.getCellGroupsAtRow = getCellGroupsAtRow;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Retrieves a list of cell groups intersecting at</span><span class="s3">\n     </span><span class="s1">* a given column.</span><span class="s3">\n     </span><span class="s1">* @param dataModel data model of the grid.</span><span class="s3">\n     </span><span class="s1">* @param rgn the cell region.</span><span class="s3">\n     </span><span class="s1">* @param column the target column to look for intersections at.</span><span class="s3">\n     </span><span class="s1">* @returns all cell groups intersecting with the column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function getCellGroupsAtColumn(dataModel, rgn, column) {</span><span class="s3">\n        </span><span class="s1">let groupsAtColumn = [];</span><span class="s3">\n        </span><span class="s1">const numGroups = dataModel.groupCount(rgn);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numGroups; i++) {</span><span class="s3">\n            </span><span class="s1">const group = dataModel.group(rgn, i);</span><span class="s3">\n            </span><span class="s1">if (column &gt;= group.c1 &amp;&amp; column &lt;= group.c2) {</span><span class="s3">\n                </span><span class="s1">groupsAtColumn.push(group);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return groupsAtColumn;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.getCellGroupsAtColumn = getCellGroupsAtColumn;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Merges a target cell group with any cell groups</span><span class="s3">\n     </span><span class="s1">* it intersects with at a given row or column.</span><span class="s3">\n     </span><span class="s1">* @param dataModel data model of the grid.</span><span class="s3">\n     </span><span class="s1">* @param regions list of cell regions.</span><span class="s3">\n     </span><span class="s1">* @param axis row or column.</span><span class="s3">\n     </span><span class="s1">* @param group the target cell group.</span><span class="s3">\n     </span><span class="s1">* @returns a new merged cell group.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function joinCellGroupsIntersectingAtAxis(dataModel, regions, axis, group) {</span><span class="s3">\n        </span><span class="s1">let groupsAtAxis = [];</span><span class="s3">\n        </span><span class="s1">if (axis === 'row') {</span><span class="s3">\n            </span><span class="s1">for (const region of regions) {</span><span class="s3">\n                </span><span class="s1">for (let r = group.r1; r &lt;= group.r2; r++) {</span><span class="s3">\n                    </span><span class="s1">groupsAtAxis = groupsAtAxis.concat(CellGroup.getCellGroupsAtRow(dataModel, region, r));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">for (const region of regions) {</span><span class="s3">\n                </span><span class="s1">for (let c = group.c1; c &lt;= group.c2; c++) {</span><span class="s3">\n                    </span><span class="s1">groupsAtAxis = groupsAtAxis.concat(CellGroup.getCellGroupsAtColumn(dataModel, region, c));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let mergedGroupAtAxis = CellGroup.joinCellGroups(groupsAtAxis);</span><span class="s3">\n        </span><span class="s1">if (groupsAtAxis.length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">let mergedCellGroups = [];</span><span class="s3">\n            </span><span class="s1">for (const region of regions) {</span><span class="s3">\n                </span><span class="s1">mergedCellGroups = mergedCellGroups.concat(CellGroup.getCellGroupsAtRegion(dataModel, region));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let g = 0; g &lt; mergedCellGroups.length; g++) {</span><span class="s3">\n                </span><span class="s1">const group = mergedCellGroups[g];</span><span class="s3">\n                </span><span class="s1">if (CellGroup.areCellGroupsIntersectingAtAxis(mergedGroupAtAxis, group, axis)) {</span><span class="s3">\n                    </span><span class="s1">mergedGroupAtAxis = CellGroup.joinCellGroups([</span><span class="s3">\n                        </span><span class="s1">group,</span><span class="s3">\n                        </span><span class="s1">mergedGroupAtAxis</span><span class="s3">\n                    </span><span class="s1">]);</span><span class="s3">\n                    </span><span class="s1">mergedCellGroups.splice(g, 1);</span><span class="s3">\n                    </span><span class="s1">g = 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return mergedGroupAtAxis;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellGroup.joinCellGroupsIntersectingAtAxis = joinCellGroupsIntersectingAtAxis;</span><span class="s3">\n</span><span class="s1">})(CellGroup || (CellGroup = {}));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A basic implementation of a data grid mouse handler.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This class may be subclassed and customized as needed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BasicMouseHandler {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this._disposed = false;</span><span class="s3">\n        </span><span class="s1">this._pressData = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by the mouse handler.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">// Bail early if the handler is already disposed.</span><span class="s3">\n        </span><span class="s1">if (this._disposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release any held resources.</span><span class="s3">\n        </span><span class="s1">this.release();</span><span class="s3">\n        </span><span class="s1">// Mark the handler as disposed.</span><span class="s3">\n        </span><span class="s1">this._disposed = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the mouse handler is disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Release the resources held by the handler.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">release() {</span><span class="s3">\n        </span><span class="s1">// Bail early if the is no press data.</span><span class="s3">\n        </span><span class="s1">if (!this._pressData) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clear the autoselect timeout.</span><span class="s3">\n        </span><span class="s1">if (this._pressData.type === 'select') {</span><span class="s3">\n            </span><span class="s1">this._pressData.timeout = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clear the press data.</span><span class="s3">\n        </span><span class="s1">this._pressData.override.dispose();</span><span class="s3">\n        </span><span class="s1">this._pressData = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse hover event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse hover event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseHover(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Hit test the grid.</span><span class="s3">\n        </span><span class="s1">let hit = grid.hitTest(event.clientX, event.clientY);</span><span class="s3">\n        </span><span class="s1">// Get the resize handle for the hit test.</span><span class="s3">\n        </span><span class="s1">let handle = Private$5.resizeHandleForHitTest(hit);</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor for the handle.</span><span class="s3">\n        </span><span class="s1">let cursor = this.cursorForHandle(handle);</span><span class="s3">\n        </span><span class="s1">// Hyperlink logic.</span><span class="s3">\n        </span><span class="s1">const config = Private$5.createCellConfigObject(grid, hit);</span><span class="s3">\n        </span><span class="s1">if (config) {</span><span class="s3">\n            </span><span class="s1">// Retrieve renderer for hovered cell.</span><span class="s3">\n            </span><span class="s1">const renderer = grid.cellRenderers.get(config);</span><span class="s3">\n            </span><span class="s1">if (renderer instanceof HyperlinkRenderer) {</span><span class="s3">\n                </span><span class="s1">cursor = this.cursorForHandle('hyperlink');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the viewport cursor based on the part.</span><span class="s3">\n        </span><span class="s1">grid.viewport.node.style.cursor = cursor;</span><span class="s3">\n        </span><span class="s1">// TODO support user-defined hover items</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse leave event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse hover event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseLeave(grid, event) {</span><span class="s3">\n        </span><span class="s1">// TODO support user-defined hover popups.</span><span class="s3">\n        </span><span class="s1">// Clear the viewport cursor.</span><span class="s3">\n        </span><span class="s1">grid.viewport.node.style.cursor = '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse down event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse down event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseDown(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Unpack the event.</span><span class="s3">\n        </span><span class="s1">let { clientX, clientY } = event;</span><span class="s3">\n        </span><span class="s1">// Hit test the grid.</span><span class="s3">\n        </span><span class="s1">let hit = grid.hitTest(clientX, clientY);</span><span class="s3">\n        </span><span class="s1">// Unpack the hit test.</span><span class="s3">\n        </span><span class="s1">const { region, row, column } = hit;</span><span class="s3">\n        </span><span class="s1">// Bail if the hit test is on an uninteresting region.</span><span class="s3">\n        </span><span class="s1">if (region === 'void') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the modifier flags.</span><span class="s3">\n        </span><span class="s1">let shift = event.shiftKey;</span><span class="s3">\n        </span><span class="s1">let accel = Platform.accelKey(event);</span><span class="s3">\n        </span><span class="s1">// Hyperlink logic.</span><span class="s3">\n        </span><span class="s1">if (grid) {</span><span class="s3">\n            </span><span class="s1">// Create cell config object.</span><span class="s3">\n            </span><span class="s1">const config = Private$5.createCellConfigObject(grid, hit);</span><span class="s3">\n            </span><span class="s1">// Retrieve cell renderer.</span><span class="s3">\n            </span><span class="s1">let renderer = grid.cellRenderers.get(config);</span><span class="s3">\n            </span><span class="s1">// Only process hyperlink renderers.</span><span class="s3">\n            </span><span class="s1">if (renderer instanceof HyperlinkRenderer) {</span><span class="s3">\n                </span><span class="s1">// Use the url param if it exists.</span><span class="s3">\n                </span><span class="s1">let url = CellRenderer.resolveOption(renderer.url, config);</span><span class="s3">\n                </span><span class="s1">// Otherwise assume cell value is the URL.</span><span class="s3">\n                </span><span class="s1">if (!url) {</span><span class="s3">\n                    </span><span class="s1">const format = TextRenderer.formatGeneric();</span><span class="s3">\n                    </span><span class="s1">url = format(config);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Open the hyperlink only if user hit Ctrl+Click.</span><span class="s3">\n                </span><span class="s1">if (accel) {</span><span class="s3">\n                    </span><span class="s1">window.open(url);</span><span class="s3">\n                    </span><span class="s1">// Reset cursor default after clicking</span><span class="s3">\n                    </span><span class="s1">const cursor = this.cursorForHandle('none');</span><span class="s3">\n                    </span><span class="s1">grid.viewport.node.style.cursor = cursor;</span><span class="s3">\n                    </span><span class="s1">// Not applying selections if navigating away.</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the hit test is the body region, the only option is select.</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n            </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n            </span><span class="s1">// Bail early if there is no selection model.</span><span class="s3">\n            </span><span class="s1">if (!model) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Override the document cursor.</span><span class="s3">\n            </span><span class="s1">let override = Drag.overrideCursor('default');</span><span class="s3">\n            </span><span class="s1">// Set up the press data.</span><span class="s3">\n            </span><span class="s1">this._pressData = {</span><span class="s3">\n                </span><span class="s1">type: 'select',</span><span class="s3">\n                </span><span class="s1">region,</span><span class="s3">\n                </span><span class="s1">row,</span><span class="s3">\n                </span><span class="s1">column,</span><span class="s3">\n                </span><span class="s1">override,</span><span class="s3">\n                </span><span class="s1">localX: -1,</span><span class="s3">\n                </span><span class="s1">localY: -1,</span><span class="s3">\n                </span><span class="s1">timeout: -1</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n            </span><span class="s1">let r1;</span><span class="s3">\n            </span><span class="s1">let c1;</span><span class="s3">\n            </span><span class="s1">let r2;</span><span class="s3">\n            </span><span class="s1">let c2;</span><span class="s3">\n            </span><span class="s1">let cursorRow;</span><span class="s3">\n            </span><span class="s1">let cursorColumn;</span><span class="s3">\n            </span><span class="s1">let clear;</span><span class="s3">\n            </span><span class="s1">// Accel == new selection, keep old selections.</span><span class="s3">\n            </span><span class="s1">if (accel) {</span><span class="s3">\n                </span><span class="s1">r1 = row;</span><span class="s3">\n                </span><span class="s1">r2 = row;</span><span class="s3">\n                </span><span class="s1">c1 = column;</span><span class="s3">\n                </span><span class="s1">c2 = column;</span><span class="s3">\n                </span><span class="s1">cursorRow = row;</span><span class="s3">\n                </span><span class="s1">cursorColumn = column;</span><span class="s3">\n                </span><span class="s1">clear = 'none';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (shift) {</span><span class="s3">\n                </span><span class="s1">r1 = model.cursorRow;</span><span class="s3">\n                </span><span class="s1">r2 = row;</span><span class="s3">\n                </span><span class="s1">c1 = model.cursorColumn;</span><span class="s3">\n                </span><span class="s1">c2 = column;</span><span class="s3">\n                </span><span class="s1">cursorRow = model.cursorRow;</span><span class="s3">\n                </span><span class="s1">cursorColumn = model.cursorColumn;</span><span class="s3">\n                </span><span class="s1">clear = 'current';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">r1 = row;</span><span class="s3">\n                </span><span class="s1">r2 = row;</span><span class="s3">\n                </span><span class="s1">c1 = column;</span><span class="s3">\n                </span><span class="s1">c2 = column;</span><span class="s3">\n                </span><span class="s1">cursorRow = row;</span><span class="s3">\n                </span><span class="s1">cursorColumn = column;</span><span class="s3">\n                </span><span class="s1">clear = 'all';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Make the selection.</span><span class="s3">\n            </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });</span><span class="s3">\n            </span><span class="s1">// Done.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, the hit test is on a header region.</span><span class="s3">\n        </span><span class="s1">// Convert the hit test into a part.</span><span class="s3">\n        </span><span class="s1">let handle = Private$5.resizeHandleForHitTest(hit);</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor for the handle.</span><span class="s3">\n        </span><span class="s1">let cursor = this.cursorForHandle(handle);</span><span class="s3">\n        </span><span class="s1">// Handle horizontal resize.</span><span class="s3">\n        </span><span class="s1">if (handle === 'left' || handle === 'right') {</span><span class="s3">\n            </span><span class="s1">// Set up the resize data type.</span><span class="s3">\n            </span><span class="s1">const type = 'column-resize';</span><span class="s3">\n            </span><span class="s1">// Determine the column region.</span><span class="s3">\n            </span><span class="s1">let rgn = region === 'column-header' ? 'body' : 'row-header';</span><span class="s3">\n            </span><span class="s1">// Determine the section index.</span><span class="s3">\n            </span><span class="s1">let index = handle === 'left' ? column - 1 : column;</span><span class="s3">\n            </span><span class="s1">// Fetch the section size.</span><span class="s3">\n            </span><span class="s1">let size = grid.columnSize(rgn, index);</span><span class="s3">\n            </span><span class="s1">// Override the document cursor.</span><span class="s3">\n            </span><span class="s1">let override = Drag.overrideCursor(cursor);</span><span class="s3">\n            </span><span class="s1">// Create the temporary press data.</span><span class="s3">\n            </span><span class="s1">this._pressData = { type, region: rgn, index, size, clientX, override };</span><span class="s3">\n            </span><span class="s1">// Done.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle vertical resize</span><span class="s3">\n        </span><span class="s1">if (handle === 'top' || handle === 'bottom') {</span><span class="s3">\n            </span><span class="s1">// Set up the resize data type.</span><span class="s3">\n            </span><span class="s1">const type = 'row-resize';</span><span class="s3">\n            </span><span class="s1">// Determine the row region.</span><span class="s3">\n            </span><span class="s1">let rgn = region === 'row-header' ? 'body' : 'column-header';</span><span class="s3">\n            </span><span class="s1">// Determine the section index.</span><span class="s3">\n            </span><span class="s1">let index = handle === 'top' ? row - 1 : row;</span><span class="s3">\n            </span><span class="s1">// Fetch the section size.</span><span class="s3">\n            </span><span class="s1">let size = grid.rowSize(rgn, index);</span><span class="s3">\n            </span><span class="s1">// Override the document cursor.</span><span class="s3">\n            </span><span class="s1">let override = Drag.overrideCursor(cursor);</span><span class="s3">\n            </span><span class="s1">// Create the temporary press data.</span><span class="s3">\n            </span><span class="s1">this._pressData = { type, region: rgn, index, size, clientY, override };</span><span class="s3">\n            </span><span class="s1">// Done.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, the only option is select.</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection model.</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Override the document cursor.</span><span class="s3">\n        </span><span class="s1">let override = Drag.overrideCursor('default');</span><span class="s3">\n        </span><span class="s1">// Set up the press data.</span><span class="s3">\n        </span><span class="s1">this._pressData = {</span><span class="s3">\n            </span><span class="s1">type: 'select',</span><span class="s3">\n            </span><span class="s1">region,</span><span class="s3">\n            </span><span class="s1">row,</span><span class="s3">\n            </span><span class="s1">column,</span><span class="s3">\n            </span><span class="s1">override,</span><span class="s3">\n            </span><span class="s1">localX: -1,</span><span class="s3">\n            </span><span class="s1">localY: -1,</span><span class="s3">\n            </span><span class="s1">timeout: -1</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cursorRow;</span><span class="s3">\n        </span><span class="s1">let cursorColumn;</span><span class="s3">\n        </span><span class="s1">let clear;</span><span class="s3">\n        </span><span class="s1">// Compute the selection based on the pressed region.</span><span class="s3">\n        </span><span class="s1">if (region === 'corner-header') {</span><span class="s3">\n            </span><span class="s1">r1 = 0;</span><span class="s3">\n            </span><span class="s1">r2 = Infinity;</span><span class="s3">\n            </span><span class="s1">c1 = 0;</span><span class="s3">\n            </span><span class="s1">c2 = Infinity;</span><span class="s3">\n            </span><span class="s1">cursorRow = accel ? 0 : shift ? model.cursorRow : 0;</span><span class="s3">\n            </span><span class="s1">cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;</span><span class="s3">\n            </span><span class="s1">clear = accel ? 'none' : shift ? 'current' : 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (region === 'row-header') {</span><span class="s3">\n            </span><span class="s1">r1 = accel ? row : shift ? model.cursorRow : row;</span><span class="s3">\n            </span><span class="s1">r2 = row;</span><span class="s3">\n            </span><span class="s1">const selectionGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };</span><span class="s3">\n            </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['row-header', 'body'], 'row', selectionGroup);</span><span class="s3">\n            </span><span class="s1">// Check if there are any merges</span><span class="s3">\n            </span><span class="s1">if (joinedGroup.r1 != Number.MAX_VALUE) {</span><span class="s3">\n                </span><span class="s1">r1 = joinedGroup.r1;</span><span class="s3">\n                </span><span class="s1">r2 = joinedGroup.r2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">c1 = 0;</span><span class="s3">\n            </span><span class="s1">c2 = Infinity;</span><span class="s3">\n            </span><span class="s1">cursorRow = accel ? row : shift ? model.cursorRow : row;</span><span class="s3">\n            </span><span class="s1">cursorColumn = accel ? 0 : shift ? model.cursorColumn : 0;</span><span class="s3">\n            </span><span class="s1">clear = accel ? 'none' : shift ? 'current' : 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (region === 'column-header') {</span><span class="s3">\n            </span><span class="s1">r1 = 0;</span><span class="s3">\n            </span><span class="s1">r2 = Infinity;</span><span class="s3">\n            </span><span class="s1">c1 = accel ? column : shift ? model.cursorColumn : column;</span><span class="s3">\n            </span><span class="s1">c2 = column;</span><span class="s3">\n            </span><span class="s1">const selectionGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };</span><span class="s3">\n            </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['column-header', 'body'], 'column', selectionGroup);</span><span class="s3">\n            </span><span class="s1">// Check if there are any merges</span><span class="s3">\n            </span><span class="s1">if (joinedGroup.c1 != Number.MAX_VALUE) {</span><span class="s3">\n                </span><span class="s1">c1 = joinedGroup.c1;</span><span class="s3">\n                </span><span class="s1">c2 = joinedGroup.c2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">cursorRow = accel ? 0 : shift ? model.cursorRow : 0;</span><span class="s3">\n            </span><span class="s1">cursorColumn = accel ? column : shift ? model.cursorColumn : column;</span><span class="s3">\n            </span><span class="s1">clear = accel ? 'none' : shift ? 'current' : 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = accel ? row : shift ? model.cursorRow : row;</span><span class="s3">\n            </span><span class="s1">r2 = row;</span><span class="s3">\n            </span><span class="s1">c1 = accel ? column : shift ? model.cursorColumn : column;</span><span class="s3">\n            </span><span class="s1">c2 = column;</span><span class="s3">\n            </span><span class="s1">cursorRow = accel ? row : shift ? model.cursorRow : row;</span><span class="s3">\n            </span><span class="s1">cursorColumn = accel ? column : shift ? model.cursorColumn : column;</span><span class="s3">\n            </span><span class="s1">clear = accel ? 'none' : shift ? 'current' : 'all';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Make the selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse move event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse move event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseMove(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Fetch the press data.</span><span class="s3">\n        </span><span class="s1">const data = this._pressData;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no press data.</span><span class="s3">\n        </span><span class="s1">if (!data) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle a row resize.</span><span class="s3">\n        </span><span class="s1">if (data.type === 'row-resize') {</span><span class="s3">\n            </span><span class="s1">let dy = event.clientY - data.clientY;</span><span class="s3">\n            </span><span class="s1">grid.resizeRow(data.region, data.index, data.size + dy);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle a column resize.</span><span class="s3">\n        </span><span class="s1">if (data.type === 'column-resize') {</span><span class="s3">\n            </span><span class="s1">let dx = event.clientX - data.clientX;</span><span class="s3">\n            </span><span class="s1">grid.resizeColumn(data.region, data.index, data.size + dx);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, it's a select.</span><span class="s3">\n        </span><span class="s1">// Mouse moves during a corner header press are a no-op.</span><span class="s3">\n        </span><span class="s1">if (data.region === 'corner-header') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if the selection model was removed.</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Map to local coordinates.</span><span class="s3">\n        </span><span class="s1">let { lx, ly } = grid.mapToLocal(event.clientX, event.clientY);</span><span class="s3">\n        </span><span class="s1">// Update the local mouse coordinates in the press data.</span><span class="s3">\n        </span><span class="s1">data.localX = lx;</span><span class="s3">\n        </span><span class="s1">data.localY = ly;</span><span class="s3">\n        </span><span class="s1">// Fetch the grid geometry.</span><span class="s3">\n        </span><span class="s1">let hw = grid.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = grid.headerHeight;</span><span class="s3">\n        </span><span class="s1">let vpw = grid.viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vph = grid.viewportHeight;</span><span class="s3">\n        </span><span class="s1">let sx = grid.scrollX;</span><span class="s3">\n        </span><span class="s1">let sy = grid.scrollY;</span><span class="s3">\n        </span><span class="s1">let msx = grid.maxScrollY;</span><span class="s3">\n        </span><span class="s1">let msy = grid.maxScrollY;</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Set up the timeout variable.</span><span class="s3">\n        </span><span class="s1">let timeout = -1;</span><span class="s3">\n        </span><span class="s1">// Compute the timemout based on hit region and mouse position.</span><span class="s3">\n        </span><span class="s1">if (data.region === 'row-header' || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">if (ly &lt; hh &amp;&amp; sy &gt; 0) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(hh - ly);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ly &gt;= vph &amp;&amp; sy &lt; msy) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(ly - vph);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (data.region === 'column-header' || mode === 'column') {</span><span class="s3">\n            </span><span class="s1">if (lx &lt; hw &amp;&amp; sx &gt; 0) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(hw - lx);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (lx &gt;= vpw &amp;&amp; sx &lt; msx) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(lx - vpw);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (lx &lt; hw &amp;&amp; sx &gt; 0) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(hw - lx);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (lx &gt;= vpw &amp;&amp; sx &lt; msx) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(lx - vpw);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ly &lt; hh &amp;&amp; sy &gt; 0) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(hh - ly);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ly &gt;= vph &amp;&amp; sy &lt; msy) {</span><span class="s3">\n                </span><span class="s1">timeout = Private$5.computeTimeout(ly - vph);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update or initiate the autoselect if needed.</span><span class="s3">\n        </span><span class="s1">if (timeout &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">if (data.timeout &lt; 0) {</span><span class="s3">\n                </span><span class="s1">data.timeout = timeout;</span><span class="s3">\n                </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">Private$5.autoselect(grid, data);</span><span class="s3">\n                </span><span class="s1">}, timeout);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">data.timeout = timeout;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, clear the autoselect timeout.</span><span class="s3">\n        </span><span class="s1">data.timeout = -1;</span><span class="s3">\n        </span><span class="s1">// Map the position to virtual coordinates.</span><span class="s3">\n        </span><span class="s1">let { vx, vy } = grid.mapToVirtual(event.clientX, event.clientY);</span><span class="s3">\n        </span><span class="s1">// Clamp the coordinates to the limits.</span><span class="s3">\n        </span><span class="s1">vx = Math.max(0, Math.min(vx, grid.bodyWidth - 1));</span><span class="s3">\n        </span><span class="s1">vy = Math.max(0, Math.min(vy, grid.bodyHeight - 1));</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1;</span><span class="s3">\n        </span><span class="s1">let c1;</span><span class="s3">\n        </span><span class="s1">let r2;</span><span class="s3">\n        </span><span class="s1">let c2;</span><span class="s3">\n        </span><span class="s1">let cursorRow = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let cursorColumn = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let clear = 'current';</span><span class="s3">\n        </span><span class="s1">// Compute the selection based pressed region.</span><span class="s3">\n        </span><span class="s1">if (data.region === 'row-header' || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">r1 = data.row;</span><span class="s3">\n            </span><span class="s1">r2 = grid.rowAt('body', vy);</span><span class="s3">\n            </span><span class="s1">const selectionGroup = { r1: r1, c1: 0, r2: r2, c2: 0 };</span><span class="s3">\n            </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['row-header', 'body'], 'row', selectionGroup);</span><span class="s3">\n            </span><span class="s1">// Check if there are any merges</span><span class="s3">\n            </span><span class="s1">if (joinedGroup.r1 != Number.MAX_VALUE) {</span><span class="s3">\n                </span><span class="s1">r1 = Math.min(r1, joinedGroup.r1);</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(r2, joinedGroup.r2);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">c1 = 0;</span><span class="s3">\n            </span><span class="s1">c2 = Infinity;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (data.region === 'column-header' || mode === 'column') {</span><span class="s3">\n            </span><span class="s1">r1 = 0;</span><span class="s3">\n            </span><span class="s1">r2 = Infinity;</span><span class="s3">\n            </span><span class="s1">c1 = data.column;</span><span class="s3">\n            </span><span class="s1">c2 = grid.columnAt('body', vx);</span><span class="s3">\n            </span><span class="s1">const selectionGroup = { r1: 0, c1: c1, r2: 0, c2: c2 };</span><span class="s3">\n            </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupsIntersectingAtAxis(grid.dataModel, ['column-header', 'body'], 'column', selectionGroup);</span><span class="s3">\n            </span><span class="s1">// Check if there are any merges</span><span class="s3">\n            </span><span class="s1">if (joinedGroup.c1 != Number.MAX_VALUE) {</span><span class="s3">\n                </span><span class="s1">c1 = joinedGroup.c1;</span><span class="s3">\n                </span><span class="s1">c2 = joinedGroup.c2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r1 = cursorRow;</span><span class="s3">\n            </span><span class="s1">r2 = grid.rowAt('body', vy);</span><span class="s3">\n            </span><span class="s1">c1 = cursorColumn;</span><span class="s3">\n            </span><span class="s1">c2 = grid.columnAt('body', vx);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Make the selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse up event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse up event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseUp(grid, event) {</span><span class="s3">\n        </span><span class="s1">this.release();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the mouse double click event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The mouse up event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onMouseDoubleClick(grid, event) {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">if (!grid.dataModel) {</span><span class="s3">\n            </span><span class="s1">this.release();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Unpack the event.</span><span class="s3">\n        </span><span class="s1">let { clientX, clientY } = event;</span><span class="s3">\n        </span><span class="s1">// Hit test the grid.</span><span class="s3">\n        </span><span class="s1">let hit = grid.hitTest(clientX, clientY);</span><span class="s3">\n        </span><span class="s1">// Unpack the hit test.</span><span class="s3">\n        </span><span class="s1">let { region, row, column } = hit;</span><span class="s3">\n        </span><span class="s1">if (region === 'void') {</span><span class="s3">\n            </span><span class="s1">this.release();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (region === 'column-header' || region === 'corner-header') {</span><span class="s3">\n            </span><span class="s1">// Convert the hit test into a part.</span><span class="s3">\n            </span><span class="s1">const handle = Private$5.resizeHandleForHitTest(hit);</span><span class="s3">\n            </span><span class="s1">if (handle === 'left' || handle === 'right') {</span><span class="s3">\n                </span><span class="s1">let colIndex = handle === 'left' ? column - 1 : column;</span><span class="s3">\n                </span><span class="s1">let colRegion = region === 'column-header' ? 'body' : 'row-header';</span><span class="s3">\n                </span><span class="s1">if (colIndex &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">if (region === 'column-header') {</span><span class="s3">\n                        </span><span class="s1">// If the column is -1, it means we are in the corner header</span><span class="s3">\n                        </span><span class="s1">colIndex = grid.dataModel.columnCount('row-header') - 1;</span><span class="s3">\n                        </span><span class="s1">colRegion = 'row-header';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// If we are on the left edge of the row header, do nothing</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const cs = (_a = grid.selectionModel) === null || _a === void 0 ? void 0 : _a.currentSelection();</span><span class="s3">\n                </span><span class="s1">const cv = grid.currentViewport;</span><span class="s3">\n                </span><span class="s1">const rowCount = (_c = (_b = grid.selectionModel) === null || _b === void 0 ? void 0 : _b.dataModel.rowCount('body')) !== null &amp;&amp; _c !== void 0 ? _c : 0;</span><span class="s3">\n                </span><span class="s1">if (colRegion == 'body' &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">cs != null &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">cv != null &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">cs.r1 == 0 &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">cs.r2 == rowCount - 1) {</span><span class="s3">\n                    </span><span class="s1">// One or more columns are selected</span><span class="s3">\n                    </span><span class="s1">let c1 = Math.max(Math.min(cs.c1, cs.c2), cv.firstColumn);</span><span class="s3">\n                    </span><span class="s1">let c2 = Math.min(Math.max(cs.c1, cs.c2), cv.lastColumn);</span><span class="s3">\n                    </span><span class="s1">if (c1 &lt;= colIndex &amp;&amp; colIndex &lt;= c2) {</span><span class="s3">\n                        </span><span class="s1">// When we double-click one of the selected column headers, resize all visible selected columns.</span><span class="s3">\n                        </span><span class="s1">for (let ci = c1; ci &lt;= c2; ci++) {</span><span class="s3">\n                            </span><span class="s1">grid.resizeColumn(colRegion, ci, null);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// When we double-click the column header outside the selection, resize only the clicked column.</span><span class="s3">\n                        </span><span class="s1">grid.resizeColumn(colRegion, colIndex, null);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// When no columns are selected, resize only the clicked column.</span><span class="s3">\n                    </span><span class="s1">grid.resizeColumn(colRegion, colIndex, null);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">if (grid.editable) {</span><span class="s3">\n                </span><span class="s1">const cell = {</span><span class="s3">\n                    </span><span class="s1">grid: grid,</span><span class="s3">\n                    </span><span class="s1">row: row,</span><span class="s3">\n                    </span><span class="s1">column: column</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">grid.editorController.edit(cell);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.release();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the context menu event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The context menu event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onContextMenu(grid, event) {</span><span class="s3">\n        </span><span class="s1">// TODO support user-defined context menus</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the wheel event for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The data grid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The wheel event of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onWheel(grid, event) {</span><span class="s3">\n        </span><span class="s1">// Bail if a mouse press is in progress.</span><span class="s3">\n        </span><span class="s1">if (this._pressData) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Extract the delta X and Y movement.</span><span class="s3">\n        </span><span class="s1">let dx = event.deltaX;</span><span class="s3">\n        </span><span class="s1">let dy = event.deltaY;</span><span class="s3">\n        </span><span class="s1">// Convert the delta values to pixel values.</span><span class="s3">\n        </span><span class="s1">switch (event.deltaMode) {</span><span class="s3">\n            </span><span class="s1">case 0: // DOM_DELTA_PIXEL</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 1: {</span><span class="s3">\n                </span><span class="s1">// DOM_DELTA_LINE</span><span class="s3">\n                </span><span class="s1">let ds = grid.defaultSizes;</span><span class="s3">\n                </span><span class="s1">dx *= ds.columnWidth;</span><span class="s3">\n                </span><span class="s1">dy *= ds.rowHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 2: // DOM_DELTA_PAGE</span><span class="s3">\n                </span><span class="s1">dx *= grid.pageWidth;</span><span class="s3">\n                </span><span class="s1">dy *= grid.pageHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Only scroll and stop the event propagation if needed.</span><span class="s3">\n        </span><span class="s1">if (</span><span class="s3">\n        </span><span class="s1">// Scrolling left and not reached min already</span><span class="s3">\n        </span><span class="s1">(dx &lt; 0 &amp;&amp; grid.scrollX !== 0) ||</span><span class="s3">\n            </span><span class="s1">// Scrolling right and not reached max already</span><span class="s3">\n            </span><span class="s1">(dx &gt; 0 &amp;&amp; grid.scrollX !== grid.maxScrollX) ||</span><span class="s3">\n            </span><span class="s1">// Scrolling top and not reached min already</span><span class="s3">\n            </span><span class="s1">(dy &lt; 0 &amp;&amp; grid.scrollY !== 0) ||</span><span class="s3">\n            </span><span class="s1">// Scrolling down and not reached max already</span><span class="s3">\n            </span><span class="s1">(dy &gt; 0 &amp;&amp; grid.scrollY !== grid.maxScrollY)) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">// Scroll by the desired amount.</span><span class="s3">\n            </span><span class="s1">grid.scrollBy(dx, dy);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Convert a resize handle into a cursor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cursorForHandle(handle) {</span><span class="s3">\n        </span><span class="s1">return Private$5.cursorMap[handle];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the current pressData</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get pressData() {</span><span class="s3">\n        </span><span class="s1">return this._pressData;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$5;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a CellConfig object from a hit region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function createCellConfigObject(grid, hit) {</span><span class="s3">\n        </span><span class="s1">const { region, row, column } = hit;</span><span class="s3">\n        </span><span class="s1">// Terminate call if region is void.</span><span class="s3">\n        </span><span class="s1">if (region === 'void') {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Augment hit region params with value and metadata.</span><span class="s3">\n        </span><span class="s1">const value = grid.dataModel.data(region, row, column);</span><span class="s3">\n        </span><span class="s1">const metadata = grid.dataModel.metadata(region, row, column);</span><span class="s3">\n        </span><span class="s1">// Create cell config object to retrieve cell renderer.</span><span class="s3">\n        </span><span class="s1">const config = {</span><span class="s3">\n            </span><span class="s1">...hit,</span><span class="s3">\n            </span><span class="s1">value: value,</span><span class="s3">\n            </span><span class="s1">metadata: metadata</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return config;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.createCellConfigObject = createCellConfigObject;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the resize handle for a grid hit test.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function resizeHandleForHitTest(hit) {</span><span class="s3">\n        </span><span class="s1">// Fetch the row and column.</span><span class="s3">\n        </span><span class="s1">let r = hit.row;</span><span class="s3">\n        </span><span class="s1">let c = hit.column;</span><span class="s3">\n        </span><span class="s1">// Fetch the leading and trailing sizes.</span><span class="s3">\n        </span><span class="s1">let lw = hit.x;</span><span class="s3">\n        </span><span class="s1">let lh = hit.y;</span><span class="s3">\n        </span><span class="s1">let tw = hit.width - hit.x;</span><span class="s3">\n        </span><span class="s1">let th = hit.height - hit.y;</span><span class="s3">\n        </span><span class="s1">// Set up the result variable.</span><span class="s3">\n        </span><span class="s1">let result;</span><span class="s3">\n        </span><span class="s1">// Dispatch based on hit test region.</span><span class="s3">\n        </span><span class="s1">switch (hit.region) {</span><span class="s3">\n            </span><span class="s1">case 'corner-header':</span><span class="s3">\n                </span><span class="s1">if (c &gt; 0 &amp;&amp; lw &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'left';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (tw &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'right';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (r &gt; 0 &amp;&amp; lh &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'top';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (th &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'bottom';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">result = 'none';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column-header':</span><span class="s3">\n                </span><span class="s1">if (c &gt; 0 &amp;&amp; lw &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'left';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (tw &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'right';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (r &gt; 0 &amp;&amp; lh &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'top';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (th &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'bottom';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">result = 'none';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row-header':</span><span class="s3">\n                </span><span class="s1">if (c &gt; 0 &amp;&amp; lw &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'left';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (tw &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'right';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (r &gt; 0 &amp;&amp; lh &lt;= 5) {</span><span class="s3">\n                    </span><span class="s1">result = 'top';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (th &lt;= 6) {</span><span class="s3">\n                    </span><span class="s1">result = 'bottom';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">result = 'none';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'body':</span><span class="s3">\n                </span><span class="s1">result = 'none';</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'void':</span><span class="s3">\n                </span><span class="s1">result = 'none';</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the result.</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.resizeHandleForHitTest = resizeHandleForHitTest;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A timer callback for the autoselect loop.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param grid - The datagrid of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param data - The select data of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function autoselect(grid, data) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the timeout has been reset.</span><span class="s3">\n        </span><span class="s1">if (data.timeout &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = grid.selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if the selection model has been removed.</span><span class="s3">\n        </span><span class="s1">if (!model) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the current selection.</span><span class="s3">\n        </span><span class="s1">let cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no current selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch local X and Y coordinates of the mouse.</span><span class="s3">\n        </span><span class="s1">let lx = data.localX;</span><span class="s3">\n        </span><span class="s1">let ly = data.localY;</span><span class="s3">\n        </span><span class="s1">// Set up the selection variables.</span><span class="s3">\n        </span><span class="s1">let r1 = cs.r1;</span><span class="s3">\n        </span><span class="s1">let c1 = cs.c1;</span><span class="s3">\n        </span><span class="s1">let r2 = cs.r2;</span><span class="s3">\n        </span><span class="s1">let c2 = cs.c2;</span><span class="s3">\n        </span><span class="s1">let cursorRow = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let cursorColumn = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">let clear = 'current';</span><span class="s3">\n        </span><span class="s1">// Fetch the grid geometry.</span><span class="s3">\n        </span><span class="s1">let hw = grid.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = grid.headerHeight;</span><span class="s3">\n        </span><span class="s1">let vpw = grid.viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vph = grid.viewportHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = model.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Update the selection based on the hit region.</span><span class="s3">\n        </span><span class="s1">if (data.region === 'row-header' || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">r2 += ly &lt;= hh ? -1 : ly &gt;= vph ? 1 : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (data.region === 'column-header' || mode === 'column') {</span><span class="s3">\n            </span><span class="s1">c2 += lx &lt;= hw ? -1 : lx &gt;= vpw ? 1 : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">r2 += ly &lt;= hh ? -1 : ly &gt;= vph ? 1 : 0;</span><span class="s3">\n            </span><span class="s1">c2 += lx &lt;= hw ? -1 : lx &gt;= vpw ? 1 : 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the current selection.</span><span class="s3">\n        </span><span class="s1">model.select({ r1, c1, r2, c2, cursorRow, cursorColumn, clear });</span><span class="s3">\n        </span><span class="s1">// Re-fetch the current selection.</span><span class="s3">\n        </span><span class="s1">cs = model.currentSelection();</span><span class="s3">\n        </span><span class="s1">// Bail if there is no selection.</span><span class="s3">\n        </span><span class="s1">if (!cs) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll the grid based on the hit region.</span><span class="s3">\n        </span><span class="s1">if (data.region === 'row-header' || mode === 'row') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToRow(cs.r2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (data.region === 'column-header' || mode == 'column') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToColumn(cs.c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (mode === 'cell') {</span><span class="s3">\n            </span><span class="s1">grid.scrollToCell(cs.r2, cs.c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Schedule the next call with the current timeout.</span><span class="s3">\n        </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n            </span><span class="s1">autoselect(grid, data);</span><span class="s3">\n        </span><span class="s1">}, data.timeout);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.autoselect = autoselect;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute the scroll timeout for the given delta distance.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param delta - The delta pixels from the origin.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The scaled timeout in milliseconds.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function computeTimeout(delta) {</span><span class="s3">\n        </span><span class="s1">return 5 + 120 * (1 - Math.min(128, Math.abs(delta)) / 128);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.computeTimeout = computeTimeout;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A mapping of resize handle to cursor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.cursorMap = {</span><span class="s3">\n        </span><span class="s1">top: 'ns-resize',</span><span class="s3">\n        </span><span class="s1">left: 'ew-resize',</span><span class="s3">\n        </span><span class="s1">right: 'ew-resize',</span><span class="s3">\n        </span><span class="s1">bottom: 'ns-resize',</span><span class="s3">\n        </span><span class="s1">hyperlink: 'pointer',</span><span class="s3">\n        </span><span class="s1">none: 'default'</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">})(Private$5 || (Private$5 = {}));</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A base class for creating data grid selection models.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* If the predefined selection models are insufficient for a particular</span><span class="s3">\n </span><span class="s1">* use case, a custom model can be defined which derives from this class.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SelectionModel {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new selection model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this._changed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._selectionMode = 'cell';</span><span class="s3">\n        </span><span class="s1">this.dataModel = options.dataModel;</span><span class="s3">\n        </span><span class="s1">this._selectionMode = options.selectionMode || 'cell';</span><span class="s3">\n        </span><span class="s1">this.dataModel.changed.connect(this.onDataModelChanged, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal emitted when the selection model has changed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get changed() {</span><span class="s3">\n        </span><span class="s1">return this._changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the selection mode for the model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get selectionMode() {</span><span class="s3">\n        </span><span class="s1">return this._selectionMode;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the selection mode for the model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This will clear the selection model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set selectionMode(value) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the mode does not change.</span><span class="s3">\n        </span><span class="s1">if (this._selectionMode === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal mode.</span><span class="s3">\n        </span><span class="s1">this._selectionMode = value;</span><span class="s3">\n        </span><span class="s1">// Clear the current selections.</span><span class="s3">\n        </span><span class="s1">this.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether any selection intersects a row.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The row index of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Whether any selection intersects the row.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method may be reimplemented in a subclass.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isRowSelected(index) {</span><span class="s3">\n        </span><span class="s1">return some(this.selections(), s =&gt; Private$4.containsRow(s, index));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether any selection intersects a column.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The column index of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Whether any selection intersects the column.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method may be reimplemented in a subclass.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isColumnSelected(index) {</span><span class="s3">\n        </span><span class="s1">return some(this.selections(), s =&gt; Private$4.containsColumn(s, index));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether any selection intersects a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Whether any selection intersects the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method may be reimplemented in a subclass.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isCellSelected(row, column) {</span><span class="s3">\n        </span><span class="s1">return some(this.selections(), s =&gt; Private$4.containsCell(s, row, column));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal handler for the data model `changed` signal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param args - The arguments for the signal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* Selection model implementations should update their selections</span><span class="s3">\n     </span><span class="s1">* in a manner that is relevant for the changes to the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The default implementation of this method is a no-op.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onDataModelChanged(sender, args) {</span><span class="s3">\n        </span><span class="s1">// pass</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Emit the `changed` signal for the selection model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* Subclasses should call this method whenever the selection model</span><span class="s3">\n     </span><span class="s1">* has changed so that attached data grids can update themselves.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">emitChanged() {</span><span class="s3">\n        </span><span class="s1">this._changed.emit(undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$4;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether a selection contains a given row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function containsRow(selection, row) {</span><span class="s3">\n        </span><span class="s1">let { r1, r2 } = selection;</span><span class="s3">\n        </span><span class="s1">return (row &gt;= r1 &amp;&amp; row &lt;= r2) || (row &gt;= r2 &amp;&amp; row &lt;= r1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.containsRow = containsRow;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether a selection contains a given column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function containsColumn(selection, column) {</span><span class="s3">\n        </span><span class="s1">let { c1, c2 } = selection;</span><span class="s3">\n        </span><span class="s1">return (column &gt;= c1 &amp;&amp; column &lt;= c2) || (column &gt;= c2 &amp;&amp; column &lt;= c1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.containsColumn = containsColumn;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Test whether a selection contains a given cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function containsCell(selection, row, column) {</span><span class="s3">\n        </span><span class="s1">return containsRow(selection, row) &amp;&amp; containsColumn(selection, column);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.containsCell = containsCell;</span><span class="s3">\n</span><span class="s1">})(Private$4 || (Private$4 = {}));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A basic selection model implementation.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This selection model is sufficient for most use cases where</span><span class="s3">\n </span><span class="s1">* structural knowledge of the data source is *not* required.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BasicSelectionModel extends SelectionModel {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this._cursorRow = -1;</span><span class="s3">\n        </span><span class="s1">this._cursorColumn = -1;</span><span class="s3">\n        </span><span class="s1">this._cursorRectIndex = -1;</span><span class="s3">\n        </span><span class="s1">this._selections = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the selection model is empty.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isEmpty() {</span><span class="s3">\n        </span><span class="s1">return this._selections.length === 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The row index of the cursor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cursorRow() {</span><span class="s3">\n        </span><span class="s1">return this._cursorRow;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The column index of the cursor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cursorColumn() {</span><span class="s3">\n        </span><span class="s1">return this._cursorColumn;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Move cursor down/up/left/right while making sure it remains</span><span class="s3">\n     </span><span class="s1">* within the bounds of selected rectangles</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param direction - The direction of the movement.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveCursorWithinSelections(direction) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections or no existing cursor</span><span class="s3">\n        </span><span class="s1">if (this.isEmpty || this.cursorRow === -1 || this._cursorColumn === -1) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if only single cell is selected</span><span class="s3">\n        </span><span class="s1">const firstSelection = this._selections[0];</span><span class="s3">\n        </span><span class="s1">if (this._selections.length === 1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">firstSelection.r1 === firstSelection.r2 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">firstSelection.c1 === firstSelection.c2) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// start from last selection rectangle</span><span class="s3">\n        </span><span class="s1">if (this._cursorRectIndex === -1) {</span><span class="s3">\n            </span><span class="s1">this._cursorRectIndex = this._selections.length - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let cursorRect = this._selections[this._cursorRectIndex];</span><span class="s3">\n        </span><span class="s1">const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;</span><span class="s3">\n        </span><span class="s1">const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;</span><span class="s3">\n        </span><span class="s1">let newRow = this._cursorRow + dr;</span><span class="s3">\n        </span><span class="s1">let newColumn = this._cursorColumn + dc;</span><span class="s3">\n        </span><span class="s1">const r1 = Math.min(cursorRect.r1, cursorRect.r2);</span><span class="s3">\n        </span><span class="s1">const r2 = Math.max(cursorRect.r1, cursorRect.r2);</span><span class="s3">\n        </span><span class="s1">const c1 = Math.min(cursorRect.c1, cursorRect.c2);</span><span class="s3">\n        </span><span class="s1">const c2 = Math.max(cursorRect.c1, cursorRect.c2);</span><span class="s3">\n        </span><span class="s1">const moveToNextRect = () =&gt; {</span><span class="s3">\n            </span><span class="s1">this._cursorRectIndex =</span><span class="s3">\n                </span><span class="s1">(this._cursorRectIndex + 1) % this._selections.length;</span><span class="s3">\n            </span><span class="s1">cursorRect = this._selections[this._cursorRectIndex];</span><span class="s3">\n            </span><span class="s1">newRow = Math.min(cursorRect.r1, cursorRect.r2);</span><span class="s3">\n            </span><span class="s1">newColumn = Math.min(cursorRect.c1, cursorRect.c2);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const moveToPreviousRect = () =&gt; {</span><span class="s3">\n            </span><span class="s1">this._cursorRectIndex =</span><span class="s3">\n                </span><span class="s1">this._cursorRectIndex === 0</span><span class="s3">\n                    </span><span class="s1">? this._selections.length - 1</span><span class="s3">\n                    </span><span class="s1">: this._cursorRectIndex - 1;</span><span class="s3">\n            </span><span class="s1">cursorRect = this._selections[this._cursorRectIndex];</span><span class="s3">\n            </span><span class="s1">newRow = Math.max(cursorRect.r1, cursorRect.r2);</span><span class="s3">\n            </span><span class="s1">newColumn = Math.max(cursorRect.c1, cursorRect.c2);</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (newRow &gt; r2) {</span><span class="s3">\n            </span><span class="s1">newRow = r1;</span><span class="s3">\n            </span><span class="s1">newColumn += 1;</span><span class="s3">\n            </span><span class="s1">if (newColumn &gt; c2) {</span><span class="s3">\n                </span><span class="s1">moveToNextRect();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (newRow &lt; r1) {</span><span class="s3">\n            </span><span class="s1">newRow = r2;</span><span class="s3">\n            </span><span class="s1">newColumn -= 1;</span><span class="s3">\n            </span><span class="s1">if (newColumn &lt; c1) {</span><span class="s3">\n                </span><span class="s1">moveToPreviousRect();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (newColumn &gt; c2) {</span><span class="s3">\n            </span><span class="s1">newColumn = c1;</span><span class="s3">\n            </span><span class="s1">newRow += 1;</span><span class="s3">\n            </span><span class="s1">if (newRow &gt; r2) {</span><span class="s3">\n                </span><span class="s1">moveToNextRect();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (newColumn &lt; c1) {</span><span class="s3">\n            </span><span class="s1">newColumn = c2;</span><span class="s3">\n            </span><span class="s1">newRow -= 1;</span><span class="s3">\n            </span><span class="s1">if (newRow &lt; r1) {</span><span class="s3">\n                </span><span class="s1">moveToPreviousRect();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._cursorRow = newRow;</span><span class="s3">\n        </span><span class="s1">this._cursorColumn = newColumn;</span><span class="s3">\n        </span><span class="s1">// Emit the changed signal.</span><span class="s3">\n        </span><span class="s1">this.emitChanged();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the current selection in the selection model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The current selection or `null`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This is the selection which holds the cursor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">currentSelection() {</span><span class="s3">\n        </span><span class="s1">return this._selections[this._selections.length - 1] || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get an iterator of the selections in the model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns A new iterator of the current selections.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* The data grid will render the selections in order.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">*selections() {</span><span class="s3">\n        </span><span class="s1">yield* this._selections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Select the specified cells.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param args - The arguments for the selection.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">select(args) {</span><span class="s3">\n        </span><span class="s1">// Fetch the current row and column counts;</span><span class="s3">\n        </span><span class="s1">let rowCount = this.dataModel.rowCount('body');</span><span class="s3">\n        </span><span class="s1">let columnCount = this.dataModel.columnCount('body');</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no content.</span><span class="s3">\n        </span><span class="s1">if (rowCount &lt;= 0 || columnCount &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Unpack the arguments.</span><span class="s3">\n        </span><span class="s1">let { r1, c1, r2, c2, cursorRow, cursorColumn, clear } = args;</span><span class="s3">\n        </span><span class="s1">// Clear the necessary selections.</span><span class="s3">\n        </span><span class="s1">if (clear === 'all') {</span><span class="s3">\n            </span><span class="s1">this._selections.length = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (clear === 'current') {</span><span class="s3">\n            </span><span class="s1">this._selections.pop();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp to the data model bounds.</span><span class="s3">\n        </span><span class="s1">r1 = Math.max(0, Math.min(r1, rowCount - 1));</span><span class="s3">\n        </span><span class="s1">r2 = Math.max(0, Math.min(r2, rowCount - 1));</span><span class="s3">\n        </span><span class="s1">c1 = Math.max(0, Math.min(c1, columnCount - 1));</span><span class="s3">\n        </span><span class="s1">c2 = Math.max(0, Math.min(c2, columnCount - 1));</span><span class="s3">\n        </span><span class="s1">// Indicate if a row/column has already been selected.</span><span class="s3">\n        </span><span class="s1">let alreadySelected = false;</span><span class="s3">\n        </span><span class="s1">// Handle the selection mode.</span><span class="s3">\n        </span><span class="s1">if (this.selectionMode === 'row') {</span><span class="s3">\n            </span><span class="s1">c1 = 0;</span><span class="s3">\n            </span><span class="s1">c2 = columnCount - 1;</span><span class="s3">\n            </span><span class="s1">alreadySelected =</span><span class="s3">\n                </span><span class="s1">this._selections.filter(selection =&gt; selection.r1 === r1).length !== 0;</span><span class="s3">\n            </span><span class="s1">// Remove from selections if already selected.</span><span class="s3">\n            </span><span class="s1">this._selections = alreadySelected</span><span class="s3">\n                </span><span class="s1">? this._selections.filter(selection =&gt; selection.r1 !== r1)</span><span class="s3">\n                </span><span class="s1">: this._selections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.selectionMode === 'column') {</span><span class="s3">\n            </span><span class="s1">r1 = 0;</span><span class="s3">\n            </span><span class="s1">r2 = rowCount - 1;</span><span class="s3">\n            </span><span class="s1">alreadySelected =</span><span class="s3">\n                </span><span class="s1">this._selections.filter(selection =&gt; selection.c1 === c1).length !== 0;</span><span class="s3">\n            </span><span class="s1">// Remove from selections if already selected.</span><span class="s3">\n            </span><span class="s1">this._selections = alreadySelected</span><span class="s3">\n                </span><span class="s1">? this._selections.filter(selection =&gt; selection.c1 !== c1)</span><span class="s3">\n                </span><span class="s1">: this._selections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Alias the cursor row and column.</span><span class="s3">\n        </span><span class="s1">let cr = cursorRow;</span><span class="s3">\n        </span><span class="s1">let cc = cursorColumn;</span><span class="s3">\n        </span><span class="s1">// Compute the new cursor location.</span><span class="s3">\n        </span><span class="s1">if (cr &lt; 0 || (cr &lt; r1 &amp;&amp; cr &lt; r2) || (cr &gt; r1 &amp;&amp; cr &gt; r2)) {</span><span class="s3">\n            </span><span class="s1">cr = r1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cc &lt; 0 || (cc &lt; c1 &amp;&amp; cc &lt; c2) || (cc &gt; c1 &amp;&amp; cc &gt; c2)) {</span><span class="s3">\n            </span><span class="s1">cc = c1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the cursor.</span><span class="s3">\n        </span><span class="s1">this._cursorRow = cr;</span><span class="s3">\n        </span><span class="s1">this._cursorColumn = cc;</span><span class="s3">\n        </span><span class="s1">this._cursorRectIndex = this._selections.length;</span><span class="s3">\n        </span><span class="s1">// Add the new selection if it wasn't already selected.</span><span class="s3">\n        </span><span class="s1">if (!alreadySelected) {</span><span class="s3">\n            </span><span class="s1">this._selections.push({ r1, c1, r2, c2 });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Emit the changed signal.</span><span class="s3">\n        </span><span class="s1">this.emitChanged();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clear all selections in the selection model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections.</span><span class="s3">\n        </span><span class="s1">if (this._selections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Reset the internal state.</span><span class="s3">\n        </span><span class="s1">this._cursorRow = -1;</span><span class="s3">\n        </span><span class="s1">this._cursorColumn = -1;</span><span class="s3">\n        </span><span class="s1">this._cursorRectIndex = -1;</span><span class="s3">\n        </span><span class="s1">this._selections.length = 0;</span><span class="s3">\n        </span><span class="s1">// Emit the changed signal.</span><span class="s3">\n        </span><span class="s1">this.emitChanged();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal handler for the data model `changed` signal.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param args - The arguments for the signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onDataModelChanged(sender, args) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the model has no current selections.</span><span class="s3">\n        </span><span class="s1">if (this._selections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the cells have changed in place.</span><span class="s3">\n        </span><span class="s1">if (args.type === 'cells-changed') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no change to the row or column count.</span><span class="s3">\n        </span><span class="s1">if (args.type === 'rows-moved' || args.type === 'columns-moved') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the last row and column index.</span><span class="s3">\n        </span><span class="s1">let lr = sender.rowCount('body') - 1;</span><span class="s3">\n        </span><span class="s1">let lc = sender.columnCount('body') - 1;</span><span class="s3">\n        </span><span class="s1">// Bail early if the data model is empty.</span><span class="s3">\n        </span><span class="s1">if (lr &lt; 0 || lc &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this._selections.length = 0;</span><span class="s3">\n            </span><span class="s1">this.emitChanged();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection mode.</span><span class="s3">\n        </span><span class="s1">let mode = this.selectionMode;</span><span class="s3">\n        </span><span class="s1">// Set up the assignment index variable.</span><span class="s3">\n        </span><span class="s1">let j = 0;</span><span class="s3">\n        </span><span class="s1">// Iterate over the current selections.</span><span class="s3">\n        </span><span class="s1">for (let i = 0, n = this._selections.length; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">// Unpack the selection.</span><span class="s3">\n            </span><span class="s1">let { r1, c1, r2, c2 } = this._selections[i];</span><span class="s3">\n            </span><span class="s1">// Skip the selection if it will disappear.</span><span class="s3">\n            </span><span class="s1">if ((lr &lt; r1 &amp;&amp; lr &lt; r2) || (lc &lt; c1 &amp;&amp; lc &lt; c2)) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Modify the bounds based on the selection mode.</span><span class="s3">\n            </span><span class="s1">if (mode === 'row') {</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, lr));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, lr));</span><span class="s3">\n                </span><span class="s1">c1 = 0;</span><span class="s3">\n                </span><span class="s1">c2 = lc;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (mode === 'column') {</span><span class="s3">\n                </span><span class="s1">r1 = 0;</span><span class="s3">\n                </span><span class="s1">r2 = lr;</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, lc));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, lc));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, lr));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, lr));</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, lc));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, lc));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Assign the modified selection to the array.</span><span class="s3">\n            </span><span class="s1">this._selections[j++] = { r1, c1, r2, c2 };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Remove the stale selections.</span><span class="s3">\n        </span><span class="s1">this._selections.length = j;</span><span class="s3">\n        </span><span class="s1">// Emit the changed signal.</span><span class="s3">\n        </span><span class="s1">this.emitChanged();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2023, Lumino Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which renders the cells of a data grid asynchronously.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* For performance reason, the datagrid only paints cells synchronously,</span><span class="s3">\n </span><span class="s1">* though if your cell renderer inherits from AsyncCellRenderer, you will</span><span class="s3">\n </span><span class="s1">* be able to do some asynchronous work prior to painting the cell.</span><span class="s3">\n </span><span class="s1">* See `ImageRenderer` for an example of an asynchronous renderer.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AsyncCellRenderer extends CellRenderer {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Jupyter Development Team.</span><span class="s3">\n </span><span class="s1">* Distributed under the terms of the Modified BSD License.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// default validation error message</span><span class="s3">\n</span><span class="s1">const DEFAULT_INVALID_INPUT_MESSAGE = 'Invalid input!';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cell input validator object which always returns valid.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class PassInputValidator {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Validate cell input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value - The cell value input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns An object with validation result.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate(cell, value) {</span><span class="s3">\n        </span><span class="s1">return { valid: true };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Text cell input validator.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TextInputValidator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Minimum text length</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no minimum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.minLength = Number.NaN;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Maximum text length</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no maximum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.maxLength = Number.NaN;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Required text pattern as regular expression</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is null, meaning no pattern constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.pattern = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Validate cell input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value - The cell value input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns An object with validation result.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate(cell, value) {</span><span class="s3">\n        </span><span class="s1">if (value === null) {</span><span class="s3">\n            </span><span class="s1">return { valid: true };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof value !== 'string') {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: 'Input must be valid text'</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.minLength) &amp;&amp; value.length &lt; this.minLength) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Text length must be greater than ${this.minLength}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.maxLength) &amp;&amp; value.length &gt; this.maxLength) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Text length must be less than ${this.maxLength}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.pattern &amp;&amp; !this.pattern.test(value)) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Text doesn't match the required pattern`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { valid: true };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Integer cell input validator.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class IntegerInputValidator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Minimum value</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no minimum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.min = Number.NaN;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Maximum value</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no maximum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.max = Number.NaN;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Validate cell input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value - The cell value input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns An object with validation result.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate(cell, value) {</span><span class="s3">\n        </span><span class="s1">if (value === null) {</span><span class="s3">\n            </span><span class="s1">return { valid: true };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isNaN(value) || value % 1 !== 0) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: 'Input must be valid integer'</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.min) &amp;&amp; value &lt; this.min) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Input must be greater than ${this.min}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.max) &amp;&amp; value &gt; this.max) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Input must be less than ${this.max}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { valid: true };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Real number cell input validator.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NumberInputValidator {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Minimum value</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no minimum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.min = Number.NaN;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Maximum value</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* The default is Number.NaN, meaning no maximum constraint</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.max = Number.NaN;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Validate cell input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value - The cell value input.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns An object with validation result.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate(cell, value) {</span><span class="s3">\n        </span><span class="s1">if (value === null) {</span><span class="s3">\n            </span><span class="s1">return { valid: true };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (isNaN(value)) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: 'Input must be valid number'</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.min) &amp;&amp; value &lt; this.min) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Input must be greater than ${this.min}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isNaN(this.max) &amp;&amp; value &gt; this.max) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">valid: false,</span><span class="s3">\n                </span><span class="s1">message: `Input must be less than ${this.max}`</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { valid: true };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An abstract base class that provides the most of the functionality</span><span class="s3">\n </span><span class="s1">* needed by a cell editor. All of the built-in cell editors</span><span class="s3">\n </span><span class="s1">* for various cell types are derived from this base class. Custom cell editors</span><span class="s3">\n </span><span class="s1">* can be easily implemented by extending this class.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class CellEditor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A signal emitted when input changes.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.inputChanged = new Signal(this);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Notification popup used to show validation error messages.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.validityNotification = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Whether the cell editor is disposed.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._disposed = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Whether the value input is valid.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._validInput = true;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Grid wheel event handler.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._gridWheelEventHandler = null;</span><span class="s3">\n        </span><span class="s1">this.inputChanged.connect(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.validate();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the cell editor is disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._disposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._gridWheelEventHandler) {</span><span class="s3">\n            </span><span class="s1">this.cell.grid.node.removeEventListener('wheel', this._gridWheelEventHandler);</span><span class="s3">\n            </span><span class="s1">this._gridWheelEventHandler = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._closeValidityNotification();</span><span class="s3">\n        </span><span class="s1">this._disposed = true;</span><span class="s3">\n        </span><span class="s1">this.cell.grid.node.removeChild(this.viewportOccluder);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The cell editing options.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">edit(cell, options) {</span><span class="s3">\n        </span><span class="s1">this.cell = cell;</span><span class="s3">\n        </span><span class="s1">this.onCommit = options &amp;&amp; options.onCommit;</span><span class="s3">\n        </span><span class="s1">this.onCancel = options &amp;&amp; options.onCancel;</span><span class="s3">\n        </span><span class="s1">this.validator =</span><span class="s3">\n            </span><span class="s1">options &amp;&amp; options.validator</span><span class="s3">\n                </span><span class="s1">? options.validator</span><span class="s3">\n                </span><span class="s1">: this.createValidatorBasedOnType();</span><span class="s3">\n        </span><span class="s1">this._gridWheelEventHandler = () =&gt; {</span><span class="s3">\n            </span><span class="s1">this._closeValidityNotification();</span><span class="s3">\n            </span><span class="s1">this.updatePosition();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">cell.grid.node.addEventListener('wheel', this._gridWheelEventHandler);</span><span class="s3">\n        </span><span class="s1">this._addContainer();</span><span class="s3">\n        </span><span class="s1">this.updatePosition();</span><span class="s3">\n        </span><span class="s1">this.startEditing();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cancel editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (this._disposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dispose();</span><span class="s3">\n        </span><span class="s1">if (this.onCancel) {</span><span class="s3">\n            </span><span class="s1">this.onCancel();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the value input is valid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get validInput() {</span><span class="s3">\n        </span><span class="s1">return this._validInput;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Validate the cell input. Shows validation error notification when input is invalid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validate() {</span><span class="s3">\n        </span><span class="s1">let value;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">value = this.getInput();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">console.log(`Input error: ${error.message}`);</span><span class="s3">\n            </span><span class="s1">this.setValidity(false, error.message || DEFAULT_INVALID_INPUT_MESSAGE);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.validator) {</span><span class="s3">\n            </span><span class="s1">const result = this.validator.validate(this.cell, value);</span><span class="s3">\n            </span><span class="s1">if (result.valid) {</span><span class="s3">\n                </span><span class="s1">this.setValidity(true);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.setValidity(false, result.message || DEFAULT_INVALID_INPUT_MESSAGE);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.setValidity(true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set validity flag.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param valid - Whether the input is valid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param message - Notification message to show.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If message is set to empty string (which is the default)</span><span class="s3">\n     </span><span class="s1">* existing notification popup is removed if any.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setValidity(valid, message = '') {</span><span class="s3">\n        </span><span class="s1">this._validInput = valid;</span><span class="s3">\n        </span><span class="s1">this._closeValidityNotification();</span><span class="s3">\n        </span><span class="s1">if (valid) {</span><span class="s3">\n            </span><span class="s1">this.editorContainer.classList.remove('lm-mod-invalid');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.editorContainer.classList.add('lm-mod-invalid');</span><span class="s3">\n            </span><span class="s1">// show a notification popup</span><span class="s3">\n            </span><span class="s1">if (message !== '') {</span><span class="s3">\n                </span><span class="s1">this.validityNotification = new CellEditor.Notification({</span><span class="s3">\n                    </span><span class="s1">target: this.editorContainer,</span><span class="s3">\n                    </span><span class="s1">message: message,</span><span class="s3">\n                    </span><span class="s1">placement: 'bottom',</span><span class="s3">\n                    </span><span class="s1">timeout: 5000</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">this.validityNotification.show();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create and return a cell input validator based on configuration of the</span><span class="s3">\n     </span><span class="s1">* cell being edited. If no suitable validator can be found, it returns undefined.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">createValidatorBasedOnType() {</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">switch (metadata &amp;&amp; metadata.type) {</span><span class="s3">\n            </span><span class="s1">case 'string':</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">const validator = new TextInputValidator();</span><span class="s3">\n                    </span><span class="s1">if (typeof metadata.format === 'string') {</span><span class="s3">\n                        </span><span class="s1">const format = metadata.format;</span><span class="s3">\n                        </span><span class="s1">switch (format) {</span><span class="s3">\n                            </span><span class="s1">case 'email':</span><span class="s3">\n                                </span><span class="s1">validator.pattern = new RegExp('^([a-z0-9_.-]+)@([da-z.-]+).([a-z.]{2,6})$');</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">case 'uuid':</span><span class="s3">\n                                </span><span class="s1">validator.pattern = new RegExp('[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}');</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (metadata.constraint) {</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.minLength !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.minLength = metadata.constraint.minLength;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.maxLength !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.maxLength = metadata.constraint.maxLength;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (typeof metadata.constraint.pattern === 'string') {</span><span class="s3">\n                            </span><span class="s1">validator.pattern = new RegExp(metadata.constraint.pattern);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return validator;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'number':</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">const validator = new NumberInputValidator();</span><span class="s3">\n                    </span><span class="s1">if (metadata.constraint) {</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.minimum !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.min = metadata.constraint.minimum;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.maximum !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.max = metadata.constraint.maximum;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return validator;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">case 'integer':</span><span class="s3">\n                </span><span class="s1">{</span><span class="s3">\n                    </span><span class="s1">const validator = new IntegerInputValidator();</span><span class="s3">\n                    </span><span class="s1">if (metadata.constraint) {</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.minimum !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.min = metadata.constraint.minimum;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (metadata.constraint.maximum !== undefined) {</span><span class="s3">\n                            </span><span class="s1">validator.max = metadata.constraint.maximum;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return validator;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Compute cell rectangle and return with other cell properties.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getCellInfo(cell) {</span><span class="s3">\n        </span><span class="s1">const { grid, row, column } = cell;</span><span class="s3">\n        </span><span class="s1">let data, columnX, rowY, width, height;</span><span class="s3">\n        </span><span class="s1">const cellGroup = CellGroup.getGroup(grid.dataModel, 'body', row, column);</span><span class="s3">\n        </span><span class="s1">if (cellGroup) {</span><span class="s3">\n            </span><span class="s1">columnX =</span><span class="s3">\n                </span><span class="s1">grid.headerWidth -</span><span class="s3">\n                    </span><span class="s1">grid.scrollX +</span><span class="s3">\n                    </span><span class="s1">grid.columnOffset('body', cellGroup.c1);</span><span class="s3">\n            </span><span class="s1">rowY =</span><span class="s3">\n                </span><span class="s1">grid.headerHeight - grid.scrollY + grid.rowOffset('body', cellGroup.r1);</span><span class="s3">\n            </span><span class="s1">width = 0;</span><span class="s3">\n            </span><span class="s1">height = 0;</span><span class="s3">\n            </span><span class="s1">for (let r = cellGroup.r1; r &lt;= cellGroup.r2; r++) {</span><span class="s3">\n                </span><span class="s1">height += grid.rowSize('body', r);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let c = cellGroup.c1; c &lt;= cellGroup.c2; c++) {</span><span class="s3">\n                </span><span class="s1">width += grid.columnSize('body', c);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">data = grid.dataModel.data('body', cellGroup.r1, cellGroup.c1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">columnX =</span><span class="s3">\n                </span><span class="s1">grid.headerWidth - grid.scrollX + grid.columnOffset('body', column);</span><span class="s3">\n            </span><span class="s1">rowY = grid.headerHeight - grid.scrollY + grid.rowOffset('body', row);</span><span class="s3">\n            </span><span class="s1">width = grid.columnSize('body', column);</span><span class="s3">\n            </span><span class="s1">height = grid.rowSize('body', row);</span><span class="s3">\n            </span><span class="s1">data = grid.dataModel.data('body', row, column);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">grid: grid,</span><span class="s3">\n            </span><span class="s1">row: row,</span><span class="s3">\n            </span><span class="s1">column: column,</span><span class="s3">\n            </span><span class="s1">data: data,</span><span class="s3">\n            </span><span class="s1">x: columnX,</span><span class="s3">\n            </span><span class="s1">y: rowY,</span><span class="s3">\n            </span><span class="s1">width: width,</span><span class="s3">\n            </span><span class="s1">height: height</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reposition cell editor by moving viewport occluder and cell editor container.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updatePosition() {</span><span class="s3">\n        </span><span class="s1">const grid = this.cell.grid;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(this.cell);</span><span class="s3">\n        </span><span class="s1">const headerHeight = grid.headerHeight;</span><span class="s3">\n        </span><span class="s1">const headerWidth = grid.headerWidth;</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.style.top = headerHeight + 'px';</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.style.left = headerWidth + 'px';</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.style.width = grid.viewportWidth - headerWidth + 'px';</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.style.height =</span><span class="s3">\n            </span><span class="s1">grid.viewportHeight - headerHeight + 'px';</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.style.position = 'absolute';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.left = cellInfo.x - 1 - headerWidth + 'px';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.top = cellInfo.y - 1 - headerHeight + 'px';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.width = cellInfo.width + 1 + 'px';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.height = cellInfo.height + 1 + 'px';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.visibility = 'visible';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.position = 'absolute';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Commit the edited value.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cursorMovement - Cursor move direction based on keys pressed to end the edit.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns true on valid input, false otherwise.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">commit(cursorMovement = 'none') {</span><span class="s3">\n        </span><span class="s1">this.validate();</span><span class="s3">\n        </span><span class="s1">if (!this._validInput) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let value;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">value = this.getInput();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (error) {</span><span class="s3">\n            </span><span class="s1">console.log(`Input error: ${error.message}`);</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dispose();</span><span class="s3">\n        </span><span class="s1">if (this.onCommit) {</span><span class="s3">\n            </span><span class="s1">this.onCommit({</span><span class="s3">\n                </span><span class="s1">cell: this.cell,</span><span class="s3">\n                </span><span class="s1">value: value,</span><span class="s3">\n                </span><span class="s1">cursorMovement: cursorMovement</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create container elements needed to prevent editor widget overflow</span><span class="s3">\n     </span><span class="s1">* beyond viewport and to position cell editor widget.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_addContainer() {</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder = document.createElement('div');</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.className = 'lm-DataGrid-cellEditorOccluder';</span><span class="s3">\n        </span><span class="s1">this.cell.grid.node.appendChild(this.viewportOccluder);</span><span class="s3">\n        </span><span class="s1">this.editorContainer = document.createElement('div');</span><span class="s3">\n        </span><span class="s1">this.editorContainer.className = 'lm-DataGrid-cellEditorContainer';</span><span class="s3">\n        </span><span class="s1">this.viewportOccluder.appendChild(this.editorContainer);</span><span class="s3">\n        </span><span class="s1">// update mouse event pass-through state based on input validity</span><span class="s3">\n        </span><span class="s1">this.editorContainer.addEventListener('mouseleave', (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.viewportOccluder.style.pointerEvents = this._validInput</span><span class="s3">\n                </span><span class="s1">? 'none'</span><span class="s3">\n                </span><span class="s1">: 'auto';</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.editorContainer.addEventListener('mouseenter', (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">this.viewportOccluder.style.pointerEvents = 'none';</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove validity notification popup.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_closeValidityNotification() {</span><span class="s3">\n        </span><span class="s1">if (this.validityNotification) {</span><span class="s3">\n            </span><span class="s1">this.validityNotification.close();</span><span class="s3">\n            </span><span class="s1">this.validityNotification = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Abstract base class with shared functionality</span><span class="s3">\n </span><span class="s1">* for cell editors which use HTML Input widget as editor.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class InputCellEditor extends CellEditor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the DOM events for the editor.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The DOM event sent to the editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">switch (event.type) {</span><span class="s3">\n            </span><span class="s1">case 'keydown':</span><span class="s3">\n                </span><span class="s1">this._onKeyDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'blur':</span><span class="s3">\n                </span><span class="s1">this._onBlur(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'input':</span><span class="s3">\n                </span><span class="s1">this._onInput(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._unbindEvents();</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">this.createWidget();</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(cell);</span><span class="s3">\n        </span><span class="s1">this.input.value = this.deserialize(cellInfo.data);</span><span class="s3">\n        </span><span class="s1">this.editorContainer.appendChild(this.input);</span><span class="s3">\n        </span><span class="s1">this.input.focus();</span><span class="s3">\n        </span><span class="s1">this.input.select();</span><span class="s3">\n        </span><span class="s1">this.bindEvents();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">deserialize(value) {</span><span class="s3">\n        </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n            </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createWidget() {</span><span class="s3">\n        </span><span class="s1">const input = document.createElement('input');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorWidget');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorInput');</span><span class="s3">\n        </span><span class="s1">input.spellcheck = false;</span><span class="s3">\n        </span><span class="s1">input.type = this.inputType;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bindEvents() {</span><span class="s3">\n        </span><span class="s1">this.input.addEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this.input.addEventListener('blur', this);</span><span class="s3">\n        </span><span class="s1">this.input.addEventListener('input', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_unbindEvents() {</span><span class="s3">\n        </span><span class="s1">this.input.removeEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this.input.removeEventListener('blur', this);</span><span class="s3">\n        </span><span class="s1">this.input.removeEventListener('input', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.cancel();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onBlur(event) {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.commit()) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this.input.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onInput(event) {</span><span class="s3">\n        </span><span class="s1">this.inputChanged.emit(void 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for text cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TextCellEditor extends InputCellEditor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.inputType = 'text';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current text input entered.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">return this.input.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for real number cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class NumberCellEditor extends InputCellEditor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.inputType = 'number';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">super.startEditing();</span><span class="s3">\n        </span><span class="s1">this.input.step = 'any';</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">const constraint = metadata.constraint;</span><span class="s3">\n        </span><span class="s1">if (constraint) {</span><span class="s3">\n            </span><span class="s1">if (constraint.minimum) {</span><span class="s3">\n                </span><span class="s1">this.input.min = constraint.minimum;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (constraint.maximum) {</span><span class="s3">\n                </span><span class="s1">this.input.max = constraint.maximum;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current number input entered. This method throws exception</span><span class="s3">\n     </span><span class="s1">* if input is invalid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">let value = this.input.value;</span><span class="s3">\n        </span><span class="s1">if (value.trim() === '') {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const floatValue = parseFloat(value);</span><span class="s3">\n        </span><span class="s1">if (isNaN(floatValue)) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid input');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return floatValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for integer cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class IntegerCellEditor extends InputCellEditor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this.inputType = 'number';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">super.startEditing();</span><span class="s3">\n        </span><span class="s1">this.input.step = '1';</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">const constraint = metadata.constraint;</span><span class="s3">\n        </span><span class="s1">if (constraint) {</span><span class="s3">\n            </span><span class="s1">if (constraint.minimum) {</span><span class="s3">\n                </span><span class="s1">this.input.min = constraint.minimum;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (constraint.maximum) {</span><span class="s3">\n                </span><span class="s1">this.input.max = constraint.maximum;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current integer input entered. This method throws exception</span><span class="s3">\n     </span><span class="s1">* if input is invalid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">let value = this.input.value;</span><span class="s3">\n        </span><span class="s1">if (value.trim() === '') {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let intValue = parseInt(value);</span><span class="s3">\n        </span><span class="s1">if (isNaN(intValue)) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Invalid input');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return intValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for date cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DateCellEditor extends CellEditor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the DOM events for the editor.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The DOM event sent to the editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">switch (event.type) {</span><span class="s3">\n            </span><span class="s1">case 'keydown':</span><span class="s3">\n                </span><span class="s1">this._onKeyDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'blur':</span><span class="s3">\n                </span><span class="s1">this._onBlur(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._unbindEvents();</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">this._createWidget();</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(cell);</span><span class="s3">\n        </span><span class="s1">this._input.value = this._deserialize(cellInfo.data);</span><span class="s3">\n        </span><span class="s1">this.editorContainer.appendChild(this._input);</span><span class="s3">\n        </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">this._bindEvents();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current date input entered.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">return this._input.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_deserialize(value) {</span><span class="s3">\n        </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n            </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_createWidget() {</span><span class="s3">\n        </span><span class="s1">const input = document.createElement('input');</span><span class="s3">\n        </span><span class="s1">input.type = 'date';</span><span class="s3">\n        </span><span class="s1">input.pattern = 'd{4}-d{2}-d{2}';</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorWidget');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorInput');</span><span class="s3">\n        </span><span class="s1">this._input = input;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_bindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_unbindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.cancel();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onBlur(event) {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.commit()) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for boolean cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class BooleanCellEditor extends CellEditor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the DOM events for the editor.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The DOM event sent to the editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">switch (event.type) {</span><span class="s3">\n            </span><span class="s1">case 'keydown':</span><span class="s3">\n                </span><span class="s1">this._onKeyDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'mousedown':</span><span class="s3">\n                </span><span class="s1">// fix focus loss problem in Safari and Firefox</span><span class="s3">\n                </span><span class="s1">this._input.focus();</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'blur':</span><span class="s3">\n                </span><span class="s1">this._onBlur(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._unbindEvents();</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">this._createWidget();</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(cell);</span><span class="s3">\n        </span><span class="s1">this._input.checked = this._deserialize(cellInfo.data);</span><span class="s3">\n        </span><span class="s1">this.editorContainer.appendChild(this._input);</span><span class="s3">\n        </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">this._bindEvents();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current boolean input entered.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">return this._input.checked;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_deserialize(value) {</span><span class="s3">\n        </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value == true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_createWidget() {</span><span class="s3">\n        </span><span class="s1">const input = document.createElement('input');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorWidget');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorCheckbox');</span><span class="s3">\n        </span><span class="s1">input.type = 'checkbox';</span><span class="s3">\n        </span><span class="s1">input.spellcheck = false;</span><span class="s3">\n        </span><span class="s1">this._input = input;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_bindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('mousedown', this);</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_unbindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('mousedown', this);</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.cancel();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onBlur(event) {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.commit()) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for option cells.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* It supports multiple option selection. If cell metadata contains</span><span class="s3">\n </span><span class="s1">* type attribute 'array', then it behaves as a multi select.</span><span class="s3">\n </span><span class="s1">* In that case cell data is expected to be list of string values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class OptionCellEditor extends CellEditor {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super(...arguments);</span><span class="s3">\n        </span><span class="s1">this._isMultiSelect = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n        </span><span class="s1">if (this._isMultiSelect) {</span><span class="s3">\n            </span><span class="s1">document.body.removeChild(this._select);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(cell);</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">this._isMultiSelect = metadata.type === 'array';</span><span class="s3">\n        </span><span class="s1">this._createWidget();</span><span class="s3">\n        </span><span class="s1">if (this._isMultiSelect) {</span><span class="s3">\n            </span><span class="s1">this._select.multiple = true;</span><span class="s3">\n            </span><span class="s1">const values = this._deserialize(cellInfo.data);</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this._select.options.length; ++i) {</span><span class="s3">\n                </span><span class="s1">const option = this._select.options.item(i);</span><span class="s3">\n                </span><span class="s1">option.selected = values.indexOf(option.value) !== -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">document.body.appendChild(this._select);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._select.value = this._deserialize(cellInfo.data);</span><span class="s3">\n            </span><span class="s1">this.editorContainer.appendChild(this._select);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._select.focus();</span><span class="s3">\n        </span><span class="s1">this._bindEvents();</span><span class="s3">\n        </span><span class="s1">this.updatePosition();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current option input.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">if (this._isMultiSelect) {</span><span class="s3">\n            </span><span class="s1">const input = [];</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; this._select.selectedOptions.length; ++i) {</span><span class="s3">\n                </span><span class="s1">input.push(this._select.selectedOptions.item(i).value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return input;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return this._select.value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reposition cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updatePosition() {</span><span class="s3">\n        </span><span class="s1">super.updatePosition();</span><span class="s3">\n        </span><span class="s1">if (!this._isMultiSelect) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(this.cell);</span><span class="s3">\n        </span><span class="s1">this._select.style.position = 'absolute';</span><span class="s3">\n        </span><span class="s1">const editorContainerRect = this.editorContainer.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">this._select.style.left = editorContainerRect.left + 'px';</span><span class="s3">\n        </span><span class="s1">this._select.style.top = editorContainerRect.top + cellInfo.height + 'px';</span><span class="s3">\n        </span><span class="s1">this._select.style.width = editorContainerRect.width + 'px';</span><span class="s3">\n        </span><span class="s1">this._select.style.maxHeight = '60px';</span><span class="s3">\n        </span><span class="s1">this.editorContainer.style.visibility = 'hidden';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_deserialize(value) {</span><span class="s3">\n        </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n            </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._isMultiSelect) {</span><span class="s3">\n            </span><span class="s1">const values = [];</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n                </span><span class="s1">for (let item of value) {</span><span class="s3">\n                    </span><span class="s1">values.push(item.toString());</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return values;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return value.toString();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_createWidget() {</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">const items = metadata.constraint.enum;</span><span class="s3">\n        </span><span class="s1">const select = document.createElement('select');</span><span class="s3">\n        </span><span class="s1">select.classList.add('lm-DataGrid-cellEditorWidget');</span><span class="s3">\n        </span><span class="s1">for (let item of items) {</span><span class="s3">\n            </span><span class="s1">const option = document.createElement('option');</span><span class="s3">\n            </span><span class="s1">option.value = item;</span><span class="s3">\n            </span><span class="s1">option.text = item;</span><span class="s3">\n            </span><span class="s1">select.appendChild(option);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._select = select;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_bindEvents() {</span><span class="s3">\n        </span><span class="s1">this._select.addEventListener('keydown', this._onKeyDown.bind(this));</span><span class="s3">\n        </span><span class="s1">this._select.addEventListener('blur', this._onBlur.bind(this));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.cancel();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onBlur(event) {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.commit()) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this._select.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Cell editor for option cells whose value can be any value</span><span class="s3">\n </span><span class="s1">* from set of pre-defined options or values that can be input by user.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DynamicOptionCellEditor extends CellEditor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the DOM events for the editor.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The DOM event sent to the editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">switch (event.type) {</span><span class="s3">\n            </span><span class="s1">case 'keydown':</span><span class="s3">\n                </span><span class="s1">this._onKeyDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'blur':</span><span class="s3">\n                </span><span class="s1">this._onBlur(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by cell editor.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._unbindEvents();</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startEditing() {</span><span class="s3">\n        </span><span class="s1">this._createWidget();</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const cellInfo = this.getCellInfo(cell);</span><span class="s3">\n        </span><span class="s1">this._input.value = this._deserialize(cellInfo.data);</span><span class="s3">\n        </span><span class="s1">this.editorContainer.appendChild(this._input);</span><span class="s3">\n        </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">this._input.select();</span><span class="s3">\n        </span><span class="s1">this._bindEvents();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Return the current option input.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getInput() {</span><span class="s3">\n        </span><span class="s1">return this._input.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_deserialize(value) {</span><span class="s3">\n        </span><span class="s1">if (value === null || value === undefined) {</span><span class="s3">\n            </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_createWidget() {</span><span class="s3">\n        </span><span class="s1">const cell = this.cell;</span><span class="s3">\n        </span><span class="s1">const grid = cell.grid;</span><span class="s3">\n        </span><span class="s1">const dataModel = grid.dataModel;</span><span class="s3">\n        </span><span class="s1">const rowCount = dataModel.rowCount('body');</span><span class="s3">\n        </span><span class="s1">const listId = 'cell-editor-list';</span><span class="s3">\n        </span><span class="s1">const list = document.createElement('datalist');</span><span class="s3">\n        </span><span class="s1">list.id = listId;</span><span class="s3">\n        </span><span class="s1">const input = document.createElement('input');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorWidget');</span><span class="s3">\n        </span><span class="s1">input.classList.add('lm-DataGrid-cellEditorInput');</span><span class="s3">\n        </span><span class="s1">const valueSet = new Set();</span><span class="s3">\n        </span><span class="s1">for (let r = 0; r &lt; rowCount; ++r) {</span><span class="s3">\n            </span><span class="s1">const data = dataModel.data('body', r, cell.column);</span><span class="s3">\n            </span><span class="s1">if (data) {</span><span class="s3">\n                </span><span class="s1">valueSet.add(data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">valueSet.forEach((value) =&gt; {</span><span class="s3">\n            </span><span class="s1">const option = document.createElement('option');</span><span class="s3">\n            </span><span class="s1">option.value = value;</span><span class="s3">\n            </span><span class="s1">option.text = value;</span><span class="s3">\n            </span><span class="s1">list.appendChild(option);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.editorContainer.appendChild(list);</span><span class="s3">\n        </span><span class="s1">input.setAttribute('list', listId);</span><span class="s3">\n        </span><span class="s1">this._input = input;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_bindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.addEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_unbindEvents() {</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._input.removeEventListener('blur', this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">switch (getKeyboardLayout().keyForKeydownEvent(event)) {</span><span class="s3">\n            </span><span class="s1">case 'Enter':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'up' : 'down');</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Tab':</span><span class="s3">\n                </span><span class="s1">this.commit(event.shiftKey ? 'left' : 'right');</span><span class="s3">\n                </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'Escape':</span><span class="s3">\n                </span><span class="s1">this.cancel();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onBlur(event) {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.commit()) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this._input.focus();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the `CellEditor` class statics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">(function (CellEditor) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A widget which implements a notification popup.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">class Notification extends Widget {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Construct a new notification.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param options - The options for initializing the notification.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">constructor(options) {</span><span class="s3">\n            </span><span class="s1">super({ node: Notification.createNode() });</span><span class="s3">\n            </span><span class="s1">this._message = '';</span><span class="s3">\n            </span><span class="s1">this.addClass('lm-DataGrid-notification');</span><span class="s3">\n            </span><span class="s1">this.setFlag(Widget.Flag.DisallowLayout);</span><span class="s3">\n            </span><span class="s1">this._target = options.target;</span><span class="s3">\n            </span><span class="s1">this._message = options.message || '';</span><span class="s3">\n            </span><span class="s1">this._placement = options.placement || 'bottom';</span><span class="s3">\n            </span><span class="s1">Widget.attach(this, document.body);</span><span class="s3">\n            </span><span class="s1">if (options.timeout &amp;&amp; options.timeout &gt; 0) {</span><span class="s3">\n                </span><span class="s1">setTimeout(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">this.close();</span><span class="s3">\n                </span><span class="s1">}, options.timeout);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle the DOM events for the notification.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param event - The DOM event sent to the notification.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* #### Notes</span><span class="s3">\n         </span><span class="s1">* This method implements the DOM `EventListener` interface and is</span><span class="s3">\n         </span><span class="s1">* called in response to events on the notification's DOM node.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* This should not be called directly by user code.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">handleEvent(event) {</span><span class="s3">\n            </span><span class="s1">switch (event.type) {</span><span class="s3">\n                </span><span class="s1">case 'mousedown':</span><span class="s3">\n                    </span><span class="s1">this._evtMouseDown(event);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'contextmenu':</span><span class="s3">\n                    </span><span class="s1">event.preventDefault();</span><span class="s3">\n                    </span><span class="s1">event.stopPropagation();</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Get the placement of the notification.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get placement() {</span><span class="s3">\n            </span><span class="s1">return this._placement;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Set the placement of the notification.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">set placement(value) {</span><span class="s3">\n            </span><span class="s1">// Do nothing if the placement does not change.</span><span class="s3">\n            </span><span class="s1">if (this._placement === value) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Update the internal placement.</span><span class="s3">\n            </span><span class="s1">this._placement = value;</span><span class="s3">\n            </span><span class="s1">// Schedule an update for notification.</span><span class="s3">\n            </span><span class="s1">this.update();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Get the current value of the message.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get message() {</span><span class="s3">\n            </span><span class="s1">return this._message;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Set the current value of the message.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">set message(value) {</span><span class="s3">\n            </span><span class="s1">// Do nothing if the value does not change.</span><span class="s3">\n            </span><span class="s1">if (this._message === value) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Update the internal value.</span><span class="s3">\n            </span><span class="s1">this._message = value;</span><span class="s3">\n            </span><span class="s1">// Schedule an update for notification.</span><span class="s3">\n            </span><span class="s1">this.update();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Get the node presenting the message.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get messageNode() {</span><span class="s3">\n            </span><span class="s1">return this.node.getElementsByClassName('lm-DataGrid-notificationMessage')[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A method invoked on a 'before-attach' message.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">onBeforeAttach(msg) {</span><span class="s3">\n            </span><span class="s1">this.node.addEventListener('mousedown', this);</span><span class="s3">\n            </span><span class="s1">this.update();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A method invoked on an 'after-detach' message.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">onAfterDetach(msg) {</span><span class="s3">\n            </span><span class="s1">this.node.removeEventListener('mousedown', this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* A method invoked on an 'update-request' message.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">onUpdateRequest(msg) {</span><span class="s3">\n            </span><span class="s1">const targetRect = this._target.getBoundingClientRect();</span><span class="s3">\n            </span><span class="s1">const style = this.node.style;</span><span class="s3">\n            </span><span class="s1">switch (this._placement) {</span><span class="s3">\n                </span><span class="s1">case 'bottom':</span><span class="s3">\n                    </span><span class="s1">style.left = targetRect.left + 'px';</span><span class="s3">\n                    </span><span class="s1">style.top = targetRect.bottom + 'px';</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'top':</span><span class="s3">\n                    </span><span class="s1">style.left = targetRect.left + 'px';</span><span class="s3">\n                    </span><span class="s1">style.height = targetRect.top + 'px';</span><span class="s3">\n                    </span><span class="s1">style.top = '0';</span><span class="s3">\n                    </span><span class="s1">style.alignItems = 'flex-end';</span><span class="s3">\n                    </span><span class="s1">style.justifyContent = 'flex-end';</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'left':</span><span class="s3">\n                    </span><span class="s1">style.left = '0';</span><span class="s3">\n                    </span><span class="s1">style.width = targetRect.left + 'px';</span><span class="s3">\n                    </span><span class="s1">style.top = targetRect.top + 'px';</span><span class="s3">\n                    </span><span class="s1">style.alignItems = 'flex-end';</span><span class="s3">\n                    </span><span class="s1">style.justifyContent = 'flex-end';</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'right':</span><span class="s3">\n                    </span><span class="s1">style.left = targetRect.right + 'px';</span><span class="s3">\n                    </span><span class="s1">style.top = targetRect.top + 'px';</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.messageNode.innerHTML = this._message;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle the `'mousedown'` event for the notification.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">_evtMouseDown(event) {</span><span class="s3">\n            </span><span class="s1">// Do nothing if it's not a left mouse press.</span><span class="s3">\n            </span><span class="s1">if (event.button !== 0) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n            </span><span class="s1">this.close();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">CellEditor.Notification = Notification;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The namespace for the `Notification` class statics.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">(function (Notification) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Create the DOM node for notification.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">function createNode() {</span><span class="s3">\n            </span><span class="s1">const node = document.createElement('div');</span><span class="s3">\n            </span><span class="s1">const container = document.createElement('div');</span><span class="s3">\n            </span><span class="s1">container.className = 'lm-DataGrid-notificationContainer';</span><span class="s3">\n            </span><span class="s1">const message = document.createElement('span');</span><span class="s3">\n            </span><span class="s1">message.className = 'lm-DataGrid-notificationMessage';</span><span class="s3">\n            </span><span class="s1">container.appendChild(message);</span><span class="s3">\n            </span><span class="s1">node.appendChild(container);</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">Notification.createNode = createNode;</span><span class="s3">\n    </span><span class="s1">})(Notification = CellEditor.Notification || (CellEditor.Notification = {}));</span><span class="s3">\n</span><span class="s1">})(CellEditor || (CellEditor = {}));</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Jupyter Development Team.</span><span class="s3">\n </span><span class="s1">* Distributed under the terms of the Modified BSD License.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Resolve a config option for a cell editor.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param option - The config option to resolve.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param config - The cell config object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @returns The resolved value for the option.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function resolveOption(option, config) {</span><span class="s3">\n    </span><span class="s1">return typeof option === 'function'</span><span class="s3">\n        </span><span class="s1">? option(config)</span><span class="s3">\n        </span><span class="s1">: option;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which manages cell editing. It stores editor overrides,</span><span class="s3">\n </span><span class="s1">* decides which editor to use for a cell, makes sure there is only one editor active.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class CellEditorController {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">// active cell editor</span><span class="s3">\n        </span><span class="s1">this._editor = null;</span><span class="s3">\n        </span><span class="s1">// active cell being edited</span><span class="s3">\n        </span><span class="s1">this._cell = null;</span><span class="s3">\n        </span><span class="s1">// cell editor overrides based on cell data type identifier</span><span class="s3">\n        </span><span class="s1">this._typeBasedOverrides = new Map();</span><span class="s3">\n        </span><span class="s1">// cell editor overrides based on partial metadata match</span><span class="s3">\n        </span><span class="s1">this._metadataBasedOverrides = new Map();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Override cell editor for the cells matching the identifier.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param identifier - Cell identifier to use when matching cells.</span><span class="s3">\n     </span><span class="s1">* if identifier is a CellDataType, then cell matching is done using data type of the cell,</span><span class="s3">\n     </span><span class="s1">* if identifier is a Metadata, then partial match of the cell metadata with identifier is used for match,</span><span class="s3">\n     </span><span class="s1">* if identifier is 'default' then override is used as default editor when no other editor is found suitable</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param editor - The cell editor to use or resolver to use to get an editor for matching cells.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setEditor(identifier, editor) {</span><span class="s3">\n        </span><span class="s1">if (typeof identifier === 'string') {</span><span class="s3">\n            </span><span class="s1">this._typeBasedOverrides.set(identifier, editor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const key = this._metadataIdentifierToKey(identifier);</span><span class="s3">\n            </span><span class="s1">this._metadataBasedOverrides.set(key, [identifier, editor]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Start editing a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell - The object holding cell configuration data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The cell editing options.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">edit(cell, options) {</span><span class="s3">\n        </span><span class="s1">const grid = cell.grid;</span><span class="s3">\n        </span><span class="s1">if (!grid.editable) {</span><span class="s3">\n            </span><span class="s1">console.error('Grid cannot be edited!');</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.cancel();</span><span class="s3">\n        </span><span class="s1">this._cell = cell;</span><span class="s3">\n        </span><span class="s1">options = options || {};</span><span class="s3">\n        </span><span class="s1">options.onCommit = options.onCommit || this._onCommit.bind(this);</span><span class="s3">\n        </span><span class="s1">options.onCancel = options.onCancel || this._onCancel.bind(this);</span><span class="s3">\n        </span><span class="s1">// if an editor is passed in with options, then use it for editing</span><span class="s3">\n        </span><span class="s1">if (options.editor) {</span><span class="s3">\n            </span><span class="s1">this._editor = options.editor;</span><span class="s3">\n            </span><span class="s1">options.editor.edit(cell, options);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// choose an editor based on overrides / cell data type</span><span class="s3">\n        </span><span class="s1">const editor = this._getEditor(cell);</span><span class="s3">\n        </span><span class="s1">if (editor) {</span><span class="s3">\n            </span><span class="s1">this._editor = editor;</span><span class="s3">\n            </span><span class="s1">editor.edit(cell, options);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cancel editing.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">cancel() {</span><span class="s3">\n        </span><span class="s1">if (this._editor) {</span><span class="s3">\n            </span><span class="s1">this._editor.cancel();</span><span class="s3">\n            </span><span class="s1">this._editor = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._cell = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onCommit(response) {</span><span class="s3">\n        </span><span class="s1">const cell = this._cell;</span><span class="s3">\n        </span><span class="s1">if (!cell) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const grid = cell.grid;</span><span class="s3">\n        </span><span class="s1">const dataModel = grid.dataModel;</span><span class="s3">\n        </span><span class="s1">let row = cell.row;</span><span class="s3">\n        </span><span class="s1">let column = cell.column;</span><span class="s3">\n        </span><span class="s1">const cellGroup = CellGroup.getGroup(grid.dataModel, 'body', row, column);</span><span class="s3">\n        </span><span class="s1">if (cellGroup) {</span><span class="s3">\n            </span><span class="s1">row = cellGroup.r1;</span><span class="s3">\n            </span><span class="s1">column = cellGroup.c1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">dataModel.setData('body', row, column, response.value);</span><span class="s3">\n        </span><span class="s1">grid.viewport.node.focus();</span><span class="s3">\n        </span><span class="s1">if (response.cursorMovement !== 'none') {</span><span class="s3">\n            </span><span class="s1">grid.moveCursor(response.cursorMovement);</span><span class="s3">\n            </span><span class="s1">grid.scrollToCursor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_onCancel() {</span><span class="s3">\n        </span><span class="s1">if (!this._cell) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._cell.grid.viewport.node.focus();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getDataTypeKey(cell) {</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel</span><span class="s3">\n            </span><span class="s1">? cell.grid.dataModel.metadata('body', cell.row, cell.column)</span><span class="s3">\n            </span><span class="s1">: null;</span><span class="s3">\n        </span><span class="s1">if (!metadata) {</span><span class="s3">\n            </span><span class="s1">return 'default';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let key = '';</span><span class="s3">\n        </span><span class="s1">if (metadata) {</span><span class="s3">\n            </span><span class="s1">key = metadata.type;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (metadata.constraint &amp;&amp; metadata.constraint.enum) {</span><span class="s3">\n            </span><span class="s1">if (metadata.constraint.enum === 'dynamic') {</span><span class="s3">\n                </span><span class="s1">key += ':dynamic-option';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">key += ':option';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return key;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_objectToKey(object) {</span><span class="s3">\n        </span><span class="s1">let str = '';</span><span class="s3">\n        </span><span class="s1">for (let key in object) {</span><span class="s3">\n            </span><span class="s1">const value = object[key];</span><span class="s3">\n            </span><span class="s1">if (typeof value === 'object') {</span><span class="s3">\n                </span><span class="s1">str += `${key}:${this._objectToKey(value)}`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">str += `[${key}:${value}]`;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return str;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_metadataIdentifierToKey(metadata) {</span><span class="s3">\n        </span><span class="s1">return this._objectToKey(metadata);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_metadataMatchesIdentifier(metadata, identifier) {</span><span class="s3">\n        </span><span class="s1">for (let key in identifier) {</span><span class="s3">\n            </span><span class="s1">if (!metadata.hasOwnProperty(key)) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const identifierValue = identifier[key];</span><span class="s3">\n            </span><span class="s1">const metadataValue = metadata[key];</span><span class="s3">\n            </span><span class="s1">if (typeof identifierValue === 'object') {</span><span class="s3">\n                </span><span class="s1">if (!this._metadataMatchesIdentifier(metadataValue, identifierValue)) {</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (metadataValue !== identifierValue) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getMetadataBasedEditor(cell) {</span><span class="s3">\n        </span><span class="s1">let editorMatched;</span><span class="s3">\n        </span><span class="s1">const metadata = cell.grid.dataModel.metadata('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">if (metadata) {</span><span class="s3">\n            </span><span class="s1">this._metadataBasedOverrides.forEach(value =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!editorMatched) {</span><span class="s3">\n                    </span><span class="s1">let [identifier, editor] = value;</span><span class="s3">\n                    </span><span class="s1">if (this._metadataMatchesIdentifier(metadata, identifier)) {</span><span class="s3">\n                        </span><span class="s1">editorMatched = resolveOption(editor, cell);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return editorMatched;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Choose the most appropriate cell editor to use based on overrides / cell data type.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If no match is found in overrides or based on cell data type, and if cell has a primitive</span><span class="s3">\n     </span><span class="s1">* data type then TextCellEditor is used as default cell editor. If 'default' cell editor</span><span class="s3">\n     </span><span class="s1">* is overridden, then it is used instead of TextCellEditor for default.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_getEditor(cell) {</span><span class="s3">\n        </span><span class="s1">const dtKey = this._getDataTypeKey(cell);</span><span class="s3">\n        </span><span class="s1">// find an editor based on data type based override</span><span class="s3">\n        </span><span class="s1">if (this._typeBasedOverrides.has(dtKey)) {</span><span class="s3">\n            </span><span class="s1">const editor = this._typeBasedOverrides.get(dtKey);</span><span class="s3">\n            </span><span class="s1">return resolveOption(editor, cell);</span><span class="s3">\n        </span><span class="s1">} // find an editor based on metadata match based override</span><span class="s3">\n        </span><span class="s1">else if (this._metadataBasedOverrides.size &gt; 0) {</span><span class="s3">\n            </span><span class="s1">const editor = this._getMetadataBasedEditor(cell);</span><span class="s3">\n            </span><span class="s1">if (editor) {</span><span class="s3">\n                </span><span class="s1">return editor;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// choose an editor based on data type</span><span class="s3">\n        </span><span class="s1">switch (dtKey) {</span><span class="s3">\n            </span><span class="s1">case 'string':</span><span class="s3">\n                </span><span class="s1">return new TextCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'number':</span><span class="s3">\n                </span><span class="s1">return new NumberCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'integer':</span><span class="s3">\n                </span><span class="s1">return new IntegerCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'boolean':</span><span class="s3">\n                </span><span class="s1">return new BooleanCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'date':</span><span class="s3">\n                </span><span class="s1">return new DateCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'string:option':</span><span class="s3">\n            </span><span class="s1">case 'number:option':</span><span class="s3">\n            </span><span class="s1">case 'integer:option':</span><span class="s3">\n            </span><span class="s1">case 'date:option':</span><span class="s3">\n            </span><span class="s1">case 'array:option':</span><span class="s3">\n                </span><span class="s1">return new OptionCellEditor();</span><span class="s3">\n            </span><span class="s1">case 'string:dynamic-option':</span><span class="s3">\n            </span><span class="s1">case 'number:dynamic-option':</span><span class="s3">\n            </span><span class="s1">case 'integer:dynamic-option':</span><span class="s3">\n            </span><span class="s1">case 'date:dynamic-option':</span><span class="s3">\n                </span><span class="s1">return new DynamicOptionCellEditor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// if an override exists for 'default', then use it</span><span class="s3">\n        </span><span class="s1">if (this._typeBasedOverrides.has('default')) {</span><span class="s3">\n            </span><span class="s1">const editor = this._typeBasedOverrides.get('default');</span><span class="s3">\n            </span><span class="s1">return resolveOption(editor, cell);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// if cell has a primitive data type then use TextCellEditor</span><span class="s3">\n        </span><span class="s1">const data = cell.grid.dataModel.data('body', cell.row, cell.column);</span><span class="s3">\n        </span><span class="s1">if (!data || typeof data !== 'object') {</span><span class="s3">\n            </span><span class="s1">return new TextCellEditor();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// no suitable editor found for the cell</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which provides the data for a data grid.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* If the predefined data models are insufficient for a particular use</span><span class="s3">\n </span><span class="s1">* case, a custom model can be defined which derives from this class.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DataModel {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this._changed = new Signal(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal emitted when the data model has changed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get changed() {</span><span class="s3">\n        </span><span class="s1">return this._changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the count of merged cell groups pertaining to a given</span><span class="s3">\n     </span><span class="s1">* cell region.</span><span class="s3">\n     </span><span class="s1">* @param region the target cell region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">groupCount(region) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the metadata for a cell in the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The cell region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of the cell of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of the cell of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The metadata for the specified cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* The returned metadata should be treated as immutable.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This method is called often, and so should be efficient.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The default implementation returns `{}`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">metadata(region, row, column) {</span><span class="s3">\n        </span><span class="s1">return DataModel.emptyMetadata;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the merged cell group corresponding to a region and index number.</span><span class="s3">\n     </span><span class="s1">* @param region the cell region of cell group.</span><span class="s3">\n     </span><span class="s1">* @param groupIndex the group index of the cell group.</span><span class="s3">\n     </span><span class="s1">* @returns a cell group.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">group(region, groupIndex) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Emit the `changed` signal for the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* Subclasses should call this method whenever the data model has</span><span class="s3">\n     </span><span class="s1">* changed so that attached data grids can update themselves.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">emitChanged(args) {</span><span class="s3">\n        </span><span class="s1">this._changed.emit(args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which provides the mutable data for a data grid.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This object is an extension to `DataModel` and it only adds ability to</span><span class="s3">\n </span><span class="s1">* change data for cells.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class MutableDataModel extends DataModel {</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the `DataModel` class statics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">(function (DataModel) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A singleton empty metadata object.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DataModel.emptyMetadata = Object.freeze({});</span><span class="s3">\n</span><span class="s1">})(DataModel || (DataModel = {}));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A thin caching wrapper around a 2D canvas rendering context.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This class is mostly a transparent wrapper around a canvas rendering</span><span class="s3">\n </span><span class="s1">* context which improves performance when writing context state.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For best performance, avoid reading state from the `gc`. Writes are</span><span class="s3">\n </span><span class="s1">* cached based on the previously written value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Unless otherwise specified, the API and semantics of this class are</span><span class="s3">\n </span><span class="s1">* identical to the builtin 2D canvas rendering context:</span><span class="s3">\n </span><span class="s1">* https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The wrapped canvas context should not be manipulated externally</span><span class="s3">\n </span><span class="s1">* until the wrapping `GraphicsContext` object is disposed.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class GraphicsContext {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new graphics context object.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param context - The 2D canvas rendering context to wrap.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(context) {</span><span class="s3">\n        </span><span class="s1">this._disposed = false;</span><span class="s3">\n        </span><span class="s1">this._context = context;</span><span class="s3">\n        </span><span class="s1">this._state = Private$3.State.create(context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">// Bail if the gc is already disposed.</span><span class="s3">\n        </span><span class="s1">if (this._disposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Mark the gc as disposed.</span><span class="s3">\n        </span><span class="s1">this._disposed = true;</span><span class="s3">\n        </span><span class="s1">// Pop any unrestored saves.</span><span class="s3">\n        </span><span class="s1">while (this._state.next) {</span><span class="s3">\n            </span><span class="s1">this._state = this._state.next;</span><span class="s3">\n            </span><span class="s1">this._context.restore();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get fillStyle() {</span><span class="s3">\n        </span><span class="s1">return this._context.fillStyle;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set fillStyle(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.fillStyle !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.fillStyle = value;</span><span class="s3">\n            </span><span class="s1">this._context.fillStyle = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get strokeStyle() {</span><span class="s3">\n        </span><span class="s1">return this._context.strokeStyle;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set strokeStyle(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.strokeStyle !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.strokeStyle = value;</span><span class="s3">\n            </span><span class="s1">this._context.strokeStyle = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get font() {</span><span class="s3">\n        </span><span class="s1">return this._context.font;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set font(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.font !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.font = value;</span><span class="s3">\n            </span><span class="s1">this._context.font = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get textAlign() {</span><span class="s3">\n        </span><span class="s1">return this._context.textAlign;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set textAlign(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.textAlign !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.textAlign = value;</span><span class="s3">\n            </span><span class="s1">this._context.textAlign = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get textBaseline() {</span><span class="s3">\n        </span><span class="s1">return this._context.textBaseline;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set textBaseline(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.textBaseline !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.textBaseline = value;</span><span class="s3">\n            </span><span class="s1">this._context.textBaseline = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineCap() {</span><span class="s3">\n        </span><span class="s1">return this._context.lineCap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set lineCap(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.lineCap !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.lineCap = value;</span><span class="s3">\n            </span><span class="s1">this._context.lineCap = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineDashOffset() {</span><span class="s3">\n        </span><span class="s1">return this._context.lineDashOffset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set lineDashOffset(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.lineDashOffset !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.lineDashOffset = value;</span><span class="s3">\n            </span><span class="s1">this._context.lineDashOffset = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineJoin() {</span><span class="s3">\n        </span><span class="s1">return this._context.lineJoin;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set lineJoin(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.lineJoin !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.lineJoin = value;</span><span class="s3">\n            </span><span class="s1">this._context.lineJoin = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineWidth() {</span><span class="s3">\n        </span><span class="s1">return this._context.lineWidth;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set lineWidth(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.lineWidth !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.lineWidth = value;</span><span class="s3">\n            </span><span class="s1">this._context.lineWidth = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get miterLimit() {</span><span class="s3">\n        </span><span class="s1">return this._context.miterLimit;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set miterLimit(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.miterLimit !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.miterLimit = value;</span><span class="s3">\n            </span><span class="s1">this._context.miterLimit = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get shadowBlur() {</span><span class="s3">\n        </span><span class="s1">return this._context.shadowBlur;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set shadowBlur(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.shadowBlur !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.shadowBlur = value;</span><span class="s3">\n            </span><span class="s1">this._context.shadowBlur = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get shadowColor() {</span><span class="s3">\n        </span><span class="s1">return this._context.shadowColor;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set shadowColor(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.shadowColor !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.shadowColor = value;</span><span class="s3">\n            </span><span class="s1">this._context.shadowColor = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get shadowOffsetX() {</span><span class="s3">\n        </span><span class="s1">return this._context.shadowOffsetX;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set shadowOffsetX(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.shadowOffsetX !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.shadowOffsetX = value;</span><span class="s3">\n            </span><span class="s1">this._context.shadowOffsetX = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get shadowOffsetY() {</span><span class="s3">\n        </span><span class="s1">return this._context.shadowOffsetY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set shadowOffsetY(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.shadowOffsetY !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.shadowOffsetY = value;</span><span class="s3">\n            </span><span class="s1">this._context.shadowOffsetY = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get imageSmoothingEnabled() {</span><span class="s3">\n        </span><span class="s1">return this._context.imageSmoothingEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set imageSmoothingEnabled(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.imageSmoothingEnabled !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.imageSmoothingEnabled = value;</span><span class="s3">\n            </span><span class="s1">this._context.imageSmoothingEnabled = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get globalAlpha() {</span><span class="s3">\n        </span><span class="s1">return this._context.globalAlpha;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set globalAlpha(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.globalAlpha !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.globalAlpha = value;</span><span class="s3">\n            </span><span class="s1">this._context.globalAlpha = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get globalCompositeOperation() {</span><span class="s3">\n        </span><span class="s1">return this._context.globalCompositeOperation;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set globalCompositeOperation(value) {</span><span class="s3">\n        </span><span class="s1">if (this._state.globalCompositeOperation !== value) {</span><span class="s3">\n            </span><span class="s1">this._state.globalCompositeOperation = value;</span><span class="s3">\n            </span><span class="s1">this._context.globalCompositeOperation = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLineDash() {</span><span class="s3">\n        </span><span class="s1">return this._context.getLineDash();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setLineDash(segments) {</span><span class="s3">\n        </span><span class="s1">this._context.setLineDash(segments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rotate(angle) {</span><span class="s3">\n        </span><span class="s1">this._context.rotate(angle);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scale(x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.scale(x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">transform(m11, m12, m21, m22, dx, dy) {</span><span class="s3">\n        </span><span class="s1">this._context.transform(m11, m12, m21, m22, dx, dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">translate(x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.translate(x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setTransform(m11, m12, m21, m22, dx, dy) {</span><span class="s3">\n        </span><span class="s1">this._context.setTransform(m11, m12, m21, m22, dx, dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">save() {</span><span class="s3">\n        </span><span class="s1">// Clone an push the current state to the stack.</span><span class="s3">\n        </span><span class="s1">this._state = Private$3.State.push(this._state);</span><span class="s3">\n        </span><span class="s1">// Save the wrapped context state.</span><span class="s3">\n        </span><span class="s1">this._context.save();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">restore() {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no state to restore.</span><span class="s3">\n        </span><span class="s1">if (!this._state.next) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Pop the saved state from the stack.</span><span class="s3">\n        </span><span class="s1">this._state = Private$3.State.pop(this._state);</span><span class="s3">\n        </span><span class="s1">// Restore the wrapped context state.</span><span class="s3">\n        </span><span class="s1">this._context.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">beginPath() {</span><span class="s3">\n        </span><span class="s1">return this._context.beginPath();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">closePath() {</span><span class="s3">\n        </span><span class="s1">this._context.closePath();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isPointInPath(x, y, fillRule) {</span><span class="s3">\n        </span><span class="s1">let result;</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 2) {</span><span class="s3">\n            </span><span class="s1">result = this._context.isPointInPath(x, y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">result = this._context.isPointInPath(x, y, fillRule);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">arc(x, y, radius, startAngle, endAngle, anticlockwise) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 5) {</span><span class="s3">\n            </span><span class="s1">this._context.arc(x, y, radius, startAngle, endAngle);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.arc(x, y, radius, startAngle, endAngle, anticlockwise);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">arcTo(x1, y1, x2, y2, radius) {</span><span class="s3">\n        </span><span class="s1">this._context.arcTo(x1, y1, x2, y2, radius);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 7) {</span><span class="s3">\n            </span><span class="s1">this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineTo(x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.lineTo(x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">moveTo(x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.moveTo(x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">quadraticCurveTo(cpx, cpy, x, y) {</span><span class="s3">\n        </span><span class="s1">this._context.quadraticCurveTo(cpx, cpy, x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">rect(x, y, w, h) {</span><span class="s3">\n        </span><span class="s1">this._context.rect(x, y, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clip(fillRule) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 0) {</span><span class="s3">\n            </span><span class="s1">this._context.clip();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.clip(fillRule);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fill(fillRule) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 0) {</span><span class="s3">\n            </span><span class="s1">this._context.fill();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.fill(fillRule);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stroke() {</span><span class="s3">\n        </span><span class="s1">this._context.stroke();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">clearRect(x, y, w, h) {</span><span class="s3">\n        </span><span class="s1">return this._context.clearRect(x, y, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fillRect(x, y, w, h) {</span><span class="s3">\n        </span><span class="s1">this._context.fillRect(x, y, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fillText(text, x, y, maxWidth) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 3) {</span><span class="s3">\n            </span><span class="s1">this._context.fillText(text, x, y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.fillText(text, x, y, maxWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">strokeRect(x, y, w, h) {</span><span class="s3">\n        </span><span class="s1">this._context.strokeRect(x, y, w, h);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">strokeText(text, x, y, maxWidth) {</span><span class="s3">\n        </span><span class="s1">if (arguments.length === 3) {</span><span class="s3">\n            </span><span class="s1">this._context.strokeText(text, x, y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._context.strokeText(text, x, y, maxWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureText(text) {</span><span class="s3">\n        </span><span class="s1">return this._context.measureText(text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createLinearGradient(x0, y0, x1, y1) {</span><span class="s3">\n        </span><span class="s1">return this._context.createLinearGradient(x0, y0, x1, y1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createRadialGradient(x0, y0, r0, x1, y1, r1) {</span><span class="s3">\n        </span><span class="s1">return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createPattern(image, repetition) {</span><span class="s3">\n        </span><span class="s1">return this._context.createPattern(image, repetition);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createImageData() {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line prefer-spread, prefer-rest-params</span><span class="s3">\n        </span><span class="s1">return this._context.createImageData.apply(this._context, arguments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getImageData(sx, sy, sw, sh) {</span><span class="s3">\n        </span><span class="s1">return this._context.getImageData(sx, sy, sw, sh);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">putImageData() {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line prefer-spread, prefer-rest-params</span><span class="s3">\n        </span><span class="s1">this._context.putImageData.apply(this._context, arguments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">drawImage() {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line prefer-spread, prefer-rest-params</span><span class="s3">\n        </span><span class="s1">this._context.drawImage.apply(this._context, arguments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">drawFocusIfNeeded(element) {</span><span class="s3">\n        </span><span class="s1">this._context.drawFocusIfNeeded(element);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$3;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The index of next valid pool object.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">let pi = -1;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A state object allocation pool.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const pool = [];</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* An object which holds the state for a gc.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">class State {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Create a gc state object from a 2D canvas context.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">static create(context) {</span><span class="s3">\n            </span><span class="s1">let state = pi &lt; 0 ? new State() : pool[pi--];</span><span class="s3">\n            </span><span class="s1">state.next = null;</span><span class="s3">\n            </span><span class="s1">state.fillStyle = context.fillStyle;</span><span class="s3">\n            </span><span class="s1">state.font = context.font;</span><span class="s3">\n            </span><span class="s1">state.globalAlpha = context.globalAlpha;</span><span class="s3">\n            </span><span class="s1">state.globalCompositeOperation = context.globalCompositeOperation;</span><span class="s3">\n            </span><span class="s1">state.imageSmoothingEnabled = context.imageSmoothingEnabled;</span><span class="s3">\n            </span><span class="s1">state.lineCap = context.lineCap;</span><span class="s3">\n            </span><span class="s1">state.lineDashOffset = context.lineDashOffset;</span><span class="s3">\n            </span><span class="s1">state.lineJoin = context.lineJoin;</span><span class="s3">\n            </span><span class="s1">state.lineWidth = context.lineWidth;</span><span class="s3">\n            </span><span class="s1">state.miterLimit = context.miterLimit;</span><span class="s3">\n            </span><span class="s1">state.shadowBlur = context.shadowBlur;</span><span class="s3">\n            </span><span class="s1">state.shadowColor = context.shadowColor;</span><span class="s3">\n            </span><span class="s1">state.shadowOffsetX = context.shadowOffsetX;</span><span class="s3">\n            </span><span class="s1">state.shadowOffsetY = context.shadowOffsetY;</span><span class="s3">\n            </span><span class="s1">state.strokeStyle = context.strokeStyle;</span><span class="s3">\n            </span><span class="s1">state.textAlign = context.textAlign;</span><span class="s3">\n            </span><span class="s1">state.textBaseline = context.textBaseline;</span><span class="s3">\n            </span><span class="s1">return state;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Clone an existing gc state object and add it to the state stack.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">static push(other) {</span><span class="s3">\n            </span><span class="s1">let state = pi &lt; 0 ? new State() : pool[pi--];</span><span class="s3">\n            </span><span class="s1">state.next = other;</span><span class="s3">\n            </span><span class="s1">state.fillStyle = other.fillStyle;</span><span class="s3">\n            </span><span class="s1">state.font = other.font;</span><span class="s3">\n            </span><span class="s1">state.globalAlpha = other.globalAlpha;</span><span class="s3">\n            </span><span class="s1">state.globalCompositeOperation = other.globalCompositeOperation;</span><span class="s3">\n            </span><span class="s1">state.imageSmoothingEnabled = other.imageSmoothingEnabled;</span><span class="s3">\n            </span><span class="s1">state.lineCap = other.lineCap;</span><span class="s3">\n            </span><span class="s1">state.lineDashOffset = other.lineDashOffset;</span><span class="s3">\n            </span><span class="s1">state.lineJoin = other.lineJoin;</span><span class="s3">\n            </span><span class="s1">state.lineWidth = other.lineWidth;</span><span class="s3">\n            </span><span class="s1">state.miterLimit = other.miterLimit;</span><span class="s3">\n            </span><span class="s1">state.shadowBlur = other.shadowBlur;</span><span class="s3">\n            </span><span class="s1">state.shadowColor = other.shadowColor;</span><span class="s3">\n            </span><span class="s1">state.shadowOffsetX = other.shadowOffsetX;</span><span class="s3">\n            </span><span class="s1">state.shadowOffsetY = other.shadowOffsetY;</span><span class="s3">\n            </span><span class="s1">state.strokeStyle = other.strokeStyle;</span><span class="s3">\n            </span><span class="s1">state.textAlign = other.textAlign;</span><span class="s3">\n            </span><span class="s1">state.textBaseline = other.textBaseline;</span><span class="s3">\n            </span><span class="s1">return state;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Pop the next state object and return the current to the pool</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">static pop(state) {</span><span class="s3">\n            </span><span class="s1">state.fillStyle = '';</span><span class="s3">\n            </span><span class="s1">state.strokeStyle = '';</span><span class="s3">\n            </span><span class="s1">pool[++pi] = state;</span><span class="s3">\n            </span><span class="s1">return state.next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.State = State;</span><span class="s3">\n</span><span class="s1">})(Private$3 || (Private$3 = {}));</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A class which manages the mapping of cell renderers.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RendererMap {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new renderer map.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param values - The initial values for the map.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param fallback - The renderer of last resort.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(values = {}, fallback) {</span><span class="s3">\n        </span><span class="s1">this._changed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._values = { ...values };</span><span class="s3">\n        </span><span class="s1">this._fallback = fallback || new TextRenderer();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal emitted when the renderer map has changed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get changed() {</span><span class="s3">\n        </span><span class="s1">return this._changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the cell renderer to use for the given cell config.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The cell config of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The renderer to use for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get(config) {</span><span class="s3">\n        </span><span class="s1">// Fetch the renderer from the values map.</span><span class="s3">\n        </span><span class="s1">let renderer = this._values[config.region];</span><span class="s3">\n        </span><span class="s1">// Execute a resolver function if necessary.</span><span class="s3">\n        </span><span class="s1">if (typeof renderer === 'function') {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">renderer = renderer(config);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">renderer = undefined;</span><span class="s3">\n                </span><span class="s1">console.error(err);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the renderer or the fallback.</span><span class="s3">\n        </span><span class="s1">return renderer || this._fallback;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Update the renderer map with new values</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param values - The updated values for the map.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param fallback - The renderer of last resort.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method always emits the `changed` signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">update(values = {}, fallback) {</span><span class="s3">\n        </span><span class="s1">this._values = { ...this._values, ...values };</span><span class="s3">\n        </span><span class="s1">this._fallback = fallback || this._fallback;</span><span class="s3">\n        </span><span class="s1">this._changed.emit(undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2019, PhosphorJS Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An object which manages a collection of variable sized sections.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* This class is an implementation detail. It is designed to manage</span><span class="s3">\n </span><span class="s1">* the variable row and column sizes for a data grid. User code will</span><span class="s3">\n </span><span class="s1">* not interact with this class directly.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SectionList {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new section list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the list.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this._count = 0;</span><span class="s3">\n        </span><span class="s1">this._length = 0;</span><span class="s3">\n        </span><span class="s1">this._sections = [];</span><span class="s3">\n        </span><span class="s1">this._minimumSize = options.minimumSize || 2;</span><span class="s3">\n        </span><span class="s1">this._defaultSize = Math.max(this._minimumSize, Math.floor(options.defaultSize));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The total size of all sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get length() {</span><span class="s3">\n        </span><span class="s1">return this._length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The total number of sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get count() {</span><span class="s3">\n        </span><span class="s1">return this._count;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the minimum size of sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get minimumSize() {</span><span class="s3">\n        </span><span class="s1">return this._minimumSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the minimum size of sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set minimumSize(value) {</span><span class="s3">\n        </span><span class="s1">// Normalize the value.</span><span class="s3">\n        </span><span class="s1">value = Math.max(2, Math.floor(value));</span><span class="s3">\n        </span><span class="s1">// Bail early if the value does not change.</span><span class="s3">\n        </span><span class="s1">if (this._minimumSize === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal minimum size.</span><span class="s3">\n        </span><span class="s1">this._minimumSize = value;</span><span class="s3">\n        </span><span class="s1">// Update default size if larger than minimum size</span><span class="s3">\n        </span><span class="s1">if (value &gt; this._defaultSize) {</span><span class="s3">\n            </span><span class="s1">this.defaultSize = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the default size of sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get defaultSize() {</span><span class="s3">\n        </span><span class="s1">return this._defaultSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the default size of sections in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set defaultSize(value) {</span><span class="s3">\n        </span><span class="s1">// Normalize the value.</span><span class="s3">\n        </span><span class="s1">value = Math.max(this._minimumSize, Math.floor(value));</span><span class="s3">\n        </span><span class="s1">// Bail early if the value does not change.</span><span class="s3">\n        </span><span class="s1">if (this._defaultSize === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the delta default size.</span><span class="s3">\n        </span><span class="s1">let delta = value - this._defaultSize;</span><span class="s3">\n        </span><span class="s1">// Update the internal default size.</span><span class="s3">\n        </span><span class="s1">this._defaultSize = value;</span><span class="s3">\n        </span><span class="s1">// Update the length.</span><span class="s3">\n        </span><span class="s1">this._length += delta * (this._count - this._sections.length);</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Recompute the offsets of the modified sections.</span><span class="s3">\n        </span><span class="s1">for (let i = 0, n = this._sections.length; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">// Look up the previous and current modified sections.</span><span class="s3">\n            </span><span class="s1">let prev = this._sections[i - 1];</span><span class="s3">\n            </span><span class="s1">let curr = this._sections[i];</span><span class="s3">\n            </span><span class="s1">// Adjust the offset for the current section.</span><span class="s3">\n            </span><span class="s1">if (prev) {</span><span class="s3">\n                </span><span class="s1">let count = curr.index - prev.index - 1;</span><span class="s3">\n                </span><span class="s1">curr.offset = prev.offset + prev.size + count * value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">curr.offset = curr.index * value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clamp a size to the minimum section size</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param size - The size to clamp.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The size or the section minimum size, whichever is larger</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clampSize(size) {</span><span class="s3">\n        </span><span class="s1">return Math.max(this._minimumSize, Math.floor(size));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the index of the section which covers the given offset.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param offset - The offset of the section of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The index of the section which covers the given offset,</span><span class="s3">\n     </span><span class="s1">*   or `-1` if the offset is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Logarithmic on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">indexOf(offset) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the offset is out of range.</span><span class="s3">\n        </span><span class="s1">if (offset &lt; 0 || offset &gt;= this._length || this._count === 0) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return Math.floor(offset / this._defaultSize);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given offset.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, offset, Private$2.offsetCmp);</span><span class="s3">\n        </span><span class="s1">// Return the index of an exact match.</span><span class="s3">\n        </span><span class="s1">if (i &lt; this._sections.length &amp;&amp; this._sections[i].offset &lt;= offset) {</span><span class="s3">\n            </span><span class="s1">return this._sections[i].index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the case of no modified sections before the offset.</span><span class="s3">\n        </span><span class="s1">if (i === 0) {</span><span class="s3">\n            </span><span class="s1">return Math.floor(offset / this._defaultSize);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the index from the previous modified section.</span><span class="s3">\n        </span><span class="s1">let section = this._sections[i - 1];</span><span class="s3">\n        </span><span class="s1">let span = offset - (section.offset + section.size);</span><span class="s3">\n        </span><span class="s1">return section.index + Math.floor(span / this._defaultSize) + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the offset of the section at the given index.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the section of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The offset of the section at the given index, or `-1`</span><span class="s3">\n     </span><span class="s1">*   if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Logarithmic on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">offsetOf(index) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return index * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Return the offset of an exact match.</span><span class="s3">\n        </span><span class="s1">if (i &lt; this._sections.length &amp;&amp; this._sections[i].index === index) {</span><span class="s3">\n            </span><span class="s1">return this._sections[i].offset;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the case of no modified sections before the index.</span><span class="s3">\n        </span><span class="s1">if (i === 0) {</span><span class="s3">\n            </span><span class="s1">return index * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the offset from the previous modified section.</span><span class="s3">\n        </span><span class="s1">let section = this._sections[i - 1];</span><span class="s3">\n        </span><span class="s1">let span = index - section.index - 1;</span><span class="s3">\n        </span><span class="s1">return section.offset + section.size + span * this._defaultSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the extent of the section at the given index.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the section of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The extent of the section at the given index, or `-1`</span><span class="s3">\n     </span><span class="s1">*   if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Logarithmic on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">extentOf(index) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return (index + 1) * this._defaultSize - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Return the offset of an exact match.</span><span class="s3">\n        </span><span class="s1">if (i &lt; this._sections.length &amp;&amp; this._sections[i].index === index) {</span><span class="s3">\n            </span><span class="s1">return this._sections[i].offset + this._sections[i].size - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the case of no modified sections before the index.</span><span class="s3">\n        </span><span class="s1">if (i === 0) {</span><span class="s3">\n            </span><span class="s1">return (index + 1) * this._defaultSize - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the offset from the previous modified section.</span><span class="s3">\n        </span><span class="s1">let section = this._sections[i - 1];</span><span class="s3">\n        </span><span class="s1">let span = index - section.index;</span><span class="s3">\n        </span><span class="s1">return section.offset + section.size + span * this._defaultSize - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Find the size of the section at the given index.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the section of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The size of the section at the given index, or `-1`</span><span class="s3">\n     </span><span class="s1">*   if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Logarithmic on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sizeOf(index) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return this._defaultSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Return the size of an exact match.</span><span class="s3">\n        </span><span class="s1">if (i &lt; this._sections.length &amp;&amp; this._sections[i].index === index) {</span><span class="s3">\n            </span><span class="s1">return this._sections[i].size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the default size for all other cases.</span><span class="s3">\n        </span><span class="s1">return this._defaultSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a section in the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the section to resize. This method</span><span class="s3">\n     </span><span class="s1">*   is a no-op if this value is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param size - The new size of the section. This value will be</span><span class="s3">\n     </span><span class="s1">*   clamped to an integer `&gt;= 0`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resize(index, size) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the size to an integer &gt;= minimum size.</span><span class="s3">\n        </span><span class="s1">size = Math.max(this._minimumSize, Math.floor(size));</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Update or create the modified section as needed.</span><span class="s3">\n        </span><span class="s1">let delta;</span><span class="s3">\n        </span><span class="s1">if (i &lt; this._sections.length &amp;&amp; this._sections[i].index === index) {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[i];</span><span class="s3">\n            </span><span class="s1">delta = size - section.size;</span><span class="s3">\n            </span><span class="s1">section.size = size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (i === 0) {</span><span class="s3">\n            </span><span class="s1">let offset = index * this._defaultSize;</span><span class="s3">\n            </span><span class="s1">ArrayExt.insert(this._sections, i, { index, offset, size });</span><span class="s3">\n            </span><span class="s1">delta = size - this._defaultSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[i - 1];</span><span class="s3">\n            </span><span class="s1">let span = index - section.index - 1;</span><span class="s3">\n            </span><span class="s1">let offset = section.offset + section.size + span * this._defaultSize;</span><span class="s3">\n            </span><span class="s1">ArrayExt.insert(this._sections, i, { index, offset, size });</span><span class="s3">\n            </span><span class="s1">delta = size - this._defaultSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the length.</span><span class="s3">\n        </span><span class="s1">this._length += delta;</span><span class="s3">\n        </span><span class="s1">// Update all modified sections after the resized section.</span><span class="s3">\n        </span><span class="s1">for (let j = i + 1, n = this._sections.length; j &lt; n; ++j) {</span><span class="s3">\n            </span><span class="s1">this._sections[j].offset += delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Insert sections into the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index at which to insert the sections. This</span><span class="s3">\n     </span><span class="s1">*   value will be clamped to the bounds of the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param count - The number of sections to insert. This method</span><span class="s3">\n     </span><span class="s1">*   is a no-op if this value is `&lt;= 0`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` or `count` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">insert(index, count) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to insert.</span><span class="s3">\n        </span><span class="s1">if (count &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the index to the bounds of the list.</span><span class="s3">\n        </span><span class="s1">index = Math.max(0, Math.min(index, this._count));</span><span class="s3">\n        </span><span class="s1">// Add the new sections to the totals.</span><span class="s3">\n        </span><span class="s1">let span = count * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">this._count += count;</span><span class="s3">\n        </span><span class="s1">this._length += span;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no modified sections to update.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the given index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Update all modified sections after the insert location.</span><span class="s3">\n        </span><span class="s1">for (let n = this._sections.length; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[i];</span><span class="s3">\n            </span><span class="s1">section.index += count;</span><span class="s3">\n            </span><span class="s1">section.offset += span;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove sections from the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the first section to remove. This</span><span class="s3">\n     </span><span class="s1">*   method is a no-op if this value is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param count - The number of sections to remove. This method</span><span class="s3">\n     </span><span class="s1">*   is a no-op if this value is `&lt;= 0`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index` or `count` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">remove(index, count) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to remove.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count || count &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the count to the bounds of the list.</span><span class="s3">\n        </span><span class="s1">count = Math.min(this._count - index, count);</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections to update.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">this._count -= count;</span><span class="s3">\n            </span><span class="s1">this._length -= count * this._defaultSize;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of removing all sections.</span><span class="s3">\n        </span><span class="s1">if (count === this._count) {</span><span class="s3">\n            </span><span class="s1">this._length = 0;</span><span class="s3">\n            </span><span class="s1">this._count = 0;</span><span class="s3">\n            </span><span class="s1">this._sections.length = 0;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the start index.</span><span class="s3">\n        </span><span class="s1">let i = ArrayExt.lowerBound(this._sections, index, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Find the modified section for the end index.</span><span class="s3">\n        </span><span class="s1">let j = ArrayExt.lowerBound(this._sections, index + count, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Remove the relevant modified sections.</span><span class="s3">\n        </span><span class="s1">let removed = this._sections.splice(i, j - i);</span><span class="s3">\n        </span><span class="s1">// Compute the total removed span.</span><span class="s3">\n        </span><span class="s1">let span = (count - removed.length) * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">for (let k = 0, n = removed.length; k &lt; n; ++k) {</span><span class="s3">\n            </span><span class="s1">span += removed[k].size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the totals.</span><span class="s3">\n        </span><span class="s1">this._count -= count;</span><span class="s3">\n        </span><span class="s1">this._length -= span;</span><span class="s3">\n        </span><span class="s1">// Update all modified sections after the removed span.</span><span class="s3">\n        </span><span class="s1">for (let k = i, n = this._sections.length; k &lt; n; ++k) {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[k];</span><span class="s3">\n            </span><span class="s1">section.index -= count;</span><span class="s3">\n            </span><span class="s1">section.offset -= span;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Move sections within the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the first section to move. This method</span><span class="s3">\n     </span><span class="s1">*   is a no-op if this value is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param count - The number of sections to move. This method is a</span><span class="s3">\n     </span><span class="s1">*   no-op if this value is `&lt;= 0`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param destination - The destination index for the first section.</span><span class="s3">\n     </span><span class="s1">*   This value will be clamped to the allowable range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Undefined Behavior</span><span class="s3">\n     </span><span class="s1">* An `index`, `count`, or `destination` which is non-integral.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Linear on the number of moved resized sections.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">move(index, count, destination) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to move.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= this._count || count &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Handle the simple case of no modified sections.</span><span class="s3">\n        </span><span class="s1">if (this._sections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the move count to the limit.</span><span class="s3">\n        </span><span class="s1">count = Math.min(count, this._count - index);</span><span class="s3">\n        </span><span class="s1">// Clamp the destination index to the limit.</span><span class="s3">\n        </span><span class="s1">destination = Math.min(Math.max(0, destination), this._count - count);</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no effective move.</span><span class="s3">\n        </span><span class="s1">if (index === destination) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the first affected index.</span><span class="s3">\n        </span><span class="s1">let i1 = Math.min(index, destination);</span><span class="s3">\n        </span><span class="s1">// Look up the first affected modified section.</span><span class="s3">\n        </span><span class="s1">let k1 = ArrayExt.lowerBound(this._sections, i1, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no affected modified sections.</span><span class="s3">\n        </span><span class="s1">if (k1 === this._sections.length) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the last affected index.</span><span class="s3">\n        </span><span class="s1">let i2 = Math.max(index + count - 1, destination + count - 1);</span><span class="s3">\n        </span><span class="s1">// Look up the last affected modified section.</span><span class="s3">\n        </span><span class="s1">let k2 = ArrayExt.upperBound(this._sections, i2, Private$2.indexCmp) - 1;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no affected modified sections.</span><span class="s3">\n        </span><span class="s1">if (k2 &lt; k1) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the pivot index.</span><span class="s3">\n        </span><span class="s1">let pivot = destination &lt; index ? index : index + count;</span><span class="s3">\n        </span><span class="s1">// Compute the count for each side of the pivot.</span><span class="s3">\n        </span><span class="s1">let count1 = pivot - i1;</span><span class="s3">\n        </span><span class="s1">let count2 = i2 - pivot + 1;</span><span class="s3">\n        </span><span class="s1">// Compute the span for each side of the pivot.</span><span class="s3">\n        </span><span class="s1">let span1 = count1 * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">let span2 = count2 * this._defaultSize;</span><span class="s3">\n        </span><span class="s1">// Adjust the spans for the modified sections.</span><span class="s3">\n        </span><span class="s1">for (let j = k1; j &lt;= k2; ++j) {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[j];</span><span class="s3">\n            </span><span class="s1">if (section.index &lt; pivot) {</span><span class="s3">\n                </span><span class="s1">span1 += section.size - this._defaultSize;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">span2 += section.size - this._defaultSize;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the pivot section.</span><span class="s3">\n        </span><span class="s1">let k3 = ArrayExt.lowerBound(this._sections, pivot, Private$2.indexCmp);</span><span class="s3">\n        </span><span class="s1">// Rotate the modified sections if needed.</span><span class="s3">\n        </span><span class="s1">if (k1 &lt;= k3 &amp;&amp; k3 &lt;= k2) {</span><span class="s3">\n            </span><span class="s1">ArrayExt.rotate(this._sections, k3 - k1, k1, k2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the modified section indices and offsets.</span><span class="s3">\n        </span><span class="s1">for (let j = k1; j &lt;= k2; ++j) {</span><span class="s3">\n            </span><span class="s1">let section = this._sections[j];</span><span class="s3">\n            </span><span class="s1">if (section.index &lt; pivot) {</span><span class="s3">\n                </span><span class="s1">section.index += count2;</span><span class="s3">\n                </span><span class="s1">section.offset += span2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">section.index -= count1;</span><span class="s3">\n                </span><span class="s1">section.offset -= span1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reset all modified sections to the default size.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reset() {</span><span class="s3">\n        </span><span class="s1">this._sections.length = 0;</span><span class="s3">\n        </span><span class="s1">this._length = this._count * this._defaultSize;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove all sections from the list.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Complexity</span><span class="s3">\n     </span><span class="s1">* Constant.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clear() {</span><span class="s3">\n        </span><span class="s1">this._count = 0;</span><span class="s3">\n        </span><span class="s1">this._length = 0;</span><span class="s3">\n        </span><span class="s1">this._sections.length = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$2;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A comparison function for searching by offset.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function offsetCmp(section, offset) {</span><span class="s3">\n        </span><span class="s1">if (offset &lt; section.offset) {</span><span class="s3">\n            </span><span class="s1">return 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (section.offset + section.size &lt;= offset) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.offsetCmp = offsetCmp;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A comparison function for searching by index.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function indexCmp(section, index) {</span><span class="s3">\n        </span><span class="s1">return section.index - index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.indexCmp = indexCmp;</span><span class="s3">\n</span><span class="s1">})(Private$2 || (Private$2 = {}));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A widget which implements a high-performance tabular data grid.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* #### Notes</span><span class="s3">\n </span><span class="s1">* A data grid is implemented as a composition of child widgets. These</span><span class="s3">\n </span><span class="s1">* child widgets are considered an implementation detail. Manipulating</span><span class="s3">\n </span><span class="s1">* the child widgets of a data grid directly is undefined behavior.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This class is not designed to be subclassed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* See also the related [example](../../examples/datagrid/index.html) and</span><span class="s3">\n </span><span class="s1">* its [source](https://github.com/jupyterlab/lumino/tree/main/examples/example-datagrid).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DataGrid extends Widget {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options = {}) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this._scrollX = 0;</span><span class="s3">\n        </span><span class="s1">this._scrollY = 0;</span><span class="s3">\n        </span><span class="s1">this._viewportWidth = 0;</span><span class="s3">\n        </span><span class="s1">this._viewportHeight = 0;</span><span class="s3">\n        </span><span class="s1">this._mousedown = false;</span><span class="s3">\n        </span><span class="s1">this._keyHandler = null;</span><span class="s3">\n        </span><span class="s1">this._mouseHandler = null;</span><span class="s3">\n        </span><span class="s1">this._vScrollBarMinWidth = 0;</span><span class="s3">\n        </span><span class="s1">this._hScrollBarMinHeight = 0;</span><span class="s3">\n        </span><span class="s1">this._dpiRatio = Math.ceil(window.devicePixelRatio);</span><span class="s3">\n        </span><span class="s1">this._dataModel = null;</span><span class="s3">\n        </span><span class="s1">this._selectionModel = null;</span><span class="s3">\n        </span><span class="s1">this._editingEnabled = false;</span><span class="s3">\n        </span><span class="s1">this.addClass('lm-DataGrid');</span><span class="s3">\n        </span><span class="s1">// Parse the simple options.</span><span class="s3">\n        </span><span class="s1">this._style = options.style || DataGrid.defaultStyle;</span><span class="s3">\n        </span><span class="s1">this._stretchLastRow = options.stretchLastRow || false;</span><span class="s3">\n        </span><span class="s1">this._stretchLastColumn = options.stretchLastColumn || false;</span><span class="s3">\n        </span><span class="s1">this._headerVisibility = options.headerVisibility || 'all';</span><span class="s3">\n        </span><span class="s1">this._cellRenderers = options.cellRenderers || new RendererMap();</span><span class="s3">\n        </span><span class="s1">this._copyConfig = options.copyConfig || DataGrid.defaultCopyConfig;</span><span class="s3">\n        </span><span class="s1">// Connect to the renderer map changed signal.</span><span class="s3">\n        </span><span class="s1">this._cellRenderers.changed.connect(this._onRenderersChanged, this);</span><span class="s3">\n        </span><span class="s1">// Parse the default sizes.</span><span class="s3">\n        </span><span class="s1">let defaultSizes = options.defaultSizes || DataGrid.defaultSizes;</span><span class="s3">\n        </span><span class="s1">let minimumSizes = options.minimumSizes || DataGrid.minimumSizes;</span><span class="s3">\n        </span><span class="s1">// Set up the sections lists.</span><span class="s3">\n        </span><span class="s1">this._rowSections = new SectionList({</span><span class="s3">\n            </span><span class="s1">defaultSize: defaultSizes.rowHeight,</span><span class="s3">\n            </span><span class="s1">minimumSize: minimumSizes.rowHeight</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this._columnSections = new SectionList({</span><span class="s3">\n            </span><span class="s1">defaultSize: defaultSizes.columnWidth,</span><span class="s3">\n            </span><span class="s1">minimumSize: minimumSizes.columnWidth</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this._rowHeaderSections = new SectionList({</span><span class="s3">\n            </span><span class="s1">defaultSize: defaultSizes.rowHeaderWidth,</span><span class="s3">\n            </span><span class="s1">minimumSize: minimumSizes.rowHeaderWidth</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this._columnHeaderSections = new SectionList({</span><span class="s3">\n            </span><span class="s1">defaultSize: defaultSizes.columnHeaderHeight,</span><span class="s3">\n            </span><span class="s1">minimumSize: minimumSizes.columnHeaderHeight</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Create the canvas, buffer, and overlay objects.</span><span class="s3">\n        </span><span class="s1">this._canvas = Private$1.createCanvas();</span><span class="s3">\n        </span><span class="s1">this._buffer = Private$1.createCanvas();</span><span class="s3">\n        </span><span class="s1">this._overlay = Private$1.createCanvas();</span><span class="s3">\n        </span><span class="s1">// Get the graphics contexts for the canvases.</span><span class="s3">\n        </span><span class="s1">this._canvasGC = this._canvas.getContext('2d');</span><span class="s3">\n        </span><span class="s1">this._bufferGC = this._buffer.getContext('2d');</span><span class="s3">\n        </span><span class="s1">this._overlayGC = this._overlay.getContext('2d');</span><span class="s3">\n        </span><span class="s1">// Set up the on-screen canvas.</span><span class="s3">\n        </span><span class="s1">this._canvas.style.position = 'absolute';</span><span class="s3">\n        </span><span class="s1">this._canvas.style.top = '0px';</span><span class="s3">\n        </span><span class="s1">this._canvas.style.left = '0px';</span><span class="s3">\n        </span><span class="s1">this._canvas.style.width = '0px';</span><span class="s3">\n        </span><span class="s1">this._canvas.style.height = '0px';</span><span class="s3">\n        </span><span class="s1">// Set up the on-screen overlay.</span><span class="s3">\n        </span><span class="s1">this._overlay.style.position = 'absolute';</span><span class="s3">\n        </span><span class="s1">this._overlay.style.top = '0px';</span><span class="s3">\n        </span><span class="s1">this._overlay.style.left = '0px';</span><span class="s3">\n        </span><span class="s1">this._overlay.style.width = '0px';</span><span class="s3">\n        </span><span class="s1">this._overlay.style.height = '0px';</span><span class="s3">\n        </span><span class="s1">// Create the internal widgets for the data grid.</span><span class="s3">\n        </span><span class="s1">this._viewport = new Widget();</span><span class="s3">\n        </span><span class="s1">this._viewport.node.tabIndex = -1;</span><span class="s3">\n        </span><span class="s1">this._viewport.node.style.outline = 'none';</span><span class="s3">\n        </span><span class="s1">this._vScrollBar = new ScrollBar({ orientation: 'vertical' });</span><span class="s3">\n        </span><span class="s1">this._hScrollBar = new ScrollBar({ orientation: 'horizontal' });</span><span class="s3">\n        </span><span class="s1">this._scrollCorner = new Widget();</span><span class="s3">\n        </span><span class="s1">this._editorController = new CellEditorController();</span><span class="s3">\n        </span><span class="s1">// Add the extra class names to the child widgets.</span><span class="s3">\n        </span><span class="s1">this._viewport.addClass('lm-DataGrid-viewport');</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.addClass('lm-DataGrid-scrollBar');</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.addClass('lm-DataGrid-scrollBar');</span><span class="s3">\n        </span><span class="s1">this._scrollCorner.addClass('lm-DataGrid-scrollCorner');</span><span class="s3">\n        </span><span class="s1">// Add the on-screen canvas to the viewport node.</span><span class="s3">\n        </span><span class="s1">this._viewport.node.appendChild(this._canvas);</span><span class="s3">\n        </span><span class="s1">// Add the on-screen overlay to the viewport node.</span><span class="s3">\n        </span><span class="s1">this._viewport.node.appendChild(this._overlay);</span><span class="s3">\n        </span><span class="s1">// Install the message hooks.</span><span class="s3">\n        </span><span class="s1">MessageLoop.installMessageHook(this._viewport, this);</span><span class="s3">\n        </span><span class="s1">MessageLoop.installMessageHook(this._hScrollBar, this);</span><span class="s3">\n        </span><span class="s1">MessageLoop.installMessageHook(this._vScrollBar, this);</span><span class="s3">\n        </span><span class="s1">// Hide the scroll bars and corner from the outset.</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.hide();</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.hide();</span><span class="s3">\n        </span><span class="s1">this._scrollCorner.hide();</span><span class="s3">\n        </span><span class="s1">// Connect to the scroll bar signals.</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.thumbMoved.connect(this._onThumbMoved, this);</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.thumbMoved.connect(this._onThumbMoved, this);</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.pageRequested.connect(this._onPageRequested, this);</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.pageRequested.connect(this._onPageRequested, this);</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.stepRequested.connect(this._onStepRequested, this);</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.stepRequested.connect(this._onStepRequested, this);</span><span class="s3">\n        </span><span class="s1">// Set the layout cell config for the child widgets.</span><span class="s3">\n        </span><span class="s1">GridLayout.setCellConfig(this._viewport, { row: 0, column: 0 });</span><span class="s3">\n        </span><span class="s1">GridLayout.setCellConfig(this._vScrollBar, { row: 0, column: 1 });</span><span class="s3">\n        </span><span class="s1">GridLayout.setCellConfig(this._hScrollBar, { row: 1, column: 0 });</span><span class="s3">\n        </span><span class="s1">GridLayout.setCellConfig(this._scrollCorner, { row: 1, column: 1 });</span><span class="s3">\n        </span><span class="s1">// Create the layout for the data grid.</span><span class="s3">\n        </span><span class="s1">let layout = new GridLayout({</span><span class="s3">\n            </span><span class="s1">rowCount: 2,</span><span class="s3">\n            </span><span class="s1">columnCount: 2,</span><span class="s3">\n            </span><span class="s1">rowSpacing: 0,</span><span class="s3">\n            </span><span class="s1">columnSpacing: 0,</span><span class="s3">\n            </span><span class="s1">fitPolicy: 'set-no-constraint'</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Set the stretch factors for the grid.</span><span class="s3">\n        </span><span class="s1">layout.setRowStretch(0, 1);</span><span class="s3">\n        </span><span class="s1">layout.setRowStretch(1, 0);</span><span class="s3">\n        </span><span class="s1">layout.setColumnStretch(0, 1);</span><span class="s3">\n        </span><span class="s1">layout.setColumnStretch(1, 0);</span><span class="s3">\n        </span><span class="s1">// Add the child widgets to the layout.</span><span class="s3">\n        </span><span class="s1">layout.addWidget(this._viewport);</span><span class="s3">\n        </span><span class="s1">layout.addWidget(this._vScrollBar);</span><span class="s3">\n        </span><span class="s1">layout.addWidget(this._hScrollBar);</span><span class="s3">\n        </span><span class="s1">layout.addWidget(this._scrollCorner);</span><span class="s3">\n        </span><span class="s1">// Install the layout on the data grid.</span><span class="s3">\n        </span><span class="s1">this.layout = layout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources held by the widgets.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n        </span><span class="s1">// Dispose of the handlers.</span><span class="s3">\n        </span><span class="s1">if (this._keyHandler) {</span><span class="s3">\n            </span><span class="s1">this._keyHandler.dispose();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.dispose();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._keyHandler = null;</span><span class="s3">\n        </span><span class="s1">this._mouseHandler = null;</span><span class="s3">\n        </span><span class="s1">// Clear the models.</span><span class="s3">\n        </span><span class="s1">this._dataModel = null;</span><span class="s3">\n        </span><span class="s1">this._selectionModel = null;</span><span class="s3">\n        </span><span class="s1">// Clear the section lists.</span><span class="s3">\n        </span><span class="s1">this._rowSections.clear();</span><span class="s3">\n        </span><span class="s1">this._columnSections.clear();</span><span class="s3">\n        </span><span class="s1">this._rowHeaderSections.clear();</span><span class="s3">\n        </span><span class="s1">this._columnHeaderSections.clear();</span><span class="s3">\n        </span><span class="s1">// Dispose of the base class.</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the data model for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get dataModel() {</span><span class="s3">\n        </span><span class="s1">return this._dataModel;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the data model for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This will automatically remove the current selection model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set dataModel(value) {</span><span class="s3">\n        </span><span class="s1">// Do nothing if the model does not change.</span><span class="s3">\n        </span><span class="s1">if (this._dataModel === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n        </span><span class="s1">// Clear the selection model.</span><span class="s3">\n        </span><span class="s1">this.selectionModel = null;</span><span class="s3">\n        </span><span class="s1">// Disconnect the change handler from the old model.</span><span class="s3">\n        </span><span class="s1">if (this._dataModel) {</span><span class="s3">\n            </span><span class="s1">this._dataModel.changed.disconnect(this._onDataModelChanged, this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Connect the change handler for the new model.</span><span class="s3">\n        </span><span class="s1">if (value) {</span><span class="s3">\n            </span><span class="s1">value.changed.connect(this._onDataModelChanged, this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal model reference.</span><span class="s3">\n        </span><span class="s1">this._dataModel = value;</span><span class="s3">\n        </span><span class="s1">// Clear the section lists.</span><span class="s3">\n        </span><span class="s1">this._rowSections.clear();</span><span class="s3">\n        </span><span class="s1">this._columnSections.clear();</span><span class="s3">\n        </span><span class="s1">this._rowHeaderSections.clear();</span><span class="s3">\n        </span><span class="s1">this._columnHeaderSections.clear();</span><span class="s3">\n        </span><span class="s1">// Populate the section lists.</span><span class="s3">\n        </span><span class="s1">if (value) {</span><span class="s3">\n            </span><span class="s1">this._rowSections.insert(0, value.rowCount('body'));</span><span class="s3">\n            </span><span class="s1">this._columnSections.insert(0, value.columnCount('body'));</span><span class="s3">\n            </span><span class="s1">this._rowHeaderSections.insert(0, value.columnCount('row-header'));</span><span class="s3">\n            </span><span class="s1">this._columnHeaderSections.insert(0, value.rowCount('column-header'));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Reset the scroll position.</span><span class="s3">\n        </span><span class="s1">this._scrollX = 0;</span><span class="s3">\n        </span><span class="s1">this._scrollY = 0;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the selection model for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get selectionModel() {</span><span class="s3">\n        </span><span class="s1">return this._selectionModel;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the selection model for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set selectionModel(value) {</span><span class="s3">\n        </span><span class="s1">// Do nothing if the selection model does not change.</span><span class="s3">\n        </span><span class="s1">if (this._selectionModel === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n        </span><span class="s1">// Ensure the data models are a match.</span><span class="s3">\n        </span><span class="s1">if (value &amp;&amp; value.dataModel !== this._dataModel) {</span><span class="s3">\n            </span><span class="s1">throw new Error('SelectionModel.dataModel !== DataGrid.dataModel');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Disconnect the change handler from the old model.</span><span class="s3">\n        </span><span class="s1">if (this._selectionModel) {</span><span class="s3">\n            </span><span class="s1">this._selectionModel.changed.disconnect(this._onSelectionsChanged, this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Connect the change handler for the new model.</span><span class="s3">\n        </span><span class="s1">if (value) {</span><span class="s3">\n            </span><span class="s1">value.changed.connect(this._onSelectionsChanged, this);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal selection model reference.</span><span class="s3">\n        </span><span class="s1">this._selectionModel = value;</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the overlay.</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the key handler for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get keyHandler() {</span><span class="s3">\n        </span><span class="s1">return this._keyHandler;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the key handler for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set keyHandler(value) {</span><span class="s3">\n        </span><span class="s1">this._keyHandler = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the mouse handler for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get mouseHandler() {</span><span class="s3">\n        </span><span class="s1">return this._mouseHandler;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the mouse handler for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set mouseHandler(value) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the mouse handler does not change.</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n        </span><span class="s1">// Update the internal mouse handler.</span><span class="s3">\n        </span><span class="s1">this._mouseHandler = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the style for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get style() {</span><span class="s3">\n        </span><span class="s1">return this._style;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the style for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set style(value) {</span><span class="s3">\n        </span><span class="s1">// Bail if the style does not change.</span><span class="s3">\n        </span><span class="s1">if (this._style === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal style.</span><span class="s3">\n        </span><span class="s1">this._style = { ...value };</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the content.</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the overlay.</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the cell renderer map for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cellRenderers() {</span><span class="s3">\n        </span><span class="s1">return this._cellRenderers;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the cell renderer map for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set cellRenderers(value) {</span><span class="s3">\n        </span><span class="s1">// Bail if the renderer map does not change.</span><span class="s3">\n        </span><span class="s1">if (this._cellRenderers === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Disconnect the old map.</span><span class="s3">\n        </span><span class="s1">this._cellRenderers.changed.disconnect(this._onRenderersChanged, this);</span><span class="s3">\n        </span><span class="s1">// Connect the new map.</span><span class="s3">\n        </span><span class="s1">value.changed.connect(this._onRenderersChanged, this);</span><span class="s3">\n        </span><span class="s1">// Update the internal renderer map.</span><span class="s3">\n        </span><span class="s1">this._cellRenderers = value;</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the grid content.</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the header visibility for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get headerVisibility() {</span><span class="s3">\n        </span><span class="s1">return this._headerVisibility;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the header visibility for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set headerVisibility(value) {</span><span class="s3">\n        </span><span class="s1">// Bail if the visibility does not change.</span><span class="s3">\n        </span><span class="s1">if (this._headerVisibility === value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal visibility.</span><span class="s3">\n        </span><span class="s1">this._headerVisibility = value;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the default sizes for the various sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get defaultSizes() {</span><span class="s3">\n        </span><span class="s1">let rowHeight = this._rowSections.defaultSize;</span><span class="s3">\n        </span><span class="s1">let columnWidth = this._columnSections.defaultSize;</span><span class="s3">\n        </span><span class="s1">let rowHeaderWidth = this._rowHeaderSections.defaultSize;</span><span class="s3">\n        </span><span class="s1">let columnHeaderHeight = this._columnHeaderSections.defaultSize;</span><span class="s3">\n        </span><span class="s1">return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the default sizes for the various sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set defaultSizes(value) {</span><span class="s3">\n        </span><span class="s1">// Update the section default sizes.</span><span class="s3">\n        </span><span class="s1">this._rowSections.defaultSize = value.rowHeight;</span><span class="s3">\n        </span><span class="s1">this._columnSections.defaultSize = value.columnWidth;</span><span class="s3">\n        </span><span class="s1">this._rowHeaderSections.defaultSize = value.rowHeaderWidth;</span><span class="s3">\n        </span><span class="s1">this._columnHeaderSections.defaultSize = value.columnHeaderHeight;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the minimum sizes for the various sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get minimumSizes() {</span><span class="s3">\n        </span><span class="s1">let rowHeight = this._rowSections.minimumSize;</span><span class="s3">\n        </span><span class="s1">let columnWidth = this._columnSections.minimumSize;</span><span class="s3">\n        </span><span class="s1">let rowHeaderWidth = this._rowHeaderSections.minimumSize;</span><span class="s3">\n        </span><span class="s1">let columnHeaderHeight = this._columnHeaderSections.minimumSize;</span><span class="s3">\n        </span><span class="s1">return { rowHeight, columnWidth, rowHeaderWidth, columnHeaderHeight };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the minimum sizes for the various sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set minimumSizes(value) {</span><span class="s3">\n        </span><span class="s1">// Update the section default sizes.</span><span class="s3">\n        </span><span class="s1">this._rowSections.minimumSize = value.rowHeight;</span><span class="s3">\n        </span><span class="s1">this._columnSections.minimumSize = value.columnWidth;</span><span class="s3">\n        </span><span class="s1">this._rowHeaderSections.minimumSize = value.rowHeaderWidth;</span><span class="s3">\n        </span><span class="s1">this._columnHeaderSections.minimumSize = value.columnHeaderHeight;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the copy configuration for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get copyConfig() {</span><span class="s3">\n        </span><span class="s1">return this._copyConfig;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the copy configuration for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set copyConfig(value) {</span><span class="s3">\n        </span><span class="s1">this._copyConfig = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get whether the last row is stretched.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get stretchLastRow() {</span><span class="s3">\n        </span><span class="s1">return this._stretchLastRow;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set whether the last row is stretched.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set stretchLastRow(value) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the value does not change.</span><span class="s3">\n        </span><span class="s1">if (value === this._stretchLastRow) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal value.</span><span class="s3">\n        </span><span class="s1">this._stretchLastRow = value;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get whether the last column is stretched.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get stretchLastColumn() {</span><span class="s3">\n        </span><span class="s1">return this._stretchLastColumn;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set whether the last column is stretched.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set stretchLastColumn(value) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the value does not change.</span><span class="s3">\n        </span><span class="s1">if (value === this._stretchLastColumn) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal value.</span><span class="s3">\n        </span><span class="s1">this._stretchLastColumn = value;</span><span class="s3">\n        </span><span class="s1">// Sync the viewport</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual width of the row headers.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get headerWidth() {</span><span class="s3">\n        </span><span class="s1">if (this._headerVisibility === 'none') {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._headerVisibility === 'column') {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._rowHeaderSections.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual height of the column headers.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get headerHeight() {</span><span class="s3">\n        </span><span class="s1">if (this._headerVisibility === 'none') {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._headerVisibility === 'row') {</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._columnHeaderSections.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual width of the grid body.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This does *not* account for a stretched last column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get bodyWidth() {</span><span class="s3">\n        </span><span class="s1">return this._columnSections.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual height of the grid body.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This does *not* account for a stretched last row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get bodyHeight() {</span><span class="s3">\n        </span><span class="s1">return this._rowSections.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual width of the entire grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This does *not* account for a stretched last column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get totalWidth() {</span><span class="s3">\n        </span><span class="s1">return this.headerWidth + this.bodyWidth;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The virtual height of the entire grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This does *not* account for a stretched last row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get totalHeight() {</span><span class="s3">\n        </span><span class="s1">return this.headerHeight + this.bodyHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The actual width of the viewport.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewportWidth() {</span><span class="s3">\n        </span><span class="s1">return this._viewportWidth;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The actual height of the viewport.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewportHeight() {</span><span class="s3">\n        </span><span class="s1">return this._viewportHeight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The width of the visible portion of the grid body.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get pageWidth() {</span><span class="s3">\n        </span><span class="s1">return Math.max(0, this.viewportWidth - this.headerWidth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The height of the visible portion of the grid body.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get pageHeight() {</span><span class="s3">\n        </span><span class="s1">return Math.max(0, this.viewportHeight - this.headerHeight);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The current scroll X position of the viewport.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get scrollX() {</span><span class="s3">\n        </span><span class="s1">return this._hScrollBar.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The current scroll Y position of the viewport.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get scrollY() {</span><span class="s3">\n        </span><span class="s1">return this._vScrollBar.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The maximum scroll X position for the grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get maxScrollX() {</span><span class="s3">\n        </span><span class="s1">return Math.max(0, this.bodyWidth - this.pageWidth - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The maximum scroll Y position for the grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get maxScrollY() {</span><span class="s3">\n        </span><span class="s1">return Math.max(0, this.bodyHeight - this.pageHeight - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The viewport widget for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get viewport() {</span><span class="s3">\n        </span><span class="s1">return this._viewport;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The cell editor controller object for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get editorController() {</span><span class="s3">\n        </span><span class="s1">return this._editorController;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set editorController(controller) {</span><span class="s3">\n        </span><span class="s1">this._editorController = controller;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the cell editing is enabled for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get editingEnabled() {</span><span class="s3">\n        </span><span class="s1">return this._editingEnabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set editingEnabled(enabled) {</span><span class="s3">\n        </span><span class="s1">this._editingEnabled = enabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the grid cells are editable.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* `editingEnabled` flag must be on and grid must have required</span><span class="s3">\n     </span><span class="s1">* selection model, editor controller and data model properties.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get editable() {</span><span class="s3">\n        </span><span class="s1">return (this._editingEnabled &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this._selectionModel !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this._editorController !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.dataModel instanceof MutableDataModel);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The rendering context for painting the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get canvasGC() {</span><span class="s3">\n        </span><span class="s1">return this._canvasGC;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The row sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get rowSections() {</span><span class="s3">\n        </span><span class="s1">return this._rowSections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The column sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get columnSections() {</span><span class="s3">\n        </span><span class="s1">return this._columnSections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The row header sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get rowHeaderSections() {</span><span class="s3">\n        </span><span class="s1">return this._rowHeaderSections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The column header sections of the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get columnHeaderSections() {</span><span class="s3">\n        </span><span class="s1">return this._columnHeaderSections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the grid to the specified row.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This is a no-op if the row is already visible.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollToRow(row) {</span><span class="s3">\n        </span><span class="s1">// Fetch the row count.</span><span class="s3">\n        </span><span class="s1">let nr = this._rowSections.count;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no content.</span><span class="s3">\n        </span><span class="s1">if (nr === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Floor the row index.</span><span class="s3">\n        </span><span class="s1">row = Math.floor(row);</span><span class="s3">\n        </span><span class="s1">// Clamp the row index.</span><span class="s3">\n        </span><span class="s1">row = Math.max(0, Math.min(row, nr - 1));</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the row.</span><span class="s3">\n        </span><span class="s1">let y1 = this._rowSections.offsetOf(row);</span><span class="s3">\n        </span><span class="s1">let y2 = this._rowSections.extentOf(row);</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the viewport.</span><span class="s3">\n        </span><span class="s1">let vy1 = this._scrollY;</span><span class="s3">\n        </span><span class="s1">let vy2 = this._scrollY + this.pageHeight - 1;</span><span class="s3">\n        </span><span class="s1">// Set up the delta variables.</span><span class="s3">\n        </span><span class="s1">let dy = 0;</span><span class="s3">\n        </span><span class="s1">// Compute the delta Y scroll.</span><span class="s3">\n        </span><span class="s1">if (y1 &lt; vy1) {</span><span class="s3">\n            </span><span class="s1">dy = y1 - vy1 - 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (y2 &gt; vy2) {</span><span class="s3">\n            </span><span class="s1">dy = y2 - vy2 + 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if no scroll is needed.</span><span class="s3">\n        </span><span class="s1">if (dy === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll by the computed delta.</span><span class="s3">\n        </span><span class="s1">this.scrollBy(0, dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the grid to the specified column.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This is a no-op if the column is already visible.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollToColumn(column) {</span><span class="s3">\n        </span><span class="s1">// Fetch the column count.</span><span class="s3">\n        </span><span class="s1">let nc = this._columnSections.count;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no content.</span><span class="s3">\n        </span><span class="s1">if (nc === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Floor the column index.</span><span class="s3">\n        </span><span class="s1">column = Math.floor(column);</span><span class="s3">\n        </span><span class="s1">// Clamp the column index.</span><span class="s3">\n        </span><span class="s1">column = Math.max(0, Math.min(column, nc - 1));</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the column.</span><span class="s3">\n        </span><span class="s1">let x1 = this._columnSections.offsetOf(column);</span><span class="s3">\n        </span><span class="s1">let x2 = this._columnSections.extentOf(column);</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the viewport.</span><span class="s3">\n        </span><span class="s1">let vx1 = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let vx2 = this._scrollX + this.pageWidth - 1;</span><span class="s3">\n        </span><span class="s1">// Set up the delta variables.</span><span class="s3">\n        </span><span class="s1">let dx = 0;</span><span class="s3">\n        </span><span class="s1">// Compute the delta X scroll.</span><span class="s3">\n        </span><span class="s1">if (x1 &lt; vx1) {</span><span class="s3">\n            </span><span class="s1">dx = x1 - vx1 - 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (x2 &gt; vx2) {</span><span class="s3">\n            </span><span class="s1">dx = x2 - vx2 + 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if no scroll is needed.</span><span class="s3">\n        </span><span class="s1">if (dx === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll by the computed delta.</span><span class="s3">\n        </span><span class="s1">this.scrollBy(dx, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the grid to the specified cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This is a no-op if the cell is already visible.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollToCell(row, column) {</span><span class="s3">\n        </span><span class="s1">// Fetch the row and column count.</span><span class="s3">\n        </span><span class="s1">let nr = this._rowSections.count;</span><span class="s3">\n        </span><span class="s1">let nc = this._columnSections.count;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no content.</span><span class="s3">\n        </span><span class="s1">if (nr === 0 || nc === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Floor the cell index.</span><span class="s3">\n        </span><span class="s1">row = Math.floor(row);</span><span class="s3">\n        </span><span class="s1">column = Math.floor(column);</span><span class="s3">\n        </span><span class="s1">// Clamp the cell index.</span><span class="s3">\n        </span><span class="s1">row = Math.max(0, Math.min(row, nr - 1));</span><span class="s3">\n        </span><span class="s1">column = Math.max(0, Math.min(column, nc - 1));</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the cell.</span><span class="s3">\n        </span><span class="s1">let x1 = this._columnSections.offsetOf(column);</span><span class="s3">\n        </span><span class="s1">let x2 = this._columnSections.extentOf(column);</span><span class="s3">\n        </span><span class="s1">let y1 = this._rowSections.offsetOf(row);</span><span class="s3">\n        </span><span class="s1">let y2 = this._rowSections.extentOf(row);</span><span class="s3">\n        </span><span class="s1">// Get the virtual bounds of the viewport.</span><span class="s3">\n        </span><span class="s1">let vx1 = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let vx2 = this._scrollX + this.pageWidth - 1;</span><span class="s3">\n        </span><span class="s1">let vy1 = this._scrollY;</span><span class="s3">\n        </span><span class="s1">let vy2 = this._scrollY + this.pageHeight - 1;</span><span class="s3">\n        </span><span class="s1">// Set up the delta variables.</span><span class="s3">\n        </span><span class="s1">let dx = 0;</span><span class="s3">\n        </span><span class="s1">let dy = 0;</span><span class="s3">\n        </span><span class="s1">// Compute the delta X scroll.</span><span class="s3">\n        </span><span class="s1">if (x1 &lt; vx1) {</span><span class="s3">\n            </span><span class="s1">dx = x1 - vx1 - 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (x2 &gt; vx2) {</span><span class="s3">\n            </span><span class="s1">dx = x2 - vx2 + 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the delta Y scroll.</span><span class="s3">\n        </span><span class="s1">if (y1 &lt; vy1) {</span><span class="s3">\n            </span><span class="s1">dy = y1 - vy1 - 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (y2 &gt; vy2) {</span><span class="s3">\n            </span><span class="s1">dy = y2 - vy2 + 10;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if no scroll is needed.</span><span class="s3">\n        </span><span class="s1">if (dx === 0 &amp;&amp; dy === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Scroll by the computed delta.</span><span class="s3">\n        </span><span class="s1">this.scrollBy(dx, dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Move cursor down/up/left/right while making sure it remains</span><span class="s3">\n     </span><span class="s1">* within the bounds of selected rectangles</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param direction - The direction of the movement.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveCursor(direction) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no selection</span><span class="s3">\n        </span><span class="s1">if (!this.dataModel ||</span><span class="s3">\n            </span><span class="s1">!this._selectionModel ||</span><span class="s3">\n            </span><span class="s1">this._selectionModel.isEmpty) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const iter = this._selectionModel.selections();</span><span class="s3">\n        </span><span class="s1">const onlyOne = iter.next() &amp;&amp; !iter.next();</span><span class="s3">\n        </span><span class="s1">// if there is a single selection that is a single cell selection</span><span class="s3">\n        </span><span class="s1">// then move the selection and cursor within grid bounds</span><span class="s3">\n        </span><span class="s1">if (onlyOne) {</span><span class="s3">\n            </span><span class="s1">const currentSel = this._selectionModel.currentSelection();</span><span class="s3">\n            </span><span class="s1">if (currentSel.r1 === currentSel.r2 &amp;&amp; currentSel.c1 === currentSel.c2) {</span><span class="s3">\n                </span><span class="s1">const dr = direction === 'down' ? 1 : direction === 'up' ? -1 : 0;</span><span class="s3">\n                </span><span class="s1">const dc = direction === 'right' ? 1 : direction === 'left' ? -1 : 0;</span><span class="s3">\n                </span><span class="s1">let newRow = currentSel.r1 + dr;</span><span class="s3">\n                </span><span class="s1">let newColumn = currentSel.c1 + dc;</span><span class="s3">\n                </span><span class="s1">const rowCount = this.dataModel.rowCount('body');</span><span class="s3">\n                </span><span class="s1">const columnCount = this.dataModel.columnCount('body');</span><span class="s3">\n                </span><span class="s1">if (newRow &gt;= rowCount) {</span><span class="s3">\n                    </span><span class="s1">newRow = 0;</span><span class="s3">\n                    </span><span class="s1">newColumn += 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (newRow === -1) {</span><span class="s3">\n                    </span><span class="s1">newRow = rowCount - 1;</span><span class="s3">\n                    </span><span class="s1">newColumn -= 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (newColumn &gt;= columnCount) {</span><span class="s3">\n                    </span><span class="s1">newColumn = 0;</span><span class="s3">\n                    </span><span class="s1">newRow += 1;</span><span class="s3">\n                    </span><span class="s1">if (newRow &gt;= rowCount) {</span><span class="s3">\n                        </span><span class="s1">newRow = 0;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (newColumn === -1) {</span><span class="s3">\n                    </span><span class="s1">newColumn = columnCount - 1;</span><span class="s3">\n                    </span><span class="s1">newRow -= 1;</span><span class="s3">\n                    </span><span class="s1">if (newRow === -1) {</span><span class="s3">\n                        </span><span class="s1">newRow = rowCount - 1;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this._selectionModel.select({</span><span class="s3">\n                    </span><span class="s1">r1: newRow,</span><span class="s3">\n                    </span><span class="s1">c1: newColumn,</span><span class="s3">\n                    </span><span class="s1">r2: newRow,</span><span class="s3">\n                    </span><span class="s1">c2: newColumn,</span><span class="s3">\n                    </span><span class="s1">cursorRow: newRow,</span><span class="s3">\n                    </span><span class="s1">cursorColumn: newColumn,</span><span class="s3">\n                    </span><span class="s1">clear: 'all'</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// if there are multiple selections, move cursor</span><span class="s3">\n        </span><span class="s1">// within selection rectangles</span><span class="s3">\n        </span><span class="s1">this._selectionModel.moveCursorWithinSelections(direction);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the grid to the current cursor position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This is a no-op if the cursor is already visible or</span><span class="s3">\n     </span><span class="s1">* if there is no selection model installed on the grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollToCursor() {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no selection model.</span><span class="s3">\n        </span><span class="s1">if (!this._selectionModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor row and column.</span><span class="s3">\n        </span><span class="s1">let row = this._selectionModel.cursorRow;</span><span class="s3">\n        </span><span class="s1">let column = this._selectionModel.cursorColumn;</span><span class="s3">\n        </span><span class="s1">// Scroll to the cursor cell.</span><span class="s3">\n        </span><span class="s1">this.scrollToCell(row, column);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the viewport by the specified amount.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param dx - The X scroll amount.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param dy - The Y scroll amount.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollBy(dx, dy) {</span><span class="s3">\n        </span><span class="s1">this.scrollTo(this.scrollX + dx, this.scrollY + dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the viewport by one page.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param dir - The desired direction of the scroll.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollByPage(dir) {</span><span class="s3">\n        </span><span class="s1">let dx = 0;</span><span class="s3">\n        </span><span class="s1">let dy = 0;</span><span class="s3">\n        </span><span class="s1">switch (dir) {</span><span class="s3">\n            </span><span class="s1">case 'up':</span><span class="s3">\n                </span><span class="s1">dy = -this.pageHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'down':</span><span class="s3">\n                </span><span class="s1">dy = this.pageHeight;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'left':</span><span class="s3">\n                </span><span class="s1">dx = -this.pageWidth;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'right':</span><span class="s3">\n                </span><span class="s1">dx = this.pageWidth;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.scrollTo(this.scrollX + dx, this.scrollY + dy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll the viewport by one cell-aligned step.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param dir - The desired direction of the scroll.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollByStep(dir) {</span><span class="s3">\n        </span><span class="s1">let r;</span><span class="s3">\n        </span><span class="s1">let c;</span><span class="s3">\n        </span><span class="s1">let x = this.scrollX;</span><span class="s3">\n        </span><span class="s1">let y = this.scrollY;</span><span class="s3">\n        </span><span class="s1">let rows = this._rowSections;</span><span class="s3">\n        </span><span class="s1">let columns = this._columnSections;</span><span class="s3">\n        </span><span class="s1">switch (dir) {</span><span class="s3">\n            </span><span class="s1">case 'up':</span><span class="s3">\n                </span><span class="s1">r = rows.indexOf(y - 1);</span><span class="s3">\n                </span><span class="s1">y = r &lt; 0 ? y : rows.offsetOf(r);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'down':</span><span class="s3">\n                </span><span class="s1">r = rows.indexOf(y);</span><span class="s3">\n                </span><span class="s1">y = r &lt; 0 ? y : rows.offsetOf(r) + rows.sizeOf(r);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'left':</span><span class="s3">\n                </span><span class="s1">c = columns.indexOf(x - 1);</span><span class="s3">\n                </span><span class="s1">x = c &lt; 0 ? x : columns.offsetOf(c);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'right':</span><span class="s3">\n                </span><span class="s1">c = columns.indexOf(x);</span><span class="s3">\n                </span><span class="s1">x = c &lt; 0 ? x : columns.offsetOf(c) + columns.sizeOf(c);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.scrollTo(x, y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll to the specified offset position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param x - The desired X position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param y - The desired Y position.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollTo(x, y) {</span><span class="s3">\n        </span><span class="s1">// Floor and clamp the position to the allowable range.</span><span class="s3">\n        </span><span class="s1">x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));</span><span class="s3">\n        </span><span class="s1">y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));</span><span class="s3">\n        </span><span class="s1">// Update the scroll bar values with the desired position.</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.value = x;</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.value = y;</span><span class="s3">\n        </span><span class="s1">// Post a scroll request message to the viewport.</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, Private$1.ScrollRequest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the row count for a particular region in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The row region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The row count for the specified region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rowCount(region) {</span><span class="s3">\n        </span><span class="s1">let count;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">count = this._rowSections.count;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">count = this._columnHeaderSections.count;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return count;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the column count for a particular region in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The column region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The column count for the specified region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">columnCount(region) {</span><span class="s3">\n        </span><span class="s1">let count;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">count = this._columnSections.count;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">count = this._rowHeaderSections.count;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return count;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the row at a virtual offset in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param offset - The virtual offset of the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The index of the row, or `-1` if the offset is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method accounts for a stretched last row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rowAt(region, offset) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the offset is negative.</span><span class="s3">\n        </span><span class="s1">if (offset &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early for the column header region.</span><span class="s3">\n        </span><span class="s1">if (region === 'column-header') {</span><span class="s3">\n            </span><span class="s1">return this._columnHeaderSections.indexOf(offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the index.</span><span class="s3">\n        </span><span class="s1">let index = this._rowSections.indexOf(offset);</span><span class="s3">\n        </span><span class="s1">// Return early if the section is found.</span><span class="s3">\n        </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">return index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the last row is not stretched.</span><span class="s3">\n        </span><span class="s1">if (!this._stretchLastRow) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Bail early if no row stretching is required.</span><span class="s3">\n        </span><span class="s1">if (ph &lt;= bh) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the offset is out of bounds.</span><span class="s3">\n        </span><span class="s1">if (offset &gt;= ph) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, return the last row.</span><span class="s3">\n        </span><span class="s1">return this._rowSections.count - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the column at a virtual offset in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param offset - The virtual offset of the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The index of the column, or `-1` if the offset is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method accounts for a stretched last column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">columnAt(region, offset) {</span><span class="s3">\n        </span><span class="s1">if (offset &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early for the row header region.</span><span class="s3">\n        </span><span class="s1">if (region === 'row-header') {</span><span class="s3">\n            </span><span class="s1">return this._rowHeaderSections.indexOf(offset);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the index.</span><span class="s3">\n        </span><span class="s1">let index = this._columnSections.indexOf(offset);</span><span class="s3">\n        </span><span class="s1">// Return early if the section is found.</span><span class="s3">\n        </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">return index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the last column is not stretched.</span><span class="s3">\n        </span><span class="s1">if (!this._stretchLastColumn) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Bail early if no column stretching is required.</span><span class="s3">\n        </span><span class="s1">if (pw &lt;= bw) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the offset is out of bounds.</span><span class="s3">\n        </span><span class="s1">if (offset &gt;= pw) {</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, return the last column.</span><span class="s3">\n        </span><span class="s1">return this._columnSections.count - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the offset of a row in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The offset of the row, or `-1` if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* A stretched last row has no effect on the return value.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rowOffset(region, index) {</span><span class="s3">\n        </span><span class="s1">let offset;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">offset = this._rowSections.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">offset = this._columnHeaderSections.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the offset of a column in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The offset of the column, or `-1` if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* A stretched last column has no effect on the return value.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">columnOffset(region, index) {</span><span class="s3">\n        </span><span class="s1">let offset;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">offset = this._columnSections.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">offset = this._rowHeaderSections.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the size of a row in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The size of the row, or `-1` if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method accounts for a stretched last row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rowSize(region, index) {</span><span class="s3">\n        </span><span class="s1">// Return early for the column header region.</span><span class="s3">\n        </span><span class="s1">if (region === 'column-header') {</span><span class="s3">\n            </span><span class="s1">return this._columnHeaderSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the row size.</span><span class="s3">\n        </span><span class="s1">let size = this._rowSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of bounds.</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early if the last row is not stretched.</span><span class="s3">\n        </span><span class="s1">if (!this._stretchLastRow) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early if its not the last row.</span><span class="s3">\n        </span><span class="s1">if (index &lt; this._rowSections.count - 1) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Return early if no stretching is needed.</span><span class="s3">\n        </span><span class="s1">if (ph &lt;= bh) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the adjusted size.</span><span class="s3">\n        </span><span class="s1">return size + (ph - bh);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the size of a column in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The size of the column, or `-1` if the index is out of range.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method accounts for a stretched last column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">columnSize(region, index) {</span><span class="s3">\n        </span><span class="s1">// Return early for the row header region.</span><span class="s3">\n        </span><span class="s1">if (region === 'row-header') {</span><span class="s3">\n            </span><span class="s1">return this._rowHeaderSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the column size.</span><span class="s3">\n        </span><span class="s1">let size = this._columnSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of bounds.</span><span class="s3">\n        </span><span class="s1">if (size &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early if the last column is not stretched.</span><span class="s3">\n        </span><span class="s1">if (!this._stretchLastColumn) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return early if its not the last column.</span><span class="s3">\n        </span><span class="s1">if (index &lt; this._columnSections.count - 1) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Return early if no stretching is needed.</span><span class="s3">\n        </span><span class="s1">if (pw &lt;= bw) {</span><span class="s3">\n            </span><span class="s1">return size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the adjusted size.</span><span class="s3">\n        </span><span class="s1">return size + (pw - bw);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a row in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the row of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param size - The desired size of the row.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resizeRow(region, index, size) {</span><span class="s3">\n        </span><span class="s1">let msg = new Private$1.RowResizeRequest(region, index, size);</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a column in the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The region which holds the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index - The index of the column of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param size - The desired size of the column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resizeColumn(region, index, size) {</span><span class="s3">\n        </span><span class="s1">let msg = new Private$1.ColumnResizeRequest(region, index, size);</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reset modified rows to their default size.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The row region of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resetRows(region) {</span><span class="s3">\n        </span><span class="s1">switch (region) {</span><span class="s3">\n            </span><span class="s1">case 'all':</span><span class="s3">\n                </span><span class="s1">this._rowSections.reset();</span><span class="s3">\n                </span><span class="s1">this._columnHeaderSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'body':</span><span class="s3">\n                </span><span class="s1">this._rowSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column-header':</span><span class="s3">\n                </span><span class="s1">this._columnHeaderSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Reset modified columns to their default size.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The column region of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resetColumns(region) {</span><span class="s3">\n        </span><span class="s1">switch (region) {</span><span class="s3">\n            </span><span class="s1">case 'all':</span><span class="s3">\n                </span><span class="s1">this._columnSections.reset();</span><span class="s3">\n                </span><span class="s1">this._rowHeaderSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'body':</span><span class="s3">\n                </span><span class="s1">this._columnSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row-header':</span><span class="s3">\n                </span><span class="s1">this._rowHeaderSections.reset();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Auto sizes column-header widths based on their text content.</span><span class="s3">\n     </span><span class="s1">* @param area which area to resize: 'body', 'row-header' or 'all'.</span><span class="s3">\n     </span><span class="s1">* @param padding padding added to resized columns (pixels).</span><span class="s3">\n     </span><span class="s1">* @param numCols specify cap on the number of column resizes (optional).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">fitColumnNames(area = 'all', padding = 15, numCols) {</span><span class="s3">\n        </span><span class="s1">// Attempt resizing only if a data model is present.</span><span class="s3">\n        </span><span class="s1">if (this.dataModel) {</span><span class="s3">\n            </span><span class="s1">// Tracking remaining columns to be resized if numCols arg passed.</span><span class="s3">\n            </span><span class="s1">let colsRemaining = numCols === undefined || numCols &lt; 0 ? undefined : numCols;</span><span class="s3">\n            </span><span class="s1">if (area === 'row-header' || area === 'all') {</span><span class="s3">\n                </span><span class="s1">// Respecting any column resize cap, if one has been passed.</span><span class="s3">\n                </span><span class="s1">if (colsRemaining !== undefined) {</span><span class="s3">\n                    </span><span class="s1">const rowColumnCount = this.dataModel.columnCount('row-header');</span><span class="s3">\n                    </span><span class="s1">/*</span><span class="s3">\n                      </span><span class="s1">If we have more row-header columns than columns available</span><span class="s3">\n                      </span><span class="s1">for resize, resize only remaining columns as per allowance</span><span class="s3">\n                      </span><span class="s1">and set remaining resize allowance number to 0.</span><span class="s3">\n                    </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">if (colsRemaining - rowColumnCount &lt; 0) {</span><span class="s3">\n                        </span><span class="s1">this._fitRowColumnHeaders(this.dataModel, padding, colsRemaining);</span><span class="s3">\n                        </span><span class="s1">colsRemaining = 0;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">/*</span><span class="s3">\n                          </span><span class="s1">Otherwise the entire row-header column count can be resized.</span><span class="s3">\n                          </span><span class="s1">Resize all row-header columns and subtract from remaining</span><span class="s3">\n                          </span><span class="s1">column resize allowance.</span><span class="s3">\n                        </span><span class="s1">*/</span><span class="s3">\n                        </span><span class="s1">this._fitRowColumnHeaders(this.dataModel, padding, rowColumnCount);</span><span class="s3">\n                        </span><span class="s1">colsRemaining = colsRemaining - rowColumnCount;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// No column resize cap passed - resizing all columns.</span><span class="s3">\n                    </span><span class="s1">this._fitRowColumnHeaders(this.dataModel, padding);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (area === 'body' || area === 'all') {</span><span class="s3">\n                </span><span class="s1">// Respecting any column resize cap, if one has been passed.</span><span class="s3">\n                </span><span class="s1">if (colsRemaining !== undefined) {</span><span class="s3">\n                    </span><span class="s1">const bodyColumnCount = this.dataModel.columnCount('body');</span><span class="s3">\n                    </span><span class="s1">/*</span><span class="s3">\n                      </span><span class="s1">If we have more body columns than columns available</span><span class="s3">\n                      </span><span class="s1">for resize, resize only remaining columns as per allowance</span><span class="s3">\n                      </span><span class="s1">and set remaining resize allowance number to 0.</span><span class="s3">\n                    </span><span class="s1">*/</span><span class="s3">\n                    </span><span class="s1">if (colsRemaining - bodyColumnCount &lt; 0) {</span><span class="s3">\n                        </span><span class="s1">this._fitBodyColumnHeaders(this.dataModel, padding, colsRemaining);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">/*</span><span class="s3">\n                          </span><span class="s1">Otherwise the entire body column count can be resized.</span><span class="s3">\n                          </span><span class="s1">Resize based on the smallest number between remaining</span><span class="s3">\n                          </span><span class="s1">resize allowance and body column count.</span><span class="s3">\n                        </span><span class="s1">*/</span><span class="s3">\n                        </span><span class="s1">this._fitBodyColumnHeaders(this.dataModel, padding, Math.min(colsRemaining, bodyColumnCount));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// No column resize cap passed - resizing all columns.</span><span class="s3">\n                    </span><span class="s1">this._fitBodyColumnHeaders(this.dataModel, padding);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Map a client position to local viewport coordinates.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientX - The client X position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientY - The client Y position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The local viewport coordinates for the position.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mapToLocal(clientX, clientY) {</span><span class="s3">\n        </span><span class="s1">// Fetch the viewport rect.</span><span class="s3">\n        </span><span class="s1">let rect = this._viewport.node.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">// Extract the rect coordinates.</span><span class="s3">\n        </span><span class="s1">let { left, top } = rect;</span><span class="s3">\n        </span><span class="s1">// Round the rect coordinates for sub-pixel positioning.</span><span class="s3">\n        </span><span class="s1">left = Math.floor(left);</span><span class="s3">\n        </span><span class="s1">top = Math.floor(top);</span><span class="s3">\n        </span><span class="s1">// Convert to local coordinates.</span><span class="s3">\n        </span><span class="s1">let lx = clientX - left;</span><span class="s3">\n        </span><span class="s1">let ly = clientY - top;</span><span class="s3">\n        </span><span class="s1">// Return the local coordinates.</span><span class="s3">\n        </span><span class="s1">return { lx, ly };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Map a client position to virtual grid coordinates.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientX - The client X position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientY - The client Y position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The virtual grid coordinates for the position.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mapToVirtual(clientX, clientY) {</span><span class="s3">\n        </span><span class="s1">// Convert to local coordiates.</span><span class="s3">\n        </span><span class="s1">let { lx, ly } = this.mapToLocal(clientX, clientY);</span><span class="s3">\n        </span><span class="s1">// Convert to virtual coordinates.</span><span class="s3">\n        </span><span class="s1">let vx = lx + this.scrollX - this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let vy = ly + this.scrollY - this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Return the local coordinates.</span><span class="s3">\n        </span><span class="s1">return { vx, vy };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Hit test the viewport for the given client position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientX - The client X position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param clientY - The client Y position of the mouse.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The hit test result, or `null` if the client</span><span class="s3">\n     </span><span class="s1">*   position is out of bounds.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method accounts for a stretched last row and/or column.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hitTest(clientX, clientY) {</span><span class="s3">\n        </span><span class="s1">// Convert the mouse position into local coordinates.</span><span class="s3">\n        </span><span class="s1">let { lx, ly } = this.mapToLocal(clientX, clientY);</span><span class="s3">\n        </span><span class="s1">// Fetch the header and body dimensions.</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Adjust the body width for a stretched last column.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw) {</span><span class="s3">\n            </span><span class="s1">bw = pw;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the body height for a stretched last row.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh) {</span><span class="s3">\n            </span><span class="s1">bh = ph;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check for a corner header hit.</span><span class="s3">\n        </span><span class="s1">if (lx &gt;= 0 &amp;&amp; lx &lt; hw &amp;&amp; ly &gt;= 0 &amp;&amp; ly &lt; hh) {</span><span class="s3">\n            </span><span class="s1">// Convert to unscrolled virtual coordinates.</span><span class="s3">\n            </span><span class="s1">let vx = lx;</span><span class="s3">\n            </span><span class="s1">let vy = ly;</span><span class="s3">\n            </span><span class="s1">// Fetch the row and column index.</span><span class="s3">\n            </span><span class="s1">let row = this.rowAt('column-header', vy);</span><span class="s3">\n            </span><span class="s1">let column = this.columnAt('row-header', vx);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell offset position.</span><span class="s3">\n            </span><span class="s1">let ox = this.columnOffset('row-header', column);</span><span class="s3">\n            </span><span class="s1">let oy = this.rowOffset('column-header', row);</span><span class="s3">\n            </span><span class="s1">// Fetch cell width and height.</span><span class="s3">\n            </span><span class="s1">let width = this.columnSize('row-header', column);</span><span class="s3">\n            </span><span class="s1">let height = this.rowSize('column-header', row);</span><span class="s3">\n            </span><span class="s1">// Compute the leading and trailing positions.</span><span class="s3">\n            </span><span class="s1">let x = vx - ox;</span><span class="s3">\n            </span><span class="s1">let y = vy - oy;</span><span class="s3">\n            </span><span class="s1">// Return the hit test result.</span><span class="s3">\n            </span><span class="s1">return { region: 'corner-header', row, column, x, y, width, height };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check for a column header hit.</span><span class="s3">\n        </span><span class="s1">if (ly &gt;= 0 &amp;&amp; ly &lt; hh &amp;&amp; lx &gt;= 0 &amp;&amp; lx &lt; hw + bw) {</span><span class="s3">\n            </span><span class="s1">// Convert to unscrolled virtual coordinates.</span><span class="s3">\n            </span><span class="s1">let vx = lx + this._scrollX - hw;</span><span class="s3">\n            </span><span class="s1">let vy = ly;</span><span class="s3">\n            </span><span class="s1">// Fetch the row and column index.</span><span class="s3">\n            </span><span class="s1">let row = this.rowAt('column-header', vy);</span><span class="s3">\n            </span><span class="s1">let column = this.columnAt('body', vx);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell offset position.</span><span class="s3">\n            </span><span class="s1">let ox = this.columnOffset('body', column);</span><span class="s3">\n            </span><span class="s1">let oy = this.rowOffset('column-header', row);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell width and height.</span><span class="s3">\n            </span><span class="s1">let width = this.columnSize('body', column);</span><span class="s3">\n            </span><span class="s1">let height = this.rowSize('column-header', row);</span><span class="s3">\n            </span><span class="s1">// Compute the leading and trailing positions.</span><span class="s3">\n            </span><span class="s1">let x = vx - ox;</span><span class="s3">\n            </span><span class="s1">let y = vy - oy;</span><span class="s3">\n            </span><span class="s1">// Return the hit test result.</span><span class="s3">\n            </span><span class="s1">return { region: 'column-header', row, column, x, y, width, height };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check for a row header hit.</span><span class="s3">\n        </span><span class="s1">if (lx &gt;= 0 &amp;&amp; lx &lt; hw &amp;&amp; ly &gt;= 0 &amp;&amp; ly &lt; hh + bh) {</span><span class="s3">\n            </span><span class="s1">// Convert to unscrolled virtual coordinates.</span><span class="s3">\n            </span><span class="s1">let vx = lx;</span><span class="s3">\n            </span><span class="s1">let vy = ly + this._scrollY - hh;</span><span class="s3">\n            </span><span class="s1">// Fetch the row and column index.</span><span class="s3">\n            </span><span class="s1">let row = this.rowAt('body', vy);</span><span class="s3">\n            </span><span class="s1">let column = this.columnAt('row-header', vx);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell offset position.</span><span class="s3">\n            </span><span class="s1">let ox = this.columnOffset('row-header', column);</span><span class="s3">\n            </span><span class="s1">let oy = this.rowOffset('body', row);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell width and height.</span><span class="s3">\n            </span><span class="s1">let width = this.columnSize('row-header', column);</span><span class="s3">\n            </span><span class="s1">let height = this.rowSize('body', row);</span><span class="s3">\n            </span><span class="s1">// Compute the leading and trailing positions.</span><span class="s3">\n            </span><span class="s1">let x = vx - ox;</span><span class="s3">\n            </span><span class="s1">let y = vy - oy;</span><span class="s3">\n            </span><span class="s1">// Return the hit test result.</span><span class="s3">\n            </span><span class="s1">return { region: 'row-header', row, column, x, y, width, height };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Check for a body hit.</span><span class="s3">\n        </span><span class="s1">if (lx &gt;= hw &amp;&amp; lx &lt; hw + bw &amp;&amp; ly &gt;= hh &amp;&amp; ly &lt; hh + bh) {</span><span class="s3">\n            </span><span class="s1">// Convert to unscrolled virtual coordinates.</span><span class="s3">\n            </span><span class="s1">let vx = lx + this._scrollX - hw;</span><span class="s3">\n            </span><span class="s1">let vy = ly + this._scrollY - hh;</span><span class="s3">\n            </span><span class="s1">// Fetch the row and column index.</span><span class="s3">\n            </span><span class="s1">let row = this.rowAt('body', vy);</span><span class="s3">\n            </span><span class="s1">let column = this.columnAt('body', vx);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell offset position.</span><span class="s3">\n            </span><span class="s1">let ox = this.columnOffset('body', column);</span><span class="s3">\n            </span><span class="s1">let oy = this.rowOffset('body', row);</span><span class="s3">\n            </span><span class="s1">// Fetch the cell width and height.</span><span class="s3">\n            </span><span class="s1">let width = this.columnSize('body', column);</span><span class="s3">\n            </span><span class="s1">let height = this.rowSize('body', row);</span><span class="s3">\n            </span><span class="s1">// Compute the part coordinates.</span><span class="s3">\n            </span><span class="s1">let x = vx - ox;</span><span class="s3">\n            </span><span class="s1">let y = vy - oy;</span><span class="s3">\n            </span><span class="s1">// Return the result.</span><span class="s3">\n            </span><span class="s1">return { region: 'body', row, column, x, y, width, height };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise, it's a void space hit.</span><span class="s3">\n        </span><span class="s1">let row = -1;</span><span class="s3">\n        </span><span class="s1">let column = -1;</span><span class="s3">\n        </span><span class="s1">let x = -1;</span><span class="s3">\n        </span><span class="s1">let y = -1;</span><span class="s3">\n        </span><span class="s1">let width = -1;</span><span class="s3">\n        </span><span class="s1">let height = -1;</span><span class="s3">\n        </span><span class="s1">// Return the hit test result.</span><span class="s3">\n        </span><span class="s1">return { region: 'void', row, column, x, y, width, height };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Copy the current selection to the system clipboard.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* The grid must have a data model and a selection model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The behavior can be configured via `DataGrid.copyConfig`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">copyToClipboard() {</span><span class="s3">\n        </span><span class="s1">// Fetch the data model.</span><span class="s3">\n        </span><span class="s1">let dataModel = this._dataModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no data model.</span><span class="s3">\n        </span><span class="s1">if (!dataModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let selectionModel = this._selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no selection model.</span><span class="s3">\n        </span><span class="s1">if (!selectionModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Coerce the selections to an array.</span><span class="s3">\n        </span><span class="s1">let selections = Array.from(selectionModel.selections());</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections.</span><span class="s3">\n        </span><span class="s1">if (selections.length === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Alert that multiple selections cannot be copied.</span><span class="s3">\n        </span><span class="s1">if (selections.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">alert('Cannot copy multiple grid selections.');</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the model counts.</span><span class="s3">\n        </span><span class="s1">let br = dataModel.rowCount('body');</span><span class="s3">\n        </span><span class="s1">let bc = dataModel.columnCount('body');</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to copy.</span><span class="s3">\n        </span><span class="s1">if (br === 0 || bc === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Unpack the selection.</span><span class="s3">\n        </span><span class="s1">let { r1, c1, r2, c2 } = selections[0];</span><span class="s3">\n        </span><span class="s1">// Clamp the selection to the model bounds.</span><span class="s3">\n        </span><span class="s1">r1 = Math.max(0, Math.min(r1, br - 1));</span><span class="s3">\n        </span><span class="s1">c1 = Math.max(0, Math.min(c1, bc - 1));</span><span class="s3">\n        </span><span class="s1">r2 = Math.max(0, Math.min(r2, br - 1));</span><span class="s3">\n        </span><span class="s1">c2 = Math.max(0, Math.min(c2, bc - 1));</span><span class="s3">\n        </span><span class="s1">// Ensure the limits are well-orderd.</span><span class="s3">\n        </span><span class="s1">if (r2 &lt; r1)</span><span class="s3">\n            </span><span class="s1">[r1, r2] = [r2, r1];</span><span class="s3">\n        </span><span class="s1">if (c2 &lt; c1)</span><span class="s3">\n            </span><span class="s1">[c1, c2] = [c2, c1];</span><span class="s3">\n        </span><span class="s1">// Fetch the header counts.</span><span class="s3">\n        </span><span class="s1">let rhc = dataModel.columnCount('row-header');</span><span class="s3">\n        </span><span class="s1">let chr = dataModel.rowCount('column-header');</span><span class="s3">\n        </span><span class="s1">// Unpack the copy config.</span><span class="s3">\n        </span><span class="s1">let separator = this._copyConfig.separator;</span><span class="s3">\n        </span><span class="s1">let format = this._copyConfig.format;</span><span class="s3">\n        </span><span class="s1">let headers = this._copyConfig.headers;</span><span class="s3">\n        </span><span class="s1">let warningThreshold = this._copyConfig.warningThreshold;</span><span class="s3">\n        </span><span class="s1">// Compute the number of cells to be copied.</span><span class="s3">\n        </span><span class="s1">let rowCount = r2 - r1 + 1;</span><span class="s3">\n        </span><span class="s1">let colCount = c2 - c1 + 1;</span><span class="s3">\n        </span><span class="s1">switch (headers) {</span><span class="s3">\n            </span><span class="s1">case 'none':</span><span class="s3">\n                </span><span class="s1">rhc = 0;</span><span class="s3">\n                </span><span class="s1">chr = 0;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row':</span><span class="s3">\n                </span><span class="s1">chr = 0;</span><span class="s3">\n                </span><span class="s1">colCount += rhc;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column':</span><span class="s3">\n                </span><span class="s1">rhc = 0;</span><span class="s3">\n                </span><span class="s1">rowCount += chr;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'all':</span><span class="s3">\n                </span><span class="s1">rowCount += chr;</span><span class="s3">\n                </span><span class="s1">colCount += rhc;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the total cell count.</span><span class="s3">\n        </span><span class="s1">let cellCount = rowCount * colCount;</span><span class="s3">\n        </span><span class="s1">// Allow the user to cancel a large copy request.</span><span class="s3">\n        </span><span class="s1">if (cellCount &gt; warningThreshold) {</span><span class="s3">\n            </span><span class="s1">let msg = `Copying ${cellCount} cells may take a while. Continue?`;</span><span class="s3">\n            </span><span class="s1">if (!window.confirm(msg)) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set up the format args.</span><span class="s3">\n        </span><span class="s1">let args = {</span><span class="s3">\n            </span><span class="s1">region: 'body',</span><span class="s3">\n            </span><span class="s1">row: 0,</span><span class="s3">\n            </span><span class="s1">column: 0,</span><span class="s3">\n            </span><span class="s1">value: null,</span><span class="s3">\n            </span><span class="s1">metadata: {}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Allocate the array of rows.</span><span class="s3">\n        </span><span class="s1">let rows = new Array(rowCount);</span><span class="s3">\n        </span><span class="s1">// Iterate over the rows.</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; rowCount; ++j) {</span><span class="s3">\n            </span><span class="s1">// Allocate the array of cells.</span><span class="s3">\n            </span><span class="s1">let cells = new Array(colCount);</span><span class="s3">\n            </span><span class="s1">// Iterate over the columns.</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; colCount; ++i) {</span><span class="s3">\n                </span><span class="s1">// Set up the format variables.</span><span class="s3">\n                </span><span class="s1">let region;</span><span class="s3">\n                </span><span class="s1">let row;</span><span class="s3">\n                </span><span class="s1">let column;</span><span class="s3">\n                </span><span class="s1">// Populate the format variables.</span><span class="s3">\n                </span><span class="s1">if (j &lt; chr &amp;&amp; i &lt; rhc) {</span><span class="s3">\n                    </span><span class="s1">region = 'corner-header';</span><span class="s3">\n                    </span><span class="s1">row = j;</span><span class="s3">\n                    </span><span class="s1">column = i;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (j &lt; chr) {</span><span class="s3">\n                    </span><span class="s1">region = 'column-header';</span><span class="s3">\n                    </span><span class="s1">row = j;</span><span class="s3">\n                    </span><span class="s1">column = i - rhc + c1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (i &lt; rhc) {</span><span class="s3">\n                    </span><span class="s1">region = 'row-header';</span><span class="s3">\n                    </span><span class="s1">row = j - chr + r1;</span><span class="s3">\n                    </span><span class="s1">column = i;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">region = 'body';</span><span class="s3">\n                    </span><span class="s1">row = j - chr + r1;</span><span class="s3">\n                    </span><span class="s1">column = i - rhc + c1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Populate the format args.</span><span class="s3">\n                </span><span class="s1">args.region = region;</span><span class="s3">\n                </span><span class="s1">args.row = row;</span><span class="s3">\n                </span><span class="s1">args.column = column;</span><span class="s3">\n                </span><span class="s1">args.value = dataModel.data(region, row, column);</span><span class="s3">\n                </span><span class="s1">args.metadata = dataModel.metadata(region, row, column);</span><span class="s3">\n                </span><span class="s1">// Format the cell.</span><span class="s3">\n                </span><span class="s1">cells[i] = format(args);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Save the row of cells.</span><span class="s3">\n            </span><span class="s1">rows[j] = cells;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Convert the cells into lines.</span><span class="s3">\n        </span><span class="s1">let lines = rows.map(cells =&gt; cells.join(separator));</span><span class="s3">\n        </span><span class="s1">// Convert the lines into text.</span><span class="s3">\n        </span><span class="s1">let text = lines.join('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n        </span><span class="s1">// Copy the text to the clipboard.</span><span class="s3">\n        </span><span class="s1">ClipboardExt.copyText(text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process a message sent to the widget.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param msg - The message sent to the widget.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">processMessage(msg) {</span><span class="s3">\n        </span><span class="s1">// Ignore child show/hide messages. The data grid controls the</span><span class="s3">\n        </span><span class="s1">// visibility of its children, and will manually dispatch the</span><span class="s3">\n        </span><span class="s1">// fit-request messages as a result of visibility change.</span><span class="s3">\n        </span><span class="s1">if (msg.type === 'child-shown' || msg.type === 'child-hidden') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Recompute the scroll bar minimums before the layout refits.</span><span class="s3">\n        </span><span class="s1">if (msg.type === 'fit-request') {</span><span class="s3">\n            </span><span class="s1">let vsbLimits = ElementExt.sizeLimits(this._vScrollBar.node);</span><span class="s3">\n            </span><span class="s1">let hsbLimits = ElementExt.sizeLimits(this._hScrollBar.node);</span><span class="s3">\n            </span><span class="s1">this._vScrollBarMinWidth = vsbLimits.minWidth;</span><span class="s3">\n            </span><span class="s1">this._hScrollBarMinHeight = hsbLimits.minHeight;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Process all other messages as normal.</span><span class="s3">\n        </span><span class="s1">super.processMessage(msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Intercept a message sent to a message handler.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param handler - The target handler of the message.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param msg - The message to be sent to the handler.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns `true` if the message should continue to be processed</span><span class="s3">\n     </span><span class="s1">*   as normal, or `false` if processing should cease immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">messageHook(handler, msg) {</span><span class="s3">\n        </span><span class="s1">// Process viewport messages.</span><span class="s3">\n        </span><span class="s1">if (handler === this._viewport) {</span><span class="s3">\n            </span><span class="s1">this._processViewportMessage(msg);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Process horizontal scroll bar messages.</span><span class="s3">\n        </span><span class="s1">if (handler === this._hScrollBar &amp;&amp; msg.type === 'activate-request') {</span><span class="s3">\n            </span><span class="s1">this.activate();</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Process vertical scroll bar messages.</span><span class="s3">\n        </span><span class="s1">if (handler === this._vScrollBar &amp;&amp; msg.type === 'activate-request') {</span><span class="s3">\n            </span><span class="s1">this.activate();</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Ignore all other messages.</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the DOM events for the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param event - The DOM event sent to the data grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This method implements the DOM `EventListener` interface and is</span><span class="s3">\n     </span><span class="s1">* called in response to events on the data grid's DOM node. It</span><span class="s3">\n     </span><span class="s1">* should not be called directly by user code.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">handleEvent(event) {</span><span class="s3">\n        </span><span class="s1">switch (event.type) {</span><span class="s3">\n            </span><span class="s1">case 'keydown':</span><span class="s3">\n                </span><span class="s1">this._evtKeyDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'mousedown':</span><span class="s3">\n                </span><span class="s1">this._evtMouseDown(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'mousemove':</span><span class="s3">\n                </span><span class="s1">this._evtMouseMove(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'mouseup':</span><span class="s3">\n                </span><span class="s1">this._evtMouseUp(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'dblclick':</span><span class="s3">\n                </span><span class="s1">this._evtMouseDoubleClick(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'mouseleave':</span><span class="s3">\n                </span><span class="s1">this._evtMouseLeave(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'contextmenu':</span><span class="s3">\n                </span><span class="s1">this._evtContextMenu(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'wheel':</span><span class="s3">\n                </span><span class="s1">this._evtWheel(event);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'resize':</span><span class="s3">\n                </span><span class="s1">this._refreshDPI();</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the current viewport.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The current viewport as row/column coordinates.</span><span class="s3">\n     </span><span class="s1">* Returns undefined if the grid is not visible.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get currentViewport() {</span><span class="s3">\n        </span><span class="s1">let width = this.viewport.node.offsetWidth;</span><span class="s3">\n        </span><span class="s1">let height = this.viewport.node.offsetHeight;</span><span class="s3">\n        </span><span class="s1">width = Math.round(width);</span><span class="s3">\n        </span><span class="s1">height = Math.round(height);</span><span class="s3">\n        </span><span class="s1">if (width &lt;= 0 || height &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const contentW = this._columnSections.length - this.scrollX;</span><span class="s3">\n        </span><span class="s1">const contentH = this._rowSections.length - this.scrollY;</span><span class="s3">\n        </span><span class="s1">const contentX = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">const contentY = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">const x1 = contentX;</span><span class="s3">\n        </span><span class="s1">const y1 = contentY;</span><span class="s3">\n        </span><span class="s1">const x2 = Math.min(width - 1, contentX + contentW - 1);</span><span class="s3">\n        </span><span class="s1">const y2 = Math.min(height - 1, contentY + contentH - 1);</span><span class="s3">\n        </span><span class="s1">const firstRow = this._rowSections.indexOf(y1 - contentY + this.scrollY);</span><span class="s3">\n        </span><span class="s1">const firstColumn = this._columnSections.indexOf(x1 - contentX + this.scrollX);</span><span class="s3">\n        </span><span class="s1">const lastRow = this._rowSections.indexOf(y2 - contentY + this.scrollY);</span><span class="s3">\n        </span><span class="s1">const lastColumn = this._columnSections.indexOf(x2 - contentX + this.scrollX);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">firstRow,</span><span class="s3">\n            </span><span class="s1">firstColumn,</span><span class="s3">\n            </span><span class="s1">lastRow,</span><span class="s3">\n            </span><span class="s1">lastColumn</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message handler invoked on an `'activate-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onActivateRequest(msg) {</span><span class="s3">\n        </span><span class="s1">this.viewport.node.focus({ preventScroll: true });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message handler invoked on a `'before-attach'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onBeforeAttach(msg) {</span><span class="s3">\n        </span><span class="s1">window.addEventListener('resize', this);</span><span class="s3">\n        </span><span class="s1">this.node.addEventListener('wheel', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('mousedown', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('mousemove', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('dblclick', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('mouseleave', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.addEventListener('contextmenu', this);</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message handler invoked on an `'after-detach'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onAfterDetach(msg) {</span><span class="s3">\n        </span><span class="s1">window.removeEventListener('resize', this);</span><span class="s3">\n        </span><span class="s1">this.node.removeEventListener('wheel', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('keydown', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('mousedown', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('mousemove', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('mouseleave', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('dblclick', this);</span><span class="s3">\n        </span><span class="s1">this._viewport.node.removeEventListener('contextmenu', this);</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message handler invoked on a `'before-show'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onBeforeShow(msg) {</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message handler invoked on a `'resize'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">onResize(msg) {</span><span class="s3">\n        </span><span class="s1">if (this._editorController) {</span><span class="s3">\n            </span><span class="s1">this._editorController.cancel();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Schedule a repaint of all of the grid content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">repaintContent() {</span><span class="s3">\n        </span><span class="s1">let msg = new Private$1.PaintRequest('all', 0, 0, 0, 0);</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Schedule a repaint of specific grid content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">repaintRegion(region, r1, c1, r2, c2) {</span><span class="s3">\n        </span><span class="s1">let msg = new Private$1.PaintRequest(region, r1, c1, r2, c2);</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, msg);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Schedule a repaint of the overlay.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">repaintOverlay() {</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, Private$1.OverlayPaintRequest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getMaxWidthInColumn(index, columnRegion) {</span><span class="s3">\n        </span><span class="s1">const dataModel = this.dataModel;</span><span class="s3">\n        </span><span class="s1">if (!dataModel) {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const columnHeaderRegion = columnRegion == 'row-header' ? 'corner-header' : 'column-header';</span><span class="s3">\n        </span><span class="s1">return Math.max(this._getMaxWidthInArea(dataModel, index, columnHeaderRegion, 'column-header'), this._getMaxWidthInArea(dataModel, index, columnRegion, 'body'));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getMaxWidthInArea(dataModel, index, region, rowRegion) {</span><span class="s3">\n        </span><span class="s1">const numRows = dataModel.rowCount(rowRegion);</span><span class="s3">\n        </span><span class="s1">// Will only allocate up to 1_000_000 elements otherwise performance can tank.</span><span class="s3">\n        </span><span class="s1">const configs = Array.from({ length: Math.min(numRows, 1000000) }, (_val, idx) =&gt; DataGrid._getConfig(dataModel, idx, index, region));</span><span class="s3">\n        </span><span class="s1">// Heuristic: Sort by the length of the text to render and only fully calculate the text width</span><span class="s3">\n        </span><span class="s1">// for the top 100_000 rows by text length</span><span class="s3">\n        </span><span class="s1">if (numRows &gt; 100000) {</span><span class="s3">\n            </span><span class="s1">// Sort by descending length</span><span class="s3">\n            </span><span class="s1">configs.sort(x =&gt; -this._getTextToRender(x).length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let maxWidth = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; numRows &amp;&amp; i &lt; 100000; ++i) {</span><span class="s3">\n            </span><span class="s1">const textWidth = this._getCellTextWidth(configs[i]);</span><span class="s3">\n            </span><span class="s1">maxWidth = Math.max(maxWidth, textWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return maxWidth;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static _getConfig(dataModel, row, col, location) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: 0,</span><span class="s3">\n            </span><span class="s1">width: 0,</span><span class="s3">\n            </span><span class="s1">height: 0,</span><span class="s3">\n            </span><span class="s1">region: location,</span><span class="s3">\n            </span><span class="s1">row: row,</span><span class="s3">\n            </span><span class="s1">column: col,</span><span class="s3">\n            </span><span class="s1">value: DataGrid._getCellValue(dataModel, location, row, col),</span><span class="s3">\n            </span><span class="s1">metadata: DataGrid._getCellMetadata(dataModel, location, row, col)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getTextToRender(config) {</span><span class="s3">\n        </span><span class="s1">const renderer = this.cellRenderers.get(config);</span><span class="s3">\n        </span><span class="s1">return renderer.getText(config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_getCellTextWidth(config) {</span><span class="s3">\n        </span><span class="s1">// Get the renderer for the given cell.</span><span class="s3">\n        </span><span class="s1">const renderer = this.cellRenderers.get(config);</span><span class="s3">\n        </span><span class="s1">// Use the canvas context to measure the cell's text width</span><span class="s3">\n        </span><span class="s1">const gc = this.canvasGC;</span><span class="s3">\n        </span><span class="s1">gc.font = CellRenderer.resolveOption(renderer.font, config);</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = CellRenderer.resolveOption(renderer.textColor, config);</span><span class="s3">\n        </span><span class="s1">gc.textAlign = CellRenderer.resolveOption(renderer.horizontalAlignment, config);</span><span class="s3">\n        </span><span class="s1">gc.textBaseline = 'bottom';</span><span class="s3">\n        </span><span class="s1">const text = this._getTextToRender(config);</span><span class="s3">\n        </span><span class="s1">return gc.measureText(text).width + 2 * renderer.horizontalPadding;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Ensure the canvas is at least the specified size.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This method will retain the valid canvas content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_resizeCanvasIfNeeded(width, height) {</span><span class="s3">\n        </span><span class="s1">// Scale the size by the dpi ratio.</span><span class="s3">\n        </span><span class="s1">width = width * this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">height = height * this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">// Compute the maximum canvas size for the given width and height.</span><span class="s3">\n        </span><span class="s1">let maxW = (Math.ceil((width + 1) / 512) + 1) * 512;</span><span class="s3">\n        </span><span class="s1">let maxH = (Math.ceil((height + 1) / 512) + 1) * 512;</span><span class="s3">\n        </span><span class="s1">// Get the current size of the canvas.</span><span class="s3">\n        </span><span class="s1">let curW = this._canvas.width;</span><span class="s3">\n        </span><span class="s1">let curH = this._canvas.height;</span><span class="s3">\n        </span><span class="s1">// Bail early if the canvas size is within bounds.</span><span class="s3">\n        </span><span class="s1">if (curW &gt;= width &amp;&amp; curH &gt;= height &amp;&amp; curW &lt;= maxW &amp;&amp; curH &lt;= maxH) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the expanded canvas size.</span><span class="s3">\n        </span><span class="s1">let expW = maxW - 512;</span><span class="s3">\n        </span><span class="s1">let expH = maxH - 512;</span><span class="s3">\n        </span><span class="s1">// Set the transforms to the identity matrix.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n        </span><span class="s1">this._bufferGC.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n        </span><span class="s1">this._overlayGC.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n        </span><span class="s1">// Resize the buffer if needed.</span><span class="s3">\n        </span><span class="s1">if (curW &lt; width) {</span><span class="s3">\n            </span><span class="s1">this._buffer.width = expW;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curW &gt; maxW) {</span><span class="s3">\n            </span><span class="s1">this._buffer.width = maxW;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the buffer height if needed.</span><span class="s3">\n        </span><span class="s1">if (curH &lt; height) {</span><span class="s3">\n            </span><span class="s1">this._buffer.height = expH;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curH &gt; maxH) {</span><span class="s3">\n            </span><span class="s1">this._buffer.height = maxH;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Test whether there is content to blit.</span><span class="s3">\n        </span><span class="s1">let needBlit = curW &gt; 0 &amp;&amp; curH &gt; 0 &amp;&amp; width &gt; 0 &amp;&amp; height &gt; 0;</span><span class="s3">\n        </span><span class="s1">// Copy the valid canvas content into the buffer if needed.</span><span class="s3">\n        </span><span class="s1">if (needBlit) {</span><span class="s3">\n            </span><span class="s1">this._bufferGC.drawImage(this._canvas, 0, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the canvas width if needed.</span><span class="s3">\n        </span><span class="s1">if (curW &lt; width) {</span><span class="s3">\n            </span><span class="s1">this._canvas.width = expW;</span><span class="s3">\n            </span><span class="s1">this._canvas.style.width = `${expW / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curW &gt; maxW) {</span><span class="s3">\n            </span><span class="s1">this._canvas.width = maxW;</span><span class="s3">\n            </span><span class="s1">this._canvas.style.width = `${maxW / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the canvas height if needed.</span><span class="s3">\n        </span><span class="s1">if (curH &lt; height) {</span><span class="s3">\n            </span><span class="s1">this._canvas.height = expH;</span><span class="s3">\n            </span><span class="s1">this._canvas.style.height = `${expH / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curH &gt; maxH) {</span><span class="s3">\n            </span><span class="s1">this._canvas.height = maxH;</span><span class="s3">\n            </span><span class="s1">this._canvas.style.height = `${maxH / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Copy the valid canvas content from the buffer if needed.</span><span class="s3">\n        </span><span class="s1">if (needBlit) {</span><span class="s3">\n            </span><span class="s1">this._canvasGC.drawImage(this._buffer, 0, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Copy the valid overlay content into the buffer if needed.</span><span class="s3">\n        </span><span class="s1">if (needBlit) {</span><span class="s3">\n            </span><span class="s1">this._bufferGC.drawImage(this._overlay, 0, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the overlay width if needed.</span><span class="s3">\n        </span><span class="s1">if (curW &lt; width) {</span><span class="s3">\n            </span><span class="s1">this._overlay.width = expW;</span><span class="s3">\n            </span><span class="s1">this._overlay.style.width = `${expW / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curW &gt; maxW) {</span><span class="s3">\n            </span><span class="s1">this._overlay.width = maxW;</span><span class="s3">\n            </span><span class="s1">this._overlay.style.width = `${maxW / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the overlay height if needed.</span><span class="s3">\n        </span><span class="s1">if (curH &lt; height) {</span><span class="s3">\n            </span><span class="s1">this._overlay.height = expH;</span><span class="s3">\n            </span><span class="s1">this._overlay.style.height = `${expH / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (curH &gt; maxH) {</span><span class="s3">\n            </span><span class="s1">this._overlay.height = maxH;</span><span class="s3">\n            </span><span class="s1">this._overlay.style.height = `${maxH / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Copy the valid overlay content from the buffer if needed.</span><span class="s3">\n        </span><span class="s1">if (needBlit) {</span><span class="s3">\n            </span><span class="s1">this._overlayGC.drawImage(this._buffer, 0, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Sync the scroll bars and scroll state with the viewport.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* If the visibility of either scroll bar changes, a synchronous</span><span class="s3">\n     </span><span class="s1">* fit-request will be dispatched to the data grid to immediately</span><span class="s3">\n     </span><span class="s1">* resize the viewport.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_syncScrollState() {</span><span class="s3">\n        </span><span class="s1">// Fetch the viewport dimensions.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Get the current scroll bar visibility.</span><span class="s3">\n        </span><span class="s1">let hasVScroll = !this._vScrollBar.isHidden;</span><span class="s3">\n        </span><span class="s1">let hasHScroll = !this._hScrollBar.isHidden;</span><span class="s3">\n        </span><span class="s1">// Get the minimum sizes of the scroll bars.</span><span class="s3">\n        </span><span class="s1">let vsw = this._vScrollBarMinWidth;</span><span class="s3">\n        </span><span class="s1">let hsh = this._hScrollBarMinHeight;</span><span class="s3">\n        </span><span class="s1">// Get the page size as if no scroll bars are visible.</span><span class="s3">\n        </span><span class="s1">let apw = pw + (hasVScroll ? vsw : 0);</span><span class="s3">\n        </span><span class="s1">let aph = ph + (hasHScroll ? hsh : 0);</span><span class="s3">\n        </span><span class="s1">// Test whether scroll bars are needed for the adjusted size.</span><span class="s3">\n        </span><span class="s1">let needVScroll = aph &lt; bh - 1;</span><span class="s3">\n        </span><span class="s1">let needHScroll = apw &lt; bw - 1;</span><span class="s3">\n        </span><span class="s1">// Re-test the horizontal scroll if a vertical scroll is needed.</span><span class="s3">\n        </span><span class="s1">if (needVScroll &amp;&amp; !needHScroll) {</span><span class="s3">\n            </span><span class="s1">needHScroll = apw - vsw &lt; bw - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Re-test the vertical scroll if a horizontal scroll is needed.</span><span class="s3">\n        </span><span class="s1">if (needHScroll &amp;&amp; !needVScroll) {</span><span class="s3">\n            </span><span class="s1">needVScroll = aph - hsh &lt; bh - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the visibility changes, immediately refit the grid.</span><span class="s3">\n        </span><span class="s1">if (needVScroll !== hasVScroll || needHScroll !== hasHScroll) {</span><span class="s3">\n            </span><span class="s1">this._vScrollBar.setHidden(!needVScroll);</span><span class="s3">\n            </span><span class="s1">this._hScrollBar.setHidden(!needHScroll);</span><span class="s3">\n            </span><span class="s1">this._scrollCorner.setHidden(!needVScroll || !needHScroll);</span><span class="s3">\n            </span><span class="s1">MessageLoop.sendMessage(this, Widget.Msg.FitRequest);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the scroll bar limits.</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.maximum = this.maxScrollY;</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.page = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.maximum = this.maxScrollX;</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.page = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Re-clamp the scroll position.</span><span class="s3">\n        </span><span class="s1">this._scrollTo(this._scrollX, this._scrollY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Sync the viewport to the given scroll position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This schedules a full repaint and syncs the scroll state.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_syncViewport() {</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process a message sent to the viewport</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_processViewportMessage(msg) {</span><span class="s3">\n        </span><span class="s1">switch (msg.type) {</span><span class="s3">\n            </span><span class="s1">case 'resize':</span><span class="s3">\n                </span><span class="s1">this._onViewportResize(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'scroll-request':</span><span class="s3">\n                </span><span class="s1">this._onViewportScrollRequest(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'paint-request':</span><span class="s3">\n                </span><span class="s1">this._onViewportPaintRequest(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'overlay-paint-request':</span><span class="s3">\n                </span><span class="s1">this._onViewportOverlayPaintRequest(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row-resize-request':</span><span class="s3">\n                </span><span class="s1">this._onViewportRowResizeRequest(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column-resize-request':</span><span class="s3">\n                </span><span class="s1">this._onViewportColumnResizeRequest(msg);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'resize'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportResize(msg) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport is not visible.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Unpack the message data.</span><span class="s3">\n        </span><span class="s1">let { width, height } = msg;</span><span class="s3">\n        </span><span class="s1">// Measure the viewport node if the dimensions are unknown.</span><span class="s3">\n        </span><span class="s1">if (width === -1) {</span><span class="s3">\n            </span><span class="s1">width = this._viewport.node.offsetWidth;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (height === -1) {</span><span class="s3">\n            </span><span class="s1">height = this._viewport.node.offsetHeight;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Round the dimensions to the nearest pixel.</span><span class="s3">\n        </span><span class="s1">width = Math.round(width);</span><span class="s3">\n        </span><span class="s1">height = Math.round(height);</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let oldWidth = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let oldHeight = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// Updated internal viewport size.</span><span class="s3">\n        </span><span class="s1">this._viewportWidth = width;</span><span class="s3">\n        </span><span class="s1">this._viewportHeight = height;</span><span class="s3">\n        </span><span class="s1">// Resize the canvas if needed.</span><span class="s3">\n        </span><span class="s1">this._resizeCanvasIfNeeded(width, height);</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to paint.</span><span class="s3">\n        </span><span class="s1">if (width === 0 || height === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the whole grid if the old size was zero.</span><span class="s3">\n        </span><span class="s1">if (oldWidth === 0 || oldHeight === 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, 0, width, height);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the right edge as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; this.pageWidth &gt; this.bodyWidth) {</span><span class="s3">\n            </span><span class="s1">let bx = this._columnSections.offsetOf(this._columnSections.count - 1);</span><span class="s3">\n            </span><span class="s1">let x = Math.min(this.headerWidth + bx, oldWidth);</span><span class="s3">\n            </span><span class="s1">this.paintContent(x, 0, width - x, height);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (width &gt; oldWidth) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(oldWidth, 0, width - oldWidth + 1, height);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the bottom edge as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; this.pageHeight &gt; this.bodyHeight) {</span><span class="s3">\n            </span><span class="s1">let by = this._rowSections.offsetOf(this._rowSections.count - 1);</span><span class="s3">\n            </span><span class="s1">let y = Math.min(this.headerHeight + by, oldHeight);</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, y, width, height - y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (height &gt; oldHeight) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, oldHeight, width, height - oldHeight + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'scroll-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportScrollRequest(msg) {</span><span class="s3">\n        </span><span class="s1">this._scrollTo(this._hScrollBar.value, this._vScrollBar.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'paint-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportPaintRequest(msg) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport is not visible.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport has zero area.</span><span class="s3">\n        </span><span class="s1">if (this._viewportWidth === 0 || this._viewportHeight === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set up the paint limits.</span><span class="s3">\n        </span><span class="s1">let xMin = 0;</span><span class="s3">\n        </span><span class="s1">let yMin = 0;</span><span class="s3">\n        </span><span class="s1">let xMax = this._viewportWidth - 1;</span><span class="s3">\n        </span><span class="s1">let yMax = this._viewportHeight - 1;</span><span class="s3">\n        </span><span class="s1">// Fetch the scroll position.</span><span class="s3">\n        </span><span class="s1">let sx = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let sy = this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Fetch the header dimensions.</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the section lists.</span><span class="s3">\n        </span><span class="s1">let rs = this._rowSections;</span><span class="s3">\n        </span><span class="s1">let cs = this._columnSections;</span><span class="s3">\n        </span><span class="s1">let rhs = this._rowHeaderSections;</span><span class="s3">\n        </span><span class="s1">let chs = this._columnHeaderSections;</span><span class="s3">\n        </span><span class="s1">// Unpack the message data.</span><span class="s3">\n        </span><span class="s1">let { region, r1, c1, r2, c2 } = msg;</span><span class="s3">\n        </span><span class="s1">// Set up the paint variables.</span><span class="s3">\n        </span><span class="s1">let x1;</span><span class="s3">\n        </span><span class="s1">let y1;</span><span class="s3">\n        </span><span class="s1">let x2;</span><span class="s3">\n        </span><span class="s1">let y2;</span><span class="s3">\n        </span><span class="s1">// Fill the paint variables based on the paint region.</span><span class="s3">\n        </span><span class="s1">switch (region) {</span><span class="s3">\n            </span><span class="s1">case 'all':</span><span class="s3">\n                </span><span class="s1">x1 = xMin;</span><span class="s3">\n                </span><span class="s1">y1 = yMin;</span><span class="s3">\n                </span><span class="s1">x2 = xMax;</span><span class="s3">\n                </span><span class="s1">y2 = yMax;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'body':</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, rs.count));</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, cs.count));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, rs.count));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, cs.count));</span><span class="s3">\n                </span><span class="s1">x1 = cs.offsetOf(c1) - sx + hw;</span><span class="s3">\n                </span><span class="s1">y1 = rs.offsetOf(r1) - sy + hh;</span><span class="s3">\n                </span><span class="s1">x2 = cs.extentOf(c2) - sx + hw;</span><span class="s3">\n                </span><span class="s1">y2 = rs.extentOf(r2) - sy + hh;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row-header':</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, rs.count));</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, rhs.count));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, rs.count));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, rhs.count));</span><span class="s3">\n                </span><span class="s1">x1 = rhs.offsetOf(c1);</span><span class="s3">\n                </span><span class="s1">y1 = rs.offsetOf(r1) - sy + hh;</span><span class="s3">\n                </span><span class="s1">x2 = rhs.extentOf(c2);</span><span class="s3">\n                </span><span class="s1">y2 = rs.extentOf(r2) - sy + hh;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column-header':</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, chs.count));</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, cs.count));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, chs.count));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, cs.count));</span><span class="s3">\n                </span><span class="s1">x1 = cs.offsetOf(c1) - sx + hw;</span><span class="s3">\n                </span><span class="s1">y1 = chs.offsetOf(r1);</span><span class="s3">\n                </span><span class="s1">x2 = cs.extentOf(c2) - sx + hw;</span><span class="s3">\n                </span><span class="s1">y2 = chs.extentOf(r2);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'corner-header':</span><span class="s3">\n                </span><span class="s1">r1 = Math.max(0, Math.min(r1, chs.count));</span><span class="s3">\n                </span><span class="s1">c1 = Math.max(0, Math.min(c1, rhs.count));</span><span class="s3">\n                </span><span class="s1">r2 = Math.max(0, Math.min(r2, chs.count));</span><span class="s3">\n                </span><span class="s1">c2 = Math.max(0, Math.min(c2, rhs.count));</span><span class="s3">\n                </span><span class="s1">x1 = rhs.offsetOf(c1);</span><span class="s3">\n                </span><span class="s1">y1 = chs.offsetOf(r1);</span><span class="s3">\n                </span><span class="s1">x2 = rhs.extentOf(c2);</span><span class="s3">\n                </span><span class="s1">y2 = chs.extentOf(r2);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the dirty rect is outside the bounds.</span><span class="s3">\n        </span><span class="s1">if (x2 &lt; xMin || y2 &lt; yMin || x1 &gt; xMax || y1 &gt; yMax) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the dirty rect to the paint bounds.</span><span class="s3">\n        </span><span class="s1">x1 = Math.max(xMin, Math.min(x1, xMax));</span><span class="s3">\n        </span><span class="s1">y1 = Math.max(yMin, Math.min(y1, yMax));</span><span class="s3">\n        </span><span class="s1">x2 = Math.max(xMin, Math.min(x2, xMax));</span><span class="s3">\n        </span><span class="s1">y2 = Math.max(yMin, Math.min(y2, yMax));</span><span class="s3">\n        </span><span class="s1">// Paint the content of the dirty rect.</span><span class="s3">\n        </span><span class="s1">this.paintContent(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'overlay-paint-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportOverlayPaintRequest(msg) {</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport is not visible.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport has zero area.</span><span class="s3">\n        </span><span class="s1">if (this._viewportWidth === 0 || this._viewportHeight === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the content of the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'row-resize-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportRowResizeRequest(msg) {</span><span class="s3">\n        </span><span class="s1">if (msg.region === 'body') {</span><span class="s3">\n            </span><span class="s1">this._resizeRow(msg.index, msg.size);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._resizeColumnHeader(msg.index, msg.size);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A message hook invoked on a viewport `'column-resize-request'` message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onViewportColumnResizeRequest(msg) {</span><span class="s3">\n        </span><span class="s1">if (msg.region === 'body') {</span><span class="s3">\n            </span><span class="s1">this._resizeColumn(msg.index, msg.size);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._resizeRowHeader(msg.index, msg.size);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `thumbMoved` signal from a scroll bar.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onThumbMoved(sender) {</span><span class="s3">\n        </span><span class="s1">MessageLoop.postMessage(this._viewport, Private$1.ScrollRequest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `pageRequested` signal from a scroll bar.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onPageRequested(sender, dir) {</span><span class="s3">\n        </span><span class="s1">if (sender === this._vScrollBar) {</span><span class="s3">\n            </span><span class="s1">this.scrollByPage(dir === 'decrement' ? 'up' : 'down');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.scrollByPage(dir === 'decrement' ? 'left' : 'right');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `stepRequested` signal from a scroll bar.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onStepRequested(sender, dir) {</span><span class="s3">\n        </span><span class="s1">if (sender === this._vScrollBar) {</span><span class="s3">\n            </span><span class="s1">this.scrollByStep(dir === 'decrement' ? 'up' : 'down');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.scrollByStep(dir === 'decrement' ? 'left' : 'right');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal handler for the data model `changed` signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onDataModelChanged(sender, args) {</span><span class="s3">\n        </span><span class="s1">switch (args.type) {</span><span class="s3">\n            </span><span class="s1">case 'rows-inserted':</span><span class="s3">\n                </span><span class="s1">this._onRowsInserted(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'columns-inserted':</span><span class="s3">\n                </span><span class="s1">this._onColumnsInserted(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'rows-removed':</span><span class="s3">\n                </span><span class="s1">this._onRowsRemoved(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'columns-removed':</span><span class="s3">\n                </span><span class="s1">this._onColumnsRemoved(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'rows-moved':</span><span class="s3">\n                </span><span class="s1">this._onRowsMoved(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'columns-moved':</span><span class="s3">\n                </span><span class="s1">this._onColumnsMoved(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'cells-changed':</span><span class="s3">\n                </span><span class="s1">this._onCellsChanged(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'model-reset':</span><span class="s3">\n                </span><span class="s1">this._onModelReset(args);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal handler for the selection model `changed` signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onSelectionsChanged(sender) {</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle rows being inserted in the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onRowsInserted(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to insert.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._rowSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._columnHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Insert the span, maintaining the scroll position as needed.</span><span class="s3">\n        </span><span class="s1">if (this._scrollY === this.maxScrollY &amp;&amp; this.maxScrollY &gt; 0) {</span><span class="s3">\n            </span><span class="s1">list.insert(index, span);</span><span class="s3">\n            </span><span class="s1">this._scrollY = this.maxScrollY;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list.insert(index, span);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle columns being inserted into the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onColumnsInserted(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to insert.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._columnSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._rowHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Insert the span, maintaining the scroll position as needed.</span><span class="s3">\n        </span><span class="s1">if (this._scrollX === this.maxScrollX &amp;&amp; this.maxScrollX &gt; 0) {</span><span class="s3">\n            </span><span class="s1">list.insert(index, span);</span><span class="s3">\n            </span><span class="s1">this._scrollX = this.maxScrollX;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list.insert(index, span);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle rows being removed from the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onRowsRemoved(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to remove.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._rowSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._columnHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail if the index or is invalid</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Remove the span, maintaining the scroll position as needed.</span><span class="s3">\n        </span><span class="s1">if (this._scrollY === this.maxScrollY &amp;&amp; this.maxScrollY &gt; 0) {</span><span class="s3">\n            </span><span class="s1">list.remove(index, span);</span><span class="s3">\n            </span><span class="s1">this._scrollY = this.maxScrollY;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list.remove(index, span);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle columns being removed from the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onColumnsRemoved(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to remove.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._columnSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._rowHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail if the index or is invalid</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Remove the span, maintaining the scroll position as needed.</span><span class="s3">\n        </span><span class="s1">if (this._scrollX === this.maxScrollX &amp;&amp; this.maxScrollX &gt; 0) {</span><span class="s3">\n            </span><span class="s1">list.remove(index, span);</span><span class="s3">\n            </span><span class="s1">this._scrollX = this.maxScrollX;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list.remove(index, span);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle rows moving in the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onRowsMoved(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span, destination } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to move.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._rowSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._columnHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the move span to the limit.</span><span class="s3">\n        </span><span class="s1">span = Math.min(span, list.count - index);</span><span class="s3">\n        </span><span class="s1">// Clamp the destination index to the limit.</span><span class="s3">\n        </span><span class="s1">destination = Math.min(Math.max(0, destination), list.count - span);</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no effective move.</span><span class="s3">\n        </span><span class="s1">if (index === destination) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the first affected index.</span><span class="s3">\n        </span><span class="s1">let r1 = Math.min(index, destination);</span><span class="s3">\n        </span><span class="s1">// Compute the last affected index.</span><span class="s3">\n        </span><span class="s1">let r2 = Math.max(index + span - 1, destination + span - 1);</span><span class="s3">\n        </span><span class="s1">// Move the sections in the list.</span><span class="s3">\n        </span><span class="s1">list.move(index, span, destination);</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the dirty cells.</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('body', r1, 0, r2, Infinity);</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('row-header', r1, 0, r2, Infinity);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('column-header', r1, 0, r2, Infinity);</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('corner-header', r1, 0, r2, Infinity);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle columns moving in the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onColumnsMoved(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, index, span, destination } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no sections to move.</span><span class="s3">\n        </span><span class="s1">if (span &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the relevant section list.</span><span class="s3">\n        </span><span class="s1">let list;</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">list = this._columnSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">list = this._rowHeaderSections;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clamp the move span to the limit.</span><span class="s3">\n        </span><span class="s1">span = Math.min(span, list.count - index);</span><span class="s3">\n        </span><span class="s1">// Clamp the destination index to the limit.</span><span class="s3">\n        </span><span class="s1">destination = Math.min(Math.max(0, destination), list.count - span);</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no effective move.</span><span class="s3">\n        </span><span class="s1">if (index === destination) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Move the sections in the list.</span><span class="s3">\n        </span><span class="s1">list.move(index, span, destination);</span><span class="s3">\n        </span><span class="s1">// Compute the first affected index.</span><span class="s3">\n        </span><span class="s1">let c1 = Math.min(index, destination);</span><span class="s3">\n        </span><span class="s1">// Compute the last affected index.</span><span class="s3">\n        </span><span class="s1">let c2 = Math.max(index + span - 1, destination + span - 1);</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the dirty cells.</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('body', 0, c1, Infinity, c2);</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('column-header', 0, c1, Infinity, c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('row-header', 0, c1, Infinity, c2);</span><span class="s3">\n            </span><span class="s1">this.repaintRegion('corner-header', 0, c1, Infinity, c2);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle cells changing in the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onCellsChanged(args) {</span><span class="s3">\n        </span><span class="s1">// Unpack the arg data.</span><span class="s3">\n        </span><span class="s1">let { region, row, column, rowSpan, columnSpan } = args;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no cells to modify.</span><span class="s3">\n        </span><span class="s1">if (rowSpan &lt;= 0 &amp;&amp; columnSpan &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the changed cell bounds.</span><span class="s3">\n        </span><span class="s1">let r1 = row;</span><span class="s3">\n        </span><span class="s1">let c1 = column;</span><span class="s3">\n        </span><span class="s1">let r2 = r1 + rowSpan - 1;</span><span class="s3">\n        </span><span class="s1">let c2 = c1 + columnSpan - 1;</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the cell content.</span><span class="s3">\n        </span><span class="s1">this.repaintRegion(region, r1, c1, r2, c2);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle a full data model reset.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onModelReset(args) {</span><span class="s3">\n        </span><span class="s1">// Look up the various current section counts.</span><span class="s3">\n        </span><span class="s1">let nr = this._rowSections.count;</span><span class="s3">\n        </span><span class="s1">let nc = this._columnSections.count;</span><span class="s3">\n        </span><span class="s1">let nrh = this._rowHeaderSections.count;</span><span class="s3">\n        </span><span class="s1">let nch = this._columnHeaderSections.count;</span><span class="s3">\n        </span><span class="s1">// Compute the delta count for each region.</span><span class="s3">\n        </span><span class="s1">let dr = this._dataModel.rowCount('body') - nr;</span><span class="s3">\n        </span><span class="s1">let dc = this._dataModel.columnCount('body') - nc;</span><span class="s3">\n        </span><span class="s1">let drh = this._dataModel.columnCount('row-header') - nrh;</span><span class="s3">\n        </span><span class="s1">let dch = this._dataModel.rowCount('column-header') - nch;</span><span class="s3">\n        </span><span class="s1">// Update the row sections, if needed.</span><span class="s3">\n        </span><span class="s1">if (dr &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this._rowSections.insert(nr, dr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (dr &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this._rowSections.remove(nr + dr, -dr);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the column sections, if needed.</span><span class="s3">\n        </span><span class="s1">if (dc &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this._columnSections.insert(nc, dc);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (dc &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this._columnSections.remove(nc + dc, -dc);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the row header sections, if needed.</span><span class="s3">\n        </span><span class="s1">if (drh &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this._rowHeaderSections.insert(nrh, drh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (drh &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this._rowHeaderSections.remove(nrh + drh, -drh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the column header sections, if needed.</span><span class="s3">\n        </span><span class="s1">if (dch &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this._columnHeaderSections.insert(nch, dch);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (dch &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this._columnHeaderSections.remove(nch + dch, -dch);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Sync the viewport.</span><span class="s3">\n        </span><span class="s1">this._syncViewport();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal handler for the renderer map `changed` signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_onRenderersChanged() {</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'keydown'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtKeyDown(event) {</span><span class="s3">\n        </span><span class="s1">if (this._mousedown) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this._keyHandler) {</span><span class="s3">\n            </span><span class="s1">this._keyHandler.onKeyDown(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'mousedown'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtMouseDown(event) {</span><span class="s3">\n        </span><span class="s1">// Ignore everything except the left mouse button.</span><span class="s3">\n        </span><span class="s1">if (event.button !== 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Activate the grid.</span><span class="s3">\n        </span><span class="s1">this.activate();</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Add the extra document listeners.</span><span class="s3">\n        </span><span class="s1">document.addEventListener('keydown', this, true);</span><span class="s3">\n        </span><span class="s1">document.addEventListener('mouseup', this, true);</span><span class="s3">\n        </span><span class="s1">document.addEventListener('mousedown', this, true);</span><span class="s3">\n        </span><span class="s1">document.addEventListener('mousemove', this, true);</span><span class="s3">\n        </span><span class="s1">document.addEventListener('contextmenu', this, true);</span><span class="s3">\n        </span><span class="s1">// Flip the mousedown flag.</span><span class="s3">\n        </span><span class="s1">this._mousedown = true;</span><span class="s3">\n        </span><span class="s1">// Dispatch to the mouse handler.</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseDown(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'mousemove'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtMouseMove(event) {</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation if the mouse is down.</span><span class="s3">\n        </span><span class="s1">if (this._mousedown) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail if there is no mouse handler.</span><span class="s3">\n        </span><span class="s1">if (!this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Dispatch to the mouse handler.</span><span class="s3">\n        </span><span class="s1">if (this._mousedown) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseMove(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseHover(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'mouseup'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtMouseUp(event) {</span><span class="s3">\n        </span><span class="s1">// Ignore everything except the left mouse button.</span><span class="s3">\n        </span><span class="s1">if (event.button !== 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Dispatch to the mouse handler.</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseUp(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'dblclick'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtMouseDoubleClick(event) {</span><span class="s3">\n        </span><span class="s1">// Ignore everything except the left mouse button.</span><span class="s3">\n        </span><span class="s1">if (event.button !== 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stop the event propagation.</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n        </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">// Dispatch to the mouse handler.</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseDoubleClick(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Release the mouse.</span><span class="s3">\n        </span><span class="s1">this._releaseMouse();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'mouseleave'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtMouseLeave(event) {</span><span class="s3">\n        </span><span class="s1">if (this._mousedown) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onMouseLeave(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'contextmenu'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtContextMenu(event) {</span><span class="s3">\n        </span><span class="s1">if (this._mousedown) {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">event.stopPropagation();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.onContextMenu(this, event);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Handle the `'wheel'` event for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_evtWheel(event) {</span><span class="s3">\n        </span><span class="s1">// Ignore the event if `accel` is held.</span><span class="s3">\n        </span><span class="s1">if (Platform.accelKey(event)) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no mouse handler.</span><span class="s3">\n        </span><span class="s1">if (!this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Dispatch to the mouse handler.</span><span class="s3">\n        </span><span class="s1">this._mouseHandler.onWheel(this, event);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Release the mouse grab.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_releaseMouse() {</span><span class="s3">\n        </span><span class="s1">// Clear the mousedown flag.</span><span class="s3">\n        </span><span class="s1">this._mousedown = false;</span><span class="s3">\n        </span><span class="s1">// Relase the mouse handler.</span><span class="s3">\n        </span><span class="s1">if (this._mouseHandler) {</span><span class="s3">\n            </span><span class="s1">this._mouseHandler.release();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Remove the document listeners.</span><span class="s3">\n        </span><span class="s1">document.removeEventListener('keydown', this, true);</span><span class="s3">\n        </span><span class="s1">document.removeEventListener('mouseup', this, true);</span><span class="s3">\n        </span><span class="s1">document.removeEventListener('mousedown', this, true);</span><span class="s3">\n        </span><span class="s1">document.removeEventListener('mousemove', this, true);</span><span class="s3">\n        </span><span class="s1">document.removeEventListener('contextmenu', this, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Refresh the dpi ratio.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_refreshDPI() {</span><span class="s3">\n        </span><span class="s1">// Get the best integral value for the dpi ratio.</span><span class="s3">\n        </span><span class="s1">let dpiRatio = Math.ceil(window.devicePixelRatio);</span><span class="s3">\n        </span><span class="s1">// Bail early if the computed dpi ratio has not changed.</span><span class="s3">\n        </span><span class="s1">if (this._dpiRatio === dpiRatio) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal dpi ratio.</span><span class="s3">\n        </span><span class="s1">this._dpiRatio = dpiRatio;</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the content.</span><span class="s3">\n        </span><span class="s1">this.repaintContent();</span><span class="s3">\n        </span><span class="s1">// Schedule a repaint of the overlay.</span><span class="s3">\n        </span><span class="s1">this.repaintOverlay();</span><span class="s3">\n        </span><span class="s1">// Update the canvas size for the new dpi ratio.</span><span class="s3">\n        </span><span class="s1">this._resizeCanvasIfNeeded(this._viewportWidth, this._viewportHeight);</span><span class="s3">\n        </span><span class="s1">// Ensure the canvas style is scaled for the new ratio.</span><span class="s3">\n        </span><span class="s1">this._canvas.style.width = `${this._canvas.width / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">this._canvas.style.height = `${this._canvas.height / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">// Ensure the overlay style is scaled for the new ratio.</span><span class="s3">\n        </span><span class="s1">this._overlay.style.width = `${this._overlay.width / this._dpiRatio}px`;</span><span class="s3">\n        </span><span class="s1">this._overlay.style.height = `${this._overlay.height / this._dpiRatio}px`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a row section immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_resizeRow(index, size) {</span><span class="s3">\n        </span><span class="s1">// Look up the target section list.</span><span class="s3">\n        </span><span class="s1">let list = this._rowSections;</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the old size of the section.</span><span class="s3">\n        </span><span class="s1">let oldSize = list.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Normalize the new size of the section.</span><span class="s3">\n        </span><span class="s1">let newSize = list.clampSize(size);</span><span class="s3">\n        </span><span class="s1">// Bail early if the size does not change.</span><span class="s3">\n        </span><span class="s1">if (oldSize === newSize) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the section in the list.</span><span class="s3">\n        </span><span class="s1">list.resize(index, newSize);</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// If there is nothing to paint, sync the scroll state.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible || vw === 0 || vh === 0) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the size delta.</span><span class="s3">\n        </span><span class="s1">let delta = newSize - oldSize;</span><span class="s3">\n        </span><span class="s1">// Look up the column header height.</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Compute the viewport offset of the section.</span><span class="s3">\n        </span><span class="s1">let offset = list.offsetOf(index) + hh - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to paint.</span><span class="s3">\n        </span><span class="s1">if (hh &gt;= vh || offset &gt;= vh) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the scroll position if the section is not visible.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &lt;= hh) {</span><span class="s3">\n            </span><span class="s1">this._scrollY += delta;</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the paint origin of the section.</span><span class="s3">\n        </span><span class="s1">let pos = Math.max(hh, offset);</span><span class="s3">\n        </span><span class="s1">// Paint from the section onward if it spans the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &gt;= vh || offset + newSize &gt;= vh) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, pos, vw, vh - pos);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the X blit dimensions.</span><span class="s3">\n        </span><span class="s1">let sx = 0;</span><span class="s3">\n        </span><span class="s1">let sw = vw;</span><span class="s3">\n        </span><span class="s1">let dx = 0;</span><span class="s3">\n        </span><span class="s1">// Compute the Y blit dimensions.</span><span class="s3">\n        </span><span class="s1">let sy;</span><span class="s3">\n        </span><span class="s1">let sh;</span><span class="s3">\n        </span><span class="s1">let dy;</span><span class="s3">\n        </span><span class="s1">if (offset + newSize &lt;= hh) {</span><span class="s3">\n            </span><span class="s1">sy = hh - delta;</span><span class="s3">\n            </span><span class="s1">sh = vh - sy;</span><span class="s3">\n            </span><span class="s1">dy = hh;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">sy = offset + oldSize;</span><span class="s3">\n            </span><span class="s1">sh = vh - sy;</span><span class="s3">\n            </span><span class="s1">dy = sy + delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Blit the valid content to the destination.</span><span class="s3">\n        </span><span class="s1">this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);</span><span class="s3">\n        </span><span class="s1">// Repaint the section if needed.</span><span class="s3">\n        </span><span class="s1">if (newSize &gt; 0 &amp;&amp; offset + newSize &gt; hh) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, pos, vw, offset + newSize - pos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the trailing space as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; this.pageHeight &gt; this.bodyHeight) {</span><span class="s3">\n            </span><span class="s1">let r = this._rowSections.count - 1;</span><span class="s3">\n            </span><span class="s1">let y = hh + this._rowSections.offsetOf(r);</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, y, vw, vh - y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (delta &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, vh + delta, vw, -delta);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Repaint merged cells that are intersected by the resized row</span><span class="s3">\n        </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n        </span><span class="s1">for (const rgn of ['body', 'row-header']) {</span><span class="s3">\n            </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRow(this.dataModel, rgn, index);</span><span class="s3">\n            </span><span class="s1">let paintRgn = {</span><span class="s3">\n                </span><span class="s1">region: rgn,</span><span class="s3">\n                </span><span class="s1">xMin: 0,</span><span class="s3">\n                </span><span class="s1">xMax: 0,</span><span class="s3">\n                </span><span class="s1">yMin: 0,</span><span class="s3">\n                </span><span class="s1">yMax: 0</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">let backgroundColor = undefined;</span><span class="s3">\n            </span><span class="s1">switch (rgn) {</span><span class="s3">\n                </span><span class="s1">case 'body':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                    </span><span class="s1">backgroundColor = this._style.backgroundColor;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'row-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                    </span><span class="s1">backgroundColor = this._style.headerBackgroundColor;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._paintMergedCells(cellGroups, paintRgn, backgroundColor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n        </span><span class="s1">// Sync the scroll state.</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a column section immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_resizeColumn(index, size) {</span><span class="s3">\n        </span><span class="s1">// Look up the target section list.</span><span class="s3">\n        </span><span class="s1">let list = this._columnSections;</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const adjustedSize = size !== null &amp;&amp; size !== void 0 ? size : this._getMaxWidthInColumn(index, 'body');</span><span class="s3">\n        </span><span class="s1">if (!adjustedSize || adjustedSize == 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the old size of the section.</span><span class="s3">\n        </span><span class="s1">let oldSize = list.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Normalize the new size of the section.</span><span class="s3">\n        </span><span class="s1">let newSize = list.clampSize(adjustedSize);</span><span class="s3">\n        </span><span class="s1">// Bail early if the size does not change.</span><span class="s3">\n        </span><span class="s1">if (oldSize === newSize) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the section in the list.</span><span class="s3">\n        </span><span class="s1">list.resize(index, newSize);</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// If there is nothing to paint, sync the scroll state.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible || vw === 0 || vh === 0) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the size delta.</span><span class="s3">\n        </span><span class="s1">let delta = newSize - oldSize;</span><span class="s3">\n        </span><span class="s1">// Look up the row header width.</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">// Compute the viewport offset of the section.</span><span class="s3">\n        </span><span class="s1">let offset = list.offsetOf(index) + hw - this._scrollX;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to paint.</span><span class="s3">\n        </span><span class="s1">if (hw &gt;= vw || offset &gt;= vw) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the scroll position if the section is not visible.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &lt;= hw) {</span><span class="s3">\n            </span><span class="s1">this._scrollX += delta;</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the paint origin of the section.</span><span class="s3">\n        </span><span class="s1">let pos = Math.max(hw, offset);</span><span class="s3">\n        </span><span class="s1">// Paint from the section onward if it spans the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &gt;= vw || offset + newSize &gt;= vw) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(pos, 0, vw - pos, vh);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the Y blit dimensions.</span><span class="s3">\n        </span><span class="s1">let sy = 0;</span><span class="s3">\n        </span><span class="s1">let sh = vh;</span><span class="s3">\n        </span><span class="s1">let dy = 0;</span><span class="s3">\n        </span><span class="s1">// Compute the X blit dimensions.</span><span class="s3">\n        </span><span class="s1">let sx;</span><span class="s3">\n        </span><span class="s1">let sw;</span><span class="s3">\n        </span><span class="s1">let dx;</span><span class="s3">\n        </span><span class="s1">if (offset + newSize &lt;= hw) {</span><span class="s3">\n            </span><span class="s1">sx = hw - delta;</span><span class="s3">\n            </span><span class="s1">sw = vw - sx;</span><span class="s3">\n            </span><span class="s1">dx = hw;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">sx = offset + oldSize;</span><span class="s3">\n            </span><span class="s1">sw = vw - sx;</span><span class="s3">\n            </span><span class="s1">dx = sx + delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Blit the valid content to the destination.</span><span class="s3">\n        </span><span class="s1">this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);</span><span class="s3">\n        </span><span class="s1">// Repaint the section if needed.</span><span class="s3">\n        </span><span class="s1">if (newSize &gt; 0 &amp;&amp; offset + newSize &gt; hw) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(pos, 0, offset + newSize - pos, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the trailing space as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; this.pageWidth &gt; this.bodyWidth) {</span><span class="s3">\n            </span><span class="s1">let c = this._columnSections.count - 1;</span><span class="s3">\n            </span><span class="s1">let x = hw + this._columnSections.offsetOf(c);</span><span class="s3">\n            </span><span class="s1">this.paintContent(x, 0, vw - x, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (delta &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(vw + delta, 0, -delta, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Repaint merged cells that are intersected by the resized column</span><span class="s3">\n        </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n        </span><span class="s1">for (const rgn of ['body', 'column-header']) {</span><span class="s3">\n            </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtColumn(this.dataModel, rgn, index);</span><span class="s3">\n            </span><span class="s1">let paintRgn = {</span><span class="s3">\n                </span><span class="s1">region: rgn,</span><span class="s3">\n                </span><span class="s1">xMin: 0,</span><span class="s3">\n                </span><span class="s1">xMax: 0,</span><span class="s3">\n                </span><span class="s1">yMin: 0,</span><span class="s3">\n                </span><span class="s1">yMax: 0</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">let backgroundColor = undefined;</span><span class="s3">\n            </span><span class="s1">switch (rgn) {</span><span class="s3">\n                </span><span class="s1">case 'body':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                    </span><span class="s1">backgroundColor = this._style.backgroundColor;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'column-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">backgroundColor = this._style.headerBackgroundColor;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._paintMergedCells(cellGroups, paintRgn, backgroundColor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n        </span><span class="s1">// Sync the scroll state after painting.</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a row header section immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_resizeRowHeader(index, size) {</span><span class="s3">\n        </span><span class="s1">// Look up the target section list.</span><span class="s3">\n        </span><span class="s1">let list = this._rowHeaderSections;</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const adjustedSize = size !== null &amp;&amp; size !== void 0 ? size : this._getMaxWidthInColumn(index, 'row-header');</span><span class="s3">\n        </span><span class="s1">if (!adjustedSize || adjustedSize == 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the old size of the section.</span><span class="s3">\n        </span><span class="s1">let oldSize = list.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Normalize the new size of the section.</span><span class="s3">\n        </span><span class="s1">let newSize = list.clampSize(adjustedSize);</span><span class="s3">\n        </span><span class="s1">// Bail early if the size does not change.</span><span class="s3">\n        </span><span class="s1">if (oldSize === newSize) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the section in the list.</span><span class="s3">\n        </span><span class="s1">list.resize(index, newSize);</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// If there is nothing to paint, sync the scroll state.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible || vw === 0 || vh === 0) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the size delta.</span><span class="s3">\n        </span><span class="s1">let delta = newSize - oldSize;</span><span class="s3">\n        </span><span class="s1">// Look up the offset of the section.</span><span class="s3">\n        </span><span class="s1">let offset = list.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">// Bail early if the section is fully outside the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset &gt;= vw) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the entire tail if the section spans the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &gt;= vw || offset + newSize &gt;= vw) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(offset, 0, vw - offset, vh);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the blit content dimensions.</span><span class="s3">\n        </span><span class="s1">let sx = offset + oldSize;</span><span class="s3">\n        </span><span class="s1">let sy = 0;</span><span class="s3">\n        </span><span class="s1">let sw = vw - sx;</span><span class="s3">\n        </span><span class="s1">let sh = vh;</span><span class="s3">\n        </span><span class="s1">let dx = sx + delta;</span><span class="s3">\n        </span><span class="s1">let dy = 0;</span><span class="s3">\n        </span><span class="s1">// Blit the valid content to the destination.</span><span class="s3">\n        </span><span class="s1">this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);</span><span class="s3">\n        </span><span class="s1">// Repaint the header section if needed.</span><span class="s3">\n        </span><span class="s1">if (newSize &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(offset, 0, newSize, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the trailing space as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; this.pageWidth &gt; this.bodyWidth) {</span><span class="s3">\n            </span><span class="s1">let c = this._columnSections.count - 1;</span><span class="s3">\n            </span><span class="s1">let x = this.headerWidth + this._columnSections.offsetOf(c);</span><span class="s3">\n            </span><span class="s1">this.paintContent(x, 0, vw - x, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (delta &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(vw + delta, 0, -delta, vh);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Repaint merged cells that are intersected by the resized row</span><span class="s3">\n        </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n        </span><span class="s1">for (const rgn of [</span><span class="s3">\n            </span><span class="s1">'corner-header',</span><span class="s3">\n            </span><span class="s1">'row-header'</span><span class="s3">\n        </span><span class="s1">]) {</span><span class="s3">\n            </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtColumn(this.dataModel, rgn, index);</span><span class="s3">\n            </span><span class="s1">let paintRgn = {</span><span class="s3">\n                </span><span class="s1">region: rgn,</span><span class="s3">\n                </span><span class="s1">xMin: 0,</span><span class="s3">\n                </span><span class="s1">xMax: 0,</span><span class="s3">\n                </span><span class="s1">yMin: 0,</span><span class="s3">\n                </span><span class="s1">yMax: 0</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">switch (rgn) {</span><span class="s3">\n                </span><span class="s1">case 'corner-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'row-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._paintMergedCells(cellGroups, paintRgn, this._style.headerBackgroundColor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n        </span><span class="s1">// Sync the scroll state after painting.</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resize a column header section immediately.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_resizeColumnHeader(index, size) {</span><span class="s3">\n        </span><span class="s1">// Look up the target section list.</span><span class="s3">\n        </span><span class="s1">let list = this._columnHeaderSections;</span><span class="s3">\n        </span><span class="s1">// Bail early if the index is out of range.</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || index &gt;= list.count) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Look up the old size of the section.</span><span class="s3">\n        </span><span class="s1">let oldSize = list.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">// Normalize the new size of the section.</span><span class="s3">\n        </span><span class="s1">let newSize = list.clampSize(size);</span><span class="s3">\n        </span><span class="s1">// Bail early if the size does not change.</span><span class="s3">\n        </span><span class="s1">if (oldSize === newSize) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resize the section in the list.</span><span class="s3">\n        </span><span class="s1">list.resize(index, newSize);</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// If there is nothing to paint, sync the scroll state.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible || vw === 0 || vh === 0) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n        </span><span class="s1">// Compute the size delta.</span><span class="s3">\n        </span><span class="s1">let delta = newSize - oldSize;</span><span class="s3">\n        </span><span class="s1">// Look up the offset of the section.</span><span class="s3">\n        </span><span class="s1">let offset = list.offsetOf(index);</span><span class="s3">\n        </span><span class="s1">// Bail early if the section is fully outside the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset &gt;= vh) {</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the entire tail if the section spans the viewport.</span><span class="s3">\n        </span><span class="s1">if (offset + oldSize &gt;= vh || offset + newSize &gt;= vh) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, offset, vw, vh - offset);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">this._syncScrollState();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the blit content dimensions.</span><span class="s3">\n        </span><span class="s1">let sx = 0;</span><span class="s3">\n        </span><span class="s1">let sy = offset + oldSize;</span><span class="s3">\n        </span><span class="s1">let sw = vw;</span><span class="s3">\n        </span><span class="s1">let sh = vh - sy;</span><span class="s3">\n        </span><span class="s1">let dx = 0;</span><span class="s3">\n        </span><span class="s1">let dy = sy + delta;</span><span class="s3">\n        </span><span class="s1">// Blit the valid contents to the destination.</span><span class="s3">\n        </span><span class="s1">this._blitContent(this._canvas, sx, sy, sw, sh, dx, dy);</span><span class="s3">\n        </span><span class="s1">// Repaint the header section if needed.</span><span class="s3">\n        </span><span class="s1">if (newSize &gt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, offset, vw, newSize);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the trailing space as needed.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; this.pageHeight &gt; this.bodyHeight) {</span><span class="s3">\n            </span><span class="s1">let r = this._rowSections.count - 1;</span><span class="s3">\n            </span><span class="s1">let y = this.headerHeight + this._rowSections.offsetOf(r);</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, y, vw, vh - y);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (delta &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, vh + delta, vw, -delta);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Repaint merged cells that are intersected by the resized row</span><span class="s3">\n        </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n        </span><span class="s1">for (const rgn of [</span><span class="s3">\n            </span><span class="s1">'corner-header',</span><span class="s3">\n            </span><span class="s1">'column-header'</span><span class="s3">\n        </span><span class="s1">]) {</span><span class="s3">\n            </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRow(this.dataModel, rgn, index);</span><span class="s3">\n            </span><span class="s1">let paintRgn = {</span><span class="s3">\n                </span><span class="s1">region: rgn,</span><span class="s3">\n                </span><span class="s1">xMin: 0,</span><span class="s3">\n                </span><span class="s1">xMax: 0,</span><span class="s3">\n                </span><span class="s1">yMin: 0,</span><span class="s3">\n                </span><span class="s1">yMax: 0</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">switch (rgn) {</span><span class="s3">\n                </span><span class="s1">case 'corner-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'column-header':</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMin = 0;</span><span class="s3">\n                    </span><span class="s1">paintRgn.yMax = this.headerHeight;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._paintMergedCells(cellGroups, paintRgn, this._style.headerBackgroundColor);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n        </span><span class="s1">// Sync the scroll state after painting.</span><span class="s3">\n        </span><span class="s1">this._syncScrollState();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Scroll immediately to the specified offset position.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_scrollTo(x, y) {</span><span class="s3">\n        </span><span class="s1">// Bail if no data model found.</span><span class="s3">\n        </span><span class="s1">if (!this.dataModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Floor and clamp the position to the allowable range.</span><span class="s3">\n        </span><span class="s1">x = Math.max(0, Math.min(Math.floor(x), this.maxScrollX));</span><span class="s3">\n        </span><span class="s1">y = Math.max(0, Math.min(Math.floor(y), this.maxScrollY));</span><span class="s3">\n        </span><span class="s1">// Synchronize the scroll bar values.</span><span class="s3">\n        </span><span class="s1">this._hScrollBar.value = x;</span><span class="s3">\n        </span><span class="s1">this._vScrollBar.value = y;</span><span class="s3">\n        </span><span class="s1">// Compute the delta scroll amount.</span><span class="s3">\n        </span><span class="s1">let dx = x - this._scrollX;</span><span class="s3">\n        </span><span class="s1">let dy = y - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no effective scroll.</span><span class="s3">\n        </span><span class="s1">if (dx === 0 &amp;&amp; dy === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport is not visible.</span><span class="s3">\n        </span><span class="s1">if (!this._viewport.isVisible) {</span><span class="s3">\n            </span><span class="s1">this._scrollX = x;</span><span class="s3">\n            </span><span class="s1">this._scrollY = y;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the current size of the viewport.</span><span class="s3">\n        </span><span class="s1">let width = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let height = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// Bail early if the viewport is empty.</span><span class="s3">\n        </span><span class="s1">if (width === 0 || height === 0) {</span><span class="s3">\n            </span><span class="s1">this._scrollX = x;</span><span class="s3">\n            </span><span class="s1">this._scrollY = y;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the visible content origin.</span><span class="s3">\n        </span><span class="s1">let contentX = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let contentY = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Get the visible content dimensions.</span><span class="s3">\n        </span><span class="s1">let contentWidth = width - contentX;</span><span class="s3">\n        </span><span class="s1">let contentHeight = height - contentY;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no content to draw.</span><span class="s3">\n        </span><span class="s1">if (contentWidth &lt;= 0 &amp;&amp; contentHeight &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">this._scrollX = x;</span><span class="s3">\n            </span><span class="s1">this._scrollY = y;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the area which needs painting for the `dx` scroll.</span><span class="s3">\n        </span><span class="s1">let dxArea = 0;</span><span class="s3">\n        </span><span class="s1">if (dx !== 0 &amp;&amp; contentWidth &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (Math.abs(dx) &gt;= contentWidth) {</span><span class="s3">\n                </span><span class="s1">dxArea = contentWidth * height;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">dxArea = Math.abs(dx) * height;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the area which needs painting for the `dy` scroll.</span><span class="s3">\n        </span><span class="s1">let dyArea = 0;</span><span class="s3">\n        </span><span class="s1">if (dy !== 0 &amp;&amp; contentHeight &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (Math.abs(dy) &gt;= contentHeight) {</span><span class="s3">\n                </span><span class="s1">dyArea = width * contentHeight;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">dyArea = width * Math.abs(dy);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If the area sum is larger than the total, paint everything.</span><span class="s3">\n        </span><span class="s1">if (dxArea + dyArea &gt;= width * height) {</span><span class="s3">\n            </span><span class="s1">this._scrollX = x;</span><span class="s3">\n            </span><span class="s1">this._scrollY = y;</span><span class="s3">\n            </span><span class="s1">this.paintContent(0, 0, width, height);</span><span class="s3">\n            </span><span class="s1">this._paintOverlay();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal Y scroll position.</span><span class="s3">\n        </span><span class="s1">this._scrollY = y;</span><span class="s3">\n        </span><span class="s1">// Scroll the Y axis if needed. If the scroll distance exceeds</span><span class="s3">\n        </span><span class="s1">// the visible height, paint everything. Otherwise, blit the</span><span class="s3">\n        </span><span class="s1">// valid content and paint the dirty region.</span><span class="s3">\n        </span><span class="s1">if (dy !== 0 &amp;&amp; contentHeight &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (Math.abs(dy) &gt;= contentHeight) {</span><span class="s3">\n                </span><span class="s1">this.paintContent(0, contentY, width, contentHeight);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const x = 0;</span><span class="s3">\n                </span><span class="s1">const y = dy &lt; 0 ? contentY : contentY + dy;</span><span class="s3">\n                </span><span class="s1">const w = width;</span><span class="s3">\n                </span><span class="s1">const h = contentHeight - Math.abs(dy);</span><span class="s3">\n                </span><span class="s1">this._blitContent(this._canvas, x, y, w, h, x, y - dy);</span><span class="s3">\n                </span><span class="s1">this.paintContent(0, dy &lt; 0 ? contentY : height - dy, width, Math.abs(dy));</span><span class="s3">\n                </span><span class="s1">// Repaint merged cells that are intersected by the scroll level</span><span class="s3">\n                </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n                </span><span class="s1">for (const rgn of ['body', 'row-header']) {</span><span class="s3">\n                    </span><span class="s1">const cellgroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn);</span><span class="s3">\n                    </span><span class="s1">let paintRgn = {</span><span class="s3">\n                        </span><span class="s1">region: rgn,</span><span class="s3">\n                        </span><span class="s1">xMin: 0,</span><span class="s3">\n                        </span><span class="s1">xMax: 0,</span><span class="s3">\n                        </span><span class="s1">yMin: 0,</span><span class="s3">\n                        </span><span class="s1">yMax: 0</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">let backgroundColor = undefined;</span><span class="s3">\n                    </span><span class="s1">switch (rgn) {</span><span class="s3">\n                        </span><span class="s1">case 'body':</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                            </span><span class="s1">backgroundColor = this._style.backgroundColor;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'row-header':</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMin = 0;</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMax = this.headerWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                            </span><span class="s1">backgroundColor = this._style.headerBackgroundColor;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this._paintMergedCells(cellgroups, paintRgn, backgroundColor);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Update the internal X scroll position.</span><span class="s3">\n        </span><span class="s1">this._scrollX = x;</span><span class="s3">\n        </span><span class="s1">// Scroll the X axis if needed. If the scroll distance exceeds</span><span class="s3">\n        </span><span class="s1">// the visible width, paint everything. Otherwise, blit the</span><span class="s3">\n        </span><span class="s1">// valid content and paint the dirty region.</span><span class="s3">\n        </span><span class="s1">if (dx !== 0 &amp;&amp; contentWidth &gt; 0) {</span><span class="s3">\n            </span><span class="s1">if (Math.abs(dx) &gt;= contentWidth) {</span><span class="s3">\n                </span><span class="s1">this.paintContent(contentX, 0, contentWidth, height);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">const x = dx &lt; 0 ? contentX : contentX + dx;</span><span class="s3">\n                </span><span class="s1">const y = 0;</span><span class="s3">\n                </span><span class="s1">const w = contentWidth - Math.abs(dx);</span><span class="s3">\n                </span><span class="s1">const h = height;</span><span class="s3">\n                </span><span class="s1">this._blitContent(this._canvas, x, y, w, h, x - dx, y);</span><span class="s3">\n                </span><span class="s1">this.paintContent(dx &lt; 0 ? contentX : width - dx, 0, Math.abs(dx), height);</span><span class="s3">\n                </span><span class="s1">// Repaint merged cells that are intersected by the scroll level</span><span class="s3">\n                </span><span class="s1">// Otherwise it will be cut in two by the valid content, and drawn incorrectly</span><span class="s3">\n                </span><span class="s1">for (const rgn of ['body', 'column-header']) {</span><span class="s3">\n                    </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn);</span><span class="s3">\n                    </span><span class="s1">let paintRgn = {</span><span class="s3">\n                        </span><span class="s1">region: rgn,</span><span class="s3">\n                        </span><span class="s1">xMin: 0,</span><span class="s3">\n                        </span><span class="s1">xMax: 0,</span><span class="s3">\n                        </span><span class="s1">yMin: 0,</span><span class="s3">\n                        </span><span class="s1">yMax: 0</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">let backgroundColor = undefined;</span><span class="s3">\n                    </span><span class="s1">switch (rgn) {</span><span class="s3">\n                        </span><span class="s1">case 'body':</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMin = this.headerHeight;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMax = this.headerHeight + this.bodyHeight;</span><span class="s3">\n                            </span><span class="s1">backgroundColor = this._style.backgroundColor;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'column-header':</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMin = this.headerWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.xMax = this.headerWidth + this.bodyWidth;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMin = 0;</span><span class="s3">\n                            </span><span class="s1">paintRgn.yMax = this.headerHeight;</span><span class="s3">\n                            </span><span class="s1">backgroundColor = this._style.headerBackgroundColor;</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this._paintMergedCells(cellGroups, paintRgn, backgroundColor);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Paint the overlay.</span><span class="s3">\n        </span><span class="s1">this._paintOverlay();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Blit content into the on-screen grid canvas.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The rect should be expressed in viewport coordinates.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This automatically accounts for the dpi ratio.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_blitContent(source, x, y, w, h, dx, dy) {</span><span class="s3">\n        </span><span class="s1">// Scale the blit coordinates by the dpi ratio.</span><span class="s3">\n        </span><span class="s1">x *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">y *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">w *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">h *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">dx *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">dy *= this._dpiRatio;</span><span class="s3">\n        </span><span class="s1">// Save the current gc state.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.save();</span><span class="s3">\n        </span><span class="s1">// Set the transform to the identity matrix.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.setTransform(1, 0, 0, 1, 0, 0);</span><span class="s3">\n        </span><span class="s1">// Draw the specified content.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.drawImage(source, x, y, w, h, dx, dy, w, h);</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint the grid content for the given dirty rect.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The rect should be expressed in valid viewport coordinates.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is the primary paint entry point. The individual `_draw*`</span><span class="s3">\n     </span><span class="s1">* methods should not be invoked directly. This method dispatches</span><span class="s3">\n     </span><span class="s1">* to the drawing methods in the correct order.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">paintContent(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Scale the canvas and buffer GC for the dpi ratio.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);</span><span class="s3">\n        </span><span class="s1">this._bufferGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);</span><span class="s3">\n        </span><span class="s1">// Clear the dirty rect of all content.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.clearRect(rx, ry, rw, rh);</span><span class="s3">\n        </span><span class="s1">// Draw the void region.</span><span class="s3">\n        </span><span class="s1">this._drawVoidRegion(rx, ry, rw, rh);</span><span class="s3">\n        </span><span class="s1">// Draw the body region.</span><span class="s3">\n        </span><span class="s1">this._drawBodyRegion(rx, ry, rw, rh);</span><span class="s3">\n        </span><span class="s1">// Draw the row header region.</span><span class="s3">\n        </span><span class="s1">this._drawRowHeaderRegion(rx, ry, rw, rh);</span><span class="s3">\n        </span><span class="s1">// Draw the column header region.</span><span class="s3">\n        </span><span class="s1">this._drawColumnHeaderRegion(rx, ry, rw, rh);</span><span class="s3">\n        </span><span class="s1">// Draw the corner header region.</span><span class="s3">\n        </span><span class="s1">this.drawCornerHeaderRegion(rx, ry, rw, rh);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resizes body column headers so their text fits</span><span class="s3">\n     </span><span class="s1">* without clipping or wrapping.</span><span class="s3">\n     </span><span class="s1">* @param dataModel</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_fitBodyColumnHeaders(dataModel, padding, numCols) {</span><span class="s3">\n        </span><span class="s1">// Get the body column count</span><span class="s3">\n        </span><span class="s1">const bodyColumnCount = numCols === undefined ? dataModel.columnCount('body') : numCols;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; bodyColumnCount; i++) {</span><span class="s3">\n            </span><span class="s1">/*</span><span class="s3">\n              </span><span class="s1">if we're working with nested column headers,</span><span class="s3">\n              </span><span class="s1">retrieve the nested levels and iterate on them.</span><span class="s3">\n            </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">const numRows = dataModel.rowCount('column-header');</span><span class="s3">\n            </span><span class="s1">/*</span><span class="s3">\n              </span><span class="s1">Calculate the maximum text width, across</span><span class="s3">\n              </span><span class="s1">all nested rows under a given column number.</span><span class="s3">\n            </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">let maxWidth = 0;</span><span class="s3">\n            </span><span class="s1">for (let j = 0; j &lt; numRows; j++) {</span><span class="s3">\n                </span><span class="s1">const config = DataGrid._getConfig(dataModel, j, i, 'column-header');</span><span class="s3">\n                </span><span class="s1">const textWidth = this._getCellTextWidth(config);</span><span class="s3">\n                </span><span class="s1">// Update the maximum width for that column.</span><span class="s3">\n                </span><span class="s1">maxWidth = Math.max(maxWidth, textWidth);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/*</span><span class="s3">\n              </span><span class="s1">Send a resize message with new width for the given column.</span><span class="s3">\n              </span><span class="s1">Using a padding of 15 pixels to leave some room.</span><span class="s3">\n            </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.resizeColumn('body', i, maxWidth + padding);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Resizes row header columns so their text fits</span><span class="s3">\n     </span><span class="s1">* without clipping or wrapping.</span><span class="s3">\n     </span><span class="s1">* @param dataModel</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_fitRowColumnHeaders(dataModel, padding, numCols) {</span><span class="s3">\n        </span><span class="s1">/*</span><span class="s3">\n          </span><span class="s1">if we're working with nested row headers,</span><span class="s3">\n          </span><span class="s1">retrieve the nested levels and iterate on them.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">const rowColumnCount = numCols === undefined ? dataModel.columnCount('row-header') : numCols;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; rowColumnCount; i++) {</span><span class="s3">\n            </span><span class="s1">const numCols = dataModel.rowCount('column-header');</span><span class="s3">\n            </span><span class="s1">/*</span><span class="s3">\n              </span><span class="s1">Calculate the maximum text width, across</span><span class="s3">\n              </span><span class="s1">all nested columns under a given row index.</span><span class="s3">\n            </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">let maxWidth = 0;</span><span class="s3">\n            </span><span class="s1">for (let j = 0; j &lt; numCols; j++) {</span><span class="s3">\n                </span><span class="s1">const config = DataGrid._getConfig(dataModel, j, i, 'corner-header');</span><span class="s3">\n                </span><span class="s1">const textWidth = this._getCellTextWidth(config);</span><span class="s3">\n                </span><span class="s1">maxWidth = Math.max(maxWidth, textWidth);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">/*</span><span class="s3">\n              </span><span class="s1">Send a resize message with new width for the given column.</span><span class="s3">\n              </span><span class="s1">Using a padding of 15 pixels to leave some room.</span><span class="s3">\n            </span><span class="s1">*/</span><span class="s3">\n            </span><span class="s1">this.resizeColumn('row-header', i, maxWidth + padding);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint the overlay content for the entire grid.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This is the primary overlay paint entry point. The individual</span><span class="s3">\n     </span><span class="s1">* `_draw*` methods should not be invoked directly. This method</span><span class="s3">\n     </span><span class="s1">* dispatches to the drawing methods in the correct order.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_paintOverlay() {</span><span class="s3">\n        </span><span class="s1">// Scale the overlay GC for the dpi ratio.</span><span class="s3">\n        </span><span class="s1">this._overlayGC.setTransform(this._dpiRatio, 0, 0, this._dpiRatio, 0, 0);</span><span class="s3">\n        </span><span class="s1">// Clear the overlay of all content.</span><span class="s3">\n        </span><span class="s1">this._overlayGC.clearRect(0, 0, this._overlay.width, this._overlay.height);</span><span class="s3">\n        </span><span class="s1">// Draw the body selections.</span><span class="s3">\n        </span><span class="s1">this._drawBodySelections();</span><span class="s3">\n        </span><span class="s1">// Draw the row header selections.</span><span class="s3">\n        </span><span class="s1">this._drawRowHeaderSelections();</span><span class="s3">\n        </span><span class="s1">// Draw the column header selections.</span><span class="s3">\n        </span><span class="s1">this._drawColumnHeaderSelections();</span><span class="s3">\n        </span><span class="s1">// Draw the cursor.</span><span class="s3">\n        </span><span class="s1">this._drawCursor();</span><span class="s3">\n        </span><span class="s1">// Draw the shadows.</span><span class="s3">\n        </span><span class="s1">this._drawShadows();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the void region for the dirty rect.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawVoidRegion(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Look up the void color.</span><span class="s3">\n        </span><span class="s1">let color = this._style.voidColor;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no void color.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fill the dirty rect with the void color.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">this._canvasGC.fillRect(rx, ry, rw, rh);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the body region which intersects the dirty rect.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawBodyRegion(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Get the visible content dimensions.</span><span class="s3">\n        </span><span class="s1">let contentW = this._columnSections.length - this._scrollX;</span><span class="s3">\n        </span><span class="s1">let contentH = this._rowSections.length - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no content to draw.</span><span class="s3">\n        </span><span class="s1">if (contentW &lt;= 0 || contentH &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the visible content origin.</span><span class="s3">\n        </span><span class="s1">let contentX = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let contentY = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Bail if the dirty rect does not intersect the content area.</span><span class="s3">\n        </span><span class="s1">if (rx + rw &lt;= contentX) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry + rh &lt;= contentY) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (rx &gt;= contentX + contentW) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry &gt;= contentY + contentH) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Get the upper and lower bounds of the dirty content area.</span><span class="s3">\n        </span><span class="s1">let x1 = Math.max(rx, contentX);</span><span class="s3">\n        </span><span class="s1">let y1 = Math.max(ry, contentY);</span><span class="s3">\n        </span><span class="s1">let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);</span><span class="s3">\n        </span><span class="s1">let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);</span><span class="s3">\n        </span><span class="s1">// Convert the dirty content bounds into cell bounds.</span><span class="s3">\n        </span><span class="s1">let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);</span><span class="s3">\n        </span><span class="s1">let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);</span><span class="s3">\n        </span><span class="s1">let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);</span><span class="s3">\n        </span><span class="s1">let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);</span><span class="s3">\n        </span><span class="s1">// Fetch the max row and column.</span><span class="s3">\n        </span><span class="s1">let maxRow = this._rowSections.count - 1;</span><span class="s3">\n        </span><span class="s1">let maxColumn = this._columnSections.count - 1;</span><span class="s3">\n        </span><span class="s1">// Handle a dirty content area larger than the cell count.</span><span class="s3">\n        </span><span class="s1">if (r2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">r2 = maxRow;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (c2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">c2 = maxColumn;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Convert the cell bounds back to visible coordinates.</span><span class="s3">\n        </span><span class="s1">let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;</span><span class="s3">\n        </span><span class="s1">let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Set up the paint region size variables.</span><span class="s3">\n        </span><span class="s1">let width = 0;</span><span class="s3">\n        </span><span class="s1">let height = 0;</span><span class="s3">\n        </span><span class="s1">// Allocate the section sizes arrays.</span><span class="s3">\n        </span><span class="s1">let rowSizes = new Array(r2 - r1 + 1);</span><span class="s3">\n        </span><span class="s1">let columnSizes = new Array(c2 - c1 + 1);</span><span class="s3">\n        </span><span class="s1">// Get the row sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let j = r1; j &lt;= r2; ++j) {</span><span class="s3">\n            </span><span class="s1">let size = this._rowSections.sizeOf(j);</span><span class="s3">\n            </span><span class="s1">rowSizes[j - r1] = size;</span><span class="s3">\n            </span><span class="s1">height += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the column sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let i = c1; i &lt;= c2; ++i) {</span><span class="s3">\n            </span><span class="s1">let size = this._columnSections.sizeOf(i);</span><span class="s3">\n            </span><span class="s1">columnSizes[i - c1] = size;</span><span class="s3">\n            </span><span class="s1">width += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the geometry if the last row is streched.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh &amp;&amp; r2 === maxRow) {</span><span class="s3">\n            </span><span class="s1">let dh = this.pageHeight - this.bodyHeight;</span><span class="s3">\n            </span><span class="s1">rowSizes[rowSizes.length - 1] += dh;</span><span class="s3">\n            </span><span class="s1">height += dh;</span><span class="s3">\n            </span><span class="s1">y2 += dh;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the geometry if the last column is streched.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw &amp;&amp; c2 === maxColumn) {</span><span class="s3">\n            </span><span class="s1">let dw = this.pageWidth - this.bodyWidth;</span><span class="s3">\n            </span><span class="s1">columnSizes[columnSizes.length - 1] += dw;</span><span class="s3">\n            </span><span class="s1">width += dw;</span><span class="s3">\n            </span><span class="s1">x2 += dw;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the paint region object.</span><span class="s3">\n        </span><span class="s1">let rgn = {</span><span class="s3">\n            </span><span class="s1">region: 'body',</span><span class="s3">\n            </span><span class="s1">xMin: x1,</span><span class="s3">\n            </span><span class="s1">yMin: y1,</span><span class="s3">\n            </span><span class="s1">xMax: x2,</span><span class="s3">\n            </span><span class="s1">yMax: y2,</span><span class="s3">\n            </span><span class="s1">x,</span><span class="s3">\n            </span><span class="s1">y,</span><span class="s3">\n            </span><span class="s1">width,</span><span class="s3">\n            </span><span class="s1">height,</span><span class="s3">\n            </span><span class="s1">row: r1,</span><span class="s3">\n            </span><span class="s1">column: c1,</span><span class="s3">\n            </span><span class="s1">rowSizes,</span><span class="s3">\n            </span><span class="s1">columnSizes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Draw the background.</span><span class="s3">\n        </span><span class="s1">this._drawBackground(rgn, this._style.backgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the row background.</span><span class="s3">\n        </span><span class="s1">this._drawRowBackground(rgn, this._style.rowBackgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the column background.</span><span class="s3">\n        </span><span class="s1">this._drawColumnBackground(rgn, this._style.columnBackgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the cell content for the paint region.</span><span class="s3">\n        </span><span class="s1">this._drawCells(rgn);</span><span class="s3">\n        </span><span class="s1">// Draw the horizontal grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawHorizontalGridLines(rgn, this._style.horizontalGridLineColor || this._style.gridLineColor);</span><span class="s3">\n        </span><span class="s1">// Draw the vertical grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawVerticalGridLines(rgn, this._style.verticalGridLineColor || this._style.gridLineColor);</span><span class="s3">\n        </span><span class="s1">// Get the cellgroups from the cell-region that intersects with the paint region</span><span class="s3">\n        </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.cellGroupInteresectsRegion(group, rgn);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Draw merged cells</span><span class="s3">\n        </span><span class="s1">this._paintMergedCells(cellGroups, rgn, this._style.backgroundColor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the row header region which intersects the dirty rect.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawRowHeaderRegion(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Get the visible content dimensions.</span><span class="s3">\n        </span><span class="s1">let contentW = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let contentH = this.bodyHeight - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no content to draw.</span><span class="s3">\n        </span><span class="s1">if (contentW &lt;= 0 || contentH &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the visible content origin.</span><span class="s3">\n        </span><span class="s1">let contentX = 0;</span><span class="s3">\n        </span><span class="s1">let contentY = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Bail if the dirty rect does not intersect the content area.</span><span class="s3">\n        </span><span class="s1">if (rx + rw &lt;= contentX) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry + rh &lt;= contentY) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (rx &gt;= contentX + contentW) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry &gt;= contentY + contentH) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Get the upper and lower bounds of the dirty content area.</span><span class="s3">\n        </span><span class="s1">let x1 = rx;</span><span class="s3">\n        </span><span class="s1">let y1 = Math.max(ry, contentY);</span><span class="s3">\n        </span><span class="s1">let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);</span><span class="s3">\n        </span><span class="s1">let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);</span><span class="s3">\n        </span><span class="s1">// Convert the dirty content bounds into cell bounds.</span><span class="s3">\n        </span><span class="s1">let r1 = this._rowSections.indexOf(y1 - contentY + this._scrollY);</span><span class="s3">\n        </span><span class="s1">let c1 = this._rowHeaderSections.indexOf(x1);</span><span class="s3">\n        </span><span class="s1">let r2 = this._rowSections.indexOf(y2 - contentY + this._scrollY);</span><span class="s3">\n        </span><span class="s1">let c2 = this._rowHeaderSections.indexOf(x2);</span><span class="s3">\n        </span><span class="s1">// Fetch max row and column.</span><span class="s3">\n        </span><span class="s1">let maxRow = this._rowSections.count - 1;</span><span class="s3">\n        </span><span class="s1">let maxColumn = this._rowHeaderSections.count - 1;</span><span class="s3">\n        </span><span class="s1">// Handle a dirty content area larger than the cell count.</span><span class="s3">\n        </span><span class="s1">if (r2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">r2 = maxRow;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (c2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">c2 = maxColumn;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Convert the cell bounds back to visible coordinates.</span><span class="s3">\n        </span><span class="s1">let x = this._rowHeaderSections.offsetOf(c1);</span><span class="s3">\n        </span><span class="s1">let y = this._rowSections.offsetOf(r1) + contentY - this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Set up the paint region size variables.</span><span class="s3">\n        </span><span class="s1">let width = 0;</span><span class="s3">\n        </span><span class="s1">let height = 0;</span><span class="s3">\n        </span><span class="s1">// Allocate the section sizes arrays.</span><span class="s3">\n        </span><span class="s1">let rowSizes = new Array(r2 - r1 + 1);</span><span class="s3">\n        </span><span class="s1">let columnSizes = new Array(c2 - c1 + 1);</span><span class="s3">\n        </span><span class="s1">// Get the row sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let j = r1; j &lt;= r2; ++j) {</span><span class="s3">\n            </span><span class="s1">let size = this._rowSections.sizeOf(j);</span><span class="s3">\n            </span><span class="s1">rowSizes[j - r1] = size;</span><span class="s3">\n            </span><span class="s1">height += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the column sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let i = c1; i &lt;= c2; ++i) {</span><span class="s3">\n            </span><span class="s1">let size = this._rowHeaderSections.sizeOf(i);</span><span class="s3">\n            </span><span class="s1">columnSizes[i - c1] = size;</span><span class="s3">\n            </span><span class="s1">width += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the geometry if the last row is stretched.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh &amp;&amp; r2 === maxRow) {</span><span class="s3">\n            </span><span class="s1">let dh = this.pageHeight - this.bodyHeight;</span><span class="s3">\n            </span><span class="s1">rowSizes[rowSizes.length - 1] += dh;</span><span class="s3">\n            </span><span class="s1">height += dh;</span><span class="s3">\n            </span><span class="s1">y2 += dh;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the paint region object.</span><span class="s3">\n        </span><span class="s1">let rgn = {</span><span class="s3">\n            </span><span class="s1">region: 'row-header',</span><span class="s3">\n            </span><span class="s1">xMin: x1,</span><span class="s3">\n            </span><span class="s1">yMin: y1,</span><span class="s3">\n            </span><span class="s1">xMax: x2,</span><span class="s3">\n            </span><span class="s1">yMax: y2,</span><span class="s3">\n            </span><span class="s1">x,</span><span class="s3">\n            </span><span class="s1">y,</span><span class="s3">\n            </span><span class="s1">width,</span><span class="s3">\n            </span><span class="s1">height,</span><span class="s3">\n            </span><span class="s1">row: r1,</span><span class="s3">\n            </span><span class="s1">column: c1,</span><span class="s3">\n            </span><span class="s1">rowSizes,</span><span class="s3">\n            </span><span class="s1">columnSizes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Draw the background.</span><span class="s3">\n        </span><span class="s1">this._drawBackground(rgn, this._style.headerBackgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the cell content for the paint region.</span><span class="s3">\n        </span><span class="s1">this._drawCells(rgn);</span><span class="s3">\n        </span><span class="s1">// Draw the horizontal grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||</span><span class="s3">\n            </span><span class="s1">this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Draw the vertical grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Get the cellgroups from the cell-region that intersects with the paint region</span><span class="s3">\n        </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.cellGroupInteresectsRegion(group, rgn);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Draw merged cells</span><span class="s3">\n        </span><span class="s1">this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the column header region which intersects the dirty rect.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawColumnHeaderRegion(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Get the visible content dimensions.</span><span class="s3">\n        </span><span class="s1">let contentW = this.bodyWidth - this._scrollX;</span><span class="s3">\n        </span><span class="s1">let contentH = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no content to draw.</span><span class="s3">\n        </span><span class="s1">if (contentW &lt;= 0 || contentH &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the visible content origin.</span><span class="s3">\n        </span><span class="s1">let contentX = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let contentY = 0;</span><span class="s3">\n        </span><span class="s1">// Bail if the dirty rect does not intersect the content area.</span><span class="s3">\n        </span><span class="s1">if (rx + rw &lt;= contentX) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry + rh &lt;= contentY) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (rx &gt;= contentX + contentW) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry &gt;= contentY + contentH) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Get the upper and lower bounds of the dirty content area.</span><span class="s3">\n        </span><span class="s1">let x1 = Math.max(rx, contentX);</span><span class="s3">\n        </span><span class="s1">let y1 = ry;</span><span class="s3">\n        </span><span class="s1">let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);</span><span class="s3">\n        </span><span class="s1">let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);</span><span class="s3">\n        </span><span class="s1">// Convert the dirty content bounds into cell bounds.</span><span class="s3">\n        </span><span class="s1">let r1 = this._columnHeaderSections.indexOf(y1);</span><span class="s3">\n        </span><span class="s1">let c1 = this._columnSections.indexOf(x1 - contentX + this._scrollX);</span><span class="s3">\n        </span><span class="s1">let r2 = this._columnHeaderSections.indexOf(y2);</span><span class="s3">\n        </span><span class="s1">let c2 = this._columnSections.indexOf(x2 - contentX + this._scrollX);</span><span class="s3">\n        </span><span class="s1">// Fetch the max row and column.</span><span class="s3">\n        </span><span class="s1">let maxRow = this._columnHeaderSections.count - 1;</span><span class="s3">\n        </span><span class="s1">let maxColumn = this._columnSections.count - 1;</span><span class="s3">\n        </span><span class="s1">// Handle a dirty content area larger than the cell count.</span><span class="s3">\n        </span><span class="s1">if (r2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">r2 = maxRow;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (c2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">c2 = maxColumn;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Convert the cell bounds back to visible coordinates.</span><span class="s3">\n        </span><span class="s1">let x = this._columnSections.offsetOf(c1) + contentX - this._scrollX;</span><span class="s3">\n        </span><span class="s1">let y = this._columnHeaderSections.offsetOf(r1);</span><span class="s3">\n        </span><span class="s1">// Set up the paint region size variables.</span><span class="s3">\n        </span><span class="s1">let width = 0;</span><span class="s3">\n        </span><span class="s1">let height = 0;</span><span class="s3">\n        </span><span class="s1">// Allocate the section sizes arrays.</span><span class="s3">\n        </span><span class="s1">let rowSizes = new Array(r2 - r1 + 1);</span><span class="s3">\n        </span><span class="s1">let columnSizes = new Array(c2 - c1 + 1);</span><span class="s3">\n        </span><span class="s1">// Get the row sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let j = r1; j &lt;= r2; ++j) {</span><span class="s3">\n            </span><span class="s1">let size = this._columnHeaderSections.sizeOf(j);</span><span class="s3">\n            </span><span class="s1">rowSizes[j - r1] = size;</span><span class="s3">\n            </span><span class="s1">height += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the column sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let i = c1; i &lt;= c2; ++i) {</span><span class="s3">\n            </span><span class="s1">let size = this._columnSections.sizeOf(i);</span><span class="s3">\n            </span><span class="s1">columnSizes[i - c1] = size;</span><span class="s3">\n            </span><span class="s1">width += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the geometry if the last column is stretched.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw &amp;&amp; c2 === maxColumn) {</span><span class="s3">\n            </span><span class="s1">let dw = this.pageWidth - this.bodyWidth;</span><span class="s3">\n            </span><span class="s1">columnSizes[columnSizes.length - 1] += dw;</span><span class="s3">\n            </span><span class="s1">width += dw;</span><span class="s3">\n            </span><span class="s1">x2 += dw;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the paint region object.</span><span class="s3">\n        </span><span class="s1">let rgn = {</span><span class="s3">\n            </span><span class="s1">region: 'column-header',</span><span class="s3">\n            </span><span class="s1">xMin: x1,</span><span class="s3">\n            </span><span class="s1">yMin: y1,</span><span class="s3">\n            </span><span class="s1">xMax: x2,</span><span class="s3">\n            </span><span class="s1">yMax: y2,</span><span class="s3">\n            </span><span class="s1">x,</span><span class="s3">\n            </span><span class="s1">y,</span><span class="s3">\n            </span><span class="s1">width,</span><span class="s3">\n            </span><span class="s1">height,</span><span class="s3">\n            </span><span class="s1">row: r1,</span><span class="s3">\n            </span><span class="s1">column: c1,</span><span class="s3">\n            </span><span class="s1">rowSizes,</span><span class="s3">\n            </span><span class="s1">columnSizes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Draw the background.</span><span class="s3">\n        </span><span class="s1">this._drawBackground(rgn, this._style.headerBackgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the cell content for the paint region.</span><span class="s3">\n        </span><span class="s1">this._drawCells(rgn);</span><span class="s3">\n        </span><span class="s1">// Draw the horizontal grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||</span><span class="s3">\n            </span><span class="s1">this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Draw the vertical grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Get the cellgroups from the cell-region that intersects with the paint region</span><span class="s3">\n        </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.cellGroupInteresectsRegion(group, rgn);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Draw merged cells</span><span class="s3">\n        </span><span class="s1">this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the corner header region which intersects the dirty rect.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawCornerHeaderRegion(rx, ry, rw, rh) {</span><span class="s3">\n        </span><span class="s1">// Get the visible content dimensions.</span><span class="s3">\n        </span><span class="s1">let contentW = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let contentH = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Bail if there is no content to draw.</span><span class="s3">\n        </span><span class="s1">if (contentW &lt;= 0 || contentH &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the visible content origin.</span><span class="s3">\n        </span><span class="s1">let contentX = 0;</span><span class="s3">\n        </span><span class="s1">let contentY = 0;</span><span class="s3">\n        </span><span class="s1">// Bail if the dirty rect does not intersect the content area.</span><span class="s3">\n        </span><span class="s1">if (rx + rw &lt;= contentX) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry + rh &lt;= contentY) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (rx &gt;= contentX + contentW) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ry &gt;= contentY + contentH) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the upper and lower bounds of the dirty content area.</span><span class="s3">\n        </span><span class="s1">let x1 = rx;</span><span class="s3">\n        </span><span class="s1">let y1 = ry;</span><span class="s3">\n        </span><span class="s1">let x2 = Math.min(rx + rw - 1, contentX + contentW - 1);</span><span class="s3">\n        </span><span class="s1">let y2 = Math.min(ry + rh - 1, contentY + contentH - 1);</span><span class="s3">\n        </span><span class="s1">// Convert the dirty content bounds into cell bounds.</span><span class="s3">\n        </span><span class="s1">let r1 = this._columnHeaderSections.indexOf(y1);</span><span class="s3">\n        </span><span class="s1">let c1 = this._rowHeaderSections.indexOf(x1);</span><span class="s3">\n        </span><span class="s1">let r2 = this._columnHeaderSections.indexOf(y2);</span><span class="s3">\n        </span><span class="s1">let c2 = this._rowHeaderSections.indexOf(x2);</span><span class="s3">\n        </span><span class="s1">// Handle a dirty content area larger than the cell count.</span><span class="s3">\n        </span><span class="s1">if (r2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">r2 = this._columnHeaderSections.count - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (c2 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">c2 = this._rowHeaderSections.count - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Convert the cell bounds back to visible coordinates.</span><span class="s3">\n        </span><span class="s1">let x = this._rowHeaderSections.offsetOf(c1);</span><span class="s3">\n        </span><span class="s1">let y = this._columnHeaderSections.offsetOf(r1);</span><span class="s3">\n        </span><span class="s1">// Set up the paint region size variables.</span><span class="s3">\n        </span><span class="s1">let width = 0;</span><span class="s3">\n        </span><span class="s1">let height = 0;</span><span class="s3">\n        </span><span class="s1">// Allocate the section sizes arrays.</span><span class="s3">\n        </span><span class="s1">let rowSizes = new Array(r2 - r1 + 1);</span><span class="s3">\n        </span><span class="s1">let columnSizes = new Array(c2 - c1 + 1);</span><span class="s3">\n        </span><span class="s1">// Get the row sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let j = r1; j &lt;= r2; ++j) {</span><span class="s3">\n            </span><span class="s1">let size = this._columnHeaderSections.sizeOf(j);</span><span class="s3">\n            </span><span class="s1">rowSizes[j - r1] = size;</span><span class="s3">\n            </span><span class="s1">height += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Get the column sizes for the region.</span><span class="s3">\n        </span><span class="s1">for (let i = c1; i &lt;= c2; ++i) {</span><span class="s3">\n            </span><span class="s1">let size = this._rowHeaderSections.sizeOf(i);</span><span class="s3">\n            </span><span class="s1">columnSizes[i - c1] = size;</span><span class="s3">\n            </span><span class="s1">width += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the paint region object.</span><span class="s3">\n        </span><span class="s1">let rgn = {</span><span class="s3">\n            </span><span class="s1">region: 'corner-header',</span><span class="s3">\n            </span><span class="s1">xMin: x1,</span><span class="s3">\n            </span><span class="s1">yMin: y1,</span><span class="s3">\n            </span><span class="s1">xMax: x2,</span><span class="s3">\n            </span><span class="s1">yMax: y2,</span><span class="s3">\n            </span><span class="s1">x,</span><span class="s3">\n            </span><span class="s1">y,</span><span class="s3">\n            </span><span class="s1">width,</span><span class="s3">\n            </span><span class="s1">height,</span><span class="s3">\n            </span><span class="s1">row: r1,</span><span class="s3">\n            </span><span class="s1">column: c1,</span><span class="s3">\n            </span><span class="s1">rowSizes,</span><span class="s3">\n            </span><span class="s1">columnSizes</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// Draw the background.</span><span class="s3">\n        </span><span class="s1">this._drawBackground(rgn, this._style.headerBackgroundColor);</span><span class="s3">\n        </span><span class="s1">// Draw the cell content for the paint region.</span><span class="s3">\n        </span><span class="s1">this._drawCells(rgn);</span><span class="s3">\n        </span><span class="s1">// Draw the horizontal grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawHorizontalGridLines(rgn, this._style.headerHorizontalGridLineColor ||</span><span class="s3">\n            </span><span class="s1">this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Draw the vertical grid lines.</span><span class="s3">\n        </span><span class="s1">this._drawVerticalGridLines(rgn, this._style.headerVerticalGridLineColor || this._style.headerGridLineColor);</span><span class="s3">\n        </span><span class="s1">// Get the cellgroups from the cell-region that intersects with the paint region</span><span class="s3">\n        </span><span class="s1">const cellGroups = CellGroup.getCellGroupsAtRegion(this.dataModel, rgn.region).filter(group =&gt; {</span><span class="s3">\n            </span><span class="s1">return this.cellGroupInteresectsRegion(group, rgn);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Draw merged cells</span><span class="s3">\n        </span><span class="s1">this._paintMergedCells(cellGroups, rgn, this._style.headerBackgroundColor);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the background for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawBackground(rgn, color) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Unpack the region.</span><span class="s3">\n        </span><span class="s1">let { xMin, yMin, xMax, yMax } = rgn;</span><span class="s3">\n        </span><span class="s1">// Fill the region with the specified color.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">this._canvasGC.fillRect(xMin, yMin, xMax - xMin + 1, yMax - yMin + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the row background for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawRowBackground(rgn, colorFn) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no color function.</span><span class="s3">\n        </span><span class="s1">if (!colorFn) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the X bounds for the row.</span><span class="s3">\n        </span><span class="s1">let x1 = Math.max(rgn.xMin, rgn.x);</span><span class="s3">\n        </span><span class="s1">let x2 = Math.min(rgn.x + rgn.width - 1, rgn.xMax);</span><span class="s3">\n        </span><span class="s1">// Draw the background for the rows in the region.</span><span class="s3">\n        </span><span class="s1">for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j &lt; n; ++j) {</span><span class="s3">\n            </span><span class="s1">// Fetch the size of the row.</span><span class="s3">\n            </span><span class="s1">let size = rgn.rowSizes[j];</span><span class="s3">\n            </span><span class="s1">// Skip zero sized rows.</span><span class="s3">\n            </span><span class="s1">if (size === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get the background color for the row.</span><span class="s3">\n            </span><span class="s1">let color = colorFn(rgn.row + j);</span><span class="s3">\n            </span><span class="s1">// Fill the row with the background color if needed.</span><span class="s3">\n            </span><span class="s1">if (color) {</span><span class="s3">\n                </span><span class="s1">let y1 = Math.max(rgn.yMin, y);</span><span class="s3">\n                </span><span class="s1">let y2 = Math.min(y + size - 1, rgn.yMax);</span><span class="s3">\n                </span><span class="s1">this._canvasGC.fillStyle = color;</span><span class="s3">\n                </span><span class="s1">this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Increment the running Y coordinate.</span><span class="s3">\n            </span><span class="s1">y += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the column background for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawColumnBackground(rgn, colorFn) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no color function.</span><span class="s3">\n        </span><span class="s1">if (!colorFn) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the Y bounds for the column.</span><span class="s3">\n        </span><span class="s1">let y1 = Math.max(rgn.yMin, rgn.y);</span><span class="s3">\n        </span><span class="s1">let y2 = Math.min(rgn.y + rgn.height - 1, rgn.yMax);</span><span class="s3">\n        </span><span class="s1">// Draw the background for the columns in the region.</span><span class="s3">\n        </span><span class="s1">for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">// Fetch the size of the column.</span><span class="s3">\n            </span><span class="s1">let size = rgn.columnSizes[i];</span><span class="s3">\n            </span><span class="s1">// Skip zero sized columns.</span><span class="s3">\n            </span><span class="s1">if (size === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get the background color for the column.</span><span class="s3">\n            </span><span class="s1">let color = colorFn(rgn.column + i);</span><span class="s3">\n            </span><span class="s1">// Fill the column with the background color if needed.</span><span class="s3">\n            </span><span class="s1">if (color) {</span><span class="s3">\n                </span><span class="s1">let x1 = Math.max(rgn.xMin, x);</span><span class="s3">\n                </span><span class="s1">let x2 = Math.min(x + size - 1, rgn.xMax);</span><span class="s3">\n                </span><span class="s1">this._canvasGC.fillStyle = color;</span><span class="s3">\n                </span><span class="s1">this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Increment the running X coordinate.</span><span class="s3">\n            </span><span class="s1">x += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns column size</span><span class="s3">\n     </span><span class="s1">* @param region</span><span class="s3">\n     </span><span class="s1">* @param index</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_getColumnSize(region, index) {</span><span class="s3">\n        </span><span class="s1">if (region === 'corner-header') {</span><span class="s3">\n            </span><span class="s1">return this._rowHeaderSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.columnSize(region, index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Returns row size</span><span class="s3">\n     </span><span class="s1">* @param region</span><span class="s3">\n     </span><span class="s1">* @param index</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_getRowSize(region, index) {</span><span class="s3">\n        </span><span class="s1">if (region === 'corner-header') {</span><span class="s3">\n            </span><span class="s1">return this._columnHeaderSections.sizeOf(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.rowSize(region, index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the cells for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawCells(rgn) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no data model.</span><span class="s3">\n        </span><span class="s1">if (!this._dataModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set up the cell config object for rendering.</span><span class="s3">\n        </span><span class="s1">let config = {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: 0,</span><span class="s3">\n            </span><span class="s1">width: 0,</span><span class="s3">\n            </span><span class="s1">height: 0,</span><span class="s3">\n            </span><span class="s1">region: rgn.region,</span><span class="s3">\n            </span><span class="s1">row: 0,</span><span class="s3">\n            </span><span class="s1">column: 0,</span><span class="s3">\n            </span><span class="s1">value: null,</span><span class="s3">\n            </span><span class="s1">metadata: DataModel.emptyMetadata</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">let groupIndex = -1;</span><span class="s3">\n        </span><span class="s1">// Save the buffer gc before wrapping.</span><span class="s3">\n        </span><span class="s1">this._bufferGC.save();</span><span class="s3">\n        </span><span class="s1">// Wrap the buffer gc for painting the cells.</span><span class="s3">\n        </span><span class="s1">let gc = new GraphicsContext(this._bufferGC);</span><span class="s3">\n        </span><span class="s1">let height = 0;</span><span class="s3">\n        </span><span class="s1">// Loop over the columns in the region.</span><span class="s3">\n        </span><span class="s1">for (let x = rgn.x, i = 0, n = rgn.columnSizes.length; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">// Fetch the size of the column.</span><span class="s3">\n            </span><span class="s1">let width = rgn.columnSizes[i];</span><span class="s3">\n            </span><span class="s1">// Skip zero sized columns.</span><span class="s3">\n            </span><span class="s1">if (width === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Compute the column index.</span><span class="s3">\n            </span><span class="s1">let column = rgn.column + i;</span><span class="s3">\n            </span><span class="s1">// Update the config for the current column.</span><span class="s3">\n            </span><span class="s1">config.x = x;</span><span class="s3">\n            </span><span class="s1">config.width = width;</span><span class="s3">\n            </span><span class="s1">config.column = column;</span><span class="s3">\n            </span><span class="s1">// Loop over the rows in the column.</span><span class="s3">\n            </span><span class="s1">for (let y = rgn.y, j = 0, n = rgn.rowSizes.length; j &lt; n; ++j) {</span><span class="s3">\n                </span><span class="s1">// Fetch the size of the row.</span><span class="s3">\n                </span><span class="s1">height = rgn.rowSizes[j];</span><span class="s3">\n                </span><span class="s1">// Skip zero sized rows.</span><span class="s3">\n                </span><span class="s1">if (height === 0) {</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Compute the row index.</span><span class="s3">\n                </span><span class="s1">let row = rgn.row + j;</span><span class="s3">\n                </span><span class="s1">groupIndex = CellGroup.getGroupIndex(this.dataModel, config.region, row, column);</span><span class="s3">\n                </span><span class="s1">// For merged cell regions, don't do anything, we draw merged regions later.</span><span class="s3">\n                </span><span class="s1">if (groupIndex !== -1) {</span><span class="s3">\n                    </span><span class="s1">y += height;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Clear the buffer rect for the cell.</span><span class="s3">\n                </span><span class="s1">gc.clearRect(x, y, width, height);</span><span class="s3">\n                </span><span class="s1">let value = DataGrid._getCellValue(this.dataModel, rgn.region, row, column);</span><span class="s3">\n                </span><span class="s1">let metadata = DataGrid._getCellMetadata(this.dataModel, rgn.region, row, column);</span><span class="s3">\n                </span><span class="s1">// Update the config for the current cell.</span><span class="s3">\n                </span><span class="s1">config.y = y;</span><span class="s3">\n                </span><span class="s1">config.height = height;</span><span class="s3">\n                </span><span class="s1">config.width = width;</span><span class="s3">\n                </span><span class="s1">config.row = row;</span><span class="s3">\n                </span><span class="s1">config.value = value;</span><span class="s3">\n                </span><span class="s1">config.metadata = metadata;</span><span class="s3">\n                </span><span class="s1">// Get the renderer for the cell.</span><span class="s3">\n                </span><span class="s1">let renderer = this._cellRenderers.get(config);</span><span class="s3">\n                </span><span class="s1">// Save the GC state.</span><span class="s3">\n                </span><span class="s1">gc.save();</span><span class="s3">\n                </span><span class="s1">// Paint the cell into the off-screen buffer.</span><span class="s3">\n                </span><span class="s1">try {</span><span class="s3">\n                    </span><span class="s1">if (renderer instanceof AsyncCellRenderer) {</span><span class="s3">\n                        </span><span class="s1">if (renderer.isReady(config)) {</span><span class="s3">\n                            </span><span class="s1">renderer.paint(gc, config);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">renderer.paintPlaceholder(gc, config);</span><span class="s3">\n                            </span><span class="s1">renderer.load(config).then(() =&gt; {</span><span class="s3">\n                                </span><span class="s1">const r1 = row;</span><span class="s3">\n                                </span><span class="s1">const r2 = row + 1;</span><span class="s3">\n                                </span><span class="s1">const c1 = column;</span><span class="s3">\n                                </span><span class="s1">const c2 = column + 1;</span><span class="s3">\n                                </span><span class="s1">this.repaintRegion(rgn.region, r1, c1, r2, c2);</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">renderer.paint(gc, config);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">catch (err) {</span><span class="s3">\n                    </span><span class="s1">console.error(err);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Restore the GC state.</span><span class="s3">\n                </span><span class="s1">gc.restore();</span><span class="s3">\n                </span><span class="s1">// Compute the actual X bounds for the cell.</span><span class="s3">\n                </span><span class="s1">let x1 = Math.max(rgn.xMin, config.x);</span><span class="s3">\n                </span><span class="s1">let x2 = Math.min(config.x + config.width - 1, rgn.xMax);</span><span class="s3">\n                </span><span class="s1">// Compute the actual Y bounds for the cell.</span><span class="s3">\n                </span><span class="s1">let y1 = Math.max(rgn.yMin, config.y);</span><span class="s3">\n                </span><span class="s1">let y2 = Math.min(config.y + config.height - 1, rgn.yMax);</span><span class="s3">\n                </span><span class="s1">this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);</span><span class="s3">\n                </span><span class="s1">// Increment the running Y coordinate.</span><span class="s3">\n                </span><span class="s1">y += height;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Restore the GC state.</span><span class="s3">\n            </span><span class="s1">gc.restore();</span><span class="s3">\n            </span><span class="s1">// Increment the running X coordinate.</span><span class="s3">\n            </span><span class="s1">x += width;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Dispose of the wrapped gc.</span><span class="s3">\n        </span><span class="s1">gc.dispose();</span><span class="s3">\n        </span><span class="s1">// Restore the final buffer gc state.</span><span class="s3">\n        </span><span class="s1">this._bufferGC.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// TODO Move this in the utils file (but we need the PaintRegion typing)</span><span class="s3">\n    </span><span class="s1">cellGroupInteresectsRegion(group, rgn) {</span><span class="s3">\n        </span><span class="s1">const rgnR1 = rgn.row;</span><span class="s3">\n        </span><span class="s1">const rgnR2 = rgn.row + rgn.rowSizes.length;</span><span class="s3">\n        </span><span class="s1">const rgnC1 = rgn.column;</span><span class="s3">\n        </span><span class="s1">const rgnC2 = rgn.column + rgn.columnSizes.length;</span><span class="s3">\n        </span><span class="s1">const dx = Math.min(group.r2, rgnR2) - Math.max(group.r1, rgnR1);</span><span class="s3">\n        </span><span class="s1">const dy = Math.min(group.c2, rgnC2) - Math.max(group.c1, rgnC1);</span><span class="s3">\n        </span><span class="s1">return dx &gt;= 0 &amp;&amp; dy &gt;= 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static _getCellValue(dm, region, row, col) {</span><span class="s3">\n        </span><span class="s1">// Get the value for the cell.</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return dm.data(region, row, col);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">console.error(err);</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static _getCellMetadata(dm, region, row, col) {</span><span class="s3">\n        </span><span class="s1">// Get the metadata for the cell.</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return dm.metadata(region, row, col);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">catch (err) {</span><span class="s3">\n            </span><span class="s1">console.error(err);</span><span class="s3">\n            </span><span class="s1">return DataModel.emptyMetadata;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint group cells.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_paintMergedCells(cellGroups, rgn, backgroundColor) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no data model.</span><span class="s3">\n        </span><span class="s1">if (!this._dataModel) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set up the cell config object for rendering.</span><span class="s3">\n        </span><span class="s1">let config = {</span><span class="s3">\n            </span><span class="s1">x: 0,</span><span class="s3">\n            </span><span class="s1">y: 0,</span><span class="s3">\n            </span><span class="s1">width: 0,</span><span class="s3">\n            </span><span class="s1">height: 0,</span><span class="s3">\n            </span><span class="s1">region: rgn.region,</span><span class="s3">\n            </span><span class="s1">row: 0,</span><span class="s3">\n            </span><span class="s1">column: 0,</span><span class="s3">\n            </span><span class="s1">value: null,</span><span class="s3">\n            </span><span class="s1">metadata: DataModel.emptyMetadata</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (backgroundColor) {</span><span class="s3">\n            </span><span class="s1">this._canvasGC.fillStyle = backgroundColor;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set the line width for the grid lines.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">// Save the buffer gc before wrapping.</span><span class="s3">\n        </span><span class="s1">this._bufferGC.save();</span><span class="s3">\n        </span><span class="s1">// Wrap the buffer gc for painting the cells.</span><span class="s3">\n        </span><span class="s1">let gc = new GraphicsContext(this._bufferGC);</span><span class="s3">\n        </span><span class="s1">for (const group of cellGroups) {</span><span class="s3">\n            </span><span class="s1">let width = 0;</span><span class="s3">\n            </span><span class="s1">for (let c = group.c1; c &lt;= group.c2; c++) {</span><span class="s3">\n                </span><span class="s1">width += this._getColumnSize(rgn.region, c);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let height = 0;</span><span class="s3">\n            </span><span class="s1">for (let r = group.r1; r &lt;= group.r2; r++) {</span><span class="s3">\n                </span><span class="s1">height += this._getRowSize(rgn.region, r);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let value = DataGrid._getCellValue(this.dataModel, rgn.region, group.r1, group.c1);</span><span class="s3">\n            </span><span class="s1">let metadata = DataGrid._getCellMetadata(this.dataModel, rgn.region, group.r1, group.c2);</span><span class="s3">\n            </span><span class="s1">let x = 0;</span><span class="s3">\n            </span><span class="s1">let y = 0;</span><span class="s3">\n            </span><span class="s1">switch (rgn.region) {</span><span class="s3">\n                </span><span class="s1">case 'body':</span><span class="s3">\n                    </span><span class="s1">x =</span><span class="s3">\n                        </span><span class="s1">this._columnSections.offsetOf(group.c1) +</span><span class="s3">\n                            </span><span class="s1">this.headerWidth -</span><span class="s3">\n                            </span><span class="s1">this._scrollX;</span><span class="s3">\n                    </span><span class="s1">y =</span><span class="s3">\n                        </span><span class="s1">this._rowSections.offsetOf(group.r1) +</span><span class="s3">\n                            </span><span class="s1">this.headerHeight -</span><span class="s3">\n                            </span><span class="s1">this._scrollY;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'column-header':</span><span class="s3">\n                    </span><span class="s1">x =</span><span class="s3">\n                        </span><span class="s1">this._columnSections.offsetOf(group.c1) +</span><span class="s3">\n                            </span><span class="s1">this.headerWidth -</span><span class="s3">\n                            </span><span class="s1">this._scrollX;</span><span class="s3">\n                    </span><span class="s1">y = this._rowSections.offsetOf(group.r1);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'row-header':</span><span class="s3">\n                    </span><span class="s1">x = this._columnSections.offsetOf(group.c1);</span><span class="s3">\n                    </span><span class="s1">y =</span><span class="s3">\n                        </span><span class="s1">this._rowSections.offsetOf(group.r1) +</span><span class="s3">\n                            </span><span class="s1">this.headerHeight -</span><span class="s3">\n                            </span><span class="s1">this._scrollY;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">case 'corner-header':</span><span class="s3">\n                    </span><span class="s1">x = this._columnSections.offsetOf(group.c1);</span><span class="s3">\n                    </span><span class="s1">y = this._rowSections.offsetOf(group.r1);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">config.x = x;</span><span class="s3">\n            </span><span class="s1">config.y = y;</span><span class="s3">\n            </span><span class="s1">config.width = width;</span><span class="s3">\n            </span><span class="s1">config.height = height;</span><span class="s3">\n            </span><span class="s1">config.region = rgn.region;</span><span class="s3">\n            </span><span class="s1">config.row = group.r1;</span><span class="s3">\n            </span><span class="s1">config.column = group.c1;</span><span class="s3">\n            </span><span class="s1">config.value = value;</span><span class="s3">\n            </span><span class="s1">config.metadata = metadata;</span><span class="s3">\n            </span><span class="s1">// Compute the actual X bounds for the cell.</span><span class="s3">\n            </span><span class="s1">const x1 = Math.max(rgn.xMin, x);</span><span class="s3">\n            </span><span class="s1">const x2 = Math.min(x + width - 2, rgn.xMax);</span><span class="s3">\n            </span><span class="s1">// Compute the actual Y bounds for the cell.</span><span class="s3">\n            </span><span class="s1">const y1 = Math.max(rgn.yMin, y);</span><span class="s3">\n            </span><span class="s1">const y2 = Math.min(y + height - 2, rgn.yMax);</span><span class="s3">\n            </span><span class="s1">if (x2 &lt;= x1 || y2 &lt;= y1) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Draw the background.</span><span class="s3">\n            </span><span class="s1">if (backgroundColor) {</span><span class="s3">\n                </span><span class="s1">this._canvasGC.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get the renderer for the cell.</span><span class="s3">\n            </span><span class="s1">let renderer = this._cellRenderers.get(config);</span><span class="s3">\n            </span><span class="s1">// Clear the buffer rect for the cell.</span><span class="s3">\n            </span><span class="s1">gc.clearRect(config.x, config.y, width, height);</span><span class="s3">\n            </span><span class="s1">// Save the GC state.</span><span class="s3">\n            </span><span class="s1">gc.save();</span><span class="s3">\n            </span><span class="s1">// Paint the cell into the off-screen buffer.</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">if (renderer instanceof AsyncCellRenderer) {</span><span class="s3">\n                    </span><span class="s1">if (renderer.isReady(config)) {</span><span class="s3">\n                        </span><span class="s1">renderer.paint(gc, config);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">renderer.paintPlaceholder(gc, config);</span><span class="s3">\n                        </span><span class="s1">const r1 = group.r1;</span><span class="s3">\n                        </span><span class="s1">const r2 = group.r2;</span><span class="s3">\n                        </span><span class="s1">const c1 = group.c1;</span><span class="s3">\n                        </span><span class="s1">const c2 = group.c2;</span><span class="s3">\n                        </span><span class="s1">renderer.load(config).then(() =&gt; {</span><span class="s3">\n                            </span><span class="s1">this.repaintRegion(rgn.region, r1, c1, r2, c2);</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">renderer.paint(gc, config);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (err) {</span><span class="s3">\n                </span><span class="s1">console.error(err);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Restore the GC state.</span><span class="s3">\n            </span><span class="s1">gc.restore();</span><span class="s3">\n            </span><span class="s1">this._blitContent(this._buffer, x1, y1, x2 - x1 + 1, y2 - y1 + 1, x1, y1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Dispose of the wrapped gc.</span><span class="s3">\n        </span><span class="s1">gc.dispose();</span><span class="s3">\n        </span><span class="s1">// Restore the final buffer gc state.</span><span class="s3">\n        </span><span class="s1">this._bufferGC.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the horizontal grid lines for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawHorizontalGridLines(rgn, color) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the X bounds for the horizontal lines.</span><span class="s3">\n        </span><span class="s1">const x1 = Math.max(rgn.xMin, rgn.x);</span><span class="s3">\n        </span><span class="s1">const x2 = Math.min(rgn.x + rgn.width, rgn.xMax + 1);</span><span class="s3">\n        </span><span class="s1">// Begin the path for the grid lines.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.beginPath();</span><span class="s3">\n        </span><span class="s1">// Set the line width for the grid lines.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">const bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">const ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the number of grid lines to be drawn.</span><span class="s3">\n        </span><span class="s1">let n = rgn.rowSizes.length;</span><span class="s3">\n        </span><span class="s1">// Adjust the count down if the last line shouldn't be drawn.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh) {</span><span class="s3">\n            </span><span class="s1">if (rgn.row + n === this._rowSections.count) {</span><span class="s3">\n                </span><span class="s1">n -= 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the horizontal grid lines.</span><span class="s3">\n        </span><span class="s1">for (let y = rgn.y, j = 0; j &lt; n; ++j) {</span><span class="s3">\n            </span><span class="s1">// Fetch the size of the row.</span><span class="s3">\n            </span><span class="s1">let size = rgn.rowSizes[j];</span><span class="s3">\n            </span><span class="s1">// Skip zero sized rows.</span><span class="s3">\n            </span><span class="s1">if (size === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Compute the Y position of the line.</span><span class="s3">\n            </span><span class="s1">let pos = y + size - 1;</span><span class="s3">\n            </span><span class="s1">// Draw the line if it's in range of the dirty rect.</span><span class="s3">\n            </span><span class="s1">if (pos &gt;= rgn.yMin &amp;&amp; pos &lt;= rgn.yMax) {</span><span class="s3">\n                </span><span class="s1">this._canvasGC.moveTo(x1, pos + 0.5);</span><span class="s3">\n                </span><span class="s1">this._canvasGC.lineTo(x2, pos + 0.5);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Increment the running Y coordinate.</span><span class="s3">\n            </span><span class="s1">y += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stroke the lines with the specified color.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.strokeStyle = color;</span><span class="s3">\n        </span><span class="s1">this._canvasGC.stroke();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the vertical grid lines for the given paint region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawVerticalGridLines(rgn, color) {</span><span class="s3">\n        </span><span class="s1">// Bail if there is no color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Compute the Y bounds for the vertical lines.</span><span class="s3">\n        </span><span class="s1">const y1 = Math.max(rgn.yMin, rgn.y);</span><span class="s3">\n        </span><span class="s1">const y2 = Math.min(rgn.y + rgn.height, rgn.yMax + 1);</span><span class="s3">\n        </span><span class="s1">// Begin the path for the grid lines</span><span class="s3">\n        </span><span class="s1">this._canvasGC.beginPath();</span><span class="s3">\n        </span><span class="s1">// Set the line width for the grid lines.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">// Fetch the geometry.</span><span class="s3">\n        </span><span class="s1">const bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">const pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">// Fetch the number of grid lines to be drawn.</span><span class="s3">\n        </span><span class="s1">let n = rgn.columnSizes.length;</span><span class="s3">\n        </span><span class="s1">// Adjust the count down if the last line shouldn't be drawn.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw) {</span><span class="s3">\n            </span><span class="s1">if (rgn.column + n === this._columnSections.count) {</span><span class="s3">\n                </span><span class="s1">n -= 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the vertical grid lines.</span><span class="s3">\n        </span><span class="s1">for (let x = rgn.x, i = 0; i &lt; n; ++i) {</span><span class="s3">\n            </span><span class="s1">// Fetch the size of the column.</span><span class="s3">\n            </span><span class="s1">let size = rgn.columnSizes[i];</span><span class="s3">\n            </span><span class="s1">// Skip zero sized columns.</span><span class="s3">\n            </span><span class="s1">if (size === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Compute the X position of the line.</span><span class="s3">\n            </span><span class="s1">let pos = x + size - 1;</span><span class="s3">\n            </span><span class="s1">// Draw the line if it's in range of the dirty rect.</span><span class="s3">\n            </span><span class="s1">if (pos &gt;= rgn.xMin &amp;&amp; pos &lt;= rgn.xMax) {</span><span class="s3">\n                </span><span class="s1">this._canvasGC.moveTo(pos + 0.5, y1);</span><span class="s3">\n                </span><span class="s1">this._canvasGC.lineTo(pos + 0.5, y2);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Increment the running X coordinate.</span><span class="s3">\n            </span><span class="s1">x += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stroke the lines with the specified color.</span><span class="s3">\n        </span><span class="s1">this._canvasGC.strokeStyle = color;</span><span class="s3">\n        </span><span class="s1">this._canvasGC.stroke();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the body selections for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawBodySelections() {</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = this._selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections.</span><span class="s3">\n        </span><span class="s1">if (!model || model.isEmpty) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection colors.</span><span class="s3">\n        </span><span class="s1">let fill = this._style.selectionFillColor;</span><span class="s3">\n        </span><span class="s1">let stroke = this._style.selectionBorderColor;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to draw.</span><span class="s3">\n        </span><span class="s1">if (!fill &amp;&amp; !stroke) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the scroll geometry.</span><span class="s3">\n        </span><span class="s1">let sx = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let sy = this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Get the first visible cell of the grid.</span><span class="s3">\n        </span><span class="s1">let r1 = this._rowSections.indexOf(sy);</span><span class="s3">\n        </span><span class="s1">let c1 = this._columnSections.indexOf(sx);</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no visible cells.</span><span class="s3">\n        </span><span class="s1">if (r1 &lt; 0 || c1 &lt; 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the extra geometry.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Get the last visible cell of the grid.</span><span class="s3">\n        </span><span class="s1">let r2 = this._rowSections.indexOf(sy + ph);</span><span class="s3">\n        </span><span class="s1">let c2 = this._columnSections.indexOf(sx + pw);</span><span class="s3">\n        </span><span class="s1">// Fetch the max row and column.</span><span class="s3">\n        </span><span class="s1">let maxRow = this._rowSections.count - 1;</span><span class="s3">\n        </span><span class="s1">let maxColumn = this._columnSections.count - 1;</span><span class="s3">\n        </span><span class="s1">// Clamp the last cell if the void space is visible.</span><span class="s3">\n        </span><span class="s1">r2 = r2 &lt; 0 ? maxRow : r2;</span><span class="s3">\n        </span><span class="s1">c2 = c2 &lt; 0 ? maxColumn : c2;</span><span class="s3">\n        </span><span class="s1">// Fetch the overlay gc.</span><span class="s3">\n        </span><span class="s1">let gc = this._overlayGC;</span><span class="s3">\n        </span><span class="s1">// Save the gc state.</span><span class="s3">\n        </span><span class="s1">gc.save();</span><span class="s3">\n        </span><span class="s1">// Set up the body clipping rect.</span><span class="s3">\n        </span><span class="s1">gc.beginPath();</span><span class="s3">\n        </span><span class="s1">gc.rect(hw, hh, pw, ph);</span><span class="s3">\n        </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">// Set up the gc style.</span><span class="s3">\n        </span><span class="s1">if (fill) {</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = fill;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (stroke) {</span><span class="s3">\n            </span><span class="s1">gc.strokeStyle = stroke;</span><span class="s3">\n            </span><span class="s1">gc.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Iterate over the selections.</span><span class="s3">\n        </span><span class="s1">for (let s of model.selections()) {</span><span class="s3">\n            </span><span class="s1">// Skip the section if it's not visible.</span><span class="s3">\n            </span><span class="s1">if (s.r1 &lt; r1 &amp;&amp; s.r2 &lt; r1) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (s.r1 &gt; r2 &amp;&amp; s.r2 &gt; r2) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (s.c1 &lt; c1 &amp;&amp; s.c2 &lt; c1) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (s.c1 &gt; c2 &amp;&amp; s.c2 &gt; c2) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Clamp the cell to the model bounds.</span><span class="s3">\n            </span><span class="s1">let sr1 = Math.max(0, Math.min(s.r1, maxRow));</span><span class="s3">\n            </span><span class="s1">let sc1 = Math.max(0, Math.min(s.c1, maxColumn));</span><span class="s3">\n            </span><span class="s1">let sr2 = Math.max(0, Math.min(s.r2, maxRow));</span><span class="s3">\n            </span><span class="s1">let sc2 = Math.max(0, Math.min(s.c2, maxColumn));</span><span class="s3">\n            </span><span class="s1">// Swap index order if needed.</span><span class="s3">\n            </span><span class="s1">let tmp;</span><span class="s3">\n            </span><span class="s1">if (sr1 &gt; sr2) {</span><span class="s3">\n                </span><span class="s1">tmp = sr1;</span><span class="s3">\n                </span><span class="s1">sr1 = sr2;</span><span class="s3">\n                </span><span class="s1">sr2 = tmp;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (sc1 &gt; sc2) {</span><span class="s3">\n                </span><span class="s1">tmp = sc1;</span><span class="s3">\n                </span><span class="s1">sc1 = sc2;</span><span class="s3">\n                </span><span class="s1">sc2 = tmp;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(this.dataModel, { r1: sr1, r2: sr2, c1: sc1, c2: sc2 }, 'body');</span><span class="s3">\n            </span><span class="s1">sr1 = joinedGroup.r1;</span><span class="s3">\n            </span><span class="s1">sr2 = joinedGroup.r2;</span><span class="s3">\n            </span><span class="s1">sc1 = joinedGroup.c1;</span><span class="s3">\n            </span><span class="s1">sc2 = joinedGroup.c2;</span><span class="s3">\n            </span><span class="s1">// Convert to pixel coordinates.</span><span class="s3">\n            </span><span class="s1">let x1 = this._columnSections.offsetOf(sc1) - sx + hw;</span><span class="s3">\n            </span><span class="s1">let y1 = this._rowSections.offsetOf(sr1) - sy + hh;</span><span class="s3">\n            </span><span class="s1">let x2 = this._columnSections.extentOf(sc2) - sx + hw;</span><span class="s3">\n            </span><span class="s1">let y2 = this._rowSections.extentOf(sr2) - sy + hh;</span><span class="s3">\n            </span><span class="s1">// Adjust the trailing X coordinate for column stretch.</span><span class="s3">\n            </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw &amp;&amp; sc2 === maxColumn) {</span><span class="s3">\n                </span><span class="s1">x2 = hw + pw - 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Adjust the trailing Y coordinate for row stretch.</span><span class="s3">\n            </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh &amp;&amp; sr2 === maxRow) {</span><span class="s3">\n                </span><span class="s1">y2 = hh + ph - 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Clamp the bounds to just outside of the clipping rect.</span><span class="s3">\n            </span><span class="s1">x1 = Math.max(hw - 1, x1);</span><span class="s3">\n            </span><span class="s1">y1 = Math.max(hh - 1, y1);</span><span class="s3">\n            </span><span class="s1">x2 = Math.min(hw + pw + 1, x2);</span><span class="s3">\n            </span><span class="s1">y2 = Math.min(hh + ph + 1, y2);</span><span class="s3">\n            </span><span class="s1">// Skip zero sized ranges.</span><span class="s3">\n            </span><span class="s1">if (x2 &lt; x1 || y2 &lt; y1) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Fill the rect if needed.</span><span class="s3">\n            </span><span class="s1">if (fill) {</span><span class="s3">\n                </span><span class="s1">gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Stroke the rect if needed.</span><span class="s3">\n            </span><span class="s1">if (stroke) {</span><span class="s3">\n                </span><span class="s1">gc.strokeRect(x1 - 0.5, y1 - 0.5, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">gc.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the row header selections for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawRowHeaderSelections() {</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = this._selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections or if the selectionMode is the entire column.</span><span class="s3">\n        </span><span class="s1">if (!model || model.isEmpty || model.selectionMode == 'column') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the row headers are not visible.</span><span class="s3">\n        </span><span class="s1">if (this.headerWidth === 0 || this.pageHeight === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection colors.</span><span class="s3">\n        </span><span class="s1">let fill = this._style.headerSelectionFillColor;</span><span class="s3">\n        </span><span class="s1">let stroke = this._style.headerSelectionBorderColor;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to draw.</span><span class="s3">\n        </span><span class="s1">if (!fill &amp;&amp; !stroke) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch common geometry.</span><span class="s3">\n        </span><span class="s1">let sy = this._scrollY;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">let rs = this._rowSections;</span><span class="s3">\n        </span><span class="s1">// Fetch the overlay gc.</span><span class="s3">\n        </span><span class="s1">let gc = this._overlayGC;</span><span class="s3">\n        </span><span class="s1">// Save the gc state.</span><span class="s3">\n        </span><span class="s1">gc.save();</span><span class="s3">\n        </span><span class="s1">// Set up the header clipping rect.</span><span class="s3">\n        </span><span class="s1">gc.beginPath();</span><span class="s3">\n        </span><span class="s1">gc.rect(0, hh, hw, ph);</span><span class="s3">\n        </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">// Set up the gc style.</span><span class="s3">\n        </span><span class="s1">if (fill) {</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = fill;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (stroke) {</span><span class="s3">\n            </span><span class="s1">gc.strokeStyle = stroke;</span><span class="s3">\n            </span><span class="s1">gc.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the max row.</span><span class="s3">\n        </span><span class="s1">let maxRow = rs.count - 1;</span><span class="s3">\n        </span><span class="s1">// Fetch the visible rows.</span><span class="s3">\n        </span><span class="s1">let r1 = rs.indexOf(sy);</span><span class="s3">\n        </span><span class="s1">let r2 = rs.indexOf(sy + ph - 1);</span><span class="s3">\n        </span><span class="s1">r2 = r2 &lt; 0 ? maxRow : r2;</span><span class="s3">\n        </span><span class="s1">// Iterate over the visible rows.</span><span class="s3">\n        </span><span class="s1">for (let j = r1; j &lt;= r2; ++j) {</span><span class="s3">\n            </span><span class="s1">// Skip rows which aren't selected.</span><span class="s3">\n            </span><span class="s1">if (!model.isRowSelected(j)) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get the dimensions of the row.</span><span class="s3">\n            </span><span class="s1">let y = rs.offsetOf(j) - sy + hh;</span><span class="s3">\n            </span><span class="s1">let h = rs.sizeOf(j);</span><span class="s3">\n            </span><span class="s1">// Adjust the height for row stretch.</span><span class="s3">\n            </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh &amp;&amp; j === maxRow) {</span><span class="s3">\n                </span><span class="s1">h = hh + ph - y;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Skip zero sized rows.</span><span class="s3">\n            </span><span class="s1">if (h === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Fill the rect if needed.</span><span class="s3">\n            </span><span class="s1">if (fill) {</span><span class="s3">\n                </span><span class="s1">gc.fillRect(0, y, hw, h);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Draw the border if needed.</span><span class="s3">\n            </span><span class="s1">if (stroke) {</span><span class="s3">\n                </span><span class="s1">gc.beginPath();</span><span class="s3">\n                </span><span class="s1">gc.moveTo(hw - 0.5, y - 1);</span><span class="s3">\n                </span><span class="s1">gc.lineTo(hw - 0.5, y + h);</span><span class="s3">\n                </span><span class="s1">gc.stroke();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">gc.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the column header selections for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawColumnHeaderSelections() {</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = this._selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no selections or if the selectionMode is the entire row</span><span class="s3">\n        </span><span class="s1">if (!model || model.isEmpty || model.selectionMode == 'row') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the column headers are not visible.</span><span class="s3">\n        </span><span class="s1">if (this.headerHeight === 0 || this.pageWidth === 0) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the selection colors.</span><span class="s3">\n        </span><span class="s1">let fill = this._style.headerSelectionFillColor;</span><span class="s3">\n        </span><span class="s1">let stroke = this._style.headerSelectionBorderColor;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to draw.</span><span class="s3">\n        </span><span class="s1">if (!fill &amp;&amp; !stroke) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch common geometry.</span><span class="s3">\n        </span><span class="s1">let sx = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">let cs = this._columnSections;</span><span class="s3">\n        </span><span class="s1">// Fetch the overlay gc.</span><span class="s3">\n        </span><span class="s1">let gc = this._overlayGC;</span><span class="s3">\n        </span><span class="s1">// Save the gc state.</span><span class="s3">\n        </span><span class="s1">gc.save();</span><span class="s3">\n        </span><span class="s1">// Set up the header clipping rect.</span><span class="s3">\n        </span><span class="s1">gc.beginPath();</span><span class="s3">\n        </span><span class="s1">gc.rect(hw, 0, pw, hh);</span><span class="s3">\n        </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">// Set up the gc style.</span><span class="s3">\n        </span><span class="s1">if (fill) {</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = fill;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (stroke) {</span><span class="s3">\n            </span><span class="s1">gc.strokeStyle = stroke;</span><span class="s3">\n            </span><span class="s1">gc.lineWidth = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the max column.</span><span class="s3">\n        </span><span class="s1">let maxCol = cs.count - 1;</span><span class="s3">\n        </span><span class="s1">// Fetch the visible columns.</span><span class="s3">\n        </span><span class="s1">let c1 = cs.indexOf(sx);</span><span class="s3">\n        </span><span class="s1">let c2 = cs.indexOf(sx + pw - 1);</span><span class="s3">\n        </span><span class="s1">c2 = c2 &lt; 0 ? maxCol : c2;</span><span class="s3">\n        </span><span class="s1">// Iterate over the visible columns.</span><span class="s3">\n        </span><span class="s1">for (let i = c1; i &lt;= c2; ++i) {</span><span class="s3">\n            </span><span class="s1">// Skip columns which aren't selected.</span><span class="s3">\n            </span><span class="s1">if (!model.isColumnSelected(i)) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get the dimensions of the column.</span><span class="s3">\n            </span><span class="s1">let x = cs.offsetOf(i) - sx + hw;</span><span class="s3">\n            </span><span class="s1">let w = cs.sizeOf(i);</span><span class="s3">\n            </span><span class="s1">// Adjust the width for column stretch.</span><span class="s3">\n            </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw &amp;&amp; i === maxCol) {</span><span class="s3">\n                </span><span class="s1">w = hw + pw - x;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Skip zero sized columns.</span><span class="s3">\n            </span><span class="s1">if (w === 0) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Fill the rect if needed.</span><span class="s3">\n            </span><span class="s1">if (fill) {</span><span class="s3">\n                </span><span class="s1">gc.fillRect(x, 0, w, hh);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Draw the border if needed.</span><span class="s3">\n            </span><span class="s1">if (stroke) {</span><span class="s3">\n                </span><span class="s1">gc.beginPath();</span><span class="s3">\n                </span><span class="s1">gc.moveTo(x - 1, hh - 0.5);</span><span class="s3">\n                </span><span class="s1">gc.lineTo(x + w, hh - 0.5);</span><span class="s3">\n                </span><span class="s1">gc.stroke();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">gc.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the overlay cursor for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawCursor() {</span><span class="s3">\n        </span><span class="s1">// Fetch the selection model.</span><span class="s3">\n        </span><span class="s1">let model = this._selectionModel;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no cursor.</span><span class="s3">\n        </span><span class="s1">if (!model || model.isEmpty || model.selectionMode !== 'cell') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Extract the style information.</span><span class="s3">\n        </span><span class="s1">let fill = this._style.cursorFillColor;</span><span class="s3">\n        </span><span class="s1">let stroke = this._style.cursorBorderColor;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to draw.</span><span class="s3">\n        </span><span class="s1">if (!fill &amp;&amp; !stroke) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the cursor location.</span><span class="s3">\n        </span><span class="s1">let startRow = model.cursorRow;</span><span class="s3">\n        </span><span class="s1">let startColumn = model.cursorColumn;</span><span class="s3">\n        </span><span class="s1">// Fetch the max row and column.</span><span class="s3">\n        </span><span class="s1">let maxRow = this._rowSections.count - 1;</span><span class="s3">\n        </span><span class="s1">let maxColumn = this._columnSections.count - 1;</span><span class="s3">\n        </span><span class="s1">// Bail early if the cursor is out of bounds.</span><span class="s3">\n        </span><span class="s1">if (startRow &lt; 0 || startRow &gt; maxRow) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (startColumn &lt; 0 || startColumn &gt; maxColumn) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let endRow = startRow;</span><span class="s3">\n        </span><span class="s1">let endColumn = startColumn;</span><span class="s3">\n        </span><span class="s1">const joinedGroup = CellGroup.joinCellGroupWithMergedCellGroups(this.dataModel, { r1: startRow, r2: endRow, c1: startColumn, c2: endColumn }, 'body');</span><span class="s3">\n        </span><span class="s1">startRow = joinedGroup.r1;</span><span class="s3">\n        </span><span class="s1">endRow = joinedGroup.r2;</span><span class="s3">\n        </span><span class="s1">startColumn = joinedGroup.c1;</span><span class="s3">\n        </span><span class="s1">endColumn = joinedGroup.c2;</span><span class="s3">\n        </span><span class="s1">// Fetch geometry.</span><span class="s3">\n        </span><span class="s1">let sx = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let sy = this._scrollY;</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// Get the cursor bounds in viewport coordinates.</span><span class="s3">\n        </span><span class="s1">let x1 = this._columnSections.offsetOf(startColumn) - sx + hw;</span><span class="s3">\n        </span><span class="s1">let x2 = this._columnSections.extentOf(endColumn) - sx + hw;</span><span class="s3">\n        </span><span class="s1">let y1 = this._rowSections.offsetOf(startRow) - sy + hh;</span><span class="s3">\n        </span><span class="s1">let y2 = this._rowSections.extentOf(endRow) - sy + hh;</span><span class="s3">\n        </span><span class="s1">// Adjust the trailing X coordinate for column stretch.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw &amp;&amp; startColumn === maxColumn) {</span><span class="s3">\n            </span><span class="s1">x2 = vw - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Adjust the trailing Y coordinate for row stretch.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh &amp;&amp; startRow === maxRow) {</span><span class="s3">\n            </span><span class="s1">y2 = vh - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Skip zero sized cursors.</span><span class="s3">\n        </span><span class="s1">if (x2 &lt; x1 || y2 &lt; y1) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Bail early if the cursor is off the screen.</span><span class="s3">\n        </span><span class="s1">if (x1 - 1 &gt;= vw || y1 - 1 &gt;= vh || x2 + 1 &lt; hw || y2 + 1 &lt; hh) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the overlay gc.</span><span class="s3">\n        </span><span class="s1">let gc = this._overlayGC;</span><span class="s3">\n        </span><span class="s1">// Save the gc state.</span><span class="s3">\n        </span><span class="s1">gc.save();</span><span class="s3">\n        </span><span class="s1">// Set up the body clipping rect.</span><span class="s3">\n        </span><span class="s1">gc.beginPath();</span><span class="s3">\n        </span><span class="s1">gc.rect(hw, hh, pw, ph);</span><span class="s3">\n        </span><span class="s1">gc.clip();</span><span class="s3">\n        </span><span class="s1">// Clear any existing overlay content.</span><span class="s3">\n        </span><span class="s1">gc.clearRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n        </span><span class="s1">// Fill the cursor rect if needed.</span><span class="s3">\n        </span><span class="s1">if (fill) {</span><span class="s3">\n            </span><span class="s1">// Set up the fill style.</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = fill;</span><span class="s3">\n            </span><span class="s1">// Fill the cursor rect.</span><span class="s3">\n            </span><span class="s1">gc.fillRect(x1, y1, x2 - x1 + 1, y2 - y1 + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Stroke the cursor border if needed.</span><span class="s3">\n        </span><span class="s1">if (stroke) {</span><span class="s3">\n            </span><span class="s1">// Set up the stroke style.</span><span class="s3">\n            </span><span class="s1">gc.strokeStyle = stroke;</span><span class="s3">\n            </span><span class="s1">gc.lineWidth = 2;</span><span class="s3">\n            </span><span class="s1">// Stroke the cursor rect.</span><span class="s3">\n            </span><span class="s1">gc.strokeRect(x1, y1, x2 - x1, y2 - y1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">gc.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the overlay shadows for the data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">_drawShadows() {</span><span class="s3">\n        </span><span class="s1">// Fetch the scroll shadow from the style.</span><span class="s3">\n        </span><span class="s1">let shadow = this._style.scrollShadow;</span><span class="s3">\n        </span><span class="s1">// Bail early if there is no shadow to draw.</span><span class="s3">\n        </span><span class="s1">if (!shadow) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the scroll position.</span><span class="s3">\n        </span><span class="s1">let sx = this._scrollX;</span><span class="s3">\n        </span><span class="s1">let sy = this._scrollY;</span><span class="s3">\n        </span><span class="s1">// Fetch maximum scroll position.</span><span class="s3">\n        </span><span class="s1">let sxMax = this.maxScrollX;</span><span class="s3">\n        </span><span class="s1">let syMax = this.maxScrollY;</span><span class="s3">\n        </span><span class="s1">// Fetch the header width and height.</span><span class="s3">\n        </span><span class="s1">let hw = this.headerWidth;</span><span class="s3">\n        </span><span class="s1">let hh = this.headerHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the page width and height.</span><span class="s3">\n        </span><span class="s1">let pw = this.pageWidth;</span><span class="s3">\n        </span><span class="s1">let ph = this.pageHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the viewport width and height.</span><span class="s3">\n        </span><span class="s1">let vw = this._viewportWidth;</span><span class="s3">\n        </span><span class="s1">let vh = this._viewportHeight;</span><span class="s3">\n        </span><span class="s1">// Fetch the body width and height.</span><span class="s3">\n        </span><span class="s1">let bw = this.bodyWidth;</span><span class="s3">\n        </span><span class="s1">let bh = this.bodyHeight;</span><span class="s3">\n        </span><span class="s1">// Adjust the body size for row and column stretch.</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastRow &amp;&amp; ph &gt; bh) {</span><span class="s3">\n            </span><span class="s1">bh = ph;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._stretchLastColumn &amp;&amp; pw &gt; bw) {</span><span class="s3">\n            </span><span class="s1">bw = pw;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fetch the gc object.</span><span class="s3">\n        </span><span class="s1">let gc = this._overlayGC;</span><span class="s3">\n        </span><span class="s1">// Save the gc state.</span><span class="s3">\n        </span><span class="s1">gc.save();</span><span class="s3">\n        </span><span class="s1">// Draw the column header shadow if needed.</span><span class="s3">\n        </span><span class="s1">if (sy &gt; 0) {</span><span class="s3">\n            </span><span class="s1">// Set up the gradient coordinates.</span><span class="s3">\n            </span><span class="s1">let x0 = 0;</span><span class="s3">\n            </span><span class="s1">let y0 = hh;</span><span class="s3">\n            </span><span class="s1">let x1 = 0;</span><span class="s3">\n            </span><span class="s1">let y1 = y0 + shadow.size;</span><span class="s3">\n            </span><span class="s1">// Create the gradient object.</span><span class="s3">\n            </span><span class="s1">let grad = gc.createLinearGradient(x0, y0, x1, y1);</span><span class="s3">\n            </span><span class="s1">// Set the gradient stops.</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0, shadow.color1);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0.5, shadow.color2);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(1, shadow.color3);</span><span class="s3">\n            </span><span class="s1">// Set up the rect coordinates.</span><span class="s3">\n            </span><span class="s1">let x = 0;</span><span class="s3">\n            </span><span class="s1">let y = hh;</span><span class="s3">\n            </span><span class="s1">let w = hw + Math.min(pw, bw - sx);</span><span class="s3">\n            </span><span class="s1">let h = shadow.size;</span><span class="s3">\n            </span><span class="s1">// Fill the shadow rect with the fill style.</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = grad;</span><span class="s3">\n            </span><span class="s1">gc.fillRect(x, y, w, h);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the row header shadow if needed.</span><span class="s3">\n        </span><span class="s1">if (sx &gt; 0) {</span><span class="s3">\n            </span><span class="s1">// Set up the gradient coordinates.</span><span class="s3">\n            </span><span class="s1">let x0 = hw;</span><span class="s3">\n            </span><span class="s1">let y0 = 0;</span><span class="s3">\n            </span><span class="s1">let x1 = x0 + shadow.size;</span><span class="s3">\n            </span><span class="s1">let y1 = 0;</span><span class="s3">\n            </span><span class="s1">// Create the gradient object.</span><span class="s3">\n            </span><span class="s1">let grad = gc.createLinearGradient(x0, y0, x1, y1);</span><span class="s3">\n            </span><span class="s1">// Set the gradient stops.</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0, shadow.color1);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0.5, shadow.color2);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(1, shadow.color3);</span><span class="s3">\n            </span><span class="s1">// Set up the rect coordinates.</span><span class="s3">\n            </span><span class="s1">let x = hw;</span><span class="s3">\n            </span><span class="s1">let y = 0;</span><span class="s3">\n            </span><span class="s1">let w = shadow.size;</span><span class="s3">\n            </span><span class="s1">let h = hh + Math.min(ph, bh - sy);</span><span class="s3">\n            </span><span class="s1">// Fill the shadow rect with the fill style.</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = grad;</span><span class="s3">\n            </span><span class="s1">gc.fillRect(x, y, w, h);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the column footer shadow if needed.</span><span class="s3">\n        </span><span class="s1">if (sy &lt; syMax) {</span><span class="s3">\n            </span><span class="s1">// Set up the gradient coordinates.</span><span class="s3">\n            </span><span class="s1">let x0 = 0;</span><span class="s3">\n            </span><span class="s1">let y0 = vh;</span><span class="s3">\n            </span><span class="s1">let x1 = 0;</span><span class="s3">\n            </span><span class="s1">let y1 = vh - shadow.size;</span><span class="s3">\n            </span><span class="s1">// Create the gradient object.</span><span class="s3">\n            </span><span class="s1">let grad = gc.createLinearGradient(x0, y0, x1, y1);</span><span class="s3">\n            </span><span class="s1">// Set the gradient stops.</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0, shadow.color1);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0.5, shadow.color2);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(1, shadow.color3);</span><span class="s3">\n            </span><span class="s1">// Set up the rect coordinates.</span><span class="s3">\n            </span><span class="s1">let x = 0;</span><span class="s3">\n            </span><span class="s1">let y = vh - shadow.size;</span><span class="s3">\n            </span><span class="s1">let w = hw + Math.min(pw, bw - sx);</span><span class="s3">\n            </span><span class="s1">let h = shadow.size;</span><span class="s3">\n            </span><span class="s1">// Fill the shadow rect with the fill style.</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = grad;</span><span class="s3">\n            </span><span class="s1">gc.fillRect(x, y, w, h);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Draw the row footer shadow if needed.</span><span class="s3">\n        </span><span class="s1">if (sx &lt; sxMax) {</span><span class="s3">\n            </span><span class="s1">// Set up the gradient coordinates.</span><span class="s3">\n            </span><span class="s1">let x0 = vw;</span><span class="s3">\n            </span><span class="s1">let y0 = 0;</span><span class="s3">\n            </span><span class="s1">let x1 = vw - shadow.size;</span><span class="s3">\n            </span><span class="s1">let y1 = 0;</span><span class="s3">\n            </span><span class="s1">// Create the gradient object.</span><span class="s3">\n            </span><span class="s1">let grad = gc.createLinearGradient(x0, y0, x1, y1);</span><span class="s3">\n            </span><span class="s1">// Set the gradient stops.</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0, shadow.color1);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(0.5, shadow.color2);</span><span class="s3">\n            </span><span class="s1">grad.addColorStop(1, shadow.color3);</span><span class="s3">\n            </span><span class="s1">// Set up the rect coordinates.</span><span class="s3">\n            </span><span class="s1">let x = vw - shadow.size;</span><span class="s3">\n            </span><span class="s1">let y = 0;</span><span class="s3">\n            </span><span class="s1">let w = shadow.size;</span><span class="s3">\n            </span><span class="s1">let h = hh + Math.min(ph, bh - sy);</span><span class="s3">\n            </span><span class="s1">// Fill the shadow rect with the fill style.</span><span class="s3">\n            </span><span class="s1">gc.fillStyle = grad;</span><span class="s3">\n            </span><span class="s1">gc.fillRect(x, y, w, h);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Restore the gc state.</span><span class="s3">\n        </span><span class="s1">gc.restore();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the `DataGrid` class statics.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">(function (DataGrid) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A generic format function for the copy handler.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param args - The format args for the function.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The string representation of the value.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* This function uses `String()` to coerce a value to a string.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function copyFormatGeneric(args) {</span><span class="s3">\n        </span><span class="s1">if (args.value === null || args.value === undefined) {</span><span class="s3">\n            </span><span class="s1">return '';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return String(args.value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">DataGrid.copyFormatGeneric = copyFormatGeneric;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The default theme for a data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DataGrid.defaultStyle = {</span><span class="s3">\n        </span><span class="s1">voidColor: '#F3F3F3',</span><span class="s3">\n        </span><span class="s1">backgroundColor: '#FFFFFF',</span><span class="s3">\n        </span><span class="s1">gridLineColor: 'rgba(20, 20, 20, 0.15)',</span><span class="s3">\n        </span><span class="s1">headerBackgroundColor: '#F3F3F3',</span><span class="s3">\n        </span><span class="s1">headerGridLineColor: 'rgba(20, 20, 20, 0.25)',</span><span class="s3">\n        </span><span class="s1">selectionFillColor: 'rgba(49, 119, 229, 0.2)',</span><span class="s3">\n        </span><span class="s1">selectionBorderColor: 'rgba(0, 107, 247, 1.0)',</span><span class="s3">\n        </span><span class="s1">cursorBorderColor: 'rgba(0, 107, 247, 1.0)',</span><span class="s3">\n        </span><span class="s1">headerSelectionFillColor: 'rgba(20, 20, 20, 0.1)',</span><span class="s3">\n        </span><span class="s1">headerSelectionBorderColor: 'rgba(0, 107, 247, 1.0)',</span><span class="s3">\n        </span><span class="s1">scrollShadow: {</span><span class="s3">\n            </span><span class="s1">size: 10,</span><span class="s3">\n            </span><span class="s1">color1: 'rgba(0, 0, 0, 0.20)',</span><span class="s3">\n            </span><span class="s1">color2: 'rgba(0, 0, 0, 0.05)',</span><span class="s3">\n            </span><span class="s1">color3: 'rgba(0, 0, 0, 0.00)'</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The default sizes for a data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DataGrid.defaultSizes = {</span><span class="s3">\n        </span><span class="s1">rowHeight: 20,</span><span class="s3">\n        </span><span class="s1">columnWidth: 64,</span><span class="s3">\n        </span><span class="s1">rowHeaderWidth: 64,</span><span class="s3">\n        </span><span class="s1">columnHeaderHeight: 20</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The default minimum sizes for a data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DataGrid.minimumSizes = {</span><span class="s3">\n        </span><span class="s1">rowHeight: 20,</span><span class="s3">\n        </span><span class="s1">columnWidth: 10,</span><span class="s3">\n        </span><span class="s1">rowHeaderWidth: 10,</span><span class="s3">\n        </span><span class="s1">columnHeaderHeight: 20</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The default copy config for a data grid.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">DataGrid.defaultCopyConfig = {</span><span class="s3">\n        </span><span class="s1">separator: '</span><span class="s3">\\</span><span class="s1">t',</span><span class="s3">\n        </span><span class="s1">format: copyFormatGeneric,</span><span class="s3">\n        </span><span class="s1">headers: 'none',</span><span class="s3">\n        </span><span class="s1">warningThreshold: 1e6</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">})(DataGrid || (DataGrid = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private$1;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A singleton `scroll-request` conflatable message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.ScrollRequest = new ConflatableMessage('scroll-request');</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A singleton `overlay-paint-request` conflatable message.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">Private.OverlayPaintRequest = new ConflatableMessage('overlay-paint-request');</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new zero-sized canvas element.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function createCanvas() {</span><span class="s3">\n        </span><span class="s1">let canvas = document.createElement('canvas');</span><span class="s3">\n        </span><span class="s1">canvas.width = 0;</span><span class="s3">\n        </span><span class="s1">canvas.height = 0;</span><span class="s3">\n        </span><span class="s1">return canvas;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.createCanvas = createCanvas;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Checks whether a given regions has merged cells in it.</span><span class="s3">\n     </span><span class="s1">* @param dataModel grid's data model.</span><span class="s3">\n     </span><span class="s1">* @param region the paint region to be checked.</span><span class="s3">\n     </span><span class="s1">* @returns boolean.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function regionHasMergedCells(dataModel, region) {</span><span class="s3">\n        </span><span class="s1">const regionGroups = CellGroup.getCellGroupsAtRegion(dataModel, region);</span><span class="s3">\n        </span><span class="s1">return regionGroups.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.regionHasMergedCells = regionHasMergedCells;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A conflatable message which merges dirty paint regions.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">class PaintRequest extends ConflatableMessage {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Construct a new paint request messages.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param region - The cell region for the paint.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param r1 - The top-left row of the dirty region.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param c1 - The top-left column of the dirty region.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param r2 - The bottom-right row of the dirty region.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param c2 - The bottom-right column of the dirty region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">constructor(region, r1, c1, r2, c2) {</span><span class="s3">\n            </span><span class="s1">super('paint-request');</span><span class="s3">\n            </span><span class="s1">this._region = region;</span><span class="s3">\n            </span><span class="s1">this._r1 = r1;</span><span class="s3">\n            </span><span class="s1">this._c1 = c1;</span><span class="s3">\n            </span><span class="s1">this._r2 = r2;</span><span class="s3">\n            </span><span class="s1">this._c2 = c2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The cell region for the paint.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get region() {</span><span class="s3">\n            </span><span class="s1">return this._region;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The top-left row of the dirty region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get r1() {</span><span class="s3">\n            </span><span class="s1">return this._r1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The top-left column of the dirty region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get c1() {</span><span class="s3">\n            </span><span class="s1">return this._c1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The bottom-right row of the dirty region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get r2() {</span><span class="s3">\n            </span><span class="s1">return this._r2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The bottom-right column of the dirty region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get c2() {</span><span class="s3">\n            </span><span class="s1">return this._c2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Conflate this message with another paint request.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">conflate(other) {</span><span class="s3">\n            </span><span class="s1">// Bail early if the request is already painting everything.</span><span class="s3">\n            </span><span class="s1">if (this._region === 'all') {</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Any region can conflate with the `'all'` region.</span><span class="s3">\n            </span><span class="s1">if (other._region === 'all') {</span><span class="s3">\n                </span><span class="s1">this._region = 'all';</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Otherwise, do not conflate with a different region.</span><span class="s3">\n            </span><span class="s1">if (this._region !== other._region) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Conflate the region to the total boundary.</span><span class="s3">\n            </span><span class="s1">this._r1 = Math.min(this._r1, other._r1);</span><span class="s3">\n            </span><span class="s1">this._c1 = Math.min(this._c1, other._c1);</span><span class="s3">\n            </span><span class="s1">this._r2 = Math.max(this._r2, other._r2);</span><span class="s3">\n            </span><span class="s1">this._c2 = Math.max(this._c2, other._c2);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.PaintRequest = PaintRequest;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A conflatable message for resizing rows.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">class RowResizeRequest extends ConflatableMessage {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Construct a new row resize request.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param region - The row region which holds the section.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index of row in the region.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param size - The target size of the section.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">constructor(region, index, size) {</span><span class="s3">\n            </span><span class="s1">super('row-resize-request');</span><span class="s3">\n            </span><span class="s1">this._region = region;</span><span class="s3">\n            </span><span class="s1">this._index = index;</span><span class="s3">\n            </span><span class="s1">this._size = size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The row region which holds the section.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get region() {</span><span class="s3">\n            </span><span class="s1">return this._region;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The index of the row in the region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get index() {</span><span class="s3">\n            </span><span class="s1">return this._index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The target size of the section.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get size() {</span><span class="s3">\n            </span><span class="s1">return this._size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Conflate this message with another row resize request.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">conflate(other) {</span><span class="s3">\n            </span><span class="s1">if (this._region !== other._region || this._index !== other._index) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._size = other._size;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.RowResizeRequest = RowResizeRequest;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A conflatable message for resizing columns.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">class ColumnResizeRequest extends ConflatableMessage {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Construct a new column resize request.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param region - The column region which holds the section.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param index - The index of column in the region.</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @param size - The target size of the section.</span><span class="s3">\n         </span><span class="s1">*               If null, then infer the size to fit.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">constructor(region, index, size) {</span><span class="s3">\n            </span><span class="s1">super('column-resize-request');</span><span class="s3">\n            </span><span class="s1">this._region = region;</span><span class="s3">\n            </span><span class="s1">this._index = index;</span><span class="s3">\n            </span><span class="s1">this._size = size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The column region which holds the section.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get region() {</span><span class="s3">\n            </span><span class="s1">return this._region;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The index of the column in the region.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get index() {</span><span class="s3">\n            </span><span class="s1">return this._index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The target size of the section.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">get size() {</span><span class="s3">\n            </span><span class="s1">return this._size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Conflate this message with another column resize request.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">conflate(other) {</span><span class="s3">\n            </span><span class="s1">if (this._region !== other._region || this._index !== other._index) {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this._size = other._size;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.ColumnResizeRequest = ColumnResizeRequest;</span><span class="s3">\n</span><span class="s1">})(Private$1 || (Private$1 = {}));</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A data model implementation for in-memory JSON data.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class JSONModel extends DataModel {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a data model with static JSON data.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the data model.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">let split = Private.splitFields(options.schema);</span><span class="s3">\n        </span><span class="s1">this._data = options.data;</span><span class="s3">\n        </span><span class="s1">this._bodyFields = split.bodyFields;</span><span class="s3">\n        </span><span class="s1">this._headerFields = split.headerFields;</span><span class="s3">\n        </span><span class="s1">this._missingValues = Private.createMissingMap(options.schema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the row count for a region in the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The row region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns - The row count for the region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rowCount(region) {</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">return this._data.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return 1; // TODO multiple column-header rows?</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the column count for a region in the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The column region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns - The column count for the region.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">columnCount(region) {</span><span class="s3">\n        </span><span class="s1">if (region === 'body') {</span><span class="s3">\n            </span><span class="s1">return this._bodyFields.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._headerFields.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the data value for a cell in the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The cell region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of the cell of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of the cell of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns - The data value for the specified cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* A `missingValue` as defined by the schema is converted to `null`.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">data(region, row, column) {</span><span class="s3">\n        </span><span class="s1">// Set up the field and value variables.</span><span class="s3">\n        </span><span class="s1">let field;</span><span class="s3">\n        </span><span class="s1">let value;</span><span class="s3">\n        </span><span class="s1">// Look up the field and value for the region.</span><span class="s3">\n        </span><span class="s1">switch (region) {</span><span class="s3">\n            </span><span class="s1">case 'body':</span><span class="s3">\n                </span><span class="s1">field = this._bodyFields[column];</span><span class="s3">\n                </span><span class="s1">value = this._data[row][field.name];</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'column-header':</span><span class="s3">\n                </span><span class="s1">field = this._bodyFields[column];</span><span class="s3">\n                </span><span class="s1">value = field.title || field.name;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'row-header':</span><span class="s3">\n                </span><span class="s1">field = this._headerFields[column];</span><span class="s3">\n                </span><span class="s1">value = this._data[row][field.name];</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">case 'corner-header':</span><span class="s3">\n                </span><span class="s1">field = this._headerFields[column];</span><span class="s3">\n                </span><span class="s1">value = field.title || field.name;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">default:</span><span class="s3">\n                </span><span class="s1">throw 'unreachable';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Test whether the value is a missing value.</span><span class="s3">\n        </span><span class="s1">let missing = this._missingValues !== null &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof value === 'string' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this._missingValues[value] === true;</span><span class="s3">\n        </span><span class="s1">// Return the final value.</span><span class="s3">\n        </span><span class="s1">return missing ? null : value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the metadata for a cell in the data model.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param region - The cell region of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param row - The row index of the cell of of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param column - The column index of the cell of interest.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The metadata for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">metadata(region, row, column) {</span><span class="s3">\n        </span><span class="s1">if (region === 'body' || region === 'column-header') {</span><span class="s3">\n            </span><span class="s1">return this._bodyFields[column];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this._headerFields[column];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The namespace for the module implementation details.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var Private;</span><span class="s3">\n</span><span class="s1">(function (Private) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Split the schema fields into header and body fields.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function splitFields(schema) {</span><span class="s3">\n        </span><span class="s1">// Normalize the primary keys.</span><span class="s3">\n        </span><span class="s1">let primaryKeys;</span><span class="s3">\n        </span><span class="s1">if (schema.primaryKey === undefined) {</span><span class="s3">\n            </span><span class="s1">primaryKeys = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (typeof schema.primaryKey === 'string') {</span><span class="s3">\n            </span><span class="s1">primaryKeys = [schema.primaryKey];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">primaryKeys = schema.primaryKey;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Separate the fields for the body and header.</span><span class="s3">\n        </span><span class="s1">let bodyFields = [];</span><span class="s3">\n        </span><span class="s1">let headerFields = [];</span><span class="s3">\n        </span><span class="s1">for (let field of schema.fields) {</span><span class="s3">\n            </span><span class="s1">if (primaryKeys.indexOf(field.name) === -1) {</span><span class="s3">\n                </span><span class="s1">bodyFields.push(field);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">headerFields.push(field);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the separated fields.</span><span class="s3">\n        </span><span class="s1">return { bodyFields, headerFields };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.splitFields = splitFields;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a missing values map for a schema.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* This returns `null` if there are no missing values.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">function createMissingMap(schema) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there are no missing values.</span><span class="s3">\n        </span><span class="s1">if (!schema.missingValues || schema.missingValues.length === 0) {</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Collect the missing values into a map.</span><span class="s3">\n        </span><span class="s1">let result = Object.create(null);</span><span class="s3">\n        </span><span class="s1">for (let value of schema.missingValues) {</span><span class="s3">\n            </span><span class="s1">result[value] = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Return the populated map.</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">Private.createMissingMap = createMissingMap;</span><span class="s3">\n</span><span class="s1">})(Private || (Private = {}));</span><span class="s3">\n\n</span><span class="s1">// Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">// Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">/*-----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) 2014-2023, Lumino Contributors</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the BSD 3-Clause License.</span><span class="s3">\n</span><span class="s1">|</span><span class="s3">\n</span><span class="s1">| The full license is in the file LICENSE, distributed with this software.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">const PERCENTAGE_REGEX = /^(</span><span class="s3">\\</span><span class="s1">d+(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?)%$/;</span><span class="s3">\n</span><span class="s1">const PIXEL_REGEX = /^(</span><span class="s3">\\</span><span class="s1">d+(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+)?)px$/;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A cell renderer which renders data values as images.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ImageRenderer extends AsyncCellRenderer {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Construct a new text renderer.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options - The options for initializing the renderer.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options = {}) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.backgroundColor = options.backgroundColor || '';</span><span class="s3">\n        </span><span class="s1">this.textColor = options.textColor || '#000000';</span><span class="s3">\n        </span><span class="s1">this.placeholder = options.placeholder || '...';</span><span class="s3">\n        </span><span class="s1">this.width = options.width || '';</span><span class="s3">\n        </span><span class="s1">// Not using the || operator, because the empty string '' is a valid value</span><span class="s3">\n        </span><span class="s1">this.height = options.height === undefined ? '100%' : options.height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the renderer is ready or not for that specific config.</span><span class="s3">\n     </span><span class="s1">* If it's not ready, the datagrid will paint the placeholder.</span><span class="s3">\n     </span><span class="s1">* If it's ready, the datagrid will paint the image synchronously.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Whether the renderer is ready for this config or not.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isReady(config) {</span><span class="s3">\n        </span><span class="s1">return (!config.value || ImageRenderer.dataCache.get(config.value) !== undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Load the image asynchronously for a specific config.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">async load(config) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to do</span><span class="s3">\n        </span><span class="s1">if (!config.value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const value = config.value;</span><span class="s3">\n        </span><span class="s1">const loadedPromise = new PromiseDelegate();</span><span class="s3">\n        </span><span class="s1">ImageRenderer.dataCache.set(value, undefined);</span><span class="s3">\n        </span><span class="s1">const img = new Image();</span><span class="s3">\n        </span><span class="s1">img.onload = () =&gt; {</span><span class="s3">\n            </span><span class="s1">ImageRenderer.dataCache.set(value, img);</span><span class="s3">\n            </span><span class="s1">loadedPromise.resolve();</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">img.src = value;</span><span class="s3">\n        </span><span class="s1">return loadedPromise.promise;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint the placeholder for a cell, waiting for the renderer to be ready.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">paintPlaceholder(gc, config) {</span><span class="s3">\n        </span><span class="s1">this.drawBackground(gc, config);</span><span class="s3">\n        </span><span class="s1">this.drawPlaceholder(gc, config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Paint the content for a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">paint(gc, config) {</span><span class="s3">\n        </span><span class="s1">this.drawBackground(gc, config);</span><span class="s3">\n        </span><span class="s1">this.drawImage(gc, config);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the background for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawBackground(gc, config) {</span><span class="s3">\n        </span><span class="s1">// Resolve the background color for the cell.</span><span class="s3">\n        </span><span class="s1">const color = CellRenderer.resolveOption(this.backgroundColor, config);</span><span class="s3">\n        </span><span class="s1">// Bail if there is no background color to draw.</span><span class="s3">\n        </span><span class="s1">if (!color) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Fill the cell with the background color.</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">gc.fillRect(config.x, config.y, config.width, config.height);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the placeholder for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawPlaceholder(gc, config) {</span><span class="s3">\n        </span><span class="s1">const placeholder = CellRenderer.resolveOption(this.placeholder, config);</span><span class="s3">\n        </span><span class="s1">const color = CellRenderer.resolveOption(this.textColor, config);</span><span class="s3">\n        </span><span class="s1">const textX = config.x + config.width / 2;</span><span class="s3">\n        </span><span class="s1">const textY = config.y + config.height / 2;</span><span class="s3">\n        </span><span class="s1">// Draw the placeholder.</span><span class="s3">\n        </span><span class="s1">gc.fillStyle = color;</span><span class="s3">\n        </span><span class="s1">gc.fillText(placeholder, textX, textY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Draw the image for the cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param gc - The graphics context to use for drawing.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param config - The configuration data for the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">drawImage(gc, config) {</span><span class="s3">\n        </span><span class="s1">// Bail early if there is nothing to draw</span><span class="s3">\n        </span><span class="s1">if (!config.value) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const img = ImageRenderer.dataCache.get(config.value);</span><span class="s3">\n        </span><span class="s1">// If it's not loaded yet, show the placeholder</span><span class="s3">\n        </span><span class="s1">if (!img) {</span><span class="s3">\n            </span><span class="s1">return this.drawPlaceholder(gc, config);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const width = CellRenderer.resolveOption(this.width, config);</span><span class="s3">\n        </span><span class="s1">const height = CellRenderer.resolveOption(this.height, config);</span><span class="s3">\n        </span><span class="s1">// width and height are unset, we display the image with its original size</span><span class="s3">\n        </span><span class="s1">if (!width &amp;&amp; !height) {</span><span class="s3">\n            </span><span class="s1">gc.drawImage(img, config.x, config.y);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let requestedWidth = img.width;</span><span class="s3">\n        </span><span class="s1">let requestedHeight = img.height;</span><span class="s3">\n        </span><span class="s1">let widthPercentageMatch;</span><span class="s3">\n        </span><span class="s1">let widthPixelMatch;</span><span class="s3">\n        </span><span class="s1">let heightPercentageMatch;</span><span class="s3">\n        </span><span class="s1">let heightPixelMatch;</span><span class="s3">\n        </span><span class="s1">if ((widthPercentageMatch = width.match(PERCENTAGE_REGEX))) {</span><span class="s3">\n            </span><span class="s1">requestedWidth =</span><span class="s3">\n                </span><span class="s1">(parseFloat(widthPercentageMatch[1]) / 100) * config.width;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((widthPixelMatch = width.match(PIXEL_REGEX))) {</span><span class="s3">\n            </span><span class="s1">requestedWidth = parseFloat(widthPixelMatch[1]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if ((heightPercentageMatch = height.match(PERCENTAGE_REGEX))) {</span><span class="s3">\n            </span><span class="s1">requestedHeight =</span><span class="s3">\n                </span><span class="s1">(parseFloat(heightPercentageMatch[1]) / 100) * config.height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((heightPixelMatch = height.match(PIXEL_REGEX))) {</span><span class="s3">\n            </span><span class="s1">requestedHeight = parseFloat(heightPixelMatch[1]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If width is not set, we compute it respecting the image size ratio</span><span class="s3">\n        </span><span class="s1">if (!width) {</span><span class="s3">\n            </span><span class="s1">requestedWidth = (img.width / img.height) * requestedHeight;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// If height is not set, we compute it respecting the image size ratio</span><span class="s3">\n        </span><span class="s1">if (!height) {</span><span class="s3">\n            </span><span class="s1">requestedHeight = (img.height / img.width) * requestedWidth;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">gc.drawImage(img, config.x, config.y, requestedWidth, requestedHeight);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">ImageRenderer.dataCache = new Map();</span><span class="s3">\n\n</span><span class="s1">export { AsyncCellRenderer, BasicKeyHandler, BasicMouseHandler, BasicSelectionModel, BooleanCellEditor, CellEditor, CellEditorController, CellGroup, CellRenderer, DataGrid, DataModel, DateCellEditor, DynamicOptionCellEditor, GraphicsContext, HyperlinkRenderer, ImageRenderer, InputCellEditor, IntegerCellEditor, IntegerInputValidator, JSONModel, MutableDataModel, NumberCellEditor, NumberInputValidator, OptionCellEditor, PassInputValidator, RendererMap, SectionList, SelectionModel, TextCellEditor, TextInputValidator, TextRenderer, resolveOption };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.es6.js.map</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>