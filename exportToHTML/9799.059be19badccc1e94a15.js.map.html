<html>
<head>
<title>9799.059be19badccc1e94a15.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
9799.059be19badccc1e94a15.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;9799.059be19badccc1e94a15.js?v=059be19badccc1e94a15&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;AAAgO;AACpF;AAC9E;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAU;AAC9B;AACA;AACA,yBAAyB;AACzB;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB,EAAE,iCAAiC;AACrE;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA;AACA,6CAA6C,4DAA4D;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,KAAK;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,gEAAU,+CAA+C,KAAK;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,UAAU,SAAS;AACnB;AACA;AACA;AACA,yBAAyB,oBAAoB,KAAK,OAAO,GAAG,kBAAkB;AAC9E;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,OAAO;AACjB,yCAAyC;AACzC;AACA;AACA,qBAAqB;AACrB;AACA;AACA,uBAAuB,gGAAgG;AACvH,mBAAmB,8DAAe;AAClC;AACA,KAAK,MAAM,mDAAmD;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,0DAAW;AACtD,2CAA2C,0DAAW;;AAEtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C,uBAAuB,8DAAW,qBAAqB,gEAAa;AACpE;AACA;AACA,6BAA6B,8DAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,sCAAsC;AACpD;AACA;AACA;AACA,wBAAwB,8DAAW,uBAAuB,gEAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF,2BAA2B,8DAAW;AACtC;AACA;AACA,qBAAqB,gEAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,wBAAwB;AAC/G,uBAAuB,8DAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gEAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gEAAa,CAAC,8DAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC,oDAAK;AAC3C;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oCAAoC,uDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,IAAI,gBAAgB,IAAI,aAAa,kBAAkB;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,oBAAoB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,gCAAgC,yCAAyC;AACzE,SAAS;AACT;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,aAAa;AAC/B,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa,8DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,KAAK;AACvE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,kBAAkB,oBAAoB,gBAAgB,UAAU;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,YAAY;AAC1C;AACA;AACA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oBAAoB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,4FAA4F,mBAAmB,uCAAuC;AACtJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0DAAW;AAChD,4BAA4B;AAC5B,CAAC;AACD,uCAAuC,0DAAW;AAClD,qCAAqC,yDAAU;AAC/C,eAAe,iCAAiC;AAChD,wBAAwB,0BAA0B;AAClD;AACA,QAAQ,yDAAW;AACnB,QAAQ,wDAAU;AAClB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,sEAAsE,qDAAqD;AAC/K;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,4DAAU;AACjD;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA,wBAAwB,yCAAyC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yCAAyC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wDAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8DAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,yCAAyC;AAC1E,YAAY,8DAAY;AACxB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,2CAA2C,4DAAU;AACrD;AACA,0DAA0D,yCAAyC;AACnG;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,sDAAsD,0CAA0C;AAChG;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,sCAAsC,mDAAI,sBAAsB,wDAAU;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,+BAA+B,wDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;AAC1C;AACA;AACA,KAAK;AACL,mDAAmD,eAAe;AAClE,oDAAoD,cAAc;AAClE,0DAA0D,UAAU,qBAAqB,KAAK;AAC9F,2DAA2D,SAAS,qBAAqB,KAAK;AAC9F,iCAAiC,8BAA8B;AAC/D,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB,wBAAwB;AAC7C,KAAK;AACL;AACA,qBAAqB;AACrB,KAAK;AACL;AACA,qBAAqB;AACrB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,sDAAO;AACxD,4CAA4C,sDAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,UAAU;AAC1C,0CAA0C,4DAAU;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,eAAe,KAAK,OAAO;AACzE;AACA,iDAAiD;AACjD,gCAAgC,mBAAmB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,WAAW;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,+BAA+B,wDAAU,UAAU,uCAAuC,wDAAU;AACpG;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,OAAO;AACP,8BAA8B,wDAAU,QAAQ,0BAA0B;AAC1E;AACA;AACA;AACA;AACA,oBAAoB,wDAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAW;AAC1C,0BAA0B;AAC1B,CAAC;AACD,iCAAiC,0DAAW;AAC5C,kCAAkC,yDAAU;AAC5C,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,wDAAU,6CAA6C,wDAAU;AACnF,CAAC;AACD;AACA,WAAW,8DAAe,sDAAsD,8DAAe;AAC/F;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,OAAO,KAAK,EAAE,OAAO,IAAI,MAAM,EAAE,MAAM,KAAK,OAAO,GAAG;;AAEtE,SAAS,oCAAoC;AAC7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B,EAAE,QAAQ,cAAc;AACpD;;AAEA,uBAAuB,OAAO;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B,cAAc,OAAO;AACrB;AACA,uBAAuB,kDAAkD,mDAAI,WAAW;AACxF;AACA,wEAAwE,0DAAW;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAW;AACxC;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4DAA4D;AAClE,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAK;AACxC,oBAAoB;AACpB,CAAC;AACD,sCAAsC,mDAAI,sBAAsB,oDAAM;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,iBAAiB,0BAA0B;AACpF;AACA,2CAA2C,wDAAU;AACrD;AACA;AACA,iDAAiD,oCAAoC;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,gCAAgC,WAAW,IAAI,OAAO,GAAG,QAAQ;AACjE;AACA;AACA,gCAAgC,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA,gCAAgC,mEAAmB;AACnD;AACA;AACA;AACA;AACA,+CAA+C,mBAAmB;AAClE,cAAc,QAAQ;AACtB;AACA;AACA;AACA,8BAA8B,2BAA2B;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA,2BAA2B;AAC3B,gBAAgB,EAAE;AAClB;AACA;AACA,wCAAwC,0DAAW;AACnD;AACA,+CAA+C,sDAAO;AACtD;AACA;AACA,CAAC;AACD,qDAAqD,yDAAU;AAC/D;AACA;AACA;AACA,kCAAkC,yDAAU;AAC5C,eAAe,OAAO,uDAAQ,SAAS;AACvC;AACA;AACA;AACA;AACA,mCAAmC,sDAAsD;AACzF;AACA;AACA;AACA,uCAAuC,4DAA4D;AACnG;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA,WAAW,gEAAa;AACxB;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAU;AAC5C;AACA;AACA;AACA,mDAAmD,gEAAa,CAAC,8DAAW;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,8DAAW;AAC7F,6BAA6B,WAAW,gEAAgE;AACxG,+BAA+B,8DAAe;AAC9C;AACA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA,yCAAyC,oDAAoD;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,8DAAW;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yBAAyB,gEAAa,CAAC,8DAAW;AAClD;AACA;AACA;AACA,WAAW,gEAAa,CAAC,8DAAW;AACpC;AACA;AACA;AACA;AACA,qBAAqB,YAAY,gCAAgC,IAAI,+BAA+B;AACpG;AACA,uBAAuB,8DAAe;AACtC;AACA;AACA,qBAAqB,WAAW,wCAAwC;AACxE;AACA,uBAAuB,8DAAe;AACtC,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qBAAqB,WAAW,gEAAgE;AAChG,uBAAuB,8DAAe;AACtC,wBAAwB;AACxB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY,iCAAiC,IAAI,+BAA+B;AACrG;AACA,uBAAuB,8DAAe;AACtC;AACA;AACA;AACA,yBAAyB,WAAW,kCAAkC;AACtE;AACA,2BAA2B,8DAAe;AAC1C;AACA;AACA;AACA;AACA,yBAAyB,WAAW,sDAAsD;AAC1F,2BAA2B,8DAAe;AAC1C;AACA;AACA;AACA;AACA;AACA,qBAAqB,WAAW,kDAAkD;AAClF;AACA,uBAAuB,8DAAe;AACtC;AACA,qDAAqD,2DAAY;AACjE;AACA,yBAAyB,WAAW,kCAAkC;AACtE;AACA,2BAA2B,8DAAe;AAC1C;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,eAAe,gEAAU;AACzB;AACA;AACA;AACA,eAAe,gEAAU;AACzB;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,2DAAY;AAC7D;AACA;AACA;AACA,iGAAiG,2DAAY;AAC7G;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,yCAAyC;AAC/C,MAAM,oCAAoC;AAC1C,MAAM,qCAAqC;AAC3C,MAAM,mEAAmE;AACzE,MAAM,kEAAkE;AACxE,MAAM,0EAA0E;AAChF,MAAM,yEAAyE;AAC/E,MAAM;AACN;AACA,yCAAyC,mDAAI,sBAAsB,oDAAM;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE6hB;;;;;;;;;;;;;;;;;;;ACzhEpb;;AAEzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAA2D,IAAI,SAAS,EAAE,mCAAmC;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,uBAAuB;AACtD;AACA;AACA;AACA;AACA,gCAAgC,qEAAqE;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kEAAkE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf,kBAAkB;AAClB,gBAAgB;AAChB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,yCAAyC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,OAAO,mBAAmB,OAAO,yBAAyB,OAAO;AACxF;AACA;AACA,6BAA6B,mDAAQ;AACrC;AACA,WAAW;AACX;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC;AACA;AACA;AACA;AACA;AACA,kDAAkD,mDAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS,aAAa,aAAa;AACjD;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B,4BAA4B,+BAA+B;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,WAAW;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,WAAW,SAAS,aAAa,OAAO;AAC9D,0BAA0B,SAAS;AACnC,+GAA+G;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D;AACA,oCAAoC,sBAAsB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA,4DAA4D,OAAO;AACnE;AACA,8EAA8E,mDAAQ;AACtF;AACA;AACA,mFAAmF,+BAA+B;AAClH;AACA;AACA,wCAAwC,+CAAI;AAC5C;AACA;AACA,qCAAqC,+CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,6DAA6D;AAC7I;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE,mCAAmC,sDAAsD,GAAG,MAAM,sBAAsB,IAAI,MAAM,EAAE,qCAAqC;AACzK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAA0D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qFAAqF,2BAA2B;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,+CAAI,SAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iDAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,aAAa,mCAAmC,sBAAsB;AAC1H;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mDAAQ;AACnC,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA,2BAA2B,kDAAO,4BAA4B,mDAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,4BAA4B,8DAAmB;AAC/C;AACA;AACA;AACA;AACA,wBAAwB,kCAAkC;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC,mHAAmH;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,gBAAgB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW;AACzE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,QAAQ,oBAAoB;AACrF;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA,2DAA2D,6CAA6C;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4F;;;;;;;;ACv0D5F;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,MAAM;AACN;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAsC;;AAEtC;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA,6BAA6B&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/autocomplete/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lezer/lr/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/process/browser.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { Annotation, StateEffect, EditorSelection, codePointAt, codePointSize, fromCodePoint, Facet, combineConfig, StateField, Prec, Text, Transaction, MapMode, RangeValue, RangeSet, CharCategory } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { Direction, logException, showTooltip, EditorView, ViewPlugin, getTooltip, Decoration, WidgetType, keymap } from '@codemirror/view';</span><span class="s3">\n</span><span class="s1">import { syntaxTree, indentUnit } from '@codemirror/language';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An instance of this is passed to completion source functions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class CompletionContext {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a new completion context. (Mostly useful for testing</span><span class="s3">\n    </span><span class="s1">completion sources—in the editor, the extension will create</span><span class="s3">\n    </span><span class="s1">these for you.)</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The editor state that the completion happens in.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">state, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The position at which the completion is happening.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">pos, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether completion was activated explicitly, or</span><span class="s3">\n    </span><span class="s1">implicitly by typing. The usual way to respond to this is to</span><span class="s3">\n    </span><span class="s1">only return completions when either there is part of a</span><span class="s3">\n    </span><span class="s1">completable entity before the cursor, or `explicit` is true.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">explicit, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The editor view. May be undefined if the context was created</span><span class="s3">\n    </span><span class="s1">in a situation where there is no such view available, such as</span><span class="s3">\n    </span><span class="s1">in synchronous updates via</span><span class="s3">\n    </span><span class="s1">[`CompletionResult.update`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.update)</span><span class="s3">\n    </span><span class="s1">or when called by test code.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">view) {</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.explicit = explicit;</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.abortListeners = [];</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.abortOnDocChange = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the extent, content, and (if there is a token) type of the</span><span class="s3">\n    </span><span class="s1">token before `this.pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">tokenBefore(types) {</span><span class="s3">\n        </span><span class="s1">let token = syntaxTree(this.state).resolveInner(this.pos, -1);</span><span class="s3">\n        </span><span class="s1">while (token &amp;&amp; types.indexOf(token.name) &lt; 0)</span><span class="s3">\n            </span><span class="s1">token = token.parent;</span><span class="s3">\n        </span><span class="s1">return token ? { from: token.from, to: this.pos,</span><span class="s3">\n            </span><span class="s1">text: this.state.sliceDoc(token.from, this.pos),</span><span class="s3">\n            </span><span class="s1">type: token.type } : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the match of the given expression directly before the</span><span class="s3">\n    </span><span class="s1">cursor.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">matchBefore(expr) {</span><span class="s3">\n        </span><span class="s1">let line = this.state.doc.lineAt(this.pos);</span><span class="s3">\n        </span><span class="s1">let start = Math.max(line.from, this.pos - 250);</span><span class="s3">\n        </span><span class="s1">let str = line.text.slice(start - line.from, this.pos - line.from);</span><span class="s3">\n        </span><span class="s1">let found = str.search(ensureAnchor(expr, false));</span><span class="s3">\n        </span><span class="s1">return found &lt; 0 ? null : { from: start + found, to: this.pos, text: str.slice(found) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Yields true when the query has been aborted. Can be useful in</span><span class="s3">\n    </span><span class="s1">asynchronous queries to avoid doing work that will be ignored.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get aborted() { return this.abortListeners == null; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Allows you to register abort handlers, which will be called when</span><span class="s3">\n    </span><span class="s1">the query is</span><span class="s3">\n    </span><span class="s1">[aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).</span><span class="s3">\n    \n    </span><span class="s1">By default, running queries will not be aborted for regular</span><span class="s3">\n    </span><span class="s1">typing or backspacing, on the assumption that they are likely to</span><span class="s3">\n    </span><span class="s1">return a result with a</span><span class="s3">\n    </span><span class="s1">[`validFor`](https://codemirror.net/6/docs/ref/#autocomplete.CompletionResult.validFor) field that</span><span class="s3">\n    </span><span class="s1">allows the result to be used after all. Passing `onDocChange:</span><span class="s3">\n    </span><span class="s1">true` will cause this query to be aborted for any document</span><span class="s3">\n    </span><span class="s1">change.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addEventListener(type, listener, options) {</span><span class="s3">\n        </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">abort</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.abortListeners) {</span><span class="s3">\n            </span><span class="s1">this.abortListeners.push(listener);</span><span class="s3">\n            </span><span class="s1">if (options &amp;&amp; options.onDocChange)</span><span class="s3">\n                </span><span class="s1">this.abortOnDocChange = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function toSet(chars) {</span><span class="s3">\n    </span><span class="s1">let flat = Object.keys(chars).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let words = /</span><span class="s3">\\</span><span class="s1">w/.test(flat);</span><span class="s3">\n    </span><span class="s1">if (words)</span><span class="s3">\n        </span><span class="s1">flat = flat.replace(/</span><span class="s3">\\</span><span class="s1">w/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return `[${words ? </span><span class="s3">\&quot;\\\\</span><span class="s1">w</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}${flat.replace(/[^</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">s]/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s3">\&quot;</span><span class="s1">)}]`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function prefixMatch(options) {</span><span class="s3">\n    </span><span class="s1">let first = Object.create(null), rest = Object.create(null);</span><span class="s3">\n    </span><span class="s1">for (let { label } of options) {</span><span class="s3">\n        </span><span class="s1">first[label[0]] = true;</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; label.length; i++)</span><span class="s3">\n            </span><span class="s1">rest[label[i]] = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let source = toSet(first) + toSet(rest) + </span><span class="s3">\&quot;</span><span class="s1">*$</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return [new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ source), new RegExp(source)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Given a a fixed array of options, return an autocompleter that</span><span class="s3">\n</span><span class="s1">completes them.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function completeFromList(list) {</span><span class="s3">\n    </span><span class="s1">let options = list.map(o =&gt; typeof o == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? { label: o } : o);</span><span class="s3">\n    </span><span class="s1">let [validFor, match] = options.every(o =&gt; /^</span><span class="s3">\\</span><span class="s1">w+$/.test(o.label)) ? [/</span><span class="s3">\\</span><span class="s1">w*$/, /</span><span class="s3">\\</span><span class="s1">w+$/] : prefixMatch(options);</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; {</span><span class="s3">\n        </span><span class="s1">let token = context.matchBefore(match);</span><span class="s3">\n        </span><span class="s1">return token || context.explicit ? { from: token ? token.from : context.pos, options, validFor } : null;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Wrap the given completion source so that it will only fire when the</span><span class="s3">\n</span><span class="s1">cursor is in a syntax node with one of the given names.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ifIn(nodes, source) {</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {</span><span class="s3">\n            </span><span class="s1">if (nodes.indexOf(pos.name) &gt; -1)</span><span class="s3">\n                </span><span class="s1">return source(context);</span><span class="s3">\n            </span><span class="s1">if (pos.type.isTop)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Wrap the given completion source so that it will not fire when the</span><span class="s3">\n</span><span class="s1">cursor is in a syntax node with one of the given names.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ifNotIn(nodes, source) {</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; {</span><span class="s3">\n        </span><span class="s1">for (let pos = syntaxTree(context.state).resolveInner(context.pos, -1); pos; pos = pos.parent) {</span><span class="s3">\n            </span><span class="s1">if (nodes.indexOf(pos.name) &gt; -1)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">if (pos.type.isTop)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return source(context);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Option {</span><span class="s3">\n    </span><span class="s1">constructor(completion, source, match, score) {</span><span class="s3">\n        </span><span class="s1">this.completion = completion;</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.match = match;</span><span class="s3">\n        </span><span class="s1">this.score = score;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cur(state) { return state.selection.main.from; }</span><span class="s3">\n</span><span class="s1">// Make sure the given regexp has a $ at its end and, if `start` is</span><span class="s3">\n</span><span class="s1">// true, a ^ at its start.</span><span class="s3">\n</span><span class="s1">function ensureAnchor(expr, start) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let { source } = expr;</span><span class="s3">\n    </span><span class="s1">let addStart = start &amp;&amp; source[0] != </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">, addEnd = source[source.length - 1] != </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (!addStart &amp;&amp; !addEnd)</span><span class="s3">\n        </span><span class="s1">return expr;</span><span class="s3">\n    </span><span class="s1">return new RegExp(`${addStart ? </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}(?:${source})${addEnd ? </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">}`, (_a = expr.flags) !== null &amp;&amp; _a !== void 0 ? _a : (expr.ignoreCase ? </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This annotation is added to transactions that are produced by</span><span class="s3">\n</span><span class="s1">picking a completion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const pickedCompletion = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Helper function that returns a transaction spec which inserts a</span><span class="s3">\n</span><span class="s1">completion's text in the main selection range, and any other</span><span class="s3">\n</span><span class="s1">selection range that has the same text in front of it.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function insertCompletionText(state, text, from, to) {</span><span class="s3">\n    </span><span class="s1">let { main } = state.selection, fromOff = from - main.from, toOff = to - main.from;</span><span class="s3">\n    </span><span class="s1">return Object.assign(Object.assign({}, state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (range != main &amp;&amp; from != to &amp;&amp;</span><span class="s3">\n            </span><span class="s1">state.sliceDoc(range.from + fromOff, range.from + toOff) != state.sliceDoc(from, to))</span><span class="s3">\n            </span><span class="s1">return { range };</span><span class="s3">\n        </span><span class="s1">let lines = state.toText(text);</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">changes: { from: range.from + fromOff, to: to == main.from ? range.to : range.from + toOff, insert: lines },</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.cursor(range.from + fromOff + lines.length)</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">})), { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const SourceCache = /*@__PURE__*/new WeakMap();</span><span class="s3">\n</span><span class="s1">function asSource(source) {</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(source))</span><span class="s3">\n        </span><span class="s1">return source;</span><span class="s3">\n    </span><span class="s1">let known = SourceCache.get(source);</span><span class="s3">\n    </span><span class="s1">if (!known)</span><span class="s3">\n        </span><span class="s1">SourceCache.set(source, known = completeFromList(source));</span><span class="s3">\n    </span><span class="s1">return known;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const startCompletionEffect = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const closeCompletionEffect = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n\n</span><span class="s1">// A pattern matcher for fuzzy completion matching. Create an instance</span><span class="s3">\n</span><span class="s1">// once for a pattern, and then use that to match any number of</span><span class="s3">\n</span><span class="s1">// completions.</span><span class="s3">\n</span><span class="s1">class FuzzyMatcher {</span><span class="s3">\n    </span><span class="s1">constructor(pattern) {</span><span class="s3">\n        </span><span class="s1">this.pattern = pattern;</span><span class="s3">\n        </span><span class="s1">this.chars = [];</span><span class="s3">\n        </span><span class="s1">this.folded = [];</span><span class="s3">\n        </span><span class="s1">// Buffers reused by calls to `match` to track matched character</span><span class="s3">\n        </span><span class="s1">// positions.</span><span class="s3">\n        </span><span class="s1">this.any = [];</span><span class="s3">\n        </span><span class="s1">this.precise = [];</span><span class="s3">\n        </span><span class="s1">this.byWord = [];</span><span class="s3">\n        </span><span class="s1">this.score = 0;</span><span class="s3">\n        </span><span class="s1">this.matched = [];</span><span class="s3">\n        </span><span class="s1">for (let p = 0; p &lt; pattern.length;) {</span><span class="s3">\n            </span><span class="s1">let char = codePointAt(pattern, p), size = codePointSize(char);</span><span class="s3">\n            </span><span class="s1">this.chars.push(char);</span><span class="s3">\n            </span><span class="s1">let part = pattern.slice(p, p + size), upper = part.toUpperCase();</span><span class="s3">\n            </span><span class="s1">this.folded.push(codePointAt(upper == part ? part.toLowerCase() : upper, 0));</span><span class="s3">\n            </span><span class="s1">p += size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.astral = pattern.length != this.chars.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">ret(score, matched) {</span><span class="s3">\n        </span><span class="s1">this.score = score;</span><span class="s3">\n        </span><span class="s1">this.matched = matched;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Matches a given word (completion) against the pattern (input).</span><span class="s3">\n    </span><span class="s1">// Will return a boolean indicating whether there was a match and,</span><span class="s3">\n    </span><span class="s1">// on success, set `this.score` to the score, `this.matched` to an</span><span class="s3">\n    </span><span class="s1">// array of `from, to` pairs indicating the matched parts of `word`.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// The score is a number that is more negative the worse the match</span><span class="s3">\n    </span><span class="s1">// is. See `Penalty` above.</span><span class="s3">\n    </span><span class="s1">match(word) {</span><span class="s3">\n        </span><span class="s1">if (this.pattern.length == 0)</span><span class="s3">\n            </span><span class="s1">return this.ret(-100 /* Penalty.NotFull */, []);</span><span class="s3">\n        </span><span class="s1">if (word.length &lt; this.pattern.length)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let { chars, folded, any, precise, byWord } = this;</span><span class="s3">\n        </span><span class="s1">// For single-character queries, only match when they occur right</span><span class="s3">\n        </span><span class="s1">// at the start</span><span class="s3">\n        </span><span class="s1">if (chars.length == 1) {</span><span class="s3">\n            </span><span class="s1">let first = codePointAt(word, 0), firstSize = codePointSize(first);</span><span class="s3">\n            </span><span class="s1">let score = firstSize == word.length ? 0 : -100 /* Penalty.NotFull */;</span><span class="s3">\n            </span><span class="s1">if (first == chars[0]) ;</span><span class="s3">\n            </span><span class="s1">else if (first == folded[0])</span><span class="s3">\n                </span><span class="s1">score += -200 /* Penalty.CaseFold */;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">return this.ret(score, [0, firstSize]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let direct = word.indexOf(this.pattern);</span><span class="s3">\n        </span><span class="s1">if (direct == 0)</span><span class="s3">\n            </span><span class="s1">return this.ret(word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */, [0, this.pattern.length]);</span><span class="s3">\n        </span><span class="s1">let len = chars.length, anyTo = 0;</span><span class="s3">\n        </span><span class="s1">if (direct &lt; 0) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0, e = Math.min(word.length, 200); i &lt; e &amp;&amp; anyTo &lt; len;) {</span><span class="s3">\n                </span><span class="s1">let next = codePointAt(word, i);</span><span class="s3">\n                </span><span class="s1">if (next == chars[anyTo] || next == folded[anyTo])</span><span class="s3">\n                    </span><span class="s1">any[anyTo++] = i;</span><span class="s3">\n                </span><span class="s1">i += codePointSize(next);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// No match, exit immediately</span><span class="s3">\n            </span><span class="s1">if (anyTo &lt; len)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// This tracks the extent of the precise (non-folded, not</span><span class="s3">\n        </span><span class="s1">// necessarily adjacent) match</span><span class="s3">\n        </span><span class="s1">let preciseTo = 0;</span><span class="s3">\n        </span><span class="s1">// Tracks whether there is a match that hits only characters that</span><span class="s3">\n        </span><span class="s1">// appear to be starting words. `byWordFolded` is set to true when</span><span class="s3">\n        </span><span class="s1">// a case folded character is encountered in such a match</span><span class="s3">\n        </span><span class="s1">let byWordTo = 0, byWordFolded = false;</span><span class="s3">\n        </span><span class="s1">// If we've found a partial adjacent match, these track its state</span><span class="s3">\n        </span><span class="s1">let adjacentTo = 0, adjacentStart = -1, adjacentEnd = -1;</span><span class="s3">\n        </span><span class="s1">let hasLower = /[a-z]/.test(word), wordAdjacent = true;</span><span class="s3">\n        </span><span class="s1">// Go over the option's text, scanning for the various kinds of matches</span><span class="s3">\n        </span><span class="s1">for (let i = 0, e = Math.min(word.length, 200), prevType = 0 /* Tp.NonWord */; i &lt; e &amp;&amp; byWordTo &lt; len;) {</span><span class="s3">\n            </span><span class="s1">let next = codePointAt(word, i);</span><span class="s3">\n            </span><span class="s1">if (direct &lt; 0) {</span><span class="s3">\n                </span><span class="s1">if (preciseTo &lt; len &amp;&amp; next == chars[preciseTo])</span><span class="s3">\n                    </span><span class="s1">precise[preciseTo++] = i;</span><span class="s3">\n                </span><span class="s1">if (adjacentTo &lt; len) {</span><span class="s3">\n                    </span><span class="s1">if (next == chars[adjacentTo] || next == folded[adjacentTo]) {</span><span class="s3">\n                        </span><span class="s1">if (adjacentTo == 0)</span><span class="s3">\n                            </span><span class="s1">adjacentStart = i;</span><span class="s3">\n                        </span><span class="s1">adjacentEnd = i + 1;</span><span class="s3">\n                        </span><span class="s1">adjacentTo++;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">adjacentTo = 0;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let ch, type = next &lt; 0xff</span><span class="s3">\n                </span><span class="s1">? (next &gt;= 48 &amp;&amp; next &lt;= 57 || next &gt;= 97 &amp;&amp; next &lt;= 122 ? 2 /* Tp.Lower */ : next &gt;= 65 &amp;&amp; next &lt;= 90 ? 1 /* Tp.Upper */ : 0 /* Tp.NonWord */)</span><span class="s3">\n                </span><span class="s1">: ((ch = fromCodePoint(next)) != ch.toLowerCase() ? 1 /* Tp.Upper */ : ch != ch.toUpperCase() ? 2 /* Tp.Lower */ : 0 /* Tp.NonWord */);</span><span class="s3">\n            </span><span class="s1">if (!i || type == 1 /* Tp.Upper */ &amp;&amp; hasLower || prevType == 0 /* Tp.NonWord */ &amp;&amp; type != 0 /* Tp.NonWord */) {</span><span class="s3">\n                </span><span class="s1">if (chars[byWordTo] == next || (folded[byWordTo] == next &amp;&amp; (byWordFolded = true)))</span><span class="s3">\n                    </span><span class="s1">byWord[byWordTo++] = i;</span><span class="s3">\n                </span><span class="s1">else if (byWord.length)</span><span class="s3">\n                    </span><span class="s1">wordAdjacent = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">prevType = type;</span><span class="s3">\n            </span><span class="s1">i += codePointSize(next);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (byWordTo == len &amp;&amp; byWord[0] == 0 &amp;&amp; wordAdjacent)</span><span class="s3">\n            </span><span class="s1">return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0), byWord, word);</span><span class="s3">\n        </span><span class="s1">if (adjacentTo == len &amp;&amp; adjacentStart == 0)</span><span class="s3">\n            </span><span class="s1">return this.ret(-200 /* Penalty.CaseFold */ - word.length + (adjacentEnd == word.length ? 0 : -100 /* Penalty.NotFull */), [0, adjacentEnd]);</span><span class="s3">\n        </span><span class="s1">if (direct &gt; -1)</span><span class="s3">\n            </span><span class="s1">return this.ret(-700 /* Penalty.NotStart */ - word.length, [direct, direct + this.pattern.length]);</span><span class="s3">\n        </span><span class="s1">if (adjacentTo == len)</span><span class="s3">\n            </span><span class="s1">return this.ret(-200 /* Penalty.CaseFold */ + -700 /* Penalty.NotStart */ - word.length, [adjacentStart, adjacentEnd]);</span><span class="s3">\n        </span><span class="s1">if (byWordTo == len)</span><span class="s3">\n            </span><span class="s1">return this.result(-100 /* Penalty.ByWord */ + (byWordFolded ? -200 /* Penalty.CaseFold */ : 0) + -700 /* Penalty.NotStart */ +</span><span class="s3">\n                </span><span class="s1">(wordAdjacent ? 0 : -1100 /* Penalty.Gap */), byWord, word);</span><span class="s3">\n        </span><span class="s1">return chars.length == 2 ? null</span><span class="s3">\n            </span><span class="s1">: this.result((any[0] ? -700 /* Penalty.NotStart */ : 0) + -200 /* Penalty.CaseFold */ + -1100 /* Penalty.Gap */, any, word);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result(score, positions, word) {</span><span class="s3">\n        </span><span class="s1">let result = [], i = 0;</span><span class="s3">\n        </span><span class="s1">for (let pos of positions) {</span><span class="s3">\n            </span><span class="s1">let to = pos + (this.astral ? codePointSize(codePointAt(word, pos)) : 1);</span><span class="s3">\n            </span><span class="s1">if (i &amp;&amp; result[i - 1] == pos)</span><span class="s3">\n                </span><span class="s1">result[i - 1] = to;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">result[i++] = pos;</span><span class="s3">\n                </span><span class="s1">result[i++] = to;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.ret(score - word.length, result);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StrictMatcher {</span><span class="s3">\n    </span><span class="s1">constructor(pattern) {</span><span class="s3">\n        </span><span class="s1">this.pattern = pattern;</span><span class="s3">\n        </span><span class="s1">this.matched = [];</span><span class="s3">\n        </span><span class="s1">this.score = 0;</span><span class="s3">\n        </span><span class="s1">this.folded = pattern.toLowerCase();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">match(word) {</span><span class="s3">\n        </span><span class="s1">if (word.length &lt; this.pattern.length)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let start = word.slice(0, this.pattern.length);</span><span class="s3">\n        </span><span class="s1">let match = start == this.pattern ? 0 : start.toLowerCase() == this.folded ? -200 /* Penalty.CaseFold */ : null;</span><span class="s3">\n        </span><span class="s1">if (match == null)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">this.matched = [0, start.length];</span><span class="s3">\n        </span><span class="s1">this.score = match + (word.length == this.pattern.length ? 0 : -100 /* Penalty.NotFull */);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const completionConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">activateOnTyping: true,</span><span class="s3">\n            </span><span class="s1">activateOnCompletion: () =&gt; false,</span><span class="s3">\n            </span><span class="s1">activateOnTypingDelay: 100,</span><span class="s3">\n            </span><span class="s1">selectOnOpen: true,</span><span class="s3">\n            </span><span class="s1">override: null,</span><span class="s3">\n            </span><span class="s1">closeOnBlur: true,</span><span class="s3">\n            </span><span class="s1">maxRenderedOptions: 100,</span><span class="s3">\n            </span><span class="s1">defaultKeymap: true,</span><span class="s3">\n            </span><span class="s1">tooltipClass: () =&gt; </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">optionClass: () =&gt; </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">aboveCursor: false,</span><span class="s3">\n            </span><span class="s1">icons: true,</span><span class="s3">\n            </span><span class="s1">addToOptions: [],</span><span class="s3">\n            </span><span class="s1">positionInfo: defaultPositionInfo,</span><span class="s3">\n            </span><span class="s1">filterStrict: false,</span><span class="s3">\n            </span><span class="s1">compareCompletions: (a, b) =&gt; a.label.localeCompare(b.label),</span><span class="s3">\n            </span><span class="s1">interactionDelay: 75,</span><span class="s3">\n            </span><span class="s1">updateSyncTime: 100</span><span class="s3">\n        </span><span class="s1">}, {</span><span class="s3">\n            </span><span class="s1">defaultKeymap: (a, b) =&gt; a &amp;&amp; b,</span><span class="s3">\n            </span><span class="s1">closeOnBlur: (a, b) =&gt; a &amp;&amp; b,</span><span class="s3">\n            </span><span class="s1">icons: (a, b) =&gt; a &amp;&amp; b,</span><span class="s3">\n            </span><span class="s1">tooltipClass: (a, b) =&gt; c =&gt; joinClass(a(c), b(c)),</span><span class="s3">\n            </span><span class="s1">optionClass: (a, b) =&gt; c =&gt; joinClass(a(c), b(c)),</span><span class="s3">\n            </span><span class="s1">addToOptions: (a, b) =&gt; a.concat(b),</span><span class="s3">\n            </span><span class="s1">filterStrict: (a, b) =&gt; a || b,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function joinClass(a, b) {</span><span class="s3">\n    </span><span class="s1">return a ? b ? a + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ b : a : b;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultPositionInfo(view, list, option, info, space, tooltip) {</span><span class="s3">\n    </span><span class="s1">let rtl = view.textDirection == Direction.RTL, left = rtl, narrow = false;</span><span class="s3">\n    </span><span class="s1">let side = </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">, offset, maxWidth;</span><span class="s3">\n    </span><span class="s1">let spaceLeft = list.left - space.left, spaceRight = space.right - list.right;</span><span class="s3">\n    </span><span class="s1">let infoWidth = info.right - info.left, infoHeight = info.bottom - info.top;</span><span class="s3">\n    </span><span class="s1">if (left &amp;&amp; spaceLeft &lt; Math.min(infoWidth, spaceRight))</span><span class="s3">\n        </span><span class="s1">left = false;</span><span class="s3">\n    </span><span class="s1">else if (!left &amp;&amp; spaceRight &lt; Math.min(infoWidth, spaceLeft))</span><span class="s3">\n        </span><span class="s1">left = true;</span><span class="s3">\n    </span><span class="s1">if (infoWidth &lt;= (left ? spaceLeft : spaceRight)) {</span><span class="s3">\n        </span><span class="s1">offset = Math.max(space.top, Math.min(option.top, space.bottom - infoHeight)) - list.top;</span><span class="s3">\n        </span><span class="s1">maxWidth = Math.min(400 /* Info.Width */, left ? spaceLeft : spaceRight);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">narrow = true;</span><span class="s3">\n        </span><span class="s1">maxWidth = Math.min(400 /* Info.Width */, (rtl ? list.right : space.right - list.left) - 30 /* Info.Margin */);</span><span class="s3">\n        </span><span class="s1">let spaceBelow = space.bottom - list.bottom;</span><span class="s3">\n        </span><span class="s1">if (spaceBelow &gt;= infoHeight || spaceBelow &gt; list.top) { // Below the completion</span><span class="s3">\n            </span><span class="s1">offset = option.bottom - list.top;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else { // Above it</span><span class="s3">\n            </span><span class="s1">side = </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">offset = list.bottom - option.top;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let scaleY = (list.bottom - list.top) / tooltip.offsetHeight;</span><span class="s3">\n    </span><span class="s1">let scaleX = (list.right - list.left) / tooltip.offsetWidth;</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">style: `${side}: ${offset / scaleY}px; max-width: ${maxWidth / scaleX}px`,</span><span class="s3">\n        </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-completionInfo-</span><span class="s3">\&quot; </span><span class="s1">+ (narrow ? (rtl ? </span><span class="s3">\&quot;</span><span class="s1">left-narrow</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">right-narrow</span><span class="s3">\&quot;</span><span class="s1">) : left ? </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function optionContent(config) {</span><span class="s3">\n    </span><span class="s1">let content = config.addToOptions.slice();</span><span class="s3">\n    </span><span class="s1">if (config.icons)</span><span class="s3">\n        </span><span class="s1">content.push({</span><span class="s3">\n            </span><span class="s1">render(completion) {</span><span class="s3">\n                </span><span class="s1">let icon = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">icon.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-completionIcon</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">if (completion.type)</span><span class="s3">\n                    </span><span class="s1">icon.classList.add(...completion.type.split(/</span><span class="s3">\\</span><span class="s1">s+/g).map(cls =&gt; </span><span class="s3">\&quot;</span><span class="s1">cm-completionIcon-</span><span class="s3">\&quot; </span><span class="s1">+ cls));</span><span class="s3">\n                </span><span class="s1">icon.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-hidden</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">return icon;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">position: 20</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">content.push({</span><span class="s3">\n        </span><span class="s1">render(completion, _s, _v, match) {</span><span class="s3">\n            </span><span class="s1">let labelElt = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">labelElt.className = </span><span class="s3">\&quot;</span><span class="s1">cm-completionLabel</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">let label = completion.displayLabel || completion.label, off = 0;</span><span class="s3">\n            </span><span class="s1">for (let j = 0; j &lt; match.length;) {</span><span class="s3">\n                </span><span class="s1">let from = match[j++], to = match[j++];</span><span class="s3">\n                </span><span class="s1">if (from &gt; off)</span><span class="s3">\n                    </span><span class="s1">labelElt.appendChild(document.createTextNode(label.slice(off, from)));</span><span class="s3">\n                </span><span class="s1">let span = labelElt.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                </span><span class="s1">span.appendChild(document.createTextNode(label.slice(from, to)));</span><span class="s3">\n                </span><span class="s1">span.className = </span><span class="s3">\&quot;</span><span class="s1">cm-completionMatchedText</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">off = to;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (off &lt; label.length)</span><span class="s3">\n                </span><span class="s1">labelElt.appendChild(document.createTextNode(label.slice(off)));</span><span class="s3">\n            </span><span class="s1">return labelElt;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">position: 50</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">render(completion) {</span><span class="s3">\n            </span><span class="s1">if (!completion.detail)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let detailElt = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">detailElt.className = </span><span class="s3">\&quot;</span><span class="s1">cm-completionDetail</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">detailElt.textContent = completion.detail;</span><span class="s3">\n            </span><span class="s1">return detailElt;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">position: 80</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return content.sort((a, b) =&gt; a.position - b.position).map(a =&gt; a.render);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function rangeAroundSelected(total, selected, max) {</span><span class="s3">\n    </span><span class="s1">if (total &lt;= max)</span><span class="s3">\n        </span><span class="s1">return { from: 0, to: total };</span><span class="s3">\n    </span><span class="s1">if (selected &lt; 0)</span><span class="s3">\n        </span><span class="s1">selected = 0;</span><span class="s3">\n    </span><span class="s1">if (selected &lt;= (total &gt;&gt; 1)) {</span><span class="s3">\n        </span><span class="s1">let off = Math.floor(selected / max);</span><span class="s3">\n        </span><span class="s1">return { from: off * max, to: (off + 1) * max };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let off = Math.floor((total - selected) / max);</span><span class="s3">\n    </span><span class="s1">return { from: total - (off + 1) * max, to: total - off * max };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CompletionTooltip {</span><span class="s3">\n    </span><span class="s1">constructor(view, stateField, applyCompletion) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.stateField = stateField;</span><span class="s3">\n        </span><span class="s1">this.applyCompletion = applyCompletion;</span><span class="s3">\n        </span><span class="s1">this.info = null;</span><span class="s3">\n        </span><span class="s1">this.infoDestroy = null;</span><span class="s3">\n        </span><span class="s1">this.placeInfoReq = {</span><span class="s3">\n            </span><span class="s1">read: () =&gt; this.measureInfo(),</span><span class="s3">\n            </span><span class="s1">write: (pos) =&gt; this.placeInfo(pos),</span><span class="s3">\n            </span><span class="s1">key: this</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.space = null;</span><span class="s3">\n        </span><span class="s1">this.currentClass = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let cState = view.state.field(stateField);</span><span class="s3">\n        </span><span class="s1">let { options, selected } = cState.open;</span><span class="s3">\n        </span><span class="s1">let config = view.state.facet(completionConfig);</span><span class="s3">\n        </span><span class="s1">this.optionContent = optionContent(config);</span><span class="s3">\n        </span><span class="s1">this.optionClass = config.optionClass;</span><span class="s3">\n        </span><span class="s1">this.tooltipClass = config.tooltipClass;</span><span class="s3">\n        </span><span class="s1">this.range = rangeAroundSelected(options.length, selected, config.maxRenderedOptions);</span><span class="s3">\n        </span><span class="s1">this.dom = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.dom.className = </span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-autocomplete</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.updateTooltipClass(view.state);</span><span class="s3">\n        </span><span class="s1">this.dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">mousedown</span><span class="s3">\&quot;</span><span class="s1">, (e) =&gt; {</span><span class="s3">\n            </span><span class="s1">let { options } = view.state.field(stateField).open;</span><span class="s3">\n            </span><span class="s1">for (let dom = e.target, match; dom &amp;&amp; dom != this.dom; dom = dom.parentNode) {</span><span class="s3">\n                </span><span class="s1">if (dom.nodeName == </span><span class="s3">\&quot;</span><span class="s1">LI</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (match = /-(</span><span class="s3">\\</span><span class="s1">d+)$/.exec(dom.id)) &amp;&amp; +match[1] &lt; options.length) {</span><span class="s3">\n                    </span><span class="s1">this.applyCompletion(view, options[+match[1]]);</span><span class="s3">\n                    </span><span class="s1">e.preventDefault();</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.dom.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">focusout</span><span class="s3">\&quot;</span><span class="s1">, (e) =&gt; {</span><span class="s3">\n            </span><span class="s1">let state = view.state.field(this.stateField, false);</span><span class="s3">\n            </span><span class="s1">if (state &amp;&amp; state.tooltip &amp;&amp; view.state.facet(completionConfig).closeOnBlur &amp;&amp;</span><span class="s3">\n                </span><span class="s1">e.relatedTarget != view.contentDOM)</span><span class="s3">\n                </span><span class="s1">view.dispatch({ effects: closeCompletionEffect.of(null) });</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.showOptions(options, cState.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() { this.updateSel(); }</span><span class="s3">\n    </span><span class="s1">showOptions(options, id) {</span><span class="s3">\n        </span><span class="s1">if (this.list)</span><span class="s3">\n            </span><span class="s1">this.list.remove();</span><span class="s3">\n        </span><span class="s1">this.list = this.dom.appendChild(this.createListBox(options, id, this.range));</span><span class="s3">\n        </span><span class="s1">this.list.addEventListener(</span><span class="s3">\&quot;</span><span class="s1">scroll</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n            </span><span class="s1">if (this.info)</span><span class="s3">\n                </span><span class="s1">this.view.requestMeasure(this.placeInfoReq);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let cState = update.state.field(this.stateField);</span><span class="s3">\n        </span><span class="s1">let prevState = update.startState.field(this.stateField);</span><span class="s3">\n        </span><span class="s1">this.updateTooltipClass(update.state);</span><span class="s3">\n        </span><span class="s1">if (cState != prevState) {</span><span class="s3">\n            </span><span class="s1">let { options, selected, disabled } = cState.open;</span><span class="s3">\n            </span><span class="s1">if (!prevState.open || prevState.open.options != options) {</span><span class="s3">\n                </span><span class="s1">this.range = rangeAroundSelected(options.length, selected, update.state.facet(completionConfig).maxRenderedOptions);</span><span class="s3">\n                </span><span class="s1">this.showOptions(options, cState.id);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.updateSel();</span><span class="s3">\n            </span><span class="s1">if (disabled != ((_a = prevState.open) === null || _a === void 0 ? void 0 : _a.disabled))</span><span class="s3">\n                </span><span class="s1">this.dom.classList.toggle(</span><span class="s3">\&quot;</span><span class="s1">cm-tooltip-autocomplete-disabled</span><span class="s3">\&quot;</span><span class="s1">, !!disabled);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateTooltipClass(state) {</span><span class="s3">\n        </span><span class="s1">let cls = this.tooltipClass(state);</span><span class="s3">\n        </span><span class="s1">if (cls != this.currentClass) {</span><span class="s3">\n            </span><span class="s1">for (let c of this.currentClass.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">if (c)</span><span class="s3">\n                    </span><span class="s1">this.dom.classList.remove(c);</span><span class="s3">\n            </span><span class="s1">for (let c of cls.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n                </span><span class="s1">if (c)</span><span class="s3">\n                    </span><span class="s1">this.dom.classList.add(c);</span><span class="s3">\n            </span><span class="s1">this.currentClass = cls;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">positioned(space) {</span><span class="s3">\n        </span><span class="s1">this.space = space;</span><span class="s3">\n        </span><span class="s1">if (this.info)</span><span class="s3">\n            </span><span class="s1">this.view.requestMeasure(this.placeInfoReq);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateSel() {</span><span class="s3">\n        </span><span class="s1">let cState = this.view.state.field(this.stateField), open = cState.open;</span><span class="s3">\n        </span><span class="s1">if (open.selected &gt; -1 &amp;&amp; open.selected &lt; this.range.from || open.selected &gt;= this.range.to) {</span><span class="s3">\n            </span><span class="s1">this.range = rangeAroundSelected(open.options.length, open.selected, this.view.state.facet(completionConfig).maxRenderedOptions);</span><span class="s3">\n            </span><span class="s1">this.showOptions(open.options, cState.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.updateSelectedOption(open.selected)) {</span><span class="s3">\n            </span><span class="s1">this.destroyInfo();</span><span class="s3">\n            </span><span class="s1">let { completion } = open.options[open.selected];</span><span class="s3">\n            </span><span class="s1">let { info } = completion;</span><span class="s3">\n            </span><span class="s1">if (!info)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let infoResult = typeof info === </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? document.createTextNode(info) : info(completion);</span><span class="s3">\n            </span><span class="s1">if (!infoResult)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (</span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot; </span><span class="s1">in infoResult) {</span><span class="s3">\n                </span><span class="s1">infoResult.then(obj =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (obj &amp;&amp; this.view.state.field(this.stateField, false) == cState)</span><span class="s3">\n                        </span><span class="s1">this.addInfoPane(obj, completion);</span><span class="s3">\n                </span><span class="s1">}).catch(e =&gt; logException(this.view.state, e, </span><span class="s3">\&quot;</span><span class="s1">completion info</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.addInfoPane(infoResult, completion);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addInfoPane(content, completion) {</span><span class="s3">\n        </span><span class="s1">this.destroyInfo();</span><span class="s3">\n        </span><span class="s1">let wrap = this.info = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">wrap.className = </span><span class="s3">\&quot;</span><span class="s1">cm-tooltip cm-completionInfo</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (content.nodeType != null) {</span><span class="s3">\n            </span><span class="s1">wrap.appendChild(content);</span><span class="s3">\n            </span><span class="s1">this.infoDestroy = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let { dom, destroy } = content;</span><span class="s3">\n            </span><span class="s1">wrap.appendChild(dom);</span><span class="s3">\n            </span><span class="s1">this.infoDestroy = destroy || null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dom.appendChild(wrap);</span><span class="s3">\n        </span><span class="s1">this.view.requestMeasure(this.placeInfoReq);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateSelectedOption(selected) {</span><span class="s3">\n        </span><span class="s1">let set = null;</span><span class="s3">\n        </span><span class="s1">for (let opt = this.list.firstChild, i = this.range.from; opt; opt = opt.nextSibling, i++) {</span><span class="s3">\n            </span><span class="s1">if (opt.nodeName != </span><span class="s3">\&quot;</span><span class="s1">LI</span><span class="s3">\&quot; </span><span class="s1">|| !opt.id) {</span><span class="s3">\n                </span><span class="s1">i--; // A section header</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (i == selected) {</span><span class="s3">\n                </span><span class="s1">if (!opt.hasAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-selected</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                    </span><span class="s1">opt.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-selected</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                    </span><span class="s1">set = opt;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (opt.hasAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-selected</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                    </span><span class="s1">opt.removeAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-selected</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (set)</span><span class="s3">\n            </span><span class="s1">scrollIntoView(this.list, set);</span><span class="s3">\n        </span><span class="s1">return set;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">measureInfo() {</span><span class="s3">\n        </span><span class="s1">let sel = this.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">[aria-selected]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!sel || !this.info)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">let listRect = this.dom.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let infoRect = this.info.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let selRect = sel.getBoundingClientRect();</span><span class="s3">\n        </span><span class="s1">let space = this.space;</span><span class="s3">\n        </span><span class="s1">if (!space) {</span><span class="s3">\n            </span><span class="s1">let win = this.dom.ownerDocument.defaultView || window;</span><span class="s3">\n            </span><span class="s1">space = { left: 0, top: 0, right: win.innerWidth, bottom: win.innerHeight };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (selRect.top &gt; Math.min(space.bottom, listRect.bottom) - 10 ||</span><span class="s3">\n            </span><span class="s1">selRect.bottom &lt; Math.max(space.top, listRect.top) + 10)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">return this.view.state.facet(completionConfig).positionInfo(this.view, listRect, selRect, infoRect, space, this.dom);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">placeInfo(pos) {</span><span class="s3">\n        </span><span class="s1">if (this.info) {</span><span class="s3">\n            </span><span class="s1">if (pos) {</span><span class="s3">\n                </span><span class="s1">if (pos.style)</span><span class="s3">\n                    </span><span class="s1">this.info.style.cssText = pos.style;</span><span class="s3">\n                </span><span class="s1">this.info.className = </span><span class="s3">\&quot;</span><span class="s1">cm-tooltip cm-completionInfo </span><span class="s3">\&quot; </span><span class="s1">+ (pos.class || </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.info.style.cssText = </span><span class="s3">\&quot;</span><span class="s1">top: -1e6px</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createListBox(options, id, range) {</span><span class="s3">\n        </span><span class="s1">const ul = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">ul</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">ul.id = id;</span><span class="s3">\n        </span><span class="s1">ul.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">role</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">listbox</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">ul.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-expanded</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">ul.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">, this.view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">Completions</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">let curSection = null;</span><span class="s3">\n        </span><span class="s1">for (let i = range.from; i &lt; range.to; i++) {</span><span class="s3">\n            </span><span class="s1">let { completion, match } = options[i], { section } = completion;</span><span class="s3">\n            </span><span class="s1">if (section) {</span><span class="s3">\n                </span><span class="s1">let name = typeof section == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? section : section.name;</span><span class="s3">\n                </span><span class="s1">if (name != curSection &amp;&amp; (i &gt; range.from || range.from == 0)) {</span><span class="s3">\n                    </span><span class="s1">curSection = name;</span><span class="s3">\n                    </span><span class="s1">if (typeof section != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; section.header) {</span><span class="s3">\n                        </span><span class="s1">ul.appendChild(section.header(section));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">let header = ul.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">completion-section</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                        </span><span class="s1">header.textContent = name;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const li = ul.appendChild(document.createElement(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">li.id = id + </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ i;</span><span class="s3">\n            </span><span class="s1">li.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">role</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">let cls = this.optionClass(completion);</span><span class="s3">\n            </span><span class="s1">if (cls)</span><span class="s3">\n                </span><span class="s1">li.className = cls;</span><span class="s3">\n            </span><span class="s1">for (let source of this.optionContent) {</span><span class="s3">\n                </span><span class="s1">let node = source(completion, this.view.state, this.view, match);</span><span class="s3">\n                </span><span class="s1">if (node)</span><span class="s3">\n                    </span><span class="s1">li.appendChild(node);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (range.from)</span><span class="s3">\n            </span><span class="s1">ul.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-completionListIncompleteTop</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (range.to &lt; options.length)</span><span class="s3">\n            </span><span class="s1">ul.classList.add(</span><span class="s3">\&quot;</span><span class="s1">cm-completionListIncompleteBottom</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return ul;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroyInfo() {</span><span class="s3">\n        </span><span class="s1">if (this.info) {</span><span class="s3">\n            </span><span class="s1">if (this.infoDestroy)</span><span class="s3">\n                </span><span class="s1">this.infoDestroy();</span><span class="s3">\n            </span><span class="s1">this.info.remove();</span><span class="s3">\n            </span><span class="s1">this.info = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">this.destroyInfo();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function completionTooltip(stateField, applyCompletion) {</span><span class="s3">\n    </span><span class="s1">return (view) =&gt; new CompletionTooltip(view, stateField, applyCompletion);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function scrollIntoView(container, element) {</span><span class="s3">\n    </span><span class="s1">let parent = container.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let self = element.getBoundingClientRect();</span><span class="s3">\n    </span><span class="s1">let scaleY = parent.height / container.offsetHeight;</span><span class="s3">\n    </span><span class="s1">if (self.top &lt; parent.top)</span><span class="s3">\n        </span><span class="s1">container.scrollTop -= (parent.top - self.top) / scaleY;</span><span class="s3">\n    </span><span class="s1">else if (self.bottom &gt; parent.bottom)</span><span class="s3">\n        </span><span class="s1">container.scrollTop += (self.bottom - parent.bottom) / scaleY;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Used to pick a preferred option when two options with the same</span><span class="s3">\n</span><span class="s1">// label occur in the result.</span><span class="s3">\n</span><span class="s1">function score(option) {</span><span class="s3">\n    </span><span class="s1">return (option.boost || 0) * 100 + (option.apply ? 10 : 0) + (option.info ? 5 : 0) +</span><span class="s3">\n        </span><span class="s1">(option.type ? 1 : 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sortOptions(active, state) {</span><span class="s3">\n    </span><span class="s1">let options = [];</span><span class="s3">\n    </span><span class="s1">let sections = null;</span><span class="s3">\n    </span><span class="s1">let addOption = (option) =&gt; {</span><span class="s3">\n        </span><span class="s1">options.push(option);</span><span class="s3">\n        </span><span class="s1">let { section } = option.completion;</span><span class="s3">\n        </span><span class="s1">if (section) {</span><span class="s3">\n            </span><span class="s1">if (!sections)</span><span class="s3">\n                </span><span class="s1">sections = [];</span><span class="s3">\n            </span><span class="s1">let name = typeof section == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? section : section.name;</span><span class="s3">\n            </span><span class="s1">if (!sections.some(s =&gt; s.name == name))</span><span class="s3">\n                </span><span class="s1">sections.push(typeof section == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? { name } : section);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">let conf = state.facet(completionConfig);</span><span class="s3">\n    </span><span class="s1">for (let a of active)</span><span class="s3">\n        </span><span class="s1">if (a.hasResult()) {</span><span class="s3">\n            </span><span class="s1">let getMatch = a.result.getMatch;</span><span class="s3">\n            </span><span class="s1">if (a.result.filter === false) {</span><span class="s3">\n                </span><span class="s1">for (let option of a.result.options) {</span><span class="s3">\n                    </span><span class="s1">addOption(new Option(option, a.source, getMatch ? getMatch(option) : [], 1e9 - options.length));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let pattern = state.sliceDoc(a.from, a.to), match;</span><span class="s3">\n                </span><span class="s1">let matcher = conf.filterStrict ? new StrictMatcher(pattern) : new FuzzyMatcher(pattern);</span><span class="s3">\n                </span><span class="s1">for (let option of a.result.options)</span><span class="s3">\n                    </span><span class="s1">if (match = matcher.match(option.label)) {</span><span class="s3">\n                        </span><span class="s1">let matched = !option.displayLabel ? match.matched : getMatch ? getMatch(option, match.matched) : [];</span><span class="s3">\n                        </span><span class="s1">addOption(new Option(option, a.source, matched, match.score + (option.boost || 0)));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (sections) {</span><span class="s3">\n        </span><span class="s1">let sectionOrder = Object.create(null), pos = 0;</span><span class="s3">\n        </span><span class="s1">let cmp = (a, b) =&gt; { var _a, _b; return ((_a = a.rank) !== null &amp;&amp; _a !== void 0 ? _a : 1e9) - ((_b = b.rank) !== null &amp;&amp; _b !== void 0 ? _b : 1e9) || (a.name &lt; b.name ? -1 : 1); };</span><span class="s3">\n        </span><span class="s1">for (let s of sections.sort(cmp)) {</span><span class="s3">\n            </span><span class="s1">pos -= 1e5;</span><span class="s3">\n            </span><span class="s1">sectionOrder[s.name] = pos;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let option of options) {</span><span class="s3">\n            </span><span class="s1">let { section } = option.completion;</span><span class="s3">\n            </span><span class="s1">if (section)</span><span class="s3">\n                </span><span class="s1">option.score += sectionOrder[typeof section == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? section : section.name];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let result = [], prev = null;</span><span class="s3">\n    </span><span class="s1">let compare = conf.compareCompletions;</span><span class="s3">\n    </span><span class="s1">for (let opt of options.sort((a, b) =&gt; (b.score - a.score) || compare(a.completion, b.completion))) {</span><span class="s3">\n        </span><span class="s1">let cur = opt.completion;</span><span class="s3">\n        </span><span class="s1">if (!prev || prev.label != cur.label || prev.detail != cur.detail ||</span><span class="s3">\n            </span><span class="s1">(prev.type != null &amp;&amp; cur.type != null &amp;&amp; prev.type != cur.type) ||</span><span class="s3">\n            </span><span class="s1">prev.apply != cur.apply || prev.boost != cur.boost)</span><span class="s3">\n            </span><span class="s1">result.push(opt);</span><span class="s3">\n        </span><span class="s1">else if (score(opt.completion) &gt; score(prev))</span><span class="s3">\n            </span><span class="s1">result[result.length - 1] = opt;</span><span class="s3">\n        </span><span class="s1">prev = opt.completion;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CompletionDialog {</span><span class="s3">\n    </span><span class="s1">constructor(options, attrs, tooltip, timestamp, selected, disabled) {</span><span class="s3">\n        </span><span class="s1">this.options = options;</span><span class="s3">\n        </span><span class="s1">this.attrs = attrs;</span><span class="s3">\n        </span><span class="s1">this.tooltip = tooltip;</span><span class="s3">\n        </span><span class="s1">this.timestamp = timestamp;</span><span class="s3">\n        </span><span class="s1">this.selected = selected;</span><span class="s3">\n        </span><span class="s1">this.disabled = disabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setSelected(selected, id) {</span><span class="s3">\n        </span><span class="s1">return selected == this.selected || selected &gt;= this.options.length ? this</span><span class="s3">\n            </span><span class="s1">: new CompletionDialog(this.options, makeAttrs(id, selected), this.tooltip, this.timestamp, selected, this.disabled);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static build(active, state, id, prev, conf, didSetActive) {</span><span class="s3">\n        </span><span class="s1">if (prev &amp;&amp; !didSetActive &amp;&amp; active.some(s =&gt; s.isPending))</span><span class="s3">\n            </span><span class="s1">return prev.setDisabled();</span><span class="s3">\n        </span><span class="s1">let options = sortOptions(active, state);</span><span class="s3">\n        </span><span class="s1">if (!options.length)</span><span class="s3">\n            </span><span class="s1">return prev &amp;&amp; active.some(a =&gt; a.isPending) ? prev.setDisabled() : null;</span><span class="s3">\n        </span><span class="s1">let selected = state.facet(completionConfig).selectOnOpen ? 0 : -1;</span><span class="s3">\n        </span><span class="s1">if (prev &amp;&amp; prev.selected != selected &amp;&amp; prev.selected != -1) {</span><span class="s3">\n            </span><span class="s1">let selectedValue = prev.options[prev.selected].completion;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; options.length; i++)</span><span class="s3">\n                </span><span class="s1">if (options[i].completion == selectedValue) {</span><span class="s3">\n                    </span><span class="s1">selected = i;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new CompletionDialog(options, makeAttrs(id, selected), {</span><span class="s3">\n            </span><span class="s1">pos: active.reduce((a, b) =&gt; b.hasResult() ? Math.min(a, b.from) : a, 1e8),</span><span class="s3">\n            </span><span class="s1">create: createTooltip,</span><span class="s3">\n            </span><span class="s1">above: conf.aboveCursor,</span><span class="s3">\n        </span><span class="s1">}, prev ? prev.timestamp : Date.now(), selected, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(changes) {</span><span class="s3">\n        </span><span class="s1">return new CompletionDialog(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: changes.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDisabled() {</span><span class="s3">\n        </span><span class="s1">return new CompletionDialog(this.options, this.attrs, this.tooltip, this.timestamp, this.selected, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CompletionState {</span><span class="s3">\n    </span><span class="s1">constructor(active, id, open) {</span><span class="s3">\n        </span><span class="s1">this.active = active;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.open = open;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static start() {</span><span class="s3">\n        </span><span class="s1">return new CompletionState(none, </span><span class="s3">\&quot;</span><span class="s1">cm-ac-</span><span class="s3">\&quot; </span><span class="s1">+ Math.floor(Math.random() * 2e6).toString(36), null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(tr) {</span><span class="s3">\n        </span><span class="s1">let { state } = tr, conf = state.facet(completionConfig);</span><span class="s3">\n        </span><span class="s1">let sources = conf.override ||</span><span class="s3">\n            </span><span class="s1">state.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">autocomplete</span><span class="s3">\&quot;</span><span class="s1">, cur(state)).map(asSource);</span><span class="s3">\n        </span><span class="s1">let active = sources.map(source =&gt; {</span><span class="s3">\n            </span><span class="s1">let value = this.active.find(s =&gt; s.source == source) ||</span><span class="s3">\n                </span><span class="s1">new ActiveSource(source, this.active.some(a =&gt; a.state != 0 /* State.Inactive */) ? 1 /* State.Pending */ : 0 /* State.Inactive */);</span><span class="s3">\n            </span><span class="s1">return value.update(tr, conf);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (active.length == this.active.length &amp;&amp; active.every((a, i) =&gt; a == this.active[i]))</span><span class="s3">\n            </span><span class="s1">active = this.active;</span><span class="s3">\n        </span><span class="s1">let open = this.open, didSet = tr.effects.some(e =&gt; e.is(setActiveEffect));</span><span class="s3">\n        </span><span class="s1">if (open &amp;&amp; tr.docChanged)</span><span class="s3">\n            </span><span class="s1">open = open.map(tr.changes);</span><span class="s3">\n        </span><span class="s1">if (tr.selection || active.some(a =&gt; a.hasResult() &amp;&amp; tr.changes.touchesRange(a.from, a.to)) ||</span><span class="s3">\n            </span><span class="s1">!sameResults(active, this.active) || didSet)</span><span class="s3">\n            </span><span class="s1">open = CompletionDialog.build(active, state, this.id, open, conf, didSet);</span><span class="s3">\n        </span><span class="s1">else if (open &amp;&amp; open.disabled &amp;&amp; !active.some(a =&gt; a.isPending))</span><span class="s3">\n            </span><span class="s1">open = null;</span><span class="s3">\n        </span><span class="s1">if (!open &amp;&amp; active.every(a =&gt; !a.isPending) &amp;&amp; active.some(a =&gt; a.hasResult()))</span><span class="s3">\n            </span><span class="s1">active = active.map(a =&gt; a.hasResult() ? new ActiveSource(a.source, 0 /* State.Inactive */) : a);</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects)</span><span class="s3">\n            </span><span class="s1">if (effect.is(setSelectedEffect))</span><span class="s3">\n                </span><span class="s1">open = open &amp;&amp; open.setSelected(effect.value, this.id);</span><span class="s3">\n        </span><span class="s1">return active == this.active &amp;&amp; open == this.open ? this : new CompletionState(active, this.id, open);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get tooltip() { return this.open ? this.open.tooltip : null; }</span><span class="s3">\n    </span><span class="s1">get attrs() { return this.open ? this.open.attrs : this.active.length ? baseAttrs : noAttrs; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameResults(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a == b)</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">for (let iA = 0, iB = 0;;) {</span><span class="s3">\n        </span><span class="s1">while (iA &lt; a.length &amp;&amp; !a[iA].hasResult())</span><span class="s3">\n            </span><span class="s1">iA++;</span><span class="s3">\n        </span><span class="s1">while (iB &lt; b.length &amp;&amp; !b[iB].hasResult())</span><span class="s3">\n            </span><span class="s1">iB++;</span><span class="s3">\n        </span><span class="s1">let endA = iA == a.length, endB = iB == b.length;</span><span class="s3">\n        </span><span class="s1">if (endA || endB)</span><span class="s3">\n            </span><span class="s1">return endA == endB;</span><span class="s3">\n        </span><span class="s1">if (a[iA++].result != b[iB++].result)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const baseAttrs = {</span><span class="s3">\n    \&quot;</span><span class="s1">aria-autocomplete</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">list</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const noAttrs = {};</span><span class="s3">\n</span><span class="s1">function makeAttrs(id, selected) {</span><span class="s3">\n    </span><span class="s1">let result = {</span><span class="s3">\n        \&quot;</span><span class="s1">aria-autocomplete</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">list</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">aria-haspopup</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">listbox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">aria-controls</span><span class="s3">\&quot;</span><span class="s1">: id</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (selected &gt; -1)</span><span class="s3">\n        </span><span class="s1">result[</span><span class="s3">\&quot;</span><span class="s1">aria-activedescendant</span><span class="s3">\&quot;</span><span class="s1">] = id + </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ selected;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none = [];</span><span class="s3">\n</span><span class="s1">function getUpdateType(tr, conf) {</span><span class="s3">\n    </span><span class="s1">if (tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">let completion = tr.annotation(pickedCompletion);</span><span class="s3">\n        </span><span class="s1">if (completion &amp;&amp; conf.activateOnCompletion(completion))</span><span class="s3">\n            </span><span class="s1">return 4 /* UpdateType.Activate */ | 8 /* UpdateType.Reset */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let typing = tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return typing &amp;&amp; conf.activateOnTyping ? 4 /* UpdateType.Activate */ | 1 /* UpdateType.Typing */</span><span class="s3">\n        </span><span class="s1">: typing ? 1 /* UpdateType.Typing */</span><span class="s3">\n            </span><span class="s1">: tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">delete.backward</span><span class="s3">\&quot;</span><span class="s1">) ? 2 /* UpdateType.Backspacing */</span><span class="s3">\n                </span><span class="s1">: tr.selection ? 8 /* UpdateType.Reset */</span><span class="s3">\n                    </span><span class="s1">: tr.docChanged ? 16 /* UpdateType.ResetIfTouching */ : 0 /* UpdateType.None */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ActiveSource {</span><span class="s3">\n    </span><span class="s1">constructor(source, state, explicit = false) {</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.explicit = explicit;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasResult() { return false; }</span><span class="s3">\n    </span><span class="s1">get isPending() { return this.state == 1 /* State.Pending */; }</span><span class="s3">\n    </span><span class="s1">update(tr, conf) {</span><span class="s3">\n        </span><span class="s1">let type = getUpdateType(tr, conf), value = this;</span><span class="s3">\n        </span><span class="s1">if ((type &amp; 8 /* UpdateType.Reset */) || (type &amp; 16 /* UpdateType.ResetIfTouching */) &amp;&amp; this.touches(tr))</span><span class="s3">\n            </span><span class="s1">value = new ActiveSource(value.source, 0 /* State.Inactive */);</span><span class="s3">\n        </span><span class="s1">if ((type &amp; 4 /* UpdateType.Activate */) &amp;&amp; value.state == 0 /* State.Inactive */)</span><span class="s3">\n            </span><span class="s1">value = new ActiveSource(this.source, 1 /* State.Pending */);</span><span class="s3">\n        </span><span class="s1">value = value.updateFor(tr, type);</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n            </span><span class="s1">if (effect.is(startCompletionEffect))</span><span class="s3">\n                </span><span class="s1">value = new ActiveSource(value.source, 1 /* State.Pending */, effect.value);</span><span class="s3">\n            </span><span class="s1">else if (effect.is(closeCompletionEffect))</span><span class="s3">\n                </span><span class="s1">value = new ActiveSource(value.source, 0 /* State.Inactive */);</span><span class="s3">\n            </span><span class="s1">else if (effect.is(setActiveEffect))</span><span class="s3">\n                </span><span class="s1">for (let active of effect.value)</span><span class="s3">\n                    </span><span class="s1">if (active.source == value.source)</span><span class="s3">\n                        </span><span class="s1">value = active;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateFor(tr, type) { return this.map(tr.changes); }</span><span class="s3">\n    </span><span class="s1">map(changes) { return this; }</span><span class="s3">\n    </span><span class="s1">touches(tr) {</span><span class="s3">\n        </span><span class="s1">return tr.changes.touchesRange(cur(tr.state));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class ActiveResult extends ActiveSource {</span><span class="s3">\n    </span><span class="s1">constructor(source, explicit, limit, result, from, to) {</span><span class="s3">\n        </span><span class="s1">super(source, 3 /* State.Result */, explicit);</span><span class="s3">\n        </span><span class="s1">this.limit = limit;</span><span class="s3">\n        </span><span class="s1">this.result = result;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hasResult() { return true; }</span><span class="s3">\n    </span><span class="s1">updateFor(tr, type) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!(type &amp; 3 /* UpdateType.SimpleInteraction */))</span><span class="s3">\n            </span><span class="s1">return this.map(tr.changes);</span><span class="s3">\n        </span><span class="s1">let result = this.result;</span><span class="s3">\n        </span><span class="s1">if (result.map &amp;&amp; !tr.changes.empty)</span><span class="s3">\n            </span><span class="s1">result = result.map(result, tr.changes);</span><span class="s3">\n        </span><span class="s1">let from = tr.changes.mapPos(this.from), to = tr.changes.mapPos(this.to, 1);</span><span class="s3">\n        </span><span class="s1">let pos = cur(tr.state);</span><span class="s3">\n        </span><span class="s1">if (pos &gt; to || !result ||</span><span class="s3">\n            </span><span class="s1">(type &amp; 2 /* UpdateType.Backspacing */) &amp;&amp; (cur(tr.startState) == this.from || pos &lt; this.limit))</span><span class="s3">\n            </span><span class="s1">return new ActiveSource(this.source, type &amp; 4 /* UpdateType.Activate */ ? 1 /* State.Pending */ : 0 /* State.Inactive */);</span><span class="s3">\n        </span><span class="s1">let limit = tr.changes.mapPos(this.limit);</span><span class="s3">\n        </span><span class="s1">if (checkValid(result.validFor, tr.state, from, to))</span><span class="s3">\n            </span><span class="s1">return new ActiveResult(this.source, this.explicit, limit, result, from, to);</span><span class="s3">\n        </span><span class="s1">if (result.update &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(result = result.update(result, from, to, new CompletionContext(tr.state, pos, false))))</span><span class="s3">\n            </span><span class="s1">return new ActiveResult(this.source, this.explicit, limit, result, result.from, (_a = result.to) !== null &amp;&amp; _a !== void 0 ? _a : cur(tr.state));</span><span class="s3">\n        </span><span class="s1">return new ActiveSource(this.source, 1 /* State.Pending */, this.explicit);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(mapping) {</span><span class="s3">\n        </span><span class="s1">if (mapping.empty)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let result = this.result.map ? this.result.map(this.result, mapping) : this.result;</span><span class="s3">\n        </span><span class="s1">if (!result)</span><span class="s3">\n            </span><span class="s1">return new ActiveSource(this.source, 0 /* State.Inactive */);</span><span class="s3">\n        </span><span class="s1">return new ActiveResult(this.source, this.explicit, mapping.mapPos(this.limit), this.result, mapping.mapPos(this.from), mapping.mapPos(this.to, 1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">touches(tr) {</span><span class="s3">\n        </span><span class="s1">return tr.changes.touchesRange(this.from, this.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkValid(validFor, state, from, to) {</span><span class="s3">\n    </span><span class="s1">if (!validFor)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let text = state.sliceDoc(from, to);</span><span class="s3">\n    </span><span class="s1">return typeof validFor == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? validFor(text, from, to, state) : ensureAnchor(validFor, true).test(text);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const setActiveEffect = /*@__PURE__*/StateEffect.define({</span><span class="s3">\n    </span><span class="s1">map(sources, mapping) { return sources.map(s =&gt; s.map(mapping)); }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const setSelectedEffect = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const completionState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return CompletionState.start(); },</span><span class="s3">\n    </span><span class="s1">update(value, tr) { return value.update(tr); },</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; [</span><span class="s3">\n        </span><span class="s1">showTooltip.from(f, val =&gt; val.tooltip),</span><span class="s3">\n        </span><span class="s1">EditorView.contentAttributes.from(f, state =&gt; state.attrs)</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function applyCompletion(view, option) {</span><span class="s3">\n    </span><span class="s1">const apply = option.completion.apply || option.completion.label;</span><span class="s3">\n    </span><span class="s1">let result = view.state.field(completionState).active.find(a =&gt; a.source == option.source);</span><span class="s3">\n    </span><span class="s1">if (!(result instanceof ActiveResult))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">if (typeof apply == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">view.dispatch(Object.assign(Object.assign({}, insertCompletionText(view.state, apply, result.from, result.to)), { annotations: pickedCompletion.of(option.completion) }));</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">apply(view, option.completion, result.from, result.to);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const createTooltip = /*@__PURE__*/completionTooltip(completionState, applyCompletion);</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns a command that moves the completion selection forward or</span><span class="s3">\n</span><span class="s1">backward by the given amount.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function moveCompletionSelection(forward, by = </span><span class="s3">\&quot;</span><span class="s1">option</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return (view) =&gt; {</span><span class="s3">\n        </span><span class="s1">let cState = view.state.field(completionState, false);</span><span class="s3">\n        </span><span class="s1">if (!cState || !cState.open || cState.open.disabled ||</span><span class="s3">\n            </span><span class="s1">Date.now() - cState.open.timestamp &lt; view.state.facet(completionConfig).interactionDelay)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let step = 1, tooltip;</span><span class="s3">\n        </span><span class="s1">if (by == </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (tooltip = getTooltip(view, cState.open.tooltip)))</span><span class="s3">\n            </span><span class="s1">step = Math.max(2, Math.floor(tooltip.dom.offsetHeight /</span><span class="s3">\n                </span><span class="s1">tooltip.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">li</span><span class="s3">\&quot;</span><span class="s1">).offsetHeight) - 1);</span><span class="s3">\n        </span><span class="s1">let { length } = cState.open.options;</span><span class="s3">\n        </span><span class="s1">let selected = cState.open.selected &gt; -1 ? cState.open.selected + step * (forward ? 1 : -1) : forward ? 0 : length - 1;</span><span class="s3">\n        </span><span class="s1">if (selected &lt; 0)</span><span class="s3">\n            </span><span class="s1">selected = by == </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot; </span><span class="s1">? 0 : length - 1;</span><span class="s3">\n        </span><span class="s1">else if (selected &gt;= length)</span><span class="s3">\n            </span><span class="s1">selected = by == </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot; </span><span class="s1">? length - 1 : 0;</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects: setSelectedEffect.of(selected) });</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Accept the current completion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const acceptCompletion = (view) =&gt; {</span><span class="s3">\n    </span><span class="s1">let cState = view.state.field(completionState, false);</span><span class="s3">\n    </span><span class="s1">if (view.state.readOnly || !cState || !cState.open || cState.open.selected &lt; 0 || cState.open.disabled ||</span><span class="s3">\n        </span><span class="s1">Date.now() - cState.open.timestamp &lt; view.state.facet(completionConfig).interactionDelay)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return applyCompletion(view, cState.open.options[cState.open.selected]);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Explicitly start autocompletion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const startCompletion = (view) =&gt; {</span><span class="s3">\n    </span><span class="s1">let cState = view.state.field(completionState, false);</span><span class="s3">\n    </span><span class="s1">if (!cState)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">view.dispatch({ effects: startCompletionEffect.of(true) });</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Close the currently active completion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const closeCompletion = (view) =&gt; {</span><span class="s3">\n    </span><span class="s1">let cState = view.state.field(completionState, false);</span><span class="s3">\n    </span><span class="s1">if (!cState || !cState.active.some(a =&gt; a.state != 0 /* State.Inactive */))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">view.dispatch({ effects: closeCompletionEffect.of(null) });</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class RunningQuery {</span><span class="s3">\n    </span><span class="s1">constructor(active, context) {</span><span class="s3">\n        </span><span class="s1">this.active = active;</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this.time = Date.now();</span><span class="s3">\n        </span><span class="s1">this.updates = [];</span><span class="s3">\n        </span><span class="s1">// Note that 'undefined' means 'not done yet', whereas 'null' means</span><span class="s3">\n        </span><span class="s1">// 'query returned null'.</span><span class="s3">\n        </span><span class="s1">this.done = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const MaxUpdateCount = 50, MinAbortTime = 1000;</span><span class="s3">\n</span><span class="s1">const completionPlugin = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.debounceUpdate = -1;</span><span class="s3">\n        </span><span class="s1">this.running = [];</span><span class="s3">\n        </span><span class="s1">this.debounceAccept = -1;</span><span class="s3">\n        </span><span class="s1">this.pendingStart = false;</span><span class="s3">\n        </span><span class="s1">this.composing = 0 /* CompositionState.None */;</span><span class="s3">\n        </span><span class="s1">for (let active of view.state.field(completionState).active)</span><span class="s3">\n            </span><span class="s1">if (active.isPending)</span><span class="s3">\n                </span><span class="s1">this.startQuery(active);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let cState = update.state.field(completionState);</span><span class="s3">\n        </span><span class="s1">let conf = update.state.facet(completionConfig);</span><span class="s3">\n        </span><span class="s1">if (!update.selectionSet &amp;&amp; !update.docChanged &amp;&amp; update.startState.field(completionState) == cState)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let doesReset = update.transactions.some(tr =&gt; {</span><span class="s3">\n            </span><span class="s1">let type = getUpdateType(tr, conf);</span><span class="s3">\n            </span><span class="s1">return (type &amp; 8 /* UpdateType.Reset */) || (tr.selection || tr.docChanged) &amp;&amp; !(type &amp; 3 /* UpdateType.SimpleInteraction */);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.running.length; i++) {</span><span class="s3">\n            </span><span class="s1">let query = this.running[i];</span><span class="s3">\n            </span><span class="s1">if (doesReset ||</span><span class="s3">\n                </span><span class="s1">query.context.abortOnDocChange &amp;&amp; update.docChanged ||</span><span class="s3">\n                </span><span class="s1">query.updates.length + update.transactions.length &gt; MaxUpdateCount &amp;&amp; Date.now() - query.time &gt; MinAbortTime) {</span><span class="s3">\n                </span><span class="s1">for (let handler of query.context.abortListeners) {</span><span class="s3">\n                    </span><span class="s1">try {</span><span class="s3">\n                        </span><span class="s1">handler();</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">catch (e) {</span><span class="s3">\n                        </span><span class="s1">logException(this.view.state, e);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">query.context.abortListeners = null;</span><span class="s3">\n                </span><span class="s1">this.running.splice(i--, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">query.updates.push(...update.transactions);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.debounceUpdate &gt; -1)</span><span class="s3">\n            </span><span class="s1">clearTimeout(this.debounceUpdate);</span><span class="s3">\n        </span><span class="s1">if (update.transactions.some(tr =&gt; tr.effects.some(e =&gt; e.is(startCompletionEffect))))</span><span class="s3">\n            </span><span class="s1">this.pendingStart = true;</span><span class="s3">\n        </span><span class="s1">let delay = this.pendingStart ? 50 : conf.activateOnTypingDelay;</span><span class="s3">\n        </span><span class="s1">this.debounceUpdate = cState.active.some(a =&gt; a.isPending &amp;&amp; !this.running.some(q =&gt; q.active.source == a.source))</span><span class="s3">\n            </span><span class="s1">? setTimeout(() =&gt; this.startUpdate(), delay) : -1;</span><span class="s3">\n        </span><span class="s1">if (this.composing != 0 /* CompositionState.None */)</span><span class="s3">\n            </span><span class="s1">for (let tr of update.transactions) {</span><span class="s3">\n                </span><span class="s1">if (tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n                    </span><span class="s1">this.composing = 2 /* CompositionState.Changed */;</span><span class="s3">\n                </span><span class="s1">else if (this.composing == 2 /* CompositionState.Changed */ &amp;&amp; tr.selection)</span><span class="s3">\n                    </span><span class="s1">this.composing = 3 /* CompositionState.ChangedAndMoved */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startUpdate() {</span><span class="s3">\n        </span><span class="s1">this.debounceUpdate = -1;</span><span class="s3">\n        </span><span class="s1">this.pendingStart = false;</span><span class="s3">\n        </span><span class="s1">let { state } = this.view, cState = state.field(completionState);</span><span class="s3">\n        </span><span class="s1">for (let active of cState.active) {</span><span class="s3">\n            </span><span class="s1">if (active.isPending &amp;&amp; !this.running.some(r =&gt; r.active.source == active.source))</span><span class="s3">\n                </span><span class="s1">this.startQuery(active);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.running.length &amp;&amp; cState.open &amp;&amp; cState.open.disabled)</span><span class="s3">\n            </span><span class="s1">this.debounceAccept = setTimeout(() =&gt; this.accept(), this.view.state.facet(completionConfig).updateSyncTime);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startQuery(active) {</span><span class="s3">\n        </span><span class="s1">let { state } = this.view, pos = cur(state);</span><span class="s3">\n        </span><span class="s1">let context = new CompletionContext(state, pos, active.explicit, this.view);</span><span class="s3">\n        </span><span class="s1">let pending = new RunningQuery(active, context);</span><span class="s3">\n        </span><span class="s1">this.running.push(pending);</span><span class="s3">\n        </span><span class="s1">Promise.resolve(active.source(context)).then(result =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!pending.context.aborted) {</span><span class="s3">\n                </span><span class="s1">pending.done = result || null;</span><span class="s3">\n                </span><span class="s1">this.scheduleAccept();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}, err =&gt; {</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({ effects: closeCompletionEffect.of(null) });</span><span class="s3">\n            </span><span class="s1">logException(this.view.state, err);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scheduleAccept() {</span><span class="s3">\n        </span><span class="s1">if (this.running.every(q =&gt; q.done !== undefined))</span><span class="s3">\n            </span><span class="s1">this.accept();</span><span class="s3">\n        </span><span class="s1">else if (this.debounceAccept &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.debounceAccept = setTimeout(() =&gt; this.accept(), this.view.state.facet(completionConfig).updateSyncTime);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// For each finished query in this.running, try to create a result</span><span class="s3">\n    </span><span class="s1">// or, if appropriate, restart the query.</span><span class="s3">\n    </span><span class="s1">accept() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (this.debounceAccept &gt; -1)</span><span class="s3">\n            </span><span class="s1">clearTimeout(this.debounceAccept);</span><span class="s3">\n        </span><span class="s1">this.debounceAccept = -1;</span><span class="s3">\n        </span><span class="s1">let updated = [];</span><span class="s3">\n        </span><span class="s1">let conf = this.view.state.facet(completionConfig), cState = this.view.state.field(completionState);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.running.length; i++) {</span><span class="s3">\n            </span><span class="s1">let query = this.running[i];</span><span class="s3">\n            </span><span class="s1">if (query.done === undefined)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">this.running.splice(i--, 1);</span><span class="s3">\n            </span><span class="s1">if (query.done) {</span><span class="s3">\n                </span><span class="s1">let pos = cur(query.updates.length ? query.updates[0].startState : this.view.state);</span><span class="s3">\n                </span><span class="s1">let limit = Math.min(pos, query.done.from + (query.active.explicit ? 0 : 1));</span><span class="s3">\n                </span><span class="s1">let active = new ActiveResult(query.active.source, query.active.explicit, limit, query.done, query.done.from, (_a = query.done.to) !== null &amp;&amp; _a !== void 0 ? _a : pos);</span><span class="s3">\n                </span><span class="s1">// Replay the transactions that happened since the start of</span><span class="s3">\n                </span><span class="s1">// the request and see if that preserves the result</span><span class="s3">\n                </span><span class="s1">for (let tr of query.updates)</span><span class="s3">\n                    </span><span class="s1">active = active.update(tr, conf);</span><span class="s3">\n                </span><span class="s1">if (active.hasResult()) {</span><span class="s3">\n                    </span><span class="s1">updated.push(active);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let current = cState.active.find(a =&gt; a.source == query.active.source);</span><span class="s3">\n            </span><span class="s1">if (current &amp;&amp; current.isPending) {</span><span class="s3">\n                </span><span class="s1">if (query.done == null) {</span><span class="s3">\n                    </span><span class="s1">// Explicitly failed. Should clear the pending status if it</span><span class="s3">\n                    </span><span class="s1">// hasn't been re-set in the meantime.</span><span class="s3">\n                    </span><span class="s1">let active = new ActiveSource(query.active.source, 0 /* State.Inactive */);</span><span class="s3">\n                    </span><span class="s1">for (let tr of query.updates)</span><span class="s3">\n                        </span><span class="s1">active = active.update(tr, conf);</span><span class="s3">\n                    </span><span class="s1">if (!active.isPending)</span><span class="s3">\n                        </span><span class="s1">updated.push(active);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Cleared by subsequent transactions. Restart.</span><span class="s3">\n                    </span><span class="s1">this.startQuery(current);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (updated.length || cState.open &amp;&amp; cState.open.disabled)</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({ effects: setActiveEffect.of(updated) });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">eventHandlers: {</span><span class="s3">\n        </span><span class="s1">blur(event) {</span><span class="s3">\n            </span><span class="s1">let state = this.view.state.field(completionState, false);</span><span class="s3">\n            </span><span class="s1">if (state &amp;&amp; state.tooltip &amp;&amp; this.view.state.facet(completionConfig).closeOnBlur) {</span><span class="s3">\n                </span><span class="s1">let dialog = state.open &amp;&amp; getTooltip(this.view, state.open.tooltip);</span><span class="s3">\n                </span><span class="s1">if (!dialog || !dialog.dom.contains(event.relatedTarget))</span><span class="s3">\n                    </span><span class="s1">setTimeout(() =&gt; this.view.dispatch({ effects: closeCompletionEffect.of(null) }), 10);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">compositionstart() {</span><span class="s3">\n            </span><span class="s1">this.composing = 1 /* CompositionState.Started */;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">compositionend() {</span><span class="s3">\n            </span><span class="s1">if (this.composing == 3 /* CompositionState.ChangedAndMoved */) {</span><span class="s3">\n                </span><span class="s1">// Safari fires compositionend events synchronously, possibly</span><span class="s3">\n                </span><span class="s1">// from inside an update, so dispatch asynchronously to avoid reentrancy</span><span class="s3">\n                </span><span class="s1">setTimeout(() =&gt; this.view.dispatch({ effects: startCompletionEffect.of(false) }), 20);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.composing = 0 /* CompositionState.None */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const windows = typeof navigator == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /*@__PURE__*//Win/.test(navigator.platform);</span><span class="s3">\n</span><span class="s1">const commitCharacters = /*@__PURE__*/Prec.highest(/*@__PURE__*/EditorView.domEventHandlers({</span><span class="s3">\n    </span><span class="s1">keydown(event, view) {</span><span class="s3">\n        </span><span class="s1">let field = view.state.field(completionState, false);</span><span class="s3">\n        </span><span class="s1">if (!field || !field.open || field.open.disabled || field.open.selected &lt; 0 ||</span><span class="s3">\n            </span><span class="s1">event.key.length &gt; 1 || event.ctrlKey &amp;&amp; !(windows &amp;&amp; event.altKey) || event.metaKey)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let option = field.open.options[field.open.selected];</span><span class="s3">\n        </span><span class="s1">let result = field.active.find(a =&gt; a.source == option.source);</span><span class="s3">\n        </span><span class="s1">let commitChars = option.completion.commitCharacters || result.result.commitCharacters;</span><span class="s3">\n        </span><span class="s1">if (commitChars &amp;&amp; commitChars.indexOf(event.key) &gt; -1)</span><span class="s3">\n            </span><span class="s1">applyCompletion(view, option);</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n\n</span><span class="s1">const baseTheme = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-tooltip.cm-tooltip-autocomplete</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; &gt; ul</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">fontFamily: </span><span class="s3">\&quot;</span><span class="s1">monospace</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">nowrap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">overflow: </span><span class="s3">\&quot;</span><span class="s1">hidden auto</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">maxWidth_fallback: </span><span class="s3">\&quot;</span><span class="s1">700px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">maxWidth: </span><span class="s3">\&quot;</span><span class="s1">min(700px, 95vw)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">minWidth: </span><span class="s3">\&quot;</span><span class="s1">250px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">maxHeight: </span><span class="s3">\&quot;</span><span class="s1">10em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">listStyle: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">margin: 0,</span><span class="s3">\n            </span><span class="s1">padding: 0,</span><span class="s3">\n            \&quot;</span><span class="s1">&amp; &gt; li, &amp; &gt; completion-section</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">1px 3px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">lineHeight: 1.2</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            \&quot;</span><span class="s1">&amp; &gt; li</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">overflowX: </span><span class="s3">\&quot;</span><span class="s1">hidden</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">textOverflow: </span><span class="s3">\&quot;</span><span class="s1">ellipsis</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">cursor: </span><span class="s3">\&quot;</span><span class="s1">pointer</span><span class="s3">\&quot;\n            </span><span class="s1">},</span><span class="s3">\n            \&quot;</span><span class="s1">&amp; &gt; completion-section</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n                </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">list-item</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">borderBottom: </span><span class="s3">\&quot;</span><span class="s1">1px solid silver</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">paddingLeft: </span><span class="s3">\&quot;</span><span class="s1">0.5em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">opacity: 0.7</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-tooltip-autocomplete ul li[aria-selected]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#17c</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-tooltip-autocomplete-disabled ul li[aria-selected]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#777</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-tooltip-autocomplete ul li[aria-selected]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#347</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">white</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">background: </span><span class="s3">\&quot;</span><span class="s1">#444</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">content: '</span><span class="s3">\&quot;</span><span class="s1">···</span><span class="s3">\&quot;</span><span class="s1">',</span><span class="s3">\n        </span><span class="s1">opacity: 0.5,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">textAlign: </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-tooltip.cm-completionInfo</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">3px 9px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: </span><span class="s3">\&quot;</span><span class="s1">max-content</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">maxWidth: `${400 /* Info.Width */}px`,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">border-box</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">pre-line</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionInfo.cm-completionInfo-left</span><span class="s3">\&quot;</span><span class="s1">: { right: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionInfo.cm-completionInfo-right</span><span class="s3">\&quot;</span><span class="s1">: { left: </span><span class="s3">\&quot;</span><span class="s1">100%</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionInfo.cm-completionInfo-left-narrow</span><span class="s3">\&quot;</span><span class="s1">: { right: `${30 /* Info.Margin */}px` },</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionInfo.cm-completionInfo-right-narrow</span><span class="s3">\&quot;</span><span class="s1">: { left: `${30 /* Info.Margin */}px` },</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-snippetField</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#00000022</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-snippetField</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#ffffff22</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-snippetFieldPosition</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">text-top</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: 0,</span><span class="s3">\n        </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">1.15em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">inline-block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">margin: </span><span class="s3">\&quot;</span><span class="s1">0 -0.7px -.7em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">borderLeft: </span><span class="s3">\&quot;</span><span class="s1">1.4px dotted #888</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionMatchedText</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">textDecoration: </span><span class="s3">\&quot;</span><span class="s1">underline</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionDetail</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">marginLeft: </span><span class="s3">\&quot;</span><span class="s1">0.5em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">fontStyle: </span><span class="s3">\&quot;</span><span class="s1">italic</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">fontSize: </span><span class="s3">\&quot;</span><span class="s1">90%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">width: </span><span class="s3">\&quot;</span><span class="s1">.8em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">display: </span><span class="s3">\&quot;</span><span class="s1">inline-block</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">textAlign: </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">paddingRight: </span><span class="s3">\&quot;</span><span class="s1">.6em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">opacity: </span><span class="s3">\&quot;</span><span class="s1">0.6</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">boxSizing: </span><span class="s3">\&quot;</span><span class="s1">content-box</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-function, .cm-completionIcon-method</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'ƒ'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-class</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'○'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-interface</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'◌'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-variable</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'𝑥'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-constant</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'𝐶'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-type</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'𝑡'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-enum</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'∪'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-property</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'□'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-keyword</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'🔑</span><span class="s3">\\</span><span class="s1">uFE0E'</span><span class="s3">\&quot; </span><span class="s1">} // Disable emoji rendering</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-namespace</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'▢'</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-completionIcon-text</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        \&quot;</span><span class="s1">&amp;:after</span><span class="s3">\&quot;</span><span class="s1">: { content: </span><span class="s3">\&quot;</span><span class="s1">'abc'</span><span class="s3">\&quot;</span><span class="s1">, fontSize: </span><span class="s3">\&quot;</span><span class="s1">50%</span><span class="s3">\&quot;</span><span class="s1">, verticalAlign: </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">class FieldPos {</span><span class="s3">\n    </span><span class="s1">constructor(field, line, from, to) {</span><span class="s3">\n        </span><span class="s1">this.field = field;</span><span class="s3">\n        </span><span class="s1">this.line = line;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class FieldRange {</span><span class="s3">\n    </span><span class="s1">constructor(field, from, to) {</span><span class="s3">\n        </span><span class="s1">this.field = field;</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(changes) {</span><span class="s3">\n        </span><span class="s1">let from = changes.mapPos(this.from, -1, MapMode.TrackDel);</span><span class="s3">\n        </span><span class="s1">let to = changes.mapPos(this.to, 1, MapMode.TrackDel);</span><span class="s3">\n        </span><span class="s1">return from == null || to == null ? null : new FieldRange(this.field, from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Snippet {</span><span class="s3">\n    </span><span class="s1">constructor(lines, fieldPositions) {</span><span class="s3">\n        </span><span class="s1">this.lines = lines;</span><span class="s3">\n        </span><span class="s1">this.fieldPositions = fieldPositions;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">instantiate(state, pos) {</span><span class="s3">\n        </span><span class="s1">let text = [], lineStart = [pos];</span><span class="s3">\n        </span><span class="s1">let lineObj = state.doc.lineAt(pos), baseIndent = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(lineObj.text)[0];</span><span class="s3">\n        </span><span class="s1">for (let line of this.lines) {</span><span class="s3">\n            </span><span class="s1">if (text.length) {</span><span class="s3">\n                </span><span class="s1">let indent = baseIndent, tabs = /^</span><span class="s3">\\</span><span class="s1">t*/.exec(line)[0].length;</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; tabs; i++)</span><span class="s3">\n                    </span><span class="s1">indent += state.facet(indentUnit);</span><span class="s3">\n                </span><span class="s1">lineStart.push(pos + indent.length - tabs);</span><span class="s3">\n                </span><span class="s1">line = indent + line.slice(tabs);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">text.push(line);</span><span class="s3">\n            </span><span class="s1">pos += line.length + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let ranges = this.fieldPositions.map(pos =&gt; new FieldRange(pos.field, lineStart[pos.line] + pos.from, lineStart[pos.line] + pos.to));</span><span class="s3">\n        </span><span class="s1">return { text, ranges };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static parse(template) {</span><span class="s3">\n        </span><span class="s1">let fields = [];</span><span class="s3">\n        </span><span class="s1">let lines = [], positions = [], m;</span><span class="s3">\n        </span><span class="s1">for (let line of template.split(/</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n/)) {</span><span class="s3">\n            </span><span class="s1">while (m = /[#$]</span><span class="s3">\\</span><span class="s1">{(?:(</span><span class="s3">\\</span><span class="s1">d+)(?::([^}]*))?|((?:</span><span class="s3">\\\\</span><span class="s1">[{}]|[^}])*))</span><span class="s3">\\</span><span class="s1">}/.exec(line)) {</span><span class="s3">\n                </span><span class="s1">let seq = m[1] ? +m[1] : null, rawName = m[2] || m[3] || </span><span class="s3">\&quot;\&quot;</span><span class="s1">, found = -1;</span><span class="s3">\n                </span><span class="s1">let name = rawName.replace(/</span><span class="s3">\\\\</span><span class="s1">[{}]/g, m =&gt; m[1]);</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; fields.length; i++) {</span><span class="s3">\n                    </span><span class="s1">if (seq != null ? fields[i].seq == seq : name ? fields[i].name == name : false)</span><span class="s3">\n                        </span><span class="s1">found = i;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (found &lt; 0) {</span><span class="s3">\n                    </span><span class="s1">let i = 0;</span><span class="s3">\n                    </span><span class="s1">while (i &lt; fields.length &amp;&amp; (seq == null || (fields[i].seq != null &amp;&amp; fields[i].seq &lt; seq)))</span><span class="s3">\n                        </span><span class="s1">i++;</span><span class="s3">\n                    </span><span class="s1">fields.splice(i, 0, { seq, name });</span><span class="s3">\n                    </span><span class="s1">found = i;</span><span class="s3">\n                    </span><span class="s1">for (let pos of positions)</span><span class="s3">\n                        </span><span class="s1">if (pos.field &gt;= found)</span><span class="s3">\n                            </span><span class="s1">pos.field++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">positions.push(new FieldPos(found, lines.length, m.index, m.index + name.length));</span><span class="s3">\n                </span><span class="s1">line = line.slice(0, m.index) + rawName + line.slice(m.index + m[0].length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">line = line.replace(/</span><span class="s3">\\\\</span><span class="s1">([{}])/g, (_, brace, index) =&gt; {</span><span class="s3">\n                </span><span class="s1">for (let pos of positions)</span><span class="s3">\n                    </span><span class="s1">if (pos.line == lines.length &amp;&amp; pos.from &gt; index) {</span><span class="s3">\n                        </span><span class="s1">pos.from--;</span><span class="s3">\n                        </span><span class="s1">pos.to--;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return brace;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">lines.push(line);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Snippet(lines, positions);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let fieldMarker = /*@__PURE__*/Decoration.widget({ widget: /*@__PURE__*/new class extends WidgetType {</span><span class="s3">\n        </span><span class="s1">toDOM() {</span><span class="s3">\n            </span><span class="s1">let span = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">span.className = </span><span class="s3">\&quot;</span><span class="s1">cm-snippetFieldPosition</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">return span;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">ignoreEvent() { return false; }</span><span class="s3">\n    </span><span class="s1">} });</span><span class="s3">\n</span><span class="s1">let fieldRange = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-snippetField</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">class ActiveSnippet {</span><span class="s3">\n    </span><span class="s1">constructor(ranges, active) {</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.active = active;</span><span class="s3">\n        </span><span class="s1">this.deco = Decoration.set(ranges.map(r =&gt; (r.from == r.to ? fieldMarker : fieldRange).range(r.from, r.to)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(changes) {</span><span class="s3">\n        </span><span class="s1">let ranges = [];</span><span class="s3">\n        </span><span class="s1">for (let r of this.ranges) {</span><span class="s3">\n            </span><span class="s1">let mapped = r.map(changes);</span><span class="s3">\n            </span><span class="s1">if (!mapped)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">ranges.push(mapped);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new ActiveSnippet(ranges, this.active);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">selectionInsideField(sel) {</span><span class="s3">\n        </span><span class="s1">return sel.ranges.every(range =&gt; this.ranges.some(r =&gt; r.field == this.active &amp;&amp; r.from &lt;= range.from &amp;&amp; r.to &gt;= range.to));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const setActive = /*@__PURE__*/StateEffect.define({</span><span class="s3">\n    </span><span class="s1">map(value, changes) { return value &amp;&amp; value.map(changes); }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const moveToField = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const snippetState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return null; },</span><span class="s3">\n    </span><span class="s1">update(value, tr) {</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n            </span><span class="s1">if (effect.is(setActive))</span><span class="s3">\n                </span><span class="s1">return effect.value;</span><span class="s3">\n            </span><span class="s1">if (effect.is(moveToField) &amp;&amp; value)</span><span class="s3">\n                </span><span class="s1">return new ActiveSnippet(value.ranges, effect.value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (value &amp;&amp; tr.docChanged)</span><span class="s3">\n            </span><span class="s1">value = value.map(tr.changes);</span><span class="s3">\n        </span><span class="s1">if (value &amp;&amp; tr.selection &amp;&amp; !value.selectionInsideField(tr.selection))</span><span class="s3">\n            </span><span class="s1">value = null;</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; EditorView.decorations.from(f, val =&gt; val ? val.deco : Decoration.none)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function fieldSelection(ranges, field) {</span><span class="s3">\n    </span><span class="s1">return EditorSelection.create(ranges.filter(r =&gt; r.field == field).map(r =&gt; EditorSelection.range(r.from, r.to)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Convert a snippet template to a function that can</span><span class="s3">\n</span><span class="s1">[apply](https://codemirror.net/6/docs/ref/#autocomplete.Completion.apply) it. Snippets are written</span><span class="s3">\n</span><span class="s1">using syntax like this:</span><span class="s3">\n\n    \&quot;</span><span class="s1">for (let ${index} = 0; ${index} &lt; ${end}; ${index}++) {</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">t${}</span><span class="s3">\\</span><span class="s1">n}</span><span class="s3">\&quot;\n\n</span><span class="s1">Each `${}` placeholder (you may also use `#{}`) indicates a field</span><span class="s3">\n</span><span class="s1">that the user can fill in. Its name, if any, will be the default</span><span class="s3">\n</span><span class="s1">content for the field.</span><span class="s3">\n\n</span><span class="s1">When the snippet is activated by calling the returned function,</span><span class="s3">\n</span><span class="s1">the code is inserted at the given position. Newlines in the</span><span class="s3">\n</span><span class="s1">template are indented by the indentation of the start line, plus</span><span class="s3">\n</span><span class="s1">one [indent unit](https://codemirror.net/6/docs/ref/#language.indentUnit) per tab character after</span><span class="s3">\n</span><span class="s1">the newline.</span><span class="s3">\n\n</span><span class="s1">On activation, (all instances of) the first field are selected.</span><span class="s3">\n</span><span class="s1">The user can move between fields with Tab and Shift-Tab as long as</span><span class="s3">\n</span><span class="s1">the fields are active. Moving to the last field or moving the</span><span class="s3">\n</span><span class="s1">cursor out of the current field deactivates the fields.</span><span class="s3">\n\n</span><span class="s1">The order of fields defaults to textual order, but you can add</span><span class="s3">\n</span><span class="s1">numbers to placeholders (`${1}` or `${1:defaultText}`) to provide</span><span class="s3">\n</span><span class="s1">a custom order.</span><span class="s3">\n\n</span><span class="s1">To include a literal `{` or `}` in your template, put a backslash</span><span class="s3">\n</span><span class="s1">in front of it. This will be removed and the brace will not be</span><span class="s3">\n</span><span class="s1">interpreted as indicating a placeholder.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function snippet(template) {</span><span class="s3">\n    </span><span class="s1">let snippet = Snippet.parse(template);</span><span class="s3">\n    </span><span class="s1">return (editor, completion, from, to) =&gt; {</span><span class="s3">\n        </span><span class="s1">let { text, ranges } = snippet.instantiate(editor.state, from);</span><span class="s3">\n        </span><span class="s1">let { main } = editor.state.selection;</span><span class="s3">\n        </span><span class="s1">let spec = {</span><span class="s3">\n            </span><span class="s1">changes: { from, to: to == main.from ? main.to : to, insert: Text.of(text) },</span><span class="s3">\n            </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n            </span><span class="s1">annotations: completion ? [pickedCompletion.of(completion), Transaction.userEvent.of(</span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot;</span><span class="s1">)] : undefined</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (ranges.length)</span><span class="s3">\n            </span><span class="s1">spec.selection = fieldSelection(ranges, 0);</span><span class="s3">\n        </span><span class="s1">if (ranges.some(r =&gt; r.field &gt; 0)) {</span><span class="s3">\n            </span><span class="s1">let active = new ActiveSnippet(ranges, 0);</span><span class="s3">\n            </span><span class="s1">let effects = spec.effects = [setActive.of(active)];</span><span class="s3">\n            </span><span class="s1">if (editor.state.field(snippetState, false) === undefined)</span><span class="s3">\n                </span><span class="s1">effects.push(StateEffect.appendConfig.of([snippetState, addSnippetKeymap, snippetPointerHandler, baseTheme]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">editor.dispatch(editor.state.update(spec));</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function moveField(dir) {</span><span class="s3">\n    </span><span class="s1">return ({ state, dispatch }) =&gt; {</span><span class="s3">\n        </span><span class="s1">let active = state.field(snippetState, false);</span><span class="s3">\n        </span><span class="s1">if (!active || dir &lt; 0 &amp;&amp; active.active == 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let next = active.active + dir, last = dir &gt; 0 &amp;&amp; !active.ranges.some(r =&gt; r.field == next + dir);</span><span class="s3">\n        </span><span class="s1">dispatch(state.update({</span><span class="s3">\n            </span><span class="s1">selection: fieldSelection(active.ranges, next),</span><span class="s3">\n            </span><span class="s1">effects: setActive.of(last ? null : new ActiveSnippet(active.ranges, next)),</span><span class="s3">\n            </span><span class="s1">scrollIntoView: true</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A command that clears the active snippet, if any.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const clearSnippet = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let active = state.field(snippetState, false);</span><span class="s3">\n    </span><span class="s1">if (!active)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ effects: setActive.of(null) }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move to the next snippet field, if available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const nextSnippetField = /*@__PURE__*/moveField(1);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move to the previous snippet field, if available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const prevSnippetField = /*@__PURE__*/moveField(-1);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Check if there is an active snippet with a next field for</span><span class="s3">\n</span><span class="s1">`nextSnippetField` to move to.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasNextSnippetField(state) {</span><span class="s3">\n    </span><span class="s1">let active = state.field(snippetState, false);</span><span class="s3">\n    </span><span class="s1">return !!(active &amp;&amp; active.ranges.some(r =&gt; r.field == active.active + 1));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns true if there is an active snippet and a previous field</span><span class="s3">\n</span><span class="s1">for `prevSnippetField` to move to.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hasPrevSnippetField(state) {</span><span class="s3">\n    </span><span class="s1">let active = state.field(snippetState, false);</span><span class="s3">\n    </span><span class="s1">return !!(active &amp;&amp; active.active &gt; 0);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultSnippetKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Tab</span><span class="s3">\&quot;</span><span class="s1">, run: nextSnippetField, shift: prevSnippetField },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">, run: clearSnippet }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet that can be used to configure the key bindings used by</span><span class="s3">\n</span><span class="s1">snippets. The default binds Tab to</span><span class="s3">\n</span><span class="s1">[`nextSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.nextSnippetField), Shift-Tab to</span><span class="s3">\n</span><span class="s1">[`prevSnippetField`](https://codemirror.net/6/docs/ref/#autocomplete.prevSnippetField), and Escape</span><span class="s3">\n</span><span class="s1">to [`clearSnippet`](https://codemirror.net/6/docs/ref/#autocomplete.clearSnippet).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const snippetKeymap = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(maps) { return maps.length ? maps[0] : defaultSnippetKeymap; }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const addSnippetKeymap = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.compute([snippetKeymap], state =&gt; state.facet(snippetKeymap)));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a completion from a snippet. Returns an object with the</span><span class="s3">\n</span><span class="s1">properties from `completion`, plus an `apply` function that</span><span class="s3">\n</span><span class="s1">applies the snippet.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function snippetCompletion(template, completion) {</span><span class="s3">\n    </span><span class="s1">return Object.assign(Object.assign({}, completion), { apply: snippet(template) });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const snippetPointerHandler = /*@__PURE__*/EditorView.domEventHandlers({</span><span class="s3">\n    </span><span class="s1">mousedown(event, view) {</span><span class="s3">\n        </span><span class="s1">let active = view.state.field(snippetState, false), pos;</span><span class="s3">\n        </span><span class="s1">if (!active || (pos = view.posAtCoords({ x: event.clientX, y: event.clientY })) == null)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let match = active.ranges.find(r =&gt; r.from &lt;= pos &amp;&amp; r.to &gt;= pos);</span><span class="s3">\n        </span><span class="s1">if (!match || match.field == active.active)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">view.dispatch({</span><span class="s3">\n            </span><span class="s1">selection: fieldSelection(active.ranges, match.field),</span><span class="s3">\n            </span><span class="s1">effects: setActive.of(active.ranges.some(r =&gt; r.field &gt; match.field)</span><span class="s3">\n                </span><span class="s1">? new ActiveSnippet(active.ranges, match.field) : null),</span><span class="s3">\n            </span><span class="s1">scrollIntoView: true</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">function wordRE(wordChars) {</span><span class="s3">\n    </span><span class="s1">let escaped = wordChars.replace(/[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\\\</span><span class="s1">]/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">$&amp;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">return new RegExp(`[</span><span class="s3">\\\\</span><span class="s1">p{Alphabetic}</span><span class="s3">\\\\</span><span class="s1">p{Number}_${escaped}]+`, </span><span class="s3">\&quot;</span><span class="s1">ug</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_a) {</span><span class="s3">\n        </span><span class="s1">return new RegExp(`[</span><span class="s3">\\</span><span class="s1">w${escaped}]`, </span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapRE(re, f) {</span><span class="s3">\n    </span><span class="s1">return new RegExp(f(re.source), re.unicode ? </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const wordCaches = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">function wordCache(wordChars) {</span><span class="s3">\n    </span><span class="s1">return wordCaches[wordChars] || (wordCaches[wordChars] = new WeakMap);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function storeWords(doc, wordRE, result, seen, ignoreAt) {</span><span class="s3">\n    </span><span class="s1">for (let lines = doc.iterLines(), pos = 0; !lines.next().done;) {</span><span class="s3">\n        </span><span class="s1">let { value } = lines, m;</span><span class="s3">\n        </span><span class="s1">wordRE.lastIndex = 0;</span><span class="s3">\n        </span><span class="s1">while (m = wordRE.exec(value)) {</span><span class="s3">\n            </span><span class="s1">if (!seen[m[0]] &amp;&amp; pos + m.index != ignoreAt) {</span><span class="s3">\n                </span><span class="s1">result.push({ type: </span><span class="s3">\&quot;</span><span class="s1">text</span><span class="s3">\&quot;</span><span class="s1">, label: m[0] });</span><span class="s3">\n                </span><span class="s1">seen[m[0]] = true;</span><span class="s3">\n                </span><span class="s1">if (result.length &gt;= 2000 /* C.MaxList */)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos += value.length + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function collectWords(doc, cache, wordRE, to, ignoreAt) {</span><span class="s3">\n    </span><span class="s1">let big = doc.length &gt;= 1000 /* C.MinCacheLen */;</span><span class="s3">\n    </span><span class="s1">let cached = big &amp;&amp; cache.get(doc);</span><span class="s3">\n    </span><span class="s1">if (cached)</span><span class="s3">\n        </span><span class="s1">return cached;</span><span class="s3">\n    </span><span class="s1">let result = [], seen = Object.create(null);</span><span class="s3">\n    </span><span class="s1">if (doc.children) {</span><span class="s3">\n        </span><span class="s1">let pos = 0;</span><span class="s3">\n        </span><span class="s1">for (let ch of doc.children) {</span><span class="s3">\n            </span><span class="s1">if (ch.length &gt;= 1000 /* C.MinCacheLen */) {</span><span class="s3">\n                </span><span class="s1">for (let c of collectWords(ch, cache, wordRE, to - pos, ignoreAt - pos)) {</span><span class="s3">\n                    </span><span class="s1">if (!seen[c.label]) {</span><span class="s3">\n                        </span><span class="s1">seen[c.label] = true;</span><span class="s3">\n                        </span><span class="s1">result.push(c);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">storeWords(ch, wordRE, result, seen, ignoreAt - pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos += ch.length + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">storeWords(doc, wordRE, result, seen, ignoreAt);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (big &amp;&amp; result.length &lt; 2000 /* C.MaxList */)</span><span class="s3">\n        </span><span class="s1">cache.set(doc, result);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A completion source that will scan the document for words (using a</span><span class="s3">\n</span><span class="s1">[character categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer)), and</span><span class="s3">\n</span><span class="s1">return those as completions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const completeAnyWord = context =&gt; {</span><span class="s3">\n    </span><span class="s1">let wordChars = context.state.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">wordChars</span><span class="s3">\&quot;</span><span class="s1">, context.pos).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">let re = wordRE(wordChars);</span><span class="s3">\n    </span><span class="s1">let token = context.matchBefore(mapRE(re, s =&gt; s + </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">if (!token &amp;&amp; !context.explicit)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let from = token ? token.from : context.pos;</span><span class="s3">\n    </span><span class="s1">let options = collectWords(context.state.doc, wordCache(wordChars), re, 50000 /* C.Range */, from);</span><span class="s3">\n    </span><span class="s1">return { from, options, validFor: mapRE(re, s =&gt; </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot; </span><span class="s1">+ s) };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const defaults = {</span><span class="s3">\n    </span><span class="s1">brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">'],</span><span class="s3">\n    </span><span class="s1">before: </span><span class="s3">\&quot;</span><span class="s1">)]}:;&gt;</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">stringPrefixes: []</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const closeBracketEffect = /*@__PURE__*/StateEffect.define({</span><span class="s3">\n    </span><span class="s1">map(value, mapping) {</span><span class="s3">\n        </span><span class="s1">let mapped = mapping.mapPos(value, -1, MapMode.TrackAfter);</span><span class="s3">\n        </span><span class="s1">return mapped == null ? undefined : mapped;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const closedBracket = /*@__PURE__*/new class extends RangeValue {</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">closedBracket.startSide = 1;</span><span class="s3">\n</span><span class="s1">closedBracket.endSide = -1;</span><span class="s3">\n</span><span class="s1">const bracketState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return RangeSet.empty; },</span><span class="s3">\n    </span><span class="s1">update(value, tr) {</span><span class="s3">\n        </span><span class="s1">value = value.map(tr.changes);</span><span class="s3">\n        </span><span class="s1">if (tr.selection) {</span><span class="s3">\n            </span><span class="s1">let line = tr.state.doc.lineAt(tr.selection.main.head);</span><span class="s3">\n            </span><span class="s1">value = value.update({ filter: from =&gt; from &gt;= line.from &amp;&amp; from &lt;= line.to });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects)</span><span class="s3">\n            </span><span class="s1">if (effect.is(closeBracketEffect))</span><span class="s3">\n                </span><span class="s1">value = value.update({ add: [closedBracket.range(effect.value, effect.value + 1)] });</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Extension to enable bracket-closing behavior. When a closeable</span><span class="s3">\n</span><span class="s1">bracket is typed, its closing bracket is immediately inserted</span><span class="s3">\n</span><span class="s1">after the cursor. When closing a bracket directly in front of a</span><span class="s3">\n</span><span class="s1">closing bracket inserted by the extension, the cursor moves over</span><span class="s3">\n</span><span class="s1">that bracket.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function closeBrackets() {</span><span class="s3">\n    </span><span class="s1">return [inputHandler, bracketState];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const definedClosing = </span><span class="s3">\&quot;</span><span class="s1">()[]{}&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function closing(ch) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; definedClosing.length; i += 2)</span><span class="s3">\n        </span><span class="s1">if (definedClosing.charCodeAt(i) == ch)</span><span class="s3">\n            </span><span class="s1">return definedClosing.charAt(i + 1);</span><span class="s3">\n    </span><span class="s1">return fromCodePoint(ch &lt; 128 ? ch : ch + 1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function config(state, pos) {</span><span class="s3">\n    </span><span class="s1">return state.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">closeBrackets</span><span class="s3">\&quot;</span><span class="s1">, pos)[0] || defaults;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const android = typeof navigator == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /*@__PURE__*//Android</span><span class="s3">\\</span><span class="s1">b/.test(navigator.userAgent);</span><span class="s3">\n</span><span class="s1">const inputHandler = /*@__PURE__*/EditorView.inputHandler.of((view, from, to, insert) =&gt; {</span><span class="s3">\n    </span><span class="s1">if ((android ? view.composing : view.compositionStarted) || view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let sel = view.state.selection.main;</span><span class="s3">\n    </span><span class="s1">if (insert.length &gt; 2 || insert.length == 2 &amp;&amp; codePointSize(codePointAt(insert, 0)) == 1 ||</span><span class="s3">\n        </span><span class="s1">from != sel.from || to != sel.to)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let tr = insertBracket(view.state, insert);</span><span class="s3">\n    </span><span class="s1">if (!tr)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">view.dispatch(tr);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Command that implements deleting a pair of matching brackets when</span><span class="s3">\n</span><span class="s1">the cursor is between them.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const deleteBracketPair = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let conf = config(state, state.selection.main.head);</span><span class="s3">\n    </span><span class="s1">let tokens = conf.brackets || defaults.brackets;</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (range.empty) {</span><span class="s3">\n            </span><span class="s1">let before = prevChar(state.doc, range.head);</span><span class="s3">\n            </span><span class="s1">for (let token of tokens) {</span><span class="s3">\n                </span><span class="s1">if (token == before &amp;&amp; nextChar(state.doc, range.head) == closing(codePointAt(token, 0)))</span><span class="s3">\n                    </span><span class="s1">return { changes: { from: range.head - token.length, to: range.head + token.length },</span><span class="s3">\n                        </span><span class="s1">range: EditorSelection.cursor(range.head - token.length) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { range: dont = range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!dont)</span><span class="s3">\n        </span><span class="s1">dispatch(state.update(changes, { scrollIntoView: true, userEvent: </span><span class="s3">\&quot;</span><span class="s1">delete.backward</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return !dont;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Close-brackets related key bindings. Binds Backspace to</span><span class="s3">\n</span><span class="s1">[`deleteBracketPair`](https://codemirror.net/6/docs/ref/#autocomplete.deleteBracketPair).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const closeBracketsKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Backspace</span><span class="s3">\&quot;</span><span class="s1">, run: deleteBracketPair }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Implements the extension's behavior on text insertion. If the</span><span class="s3">\n</span><span class="s1">given string counts as a bracket in the language around the</span><span class="s3">\n</span><span class="s1">selection, and replacing the selection with it requires custom</span><span class="s3">\n</span><span class="s1">behavior (inserting a closing version or skipping past a</span><span class="s3">\n</span><span class="s1">previously-closed bracket), this function returns a transaction</span><span class="s3">\n</span><span class="s1">representing that custom behavior. (You only need this if you want</span><span class="s3">\n</span><span class="s1">to programmatically insert brackets—the</span><span class="s3">\n</span><span class="s1">[`closeBrackets`](https://codemirror.net/6/docs/ref/#autocomplete.closeBrackets) extension will</span><span class="s3">\n</span><span class="s1">take care of running this for user input.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function insertBracket(state, bracket) {</span><span class="s3">\n    </span><span class="s1">let conf = config(state, state.selection.main.head);</span><span class="s3">\n    </span><span class="s1">let tokens = conf.brackets || defaults.brackets;</span><span class="s3">\n    </span><span class="s1">for (let tok of tokens) {</span><span class="s3">\n        </span><span class="s1">let closed = closing(codePointAt(tok, 0));</span><span class="s3">\n        </span><span class="s1">if (bracket == tok)</span><span class="s3">\n            </span><span class="s1">return closed == tok ? handleSame(state, tok, tokens.indexOf(tok + tok + tok) &gt; -1, conf)</span><span class="s3">\n                </span><span class="s1">: handleOpen(state, tok, closed, conf.before || defaults.before);</span><span class="s3">\n        </span><span class="s1">if (bracket == closed &amp;&amp; closedBracketAt(state, state.selection.main.from))</span><span class="s3">\n            </span><span class="s1">return handleClose(state, tok, closed);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function closedBracketAt(state, pos) {</span><span class="s3">\n    </span><span class="s1">let found = false;</span><span class="s3">\n    </span><span class="s1">state.field(bracketState).between(0, state.doc.length, from =&gt; {</span><span class="s3">\n        </span><span class="s1">if (from == pos)</span><span class="s3">\n            </span><span class="s1">found = true;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nextChar(doc, pos) {</span><span class="s3">\n    </span><span class="s1">let next = doc.sliceString(pos, pos + 2);</span><span class="s3">\n    </span><span class="s1">return next.slice(0, codePointSize(codePointAt(next, 0)));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function prevChar(doc, pos) {</span><span class="s3">\n    </span><span class="s1">let prev = doc.sliceString(pos - 2, pos);</span><span class="s3">\n    </span><span class="s1">return codePointSize(codePointAt(prev, 0)) == prev.length ? prev : prev.slice(1);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function handleOpen(state, open, close, closeBefore) {</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!range.empty)</span><span class="s3">\n            </span><span class="s1">return { changes: [{ insert: open, from: range.from }, { insert: close, from: range.to }],</span><span class="s3">\n                </span><span class="s1">effects: closeBracketEffect.of(range.to + open.length),</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.range(range.anchor + open.length, range.head + open.length) };</span><span class="s3">\n        </span><span class="s1">let next = nextChar(state.doc, range.head);</span><span class="s3">\n        </span><span class="s1">if (!next || /</span><span class="s3">\\</span><span class="s1">s/.test(next) || closeBefore.indexOf(next) &gt; -1)</span><span class="s3">\n            </span><span class="s1">return { changes: { insert: open + close, from: range.head },</span><span class="s3">\n                </span><span class="s1">effects: closeBracketEffect.of(range.head + open.length),</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(range.head + open.length) };</span><span class="s3">\n        </span><span class="s1">return { range: dont = range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return dont ? null : state.update(changes, {</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function handleClose(state, _open, close) {</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (range.empty &amp;&amp; nextChar(state.doc, range.head) == close)</span><span class="s3">\n            </span><span class="s1">return { changes: { from: range.head, to: range.head + close.length, insert: close },</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(range.head + close.length) };</span><span class="s3">\n        </span><span class="s1">return dont = { range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return dont ? null : state.update(changes, {</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Handles cases where the open and close token are the same, and</span><span class="s3">\n</span><span class="s1">// possibly triple quotes (as in `</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">abc</span><span class="s3">\&quot;\&quot;\&quot;</span><span class="s1">`-style quoting).</span><span class="s3">\n</span><span class="s1">function handleSame(state, token, allowTriple, config) {</span><span class="s3">\n    </span><span class="s1">let stringPrefixes = config.stringPrefixes || defaults.stringPrefixes;</span><span class="s3">\n    </span><span class="s1">let dont = null, changes = state.changeByRange(range =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!range.empty)</span><span class="s3">\n            </span><span class="s1">return { changes: [{ insert: token, from: range.from }, { insert: token, from: range.to }],</span><span class="s3">\n                </span><span class="s1">effects: closeBracketEffect.of(range.to + token.length),</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.range(range.anchor + token.length, range.head + token.length) };</span><span class="s3">\n        </span><span class="s1">let pos = range.head, next = nextChar(state.doc, pos), start;</span><span class="s3">\n        </span><span class="s1">if (next == token) {</span><span class="s3">\n            </span><span class="s1">if (nodeStart(state, pos)) {</span><span class="s3">\n                </span><span class="s1">return { changes: { insert: token + token, from: pos },</span><span class="s3">\n                    </span><span class="s1">effects: closeBracketEffect.of(pos + token.length),</span><span class="s3">\n                    </span><span class="s1">range: EditorSelection.cursor(pos + token.length) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (closedBracketAt(state, pos)) {</span><span class="s3">\n                </span><span class="s1">let isTriple = allowTriple &amp;&amp; state.sliceDoc(pos, pos + token.length * 3) == token + token + token;</span><span class="s3">\n                </span><span class="s1">let content = isTriple ? token + token + token : token;</span><span class="s3">\n                </span><span class="s1">return { changes: { from: pos, to: pos + content.length, insert: content },</span><span class="s3">\n                    </span><span class="s1">range: EditorSelection.cursor(pos + content.length) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (allowTriple &amp;&amp; state.sliceDoc(pos - 2 * token.length, pos) == token + token &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(start = canStartStringAt(state, pos - 2 * token.length, stringPrefixes)) &gt; -1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">nodeStart(state, start)) {</span><span class="s3">\n            </span><span class="s1">return { changes: { insert: token + token + token + token, from: pos },</span><span class="s3">\n                </span><span class="s1">effects: closeBracketEffect.of(pos + token.length),</span><span class="s3">\n                </span><span class="s1">range: EditorSelection.cursor(pos + token.length) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (state.charCategorizer(pos)(next) != CharCategory.Word) {</span><span class="s3">\n            </span><span class="s1">if (canStartStringAt(state, pos, stringPrefixes) &gt; -1 &amp;&amp; !probablyInString(state, pos, token, stringPrefixes))</span><span class="s3">\n                </span><span class="s1">return { changes: { insert: token + token, from: pos },</span><span class="s3">\n                    </span><span class="s1">effects: closeBracketEffect.of(pos + token.length),</span><span class="s3">\n                    </span><span class="s1">range: EditorSelection.cursor(pos + token.length) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { range: dont = range };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return dont ? null : state.update(changes, {</span><span class="s3">\n        </span><span class="s1">scrollIntoView: true,</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nodeStart(state, pos) {</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state).resolveInner(pos + 1);</span><span class="s3">\n    </span><span class="s1">return tree.parent &amp;&amp; tree.from == pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function probablyInString(state, pos, quoteToken, prefixes) {</span><span class="s3">\n    </span><span class="s1">let node = syntaxTree(state).resolveInner(pos, -1);</span><span class="s3">\n    </span><span class="s1">let maxPrefix = prefixes.reduce((m, p) =&gt; Math.max(m, p.length), 0);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; 5; i++) {</span><span class="s3">\n        </span><span class="s1">let start = state.sliceDoc(node.from, Math.min(node.to, node.from + quoteToken.length + maxPrefix));</span><span class="s3">\n        </span><span class="s1">let quotePos = start.indexOf(quoteToken);</span><span class="s3">\n        </span><span class="s1">if (!quotePos || quotePos &gt; -1 &amp;&amp; prefixes.indexOf(start.slice(0, quotePos)) &gt; -1) {</span><span class="s3">\n            </span><span class="s1">let first = node.firstChild;</span><span class="s3">\n            </span><span class="s1">while (first &amp;&amp; first.from == node.from &amp;&amp; first.to - first.from &gt; quoteToken.length + quotePos) {</span><span class="s3">\n                </span><span class="s1">if (state.sliceDoc(first.to - quoteToken.length, first.to) == quoteToken)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">first = first.firstChild;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let parent = node.to == pos &amp;&amp; node.parent;</span><span class="s3">\n        </span><span class="s1">if (!parent)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">node = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function canStartStringAt(state, pos, prefixes) {</span><span class="s3">\n    </span><span class="s1">let charCat = state.charCategorizer(pos);</span><span class="s3">\n    </span><span class="s1">if (charCat(state.sliceDoc(pos - 1, pos)) != CharCategory.Word)</span><span class="s3">\n        </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">for (let prefix of prefixes) {</span><span class="s3">\n        </span><span class="s1">let start = pos - prefix.length;</span><span class="s3">\n        </span><span class="s1">if (state.sliceDoc(start, pos) == prefix &amp;&amp; charCat(state.sliceDoc(start - 1, start)) != CharCategory.Word)</span><span class="s3">\n            </span><span class="s1">return start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns an extension that enables autocompletion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function autocompletion(config = {}) {</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">commitCharacters,</span><span class="s3">\n        </span><span class="s1">completionState,</span><span class="s3">\n        </span><span class="s1">completionConfig.of(config),</span><span class="s3">\n        </span><span class="s1">completionPlugin,</span><span class="s3">\n        </span><span class="s1">completionKeymapExt,</span><span class="s3">\n        </span><span class="s1">baseTheme</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Basic keybindings for autocompletion.</span><span class="s3">\n\n </span><span class="s1">- Ctrl-Space (and Alt-</span><span class="s3">\\</span><span class="s1">` on macOS): [`startCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.startCompletion)</span><span class="s3">\n </span><span class="s1">- Escape: [`closeCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.closeCompletion)</span><span class="s3">\n </span><span class="s1">- ArrowDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true)`</span><span class="s3">\n </span><span class="s1">- ArrowUp: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(false)`</span><span class="s3">\n </span><span class="s1">- PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot;</span><span class="s1">)`</span><span class="s3">\n </span><span class="s1">- PageDown: [`moveCompletionSelection`](https://codemirror.net/6/docs/ref/#autocomplete.moveCompletionSelection)`(true, </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot;</span><span class="s1">)`</span><span class="s3">\n </span><span class="s1">- Enter: [`acceptCompletion`](https://codemirror.net/6/docs/ref/#autocomplete.acceptCompletion)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const completionKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Space</span><span class="s3">\&quot;</span><span class="s1">, run: startCompletion },</span><span class="s3">\n    </span><span class="s1">{ mac: </span><span class="s3">\&quot;</span><span class="s1">Alt-`</span><span class="s3">\&quot;</span><span class="s1">, run: startCompletion },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">, run: closeCompletion },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowDown</span><span class="s3">\&quot;</span><span class="s1">, run: /*@__PURE__*/moveCompletionSelection(true) },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">ArrowUp</span><span class="s3">\&quot;</span><span class="s1">, run: /*@__PURE__*/moveCompletionSelection(false) },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">PageDown</span><span class="s3">\&quot;</span><span class="s1">, run: /*@__PURE__*/moveCompletionSelection(true, </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot;</span><span class="s1">) },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">PageUp</span><span class="s3">\&quot;</span><span class="s1">, run: /*@__PURE__*/moveCompletionSelection(false, </span><span class="s3">\&quot;</span><span class="s1">page</span><span class="s3">\&quot;</span><span class="s1">) },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Enter</span><span class="s3">\&quot;</span><span class="s1">, run: acceptCompletion }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const completionKeymapExt = /*@__PURE__*/Prec.highest(/*@__PURE__*/keymap.computeN([completionConfig], state =&gt; state.facet(completionConfig).defaultKeymap ? [completionKeymap] : []));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the current completion status. When completions are available,</span><span class="s3">\n</span><span class="s1">this will return `</span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot;</span><span class="s1">`. When completions are pending (in the</span><span class="s3">\n</span><span class="s1">process of being queried), this returns `</span><span class="s3">\&quot;</span><span class="s1">pending</span><span class="s3">\&quot;</span><span class="s1">`. Otherwise, it</span><span class="s3">\n</span><span class="s1">returns `null`.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function completionStatus(state) {</span><span class="s3">\n    </span><span class="s1">let cState = state.field(completionState, false);</span><span class="s3">\n    </span><span class="s1">return cState &amp;&amp; cState.active.some(a =&gt; a.isPending) ? </span><span class="s3">\&quot;</span><span class="s1">pending</span><span class="s3">\&quot;\n        </span><span class="s1">: cState &amp;&amp; cState.active.some(a =&gt; a.state != 0 /* State.Inactive */) ? </span><span class="s3">\&quot;</span><span class="s1">active</span><span class="s3">\&quot; </span><span class="s1">: null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const completionArrayCache = /*@__PURE__*/new WeakMap;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns the available completions as an array.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function currentCompletions(state) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;</span><span class="s3">\n    </span><span class="s1">if (!open || open.disabled)</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">let completions = completionArrayCache.get(open.options);</span><span class="s3">\n    </span><span class="s1">if (!completions)</span><span class="s3">\n        </span><span class="s1">completionArrayCache.set(open.options, completions = open.options.map(o =&gt; o.completion));</span><span class="s3">\n    </span><span class="s1">return completions;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Return the currently selected completion, if any.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function selectedCompletion(state) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;</span><span class="s3">\n    </span><span class="s1">return open &amp;&amp; !open.disabled &amp;&amp; open.selected &gt;= 0 ? open.options[open.selected].completion : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns the currently selected position in the active completion</span><span class="s3">\n</span><span class="s1">list, or null if no completions are active.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function selectedCompletionIndex(state) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let open = (_a = state.field(completionState, false)) === null || _a === void 0 ? void 0 : _a.open;</span><span class="s3">\n    </span><span class="s1">return open &amp;&amp; !open.disabled &amp;&amp; open.selected &gt;= 0 ? open.selected : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an effect that can be attached to a transaction to change</span><span class="s3">\n</span><span class="s1">the currently selected completion.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setSelectedCompletion(index) {</span><span class="s3">\n    </span><span class="s1">return setSelectedEffect.of(index);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { CompletionContext, acceptCompletion, autocompletion, clearSnippet, closeBrackets, closeBracketsKeymap, closeCompletion, completeAnyWord, completeFromList, completionKeymap, completionStatus, currentCompletions, deleteBracketPair, hasNextSnippetField, hasPrevSnippetField, ifIn, ifNotIn, insertBracket, insertCompletionText, moveCompletionSelection, nextSnippetField, pickedCompletion, prevSnippetField, selectedCompletion, selectedCompletionIndex, setSelectedCompletion, snippet, snippetCompletion, snippetKeymap, startCompletion };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { Parser, NodeProp, NodeSet, NodeType, DefaultBufferLength, Tree, IterMode } from '@lezer/common';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A parse stack. These are used internally by the parser to track</span><span class="s3">\n</span><span class="s1">parsing progress. They also provide some properties and methods</span><span class="s3">\n</span><span class="s1">that external code such as a tokenizer can use to get information</span><span class="s3">\n</span><span class="s1">about the parse state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Stack {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The parse that this stack is part of @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">p, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Holds state, input pos, buffer index triplets for all but the</span><span class="s3">\n    </span><span class="s1">top state @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stack, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current parse state @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">state, </span><span class="s3">\n    </span><span class="s1">// The position at which the next reduce should take place. This</span><span class="s3">\n    </span><span class="s1">// can be less than `this.pos` when skipped expressions have been</span><span class="s3">\n    </span><span class="s1">// added to the stack (which should be moved outside of the next</span><span class="s3">\n    </span><span class="s1">// reduction)</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reducePos, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The input position up to which this stack has parsed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">pos, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The dynamic score of the stack, including dynamic precedence</span><span class="s3">\n    </span><span class="s1">and error-recovery penalties</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">score, </span><span class="s3">\n    </span><span class="s1">// The output buffer. Holds (type, start, end, size) quads</span><span class="s3">\n    </span><span class="s1">// representing nodes created by the parser, where `size` is</span><span class="s3">\n    </span><span class="s1">// amount of buffer array entries covered by this node.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">buffer, </span><span class="s3">\n    </span><span class="s1">// The base offset of the buffer. When stacks are split, the split</span><span class="s3">\n    </span><span class="s1">// instance shared the buffer history with its parent up to</span><span class="s3">\n    </span><span class="s1">// `bufferBase`, which is the absolute offset (including the</span><span class="s3">\n    </span><span class="s1">// offset of previous splits) into the buffer at which this stack</span><span class="s3">\n    </span><span class="s1">// starts writing.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">bufferBase, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">curContext, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lookAhead = 0, </span><span class="s3">\n    </span><span class="s1">// A parent stack from which this was split off, if any. This is</span><span class="s3">\n    </span><span class="s1">// set up so that it always points to a stack that has some</span><span class="s3">\n    </span><span class="s1">// additional buffer content, never to a stack with an equal</span><span class="s3">\n    </span><span class="s1">// `bufferBase`.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parent) {</span><span class="s3">\n        </span><span class="s1">this.p = p;</span><span class="s3">\n        </span><span class="s1">this.stack = stack;</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.reducePos = reducePos;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.score = score;</span><span class="s3">\n        </span><span class="s1">this.buffer = buffer;</span><span class="s3">\n        </span><span class="s1">this.bufferBase = bufferBase;</span><span class="s3">\n        </span><span class="s1">this.curContext = curContext;</span><span class="s3">\n        </span><span class="s1">this.lookAhead = lookAhead;</span><span class="s3">\n        </span><span class="s1">this.parent = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">return `[${this.stack.filter((_, i) =&gt; i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot; </span><span class="s1">+ this.score : </span><span class="s3">\&quot;\&quot;</span><span class="s1">}`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Start an empty stack</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static start(p, state, pos = 0) {</span><span class="s3">\n        </span><span class="s1">let cx = p.parser.context;</span><span class="s3">\n        </span><span class="s1">return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The stack's current [context](#lr.ContextTracker) value, if</span><span class="s3">\n    </span><span class="s1">any. Its type will depend on the context tracker's type</span><span class="s3">\n    </span><span class="s1">parameter, or it will be `null` if there is no context</span><span class="s3">\n    </span><span class="s1">tracker.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get context() { return this.curContext ? this.curContext.context : null; }</span><span class="s3">\n    </span><span class="s1">// Push a state onto the stack, tracking its start position as well</span><span class="s3">\n    </span><span class="s1">// as the buffer base at that point.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">pushState(state, start) {</span><span class="s3">\n        </span><span class="s1">this.stack.push(this.state, start, this.bufferBase + this.buffer.length);</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Apply a reduce action</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reduce(action) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let depth = action &gt;&gt; 19 /* Action.ReduceDepthShift */, type = action &amp; 65535 /* Action.ValueMask */;</span><span class="s3">\n        </span><span class="s1">let { parser } = this.p;</span><span class="s3">\n        </span><span class="s1">let dPrec = parser.dynamicPrecedence(type);</span><span class="s3">\n        </span><span class="s1">if (dPrec)</span><span class="s3">\n            </span><span class="s1">this.score += dPrec;</span><span class="s3">\n        </span><span class="s1">if (depth == 0) {</span><span class="s3">\n            </span><span class="s1">this.pushState(parser.getGoto(this.state, type, true), this.reducePos);</span><span class="s3">\n            </span><span class="s1">// Zero-depth reductions are a special case—they add stuff to</span><span class="s3">\n            </span><span class="s1">// the stack without popping anything off.</span><span class="s3">\n            </span><span class="s1">if (type &lt; parser.minRepeatTerm)</span><span class="s3">\n                </span><span class="s1">this.storeNode(type, this.reducePos, this.reducePos, 4, true);</span><span class="s3">\n            </span><span class="s1">this.reduceContext(type, this.reducePos);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Find the base index into `this.stack`, content after which will</span><span class="s3">\n        </span><span class="s1">// be dropped. Note that with `StayFlag` reductions we need to</span><span class="s3">\n        </span><span class="s1">// consume two extra frames (the dummy parent node for the skipped</span><span class="s3">\n        </span><span class="s1">// expression and the state that we'll be staying in, which should</span><span class="s3">\n        </span><span class="s1">// be moved to `this.state`).</span><span class="s3">\n        </span><span class="s1">let base = this.stack.length - ((depth - 1) * 3) - (action &amp; 262144 /* Action.StayFlag */ ? 6 : 0);</span><span class="s3">\n        </span><span class="s1">let start = base ? this.stack[base - 2] : this.p.ranges[0].from, size = this.reducePos - start;</span><span class="s3">\n        </span><span class="s1">// This is a kludge to try and detect overly deep left-associative</span><span class="s3">\n        </span><span class="s1">// trees, which will not increase the parse stack depth and thus</span><span class="s3">\n        </span><span class="s1">// won't be caught by the regular stack-depth limit check.</span><span class="s3">\n        </span><span class="s1">if (size &gt;= 2000 /* Recover.MinBigReduction */ &amp;&amp; !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {</span><span class="s3">\n            </span><span class="s1">if (start == this.p.lastBigReductionStart) {</span><span class="s3">\n                </span><span class="s1">this.p.bigReductionCount++;</span><span class="s3">\n                </span><span class="s1">this.p.lastBigReductionSize = size;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.p.lastBigReductionSize &lt; size) {</span><span class="s3">\n                </span><span class="s1">this.p.bigReductionCount = 1;</span><span class="s3">\n                </span><span class="s1">this.p.lastBigReductionStart = start;</span><span class="s3">\n                </span><span class="s1">this.p.lastBigReductionSize = size;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let bufferBase = base ? this.stack[base - 1] : 0, count = this.bufferBase + this.buffer.length - bufferBase;</span><span class="s3">\n        </span><span class="s1">// Store normal terms or `R -&gt; R R` repeat reductions</span><span class="s3">\n        </span><span class="s1">if (type &lt; parser.minRepeatTerm || (action &amp; 131072 /* Action.RepeatFlag */)) {</span><span class="s3">\n            </span><span class="s1">let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;</span><span class="s3">\n            </span><span class="s1">this.storeNode(type, start, pos, count + 4, true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (action &amp; 262144 /* Action.StayFlag */) {</span><span class="s3">\n            </span><span class="s1">this.state = this.stack[base];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let baseStateID = this.stack[base - 3];</span><span class="s3">\n            </span><span class="s1">this.state = parser.getGoto(baseStateID, type, true);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (this.stack.length &gt; base)</span><span class="s3">\n            </span><span class="s1">this.stack.pop();</span><span class="s3">\n        </span><span class="s1">this.reduceContext(type, start);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Shift a value into the buffer</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">storeNode(term, start, end, size = 4, isReduce = false) {</span><span class="s3">\n        </span><span class="s1">if (term == 0 /* Term.Err */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!this.stack.length || this.stack[this.stack.length - 1] &lt; this.buffer.length + this.bufferBase)) {</span><span class="s3">\n            </span><span class="s1">// Try to omit/merge adjacent error nodes</span><span class="s3">\n            </span><span class="s1">let cur = this, top = this.buffer.length;</span><span class="s3">\n            </span><span class="s1">if (top == 0 &amp;&amp; cur.parent) {</span><span class="s3">\n                </span><span class="s1">top = cur.bufferBase - cur.parent.bufferBase;</span><span class="s3">\n                </span><span class="s1">cur = cur.parent;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (top &gt; 0 &amp;&amp; cur.buffer[top - 4] == 0 /* Term.Err */ &amp;&amp; cur.buffer[top - 1] &gt; -1) {</span><span class="s3">\n                </span><span class="s1">if (start == end)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">if (cur.buffer[top - 2] &gt;= start) {</span><span class="s3">\n                    </span><span class="s1">cur.buffer[top - 2] = end;</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!isReduce || this.pos == end) { // Simple case, just append</span><span class="s3">\n            </span><span class="s1">this.buffer.push(term, start, end, size);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else { // There may be skipped nodes that have to be moved forward</span><span class="s3">\n            </span><span class="s1">let index = this.buffer.length;</span><span class="s3">\n            </span><span class="s1">if (index &gt; 0 &amp;&amp; this.buffer[index - 4] != 0 /* Term.Err */)</span><span class="s3">\n                </span><span class="s1">while (index &gt; 0 &amp;&amp; this.buffer[index - 2] &gt; end) {</span><span class="s3">\n                    </span><span class="s1">// Move this record forward</span><span class="s3">\n                    </span><span class="s1">this.buffer[index] = this.buffer[index - 4];</span><span class="s3">\n                    </span><span class="s1">this.buffer[index + 1] = this.buffer[index - 3];</span><span class="s3">\n                    </span><span class="s1">this.buffer[index + 2] = this.buffer[index - 2];</span><span class="s3">\n                    </span><span class="s1">this.buffer[index + 3] = this.buffer[index - 1];</span><span class="s3">\n                    </span><span class="s1">index -= 4;</span><span class="s3">\n                    </span><span class="s1">if (size &gt; 4)</span><span class="s3">\n                        </span><span class="s1">size -= 4;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.buffer[index] = term;</span><span class="s3">\n            </span><span class="s1">this.buffer[index + 1] = start;</span><span class="s3">\n            </span><span class="s1">this.buffer[index + 2] = end;</span><span class="s3">\n            </span><span class="s1">this.buffer[index + 3] = size;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Apply a shift action</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">shift(action, type, start, end) {</span><span class="s3">\n        </span><span class="s1">if (action &amp; 131072 /* Action.GotoFlag */) {</span><span class="s3">\n            </span><span class="s1">this.pushState(action &amp; 65535 /* Action.ValueMask */, this.pos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((action &amp; 262144 /* Action.StayFlag */) == 0) { // Regular shift</span><span class="s3">\n            </span><span class="s1">let nextState = action, { parser } = this.p;</span><span class="s3">\n            </span><span class="s1">if (end &gt; this.pos || type &lt;= parser.maxNode) {</span><span class="s3">\n                </span><span class="s1">this.pos = end;</span><span class="s3">\n                </span><span class="s1">if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */))</span><span class="s3">\n                    </span><span class="s1">this.reducePos = end;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.pushState(nextState, start);</span><span class="s3">\n            </span><span class="s1">this.shiftContext(type, start);</span><span class="s3">\n            </span><span class="s1">if (type &lt;= parser.maxNode)</span><span class="s3">\n                </span><span class="s1">this.buffer.push(type, start, end, 4);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else { // Shift-and-stay, which means this is a skipped token</span><span class="s3">\n            </span><span class="s1">this.pos = end;</span><span class="s3">\n            </span><span class="s1">this.shiftContext(type, start);</span><span class="s3">\n            </span><span class="s1">if (type &lt;= this.p.parser.maxNode)</span><span class="s3">\n                </span><span class="s1">this.buffer.push(type, start, end, 4);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Apply an action</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">apply(action, next, nextStart, nextEnd) {</span><span class="s3">\n        </span><span class="s1">if (action &amp; 65536 /* Action.ReduceFlag */)</span><span class="s3">\n            </span><span class="s1">this.reduce(action);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.shift(action, next, nextStart, nextEnd);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Add a prebuilt (reused) node into the buffer.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">useNode(value, next) {</span><span class="s3">\n        </span><span class="s1">let index = this.p.reused.length - 1;</span><span class="s3">\n        </span><span class="s1">if (index &lt; 0 || this.p.reused[index] != value) {</span><span class="s3">\n            </span><span class="s1">this.p.reused.push(value);</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let start = this.pos;</span><span class="s3">\n        </span><span class="s1">this.reducePos = this.pos = start + value.length;</span><span class="s3">\n        </span><span class="s1">this.pushState(next, start);</span><span class="s3">\n        </span><span class="s1">this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);</span><span class="s3">\n        </span><span class="s1">if (this.curContext)</span><span class="s3">\n            </span><span class="s1">this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Split the stack. Due to the buffer sharing and the fact</span><span class="s3">\n    </span><span class="s1">// that `this.stack` tends to stay quite shallow, this isn't very</span><span class="s3">\n    </span><span class="s1">// expensive.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">split() {</span><span class="s3">\n        </span><span class="s1">let parent = this;</span><span class="s3">\n        </span><span class="s1">let off = parent.buffer.length;</span><span class="s3">\n        </span><span class="s1">// Because the top of the buffer (after this.pos) may be mutated</span><span class="s3">\n        </span><span class="s1">// to reorder reductions and skipped tokens, and shared buffers</span><span class="s3">\n        </span><span class="s1">// should be immutable, this copies any outstanding skipped tokens</span><span class="s3">\n        </span><span class="s1">// to the new buffer, and puts the base pointer before them.</span><span class="s3">\n        </span><span class="s1">while (off &gt; 0 &amp;&amp; parent.buffer[off - 2] &gt; parent.reducePos)</span><span class="s3">\n            </span><span class="s1">off -= 4;</span><span class="s3">\n        </span><span class="s1">let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;</span><span class="s3">\n        </span><span class="s1">// Make sure parent points to an actual parent with content, if there is such a parent.</span><span class="s3">\n        </span><span class="s1">while (parent &amp;&amp; base == parent.bufferBase)</span><span class="s3">\n            </span><span class="s1">parent = parent.parent;</span><span class="s3">\n        </span><span class="s1">return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Try to recover from an error by 'deleting' (ignoring) one token.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">recoverByDelete(next, nextEnd) {</span><span class="s3">\n        </span><span class="s1">let isNode = next &lt;= this.p.parser.maxNode;</span><span class="s3">\n        </span><span class="s1">if (isNode)</span><span class="s3">\n            </span><span class="s1">this.storeNode(next, this.pos, nextEnd, 4);</span><span class="s3">\n        </span><span class="s1">this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);</span><span class="s3">\n        </span><span class="s1">this.pos = this.reducePos = nextEnd;</span><span class="s3">\n        </span><span class="s1">this.score -= 190 /* Recover.Delete */;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Check if the given term would be able to be shifted (optionally</span><span class="s3">\n    </span><span class="s1">after some reductions) on this stack. This can be useful for</span><span class="s3">\n    </span><span class="s1">external tokenizers that want to make sure they only provide a</span><span class="s3">\n    </span><span class="s1">given token when it applies.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canShift(term) {</span><span class="s3">\n        </span><span class="s1">for (let sim = new SimulatedStack(this);;) {</span><span class="s3">\n            </span><span class="s1">let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);</span><span class="s3">\n            </span><span class="s1">if (action == 0)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">if ((action &amp; 65536 /* Action.ReduceFlag */) == 0)</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">sim.reduce(action);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Apply up to Recover.MaxNext recovery actions that conceptually</span><span class="s3">\n    </span><span class="s1">// inserts some missing token or rule.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">recoverByInsert(next) {</span><span class="s3">\n        </span><span class="s1">if (this.stack.length &gt;= 300 /* Recover.MaxInsertStackDepth */)</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">let nextStates = this.p.parser.nextStates(this.state);</span><span class="s3">\n        </span><span class="s1">if (nextStates.length &gt; 4 /* Recover.MaxNext */ &lt;&lt; 1 || this.stack.length &gt;= 120 /* Recover.DampenInsertStackDepth */) {</span><span class="s3">\n            </span><span class="s1">let best = [];</span><span class="s3">\n            </span><span class="s1">for (let i = 0, s; i &lt; nextStates.length; i += 2) {</span><span class="s3">\n                </span><span class="s1">if ((s = nextStates[i + 1]) != this.state &amp;&amp; this.p.parser.hasAction(s, next))</span><span class="s3">\n                    </span><span class="s1">best.push(nextStates[i], s);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.stack.length &lt; 120 /* Recover.DampenInsertStackDepth */)</span><span class="s3">\n                </span><span class="s1">for (let i = 0; best.length &lt; 4 /* Recover.MaxNext */ &lt;&lt; 1 &amp;&amp; i &lt; nextStates.length; i += 2) {</span><span class="s3">\n                    </span><span class="s1">let s = nextStates[i + 1];</span><span class="s3">\n                    </span><span class="s1">if (!best.some((v, i) =&gt; (i &amp; 1) &amp;&amp; v == s))</span><span class="s3">\n                        </span><span class="s1">best.push(nextStates[i], s);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">nextStates = best;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; nextStates.length &amp;&amp; result.length &lt; 4 /* Recover.MaxNext */; i += 2) {</span><span class="s3">\n            </span><span class="s1">let s = nextStates[i + 1];</span><span class="s3">\n            </span><span class="s1">if (s == this.state)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let stack = this.split();</span><span class="s3">\n            </span><span class="s1">stack.pushState(s, this.pos);</span><span class="s3">\n            </span><span class="s1">stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);</span><span class="s3">\n            </span><span class="s1">stack.shiftContext(nextStates[i], this.pos);</span><span class="s3">\n            </span><span class="s1">stack.reducePos = this.pos;</span><span class="s3">\n            </span><span class="s1">stack.score -= 200 /* Recover.Insert */;</span><span class="s3">\n            </span><span class="s1">result.push(stack);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Force a reduce, if possible. Return false if that can't</span><span class="s3">\n    </span><span class="s1">// be done.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">forceReduce() {</span><span class="s3">\n        </span><span class="s1">let { parser } = this.p;</span><span class="s3">\n        </span><span class="s1">let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);</span><span class="s3">\n        </span><span class="s1">if ((reduce &amp; 65536 /* Action.ReduceFlag */) == 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (!parser.validAction(this.state, reduce)) {</span><span class="s3">\n            </span><span class="s1">let depth = reduce &gt;&gt; 19 /* Action.ReduceDepthShift */, term = reduce &amp; 65535 /* Action.ValueMask */;</span><span class="s3">\n            </span><span class="s1">let target = this.stack.length - depth * 3;</span><span class="s3">\n            </span><span class="s1">if (target &lt; 0 || parser.getGoto(this.stack[target], term, false) &lt; 0) {</span><span class="s3">\n                </span><span class="s1">let backup = this.findForcedReduction();</span><span class="s3">\n                </span><span class="s1">if (backup == null)</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">reduce = backup;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);</span><span class="s3">\n            </span><span class="s1">this.score -= 100 /* Recover.Reduce */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.reducePos = this.pos;</span><span class="s3">\n        </span><span class="s1">this.reduce(reduce);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Try to scan through the automaton to find some kind of reduction</span><span class="s3">\n    </span><span class="s1">that can be applied. Used when the regular ForcedReduce field</span><span class="s3">\n    </span><span class="s1">isn't a valid action. @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">findForcedReduction() {</span><span class="s3">\n        </span><span class="s1">let { parser } = this.p, seen = [];</span><span class="s3">\n        </span><span class="s1">let explore = (state, depth) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (seen.includes(state))</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">seen.push(state);</span><span class="s3">\n            </span><span class="s1">return parser.allActions(state, (action) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (action &amp; (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;</span><span class="s3">\n                </span><span class="s1">else if (action &amp; 65536 /* Action.ReduceFlag */) {</span><span class="s3">\n                    </span><span class="s1">let rDepth = (action &gt;&gt; 19 /* Action.ReduceDepthShift */) - depth;</span><span class="s3">\n                    </span><span class="s1">if (rDepth &gt; 1) {</span><span class="s3">\n                        </span><span class="s1">let term = action &amp; 65535 /* Action.ValueMask */, target = this.stack.length - rDepth * 3;</span><span class="s3">\n                        </span><span class="s1">if (target &gt;= 0 &amp;&amp; parser.getGoto(this.stack[target], term, false) &gt;= 0)</span><span class="s3">\n                            </span><span class="s1">return (rDepth &lt;&lt; 19 /* Action.ReduceDepthShift */) | 65536 /* Action.ReduceFlag */ | term;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let found = explore(action, depth + 1);</span><span class="s3">\n                    </span><span class="s1">if (found != null)</span><span class="s3">\n                        </span><span class="s1">return found;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return explore(this.state, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">forceAll() {</span><span class="s3">\n        </span><span class="s1">while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {</span><span class="s3">\n            </span><span class="s1">if (!this.forceReduce()) {</span><span class="s3">\n                </span><span class="s1">this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Check whether this state has no further actions (assumed to be a direct descendant of the</span><span class="s3">\n    </span><span class="s1">top state, since any other states must be able to continue</span><span class="s3">\n    </span><span class="s1">somehow). @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get deadEnd() {</span><span class="s3">\n        </span><span class="s1">if (this.stack.length != 3)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let { parser } = this.p;</span><span class="s3">\n        </span><span class="s1">return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Restart the stack (put it back in its start state). Only safe</span><span class="s3">\n    </span><span class="s1">when this.stack.length == 3 (state is directly below the top</span><span class="s3">\n    </span><span class="s1">state). @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">restart() {</span><span class="s3">\n        </span><span class="s1">this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);</span><span class="s3">\n        </span><span class="s1">this.state = this.stack[0];</span><span class="s3">\n        </span><span class="s1">this.stack.length = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sameState(other) {</span><span class="s3">\n        </span><span class="s1">if (this.state != other.state || this.stack.length != other.stack.length)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.stack.length; i += 3)</span><span class="s3">\n            </span><span class="s1">if (this.stack[i] != other.stack[i])</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the parser used by this stack.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get parser() { return this.p.parser; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Test whether a given dialect (by numeric ID, as exported from</span><span class="s3">\n    </span><span class="s1">the terms file) is enabled.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }</span><span class="s3">\n    </span><span class="s1">shiftContext(term, start) {</span><span class="s3">\n        </span><span class="s1">if (this.curContext)</span><span class="s3">\n            </span><span class="s1">this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reduceContext(term, start) {</span><span class="s3">\n        </span><span class="s1">if (this.curContext)</span><span class="s3">\n            </span><span class="s1">this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">emitContext() {</span><span class="s3">\n        </span><span class="s1">let last = this.buffer.length - 1;</span><span class="s3">\n        </span><span class="s1">if (last &lt; 0 || this.buffer[last] != -3)</span><span class="s3">\n            </span><span class="s1">this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">emitLookAhead() {</span><span class="s3">\n        </span><span class="s1">let last = this.buffer.length - 1;</span><span class="s3">\n        </span><span class="s1">if (last &lt; 0 || this.buffer[last] != -4)</span><span class="s3">\n            </span><span class="s1">this.buffer.push(this.lookAhead, this.pos, this.pos, -4);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateContext(context) {</span><span class="s3">\n        </span><span class="s1">if (context != this.curContext.context) {</span><span class="s3">\n            </span><span class="s1">let newCx = new StackContext(this.curContext.tracker, context);</span><span class="s3">\n            </span><span class="s1">if (newCx.hash != this.curContext.hash)</span><span class="s3">\n                </span><span class="s1">this.emitContext();</span><span class="s3">\n            </span><span class="s1">this.curContext = newCx;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setLookAhead(lookAhead) {</span><span class="s3">\n        </span><span class="s1">if (lookAhead &gt; this.lookAhead) {</span><span class="s3">\n            </span><span class="s1">this.emitLookAhead();</span><span class="s3">\n            </span><span class="s1">this.lookAhead = lookAhead;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">close() {</span><span class="s3">\n        </span><span class="s1">if (this.curContext &amp;&amp; this.curContext.tracker.strict)</span><span class="s3">\n            </span><span class="s1">this.emitContext();</span><span class="s3">\n        </span><span class="s1">if (this.lookAhead &gt; 0)</span><span class="s3">\n            </span><span class="s1">this.emitLookAhead();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StackContext {</span><span class="s3">\n    </span><span class="s1">constructor(tracker, context) {</span><span class="s3">\n        </span><span class="s1">this.tracker = tracker;</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this.hash = tracker.strict ? tracker.hash(context) : 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Used to cheaply run some reductions to scan ahead without mutating</span><span class="s3">\n</span><span class="s1">// an entire stack</span><span class="s3">\n</span><span class="s1">class SimulatedStack {</span><span class="s3">\n    </span><span class="s1">constructor(start) {</span><span class="s3">\n        </span><span class="s1">this.start = start;</span><span class="s3">\n        </span><span class="s1">this.state = start.state;</span><span class="s3">\n        </span><span class="s1">this.stack = start.stack;</span><span class="s3">\n        </span><span class="s1">this.base = this.stack.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reduce(action) {</span><span class="s3">\n        </span><span class="s1">let term = action &amp; 65535 /* Action.ValueMask */, depth = action &gt;&gt; 19 /* Action.ReduceDepthShift */;</span><span class="s3">\n        </span><span class="s1">if (depth == 0) {</span><span class="s3">\n            </span><span class="s1">if (this.stack == this.start.stack)</span><span class="s3">\n                </span><span class="s1">this.stack = this.stack.slice();</span><span class="s3">\n            </span><span class="s1">this.stack.push(this.state, 0, 0);</span><span class="s3">\n            </span><span class="s1">this.base += 3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.base -= (depth - 1) * 3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);</span><span class="s3">\n        </span><span class="s1">this.state = goto;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// This is given to `Tree.build` to build a buffer, and encapsulates</span><span class="s3">\n</span><span class="s1">// the parent-stack-walking necessary to read the nodes.</span><span class="s3">\n</span><span class="s1">class StackBufferCursor {</span><span class="s3">\n    </span><span class="s1">constructor(stack, pos, index) {</span><span class="s3">\n        </span><span class="s1">this.stack = stack;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.index = index;</span><span class="s3">\n        </span><span class="s1">this.buffer = stack.buffer;</span><span class="s3">\n        </span><span class="s1">if (this.index == 0)</span><span class="s3">\n            </span><span class="s1">this.maybeNext();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static create(stack, pos = stack.bufferBase + stack.buffer.length) {</span><span class="s3">\n        </span><span class="s1">return new StackBufferCursor(stack, pos, pos - stack.bufferBase);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeNext() {</span><span class="s3">\n        </span><span class="s1">let next = this.stack.parent;</span><span class="s3">\n        </span><span class="s1">if (next != null) {</span><span class="s3">\n            </span><span class="s1">this.index = this.stack.bufferBase - next.bufferBase;</span><span class="s3">\n            </span><span class="s1">this.stack = next;</span><span class="s3">\n            </span><span class="s1">this.buffer = next.buffer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get id() { return this.buffer[this.index - 4]; }</span><span class="s3">\n    </span><span class="s1">get start() { return this.buffer[this.index - 3]; }</span><span class="s3">\n    </span><span class="s1">get end() { return this.buffer[this.index - 2]; }</span><span class="s3">\n    </span><span class="s1">get size() { return this.buffer[this.index - 1]; }</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">this.index -= 4;</span><span class="s3">\n        </span><span class="s1">this.pos -= 4;</span><span class="s3">\n        </span><span class="s1">if (this.index == 0)</span><span class="s3">\n            </span><span class="s1">this.maybeNext();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fork() {</span><span class="s3">\n        </span><span class="s1">return new StackBufferCursor(this.stack, this.pos, this.index);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// See lezer-generator/src/encode.ts for comments about the encoding</span><span class="s3">\n</span><span class="s1">// used here</span><span class="s3">\n</span><span class="s1">function decodeArray(input, Type = Uint16Array) {</span><span class="s3">\n    </span><span class="s1">if (typeof input != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return input;</span><span class="s3">\n    </span><span class="s1">let array = null;</span><span class="s3">\n    </span><span class="s1">for (let pos = 0, out = 0; pos &lt; input.length;) {</span><span class="s3">\n        </span><span class="s1">let value = 0;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let next = input.charCodeAt(pos++), stop = false;</span><span class="s3">\n            </span><span class="s1">if (next == 126 /* Encode.BigValCode */) {</span><span class="s3">\n                </span><span class="s1">value = 65535 /* Encode.BigVal */;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (next &gt;= 92 /* Encode.Gap2 */)</span><span class="s3">\n                </span><span class="s1">next--;</span><span class="s3">\n            </span><span class="s1">if (next &gt;= 34 /* Encode.Gap1 */)</span><span class="s3">\n                </span><span class="s1">next--;</span><span class="s3">\n            </span><span class="s1">let digit = next - 32 /* Encode.Start */;</span><span class="s3">\n            </span><span class="s1">if (digit &gt;= 46 /* Encode.Base */) {</span><span class="s3">\n                </span><span class="s1">digit -= 46 /* Encode.Base */;</span><span class="s3">\n                </span><span class="s1">stop = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">value += digit;</span><span class="s3">\n            </span><span class="s1">if (stop)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">value *= 46 /* Encode.Base */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (array)</span><span class="s3">\n            </span><span class="s1">array[out++] = value;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">array = new Type(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class CachedToken {</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.start = -1;</span><span class="s3">\n        </span><span class="s1">this.value = -1;</span><span class="s3">\n        </span><span class="s1">this.end = -1;</span><span class="s3">\n        </span><span class="s1">this.extended = -1;</span><span class="s3">\n        </span><span class="s1">this.lookAhead = 0;</span><span class="s3">\n        </span><span class="s1">this.mask = 0;</span><span class="s3">\n        </span><span class="s1">this.context = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const nullToken = new CachedToken;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">[Tokenizers](#lr.ExternalTokenizer) interact with the input</span><span class="s3">\n</span><span class="s1">through this interface. It presents the input as a stream of</span><span class="s3">\n</span><span class="s1">characters, tracking lookahead and hiding the complexity of</span><span class="s3">\n</span><span class="s1">[ranges](#common.Parser.parse^ranges) from tokenizer code.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class InputStream {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">input, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ranges) {</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.chunk = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.chunkOff = 0;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">Backup chunk</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.chunk2 = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.chunk2Pos = 0;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">The character code of the next code unit in the input, or -1</span><span class="s3">\n        </span><span class="s1">when the stream is at the end of the input.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.next = -1;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.token = nullToken;</span><span class="s3">\n        </span><span class="s1">this.rangeIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.pos = this.chunkPos = ranges[0].from;</span><span class="s3">\n        </span><span class="s1">this.range = ranges[0];</span><span class="s3">\n        </span><span class="s1">this.end = ranges[ranges.length - 1].to;</span><span class="s3">\n        </span><span class="s1">this.readNext();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resolveOffset(offset, assoc) {</span><span class="s3">\n        </span><span class="s1">let range = this.range, index = this.rangeIndex;</span><span class="s3">\n        </span><span class="s1">let pos = this.pos + offset;</span><span class="s3">\n        </span><span class="s1">while (pos &lt; range.from) {</span><span class="s3">\n            </span><span class="s1">if (!index)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let next = this.ranges[--index];</span><span class="s3">\n            </span><span class="s1">pos -= range.from - next.to;</span><span class="s3">\n            </span><span class="s1">range = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (assoc &lt; 0 ? pos &gt; range.to : pos &gt;= range.to) {</span><span class="s3">\n            </span><span class="s1">if (index == this.ranges.length - 1)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let next = this.ranges[++index];</span><span class="s3">\n            </span><span class="s1">pos += next.from - range.to;</span><span class="s3">\n            </span><span class="s1">range = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clipPos(pos) {</span><span class="s3">\n        </span><span class="s1">if (pos &gt;= this.range.from &amp;&amp; pos &lt; this.range.to)</span><span class="s3">\n            </span><span class="s1">return pos;</span><span class="s3">\n        </span><span class="s1">for (let range of this.ranges)</span><span class="s3">\n            </span><span class="s1">if (range.to &gt; pos)</span><span class="s3">\n                </span><span class="s1">return Math.max(pos, range.from);</span><span class="s3">\n        </span><span class="s1">return this.end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Look at a code unit near the stream position. `.peek(0)` equals</span><span class="s3">\n    </span><span class="s1">`.next`, `.peek(-1)` gives you the previous character, and so</span><span class="s3">\n    </span><span class="s1">on.</span><span class="s3">\n    \n    </span><span class="s1">Note that looking around during tokenizing creates dependencies</span><span class="s3">\n    </span><span class="s1">on potentially far-away content, which may reduce the</span><span class="s3">\n    </span><span class="s1">effectiveness incremental parsing—when looking forward—or even</span><span class="s3">\n    </span><span class="s1">cause invalid reparses when looking backward more than 25 code</span><span class="s3">\n    </span><span class="s1">units, since the library does not track lookbehind.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">peek(offset) {</span><span class="s3">\n        </span><span class="s1">let idx = this.chunkOff + offset, pos, result;</span><span class="s3">\n        </span><span class="s1">if (idx &gt;= 0 &amp;&amp; idx &lt; this.chunk.length) {</span><span class="s3">\n            </span><span class="s1">pos = this.pos + offset;</span><span class="s3">\n            </span><span class="s1">result = this.chunk.charCodeAt(idx);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let resolved = this.resolveOffset(offset, 1);</span><span class="s3">\n            </span><span class="s1">if (resolved == null)</span><span class="s3">\n                </span><span class="s1">return -1;</span><span class="s3">\n            </span><span class="s1">pos = resolved;</span><span class="s3">\n            </span><span class="s1">if (pos &gt;= this.chunk2Pos &amp;&amp; pos &lt; this.chunk2Pos + this.chunk2.length) {</span><span class="s3">\n                </span><span class="s1">result = this.chunk2.charCodeAt(pos - this.chunk2Pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let i = this.rangeIndex, range = this.range;</span><span class="s3">\n                </span><span class="s1">while (range.to &lt;= pos)</span><span class="s3">\n                    </span><span class="s1">range = this.ranges[++i];</span><span class="s3">\n                </span><span class="s1">this.chunk2 = this.input.chunk(this.chunk2Pos = pos);</span><span class="s3">\n                </span><span class="s1">if (pos + this.chunk2.length &gt; range.to)</span><span class="s3">\n                    </span><span class="s1">this.chunk2 = this.chunk2.slice(0, range.to - pos);</span><span class="s3">\n                </span><span class="s1">result = this.chunk2.charCodeAt(0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &gt;= this.token.lookAhead)</span><span class="s3">\n            </span><span class="s1">this.token.lookAhead = pos + 1;</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Accept a token. By default, the end of the token is set to the</span><span class="s3">\n    </span><span class="s1">current stream position, but you can pass an offset (relative to</span><span class="s3">\n    </span><span class="s1">the stream position) to change that.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">acceptToken(token, endOffset = 0) {</span><span class="s3">\n        </span><span class="s1">let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;</span><span class="s3">\n        </span><span class="s1">if (end == null || end &lt; this.token.start)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Token end out of bounds</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.token.value = token;</span><span class="s3">\n        </span><span class="s1">this.token.end = end;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getChunk() {</span><span class="s3">\n        </span><span class="s1">if (this.pos &gt;= this.chunk2Pos &amp;&amp; this.pos &lt; this.chunk2Pos + this.chunk2.length) {</span><span class="s3">\n            </span><span class="s1">let { chunk, chunkPos } = this;</span><span class="s3">\n            </span><span class="s1">this.chunk = this.chunk2;</span><span class="s3">\n            </span><span class="s1">this.chunkPos = this.chunk2Pos;</span><span class="s3">\n            </span><span class="s1">this.chunk2 = chunk;</span><span class="s3">\n            </span><span class="s1">this.chunk2Pos = chunkPos;</span><span class="s3">\n            </span><span class="s1">this.chunkOff = this.pos - this.chunkPos;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.chunk2 = this.chunk;</span><span class="s3">\n            </span><span class="s1">this.chunk2Pos = this.chunkPos;</span><span class="s3">\n            </span><span class="s1">let nextChunk = this.input.chunk(this.pos);</span><span class="s3">\n            </span><span class="s1">let end = this.pos + nextChunk.length;</span><span class="s3">\n            </span><span class="s1">this.chunk = end &gt; this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;</span><span class="s3">\n            </span><span class="s1">this.chunkPos = this.pos;</span><span class="s3">\n            </span><span class="s1">this.chunkOff = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">readNext() {</span><span class="s3">\n        </span><span class="s1">if (this.chunkOff &gt;= this.chunk.length) {</span><span class="s3">\n            </span><span class="s1">this.getChunk();</span><span class="s3">\n            </span><span class="s1">if (this.chunkOff == this.chunk.length)</span><span class="s3">\n                </span><span class="s1">return this.next = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.next = this.chunk.charCodeAt(this.chunkOff);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move the stream forward N (defaults to 1) code units. Returns</span><span class="s3">\n    </span><span class="s1">the new value of [`next`](#lr.InputStream.next).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">advance(n = 1) {</span><span class="s3">\n        </span><span class="s1">this.chunkOff += n;</span><span class="s3">\n        </span><span class="s1">while (this.pos + n &gt;= this.range.to) {</span><span class="s3">\n            </span><span class="s1">if (this.rangeIndex == this.ranges.length - 1)</span><span class="s3">\n                </span><span class="s1">return this.setDone();</span><span class="s3">\n            </span><span class="s1">n -= this.range.to - this.pos;</span><span class="s3">\n            </span><span class="s1">this.range = this.ranges[++this.rangeIndex];</span><span class="s3">\n            </span><span class="s1">this.pos = this.range.from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.pos += n;</span><span class="s3">\n        </span><span class="s1">if (this.pos &gt;= this.token.lookAhead)</span><span class="s3">\n            </span><span class="s1">this.token.lookAhead = this.pos + 1;</span><span class="s3">\n        </span><span class="s1">return this.readNext();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setDone() {</span><span class="s3">\n        </span><span class="s1">this.pos = this.chunkPos = this.end;</span><span class="s3">\n        </span><span class="s1">this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];</span><span class="s3">\n        </span><span class="s1">this.chunk = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return this.next = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reset(pos, token) {</span><span class="s3">\n        </span><span class="s1">if (token) {</span><span class="s3">\n            </span><span class="s1">this.token = token;</span><span class="s3">\n            </span><span class="s1">token.start = pos;</span><span class="s3">\n            </span><span class="s1">token.lookAhead = pos + 1;</span><span class="s3">\n            </span><span class="s1">token.value = token.extended = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.token = nullToken;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.pos != pos) {</span><span class="s3">\n            </span><span class="s1">this.pos = pos;</span><span class="s3">\n            </span><span class="s1">if (pos == this.end) {</span><span class="s3">\n                </span><span class="s1">this.setDone();</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">while (pos &lt; this.range.from)</span><span class="s3">\n                </span><span class="s1">this.range = this.ranges[--this.rangeIndex];</span><span class="s3">\n            </span><span class="s1">while (pos &gt;= this.range.to)</span><span class="s3">\n                </span><span class="s1">this.range = this.ranges[++this.rangeIndex];</span><span class="s3">\n            </span><span class="s1">if (pos &gt;= this.chunkPos &amp;&amp; pos &lt; this.chunkPos + this.chunk.length) {</span><span class="s3">\n                </span><span class="s1">this.chunkOff = pos - this.chunkPos;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.chunk = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">this.chunkOff = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.readNext();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">read(from, to) {</span><span class="s3">\n        </span><span class="s1">if (from &gt;= this.chunkPos &amp;&amp; to &lt;= this.chunkPos + this.chunk.length)</span><span class="s3">\n            </span><span class="s1">return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);</span><span class="s3">\n        </span><span class="s1">if (from &gt;= this.chunk2Pos &amp;&amp; to &lt;= this.chunk2Pos + this.chunk2.length)</span><span class="s3">\n            </span><span class="s1">return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);</span><span class="s3">\n        </span><span class="s1">if (from &gt;= this.range.from &amp;&amp; to &lt;= this.range.to)</span><span class="s3">\n            </span><span class="s1">return this.input.read(from, to);</span><span class="s3">\n        </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let r of this.ranges) {</span><span class="s3">\n            </span><span class="s1">if (r.from &gt;= to)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (r.to &gt; from)</span><span class="s3">\n                </span><span class="s1">result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">@internal</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TokenGroup {</span><span class="s3">\n    </span><span class="s1">constructor(data, id) {</span><span class="s3">\n        </span><span class="s1">this.data = data;</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">token(input, stack) {</span><span class="s3">\n        </span><span class="s1">let { parser } = stack.p;</span><span class="s3">\n        </span><span class="s1">readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">TokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">@hide</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LocalTokenGroup {</span><span class="s3">\n    </span><span class="s1">constructor(data, precTable, elseToken) {</span><span class="s3">\n        </span><span class="s1">this.precTable = precTable;</span><span class="s3">\n        </span><span class="s1">this.elseToken = elseToken;</span><span class="s3">\n        </span><span class="s1">this.data = typeof data == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? decodeArray(data) : data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">token(input, stack) {</span><span class="s3">\n        </span><span class="s1">let start = input.pos, skipped = 0;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let atEof = input.next &lt; 0, nextPos = input.resolveOffset(1, 1);</span><span class="s3">\n            </span><span class="s1">readToken(this.data, input, stack, 0, this.data, this.precTable);</span><span class="s3">\n            </span><span class="s1">if (input.token.value &gt; -1)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (this.elseToken == null)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (!atEof)</span><span class="s3">\n                </span><span class="s1">skipped++;</span><span class="s3">\n            </span><span class="s1">if (nextPos == null)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">input.reset(nextPos, input.token);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (skipped) {</span><span class="s3">\n            </span><span class="s1">input.reset(start, input.token);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(this.elseToken, skipped);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">LocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">`@external tokens` declarations in the grammar should resolve to</span><span class="s3">\n</span><span class="s1">an instance of this class.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ExternalTokenizer {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a tokenizer. The first argument is the function that,</span><span class="s3">\n    </span><span class="s1">given an input stream, scans for the types of tokens it</span><span class="s3">\n    </span><span class="s1">recognizes at the stream's position, and calls</span><span class="s3">\n    </span><span class="s1">[`acceptToken`](#lr.InputStream.acceptToken) when it finds</span><span class="s3">\n    </span><span class="s1">one.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">token, options = {}) {</span><span class="s3">\n        </span><span class="s1">this.token = token;</span><span class="s3">\n        </span><span class="s1">this.contextual = !!options.contextual;</span><span class="s3">\n        </span><span class="s1">this.fallback = !!options.fallback;</span><span class="s3">\n        </span><span class="s1">this.extend = !!options.extend;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Tokenizer data is stored a big uint16 array containing, for each</span><span class="s3">\n</span><span class="s1">// state:</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  - A group bitmask, indicating what token groups are reachable from</span><span class="s3">\n</span><span class="s1">//    this state, so that paths that can only lead to tokens not in</span><span class="s3">\n</span><span class="s1">//    any of the current groups can be cut off early.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  - The position of the end of the state's sequence of accepting</span><span class="s3">\n</span><span class="s1">//    tokens</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  - The number of outgoing edges for the state</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  - The accepting tokens, as (token id, group mask) pairs</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">//  - The outgoing edges, as (start character, end character, state</span><span class="s3">\n</span><span class="s1">//    index) triples, with end character being exclusive</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// This function interprets that data, running through a stream as</span><span class="s3">\n</span><span class="s1">// long as new states with the a matching group mask can be reached,</span><span class="s3">\n</span><span class="s1">// and updating `input.token` when it matches a token.</span><span class="s3">\n</span><span class="s1">function readToken(data, input, stack, group, precTable, precOffset) {</span><span class="s3">\n    </span><span class="s1">let state = 0, groupMask = 1 &lt;&lt; group, { dialect } = stack.p.parser;</span><span class="s3">\n    </span><span class="s1">scan: for (;;) {</span><span class="s3">\n        </span><span class="s1">if ((groupMask &amp; data[state]) == 0)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">let accEnd = data[state + 1];</span><span class="s3">\n        </span><span class="s1">// Check whether this state can lead to a token in the current group</span><span class="s3">\n        </span><span class="s1">// Accept tokens in this state, possibly overwriting</span><span class="s3">\n        </span><span class="s1">// lower-precedence / shorter tokens</span><span class="s3">\n        </span><span class="s1">for (let i = state + 3; i &lt; accEnd; i += 2)</span><span class="s3">\n            </span><span class="s1">if ((data[i + 1] &amp; groupMask) &gt; 0) {</span><span class="s3">\n                </span><span class="s1">let term = data[i];</span><span class="s3">\n                </span><span class="s1">if (dialect.allows(term) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(input.token.value == -1 || input.token.value == term ||</span><span class="s3">\n                        </span><span class="s1">overrides(term, input.token.value, precTable, precOffset))) {</span><span class="s3">\n                    </span><span class="s1">input.acceptToken(term);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let next = input.next, low = 0, high = data[state + 2];</span><span class="s3">\n        </span><span class="s1">// Special case for EOF</span><span class="s3">\n        </span><span class="s1">if (input.next &lt; 0 &amp;&amp; high &gt; low &amp;&amp; data[accEnd + high * 3 - 3] == 65535 /* Seq.End */ &amp;&amp; data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {</span><span class="s3">\n            </span><span class="s1">state = data[accEnd + high * 3 - 1];</span><span class="s3">\n            </span><span class="s1">continue scan;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Do a binary search on the state's edges</span><span class="s3">\n        </span><span class="s1">for (; low &lt; high;) {</span><span class="s3">\n            </span><span class="s1">let mid = (low + high) &gt;&gt; 1;</span><span class="s3">\n            </span><span class="s1">let index = accEnd + mid + (mid &lt;&lt; 1);</span><span class="s3">\n            </span><span class="s1">let from = data[index], to = data[index + 1] || 0x10000;</span><span class="s3">\n            </span><span class="s1">if (next &lt; from)</span><span class="s3">\n                </span><span class="s1">high = mid;</span><span class="s3">\n            </span><span class="s1">else if (next &gt;= to)</span><span class="s3">\n                </span><span class="s1">low = mid + 1;</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">state = data[index + 2];</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n                </span><span class="s1">continue scan;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findOffset(data, start, term) {</span><span class="s3">\n    </span><span class="s1">for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++)</span><span class="s3">\n        </span><span class="s1">if (next == term)</span><span class="s3">\n            </span><span class="s1">return i - start;</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function overrides(token, prev, tableData, tableOffset) {</span><span class="s3">\n    </span><span class="s1">let iPrev = findOffset(tableData, tableOffset, prev);</span><span class="s3">\n    </span><span class="s1">return iPrev &lt; 0 || findOffset(tableData, tableOffset, token) &lt; iPrev;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Environment variable used to control console output</span><span class="s3">\n</span><span class="s1">const verbose = typeof process != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; process.env &amp;&amp; /</span><span class="s3">\\</span><span class="s1">bparse</span><span class="s3">\\</span><span class="s1">b/.test(process.env.LOG);</span><span class="s3">\n</span><span class="s1">let stackIDs = null;</span><span class="s3">\n</span><span class="s1">function cutAt(tree, pos, side) {</span><span class="s3">\n    </span><span class="s1">let cursor = tree.cursor(IterMode.IncludeAnonymous);</span><span class="s3">\n    </span><span class="s1">cursor.moveTo(pos);</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (!(side &lt; 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">if ((side &lt; 0 ? cursor.to &lt; pos : cursor.from &gt; pos) &amp;&amp; !cursor.type.isError)</span><span class="s3">\n                    </span><span class="s1">return side &lt; 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Safety.Margin */))</span><span class="s3">\n                        </span><span class="s1">: Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Safety.Margin */));</span><span class="s3">\n                </span><span class="s1">if (side &lt; 0 ? cursor.prevSibling() : cursor.nextSibling())</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (!cursor.parent())</span><span class="s3">\n                    </span><span class="s1">return side &lt; 0 ? 0 : tree.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class FragmentCursor {</span><span class="s3">\n    </span><span class="s1">constructor(fragments, nodeSet) {</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.nodeSet = nodeSet;</span><span class="s3">\n        </span><span class="s1">this.i = 0;</span><span class="s3">\n        </span><span class="s1">this.fragment = null;</span><span class="s3">\n        </span><span class="s1">this.safeFrom = -1;</span><span class="s3">\n        </span><span class="s1">this.safeTo = -1;</span><span class="s3">\n        </span><span class="s1">this.trees = [];</span><span class="s3">\n        </span><span class="s1">this.start = [];</span><span class="s3">\n        </span><span class="s1">this.index = [];</span><span class="s3">\n        </span><span class="s1">this.nextFragment();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextFragment() {</span><span class="s3">\n        </span><span class="s1">let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];</span><span class="s3">\n        </span><span class="s1">if (fr) {</span><span class="s3">\n            </span><span class="s1">this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;</span><span class="s3">\n            </span><span class="s1">this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;</span><span class="s3">\n            </span><span class="s1">while (this.trees.length) {</span><span class="s3">\n                </span><span class="s1">this.trees.pop();</span><span class="s3">\n                </span><span class="s1">this.start.pop();</span><span class="s3">\n                </span><span class="s1">this.index.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.trees.push(fr.tree);</span><span class="s3">\n            </span><span class="s1">this.start.push(-fr.offset);</span><span class="s3">\n            </span><span class="s1">this.index.push(0);</span><span class="s3">\n            </span><span class="s1">this.nextStart = this.safeFrom;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.nextStart = 1e9;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// `pos` must be &gt;= any previously given `pos` for this cursor</span><span class="s3">\n    </span><span class="s1">nodeAt(pos) {</span><span class="s3">\n        </span><span class="s1">if (pos &lt; this.nextStart)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">while (this.fragment &amp;&amp; this.safeTo &lt;= pos)</span><span class="s3">\n            </span><span class="s1">this.nextFragment();</span><span class="s3">\n        </span><span class="s1">if (!this.fragment)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let last = this.trees.length - 1;</span><span class="s3">\n            </span><span class="s1">if (last &lt; 0) { // End of tree</span><span class="s3">\n                </span><span class="s1">this.nextFragment();</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let top = this.trees[last], index = this.index[last];</span><span class="s3">\n            </span><span class="s1">if (index == top.children.length) {</span><span class="s3">\n                </span><span class="s1">this.trees.pop();</span><span class="s3">\n                </span><span class="s1">this.start.pop();</span><span class="s3">\n                </span><span class="s1">this.index.pop();</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let next = top.children[index];</span><span class="s3">\n            </span><span class="s1">let start = this.start[last] + top.positions[index];</span><span class="s3">\n            </span><span class="s1">if (start &gt; pos) {</span><span class="s3">\n                </span><span class="s1">this.nextStart = start;</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (next instanceof Tree) {</span><span class="s3">\n                </span><span class="s1">if (start == pos) {</span><span class="s3">\n                    </span><span class="s1">if (start &lt; this.safeFrom)</span><span class="s3">\n                        </span><span class="s1">return null;</span><span class="s3">\n                    </span><span class="s1">let end = start + next.length;</span><span class="s3">\n                    </span><span class="s1">if (end &lt;= this.safeTo) {</span><span class="s3">\n                        </span><span class="s1">let lookAhead = next.prop(NodeProp.lookAhead);</span><span class="s3">\n                        </span><span class="s1">if (!lookAhead || end + lookAhead &lt; this.fragment.to)</span><span class="s3">\n                            </span><span class="s1">return next;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.index[last]++;</span><span class="s3">\n                </span><span class="s1">if (start + next.length &gt;= Math.max(this.safeFrom, pos)) { // Enter this node</span><span class="s3">\n                    </span><span class="s1">this.trees.push(next);</span><span class="s3">\n                    </span><span class="s1">this.start.push(start);</span><span class="s3">\n                    </span><span class="s1">this.index.push(0);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.index[last]++;</span><span class="s3">\n                </span><span class="s1">this.nextStart = start + next.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TokenCache {</span><span class="s3">\n    </span><span class="s1">constructor(parser, stream) {</span><span class="s3">\n        </span><span class="s1">this.stream = stream;</span><span class="s3">\n        </span><span class="s1">this.tokens = [];</span><span class="s3">\n        </span><span class="s1">this.mainToken = null;</span><span class="s3">\n        </span><span class="s1">this.actions = [];</span><span class="s3">\n        </span><span class="s1">this.tokens = parser.tokenizers.map(_ =&gt; new CachedToken);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getActions(stack) {</span><span class="s3">\n        </span><span class="s1">let actionIndex = 0;</span><span class="s3">\n        </span><span class="s1">let main = null;</span><span class="s3">\n        </span><span class="s1">let { parser } = stack.p, { tokenizers } = parser;</span><span class="s3">\n        </span><span class="s1">let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);</span><span class="s3">\n        </span><span class="s1">let context = stack.curContext ? stack.curContext.hash : 0;</span><span class="s3">\n        </span><span class="s1">let lookAhead = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; tokenizers.length; i++) {</span><span class="s3">\n            </span><span class="s1">if (((1 &lt;&lt; i) &amp; mask) == 0)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let tokenizer = tokenizers[i], token = this.tokens[i];</span><span class="s3">\n            </span><span class="s1">if (main &amp;&amp; !tokenizer.fallback)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {</span><span class="s3">\n                </span><span class="s1">this.updateCachedToken(token, tokenizer, stack);</span><span class="s3">\n                </span><span class="s1">token.mask = mask;</span><span class="s3">\n                </span><span class="s1">token.context = context;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (token.lookAhead &gt; token.end + 25 /* Safety.Margin */)</span><span class="s3">\n                </span><span class="s1">lookAhead = Math.max(token.lookAhead, lookAhead);</span><span class="s3">\n            </span><span class="s1">if (token.value != 0 /* Term.Err */) {</span><span class="s3">\n                </span><span class="s1">let startIndex = actionIndex;</span><span class="s3">\n                </span><span class="s1">if (token.extended &gt; -1)</span><span class="s3">\n                    </span><span class="s1">actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);</span><span class="s3">\n                </span><span class="s1">actionIndex = this.addActions(stack, token.value, token.end, actionIndex);</span><span class="s3">\n                </span><span class="s1">if (!tokenizer.extend) {</span><span class="s3">\n                    </span><span class="s1">main = token;</span><span class="s3">\n                    </span><span class="s1">if (actionIndex &gt; startIndex)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (this.actions.length &gt; actionIndex)</span><span class="s3">\n            </span><span class="s1">this.actions.pop();</span><span class="s3">\n        </span><span class="s1">if (lookAhead)</span><span class="s3">\n            </span><span class="s1">stack.setLookAhead(lookAhead);</span><span class="s3">\n        </span><span class="s1">if (!main &amp;&amp; stack.pos == this.stream.end) {</span><span class="s3">\n            </span><span class="s1">main = new CachedToken;</span><span class="s3">\n            </span><span class="s1">main.value = stack.p.parser.eofTerm;</span><span class="s3">\n            </span><span class="s1">main.start = main.end = stack.pos;</span><span class="s3">\n            </span><span class="s1">actionIndex = this.addActions(stack, main.value, main.end, actionIndex);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.mainToken = main;</span><span class="s3">\n        </span><span class="s1">return this.actions;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getMainToken(stack) {</span><span class="s3">\n        </span><span class="s1">if (this.mainToken)</span><span class="s3">\n            </span><span class="s1">return this.mainToken;</span><span class="s3">\n        </span><span class="s1">let main = new CachedToken, { pos, p } = stack;</span><span class="s3">\n        </span><span class="s1">main.start = pos;</span><span class="s3">\n        </span><span class="s1">main.end = Math.min(pos + 1, p.stream.end);</span><span class="s3">\n        </span><span class="s1">main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;</span><span class="s3">\n        </span><span class="s1">return main;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">updateCachedToken(token, tokenizer, stack) {</span><span class="s3">\n        </span><span class="s1">let start = this.stream.clipPos(stack.pos);</span><span class="s3">\n        </span><span class="s1">tokenizer.token(this.stream.reset(start, token), stack);</span><span class="s3">\n        </span><span class="s1">if (token.value &gt; -1) {</span><span class="s3">\n            </span><span class="s1">let { parser } = stack.p;</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; parser.specialized.length; i++)</span><span class="s3">\n                </span><span class="s1">if (parser.specialized[i] == token.value) {</span><span class="s3">\n                    </span><span class="s1">let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);</span><span class="s3">\n                    </span><span class="s1">if (result &gt;= 0 &amp;&amp; stack.p.parser.dialect.allows(result &gt;&gt; 1)) {</span><span class="s3">\n                        </span><span class="s1">if ((result &amp; 1) == 0 /* Specialize.Specialize */)</span><span class="s3">\n                            </span><span class="s1">token.value = result &gt;&gt; 1;</span><span class="s3">\n                        </span><span class="s1">else</span><span class="s3">\n                            </span><span class="s1">token.extended = result &gt;&gt; 1;</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">token.value = 0 /* Term.Err */;</span><span class="s3">\n            </span><span class="s1">token.end = this.stream.clipPos(start + 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">putAction(action, token, end, index) {</span><span class="s3">\n        </span><span class="s1">// Don't add duplicate actions</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; index; i += 3)</span><span class="s3">\n            </span><span class="s1">if (this.actions[i] == action)</span><span class="s3">\n                </span><span class="s1">return index;</span><span class="s3">\n        </span><span class="s1">this.actions[index++] = action;</span><span class="s3">\n        </span><span class="s1">this.actions[index++] = token;</span><span class="s3">\n        </span><span class="s1">this.actions[index++] = end;</span><span class="s3">\n        </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addActions(stack, token, end, index) {</span><span class="s3">\n        </span><span class="s1">let { state } = stack, { parser } = stack.p, { data } = parser;</span><span class="s3">\n        </span><span class="s1">for (let set = 0; set &lt; 2; set++) {</span><span class="s3">\n            </span><span class="s1">for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {</span><span class="s3">\n                </span><span class="s1">if (data[i] == 65535 /* Seq.End */) {</span><span class="s3">\n                    </span><span class="s1">if (data[i + 1] == 1 /* Seq.Next */) {</span><span class="s3">\n                        </span><span class="s1">i = pair(data, i + 2);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">if (index == 0 &amp;&amp; data[i + 1] == 2 /* Seq.Other */)</span><span class="s3">\n                            </span><span class="s1">index = this.putAction(pair(data, i + 2), token, end, index);</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (data[i] == token)</span><span class="s3">\n                    </span><span class="s1">index = this.putAction(pair(data, i + 1), token, end, index);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Parse {</span><span class="s3">\n    </span><span class="s1">constructor(parser, input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.recovering = 0;</span><span class="s3">\n        </span><span class="s1">this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧</span><span class="s3">\n        </span><span class="s1">this.minStackPos = 0;</span><span class="s3">\n        </span><span class="s1">this.reused = [];</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = null;</span><span class="s3">\n        </span><span class="s1">this.lastBigReductionStart = -1;</span><span class="s3">\n        </span><span class="s1">this.lastBigReductionSize = 0;</span><span class="s3">\n        </span><span class="s1">this.bigReductionCount = 0;</span><span class="s3">\n        </span><span class="s1">this.stream = new InputStream(input, ranges);</span><span class="s3">\n        </span><span class="s1">this.tokens = new TokenCache(parser, this.stream);</span><span class="s3">\n        </span><span class="s1">this.topTerm = parser.top[1];</span><span class="s3">\n        </span><span class="s1">let { from } = ranges[0];</span><span class="s3">\n        </span><span class="s1">this.stacks = [Stack.start(this, parser.top[0], from)];</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments.length &amp;&amp; this.stream.end - from &gt; parser.bufferLength * 4</span><span class="s3">\n            </span><span class="s1">? new FragmentCursor(fragments, parser.nodeSet) : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get parsedPos() {</span><span class="s3">\n        </span><span class="s1">return this.minStackPos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Move the parser forward. This will process all parse stacks at</span><span class="s3">\n    </span><span class="s1">// `this.pos` and try to advance them to a further position. If no</span><span class="s3">\n    </span><span class="s1">// stack for such a position is found, it'll start error-recovery.</span><span class="s3">\n    </span><span class="s1">//</span><span class="s3">\n    </span><span class="s1">// When the parse is finished, this will return a syntax tree. When</span><span class="s3">\n    </span><span class="s1">// not, it returns `null`.</span><span class="s3">\n    </span><span class="s1">advance() {</span><span class="s3">\n        </span><span class="s1">let stacks = this.stacks, pos = this.minStackPos;</span><span class="s3">\n        </span><span class="s1">// This will hold stacks beyond `pos`.</span><span class="s3">\n        </span><span class="s1">let newStacks = this.stacks = [];</span><span class="s3">\n        </span><span class="s1">let stopped, stoppedTokens;</span><span class="s3">\n        </span><span class="s1">// If a large amount of reductions happened with the same start</span><span class="s3">\n        </span><span class="s1">// position, force the stack out of that production in order to</span><span class="s3">\n        </span><span class="s1">// avoid creating a tree too deep to recurse through.</span><span class="s3">\n        </span><span class="s1">// (This is an ugly kludge, because unfortunately there is no</span><span class="s3">\n        </span><span class="s1">// straightforward, cheap way to check for this happening, due to</span><span class="s3">\n        </span><span class="s1">// the history of reductions only being available in an</span><span class="s3">\n        </span><span class="s1">// expensive-to-access format in the stack buffers.)</span><span class="s3">\n        </span><span class="s1">if (this.bigReductionCount &gt; 300 /* Rec.MaxLeftAssociativeReductionCount */ &amp;&amp; stacks.length == 1) {</span><span class="s3">\n            </span><span class="s1">let [s] = stacks;</span><span class="s3">\n            </span><span class="s1">while (s.forceReduce() &amp;&amp; s.stack.length &amp;&amp; s.stack[s.stack.length - 2] &gt;= this.lastBigReductionStart) { }</span><span class="s3">\n            </span><span class="s1">this.bigReductionCount = this.lastBigReductionSize = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Keep advancing any stacks at `pos` until they either move</span><span class="s3">\n        </span><span class="s1">// forward or can't be advanced. Gather stacks that can't be</span><span class="s3">\n        </span><span class="s1">// advanced further in `stopped`.</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; stacks.length; i++) {</span><span class="s3">\n            </span><span class="s1">let stack = stacks[i];</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">this.tokens.mainToken = null;</span><span class="s3">\n                </span><span class="s1">if (stack.pos &gt; pos) {</span><span class="s3">\n                    </span><span class="s1">newStacks.push(stack);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (this.advanceStack(stack, newStacks, stacks)) {</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (!stopped) {</span><span class="s3">\n                        </span><span class="s1">stopped = [];</span><span class="s3">\n                        </span><span class="s1">stoppedTokens = [];</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">stopped.push(stack);</span><span class="s3">\n                    </span><span class="s1">let tok = this.tokens.getMainToken(stack);</span><span class="s3">\n                    </span><span class="s1">stoppedTokens.push(tok.value, tok.end);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!newStacks.length) {</span><span class="s3">\n            </span><span class="s1">let finished = stopped &amp;&amp; findFinished(stopped);</span><span class="s3">\n            </span><span class="s1">if (finished) {</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">Finish with </span><span class="s3">\&quot; </span><span class="s1">+ this.stackID(finished));</span><span class="s3">\n                </span><span class="s1">return this.stackToTree(finished);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.parser.strict) {</span><span class="s3">\n                </span><span class="s1">if (verbose &amp;&amp; stopped)</span><span class="s3">\n                    </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">Stuck with token </span><span class="s3">\&quot; </span><span class="s1">+ (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n                </span><span class="s1">throw new SyntaxError(</span><span class="s3">\&quot;</span><span class="s1">No parse at </span><span class="s3">\&quot; </span><span class="s1">+ pos);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.recovering)</span><span class="s3">\n                </span><span class="s1">this.recovering = 5 /* Rec.Distance */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.recovering &amp;&amp; stopped) {</span><span class="s3">\n            </span><span class="s1">let finished = this.stoppedAt != null &amp;&amp; stopped[0].pos &gt; this.stoppedAt ? stopped[0]</span><span class="s3">\n                </span><span class="s1">: this.runRecovery(stopped, stoppedTokens, newStacks);</span><span class="s3">\n            </span><span class="s1">if (finished) {</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">Force-finish </span><span class="s3">\&quot; </span><span class="s1">+ this.stackID(finished));</span><span class="s3">\n                </span><span class="s1">return this.stackToTree(finished.forceAll());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.recovering) {</span><span class="s3">\n            </span><span class="s1">let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;</span><span class="s3">\n            </span><span class="s1">if (newStacks.length &gt; maxRemaining) {</span><span class="s3">\n                </span><span class="s1">newStacks.sort((a, b) =&gt; b.score - a.score);</span><span class="s3">\n                </span><span class="s1">while (newStacks.length &gt; maxRemaining)</span><span class="s3">\n                    </span><span class="s1">newStacks.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (newStacks.some(s =&gt; s.reducePos &gt; pos))</span><span class="s3">\n                </span><span class="s1">this.recovering--;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (newStacks.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">// Prune stacks that are in the same state, or that have been</span><span class="s3">\n            </span><span class="s1">// running without splitting for a while, to avoid getting stuck</span><span class="s3">\n            </span><span class="s1">// with multiple successful stacks running endlessly on.</span><span class="s3">\n            </span><span class="s1">outer: for (let i = 0; i &lt; newStacks.length - 1; i++) {</span><span class="s3">\n                </span><span class="s1">let stack = newStacks[i];</span><span class="s3">\n                </span><span class="s1">for (let j = i + 1; j &lt; newStacks.length; j++) {</span><span class="s3">\n                    </span><span class="s1">let other = newStacks[j];</span><span class="s3">\n                    </span><span class="s1">if (stack.sameState(other) ||</span><span class="s3">\n                        </span><span class="s1">stack.buffer.length &gt; 500 /* Rec.MinBufferLengthPrune */ &amp;&amp; other.buffer.length &gt; 500 /* Rec.MinBufferLengthPrune */) {</span><span class="s3">\n                        </span><span class="s1">if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) &gt; 0) {</span><span class="s3">\n                            </span><span class="s1">newStacks.splice(j--, 1);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">newStacks.splice(i--, 1);</span><span class="s3">\n                            </span><span class="s1">continue outer;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (newStacks.length &gt; 12 /* Rec.MaxStackCount */)</span><span class="s3">\n                </span><span class="s1">newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.minStackPos = newStacks[0].pos;</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; newStacks.length; i++)</span><span class="s3">\n            </span><span class="s1">if (newStacks[i].pos &lt; this.minStackPos)</span><span class="s3">\n                </span><span class="s1">this.minStackPos = newStacks[i].pos;</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stopAt(pos) {</span><span class="s3">\n        </span><span class="s1">if (this.stoppedAt != null &amp;&amp; this.stoppedAt &lt; pos)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Can't move stoppedAt forward</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Returns an updated version of the given stack, or null if the</span><span class="s3">\n    </span><span class="s1">// stack can't advance normally. When `split` and `stacks` are</span><span class="s3">\n    </span><span class="s1">// given, stacks split off by ambiguous operations will be pushed to</span><span class="s3">\n    </span><span class="s1">// `split`, or added to `stacks` if they move `pos` forward.</span><span class="s3">\n    </span><span class="s1">advanceStack(stack, stacks, split) {</span><span class="s3">\n        </span><span class="s1">let start = stack.pos, { parser } = this;</span><span class="s3">\n        </span><span class="s1">let base = verbose ? this.stackID(stack) + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (this.stoppedAt != null &amp;&amp; start &gt; this.stoppedAt)</span><span class="s3">\n            </span><span class="s1">return stack.forceReduce() ? stack : null;</span><span class="s3">\n        </span><span class="s1">if (this.fragments) {</span><span class="s3">\n            </span><span class="s1">let strictCx = stack.curContext &amp;&amp; stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;</span><span class="s3">\n            </span><span class="s1">for (let cached = this.fragments.nodeAt(start); cached;) {</span><span class="s3">\n                </span><span class="s1">let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;</span><span class="s3">\n                </span><span class="s1">if (match &gt; -1 &amp;&amp; cached.length &amp;&amp; (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {</span><span class="s3">\n                    </span><span class="s1">stack.useNode(cached, match);</span><span class="s3">\n                    </span><span class="s1">if (verbose)</span><span class="s3">\n                        </span><span class="s1">console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] &gt; 0)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">let inner = cached.children[0];</span><span class="s3">\n                </span><span class="s1">if (inner instanceof Tree &amp;&amp; cached.positions[0] == 0)</span><span class="s3">\n                    </span><span class="s1">cached = inner;</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);</span><span class="s3">\n        </span><span class="s1">if (defaultReduce &gt; 0) {</span><span class="s3">\n            </span><span class="s1">stack.reduce(defaultReduce);</span><span class="s3">\n            </span><span class="s1">if (verbose)</span><span class="s3">\n                </span><span class="s1">console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce &amp; 65535 /* Action.ValueMask */)})`);</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (stack.stack.length &gt;= 9000 /* Rec.CutDepth */) {</span><span class="s3">\n            </span><span class="s1">while (stack.stack.length &gt; 6000 /* Rec.CutTo */ &amp;&amp; stack.forceReduce()) { }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let actions = this.tokens.getActions(stack);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; actions.length;) {</span><span class="s3">\n            </span><span class="s1">let action = actions[i++], term = actions[i++], end = actions[i++];</span><span class="s3">\n            </span><span class="s1">let last = i == actions.length || !split;</span><span class="s3">\n            </span><span class="s1">let localStack = last ? stack : stack.split();</span><span class="s3">\n            </span><span class="s1">let main = this.tokens.mainToken;</span><span class="s3">\n            </span><span class="s1">localStack.apply(action, term, main ? main.start : localStack.pos, end);</span><span class="s3">\n            </span><span class="s1">if (verbose)</span><span class="s3">\n                </span><span class="s1">console.log(base + this.stackID(localStack) + ` (via ${(action &amp; 65536 /* Action.ReduceFlag */) == 0 ? </span><span class="s3">\&quot;</span><span class="s1">shift</span><span class="s3">\&quot;\n                    </span><span class="s1">: `reduce of ${parser.getName(action &amp; 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">, split</span><span class="s3">\&quot;</span><span class="s1">})`);</span><span class="s3">\n            </span><span class="s1">if (last)</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">else if (localStack.pos &gt; start)</span><span class="s3">\n                </span><span class="s1">stacks.push(localStack);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">split.push(localStack);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Advance a given stack forward as far as it will go. Returns the</span><span class="s3">\n    </span><span class="s1">// (possibly updated) stack if it got stuck, or null if it moved</span><span class="s3">\n    </span><span class="s1">// forward and was given to `pushStackDedup`.</span><span class="s3">\n    </span><span class="s1">advanceFully(stack, newStacks) {</span><span class="s3">\n        </span><span class="s1">let pos = stack.pos;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (!this.advanceStack(stack, null, null))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">if (stack.pos &gt; pos) {</span><span class="s3">\n                </span><span class="s1">pushStackDedup(stack, newStacks);</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">runRecovery(stacks, tokens, newStacks) {</span><span class="s3">\n        </span><span class="s1">let finished = null, restarted = false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; stacks.length; i++) {</span><span class="s3">\n            </span><span class="s1">let stack = stacks[i], token = tokens[i &lt;&lt; 1], tokenEnd = tokens[(i &lt;&lt; 1) + 1];</span><span class="s3">\n            </span><span class="s1">let base = verbose ? this.stackID(stack) + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">if (stack.deadEnd) {</span><span class="s3">\n                </span><span class="s1">if (restarted)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">restarted = true;</span><span class="s3">\n                </span><span class="s1">stack.restart();</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(base + this.stackID(stack) + </span><span class="s3">\&quot; </span><span class="s1">(restarted)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">let done = this.advanceFully(stack, newStacks);</span><span class="s3">\n                </span><span class="s1">if (done)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let force = stack.split(), forceBase = base;</span><span class="s3">\n            </span><span class="s1">for (let j = 0; force.forceReduce() &amp;&amp; j &lt; 10 /* Rec.ForceReduceLimit */; j++) {</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(forceBase + this.stackID(force) + </span><span class="s3">\&quot; </span><span class="s1">(via force-reduce)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">let done = this.advanceFully(force, newStacks);</span><span class="s3">\n                </span><span class="s1">if (done)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">forceBase = this.stackID(force) + </span><span class="s3">\&quot; </span><span class="s1">-&gt; </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let insert of stack.recoverByInsert(token)) {</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(base + this.stackID(insert) + </span><span class="s3">\&quot; </span><span class="s1">(via recover-insert)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                </span><span class="s1">this.advanceFully(insert, newStacks);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.stream.end &gt; stack.pos) {</span><span class="s3">\n                </span><span class="s1">if (tokenEnd == stack.pos) {</span><span class="s3">\n                    </span><span class="s1">tokenEnd++;</span><span class="s3">\n                    </span><span class="s1">token = 0 /* Term.Err */;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">stack.recoverByDelete(token, tokenEnd);</span><span class="s3">\n                </span><span class="s1">if (verbose)</span><span class="s3">\n                    </span><span class="s1">console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);</span><span class="s3">\n                </span><span class="s1">pushStackDedup(stack, newStacks);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!finished || finished.score &lt; stack.score) {</span><span class="s3">\n                </span><span class="s1">finished = stack;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return finished;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Convert the stack's buffer to a syntax tree.</span><span class="s3">\n    </span><span class="s1">stackToTree(stack) {</span><span class="s3">\n        </span><span class="s1">stack.close();</span><span class="s3">\n        </span><span class="s1">return Tree.build({ buffer: StackBufferCursor.create(stack),</span><span class="s3">\n            </span><span class="s1">nodeSet: this.parser.nodeSet,</span><span class="s3">\n            </span><span class="s1">topID: this.topTerm,</span><span class="s3">\n            </span><span class="s1">maxBufferLength: this.parser.bufferLength,</span><span class="s3">\n            </span><span class="s1">reused: this.reused,</span><span class="s3">\n            </span><span class="s1">start: this.ranges[0].from,</span><span class="s3">\n            </span><span class="s1">length: stack.pos - this.ranges[0].from,</span><span class="s3">\n            </span><span class="s1">minRepeatType: this.parser.minRepeatTerm });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stackID(stack) {</span><span class="s3">\n        </span><span class="s1">let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);</span><span class="s3">\n        </span><span class="s1">if (!id)</span><span class="s3">\n            </span><span class="s1">stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));</span><span class="s3">\n        </span><span class="s1">return id + stack;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function pushStackDedup(stack, newStacks) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; newStacks.length; i++) {</span><span class="s3">\n        </span><span class="s1">let other = newStacks[i];</span><span class="s3">\n        </span><span class="s1">if (other.pos == stack.pos &amp;&amp; other.sameState(stack)) {</span><span class="s3">\n            </span><span class="s1">if (newStacks[i].score &lt; stack.score)</span><span class="s3">\n                </span><span class="s1">newStacks[i] = stack;</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newStacks.push(stack);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Dialect {</span><span class="s3">\n    </span><span class="s1">constructor(source, flags, disabled) {</span><span class="s3">\n        </span><span class="s1">this.source = source;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n        </span><span class="s1">this.disabled = disabled;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">allows(term) { return !this.disabled || this.disabled[term] == 0; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const id = x =&gt; x;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Context trackers are used to track stateful context (such as</span><span class="s3">\n</span><span class="s1">indentation in the Python grammar, or parent elements in the XML</span><span class="s3">\n</span><span class="s1">grammar) needed by external tokenizers. You declare them in a</span><span class="s3">\n</span><span class="s1">grammar file as `@context exportName from </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot;</span><span class="s1">`.</span><span class="s3">\n\n</span><span class="s1">Context values should be immutable, and can be updated (replaced)</span><span class="s3">\n</span><span class="s1">on shift or reduce actions.</span><span class="s3">\n\n</span><span class="s1">The export used in a `@context` declaration should be of this</span><span class="s3">\n</span><span class="s1">type.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ContextTracker {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a context tracker.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">this.start = spec.start;</span><span class="s3">\n        </span><span class="s1">this.shift = spec.shift || id;</span><span class="s3">\n        </span><span class="s1">this.reduce = spec.reduce || id;</span><span class="s3">\n        </span><span class="s1">this.reuse = spec.reuse || id;</span><span class="s3">\n        </span><span class="s1">this.hash = spec.hash || (() =&gt; 0);</span><span class="s3">\n        </span><span class="s1">this.strict = spec.strict !== false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Holds the parse tables for a given grammar, as generated by</span><span class="s3">\n</span><span class="s1">`lezer-generator`, and provides [methods](#common.Parser) to parse</span><span class="s3">\n</span><span class="s1">content with.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LRParser extends Parser {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.wrappers = [];</span><span class="s3">\n        </span><span class="s1">if (spec.version != 14 /* File.Version */)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);</span><span class="s3">\n        </span><span class="s1">let nodeNames = spec.nodeNames.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">this.minRepeatTerm = nodeNames.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; spec.repeatNodeCount; i++)</span><span class="s3">\n            </span><span class="s1">nodeNames.push(</span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let topTerms = Object.keys(spec.topRules).map(r =&gt; spec.topRules[r][1]);</span><span class="s3">\n        </span><span class="s1">let nodeProps = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; nodeNames.length; i++)</span><span class="s3">\n            </span><span class="s1">nodeProps.push([]);</span><span class="s3">\n        </span><span class="s1">function setProp(nodeID, prop, value) {</span><span class="s3">\n            </span><span class="s1">nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (spec.nodeProps)</span><span class="s3">\n            </span><span class="s1">for (let propSpec of spec.nodeProps) {</span><span class="s3">\n                </span><span class="s1">let prop = propSpec[0];</span><span class="s3">\n                </span><span class="s1">if (typeof prop == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">prop = NodeProp[prop];</span><span class="s3">\n                </span><span class="s1">for (let i = 1; i &lt; propSpec.length;) {</span><span class="s3">\n                    </span><span class="s1">let next = propSpec[i++];</span><span class="s3">\n                    </span><span class="s1">if (next &gt;= 0) {</span><span class="s3">\n                        </span><span class="s1">setProp(next, prop, propSpec[i++]);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">let value = propSpec[i + -next];</span><span class="s3">\n                        </span><span class="s1">for (let j = -next; j &gt; 0; j--)</span><span class="s3">\n                            </span><span class="s1">setProp(propSpec[i++], prop, value);</span><span class="s3">\n                        </span><span class="s1">i++;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.nodeSet = new NodeSet(nodeNames.map((name, i) =&gt; NodeType.define({</span><span class="s3">\n            </span><span class="s1">name: i &gt;= this.minRepeatTerm ? undefined : name,</span><span class="s3">\n            </span><span class="s1">id: i,</span><span class="s3">\n            </span><span class="s1">props: nodeProps[i],</span><span class="s3">\n            </span><span class="s1">top: topTerms.indexOf(i) &gt; -1,</span><span class="s3">\n            </span><span class="s1">error: i == 0,</span><span class="s3">\n            </span><span class="s1">skipped: spec.skippedNodes &amp;&amp; spec.skippedNodes.indexOf(i) &gt; -1</span><span class="s3">\n        </span><span class="s1">})));</span><span class="s3">\n        </span><span class="s1">if (spec.propSources)</span><span class="s3">\n            </span><span class="s1">this.nodeSet = this.nodeSet.extend(...spec.propSources);</span><span class="s3">\n        </span><span class="s1">this.strict = false;</span><span class="s3">\n        </span><span class="s1">this.bufferLength = DefaultBufferLength;</span><span class="s3">\n        </span><span class="s1">let tokenArray = decodeArray(spec.tokenData);</span><span class="s3">\n        </span><span class="s1">this.context = spec.context;</span><span class="s3">\n        </span><span class="s1">this.specializerSpecs = spec.specialized || [];</span><span class="s3">\n        </span><span class="s1">this.specialized = new Uint16Array(this.specializerSpecs.length);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.specializerSpecs.length; i++)</span><span class="s3">\n            </span><span class="s1">this.specialized[i] = this.specializerSpecs[i].term;</span><span class="s3">\n        </span><span class="s1">this.specializers = this.specializerSpecs.map(getSpecializer);</span><span class="s3">\n        </span><span class="s1">this.states = decodeArray(spec.states, Uint32Array);</span><span class="s3">\n        </span><span class="s1">this.data = decodeArray(spec.stateData);</span><span class="s3">\n        </span><span class="s1">this.goto = decodeArray(spec.goto);</span><span class="s3">\n        </span><span class="s1">this.maxTerm = spec.maxTerm;</span><span class="s3">\n        </span><span class="s1">this.tokenizers = spec.tokenizers.map(value =&gt; typeof value == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">? new TokenGroup(tokenArray, value) : value);</span><span class="s3">\n        </span><span class="s1">this.topRules = spec.topRules;</span><span class="s3">\n        </span><span class="s1">this.dialects = spec.dialects || {};</span><span class="s3">\n        </span><span class="s1">this.dynamicPrecedences = spec.dynamicPrecedences || null;</span><span class="s3">\n        </span><span class="s1">this.tokenPrecTable = spec.tokenPrec;</span><span class="s3">\n        </span><span class="s1">this.termNames = spec.termNames || null;</span><span class="s3">\n        </span><span class="s1">this.maxNode = this.nodeSet.types.length - 1;</span><span class="s3">\n        </span><span class="s1">this.dialect = this.parseDialect();</span><span class="s3">\n        </span><span class="s1">this.top = this.topRules[Object.keys(this.topRules)[0]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createParse(input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">let parse = new Parse(this, input, fragments, ranges);</span><span class="s3">\n        </span><span class="s1">for (let w of this.wrappers)</span><span class="s3">\n            </span><span class="s1">parse = w(parse, input, fragments, ranges);</span><span class="s3">\n        </span><span class="s1">return parse;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a goto table entry @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getGoto(state, term, loose = false) {</span><span class="s3">\n        </span><span class="s1">let table = this.goto;</span><span class="s3">\n        </span><span class="s1">if (term &gt;= table[0])</span><span class="s3">\n            </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">for (let pos = table[term + 1];;) {</span><span class="s3">\n            </span><span class="s1">let groupTag = table[pos++], last = groupTag &amp; 1;</span><span class="s3">\n            </span><span class="s1">let target = table[pos++];</span><span class="s3">\n            </span><span class="s1">if (last &amp;&amp; loose)</span><span class="s3">\n                </span><span class="s1">return target;</span><span class="s3">\n            </span><span class="s1">for (let end = pos + (groupTag &gt;&gt; 1); pos &lt; end; pos++)</span><span class="s3">\n                </span><span class="s1">if (table[pos] == state)</span><span class="s3">\n                    </span><span class="s1">return target;</span><span class="s3">\n            </span><span class="s1">if (last)</span><span class="s3">\n                </span><span class="s1">return -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Check if this state has an action for a given terminal @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasAction(state, terminal) {</span><span class="s3">\n        </span><span class="s1">let data = this.data;</span><span class="s3">\n        </span><span class="s1">for (let set = 0; set &lt; 2; set++) {</span><span class="s3">\n            </span><span class="s1">for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {</span><span class="s3">\n                </span><span class="s1">if ((next = data[i]) == 65535 /* Seq.End */) {</span><span class="s3">\n                    </span><span class="s1">if (data[i + 1] == 1 /* Seq.Next */)</span><span class="s3">\n                        </span><span class="s1">next = data[i = pair(data, i + 2)];</span><span class="s3">\n                    </span><span class="s1">else if (data[i + 1] == 2 /* Seq.Other */)</span><span class="s3">\n                        </span><span class="s1">return pair(data, i + 2);</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (next == terminal || next == 0 /* Term.Err */)</span><span class="s3">\n                    </span><span class="s1">return pair(data, i + 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stateSlot(state, slot) {</span><span class="s3">\n        </span><span class="s1">return this.states[(state * 6 /* ParseState.Size */) + slot];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">stateFlag(state, flag) {</span><span class="s3">\n        </span><span class="s1">return (this.stateSlot(state, 0 /* ParseState.Flags */) &amp; flag) &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validAction(state, action) {</span><span class="s3">\n        </span><span class="s1">return !!this.allActions(state, a =&gt; a == action ? true : null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">allActions(state, action) {</span><span class="s3">\n        </span><span class="s1">let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);</span><span class="s3">\n        </span><span class="s1">let result = deflt ? action(deflt) : undefined;</span><span class="s3">\n        </span><span class="s1">for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {</span><span class="s3">\n            </span><span class="s1">if (this.data[i] == 65535 /* Seq.End */) {</span><span class="s3">\n                </span><span class="s1">if (this.data[i + 1] == 1 /* Seq.Next */)</span><span class="s3">\n                    </span><span class="s1">i = pair(this.data, i + 2);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">result = action(pair(this.data, i + 1));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the states that can follow this one through shift actions or</span><span class="s3">\n    </span><span class="s1">goto jumps. @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">nextStates(state) {</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {</span><span class="s3">\n            </span><span class="s1">if (this.data[i] == 65535 /* Seq.End */) {</span><span class="s3">\n                </span><span class="s1">if (this.data[i + 1] == 1 /* Seq.Next */)</span><span class="s3">\n                    </span><span class="s1">i = pair(this.data, i + 2);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if ((this.data[i + 2] &amp; (65536 /* Action.ReduceFlag */ &gt;&gt; 16)) == 0) {</span><span class="s3">\n                </span><span class="s1">let value = this.data[i + 1];</span><span class="s3">\n                </span><span class="s1">if (!result.some((v, i) =&gt; (i &amp; 1) &amp;&amp; v == value))</span><span class="s3">\n                    </span><span class="s1">result.push(this.data[i], value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Configure the parser. Returns a new parser instance that has the</span><span class="s3">\n    </span><span class="s1">given settings modified. Settings not provided in `config` are</span><span class="s3">\n    </span><span class="s1">kept from the original parser.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">configure(config) {</span><span class="s3">\n        </span><span class="s1">// Hideous reflection-based kludge to make it easy to create a</span><span class="s3">\n        </span><span class="s1">// slightly modified copy of a parser.</span><span class="s3">\n        </span><span class="s1">let copy = Object.assign(Object.create(LRParser.prototype), this);</span><span class="s3">\n        </span><span class="s1">if (config.props)</span><span class="s3">\n            </span><span class="s1">copy.nodeSet = this.nodeSet.extend(...config.props);</span><span class="s3">\n        </span><span class="s1">if (config.top) {</span><span class="s3">\n            </span><span class="s1">let info = this.topRules[config.top];</span><span class="s3">\n            </span><span class="s1">if (!info)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(`Invalid top rule name ${config.top}`);</span><span class="s3">\n            </span><span class="s1">copy.top = info;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (config.tokenizers)</span><span class="s3">\n            </span><span class="s1">copy.tokenizers = this.tokenizers.map(t =&gt; {</span><span class="s3">\n                </span><span class="s1">let found = config.tokenizers.find(r =&gt; r.from == t);</span><span class="s3">\n                </span><span class="s1">return found ? found.to : t;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (config.specializers) {</span><span class="s3">\n            </span><span class="s1">copy.specializers = this.specializers.slice();</span><span class="s3">\n            </span><span class="s1">copy.specializerSpecs = this.specializerSpecs.map((s, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">let found = config.specializers.find(r =&gt; r.from == s.external);</span><span class="s3">\n                </span><span class="s1">if (!found)</span><span class="s3">\n                    </span><span class="s1">return s;</span><span class="s3">\n                </span><span class="s1">let spec = Object.assign(Object.assign({}, s), { external: found.to });</span><span class="s3">\n                </span><span class="s1">copy.specializers[i] = getSpecializer(spec);</span><span class="s3">\n                </span><span class="s1">return spec;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (config.contextTracker)</span><span class="s3">\n            </span><span class="s1">copy.context = config.contextTracker;</span><span class="s3">\n        </span><span class="s1">if (config.dialect)</span><span class="s3">\n            </span><span class="s1">copy.dialect = this.parseDialect(config.dialect);</span><span class="s3">\n        </span><span class="s1">if (config.strict != null)</span><span class="s3">\n            </span><span class="s1">copy.strict = config.strict;</span><span class="s3">\n        </span><span class="s1">if (config.wrap)</span><span class="s3">\n            </span><span class="s1">copy.wrappers = copy.wrappers.concat(config.wrap);</span><span class="s3">\n        </span><span class="s1">if (config.bufferLength != null)</span><span class="s3">\n            </span><span class="s1">copy.bufferLength = config.bufferLength;</span><span class="s3">\n        </span><span class="s1">return copy;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)</span><span class="s3">\n    </span><span class="s1">are registered for this parser.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">hasWrappers() {</span><span class="s3">\n        </span><span class="s1">return this.wrappers.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns the name associated with a given term. This will only</span><span class="s3">\n    </span><span class="s1">work for all terms when the parser was generated with the</span><span class="s3">\n    </span><span class="s1">`--names` option. By default, only the names of tagged terms are</span><span class="s3">\n    </span><span class="s1">stored.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getName(term) {</span><span class="s3">\n        </span><span class="s1">return this.termNames ? this.termNames[term] : String(term &lt;= this.maxNode &amp;&amp; this.nodeSet.types[term].name || term);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The eof term id is always allocated directly after the node</span><span class="s3">\n    </span><span class="s1">types. @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get eofTerm() { return this.maxNode + 1; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The type of top node produced by the parser.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get topNode() { return this.nodeSet.types[this.top[1]]; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dynamicPrecedence(term) {</span><span class="s3">\n        </span><span class="s1">let prec = this.dynamicPrecedences;</span><span class="s3">\n        </span><span class="s1">return prec == null ? 0 : prec[term] || 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parseDialect(dialect) {</span><span class="s3">\n        </span><span class="s1">let values = Object.keys(this.dialects), flags = values.map(() =&gt; false);</span><span class="s3">\n        </span><span class="s1">if (dialect)</span><span class="s3">\n            </span><span class="s1">for (let part of dialect.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">let id = values.indexOf(part);</span><span class="s3">\n                </span><span class="s1">if (id &gt;= 0)</span><span class="s3">\n                    </span><span class="s1">flags[id] = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let disabled = null;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; values.length; i++)</span><span class="s3">\n            </span><span class="s1">if (!flags[i]) {</span><span class="s3">\n                </span><span class="s1">for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;)</span><span class="s3">\n                    </span><span class="s1">(disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new Dialect(dialect, flags, disabled);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Used by the output of the parser generator. Not available to</span><span class="s3">\n    </span><span class="s1">user code. @hide</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static deserialize(spec) {</span><span class="s3">\n        </span><span class="s1">return new LRParser(spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function pair(data, off) { return data[off] | (data[off + 1] &lt;&lt; 16); }</span><span class="s3">\n</span><span class="s1">function findFinished(stacks) {</span><span class="s3">\n    </span><span class="s1">let best = null;</span><span class="s3">\n    </span><span class="s1">for (let stack of stacks) {</span><span class="s3">\n        </span><span class="s1">let stopped = stack.p.stoppedAt;</span><span class="s3">\n        </span><span class="s1">if ((stack.pos == stack.p.stream.end || stopped != null &amp;&amp; stack.pos &gt; stopped) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!best || best.score &lt; stack.score))</span><span class="s3">\n            </span><span class="s1">best = stack;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return best;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getSpecializer(spec) {</span><span class="s3">\n    </span><span class="s1">if (spec.external) {</span><span class="s3">\n        </span><span class="s1">let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;</span><span class="s3">\n        </span><span class="s1">return (value, stack) =&gt; (spec.external(value, stack) &lt;&lt; 1) | mask;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return spec.get;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { ContextTracker, ExternalTokenizer, InputStream, LRParser, LocalTokenGroup, Stack };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;// shim for using process in browser</span><span class="s3">\n</span><span class="s1">var process = module.exports = {};</span><span class="s3">\n\n</span><span class="s1">// cached from whatever global is present so that test runners that stub it</span><span class="s3">\n</span><span class="s1">// don't break things.  But we need to wrap it in a try catch in case it is</span><span class="s3">\n</span><span class="s1">// wrapped in strict mode code which doesn't define any globals.  It's inside a</span><span class="s3">\n</span><span class="s1">// function because try/catches deoptimize in certain engines.</span><span class="s3">\n\n</span><span class="s1">var cachedSetTimeout;</span><span class="s3">\n</span><span class="s1">var cachedClearTimeout;</span><span class="s3">\n\n</span><span class="s1">function defaultSetTimout() {</span><span class="s3">\n    </span><span class="s1">throw new Error('setTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultClearTimeout () {</span><span class="s3">\n    </span><span class="s1">throw new Error('clearTimeout has not been defined');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">(function () {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof setTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = defaultSetTimout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">if (typeof clearTimeout === 'function') {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = defaultClearTimeout;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">} ())</span><span class="s3">\n</span><span class="s1">function runTimeout(fun) {</span><span class="s3">\n    </span><span class="s1">if (cachedSetTimeout === setTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if setTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &amp;&amp; setTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedSetTimeout = setTimeout;</span><span class="s3">\n        </span><span class="s1">return setTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedSetTimeout(fun, 0);</span><span class="s3">\n    </span><span class="s1">} catch(e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(null, fun, 0);</span><span class="s3">\n        </span><span class="s1">} catch(e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error</span><span class="s3">\n            </span><span class="s1">return cachedSetTimeout.call(this, fun, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function runClearTimeout(marker) {</span><span class="s3">\n    </span><span class="s1">if (cachedClearTimeout === clearTimeout) {</span><span class="s3">\n        </span><span class="s1">//normal enviroments in sane situations</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if clearTimeout wasn't available but was latter defined</span><span class="s3">\n    </span><span class="s1">if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) &amp;&amp; clearTimeout) {</span><span class="s3">\n        </span><span class="s1">cachedClearTimeout = clearTimeout;</span><span class="s3">\n        </span><span class="s1">return clearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">// when when somebody has screwed with setTimeout but no I.E. maddness</span><span class="s3">\n        </span><span class="s1">return cachedClearTimeout(marker);</span><span class="s3">\n    </span><span class="s1">} catch (e){</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(null, marker);</span><span class="s3">\n        </span><span class="s1">} catch (e){</span><span class="s3">\n            </span><span class="s1">// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.</span><span class="s3">\n            </span><span class="s1">// Some versions of I.E. have different rules for clearTimeout vs setTimeout</span><span class="s3">\n            </span><span class="s1">return cachedClearTimeout.call(this, marker);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n\n\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">var queue = [];</span><span class="s3">\n</span><span class="s1">var draining = false;</span><span class="s3">\n</span><span class="s1">var currentQueue;</span><span class="s3">\n</span><span class="s1">var queueIndex = -1;</span><span class="s3">\n\n</span><span class="s1">function cleanUpNextTick() {</span><span class="s3">\n    </span><span class="s1">if (!draining || !currentQueue) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">if (currentQueue.length) {</span><span class="s3">\n        </span><span class="s1">queue = currentQueue.concat(queue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (queue.length) {</span><span class="s3">\n        </span><span class="s1">drainQueue();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function drainQueue() {</span><span class="s3">\n    </span><span class="s1">if (draining) {</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var timeout = runTimeout(cleanUpNextTick);</span><span class="s3">\n    </span><span class="s1">draining = true;</span><span class="s3">\n\n    </span><span class="s1">var len = queue.length;</span><span class="s3">\n    </span><span class="s1">while(len) {</span><span class="s3">\n        </span><span class="s1">currentQueue = queue;</span><span class="s3">\n        </span><span class="s1">queue = [];</span><span class="s3">\n        </span><span class="s1">while (++queueIndex &lt; len) {</span><span class="s3">\n            </span><span class="s1">if (currentQueue) {</span><span class="s3">\n                </span><span class="s1">currentQueue[queueIndex].run();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">queueIndex = -1;</span><span class="s3">\n        </span><span class="s1">len = queue.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">currentQueue = null;</span><span class="s3">\n    </span><span class="s1">draining = false;</span><span class="s3">\n    </span><span class="s1">runClearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">process.nextTick = function (fun) {</span><span class="s3">\n    </span><span class="s1">var args = new Array(arguments.length - 1);</span><span class="s3">\n    </span><span class="s1">if (arguments.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">for (var i = 1; i &lt; arguments.length; i++) {</span><span class="s3">\n            </span><span class="s1">args[i - 1] = arguments[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">queue.push(new Item(fun, args));</span><span class="s3">\n    </span><span class="s1">if (queue.length === 1 &amp;&amp; !draining) {</span><span class="s3">\n        </span><span class="s1">runTimeout(drainQueue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// v8 likes predictible objects</span><span class="s3">\n</span><span class="s1">function Item(fun, array) {</span><span class="s3">\n    </span><span class="s1">this.fun = fun;</span><span class="s3">\n    </span><span class="s1">this.array = array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Item.prototype.run = function () {</span><span class="s3">\n    </span><span class="s1">this.fun.apply(null, this.array);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.title = 'browser';</span><span class="s3">\n</span><span class="s1">process.browser = true;</span><span class="s3">\n</span><span class="s1">process.env = {};</span><span class="s3">\n</span><span class="s1">process.argv = [];</span><span class="s3">\n</span><span class="s1">process.version = ''; // empty string to avoid regexp issues</span><span class="s3">\n</span><span class="s1">process.versions = {};</span><span class="s3">\n\n</span><span class="s1">function noop() {}</span><span class="s3">\n\n</span><span class="s1">process.on = noop;</span><span class="s3">\n</span><span class="s1">process.addListener = noop;</span><span class="s3">\n</span><span class="s1">process.once = noop;</span><span class="s3">\n</span><span class="s1">process.off = noop;</span><span class="s3">\n</span><span class="s1">process.removeListener = noop;</span><span class="s3">\n</span><span class="s1">process.removeAllListeners = noop;</span><span class="s3">\n</span><span class="s1">process.emit = noop;</span><span class="s3">\n</span><span class="s1">process.prependListener = noop;</span><span class="s3">\n</span><span class="s1">process.prependOnceListener = noop;</span><span class="s3">\n\n</span><span class="s1">process.listeners = function (name) { return [] }</span><span class="s3">\n\n</span><span class="s1">process.binding = function (name) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.binding is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">process.cwd = function () { return '/' };</span><span class="s3">\n</span><span class="s1">process.chdir = function (dir) {</span><span class="s3">\n    </span><span class="s1">throw new Error('process.chdir is not supported');</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">process.umask = function() { return 0; };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>