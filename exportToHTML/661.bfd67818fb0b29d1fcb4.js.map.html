<html>
<head>
<title>661.bfd67818fb0b29d1fcb4.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
661.bfd67818fb0b29d1fcb4.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;661.bfd67818fb0b29d1fcb4.js?v=bfd67818fb0b29d1fcb4&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,QAAQ;AAC/B;AACA,2CAA2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM,iBAAiB,MAAM;AAC7B;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,6CAA6C,GAAG,IAAI;AACpD;AACA;;AAEA;AACA,8BAA8B,UAAU;AACxC;AACA;AACA;AACA,sBAAsB,OAAO;AAC7B,4BAA4B,oCAAoC;AAChE,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR,gBAAgB;AAChB;AACA;AACA,qEAAqE,OAAO;AAC5E;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,GAAG;AACrC;AACA,iCAAiC,IAAI;AACrC,4BAA4B,GAAG;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,sBAAsB,oBAAoB,kBAAkB,YAAY;;AAExE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,YAAY;AACZ;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,GAAG;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,wCAAwC,kBAAkB,kBAAkB;AAC5E,6BAA6B,kBAAkB;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,2CAA2C;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;;AAEA;AACA,8EAA8E;AAC9E;AACA;AACA,+HAA+H;AAC/H,iDAAiD;AACjD,kBAAkB,yBAAyB;AAC3C,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,+FAA+F;AAC/F,4DAA4D,cAAc;AAC1E,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,2EAA2E,cAAc;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,6DAA6D,uBAAuB;AACpF;AACA;AACA;AACA;AACA,kBAAkB,kCAAkC;AACpD;AACA;AACA;AACA;AACA;AACA,sBAAsB,EAAE;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,kBAAkB;AAClB;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA,6BAA6B,uBAAuB;AACpD;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA,6BAA6B,wBAAwB;AACrD;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM,wBAAwB,EAAE;AAChC;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,uBAAuB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D,8BAA8B,iBAAiB;AAC/C;AACA;AACA,kBAAkB,sCAAsC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,0CAA0C,uBAAuB;AACjE;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,uBAAuB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB,gCAAgC;AAC/E,8BAA8B,uBAAuB,iCAAiC;AACtF,kBAAkB,uCAAuC,wBAAwB;AACjF;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qCAAqC;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uBAAuB;AAChD;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,cAAc,2BAA2B;AAC5F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0EAA0E,IAAI;AAC9E,uCAAuC;AACvC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,2EAA2E,QAAQ;AACnF;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kDAAkD,GAAG;AACrD,6CAA6C,oBAAoB,yBAAyB;AAC1F,sBAAsB,uBAAuB,kBAAkB;AAC/D;AACA;AACA;AACA;;AAEO,iCAAiC,mBAAmB;AACpD,2BAA2B,yBAAyB;AACpD,6BAA6B,2BAA2B;AACxD,iCAAiC,qCAAqC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/javascript.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function mkJavaScript(parserConfig) {</span><span class="s3">\n  </span><span class="s1">var statementIndent = parserConfig.statementIndent;</span><span class="s3">\n  </span><span class="s1">var jsonldMode = parserConfig.jsonld;</span><span class="s3">\n  </span><span class="s1">var jsonMode = parserConfig.json || jsonldMode;</span><span class="s3">\n  </span><span class="s1">var isTS = parserConfig.typescript;</span><span class="s3">\n  </span><span class="s1">var wordRE = parserConfig.wordCharacters || /[</span><span class="s3">\\</span><span class="s1">w$</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/;</span><span class="s3">\n\n  </span><span class="s1">// Tokenizer</span><span class="s3">\n\n  </span><span class="s1">var keywords = function(){</span><span class="s3">\n    </span><span class="s1">function kw(type) {return {type: type, style: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">};}</span><span class="s3">\n    </span><span class="s1">var A = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword a</span><span class="s3">\&quot;</span><span class="s1">), B = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword b</span><span class="s3">\&quot;</span><span class="s1">), C = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot;</span><span class="s1">), D = kw(</span><span class="s3">\&quot;</span><span class="s1">keyword d</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">var operator = kw(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">), atom = {type: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">, style: </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      \&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">: A, </span><span class="s3">\&quot;</span><span class="s1">with</span><span class="s3">\&quot;</span><span class="s1">: A, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">: B, </span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">: B, </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">: B, </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">: B,</span><span class="s3">\n      \&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">: D, </span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">: D, </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">: D, </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">: C,</span><span class="s3">\n      \&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">const</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">let</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      \&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      \&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      \&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">: operator, </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">: operator, </span><span class="s3">\&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">: operator,</span><span class="s3">\n      \&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot;</span><span class="s1">: atom, </span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">: atom,</span><span class="s3">\n      \&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">super</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      \&quot;</span><span class="s1">yield</span><span class="s3">\&quot;</span><span class="s1">: C, </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">: kw(</span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">: C,</span><span class="s3">\n      \&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">: C</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}();</span><span class="s3">\n\n  </span><span class="s1">var isOperatorChar = /[+</span><span class="s3">\\</span><span class="s1">-*&amp;%=&lt;&gt;!?|~^@]/;</span><span class="s3">\n  </span><span class="s1">var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)</span><span class="s3">\&quot;</span><span class="s1">/;</span><span class="s3">\n\n  </span><span class="s1">function readRegexp(stream) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next, inSet = false;</span><span class="s3">\n    </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (!escaped) {</span><span class="s3">\n        </span><span class="s1">if (next == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !inSet) return;</span><span class="s3">\n        </span><span class="s1">if (next == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) inSet = true;</span><span class="s3">\n        </span><span class="s1">else if (inSet &amp;&amp; next == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">) inSet = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Used as scratch variables to communicate multiple values without</span><span class="s3">\n  </span><span class="s1">// consing up tons of objects.</span><span class="s3">\n  </span><span class="s1">var type, content;</span><span class="s3">\n  </span><span class="s1">function ret(tp, style, cont) {</span><span class="s3">\n    </span><span class="s1">type = tp; content = cont;</span><span class="s3">\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch = stream.next();</span><span class="s3">\n    </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">' || ch == </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenString(ch);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^</span><span class="s3">\\</span><span class="s1">d[</span><span class="s3">\\</span><span class="s1">d_]*(?:[eE][+</span><span class="s3">\\</span><span class="s1">-]?[</span><span class="s3">\\</span><span class="s1">d_]+)?/)) {</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">..</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (/[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">),;</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">.]/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">return ret(ch);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^(?:x[</span><span class="s3">\\</span><span class="s1">dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (/</span><span class="s3">\\</span><span class="s1">d/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">stream.match(/^[</span><span class="s3">\\</span><span class="s1">d_]*(?:n|(?:</span><span class="s3">\\</span><span class="s1">.[</span><span class="s3">\\</span><span class="s1">d_]*)?(?:[eE][+</span><span class="s3">\\</span><span class="s1">-]?[</span><span class="s3">\\</span><span class="s1">d_]+)?)?/);</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n        </span><span class="s1">return tokenComment(stream, state);</span><span class="s3">\n      </span><span class="s1">} else if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n        </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (expressionAllowed(stream, state, 1)) {</span><span class="s3">\n        </span><span class="s1">readRegexp(stream);</span><span class="s3">\n        </span><span class="s1">stream.match(/^</span><span class="s3">\\</span><span class="s1">b(([gimyus])(?![gimyus]*</span><span class="s3">\\</span><span class="s1">2))+</span><span class="s3">\\</span><span class="s1">b/);</span><span class="s3">\n        </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stream.eat(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, stream.current());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenQuasi;</span><span class="s3">\n      </span><span class="s1">return tokenQuasi(stream, state);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eatWhile(wordRE)) {</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (ch == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">!--</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n               </span><span class="s1">(ch == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(</span><span class="s3">\&quot;</span><span class="s1">-&gt;</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">S/.test(stream.string.slice(0, stream.start)))) {</span><span class="s3">\n      </span><span class="s1">stream.skipToEnd()</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">} else if (isOperatorChar.test(ch)) {</span><span class="s3">\n      </span><span class="s1">if (ch != </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot; </span><span class="s1">|| !state.lexical || state.lexical.type != </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot; </span><span class="s1">|| ch == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) stream.eat(</span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">} else if (/[&lt;&gt;*+</span><span class="s3">\\</span><span class="s1">-|&amp;?]/.test(ch)) {</span><span class="s3">\n          </span><span class="s1">stream.eat(ch)</span><span class="s3">\n          </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">) stream.eat(ch)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)) return ret(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">, stream.current());</span><span class="s3">\n    </span><span class="s1">} else if (wordRE.test(ch)) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(wordRE);</span><span class="s3">\n      </span><span class="s1">var word = stream.current()</span><span class="s3">\n      </span><span class="s1">if (state.lastType != </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (keywords.propertyIsEnumerable(word)) {</span><span class="s3">\n          </span><span class="s1">var kw = keywords[word]</span><span class="s3">\n          </span><span class="s1">return ret(kw.type, kw.style, word)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (word == </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(/^(</span><span class="s3">\\</span><span class="s1">s|</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*([^*]|</span><span class="s3">\\</span><span class="s1">*(?!</span><span class="s3">\\</span><span class="s1">/))*?</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">/)*[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">w]/, false))</span><span class="s3">\n          </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">, word)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, word)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenString(quote) {</span><span class="s3">\n    </span><span class="s1">return function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var escaped = false, next;</span><span class="s3">\n      </span><span class="s1">if (jsonldMode &amp;&amp; stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.match(isJsonldKeyword)){</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">jsonld-keyword</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n        </span><span class="s1">if (next == quote &amp;&amp; !escaped) break;</span><span class="s3">\n        </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!escaped) state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n    </span><span class="s1">var maybeEnd = false, ch;</span><span class="s3">\n    </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenQuasi(stream, state) {</span><span class="s3">\n    </span><span class="s1">var escaped = false, next;</span><span class="s3">\n    </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n      </span><span class="s1">if (!escaped &amp;&amp; (next == </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot; </span><span class="s1">|| next == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.eat(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">))) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ret(</span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">, stream.current());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var brackets = </span><span class="s3">\&quot;</span><span class="s1">([{}])</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// This is a crude lookahead trick to try and notice that we're</span><span class="s3">\n  </span><span class="s1">// parsing the argument patterns for a fat-arrow function before we</span><span class="s3">\n  </span><span class="s1">// actually hit the arrow token. It only works if the arrow is on</span><span class="s3">\n  </span><span class="s1">// the same line as the arguments and there's no strange noise</span><span class="s3">\n  </span><span class="s1">// (comments) in between. Fallback is to only notice when we hit the</span><span class="s3">\n  </span><span class="s1">// arrow, and not declare the arguments as locals for the arrow</span><span class="s3">\n  </span><span class="s1">// body.</span><span class="s3">\n  </span><span class="s1">function findFatArrow(stream, state) {</span><span class="s3">\n    </span><span class="s1">if (state.fatArrowAt) state.fatArrowAt = null;</span><span class="s3">\n    </span><span class="s1">var arrow = stream.string.indexOf(</span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">, stream.start);</span><span class="s3">\n    </span><span class="s1">if (arrow &lt; 0) return;</span><span class="s3">\n\n    </span><span class="s1">if (isTS) { // Try to skip TypeScript return type declarations after the arguments</span><span class="s3">\n      </span><span class="s1">var m = /:</span><span class="s3">\\</span><span class="s1">s*(?:</span><span class="s3">\\</span><span class="s1">w+(?:&lt;[^&gt;]*&gt;|</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">])?|</span><span class="s3">\\</span><span class="s1">{[^}]*</span><span class="s3">\\</span><span class="s1">})</span><span class="s3">\\</span><span class="s1">s*$/.exec(stream.string.slice(stream.start, arrow))</span><span class="s3">\n      </span><span class="s1">if (m) arrow = m.index</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var depth = 0, sawSomething = false;</span><span class="s3">\n    </span><span class="s1">for (var pos = arrow - 1; pos &gt;= 0; --pos) {</span><span class="s3">\n      </span><span class="s1">var ch = stream.string.charAt(pos);</span><span class="s3">\n      </span><span class="s1">var bracket = brackets.indexOf(ch);</span><span class="s3">\n      </span><span class="s1">if (bracket &gt;= 0 &amp;&amp; bracket &lt; 3) {</span><span class="s3">\n        </span><span class="s1">if (!depth) { ++pos; break; }</span><span class="s3">\n        </span><span class="s1">if (--depth == 0) { if (ch == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) sawSomething = true; break; }</span><span class="s3">\n      </span><span class="s1">} else if (bracket &gt;= 3 &amp;&amp; bracket &lt; 6) {</span><span class="s3">\n        </span><span class="s1">++depth;</span><span class="s3">\n      </span><span class="s1">} else if (wordRE.test(ch)) {</span><span class="s3">\n        </span><span class="s1">sawSomething = true;</span><span class="s3">\n      </span><span class="s1">} else if (/[</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\\</span><span class="s1">/`]/.test(ch)) {</span><span class="s3">\n        </span><span class="s1">for (;; --pos) {</span><span class="s3">\n          </span><span class="s1">if (pos == 0) return</span><span class="s3">\n          </span><span class="s1">var next = stream.string.charAt(pos - 1)</span><span class="s3">\n          </span><span class="s1">if (next == ch &amp;&amp; stream.string.charAt(pos - 2) != </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">) { pos--; break }</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (sawSomething &amp;&amp; !depth) {</span><span class="s3">\n        </span><span class="s1">++pos;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (sawSomething &amp;&amp; !depth) state.fatArrowAt = pos;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Parser</span><span class="s3">\n\n  </span><span class="s1">var atomicTypes = {</span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">: true,</span><span class="s3">\n                     \&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">: true, </span><span class="s3">\&quot;</span><span class="s1">jsonld-keyword</span><span class="s3">\&quot;</span><span class="s1">: true};</span><span class="s3">\n\n  </span><span class="s1">function JSLexical(indented, column, type, align, prev, info) {</span><span class="s3">\n    </span><span class="s1">this.indented = indented;</span><span class="s3">\n    </span><span class="s1">this.column = column;</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">this.prev = prev;</span><span class="s3">\n    </span><span class="s1">this.info = info;</span><span class="s3">\n    </span><span class="s1">if (align != null) this.align = align;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function inScope(state, varname) {</span><span class="s3">\n    </span><span class="s1">for (var v = state.localVars; v; v = v.next)</span><span class="s3">\n      </span><span class="s1">if (v.name == varname) return true;</span><span class="s3">\n    </span><span class="s1">for (var cx = state.context; cx; cx = cx.prev) {</span><span class="s3">\n      </span><span class="s1">for (var v = cx.vars; v; v = v.next)</span><span class="s3">\n        </span><span class="s1">if (v.name == varname) return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function parseJS(state, style, type, content, stream) {</span><span class="s3">\n    </span><span class="s1">var cc = state.cc;</span><span class="s3">\n    </span><span class="s1">// Communicate our context to the combinators.</span><span class="s3">\n    </span><span class="s1">// (Less wasteful than consing up a hundred closures on every call.)</span><span class="s3">\n    </span><span class="s1">cx.state = state; cx.stream = stream; cx.marked = null; cx.cc = cc; cx.style = style;</span><span class="s3">\n\n    </span><span class="s1">if (!state.lexical.hasOwnProperty(</span><span class="s3">\&quot;</span><span class="s1">align</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n      </span><span class="s1">state.lexical.align = true;</span><span class="s3">\n\n    </span><span class="s1">while(true) {</span><span class="s3">\n      </span><span class="s1">var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;</span><span class="s3">\n      </span><span class="s1">if (combinator(type, content)) {</span><span class="s3">\n        </span><span class="s1">while(cc.length &amp;&amp; cc[cc.length - 1].lex)</span><span class="s3">\n          </span><span class="s1">cc.pop()();</span><span class="s3">\n        </span><span class="s1">if (cx.marked) return cx.marked;</span><span class="s3">\n        </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; inScope(state, content)) return </span><span class="s3">\&quot;</span><span class="s1">variableName.local</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">return style;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Combinator utils</span><span class="s3">\n\n  </span><span class="s1">var cx = {state: null, column: null, marked: null, cc: null};</span><span class="s3">\n  </span><span class="s1">function pass() {</span><span class="s3">\n    </span><span class="s1">for (var i = arguments.length - 1; i &gt;= 0; i--) cx.cc.push(arguments[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function cont() {</span><span class="s3">\n    </span><span class="s1">pass.apply(null, arguments);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function inList(name, list) {</span><span class="s3">\n    </span><span class="s1">for (var v = list; v; v = v.next) if (v.name == name) return true</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function register(varname) {</span><span class="s3">\n    </span><span class="s1">var state = cx.state;</span><span class="s3">\n    </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (state.context) {</span><span class="s3">\n      </span><span class="s1">if (state.lexical.info == </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; state.context &amp;&amp; state.context.block) {</span><span class="s3">\n        </span><span class="s1">// FIXME function decls are also not block scoped</span><span class="s3">\n        </span><span class="s1">var newContext = registerVarScoped(varname, state.context)</span><span class="s3">\n        </span><span class="s1">if (newContext != null) {</span><span class="s3">\n          </span><span class="s1">state.context = newContext</span><span class="s3">\n          </span><span class="s1">return</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (!inList(varname, state.localVars)) {</span><span class="s3">\n        </span><span class="s1">state.localVars = new Var(varname, state.localVars)</span><span class="s3">\n        </span><span class="s1">return</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Fall through means this is global</span><span class="s3">\n    </span><span class="s1">if (parserConfig.globalVars &amp;&amp; !inList(varname, state.globalVars))</span><span class="s3">\n      </span><span class="s1">state.globalVars = new Var(varname, state.globalVars)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function registerVarScoped(varname, context) {</span><span class="s3">\n    </span><span class="s1">if (!context) {</span><span class="s3">\n      </span><span class="s1">return null</span><span class="s3">\n    </span><span class="s1">} else if (context.block) {</span><span class="s3">\n      </span><span class="s1">var inner = registerVarScoped(varname, context.prev)</span><span class="s3">\n      </span><span class="s1">if (!inner) return null</span><span class="s3">\n      </span><span class="s1">if (inner == context.prev) return context</span><span class="s3">\n      </span><span class="s1">return new Context(inner, context.vars, true)</span><span class="s3">\n    </span><span class="s1">} else if (inList(varname, context.vars)) {</span><span class="s3">\n      </span><span class="s1">return context</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return new Context(context.prev, new Var(varname, context.vars), false)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function isModifier(name) {</span><span class="s3">\n    </span><span class="s1">return name == </span><span class="s3">\&quot;</span><span class="s1">public</span><span class="s3">\&quot; </span><span class="s1">|| name == </span><span class="s3">\&quot;</span><span class="s1">private</span><span class="s3">\&quot; </span><span class="s1">|| name == </span><span class="s3">\&quot;</span><span class="s1">protected</span><span class="s3">\&quot; </span><span class="s1">|| name == </span><span class="s3">\&quot;</span><span class="s1">abstract</span><span class="s3">\&quot; </span><span class="s1">|| name == </span><span class="s3">\&quot;</span><span class="s1">readonly</span><span class="s3">\&quot;\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Combinators</span><span class="s3">\n\n  </span><span class="s1">function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }</span><span class="s3">\n  </span><span class="s1">function Var(name, next) { this.name = name; this.next = next }</span><span class="s3">\n\n  </span><span class="s1">var defaultVars = new Var(</span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, new Var(</span><span class="s3">\&quot;</span><span class="s1">arguments</span><span class="s3">\&quot;</span><span class="s1">, null))</span><span class="s3">\n  </span><span class="s1">function pushcontext() {</span><span class="s3">\n    </span><span class="s1">cx.state.context = new Context(cx.state.context, cx.state.localVars, false)</span><span class="s3">\n    </span><span class="s1">cx.state.localVars = defaultVars</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function pushblockcontext() {</span><span class="s3">\n    </span><span class="s1">cx.state.context = new Context(cx.state.context, cx.state.localVars, true)</span><span class="s3">\n    </span><span class="s1">cx.state.localVars = null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">pushcontext.lex = pushblockcontext.lex = true</span><span class="s3">\n  </span><span class="s1">function popcontext() {</span><span class="s3">\n    </span><span class="s1">cx.state.localVars = cx.state.context.vars</span><span class="s3">\n    </span><span class="s1">cx.state.context = cx.state.context.prev</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">popcontext.lex = true</span><span class="s3">\n  </span><span class="s1">function pushlex(type, info) {</span><span class="s3">\n    </span><span class="s1">var result = function() {</span><span class="s3">\n      </span><span class="s1">var state = cx.state, indent = state.indented;</span><span class="s3">\n      </span><span class="s1">if (state.lexical.type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">) indent = state.lexical.indented;</span><span class="s3">\n      </span><span class="s1">else for (var outer = state.lexical; outer &amp;&amp; outer.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; outer.align; outer = outer.prev)</span><span class="s3">\n        </span><span class="s1">indent = outer.indented;</span><span class="s3">\n      </span><span class="s1">state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">result.lex = true;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function poplex() {</span><span class="s3">\n    </span><span class="s1">var state = cx.state;</span><span class="s3">\n    </span><span class="s1">if (state.lexical.prev) {</span><span class="s3">\n      </span><span class="s1">if (state.lexical.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">state.indented = state.lexical.indented;</span><span class="s3">\n      </span><span class="s1">state.lexical = state.lexical.prev;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">poplex.lex = true;</span><span class="s3">\n\n  </span><span class="s1">function expect(wanted) {</span><span class="s3">\n    </span><span class="s1">function exp(type) {</span><span class="s3">\n      </span><span class="s1">if (type == wanted) return cont();</span><span class="s3">\n      </span><span class="s1">else if (wanted == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">) return pass();</span><span class="s3">\n      </span><span class="s1">else return cont(exp);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return exp;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function statement(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">vardef</span><span class="s3">\&quot;</span><span class="s1">, value), vardef, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword a</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), parenExpr, statement, poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword b</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), statement, poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword d</span><span class="s3">\&quot;</span><span class="s1">) return cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*$/, false) ? cont() : cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), maybeexpression, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">) return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), pushblockcontext, block, poplex, popcontext);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (cx.state.lexical.info == </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; cx.state.cc[cx.state.cc.length - 1] == poplex)</span><span class="s3">\n        </span><span class="s1">cx.state.cc.pop()();</span><span class="s3">\n      </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), parenExpr, statement, poplex, maybeelse);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), pushblockcontext, forspec, statement, popcontext, poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot; </span><span class="s1">|| (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">, type == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot; </span><span class="s1">? type : value), className, poplex)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">declare</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n        </span><span class="s1">return cont(statement)</span><span class="s3">\n      </span><span class="s1">} else if (isTS &amp;&amp; (value == </span><span class="s3">\&quot;</span><span class="s1">module</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">w/, false)) {</span><span class="s3">\n        </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n        </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">) return cont(enumdef);</span><span class="s3">\n        </span><span class="s1">else if (value == </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">) return cont(typename, expect(</span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">), typeexpr, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">else return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), pattern, expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">), pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), block, poplex, poplex)</span><span class="s3">\n      </span><span class="s1">} else if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">namespace</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n        </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), expression, statement, poplex)</span><span class="s3">\n      </span><span class="s1">} else if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">abstract</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n        </span><span class="s1">return cont(statement)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), maybelabel);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), parenExpr, expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">), pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">), pushblockcontext,</span><span class="s3">\n                                      </span><span class="s1">block, poplex, poplex, popcontext);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), pushcontext, maybeCatchBinding, statement, poplex, popcontext);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">export</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), afterExport, poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">import</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), afterImport, poplex);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">) return cont(statement)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, statement)</span><span class="s3">\n    </span><span class="s1">return pass(pushlex(</span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">), expression, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeCatchBinding(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(funarg, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function expression(type, value) {</span><span class="s3">\n    </span><span class="s1">return expressionInner(type, value, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function expressionNoComma(type, value) {</span><span class="s3">\n    </span><span class="s1">return expressionInner(type, value, true);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function parenExpr(type) {</span><span class="s3">\n    </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return pass()</span><span class="s3">\n    </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), maybeexpression, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function expressionInner(type, value, noComma) {</span><span class="s3">\n    </span><span class="s1">if (cx.state.fatArrowAt == cx.stream.start) {</span><span class="s3">\n      </span><span class="s1">var body = noComma ? arrowBodyNoComma : arrowBody;</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushcontext, pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), commasep(funarg, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, expect(</span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">), body, popcontext);</span><span class="s3">\n      </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return pass(pushcontext, pattern, expect(</span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">), body, popcontext);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;</span><span class="s3">\n    </span><span class="s1">if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) return cont(functiondef, maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot; </span><span class="s1">|| (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;</span><span class="s1">)) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), classExpression, poplex); }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword c</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">) return cont(noComma ? expressionNoComma : expression);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), maybeexpression, expect(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) return cont(noComma ? expressionNoComma : expression);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), arrayLiteral, poplex, maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return contCommasep(objprop, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">, null, maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">) return pass(quasi, maybeop);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybeTarget(noComma));</span><span class="s3">\n    </span><span class="s1">return cont();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeexpression(type) {</span><span class="s3">\n    </span><span class="s1">if (type.match(/[;</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">],]/)) return pass();</span><span class="s3">\n    </span><span class="s1">return pass(expression);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function maybeoperatorComma(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybeexpression);</span><span class="s3">\n    </span><span class="s1">return maybeoperatorNoComma(type, value, false);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeoperatorNoComma(type, value, noComma) {</span><span class="s3">\n    </span><span class="s1">var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;</span><span class="s3">\n    </span><span class="s1">var expr = noComma == false ? expression : expressionNoComma;</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">+|--/.test(value) || isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot;</span><span class="s1">) return cont(me);</span><span class="s3">\n      </span><span class="s1">if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; cx.stream.match(/^([^&lt;&gt;]|&lt;[^&lt;&gt;]*&gt;)*&gt;</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">(/, false))</span><span class="s3">\n        </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeexpr, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, me);</span><span class="s3">\n      </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">), expr);</span><span class="s3">\n      </span><span class="s1">return cont(expr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">) { return pass(quasi, me); }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return;</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return contCommasep(expressionNoComma, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">, me);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) return cont(property, me);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), maybeexpression, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), poplex, me);</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(typeexpr, me) }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.state.lastType = cx.marked = </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;\n      </span><span class="s1">cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)</span><span class="s3">\n      </span><span class="s1">return cont(expr)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function quasi(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">) return pass();</span><span class="s3">\n    </span><span class="s1">if (value.slice(value.length - 2) != </span><span class="s3">\&quot;</span><span class="s1">${</span><span class="s3">\&quot;</span><span class="s1">) return cont(quasi);</span><span class="s3">\n    </span><span class="s1">return cont(maybeexpression, continueQuasi);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function continueQuasi(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">cx.state.tokenize = tokenQuasi;</span><span class="s3">\n      </span><span class="s1">return cont(quasi);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function arrowBody(type) {</span><span class="s3">\n    </span><span class="s1">findFatArrow(cx.stream, cx.state);</span><span class="s3">\n    </span><span class="s1">return pass(type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">? statement : expression);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function arrowBodyNoComma(type) {</span><span class="s3">\n    </span><span class="s1">findFatArrow(cx.stream, cx.state);</span><span class="s3">\n    </span><span class="s1">return pass(type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">? statement : expressionNoComma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeTarget(noComma) {</span><span class="s3">\n    </span><span class="s1">return function(type) {</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) return cont(noComma ? targetNoComma : target);</span><span class="s3">\n      </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)</span><span class="s3">\n      </span><span class="s1">else return pass(noComma ? expressionNoComma : expression);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function target(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(maybeoperatorComma); }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function targetNoComma(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(maybeoperatorNoComma); }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybelabel(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(poplex, statement);</span><span class="s3">\n    </span><span class="s1">return pass(maybeoperatorComma, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">), poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function property(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">; return cont();}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function objprop(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(objprop);</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| cx.style == </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot;</span><span class="s1">) return cont(getterSetter);</span><span class="s3">\n      </span><span class="s1">var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params</span><span class="s3">\n      </span><span class="s1">if (isTS &amp;&amp; cx.state.fatArrowAt == cx.stream.start &amp;&amp; (m = cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*:</span><span class="s3">\\</span><span class="s1">s*/, false)))</span><span class="s3">\n        </span><span class="s1">cx.state.fatArrowAt = cx.stream.pos + m[0].length</span><span class="s3">\n      </span><span class="s1">return cont(afterprop);</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = jsonldMode ? </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot; </span><span class="s1">: (cx.style + </span><span class="s3">\&quot; </span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return cont(afterprop);</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">jsonld-keyword</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(afterprop);</span><span class="s3">\n    </span><span class="s1">} else if (isTS &amp;&amp; isModifier(value)) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(objprop)</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(expression, maybetype, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), afterprop);</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(expressionNoComma, afterprop);</span><span class="s3">\n    </span><span class="s1">} else if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(objprop);</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return pass(afterprop)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function getterSetter(type) {</span><span class="s3">\n    </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return pass(afterprop);</span><span class="s3">\n    </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return cont(functiondef);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function afterprop(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(expressionNoComma);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return pass(functiondef);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function commasep(what, end, sep) {</span><span class="s3">\n    </span><span class="s1">function proceed(type, value) {</span><span class="s3">\n      </span><span class="s1">if (sep ? sep.indexOf(type) &gt; -1 : type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">var lex = cx.state.lexical;</span><span class="s3">\n        </span><span class="s1">if (lex.info == </span><span class="s3">\&quot;</span><span class="s1">call</span><span class="s3">\&quot;</span><span class="s1">) lex.pos = (lex.pos || 0) + 1;</span><span class="s3">\n        </span><span class="s1">return cont(function(type, value) {</span><span class="s3">\n          </span><span class="s1">if (type == end || value == end) return pass()</span><span class="s3">\n          </span><span class="s1">return pass(what)</span><span class="s3">\n        </span><span class="s1">}, proceed);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (type == end || value == end) return cont();</span><span class="s3">\n      </span><span class="s1">if (sep &amp;&amp; sep.indexOf(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) &gt; -1) return pass(what)</span><span class="s3">\n      </span><span class="s1">return cont(expect(end));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return function(type, value) {</span><span class="s3">\n      </span><span class="s1">if (type == end || value == end) return cont();</span><span class="s3">\n      </span><span class="s1">return pass(what, proceed);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function contCommasep(what, end, info) {</span><span class="s3">\n    </span><span class="s1">for (var i = 3; i &lt; arguments.length; i++)</span><span class="s3">\n      </span><span class="s1">cx.cc.push(arguments[i]);</span><span class="s3">\n    </span><span class="s1">return cont(pushlex(end, info), commasep(what, end), poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function block(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n    </span><span class="s1">return pass(statement, block);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybetype(type, value) {</span><span class="s3">\n    </span><span class="s1">if (isTS) {</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr);</span><span class="s3">\n      </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybetype);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybetypeOrIn(type, value) {</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">)) return cont(typeexpr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function mayberettype(type) {</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">w+</span><span class="s3">\\</span><span class="s1">s+is</span><span class="s3">\\</span><span class="s1">b/, false)) return cont(expression, isKW, typeexpr)</span><span class="s3">\n      </span><span class="s1">else return cont(typeexpr)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function isKW(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">is</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n      </span><span class="s1">return cont()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typeexpr(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">keyof</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">infer</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">readonly</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(value == </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot; </span><span class="s1">? expressionNoComma : typeexpr)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">void</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(afterType)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">) return cont(afterType);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeexpr, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">), poplex, afterType)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), typeprops, poplex, afterType)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(commasep(typearg, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), maybeReturnType, afterType)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(commasep(typeexpr, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), typeexpr)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">) return pass(quasiType, afterType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeReturnType(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typeprops(type) {</span><span class="s3">\n    </span><span class="s1">if (type.match(/[</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">]]/)) return cont()</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeprops)</span><span class="s3">\n    </span><span class="s1">return pass(typeprop, typeprops)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typeprop(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| cx.style == </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(typeprop)</span><span class="s3">\n    </span><span class="s1">} else if (value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(typeprop)</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(typeexpr)</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">), maybetypeOrIn, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), typeprop)</span><span class="s3">\n    </span><span class="s1">} else if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return pass(functiondecl, typeprop)</span><span class="s3">\n    </span><span class="s1">} else if (!type.match(/[;</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">],]/)) {</span><span class="s3">\n      </span><span class="s1">return cont()</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function quasiType(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type != </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot;</span><span class="s1">) return pass();</span><span class="s3">\n    </span><span class="s1">if (value.slice(value.length - 2) != </span><span class="s3">\&quot;</span><span class="s1">${</span><span class="s3">\&quot;</span><span class="s1">) return cont(quasiType);</span><span class="s3">\n    </span><span class="s1">return cont(typeexpr, continueQuasiType);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function continueQuasiType(type) {</span><span class="s3">\n   </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">cx.state.tokenize = tokenQuasi;</span><span class="s3">\n      </span><span class="s1">return cont(quasiType);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typearg(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*[?:]/, false) || value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) return cont(typearg)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) return cont(typearg)</span><span class="s3">\n    </span><span class="s1">return pass(typeexpr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function afterType(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeexpr, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, afterType)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), afterType)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">implements</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(typeexpr) }</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr, expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">), typeexpr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeTypeArgs(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeexpr, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, afterType)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typeparam() {</span><span class="s3">\n    </span><span class="s1">return pass(typeexpr, maybeTypeDefault)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeTypeDefault(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function vardef(_, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">enum</span><span class="s3">\&quot;</span><span class="s1">) {cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(enumdef)}</span><span class="s3">\n    </span><span class="s1">return pass(pattern, maybetype, maybeAssign, vardefCont);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function pattern(type, value) {</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; isModifier(value)) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(pattern) }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) { register(value); return cont(); }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) return cont(pattern);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return contCommasep(eltpattern, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return contCommasep(proppattern, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function proppattern(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s*:/, false)) {</span><span class="s3">\n      </span><span class="s1">register(value);</span><span class="s3">\n      </span><span class="s1">return cont(maybeAssign);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) return cont(pattern);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) return pass();</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, expect(']'), expect(':'), proppattern);</span><span class="s3">\n    </span><span class="s1">return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">), pattern, maybeAssign);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function eltpattern() {</span><span class="s3">\n    </span><span class="s1">return pass(pattern, maybeAssign)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeAssign(_type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) return cont(expressionNoComma);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function vardefCont(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(vardef);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeelse(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword b</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">), statement, poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function forspec(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">await</span><span class="s3">\&quot;</span><span class="s1">) return cont(forspec);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), forspec1, poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function forspec1(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">var</span><span class="s3">\&quot;</span><span class="s1">) return cont(vardef, forspec2);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return cont(forspec2);</span><span class="s3">\n    </span><span class="s1">return pass(forspec2)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function forspec2(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">) return cont()</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">) return cont(forspec2)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">of</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(expression, forspec2) }</span><span class="s3">\n    </span><span class="s1">return pass(expression, forspec2)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function functiondef(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(functiondef);}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {register(value); return cont(functiondef);}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushcontext, pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), commasep(funarg, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, mayberettype, statement, popcontext);</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeparam, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, functiondef)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function functiondecl(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(functiondecl);}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {register(value); return cont(functiondecl);}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushcontext, pushlex(</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), commasep(funarg, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">), poplex, mayberettype, popcontext);</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeparam, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, functiondecl)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function typename(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;\n      </span><span class="s1">return cont(typename)</span><span class="s3">\n    </span><span class="s1">} else if (value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeparam, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function funarg(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) cont(expression, funarg)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">spread</span><span class="s3">\&quot;</span><span class="s1">) return cont(funarg);</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; isModifier(value)) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(funarg); }</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; type == </span><span class="s3">\&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">) return cont(maybetype, maybeAssign)</span><span class="s3">\n    </span><span class="s1">return pass(pattern, maybetype, maybeAssign);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function classExpression(type, value) {</span><span class="s3">\n    </span><span class="s1">// Class expressions may have an optional name.</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return className(type, value);</span><span class="s3">\n    </span><span class="s1">return classNameAfter(type, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function className(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) {register(value); return cont(classNameAfter);}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function classNameAfter(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">&lt;</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), commasep(typeparam, </span><span class="s3">\&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">), poplex, classNameAfter)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">implements</span><span class="s3">\&quot; </span><span class="s1">|| (isTS &amp;&amp; type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">implements</span><span class="s3">\&quot;</span><span class="s1">) cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(isTS ? typeexpr : expression, classNameAfter);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), classBody, poplex);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function classBody(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">async</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n        </span><span class="s1">(type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp;</span><span class="s3">\n         </span><span class="s1">(value == </span><span class="s3">\&quot;</span><span class="s1">static</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">set</span><span class="s3">\&quot; </span><span class="s1">|| (isTS &amp;&amp; isModifier(value))) &amp;&amp;</span><span class="s3">\n         </span><span class="s1">cx.stream.match(/^</span><span class="s3">\\</span><span class="s1">s+#?[</span><span class="s3">\\</span><span class="s1">w$</span><span class="s3">\\</span><span class="s1">xa1-</span><span class="s3">\\</span><span class="s1">uffff]/, false))) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(classBody);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot; </span><span class="s1">|| cx.style == </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(classfield, classBody);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) return cont(classfield, classBody);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">return cont(expression, maybetype, expect(</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">), classfield, classBody)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">return cont(classBody);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isTS &amp;&amp; type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return pass(functiondecl, classBody)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">|| type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(classBody);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">) return cont(expression, classBody)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function classfield(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">!</span><span class="s3">\&quot; </span><span class="s1">|| value == </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">) return cont(classfield)</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) return cont(typeexpr, maybeAssign)</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">=</span><span class="s3">\&quot;</span><span class="s1">) return cont(expressionNoComma)</span><span class="s3">\n    </span><span class="s1">var context = cx.state.lexical.prev, isInterface = context &amp;&amp; context.info == </span><span class="s3">\&quot;</span><span class="s1">interface</span><span class="s3">\&quot;\n    </span><span class="s1">return pass(isInterface ? functiondecl : functiondef)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function afterExport(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(maybeFrom, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)); }</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(expression, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)); }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return cont(commasep(exportField, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), maybeFrom, expect(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">return pass(statement);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function exportField(type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(expect(</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">)); }</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return pass(expressionNoComma, exportField);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function afterImport(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) return pass(expression);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) return pass(maybeoperatorComma);</span><span class="s3">\n    </span><span class="s1">return pass(importSpec, maybeMoreImports, maybeFrom);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function importSpec(type, value) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return contCommasep(importSpec, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) register(value);</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">) cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">return cont(maybeAs);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeMoreImports(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">) return cont(importSpec, maybeMoreImports)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeAs(_type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(importSpec); }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function maybeFrom(_type, value) {</span><span class="s3">\n    </span><span class="s1">if (value == </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">) { cx.marked = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">; return cont(expression); }</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function arrayLiteral(type) {</span><span class="s3">\n    </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">) return cont();</span><span class="s3">\n    </span><span class="s1">return pass(commasep(expressionNoComma, </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function enumdef() {</span><span class="s3">\n    </span><span class="s1">return pass(pushlex(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">), pattern, expect(</span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">), pushlex(</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), commasep(enummember, </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">), poplex, poplex)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function enummember() {</span><span class="s3">\n    </span><span class="s1">return pass(pattern, maybeAssign);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function isContinuedStatement(state, textAfter) {</span><span class="s3">\n    </span><span class="s1">return state.lastType == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">|| state.lastType == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">||</span><span class="s3">\n      </span><span class="s1">isOperatorChar.test(textAfter.charAt(0)) ||</span><span class="s3">\n      </span><span class="s1">/[,.]/.test(textAfter.charAt(0));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function expressionAllowed(stream, state, backUp) {</span><span class="s3">\n    </span><span class="s1">return state.tokenize == tokenBase &amp;&amp;</span><span class="s3">\n      </span><span class="s1">/^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[</span><span class="s3">\\</span><span class="s1">[{}</span><span class="s3">\\</span><span class="s1">(,;:]|=&gt;)$/.test(state.lastType) ||</span><span class="s3">\n      </span><span class="s1">(state.lastType == </span><span class="s3">\&quot;</span><span class="s1">quasi</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; /</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Interface</span><span class="s3">\n\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: parserConfig.name,</span><span class="s3">\n\n    </span><span class="s1">startState: function(indentUnit) {</span><span class="s3">\n      </span><span class="s1">var state = {</span><span class="s3">\n        </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n        </span><span class="s1">lastType: </span><span class="s3">\&quot;</span><span class="s1">sof</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">cc: [],</span><span class="s3">\n        </span><span class="s1">lexical: new JSLexical(-indentUnit, 0, </span><span class="s3">\&quot;</span><span class="s1">block</span><span class="s3">\&quot;</span><span class="s1">, false),</span><span class="s3">\n        </span><span class="s1">localVars: parserConfig.localVars,</span><span class="s3">\n        </span><span class="s1">context: parserConfig.localVars &amp;&amp; new Context(null, null, false),</span><span class="s3">\n        </span><span class="s1">indented: 0</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (parserConfig.globalVars &amp;&amp; typeof parserConfig.globalVars == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">state.globalVars = parserConfig.globalVars;</span><span class="s3">\n      </span><span class="s1">return state;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n        </span><span class="s1">if (!state.lexical.hasOwnProperty(</span><span class="s3">\&quot;</span><span class="s1">align</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n          </span><span class="s1">state.lexical.align = false;</span><span class="s3">\n        </span><span class="s1">state.indented = stream.indentation();</span><span class="s3">\n        </span><span class="s1">findFatArrow(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (state.tokenize != tokenComment &amp;&amp; stream.eatSpace()) return null;</span><span class="s3">\n      </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">) return style;</span><span class="s3">\n      </span><span class="s1">state.lastType = type == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (content == </span><span class="s3">\&quot;</span><span class="s1">++</span><span class="s3">\&quot; </span><span class="s1">|| content == </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot;</span><span class="s1">) ? </span><span class="s3">\&quot;</span><span class="s1">incdec</span><span class="s3">\&quot; </span><span class="s1">: type;</span><span class="s3">\n      </span><span class="s1">return parseJS(state, style, type, content, stream);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">indent: function(state, textAfter, cx) {</span><span class="s3">\n      </span><span class="s1">if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return null;</span><span class="s3">\n      </span><span class="s1">if (state.tokenize != tokenBase) return 0;</span><span class="s3">\n      </span><span class="s1">var firstChar = textAfter &amp;&amp; textAfter.charAt(0), lexical = state.lexical, top</span><span class="s3">\n      </span><span class="s1">// Kludge to prevent 'maybelse' from blocking lexical scope pops</span><span class="s3">\n      </span><span class="s1">if (!/^</span><span class="s3">\\</span><span class="s1">s*else</span><span class="s3">\\</span><span class="s1">b/.test(textAfter)) for (var i = state.cc.length - 1; i &gt;= 0; --i) {</span><span class="s3">\n        </span><span class="s1">var c = state.cc[i];</span><span class="s3">\n        </span><span class="s1">if (c == poplex) lexical = lexical.prev;</span><span class="s3">\n        </span><span class="s1">else if (c != maybeelse &amp;&amp; c != popcontext) break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">while ((lexical.type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot; </span><span class="s1">|| lexical.type == </span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp;</span><span class="s3">\n             </span><span class="s1">(firstChar == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot; </span><span class="s1">|| ((top = state.cc[state.cc.length - 1]) &amp;&amp;</span><span class="s3">\n                                   </span><span class="s1">(top == maybeoperatorComma || top == maybeoperatorNoComma) &amp;&amp;</span><span class="s3">\n                                   </span><span class="s1">!/^[,</span><span class="s3">\\</span><span class="s1">.=+</span><span class="s3">\\</span><span class="s1">-*:?[</span><span class="s3">\\</span><span class="s1">(]/.test(textAfter))))</span><span class="s3">\n        </span><span class="s1">lexical = lexical.prev;</span><span class="s3">\n      </span><span class="s1">if (statementIndent &amp;&amp; lexical.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; lexical.prev.type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">lexical = lexical.prev;</span><span class="s3">\n      </span><span class="s1">var type = lexical.type, closing = firstChar == type;</span><span class="s3">\n\n      </span><span class="s1">if (type == </span><span class="s3">\&quot;</span><span class="s1">vardef</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented + (state.lastType == </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot; </span><span class="s1">|| state.lastType == </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">? lexical.info.length + 1 : 0);</span><span class="s3">\n      </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented;</span><span class="s3">\n      </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">) return lexical.indented + cx.unit;</span><span class="s3">\n      </span><span class="s1">else if (type == </span><span class="s3">\&quot;</span><span class="s1">stat</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || cx.unit : 0);</span><span class="s3">\n      </span><span class="s1">else if (lexical.info == </span><span class="s3">\&quot;</span><span class="s1">switch</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !closing &amp;&amp; parserConfig.doubleIndentSwitch != false)</span><span class="s3">\n        </span><span class="s1">return lexical.indented + (/^(?:case|default)</span><span class="s3">\\</span><span class="s1">b/.test(textAfter) ? cx.unit : 2 * cx.unit);</span><span class="s3">\n      </span><span class="s1">else if (lexical.align) return lexical.column + (closing ? 0 : 1);</span><span class="s3">\n      </span><span class="s1">else return lexical.indented + (closing ? 0 : cx.unit);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">languageData: {</span><span class="s3">\n      </span><span class="s1">indentOnInput: /^</span><span class="s3">\\</span><span class="s1">s*(?:case .*?:|default:|</span><span class="s3">\\</span><span class="s1">{|</span><span class="s3">\\</span><span class="s1">})$/,</span><span class="s3">\n      </span><span class="s1">commentTokens: jsonMode ? undefined : {line: </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}},</span><span class="s3">\n      </span><span class="s1">closeBrackets: {brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">]},</span><span class="s3">\n      </span><span class="s1">wordChars: </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const javascript = mkJavaScript({name: </span><span class="s3">\&quot;</span><span class="s1">javascript</span><span class="s3">\&quot;</span><span class="s1">})</span><span class="s3">\n</span><span class="s1">export const json = mkJavaScript({name: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">, json: true})</span><span class="s3">\n</span><span class="s1">export const jsonld = mkJavaScript({name: </span><span class="s3">\&quot;</span><span class="s1">json</span><span class="s3">\&quot;</span><span class="s1">, jsonld: true})</span><span class="s3">\n</span><span class="s1">export const typescript = mkJavaScript({name: </span><span class="s3">\&quot;</span><span class="s1">typescript</span><span class="s3">\&quot;</span><span class="s1">, typescript: true})</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>