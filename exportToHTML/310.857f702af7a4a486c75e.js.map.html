<html>
<head>
<title>310.857f702af7a4a486c75e.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
310.857f702af7a4a486c75e.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;310.857f702af7a4a486c75e.js?v=857f702af7a4a486c75e&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;AAAA;AACA,IAAI,IAAyD;AAC7D,2BAA2B,mBAAO,CAAC,KAAa;AAChD,MAAM,EAK2C;AACjD,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,8BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB,uBAAuB;AACpD;AACA;AACA,UAAU,8BAAmB;AAC7B,eAAe,8BAAmB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,8BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,8BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,iBAAiB,8BAAmB,CAAC,8BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,wBAAwB,+BAAmB;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;;AAErD;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,aAAa,+BAAmB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,oBAAoB,+BAAmB;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;AACtC,YAAY,+BAAmB;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,eAAe,+BAAmB;AAClC,uBAAuB,+BAAmB;AAC1C,gBAAgB,+BAAmB;AACnC,eAAe,+BAAmB;AAClC,eAAe,+BAAmB;AAClC,oBAAoB,+BAAmB;AACvC,wBAAwB,+BAAmB;AAC3C,sBAAsB,+BAAmB;AACzC,YAAY,+BAAmB;AAC/B,aAAa,+BAAmB;AAChC,aAAa,+BAAmB;AAChC,cAAc,+BAAmB;AACjC,gBAAgB,+BAAmB;AACnC,aAAa,+BAAmB;AAChC,gBAAgB,+BAAmB;;AAEnC;AACA;;AAEA,uBAAuB;AACvB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,2BAA2B,2BAA2B;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;;AAE3B,uBAAuB;AACvB;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC,8BAA8B;AAC9B,oCAAoC;;AAEpC;;AAEA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,mEAAmE;;AAEnE,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mCAAmC;AACzD;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA,kBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,8BAA8B;AAChD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B;AAC7C;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA;;AAEA,sBAAsB,gCAAmB;AACzC,yBAAyB,gCAAmB;AAC5C,oBAAoB,gCAAmB;AACvC,qBAAqB,gCAAmB;AACxC,4BAA4B,gCAAmB;AAC/C,sBAAsB,gCAAmB;AACzC,oBAAoB,gCAAmB;;AAEvC;;AAEA,OAAO;AACP;AACA,CAAC;;;;;;;ACt6CD;AACA,IAAI,IAAyD;AAC7D,2BAA2B,mBAAO,CAAC,KAAW;AAC9C,MAAM,EAKqD;AAC3D,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,8BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB,uBAAuB;AACpD;AACA;AACA,UAAU,8BAAmB;AAC7B,eAAe,8BAAmB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,8BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,8BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,iBAAiB,8BAAmB,CAAC,8BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,sBAAsB,+BAAmB;AACzC,wBAAwB,+BAAmB;AAC3C,oBAAoB,+BAAmB;AACvC,iBAAiB,+BAAmB;AACpC,eAAe,+BAAmB;AAClC,aAAa,+BAAmB;AAChC,iBAAiB,+BAAmB;;AAEpC;AACA;AACA,4BAA4B;AAC5B;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8DAA8D,iEAAiE;;AAE/H;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,oBAAoB,mCAAmC;;AAEvD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B,mCAAmC;AAC7D;AACA;;AAEA;AACA;;AAEA,oBAAoB,8BAA8B;AAClD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA,wBAAwB,kCAAkC;;AAE1D;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wDAAwD;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH,sBAAsB;;AAEtB;AACA;AACA;AACA;AACA,gGAAgG;AAChG;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,0CAA0C;AAC1F,iDAAiD,0CAA0C;AAC3F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe;AACf;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,CAAC;;;;;;;ACzcD;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAK2B;AACjC,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,8BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB,uBAAuB;AACpD;AACA;AACA,UAAU,8BAAmB;AAC7B,eAAe,8BAAmB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,8BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,8BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,iBAAiB,8BAAmB,CAAC,8BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;AACtC,gBAAgB,+BAAmB;AACnC,YAAY,+BAAmB;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;AACtC,cAAc,+BAAmB;AACjC,iBAAiB,+BAAmB;AACpC,sBAAsB,+BAAmB;AACzC,iBAAiB,+BAAmB;AACpC,aAAa,+BAAmB;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qGAAqG;AACrG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mBAAmB,gCAAmB;AACtC,cAAc,gCAAmB;AACjC,sBAAsB,gCAAmB;AACzC,oBAAoB,gCAAmB;AACvC,YAAY,gCAAmB;AAC/B,YAAY,gCAAmB;AAC/B,iBAAiB,gCAAmB;AACpC,YAAY,gCAAmB;AAC/B,iBAAiB,gCAAmB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA;AACA,YAAY,gCAAmB;;AAE/B;AACA,WAAW,gCAAmB,KAAK;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,sBAAsB,gCAAmB;;AAEzC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,gCAAmB;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA,0BAA0B,KAAK;;AAE/B;AACA;AACA,0BAA0B,KAAK;;AAE/B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,oCAAoC;AACpC,IAAI;AACJ,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,qGAAqG,qBAAqB,mBAAmB;;AAE7I;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,oBAAoB,eAAe,OAAO;;AAExK,sBAAsB,gCAAmB;AACzC,oBAAoB,gCAAmB;AACvC,YAAY,gCAAmB;AAC/B,YAAY,gCAAmB;AAC/B,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,gBAAgB,gCAAmB;AACnC,cAAc,gCAAmB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,aAAa,gCAAmB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,oBAAoB,eAAe,OAAO;;AAExK,aAAa,gCAAmB;AAChC,wBAAwB,gCAAmB;AAC3C,sBAAsB,gCAAmB;AACzC,gBAAgB,gCAAmB;AACnC,YAAY,gCAAmB;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,mBAAmB;AACnC;;AAEA,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA,kBAAkB,WAAW;AAC7B,oBAAoB,WAAW;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,uBAAuB;AAC1D,qCAAqC,uBAAuB;AAC5D;AACA,0BAA0B,uBAAuB;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,YAAY,iCAAmB;AAC/B,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,YAAY,iCAAmB;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iCAAmB;;AAEpC;AACA;AACA;;AAEA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA,iFAAiF;AACjF;AACA,KAAK;AACL;AACA;AACA,iFAAiF;AACjF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,eAAe;AACvC;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB;AACzC;;AAEA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C,kCAAkC,iBAAiB;AACnD;AACA;AACA,mIAAmI;;AAEnI;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;;AAEA,yFAAyF;AACzF;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA;AACA;AACA;;AAEA,sBAAsB,iCAAmB;AACzC,+BAA+B,iCAAmB;AAClD,0BAA0B,iCAAmB;AAC7C,0BAA0B,iCAAmB;AAC7C,wBAAwB,iCAAmB;AAC3C,qBAAqB,iCAAmB;AACxC,qBAAqB,iCAAmB;AACxC,uBAAuB,iCAAmB;AAC1C,mBAAmB,iCAAmB;AACtC,qBAAqB,iCAAmB;AACxC,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,wBAAwB,iCAAmB;AAC3C,wBAAwB,iCAAmB;AAC3C,uBAAuB,iCAAmB;AAC1C,+BAA+B,iCAAmB;AAClD,uBAAuB,iCAAmB;AAC1C,wBAAwB,iCAAmB;AAC3C,0BAA0B,iCAAmB;AAC7C,oBAAoB,iCAAmB;AACvC,mBAAmB,iCAAmB;AACtC,2BAA2B,iCAAmB;AAC9C,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,6BAA6B,iCAAmB;AAChD,6BAA6B,iCAAmB;;AAEhD;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;AC3uI6B;AAGA;AAGA;AAQA;;AAE9B;AACA;AACA,0BAA0B,qEAAM;AAChC,sBAAsB,gBAAgB,KAAK;AAC3C;AACA,GAAG;AACH;AACA,2BAA2B,qEAAM;AACjC,KAAK;AACL,UAAU;AACV,gBAAgB,gVAAgV;AAChW,kBAAkB,6KAA6K;AAC/L;AACA,mCAAmC,qEAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL,cAAc,qCAAqC,IAAI,QAAQ,IAAI,WAAW,IAAI,oCAAoC,IAAI,uGAAuG,oBAAoB,WAAW,oCAAoC,gGAAgG,IAAI,4FAA4F,IAAI,iCAAiC,oBAAoB,oEAAoE,2HAA2H,aAAa,KAAK,aAAa,IAAI,iCAAiC,IAAI,gGAAgG,oBAAoB,iBAAiB,yGAAyG,aAAa,IAAI,aAAa,oBAAoB,iBAAiB,uCAAuC,aAAa;AACzoC,sBAAsB,sBAAsB;AAC5C,gCAAgC,qEAAM;AACtC;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,KAAK;AACL,2BAA2B,qEAAM;AACjC;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAM;AACZ,iEAAiE;AACjE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,gCAAgC,qEAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,qEAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,6BAA6B,qEAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4BAA4B,qEAAM;AAClC;AACA;AACA,OAAO;AACP;AACA,8BAA8B,qEAAM;AACpC;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;AACA,4BAA4B,qEAAM;AAClC;AACA,OAAO;AACP;AACA,iCAAiC,qEAAM;AACvC;AACA;AACA,OAAO;AACP;AACA,qCAAqC,qEAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,oCAAoC,qEAAM;AAC1C;AACA;AACA;AACA,OAAO;AACP;AACA,kCAAkC,qEAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,4BAA4B,qEAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,gBAAgB;AAChB;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,2BAA2B,qEAAM;AACjC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,6BAA6B,qEAAM;AACnC;AACA,OAAO;AACP;AACA,gCAAgC,qEAAM;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,qCAAqC,qEAAM;AAC3C;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP,4DAA4D;AAC5D,gCAAgC,qEAAM;AACtC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,iCAAiC,qEAAM;AACvC;AACA,OAAO;AACP;AACA,sCAAsC,qEAAM;AAC5C;AACA,OAAO;AACP,iBAAiB,0BAA0B;AAC3C,qCAAqC,qEAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,gPAAgP,EAAE,6DAA6D,EAAE,8JAA8J,EAAE,wEAAwE;AACzhB,oBAAoB,WAAW,qCAAqC,YAAY,qCAAqC,aAAa,uCAAuC,YAAY,uCAAuC,YAAY,+EAA+E,eAAe;AACtU;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,EAAE,qEAAM;AACR;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA;AACA,4BAA4B,qEAAM;AAClC;AACA;AACA;AACA,CAAC;AACD,gCAAgC,qEAAM;AACtC,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,iCAAiC,qEAAM;AACvC;AACA,CAAC;AACD,8BAA8B,qEAAM;AACpC,EAAE,8DAAG;AACL,eAAe,yEAAS;AACxB,yCAAyC,gFAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2EAAY;AACxB;AACA,WAAW,2EAAY;AACvB;AACA;AACA,yCAAyC,gFAAqB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,qEAAM;AACpC,EAAE,8DAAG;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,CAAC;AACD,sCAAsC,qEAAM;AAC5C;AACA,CAAC;AACD,mCAAmC,qEAAM;AACzC;AACA;AACA;AACA,iBAAiB,yEAAS;AAC1B;AACA;AACA,gBAAgB,2EAAY;AAC5B;AACA;AACA,iBAAiB,2EAAY;AAC7B;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gCAAgC,qEAAM,OAAO,8DAAG;AAChD,qCAAqC,qEAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACkC;AACe;AACrB;;AAE5B;AACA;AACA,iCAAiC,qEAAM;AACvC;AACA;AACA;AACA,UAAU,kBAAkB,GAAG,uBAAuB,cAAc,qBAAqB,YAAY,kBAAkB;AACvH;AACA;AACA,CAAC;AACD,8BAA8B,qEAAM;AACpC;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG,GAAG,IAAI,QAAQ,SAAS,GAAG;AAC3C,SAAS,GAAG,GAAG,IAAI,QAAQ,QAAQ,GAAG;AACtC,SAAS,GAAG,GAAG,IAAI,QAAQ,SAAS,GAAG;;AAEvC,SAAS,GAAG,GAAG,IAAI,QAAQ,SAAS,GAAG;AACvC,SAAS,GAAG,GAAG,IAAI,QAAQ,cAAc,GAAG;;AAE5C,SAAS,GAAG,GAAG,IAAI,QAAQ,cAAc,GAAG;AAC5C,SAAS,GAAG,GAAG,IAAI,QAAQ,aAAa,GAAG;AAC3C,SAAS,GAAG,GAAG,IAAI,QAAQ,cAAc,GAAG;;AAE5C,SAAS,GAAG,GAAG,IAAI,QAAQ,aAAa,GAAG;AAC3C,SAAS,GAAG,GAAG,IAAI,QAAQ,QAAQ,GAAG;;AAEtC;AACA;AACA,CAAC;AACD,8BAA8B,qEAAM;AACpC;AACA;AACA;AACA;AACA;AACA,aAAa,EAAE,GAAG,GAAG,QAAQ,SAAS,GAAG;AACzC,SAAS,EAAE,GAAG,GAAG,QAAQ,SAAS,GAAG;AACrC,SAAS,EAAE,GAAG,GAAG,QAAQ,SAAS,GAAG;AACrC,SAAS,EAAE,GAAG,GAAG,QAAQ,SAAS,GAAG;;AAErC,SAAS,EAAE,GAAG,GAAG,QAAQ,SAAS,GAAG;AACrC,SAAS,QAAQ,GAAG,SAAS,QAAQ,EAAE,GAAG;AAC1C,SAAS,EAAE,GAAG,GAAG,QAAQ,cAAc,GAAG;;AAE1C,SAAS,EAAE,GAAG,GAAG,QAAQ,cAAc,GAAG;AAC1C,SAAS,EAAE,GAAG,GAAG,QAAQ,cAAc,GAAG;AAC1C,SAAS,EAAE,GAAG,GAAG,QAAQ,cAAc,GAAG;AAC1C,SAAS,EAAE,GAAG,GAAG,QAAQ,cAAc,GAAG;;AAE1C,SAAS,EAAE,GAAG,GAAG,QAAQ,aAAa,GAAG;AACzC,SAAS,QAAQ,GAAG,SAAS,QAAQ,EAAE,GAAG;AAC1C,SAAS,EAAE,GAAG,GAAG,QAAQ,QAAQ,GAAG;;AAEpC;AACA;AACA,CAAC;AACD,gCAAgC,qEAAM;AACtC;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qEAAM;AACN,iCAAiC,qEAAM;AACvC;AACA;AACA;AACA;AACA;AACA,MAAM,YAAY;AAClB,MAAM,gBAAgB;AACtB,MAAM,iBAAiB;AACvB,MAAM,iBAAiB;AACvB,MAAM,aAAa;AACnB,MAAM;AACN;AACA;AACA,CAAC;AACD,qCAAqC,qEAAM;AAC3C;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4EAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,uIAAuI;AACvI;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,wIAAwI,oCAAoC;AAC5K;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mCAAmC,qEAAM;AACzC;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,0DAAS,KAAK,+DAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAG;AACT;AACA;AACA,aAAa,cAAc,GAAG,eAAe,IAAI,YAAY,GAAG,aAAa,GAAG,YAAY,GAAG,aAAa;AAC5G;AACA;AACA,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW,GAAG,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,qEAAM;AACN;AACA;AACA,qBAAqB,oDAAM;AAC3B,eAAe,8DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM,8DAAG;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAG;AACP;AACA;AACA,mBAAmB,mCAAmC,IAAI,oCAAoC;AAC9F;AACA,2BAA2B,GAAG;AAC9B,GAAG;AACH;AACA,qEAAM;AACN,2BAA2B,qEAAM;AACjC,EAAE,8DAAG;AACL;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAS;AACxB;AACA,cAAc,8EAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gFAAiB;AACnB;AACA;AACA,6BAA6B,gFAAqB;AAClD,iCAAiC,gFAAqB;AACtD;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACiD;AACjD,kCAAkC,qEAAM;AACxC;AACA,kBAAkB,+BAA+B;AACjD;AACA,QAAQ,2DAAM;AACd,iCAAiC,2DAAO;AACxC,MAAM;AACN,iCAAiC,2DAAM;AACvC;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;AACA,eAAe,OAAO,iBAAiB,OAAO,iBAAiB,OAAO,mBAAmB,OAAO,oBAAoB,OAAO;AAC3H,cAAc;AACd;AACA,eAAe,OAAO;AACtB,aAAa;AACb;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA,oBAAoB;AACpB,gBAAgB;AAChB;AACA,kBAAkB;AAClB,sBAAsB;AACtB;AACA,eAAe,OAAO;AACtB,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gCAAgC,qEAAM;AACtC;AACA;AACA;AACA,IAAI;AACJ;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGE&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cose-base/cose-base.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cytoscape-cose-bilkent/cytoscape-cose-bilkent.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/layout-base/layout-base.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/mindmap-definition-ALO5MXBD.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory(require(</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">] = factory(require(</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">] = factory(root[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">l: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.l = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// identity function for calling harmony imports with the correct context</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.i = function(value) { return value; };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 7);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n</span><span class="s1">module.exports = __WEBPACK_EXTERNAL_MODULE_0__;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 1 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;</span><span class="s3">\n\n</span><span class="s1">function CoSEConstants() {}</span><span class="s3">\n\n</span><span class="s1">//CoSEConstants inherits static props in FDLayoutConstants</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutConstants) {</span><span class="s3">\n  </span><span class="s1">CoSEConstants[prop] = FDLayoutConstants[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;</span><span class="s3">\n</span><span class="s1">CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n</span><span class="s1">CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILE = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILING_PADDING_VERTICAL = 10;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILING_PADDING_HORIZONTAL = 10;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false; // make this true when cose is used incrementally as a part of other non-incremental layout</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 2 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var FDLayoutEdge = __webpack_require__(0).FDLayoutEdge;</span><span class="s3">\n\n</span><span class="s1">function CoSEEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">FDLayoutEdge.call(this, source, target, vEdge);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutEdge) {</span><span class="s3">\n  </span><span class="s1">CoSEEdge[prop] = FDLayoutEdge[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 3 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraph = __webpack_require__(0).LGraph;</span><span class="s3">\n\n</span><span class="s1">function CoSEGraph(parent, graphMgr, vGraph) {</span><span class="s3">\n  </span><span class="s1">LGraph.call(this, parent, graphMgr, vGraph);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEGraph.prototype = Object.create(LGraph.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraph) {</span><span class="s3">\n  </span><span class="s1">CoSEGraph[prop] = LGraph[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEGraph;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 4 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphManager = __webpack_require__(0).LGraphManager;</span><span class="s3">\n\n</span><span class="s1">function CoSEGraphManager(layout) {</span><span class="s3">\n  </span><span class="s1">LGraphManager.call(this, layout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphManager) {</span><span class="s3">\n  </span><span class="s1">CoSEGraphManager[prop] = LGraphManager[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEGraphManager;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 5 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var FDLayoutNode = __webpack_require__(0).FDLayoutNode;</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(0).IMath;</span><span class="s3">\n\n</span><span class="s1">function CoSENode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">FDLayoutNode.call(this, gm, loc, size, vNode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype = Object.create(FDLayoutNode.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutNode) {</span><span class="s3">\n  </span><span class="s1">CoSENode[prop] = FDLayoutNode[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.move = function () {</span><span class="s3">\n  </span><span class="s1">var layout = this.graphManager.getLayout();</span><span class="s3">\n  </span><span class="s1">this.displacementX = layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;</span><span class="s3">\n  </span><span class="s1">this.displacementY = layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.displacementX) &gt; layout.coolingFactor * layout.maxNodeDisplacement) {</span><span class="s3">\n    </span><span class="s1">this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.displacementY) &gt; layout.coolingFactor * layout.maxNodeDisplacement) {</span><span class="s3">\n    </span><span class="s1">this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// a simple node, just move it</span><span class="s3">\n  </span><span class="s1">if (this.child == null) {</span><span class="s3">\n    </span><span class="s1">this.moveBy(this.displacementX, this.displacementY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// an empty compound node, again just move it</span><span class="s3">\n  </span><span class="s1">else if (this.child.getNodes().length == 0) {</span><span class="s3">\n      </span><span class="s1">this.moveBy(this.displacementX, this.displacementY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// non-empty compound node, propogate movement to children as well</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">this.propogateDisplacementToChildren(this.displacementX, this.displacementY);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);</span><span class="s3">\n\n  </span><span class="s1">this.springForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.springForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementX = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementY = 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {</span><span class="s3">\n  </span><span class="s1">var nodes = this.getChild().getNodes();</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = nodes[i];</span><span class="s3">\n    </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">node.moveBy(dX, dY);</span><span class="s3">\n      </span><span class="s1">node.displacementX += dX;</span><span class="s3">\n      </span><span class="s1">node.displacementY += dY;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">node.propogateDisplacementToChildren(dX, dY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setPred1 = function (pred1) {</span><span class="s3">\n  </span><span class="s1">this.pred1 = pred1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getPred1 = function () {</span><span class="s3">\n  </span><span class="s1">return pred1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getPred2 = function () {</span><span class="s3">\n  </span><span class="s1">return pred2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setNext = function (next) {</span><span class="s3">\n  </span><span class="s1">this.next = next;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getNext = function () {</span><span class="s3">\n  </span><span class="s1">return next;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setProcessed = function (processed) {</span><span class="s3">\n  </span><span class="s1">this.processed = processed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.isProcessed = function () {</span><span class="s3">\n  </span><span class="s1">return processed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSENode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 6 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var FDLayout = __webpack_require__(0).FDLayout;</span><span class="s3">\n</span><span class="s1">var CoSEGraphManager = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">var CoSEGraph = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var CoSENode = __webpack_require__(5);</span><span class="s3">\n</span><span class="s1">var CoSEEdge = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var CoSEConstants = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(0).FDLayoutConstants;</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0).LayoutConstants;</span><span class="s3">\n</span><span class="s1">var Point = __webpack_require__(0).Point;</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(0).PointD;</span><span class="s3">\n</span><span class="s1">var Layout = __webpack_require__(0).Layout;</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(0).Integer;</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(0).IGeometry;</span><span class="s3">\n</span><span class="s1">var LGraph = __webpack_require__(0).LGraph;</span><span class="s3">\n</span><span class="s1">var Transform = __webpack_require__(0).Transform;</span><span class="s3">\n\n</span><span class="s1">function CoSELayout() {</span><span class="s3">\n  </span><span class="s1">FDLayout.call(this);</span><span class="s3">\n\n  </span><span class="s1">this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype = Object.create(FDLayout.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in FDLayout) {</span><span class="s3">\n  </span><span class="s1">CoSELayout[prop] = FDLayout[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">var gm = new CoSEGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n  </span><span class="s1">return gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newGraph = function (vGraph) {</span><span class="s3">\n  </span><span class="s1">return new CoSEGraph(null, this.graphManager, vGraph);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newNode = function (vNode) {</span><span class="s3">\n  </span><span class="s1">return new CoSENode(this.graphManager, vNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newEdge = function (vEdge) {</span><span class="s3">\n  </span><span class="s1">return new CoSEEdge(null, null, vEdge);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">FDLayout.prototype.initParameters.call(this, arguments);</span><span class="s3">\n  </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.DEFAULT_EDGE_LENGTH &lt; 10) {</span><span class="s3">\n      </span><span class="s1">this.idealEdgeLength = 10;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;</span><span class="s3">\n    </span><span class="s1">this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n    </span><span class="s1">this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n\n    </span><span class="s1">// variables for tree reduction support</span><span class="s3">\n    </span><span class="s1">this.prunedNodesAll = [];</span><span class="s3">\n    </span><span class="s1">this.growTreeIterations = 0;</span><span class="s3">\n    </span><span class="s1">this.afterGrowthIterations = 0;</span><span class="s3">\n    </span><span class="s1">this.isTreeGrowing = false;</span><span class="s3">\n    </span><span class="s1">this.isGrowthFinished = false;</span><span class="s3">\n\n    </span><span class="s1">// variables for cooling</span><span class="s3">\n    </span><span class="s1">this.coolingCycle = 0;</span><span class="s3">\n    </span><span class="s1">this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;</span><span class="s3">\n    </span><span class="s1">this.finalTemperature = FDLayoutConstants.CONVERGENCE_CHECK_PERIOD / this.maxIterations;</span><span class="s3">\n    </span><span class="s1">this.coolingAdjuster = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.layout = function () {</span><span class="s3">\n  </span><span class="s1">var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n  </span><span class="s1">if (createBendsAsNeeded) {</span><span class="s3">\n    </span><span class="s1">this.createBendpoints();</span><span class="s3">\n    </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.level = 0;</span><span class="s3">\n  </span><span class="s1">return this.classicLayout();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.classicLayout = function () {</span><span class="s3">\n  </span><span class="s1">this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();</span><span class="s3">\n  </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);</span><span class="s3">\n  </span><span class="s1">this.calcNoOfChildrenForAllNodes();</span><span class="s3">\n  </span><span class="s1">this.graphManager.calcLowestCommonAncestors();</span><span class="s3">\n  </span><span class="s1">this.graphManager.calcInclusionTreeDepths();</span><span class="s3">\n  </span><span class="s1">this.graphManager.getRoot().calcEstimatedSize();</span><span class="s3">\n  </span><span class="s1">this.calcIdealEdgeLengths();</span><span class="s3">\n\n  </span><span class="s1">if (!this.incremental) {</span><span class="s3">\n    </span><span class="s1">var forest = this.getFlatForest();</span><span class="s3">\n\n    </span><span class="s1">// The graph associated with this layout is flat and a forest</span><span class="s3">\n    </span><span class="s1">if (forest.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.positionNodesRadially(forest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// The graph associated with this layout is not flat or a forest</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// Reduce the trees when incremental mode is not enabled and graph is not a forest </span><span class="s3">\n        </span><span class="s1">this.reduceTrees();</span><span class="s3">\n        </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n        </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n        </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n        </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n          </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n\n        </span><span class="s1">this.positionNodesRandomly();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {</span><span class="s3">\n      </span><span class="s1">// Reduce the trees in incremental mode if only this constant is set to true </span><span class="s3">\n      </span><span class="s1">this.reduceTrees();</span><span class="s3">\n      </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n      </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n      </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n        </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.initSpringEmbedder();</span><span class="s3">\n  </span><span class="s1">this.runSpringEmbedder();</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tick = function () {</span><span class="s3">\n  </span><span class="s1">this.totalIterations++;</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations === this.maxIterations &amp;&amp; !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.isTreeGrowing = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 &amp;&amp; !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.isConverged()) {</span><span class="s3">\n      </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">this.isTreeGrowing = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.coolingCycle++;</span><span class="s3">\n\n    </span><span class="s1">if (this.layoutQuality == 0) {</span><span class="s3">\n      </span><span class="s1">// quality - </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;\n      </span><span class="s1">this.coolingAdjuster = this.coolingCycle;</span><span class="s3">\n    </span><span class="s1">} else if (this.layoutQuality == 1) {</span><span class="s3">\n      </span><span class="s1">// quality - </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;\n      </span><span class="s1">this.coolingAdjuster = this.coolingCycle / 3;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// cooling schedule is based on http://www.btluke.com/simanf1.html -&gt; cooling schedule 3</span><span class="s3">\n    </span><span class="s1">this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);</span><span class="s3">\n    </span><span class="s1">this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Operations while tree is growing again </span><span class="s3">\n  </span><span class="s1">if (this.isTreeGrowing) {</span><span class="s3">\n    </span><span class="s1">if (this.growTreeIterations % 10 == 0) {</span><span class="s3">\n      </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n        </span><span class="s1">this.updateGrid();</span><span class="s3">\n        </span><span class="s1">this.growTree(this.prunedNodesAll);</span><span class="s3">\n        </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n        </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n        </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n        </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n          </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n\n        </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n        </span><span class="s1">this.updateGrid();</span><span class="s3">\n        </span><span class="s1">this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.isTreeGrowing = false;</span><span class="s3">\n        </span><span class="s1">this.isGrowthFinished = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.growTreeIterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Operations after growth is finished</span><span class="s3">\n  </span><span class="s1">if (this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.isConverged()) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.afterGrowthIterations % 10 == 0) {</span><span class="s3">\n      </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n      </span><span class="s1">this.updateGrid();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);</span><span class="s3">\n    </span><span class="s1">this.afterGrowthIterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var gridUpdateAllowed = !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished;</span><span class="s3">\n  </span><span class="s1">var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 &amp;&amp; this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 &amp;&amp; this.isGrowthFinished;</span><span class="s3">\n\n  </span><span class="s1">this.totalDisplacement = 0;</span><span class="s3">\n  </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n  </span><span class="s1">this.calcSpringForces();</span><span class="s3">\n  </span><span class="s1">this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);</span><span class="s3">\n  </span><span class="s1">this.calcGravitationalForces();</span><span class="s3">\n  </span><span class="s1">this.moveNodes();</span><span class="s3">\n  </span><span class="s1">this.animate();</span><span class="s3">\n\n  </span><span class="s1">return false; // Layout is not ended yet return false</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.getPositionsData = function () {</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var pData = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var rect = allNodes[i].rect;</span><span class="s3">\n    </span><span class="s1">var id = allNodes[i].id;</span><span class="s3">\n    </span><span class="s1">pData[id] = {</span><span class="s3">\n      </span><span class="s1">id: id,</span><span class="s3">\n      </span><span class="s1">x: rect.getCenterX(),</span><span class="s3">\n      </span><span class="s1">y: rect.getCenterY(),</span><span class="s3">\n      </span><span class="s1">w: rect.width,</span><span class="s3">\n      </span><span class="s1">h: rect.height</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pData;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.runSpringEmbedder = function () {</span><span class="s3">\n  </span><span class="s1">this.initialAnimationPeriod = 25;</span><span class="s3">\n  </span><span class="s1">this.animationPeriod = this.initialAnimationPeriod;</span><span class="s3">\n  </span><span class="s1">var layoutEnded = false;</span><span class="s3">\n\n  </span><span class="s1">// If aminate option is 'during' signal that layout is supposed to start iterating</span><span class="s3">\n  </span><span class="s1">if (FDLayoutConstants.ANIMATE === 'during') {</span><span class="s3">\n    </span><span class="s1">this.emit('layoutstarted');</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// If aminate option is 'during' tick() function will be called on index.js</span><span class="s3">\n    </span><span class="s1">while (!layoutEnded) {</span><span class="s3">\n      </span><span class="s1">layoutEnded = this.tick();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {</span><span class="s3">\n  </span><span class="s1">var nodeList = [];</span><span class="s3">\n  </span><span class="s1">var graph;</span><span class="s3">\n\n  </span><span class="s1">var graphs = this.graphManager.getGraphs();</span><span class="s3">\n  </span><span class="s1">var size = graphs.length;</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; size; i++) {</span><span class="s3">\n    </span><span class="s1">graph = graphs[i];</span><span class="s3">\n\n    </span><span class="s1">graph.updateConnected();</span><span class="s3">\n\n    </span><span class="s1">if (!graph.isConnected) {</span><span class="s3">\n      </span><span class="s1">nodeList = nodeList.concat(graph.getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nodeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.createBendpoints = function () {</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">edges = edges.concat(this.graphManager.getAllEdges());</span><span class="s3">\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n\n    </span><span class="s1">if (!visited.has(edge)) {</span><span class="s3">\n      </span><span class="s1">var source = edge.getSource();</span><span class="s3">\n      </span><span class="s1">var target = edge.getTarget();</span><span class="s3">\n\n      </span><span class="s1">if (source == target) {</span><span class="s3">\n        </span><span class="s1">edge.getBendpoints().push(new PointD());</span><span class="s3">\n        </span><span class="s1">edge.getBendpoints().push(new PointD());</span><span class="s3">\n        </span><span class="s1">this.createDummyNodesForBendpoints(edge);</span><span class="s3">\n        </span><span class="s1">visited.add(edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var edgeList = [];</span><span class="s3">\n\n        </span><span class="s1">edgeList = edgeList.concat(source.getEdgeListToNode(target));</span><span class="s3">\n        </span><span class="s1">edgeList = edgeList.concat(target.getEdgeListToNode(source));</span><span class="s3">\n\n        </span><span class="s1">if (!visited.has(edgeList[0])) {</span><span class="s3">\n          </span><span class="s1">if (edgeList.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">var k;</span><span class="s3">\n            </span><span class="s1">for (k = 0; k &lt; edgeList.length; k++) {</span><span class="s3">\n              </span><span class="s1">var multiEdge = edgeList[k];</span><span class="s3">\n              </span><span class="s1">multiEdge.getBendpoints().push(new PointD());</span><span class="s3">\n              </span><span class="s1">this.createDummyNodesForBendpoints(multiEdge);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">edgeList.forEach(function (edge) {</span><span class="s3">\n            </span><span class="s1">visited.add(edge);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (visited.size == edges.length) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.positionNodesRadially = function (forest) {</span><span class="s3">\n  </span><span class="s1">// We tile the trees to a grid row by row; first tree starts at (0,0)</span><span class="s3">\n  </span><span class="s1">var currentStartingPoint = new Point(0, 0);</span><span class="s3">\n  </span><span class="s1">var numberOfColumns = Math.ceil(Math.sqrt(forest.length));</span><span class="s3">\n  </span><span class="s1">var height = 0;</span><span class="s3">\n  </span><span class="s1">var currentY = 0;</span><span class="s3">\n  </span><span class="s1">var currentX = 0;</span><span class="s3">\n  </span><span class="s1">var point = new PointD(0, 0);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; forest.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (i % numberOfColumns == 0) {</span><span class="s3">\n      </span><span class="s1">// Start of a new row, make the x coordinate 0, increment the</span><span class="s3">\n      </span><span class="s1">// y coordinate with the max height of the previous row</span><span class="s3">\n      </span><span class="s1">currentX = 0;</span><span class="s3">\n      </span><span class="s1">currentY = height;</span><span class="s3">\n\n      </span><span class="s1">if (i != 0) {</span><span class="s3">\n        </span><span class="s1">currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">height = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var tree = forest[i];</span><span class="s3">\n\n    </span><span class="s1">// Find the center of the tree</span><span class="s3">\n    </span><span class="s1">var centerNode = Layout.findCenterOfTree(tree);</span><span class="s3">\n\n    </span><span class="s1">// Set the staring point of the next tree</span><span class="s3">\n    </span><span class="s1">currentStartingPoint.x = currentX;</span><span class="s3">\n    </span><span class="s1">currentStartingPoint.y = currentY;</span><span class="s3">\n\n    </span><span class="s1">// Do a radial layout starting with the center</span><span class="s3">\n    </span><span class="s1">point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);</span><span class="s3">\n\n    </span><span class="s1">if (point.y &gt; height) {</span><span class="s3">\n      </span><span class="s1">height = Math.floor(point.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {</span><span class="s3">\n  </span><span class="s1">var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);</span><span class="s3">\n  </span><span class="s1">CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);</span><span class="s3">\n  </span><span class="s1">var bounds = LGraph.calculateBounds(tree);</span><span class="s3">\n\n  </span><span class="s1">var transform = new Transform();</span><span class="s3">\n  </span><span class="s1">transform.setDeviceOrgX(bounds.getMinX());</span><span class="s3">\n  </span><span class="s1">transform.setDeviceOrgY(bounds.getMinY());</span><span class="s3">\n  </span><span class="s1">transform.setWorldOrgX(startingPoint.x);</span><span class="s3">\n  </span><span class="s1">transform.setWorldOrgY(startingPoint.y);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = tree[i];</span><span class="s3">\n    </span><span class="s1">node.transform(transform);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());</span><span class="s3">\n\n  </span><span class="s1">return transform.inverseTransformPoint(bottomRight);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {</span><span class="s3">\n  </span><span class="s1">// First, position this node by finding its angle.</span><span class="s3">\n  </span><span class="s1">var halfInterval = (endAngle - startAngle + 1) / 2;</span><span class="s3">\n\n  </span><span class="s1">if (halfInterval &lt; 0) {</span><span class="s3">\n    </span><span class="s1">halfInterval += 180;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var nodeAngle = (halfInterval + startAngle) % 360;</span><span class="s3">\n  </span><span class="s1">var teta = nodeAngle * IGeometry.TWO_PI / 360;</span><span class="s3">\n\n  </span><span class="s1">// Make polar to java cordinate conversion.</span><span class="s3">\n  </span><span class="s1">var cos_teta = Math.cos(teta);</span><span class="s3">\n  </span><span class="s1">var x_ = distance * Math.cos(teta);</span><span class="s3">\n  </span><span class="s1">var y_ = distance * Math.sin(teta);</span><span class="s3">\n\n  </span><span class="s1">node.setCenter(x_, y_);</span><span class="s3">\n\n  </span><span class="s1">// Traverse all neighbors of this node and recursively call this</span><span class="s3">\n  </span><span class="s1">// function.</span><span class="s3">\n  </span><span class="s1">var neighborEdges = [];</span><span class="s3">\n  </span><span class="s1">neighborEdges = neighborEdges.concat(node.getEdges());</span><span class="s3">\n  </span><span class="s1">var childCount = neighborEdges.length;</span><span class="s3">\n\n  </span><span class="s1">if (parentOfNode != null) {</span><span class="s3">\n    </span><span class="s1">childCount--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var branchCount = 0;</span><span class="s3">\n\n  </span><span class="s1">var incEdgesCount = neighborEdges.length;</span><span class="s3">\n  </span><span class="s1">var startIndex;</span><span class="s3">\n\n  </span><span class="s1">var edges = node.getEdgesBetween(parentOfNode);</span><span class="s3">\n\n  </span><span class="s1">// If there are multiple edges, prune them until there remains only one</span><span class="s3">\n  </span><span class="s1">// edge.</span><span class="s3">\n  </span><span class="s1">while (edges.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">//neighborEdges.remove(edges.remove(0));</span><span class="s3">\n    </span><span class="s1">var temp = edges[0];</span><span class="s3">\n    </span><span class="s1">edges.splice(0, 1);</span><span class="s3">\n    </span><span class="s1">var index = neighborEdges.indexOf(temp);</span><span class="s3">\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">neighborEdges.splice(index, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">incEdgesCount--;</span><span class="s3">\n    </span><span class="s1">childCount--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (parentOfNode != null) {</span><span class="s3">\n    </span><span class="s1">//assert edges.length == 1;</span><span class="s3">\n    </span><span class="s1">startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">startIndex = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var stepAngle = Math.abs(endAngle - startAngle) / childCount;</span><span class="s3">\n\n  </span><span class="s1">for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {</span><span class="s3">\n    </span><span class="s1">var currentNeighbor = neighborEdges[i].getOtherEnd(node);</span><span class="s3">\n\n    </span><span class="s1">// Don't back traverse to root node in current tree.</span><span class="s3">\n    </span><span class="s1">if (currentNeighbor == parentOfNode) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var childStartAngle = (startAngle + branchCount * stepAngle) % 360;</span><span class="s3">\n    </span><span class="s1">var childEndAngle = (childStartAngle + stepAngle) % 360;</span><span class="s3">\n\n    </span><span class="s1">CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);</span><span class="s3">\n\n    </span><span class="s1">branchCount++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.maxDiagonalInTree = function (tree) {</span><span class="s3">\n  </span><span class="s1">var maxDiagonal = Integer.MIN_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = tree[i];</span><span class="s3">\n    </span><span class="s1">var diagonal = node.getDiagonal();</span><span class="s3">\n\n    </span><span class="s1">if (diagonal &gt; maxDiagonal) {</span><span class="s3">\n      </span><span class="s1">maxDiagonal = diagonal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return maxDiagonal;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.calcRepulsionRange = function () {</span><span class="s3">\n  </span><span class="s1">// formula is 2 x (level + 1) x idealEdgeLength</span><span class="s3">\n  </span><span class="s1">return 2 * (this.level + 1) * this.idealEdgeLength;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Tiling methods</span><span class="s3">\n\n</span><span class="s1">// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.groupZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">// array of [parent_id x oneDegreeNode_id]</span><span class="s3">\n  </span><span class="s1">var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members</span><span class="s3">\n  </span><span class="s1">this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled</span><span class="s3">\n  </span><span class="s1">this.idToDummyNode = {}; // A map of id to dummy node </span><span class="s3">\n\n  </span><span class="s1">var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">// Fill zero degree list</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">var parent = node.getParent();</span><span class="s3">\n    </span><span class="s1">// If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list</span><span class="s3">\n    </span><span class="s1">if (this.getNodeDegreeWithChildren(node) === 0 &amp;&amp; (parent.id == undefined || !this.getToBeTiled(parent))) {</span><span class="s3">\n      </span><span class="s1">zeroDegree.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a map of parent node and its zero degree members</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; zeroDegree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = zeroDegree[i]; // Zero degree node itself</span><span class="s3">\n    </span><span class="s1">var p_id = node.getParent().id; // Parent id</span><span class="s3">\n\n    </span><span class="s1">if (typeof tempMemberGroups[p_id] === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) tempMemberGroups[p_id] = [];</span><span class="s3">\n\n    </span><span class="s1">tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If there are at least two nodes at a level, create a dummy compound for them</span><span class="s3">\n  </span><span class="s1">Object.keys(tempMemberGroups).forEach(function (p_id) {</span><span class="s3">\n    </span><span class="s1">if (tempMemberGroups[p_id].length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">var dummyCompoundId = </span><span class="s3">\&quot;</span><span class="s1">DummyCompound_</span><span class="s3">\&quot; </span><span class="s1">+ p_id; // The id of dummy compound which will be created soon</span><span class="s3">\n      </span><span class="s1">self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups</span><span class="s3">\n\n      </span><span class="s1">var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound</span><span class="s3">\n\n      </span><span class="s1">// Create a dummy compound with calculated id</span><span class="s3">\n      </span><span class="s1">var dummyCompound = new CoSENode(self.graphManager);</span><span class="s3">\n      </span><span class="s1">dummyCompound.id = dummyCompoundId;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingLeft = parent.paddingLeft || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingRight = parent.paddingRight || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingBottom = parent.paddingBottom || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingTop = parent.paddingTop || 0;</span><span class="s3">\n\n      </span><span class="s1">self.idToDummyNode[dummyCompoundId] = dummyCompound;</span><span class="s3">\n\n      </span><span class="s1">var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);</span><span class="s3">\n      </span><span class="s1">var parentGraph = parent.getChild();</span><span class="s3">\n\n      </span><span class="s1">// Add dummy compound to parent the graph</span><span class="s3">\n      </span><span class="s1">parentGraph.add(dummyCompound);</span><span class="s3">\n\n      </span><span class="s1">// For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; tempMemberGroups[p_id].length; i++) {</span><span class="s3">\n        </span><span class="s1">var node = tempMemberGroups[p_id][i];</span><span class="s3">\n\n        </span><span class="s1">parentGraph.remove(node);</span><span class="s3">\n        </span><span class="s1">dummyParentGraph.add(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.clearCompounds = function () {</span><span class="s3">\n  </span><span class="s1">var childGraphMap = {};</span><span class="s3">\n  </span><span class="s1">var idToNode = {};</span><span class="s3">\n\n  </span><span class="s1">// Get compound ordering by finding the inner one first</span><span class="s3">\n  </span><span class="s1">this.performDFSOnCompounds();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; this.compoundOrder.length; i++) {</span><span class="s3">\n\n    </span><span class="s1">idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];</span><span class="s3">\n    </span><span class="s1">childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());</span><span class="s3">\n\n    </span><span class="s1">// Remove children of compounds</span><span class="s3">\n    </span><span class="s1">this.graphManager.remove(this.compoundOrder[i].getChild());</span><span class="s3">\n    </span><span class="s1">this.compoundOrder[i].child = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n\n  </span><span class="s1">// Tile the removed children</span><span class="s3">\n  </span><span class="s1">this.tileCompoundMembers(childGraphMap, idToNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.clearZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var tiledZeroDegreePack = this.tiledZeroDegreePack = [];</span><span class="s3">\n\n  </span><span class="s1">Object.keys(this.memberGroups).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">var compoundNode = self.idToDummyNode[id]; // Get the dummy compound</span><span class="s3">\n\n    </span><span class="s1">tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);</span><span class="s3">\n\n    </span><span class="s1">// Set the width and height of the dummy compound as calculated</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.width = tiledZeroDegreePack[id].width;</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.height = tiledZeroDegreePack[id].height;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.repopulateCompounds = function () {</span><span class="s3">\n  </span><span class="s1">for (var i = this.compoundOrder.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var lCompoundNode = this.compoundOrder[i];</span><span class="s3">\n    </span><span class="s1">var id = lCompoundNode.id;</span><span class="s3">\n    </span><span class="s1">var horizontalMargin = lCompoundNode.paddingLeft;</span><span class="s3">\n    </span><span class="s1">var verticalMargin = lCompoundNode.paddingTop;</span><span class="s3">\n\n    </span><span class="s1">this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.repopulateZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var tiledPack = this.tiledZeroDegreePack;</span><span class="s3">\n\n  </span><span class="s1">Object.keys(tiledPack).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id</span><span class="s3">\n    </span><span class="s1">var horizontalMargin = compoundNode.paddingLeft;</span><span class="s3">\n    </span><span class="s1">var verticalMargin = compoundNode.paddingTop;</span><span class="s3">\n\n    </span><span class="s1">// Adjust the positions of nodes wrt its compound</span><span class="s3">\n    </span><span class="s1">self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.getToBeTiled = function (node) {</span><span class="s3">\n  </span><span class="s1">var id = node.id;</span><span class="s3">\n  </span><span class="s1">//firstly check the previous results</span><span class="s3">\n  </span><span class="s1">if (this.toBeTiled[id] != null) {</span><span class="s3">\n    </span><span class="s1">return this.toBeTiled[id];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//only compound nodes are to be tiled</span><span class="s3">\n  </span><span class="s1">var childGraph = node.getChild();</span><span class="s3">\n  </span><span class="s1">if (childGraph == null) {</span><span class="s3">\n    </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var children = childGraph.getNodes(); // Get the children nodes</span><span class="s3">\n\n  </span><span class="s1">//a compound node is not to be tiled if all of its compound children are not to be tiled</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var theChild = children[i];</span><span class="s3">\n\n    </span><span class="s1">if (this.getNodeDegree(theChild) &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">//pass the children not having the compound structure</span><span class="s3">\n    </span><span class="s1">if (theChild.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[theChild.id] = false;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.getToBeTiled(theChild)) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.toBeTiled[id] = true;</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Get degree of a node depending of its edges and independent of its children</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getNodeDegree = function (node) {</span><span class="s3">\n  </span><span class="s1">var id = node.id;</span><span class="s3">\n  </span><span class="s1">var edges = node.getEdges();</span><span class="s3">\n  </span><span class="s1">var degree = 0;</span><span class="s3">\n\n  </span><span class="s1">// For the edges connected</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n    </span><span class="s1">if (edge.getSource().id !== edge.getTarget().id) {</span><span class="s3">\n      </span><span class="s1">degree = degree + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return degree;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Get degree of a node with its children</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {</span><span class="s3">\n  </span><span class="s1">var degree = this.getNodeDegree(node);</span><span class="s3">\n  </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">return degree;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var children = node.getChild().getNodes();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var child = children[i];</span><span class="s3">\n    </span><span class="s1">degree += this.getNodeDegreeWithChildren(child);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return degree;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.performDFSOnCompounds = function () {</span><span class="s3">\n  </span><span class="s1">this.compoundOrder = [];</span><span class="s3">\n  </span><span class="s1">this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.fillCompexOrderByDFS = function (children) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var child = children[i];</span><span class="s3">\n    </span><span class="s1">if (child.getChild() != null) {</span><span class="s3">\n      </span><span class="s1">this.fillCompexOrderByDFS(child.getChild().getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.getToBeTiled(child)) {</span><span class="s3">\n      </span><span class="s1">this.compoundOrder.push(child);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* This method places each zero degree member wrt given (x,y) coordinates (top left).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin) {</span><span class="s3">\n  </span><span class="s1">x += compoundHorizontalMargin;</span><span class="s3">\n  </span><span class="s1">y += compoundVerticalMargin;</span><span class="s3">\n\n  </span><span class="s1">var left = x;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n    </span><span class="s1">var row = organization.rows[i];</span><span class="s3">\n    </span><span class="s1">x = left;</span><span class="s3">\n    </span><span class="s1">var maxHeight = 0;</span><span class="s3">\n\n    </span><span class="s1">for (var j = 0; j &lt; row.length; j++) {</span><span class="s3">\n      </span><span class="s1">var lnode = row[j];</span><span class="s3">\n\n      </span><span class="s1">lnode.rect.x = x; // + lnode.rect.width / 2;</span><span class="s3">\n      </span><span class="s1">lnode.rect.y = y; // + lnode.rect.height / 2;</span><span class="s3">\n\n      </span><span class="s1">x += lnode.rect.width + organization.horizontalPadding;</span><span class="s3">\n\n      </span><span class="s1">if (lnode.rect.height &gt; maxHeight) maxHeight = lnode.rect.height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">y += maxHeight + organization.verticalPadding;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">this.tiledMemberPack = [];</span><span class="s3">\n\n  </span><span class="s1">Object.keys(childGraphMap).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">// Get the compound node</span><span class="s3">\n    </span><span class="s1">var compoundNode = idToNode[id];</span><span class="s3">\n\n    </span><span class="s1">self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);</span><span class="s3">\n\n    </span><span class="s1">compoundNode.rect.width = self.tiledMemberPack[id].width;</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.height = self.tiledMemberPack[id].height;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tileNodes = function (nodes, minWidth) {</span><span class="s3">\n  </span><span class="s1">var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;</span><span class="s3">\n  </span><span class="s1">var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;</span><span class="s3">\n  </span><span class="s1">var organization = {</span><span class="s3">\n    </span><span class="s1">rows: [],</span><span class="s3">\n    </span><span class="s1">rowWidth: [],</span><span class="s3">\n    </span><span class="s1">rowHeight: [],</span><span class="s3">\n    </span><span class="s1">width: 0,</span><span class="s3">\n    </span><span class="s1">height: minWidth, // assume minHeight equals to minWidth</span><span class="s3">\n    </span><span class="s1">verticalPadding: verticalPadding,</span><span class="s3">\n    </span><span class="s1">horizontalPadding: horizontalPadding</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// Sort the nodes in ascending order of their areas</span><span class="s3">\n  </span><span class="s1">nodes.sort(function (n1, n2) {</span><span class="s3">\n    </span><span class="s1">if (n1.rect.width * n1.rect.height &gt; n2.rect.width * n2.rect.height) return -1;</span><span class="s3">\n    </span><span class="s1">if (n1.rect.width * n1.rect.height &lt; n2.rect.width * n2.rect.height) return 1;</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Create the organization -&gt; tile members</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">if (organization.rows.length == 0) {</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, 0, minWidth);</span><span class="s3">\n    </span><span class="s1">} else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, this.getShortestRowIndex(organization), minWidth);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.shiftToLastRow(organization);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return organization;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {</span><span class="s3">\n  </span><span class="s1">var minCompoundSize = minWidth;</span><span class="s3">\n\n  </span><span class="s1">// Add new row if needed</span><span class="s3">\n  </span><span class="s1">if (rowIndex == organization.rows.length) {</span><span class="s3">\n    </span><span class="s1">var secondDimension = [];</span><span class="s3">\n\n    </span><span class="s1">organization.rows.push(secondDimension);</span><span class="s3">\n    </span><span class="s1">organization.rowWidth.push(minCompoundSize);</span><span class="s3">\n    </span><span class="s1">organization.rowHeight.push(0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update row width</span><span class="s3">\n  </span><span class="s1">var w = organization.rowWidth[rowIndex] + node.rect.width;</span><span class="s3">\n\n  </span><span class="s1">if (organization.rows[rowIndex].length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">w += organization.horizontalPadding;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">organization.rowWidth[rowIndex] = w;</span><span class="s3">\n  </span><span class="s1">// Update compound width</span><span class="s3">\n  </span><span class="s1">if (organization.width &lt; w) {</span><span class="s3">\n    </span><span class="s1">organization.width = w;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update height</span><span class="s3">\n  </span><span class="s1">var h = node.rect.height;</span><span class="s3">\n  </span><span class="s1">if (rowIndex &gt; 0) h += organization.verticalPadding;</span><span class="s3">\n\n  </span><span class="s1">var extraHeight = 0;</span><span class="s3">\n  </span><span class="s1">if (h &gt; organization.rowHeight[rowIndex]) {</span><span class="s3">\n    </span><span class="s1">extraHeight = organization.rowHeight[rowIndex];</span><span class="s3">\n    </span><span class="s1">organization.rowHeight[rowIndex] = h;</span><span class="s3">\n    </span><span class="s1">extraHeight = organization.rowHeight[rowIndex] - extraHeight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">organization.height += extraHeight;</span><span class="s3">\n\n  </span><span class="s1">// Insert node</span><span class="s3">\n  </span><span class="s1">organization.rows[rowIndex].push(node);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//Scans the rows of an organization and returns the one with the min width</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getShortestRowIndex = function (organization) {</span><span class="s3">\n  </span><span class="s1">var r = -1;</span><span class="s3">\n  </span><span class="s1">var min = Number.MAX_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (organization.rowWidth[i] &lt; min) {</span><span class="s3">\n      </span><span class="s1">r = i;</span><span class="s3">\n      </span><span class="s1">min = organization.rowWidth[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return r;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//Scans the rows of an organization and returns the one with the max width</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getLongestRowIndex = function (organization) {</span><span class="s3">\n  </span><span class="s1">var r = -1;</span><span class="s3">\n  </span><span class="s1">var max = Number.MIN_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n\n    </span><span class="s1">if (organization.rowWidth[i] &gt; max) {</span><span class="s3">\n      </span><span class="s1">r = i;</span><span class="s3">\n      </span><span class="s1">max = organization.rowWidth[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return r;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* This method checks whether adding extra width to the organization violates</span><span class="s3">\n</span><span class="s1">* the aspect ratio(1) or not.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {</span><span class="s3">\n\n  </span><span class="s1">var sri = this.getShortestRowIndex(organization);</span><span class="s3">\n\n  </span><span class="s1">if (sri &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var min = organization.rowWidth[sri];</span><span class="s3">\n\n  </span><span class="s1">if (min + organization.horizontalPadding + extraWidth &lt;= organization.width) return true;</span><span class="s3">\n\n  </span><span class="s1">var hDiff = 0;</span><span class="s3">\n\n  </span><span class="s1">// Adding to an existing row</span><span class="s3">\n  </span><span class="s1">if (organization.rowHeight[sri] &lt; extraHeight) {</span><span class="s3">\n    </span><span class="s1">if (sri &gt; 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var add_to_row_ratio;</span><span class="s3">\n  </span><span class="s1">if (organization.width - min &gt;= extraWidth + organization.horizontalPadding) {</span><span class="s3">\n    </span><span class="s1">add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">add_to_row_ratio = (organization.height + hDiff) / organization.width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Adding a new row for this node</span><span class="s3">\n  </span><span class="s1">hDiff = extraHeight + organization.verticalPadding;</span><span class="s3">\n  </span><span class="s1">var add_new_row_ratio;</span><span class="s3">\n  </span><span class="s1">if (organization.width &lt; extraWidth) {</span><span class="s3">\n    </span><span class="s1">add_new_row_ratio = (organization.height + hDiff) / extraWidth;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">add_new_row_ratio = (organization.height + hDiff) / organization.width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (add_new_row_ratio &lt; 1) add_new_row_ratio = 1 / add_new_row_ratio;</span><span class="s3">\n\n  </span><span class="s1">if (add_to_row_ratio &lt; 1) add_to_row_ratio = 1 / add_to_row_ratio;</span><span class="s3">\n\n  </span><span class="s1">return add_to_row_ratio &lt; add_new_row_ratio;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//If moving the last node from the longest row and adding it to the last</span><span class="s3">\n</span><span class="s1">//row makes the bounding box smaller, do it.</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.shiftToLastRow = function (organization) {</span><span class="s3">\n  </span><span class="s1">var longest = this.getLongestRowIndex(organization);</span><span class="s3">\n  </span><span class="s1">var last = organization.rowWidth.length - 1;</span><span class="s3">\n  </span><span class="s1">var row = organization.rows[longest];</span><span class="s3">\n  </span><span class="s1">var node = row[row.length - 1];</span><span class="s3">\n\n  </span><span class="s1">var diff = node.width + organization.horizontalPadding;</span><span class="s3">\n\n  </span><span class="s1">// Check if there is enough space on the last row</span><span class="s3">\n  </span><span class="s1">if (organization.width - organization.rowWidth[last] &gt; diff &amp;&amp; longest != last) {</span><span class="s3">\n    </span><span class="s1">// Remove the last element of the longest row</span><span class="s3">\n    </span><span class="s1">row.splice(-1, 1);</span><span class="s3">\n\n    </span><span class="s1">// Push it to the last row</span><span class="s3">\n    </span><span class="s1">organization.rows[last].push(node);</span><span class="s3">\n\n    </span><span class="s1">organization.rowWidth[longest] = organization.rowWidth[longest] - diff;</span><span class="s3">\n    </span><span class="s1">organization.rowWidth[last] = organization.rowWidth[last] + diff;</span><span class="s3">\n    </span><span class="s1">organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];</span><span class="s3">\n\n    </span><span class="s1">// Update heights of the organization</span><span class="s3">\n    </span><span class="s1">var maxHeight = Number.MIN_VALUE;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; row.length; i++) {</span><span class="s3">\n      </span><span class="s1">if (row[i].height &gt; maxHeight) maxHeight = row[i].height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (longest &gt; 0) maxHeight += organization.verticalPadding;</span><span class="s3">\n\n    </span><span class="s1">var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];</span><span class="s3">\n\n    </span><span class="s1">organization.rowHeight[longest] = maxHeight;</span><span class="s3">\n    </span><span class="s1">if (organization.rowHeight[last] &lt; node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;</span><span class="s3">\n\n    </span><span class="s1">var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];</span><span class="s3">\n    </span><span class="s1">organization.height += finalTotal - prevTotal;</span><span class="s3">\n\n    </span><span class="s1">this.shiftToLastRow(organization);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tilingPreLayout = function () {</span><span class="s3">\n  </span><span class="s1">if (CoSEConstants.TILE) {</span><span class="s3">\n    </span><span class="s1">// Find zero degree nodes and create a compound for each level</span><span class="s3">\n    </span><span class="s1">this.groupZeroDegreeMembers();</span><span class="s3">\n    </span><span class="s1">// Tile and clear children of each compound</span><span class="s3">\n    </span><span class="s1">this.clearCompounds();</span><span class="s3">\n    </span><span class="s1">// Separately tile and clear zero degree nodes for each level</span><span class="s3">\n    </span><span class="s1">this.clearZeroDegreeMembers();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tilingPostLayout = function () {</span><span class="s3">\n  </span><span class="s1">if (CoSEConstants.TILE) {</span><span class="s3">\n    </span><span class="s1">this.repopulateZeroDegreeMembers();</span><span class="s3">\n    </span><span class="s1">this.repopulateCompounds();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: Tree Reduction methods</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Reduce trees </span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.reduceTrees = function () {</span><span class="s3">\n  </span><span class="s1">var prunedNodesAll = [];</span><span class="s3">\n  </span><span class="s1">var containsLeaf = true;</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">while (containsLeaf) {</span><span class="s3">\n    </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n    </span><span class="s1">var prunedNodesInStepTemp = [];</span><span class="s3">\n    </span><span class="s1">containsLeaf = false;</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = allNodes[i];</span><span class="s3">\n      </span><span class="s1">if (node.getEdges().length == 1 &amp;&amp; !node.getEdges()[0].isInterGraph &amp;&amp; node.getChild() == null) {</span><span class="s3">\n        </span><span class="s1">prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);</span><span class="s3">\n        </span><span class="s1">containsLeaf = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (containsLeaf == true) {</span><span class="s3">\n      </span><span class="s1">var prunedNodesInStep = [];</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; prunedNodesInStepTemp.length; j++) {</span><span class="s3">\n        </span><span class="s1">if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {</span><span class="s3">\n          </span><span class="s1">prunedNodesInStep.push(prunedNodesInStepTemp[j]);</span><span class="s3">\n          </span><span class="s1">prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">prunedNodesAll.push(prunedNodesInStep);</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.prunedNodesAll = prunedNodesAll;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Grow tree one step </span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.growTree = function (prunedNodesAll) {</span><span class="s3">\n  </span><span class="s1">var lengthOfPrunedNodesInStep = prunedNodesAll.length;</span><span class="s3">\n  </span><span class="s1">var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];</span><span class="s3">\n\n  </span><span class="s1">var nodeData;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; prunedNodesInStep.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodeData = prunedNodesInStep[i];</span><span class="s3">\n\n    </span><span class="s1">this.findPlaceforPrunedNode(nodeData);</span><span class="s3">\n\n    </span><span class="s1">nodeData[2].add(nodeData[0]);</span><span class="s3">\n    </span><span class="s1">nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">prunedNodesAll.splice(prunedNodesAll.length - 1, 1);</span><span class="s3">\n  </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n  </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Find an appropriate position to replace pruned node, this method can be improved</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {</span><span class="s3">\n\n  </span><span class="s1">var gridForPrunedNode;</span><span class="s3">\n  </span><span class="s1">var nodeToConnect;</span><span class="s3">\n  </span><span class="s1">var prunedNode = nodeData[0];</span><span class="s3">\n  </span><span class="s1">if (prunedNode == nodeData[1].source) {</span><span class="s3">\n    </span><span class="s1">nodeToConnect = nodeData[1].target;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">nodeToConnect = nodeData[1].source;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var startGridX = nodeToConnect.startX;</span><span class="s3">\n  </span><span class="s1">var finishGridX = nodeToConnect.finishX;</span><span class="s3">\n  </span><span class="s1">var startGridY = nodeToConnect.startY;</span><span class="s3">\n  </span><span class="s1">var finishGridY = nodeToConnect.finishY;</span><span class="s3">\n\n  </span><span class="s1">var upNodeCount = 0;</span><span class="s3">\n  </span><span class="s1">var downNodeCount = 0;</span><span class="s3">\n  </span><span class="s1">var rightNodeCount = 0;</span><span class="s3">\n  </span><span class="s1">var leftNodeCount = 0;</span><span class="s3">\n  </span><span class="s1">var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];</span><span class="s3">\n\n  </span><span class="s1">if (startGridY &gt; 0) {</span><span class="s3">\n    </span><span class="s1">for (var i = startGridX; i &lt;= finishGridX; i++) {</span><span class="s3">\n      </span><span class="s1">controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (finishGridX &lt; this.grid.length - 1) {</span><span class="s3">\n    </span><span class="s1">for (var i = startGridY; i &lt;= finishGridY; i++) {</span><span class="s3">\n      </span><span class="s1">controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (finishGridY &lt; this.grid[0].length - 1) {</span><span class="s3">\n    </span><span class="s1">for (var i = startGridX; i &lt;= finishGridX; i++) {</span><span class="s3">\n      </span><span class="s1">controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (startGridX &gt; 0) {</span><span class="s3">\n    </span><span class="s1">for (var i = startGridY; i &lt;= finishGridY; i++) {</span><span class="s3">\n      </span><span class="s1">controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var min = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var minCount;</span><span class="s3">\n  </span><span class="s1">var minIndex;</span><span class="s3">\n  </span><span class="s1">for (var j = 0; j &lt; controlRegions.length; j++) {</span><span class="s3">\n    </span><span class="s1">if (controlRegions[j] &lt; min) {</span><span class="s3">\n      </span><span class="s1">min = controlRegions[j];</span><span class="s3">\n      </span><span class="s1">minCount = 1;</span><span class="s3">\n      </span><span class="s1">minIndex = j;</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[j] == min) {</span><span class="s3">\n      </span><span class="s1">minCount++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (minCount == 3 &amp;&amp; min == 0) {</span><span class="s3">\n    </span><span class="s1">if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[2] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (minCount == 2 &amp;&amp; min == 0) {</span><span class="s3">\n    </span><span class="s1">var random = Math.floor(Math.random() * 2);</span><span class="s3">\n    </span><span class="s1">if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0) {</span><span class="s3">\n      </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (random == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (minCount == 4 &amp;&amp; min == 0) {</span><span class="s3">\n    </span><span class="s1">var random = Math.floor(Math.random() * 4);</span><span class="s3">\n    </span><span class="s1">gridForPrunedNode = random;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">gridForPrunedNode = minIndex;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (gridForPrunedNode == 0) {</span><span class="s3">\n    </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);</span><span class="s3">\n  </span><span class="s1">} else if (gridForPrunedNode == 1) {</span><span class="s3">\n    </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());</span><span class="s3">\n  </span><span class="s1">} else if (gridForPrunedNode == 2) {</span><span class="s3">\n    </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSELayout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 7 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var coseBase = {};</span><span class="s3">\n\n</span><span class="s1">coseBase.layoutBase = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEConstants = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEEdge = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEGraph = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEGraphManager = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">coseBase.CoSELayout = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">coseBase.CoSENode = __webpack_require__(5);</span><span class="s3">\n\n</span><span class="s1">module.exports = coseBase;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ]);</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory(require(</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">cytoscapeCoseBilkent</span><span class="s3">\&quot;</span><span class="s1">] = factory(require(</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">cytoscapeCoseBilkent</span><span class="s3">\&quot;</span><span class="s1">] = factory(root[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">})(this, function(__WEBPACK_EXTERNAL_MODULE_0__) {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">l: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.l = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// identity function for calling harmony imports with the correct context</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.i = function(value) { return value; };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 1);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports) {</span><span class="s3">\n\n</span><span class="s1">module.exports = __WEBPACK_EXTERNAL_MODULE_0__;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 1 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LayoutConstants = __webpack_require__(0).layoutBase.LayoutConstants;</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(0).layoutBase.FDLayoutConstants;</span><span class="s3">\n</span><span class="s1">var CoSEConstants = __webpack_require__(0).CoSEConstants;</span><span class="s3">\n</span><span class="s1">var CoSELayout = __webpack_require__(0).CoSELayout;</span><span class="s3">\n</span><span class="s1">var CoSENode = __webpack_require__(0).CoSENode;</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(0).layoutBase.PointD;</span><span class="s3">\n</span><span class="s1">var DimensionD = __webpack_require__(0).layoutBase.DimensionD;</span><span class="s3">\n\n</span><span class="s1">var defaults = {</span><span class="s3">\n  </span><span class="s1">// Called on `layoutready`</span><span class="s3">\n  </span><span class="s1">ready: function ready() {},</span><span class="s3">\n  </span><span class="s1">// Called on `layoutstop`</span><span class="s3">\n  </span><span class="s1">stop: function stop() {},</span><span class="s3">\n  </span><span class="s1">// 'draft', 'default' or 'proof</span><span class="s3">\&quot; \n  </span><span class="s1">// - 'draft' fast cooling rate </span><span class="s3">\n  </span><span class="s1">// - 'default' moderate cooling rate </span><span class="s3">\n  </span><span class="s1">// - </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot; </span><span class="s1">slow cooling rate</span><span class="s3">\n  </span><span class="s1">quality: 'default',</span><span class="s3">\n  </span><span class="s1">// include labels in node dimensions</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// number of ticks per frame; higher is faster but more jerky</span><span class="s3">\n  </span><span class="s1">refresh: 30,</span><span class="s3">\n  </span><span class="s1">// Whether to fit the network view after when done</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// Padding on fit</span><span class="s3">\n  </span><span class="s1">padding: 10,</span><span class="s3">\n  </span><span class="s1">// Whether to enable incremental mode</span><span class="s3">\n  </span><span class="s1">randomize: true,</span><span class="s3">\n  </span><span class="s1">// Node repulsion (non overlapping) multiplier</span><span class="s3">\n  </span><span class="s1">nodeRepulsion: 4500,</span><span class="s3">\n  </span><span class="s1">// Ideal edge (non nested) length</span><span class="s3">\n  </span><span class="s1">idealEdgeLength: 50,</span><span class="s3">\n  </span><span class="s1">// Divisor to compute edge forces</span><span class="s3">\n  </span><span class="s1">edgeElasticity: 0.45,</span><span class="s3">\n  </span><span class="s1">// Nesting factor (multiplier) to compute ideal edge length for nested edges</span><span class="s3">\n  </span><span class="s1">nestingFactor: 0.1,</span><span class="s3">\n  </span><span class="s1">// Gravity force (constant)</span><span class="s3">\n  </span><span class="s1">gravity: 0.25,</span><span class="s3">\n  </span><span class="s1">// Maximum number of iterations to perform</span><span class="s3">\n  </span><span class="s1">numIter: 2500,</span><span class="s3">\n  </span><span class="s1">// For enabling tiling</span><span class="s3">\n  </span><span class="s1">tile: true,</span><span class="s3">\n  </span><span class="s1">// Type of layout animation. The option set is {'during', 'end', false}</span><span class="s3">\n  </span><span class="s1">animate: 'end',</span><span class="s3">\n  </span><span class="s1">// Duration for animate:end</span><span class="s3">\n  </span><span class="s1">animationDuration: 500,</span><span class="s3">\n  </span><span class="s1">// Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)</span><span class="s3">\n  </span><span class="s1">tilingPaddingVertical: 10,</span><span class="s3">\n  </span><span class="s1">// Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)</span><span class="s3">\n  </span><span class="s1">tilingPaddingHorizontal: 10,</span><span class="s3">\n  </span><span class="s1">// Gravity range (constant) for compounds</span><span class="s3">\n  </span><span class="s1">gravityRangeCompound: 1.5,</span><span class="s3">\n  </span><span class="s1">// Gravity force (constant) for compounds</span><span class="s3">\n  </span><span class="s1">gravityCompound: 1.0,</span><span class="s3">\n  </span><span class="s1">// Gravity range (constant)</span><span class="s3">\n  </span><span class="s1">gravityRange: 3.8,</span><span class="s3">\n  </span><span class="s1">// Initial cooling factor for incremental layout</span><span class="s3">\n  </span><span class="s1">initialEnergyOnIncremental: 0.5</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function extend(defaults, options) {</span><span class="s3">\n  </span><span class="s1">var obj = {};</span><span class="s3">\n\n  </span><span class="s1">for (var i in defaults) {</span><span class="s3">\n    </span><span class="s1">obj[i] = defaults[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i in options) {</span><span class="s3">\n    </span><span class="s1">obj[i] = options[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">function _CoSELayout(_options) {</span><span class="s3">\n  </span><span class="s1">this.options = extend(defaults, _options);</span><span class="s3">\n  </span><span class="s1">getUserOptions(this.options);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var getUserOptions = function getUserOptions(options) {</span><span class="s3">\n  </span><span class="s1">if (options.nodeRepulsion != null) CoSEConstants.DEFAULT_REPULSION_STRENGTH = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = options.nodeRepulsion;</span><span class="s3">\n  </span><span class="s1">if (options.idealEdgeLength != null) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;</span><span class="s3">\n  </span><span class="s1">if (options.edgeElasticity != null) CoSEConstants.DEFAULT_SPRING_STRENGTH = FDLayoutConstants.DEFAULT_SPRING_STRENGTH = options.edgeElasticity;</span><span class="s3">\n  </span><span class="s1">if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;</span><span class="s3">\n  </span><span class="s1">if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;</span><span class="s3">\n  </span><span class="s1">if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;</span><span class="s3">\n  </span><span class="s1">if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;</span><span class="s3">\n  </span><span class="s1">if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;</span><span class="s3">\n  </span><span class="s1">if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;</span><span class="s3">\n  </span><span class="s1">if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;</span><span class="s3">\n\n  </span><span class="s1">if (options.quality == 'draft') LayoutConstants.QUALITY = 0;else if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 1;</span><span class="s3">\n\n  </span><span class="s1">CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILE = options.tile;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">_CoSELayout.prototype.run = function () {</span><span class="s3">\n  </span><span class="s1">var ready;</span><span class="s3">\n  </span><span class="s1">var frameId;</span><span class="s3">\n  </span><span class="s1">var options = this.options;</span><span class="s3">\n  </span><span class="s1">var idToLNode = this.idToLNode = {};</span><span class="s3">\n  </span><span class="s1">var layout = this.layout = new CoSELayout();</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">self.stopped = false;</span><span class="s3">\n\n  </span><span class="s1">this.cy = this.options.cy;</span><span class="s3">\n\n  </span><span class="s1">this.cy.trigger({ type: 'layoutstart', layout: this });</span><span class="s3">\n\n  </span><span class="s1">var gm = layout.newGraphManager();</span><span class="s3">\n  </span><span class="s1">this.gm = gm;</span><span class="s3">\n\n  </span><span class="s1">var nodes = this.options.eles.nodes();</span><span class="s3">\n  </span><span class="s1">var edges = this.options.eles.edges();</span><span class="s3">\n\n  </span><span class="s1">this.root = gm.addRoot();</span><span class="s3">\n  </span><span class="s1">this.processChildrenList(this.root, this.getTopMostNodes(nodes), layout);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n    </span><span class="s1">var sourceNode = this.idToLNode[edge.data(</span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n    </span><span class="s1">var targetNode = this.idToLNode[edge.data(</span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n    </span><span class="s1">if (sourceNode !== targetNode &amp;&amp; sourceNode.getEdgesBetween(targetNode).length == 0) {</span><span class="s3">\n      </span><span class="s1">var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);</span><span class="s3">\n      </span><span class="s1">e1.id = edge.id();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var getPositions = function getPositions(ele, i) {</span><span class="s3">\n    </span><span class="s1">if (typeof ele === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">ele = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var theId = ele.data('id');</span><span class="s3">\n    </span><span class="s1">var lNode = self.idToLNode[theId];</span><span class="s3">\n\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">x: lNode.getRect().getCenterX(),</span><span class="s3">\n      </span><span class="s1">y: lNode.getRect().getCenterY()</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/*</span><span class="s3">\n   </span><span class="s1">* Reposition nodes in iterations animatedly</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">var iterateAnimated = function iterateAnimated() {</span><span class="s3">\n    </span><span class="s1">// Thigs to perform after nodes are repositioned on screen</span><span class="s3">\n    </span><span class="s1">var afterReposition = function afterReposition() {</span><span class="s3">\n      </span><span class="s1">if (options.fit) {</span><span class="s3">\n        </span><span class="s1">options.cy.fit(options.eles, options.padding);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!ready) {</span><span class="s3">\n        </span><span class="s1">ready = true;</span><span class="s3">\n        </span><span class="s1">self.cy.one('layoutready', options.ready);</span><span class="s3">\n        </span><span class="s1">self.cy.trigger({ type: 'layoutready', layout: self });</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">var ticksPerFrame = self.options.refresh;</span><span class="s3">\n    </span><span class="s1">var isDone;</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; ticksPerFrame &amp;&amp; !isDone; i++) {</span><span class="s3">\n      </span><span class="s1">isDone = self.stopped || self.layout.tick();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// If layout is done</span><span class="s3">\n    </span><span class="s1">if (isDone) {</span><span class="s3">\n      </span><span class="s1">// If the layout is not a sublayout and it is successful perform post layout.</span><span class="s3">\n      </span><span class="s1">if (layout.checkLayoutSuccess() &amp;&amp; !layout.isSubLayout) {</span><span class="s3">\n        </span><span class="s1">layout.doPostLayout();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// If layout has a tilingPostLayout function property call it.</span><span class="s3">\n      </span><span class="s1">if (layout.tilingPostLayout) {</span><span class="s3">\n        </span><span class="s1">layout.tilingPostLayout();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">layout.isLayoutFinished = true;</span><span class="s3">\n\n      </span><span class="s1">self.options.eles.nodes().positions(getPositions);</span><span class="s3">\n\n      </span><span class="s1">afterReposition();</span><span class="s3">\n\n      </span><span class="s1">// trigger layoutstop when the layout stops (e.g. finishes)</span><span class="s3">\n      </span><span class="s1">self.cy.one('layoutstop', self.options.stop);</span><span class="s3">\n      </span><span class="s1">self.cy.trigger({ type: 'layoutstop', layout: self });</span><span class="s3">\n\n      </span><span class="s1">if (frameId) {</span><span class="s3">\n        </span><span class="s1">cancelAnimationFrame(frameId);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">ready = false;</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var animationData = self.layout.getPositionsData(); // Get positions of layout nodes note that all nodes may not be layout nodes because of tiling</span><span class="s3">\n\n    </span><span class="s1">// Position nodes, for the nodes whose id does not included in data (because they are removed from their parents and included in dummy compounds)</span><span class="s3">\n    </span><span class="s1">// use position of their ancestors or dummy ancestors</span><span class="s3">\n    </span><span class="s1">options.eles.nodes().positions(function (ele, i) {</span><span class="s3">\n      </span><span class="s1">if (typeof ele === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">ele = i;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// If ele is a compound node, then its position will be defined by its children</span><span class="s3">\n      </span><span class="s1">if (!ele.isParent()) {</span><span class="s3">\n        </span><span class="s1">var theId = ele.id();</span><span class="s3">\n        </span><span class="s1">var pNode = animationData[theId];</span><span class="s3">\n        </span><span class="s1">var temp = ele;</span><span class="s3">\n        </span><span class="s1">// If pNode is undefined search until finding position data of its first ancestor (It may be dummy as well)</span><span class="s3">\n        </span><span class="s1">while (pNode == null) {</span><span class="s3">\n          </span><span class="s1">pNode = animationData[temp.data('parent')] || animationData['DummyCompound_' + temp.data('parent')];</span><span class="s3">\n          </span><span class="s1">animationData[theId] = pNode;</span><span class="s3">\n          </span><span class="s1">temp = temp.parent()[0];</span><span class="s3">\n          </span><span class="s1">if (temp == undefined) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pNode != null) {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">x: pNode.x,</span><span class="s3">\n            </span><span class="s1">y: pNode.y</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">x: ele.position('x'),</span><span class="s3">\n            </span><span class="s1">y: ele.position('y')</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">afterReposition();</span><span class="s3">\n\n    </span><span class="s1">frameId = requestAnimationFrame(iterateAnimated);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/*</span><span class="s3">\n  </span><span class="s1">* Listen 'layoutstarted' event and start animated iteration if animate option is 'during'</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">layout.addListener('layoutstarted', function () {</span><span class="s3">\n    </span><span class="s1">if (self.options.animate === 'during') {</span><span class="s3">\n      </span><span class="s1">frameId = requestAnimationFrame(iterateAnimated);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">layout.runLayout(); // Run cose layout</span><span class="s3">\n\n  </span><span class="s1">/*</span><span class="s3">\n   </span><span class="s1">* If animate option is not 'during' ('end' or false) perform these here (If it is 'during' similar things are already performed)</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">if (this.options.animate !== </span><span class="s3">\&quot;</span><span class="s1">during</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">self.options.eles.nodes().not(</span><span class="s3">\&quot;</span><span class="s1">:parent</span><span class="s3">\&quot;</span><span class="s1">).layoutPositions(self, self.options, getPositions); // Use layout positions to reposition the nodes it considers the options parameter</span><span class="s3">\n    </span><span class="s1">ready = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//Get the top most ones of a list of nodes</span><span class="s3">\n</span><span class="s1">_CoSELayout.prototype.getTopMostNodes = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var nodesMap = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodesMap[nodes[i].id()] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var roots = nodes.filter(function (ele, i) {</span><span class="s3">\n    </span><span class="s1">if (typeof ele === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">ele = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var parent = ele.parent()[0];</span><span class="s3">\n    </span><span class="s1">while (parent != null) {</span><span class="s3">\n      </span><span class="s1">if (nodesMap[parent.id()]) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">parent = parent.parent()[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return roots;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">_CoSELayout.prototype.processChildrenList = function (parent, children, layout) {</span><span class="s3">\n  </span><span class="s1">var size = children.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; size; i++) {</span><span class="s3">\n    </span><span class="s1">var theChild = children[i];</span><span class="s3">\n    </span><span class="s1">var children_of_children = theChild.children();</span><span class="s3">\n    </span><span class="s1">var theNode;</span><span class="s3">\n\n    </span><span class="s1">var dimensions = theChild.layoutDimensions({</span><span class="s3">\n      </span><span class="s1">nodeDimensionsIncludeLabels: this.options.nodeDimensionsIncludeLabels</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (theChild.outerWidth() != null &amp;&amp; theChild.outerHeight() != null) {</span><span class="s3">\n      </span><span class="s1">theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">theNode = parent.add(new CoSENode(this.graphManager));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Attach id to the layout node</span><span class="s3">\n    </span><span class="s1">theNode.id = theChild.data(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">// Attach the paddings of cy node to layout node</span><span class="s3">\n    </span><span class="s1">theNode.paddingLeft = parseInt(theChild.css('padding'));</span><span class="s3">\n    </span><span class="s1">theNode.paddingTop = parseInt(theChild.css('padding'));</span><span class="s3">\n    </span><span class="s1">theNode.paddingRight = parseInt(theChild.css('padding'));</span><span class="s3">\n    </span><span class="s1">theNode.paddingBottom = parseInt(theChild.css('padding'));</span><span class="s3">\n\n    </span><span class="s1">//Attach the label properties to compound if labels will be included in node dimensions  </span><span class="s3">\n    </span><span class="s1">if (this.options.nodeDimensionsIncludeLabels) {</span><span class="s3">\n      </span><span class="s1">if (theChild.isParent()) {</span><span class="s3">\n        </span><span class="s1">var labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false }).w;</span><span class="s3">\n        </span><span class="s1">var labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false }).h;</span><span class="s3">\n        </span><span class="s1">var labelPos = theChild.css(</span><span class="s3">\&quot;</span><span class="s1">text-halign</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">theNode.labelWidth = labelWidth;</span><span class="s3">\n        </span><span class="s1">theNode.labelHeight = labelHeight;</span><span class="s3">\n        </span><span class="s1">theNode.labelPos = labelPos;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Map the layout node</span><span class="s3">\n    </span><span class="s1">this.idToLNode[theChild.data(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)] = theNode;</span><span class="s3">\n\n    </span><span class="s1">if (isNaN(theNode.rect.x)) {</span><span class="s3">\n      </span><span class="s1">theNode.rect.x = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (isNaN(theNode.rect.y)) {</span><span class="s3">\n      </span><span class="s1">theNode.rect.y = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (children_of_children != null &amp;&amp; children_of_children.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var theNewGraph;</span><span class="s3">\n      </span><span class="s1">theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);</span><span class="s3">\n      </span><span class="s1">this.processChildrenList(theNewGraph, children_of_children, layout);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @brief : called on continuous layouts to stop them before they finish</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">_CoSELayout.prototype.stop = function () {</span><span class="s3">\n  </span><span class="s1">this.stopped = true;</span><span class="s3">\n\n  </span><span class="s1">return this; // chaining</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var register = function register(cytoscape) {</span><span class="s3">\n  </span><span class="s1">//  var Layout = getLayout( cytoscape );</span><span class="s3">\n\n  </span><span class="s1">cytoscape('layout', 'cose-bilkent', _CoSELayout);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// auto reg for globals</span><span class="s3">\n</span><span class="s1">if (typeof cytoscape !== 'undefined') {</span><span class="s3">\n  </span><span class="s1">register(cytoscape);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = register;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ]);</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(this, function() {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">l: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.l = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// identity function for calling harmony imports with the correct context</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.i = function(value) { return value; };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 26);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function LayoutConstants() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Layout Quality: 0:draft, 1:default, 2:proof</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.QUALITY = 1;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Default parameters</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_INCREMENTAL = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: General other constants</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Margins of a graph to be applied on bouding rectangle of its contents. We</span><span class="s3">\r\n </span><span class="s1">* assume margins on all four sides to be uniform.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Whether to consider labels in node dimensions or not</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Default dimension of a non-compound node.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.SIMPLE_NODE_SIZE = 40;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Default dimension of a non-compound node.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Empty compound node size. When a compound node is empty, its both</span><span class="s3">\r\n </span><span class="s1">* dimensions should be of this value.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Minimum length that an edge should take during layout</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.MIN_EDGE_LENGTH = 1;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* World boundaries that layout operates on</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_BOUNDARY = 1000000;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* World boundaries that random positioning can be performed with</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Coordinates of the world center</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_CENTER_X = 1200;</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_CENTER_Y = 900;</span><span class="s3">\n\n</span><span class="s1">module.exports = LayoutConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 1 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(9);</span><span class="s3">\n\n</span><span class="s1">function LEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">LGraphObject.call(this, vEdge);</span><span class="s3">\n\n  </span><span class="s1">this.isOverlapingSourceAndTarget = false;</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vEdge;</span><span class="s3">\n  </span><span class="s1">this.bendpoints = [];</span><span class="s3">\n  </span><span class="s1">this.source = source;</span><span class="s3">\n  </span><span class="s1">this.target = target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LEdge[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getSource = function () {</span><span class="s3">\n  </span><span class="s1">return this.source;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getTarget = function () {</span><span class="s3">\n  </span><span class="s1">return this.target;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.isInterGraph = function () {</span><span class="s3">\n  </span><span class="s1">return this.isInterGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getLength = function () {</span><span class="s3">\n  </span><span class="s1">return this.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.isOverlapingSourceAndTarget = function () {</span><span class="s3">\n  </span><span class="s1">return this.isOverlapingSourceAndTarget;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getBendpoints = function () {</span><span class="s3">\n  </span><span class="s1">return this.bendpoints;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.lca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getSourceInLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.sourceInLca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getTargetInLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.targetInLca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getOtherEnd = function (node) {</span><span class="s3">\n  </span><span class="s1">if (this.source === node) {</span><span class="s3">\n    </span><span class="s1">return this.target;</span><span class="s3">\n  </span><span class="s1">} else if (this.target === node) {</span><span class="s3">\n    </span><span class="s1">return this.source;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node is not incident with this edge</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getOtherEndInGraph = function (node, graph) {</span><span class="s3">\n  </span><span class="s1">var otherEnd = this.getOtherEnd(node);</span><span class="s3">\n  </span><span class="s1">var root = graph.getGraphManager().getRoot();</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">if (otherEnd.getOwner() == graph) {</span><span class="s3">\n      </span><span class="s1">return otherEnd;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (otherEnd.getOwner() == root) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">otherEnd = otherEnd.getOwner().getParent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.updateLength = function () {</span><span class="s3">\n  </span><span class="s1">var clipPointCoordinates = new Array(4);</span><span class="s3">\n\n  </span><span class="s1">this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);</span><span class="s3">\n\n  </span><span class="s1">if (!this.isOverlapingSourceAndTarget) {</span><span class="s3">\n    </span><span class="s1">this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];</span><span class="s3">\n    </span><span class="s1">this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];</span><span class="s3">\n\n    </span><span class="s1">if (Math.abs(this.lengthX) &lt; 1.0) {</span><span class="s3">\n      </span><span class="s1">this.lengthX = IMath.sign(this.lengthX);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Math.abs(this.lengthY) &lt; 1.0) {</span><span class="s3">\n      </span><span class="s1">this.lengthY = IMath.sign(this.lengthY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.updateLengthSimple = function () {</span><span class="s3">\n  </span><span class="s1">this.lengthX = this.target.getCenterX() - this.source.getCenterX();</span><span class="s3">\n  </span><span class="s1">this.lengthY = this.target.getCenterY() - this.source.getCenterY();</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.lengthX) &lt; 1.0) {</span><span class="s3">\n    </span><span class="s1">this.lengthX = IMath.sign(this.lengthX);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.lengthY) &lt; 1.0) {</span><span class="s3">\n    </span><span class="s1">this.lengthY = IMath.sign(this.lengthY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 2 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function LGraphObject(vGraphObject) {</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vGraphObject;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraphObject;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 3 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">var RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var RandomSeed = __webpack_require__(16);</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(4);</span><span class="s3">\n\n</span><span class="s1">function LNode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">//Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)</span><span class="s3">\n  </span><span class="s1">if (size == null &amp;&amp; vNode == null) {</span><span class="s3">\n    </span><span class="s1">vNode = loc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">LGraphObject.call(this, vNode);</span><span class="s3">\n\n  </span><span class="s1">//Alternative constructor 2 : LNode(Layout layout, Object vNode)</span><span class="s3">\n  </span><span class="s1">if (gm.graphManager != null) gm = gm.graphManager;</span><span class="s3">\n\n  </span><span class="s1">this.estimatedSize = Integer.MIN_VALUE;</span><span class="s3">\n  </span><span class="s1">this.inclusionTreeDepth = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vNode;</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n\n  </span><span class="s1">if (size != null &amp;&amp; loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LNode.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LNode[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.edges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getChild = function () {</span><span class="s3">\n  </span><span class="s1">return this.child;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getOwner = function () {</span><span class="s3">\n  </span><span class="s1">//  if (this.owner != null) {</span><span class="s3">\n  </span><span class="s1">//    if (!(this.owner == null || this.owner.getNodes().indexOf(this) &gt; -1)) {</span><span class="s3">\n  </span><span class="s1">//      throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//  }</span><span class="s3">\n\n  </span><span class="s1">return this.owner;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.rect.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.rect.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenterX = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x + this.rect.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenterY = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y + this.rect.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenter = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getLocation = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.rect.x, this.rect.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getRect = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getDiagonal = function () {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns half the diagonal length of this node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LNode.prototype.getHalfTheDiagonal = function () {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setRect = function (upperLeft, dimension) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = upperLeft.x;</span><span class="s3">\n  </span><span class="s1">this.rect.y = upperLeft.y;</span><span class="s3">\n  </span><span class="s1">this.rect.width = dimension.width;</span><span class="s3">\n  </span><span class="s1">this.rect.height = dimension.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setCenter = function (cx, cy) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = cx - this.rect.width / 2;</span><span class="s3">\n  </span><span class="s1">this.rect.y = cy - this.rect.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setLocation = function (x, y) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = x;</span><span class="s3">\n  </span><span class="s1">this.rect.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.moveBy = function (dx, dy) {</span><span class="s3">\n  </span><span class="s1">this.rect.x += dx;</span><span class="s3">\n  </span><span class="s1">this.rect.y += dy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdgeListToNode = function (to) {</span><span class="s3">\n  </span><span class="s1">var edgeList = [];</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (edge.target == to) {</span><span class="s3">\n      </span><span class="s1">if (edge.source != self) throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect edge source!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">edgeList.push(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return edgeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdgesBetween = function (other) {</span><span class="s3">\n  </span><span class="s1">var edgeList = [];</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source == self || edge.target == self)) throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect edge source and/or target</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (edge.target == other || edge.source == other) {</span><span class="s3">\n      </span><span class="s1">edgeList.push(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return edgeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getNeighborsList = function () {</span><span class="s3">\n  </span><span class="s1">var neighbors = new Set();</span><span class="s3">\n\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (edge.source == self) {</span><span class="s3">\n      </span><span class="s1">neighbors.add(edge.target);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (edge.target != self) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect incidency!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">neighbors.add(edge.source);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return neighbors;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.withChildren = function () {</span><span class="s3">\n  </span><span class="s1">var withNeighborsList = new Set();</span><span class="s3">\n  </span><span class="s1">var childNode;</span><span class="s3">\n  </span><span class="s1">var children;</span><span class="s3">\n\n  </span><span class="s1">withNeighborsList.add(this);</span><span class="s3">\n\n  </span><span class="s1">if (this.child != null) {</span><span class="s3">\n    </span><span class="s1">var nodes = this.child.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">childNode = nodes[i];</span><span class="s3">\n      </span><span class="s1">children = childNode.withChildren();</span><span class="s3">\n      </span><span class="s1">children.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">withNeighborsList.add(node);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return withNeighborsList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getNoOfChildren = function () {</span><span class="s3">\n  </span><span class="s1">var noOfChildren = 0;</span><span class="s3">\n  </span><span class="s1">var childNode;</span><span class="s3">\n\n  </span><span class="s1">if (this.child == null) {</span><span class="s3">\n    </span><span class="s1">noOfChildren = 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var nodes = this.child.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">childNode = nodes[i];</span><span class="s3">\n\n      </span><span class="s1">noOfChildren += childNode.getNoOfChildren();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (noOfChildren == 0) {</span><span class="s3">\n    </span><span class="s1">noOfChildren = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return noOfChildren;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.estimatedSize == Integer.MIN_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.calcEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.child == null) {</span><span class="s3">\n    </span><span class="s1">return this.estimatedSize = (this.rect.width + this.rect.height) / 2;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = this.child.calcEstimatedSize();</span><span class="s3">\n    </span><span class="s1">this.rect.width = this.estimatedSize;</span><span class="s3">\n    </span><span class="s1">this.rect.height = this.estimatedSize;</span><span class="s3">\n\n    </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.scatter = function () {</span><span class="s3">\n  </span><span class="s1">var randomCenterX;</span><span class="s3">\n  </span><span class="s1">var randomCenterY;</span><span class="s3">\n\n  </span><span class="s1">var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;</span><span class="s3">\n\n  </span><span class="s1">var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;</span><span class="s3">\n\n  </span><span class="s1">this.rect.x = randomCenterX;</span><span class="s3">\n  </span><span class="s1">this.rect.y = randomCenterY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.updateBounds = function () {</span><span class="s3">\n  </span><span class="s1">if (this.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (this.getChild().getNodes().length != 0) {</span><span class="s3">\n    </span><span class="s1">// wrap the children nodes by re-arranging the boundaries</span><span class="s3">\n    </span><span class="s1">var childGraph = this.getChild();</span><span class="s3">\n    </span><span class="s1">childGraph.updateBounds(true);</span><span class="s3">\n\n    </span><span class="s1">this.rect.x = childGraph.getLeft();</span><span class="s3">\n    </span><span class="s1">this.rect.y = childGraph.getTop();</span><span class="s3">\n\n    </span><span class="s1">this.setWidth(childGraph.getRight() - childGraph.getLeft());</span><span class="s3">\n    </span><span class="s1">this.setHeight(childGraph.getBottom() - childGraph.getTop());</span><span class="s3">\n\n    </span><span class="s1">// Update compound bounds considering its label properties    </span><span class="s3">\n    </span><span class="s1">if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {</span><span class="s3">\n\n      </span><span class="s1">var width = childGraph.getRight() - childGraph.getLeft();</span><span class="s3">\n      </span><span class="s1">var height = childGraph.getBottom() - childGraph.getTop();</span><span class="s3">\n\n      </span><span class="s1">if (this.labelWidth &gt; width) {</span><span class="s3">\n        </span><span class="s1">this.rect.x -= (this.labelWidth - width) / 2;</span><span class="s3">\n        </span><span class="s1">this.setWidth(this.labelWidth);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.labelHeight &gt; height) {</span><span class="s3">\n        </span><span class="s1">if (this.labelPos == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.rect.y -= (this.labelHeight - height) / 2;</span><span class="s3">\n        </span><span class="s1">} else if (this.labelPos == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.rect.y -= this.labelHeight - height;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.setHeight(this.labelHeight);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getInclusionTreeDepth = function () {</span><span class="s3">\n  </span><span class="s1">if (this.inclusionTreeDepth == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.inclusionTreeDepth;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.transform = function (trans) {</span><span class="s3">\n  </span><span class="s1">var left = this.rect.x;</span><span class="s3">\n\n  </span><span class="s1">if (left &gt; LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">left = LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">} else if (left &lt; -LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">left = -LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var top = this.rect.y;</span><span class="s3">\n\n  </span><span class="s1">if (top &gt; LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">top = LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">} else if (top &lt; -LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">top = -LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var leftTop = new PointD(left, top);</span><span class="s3">\n  </span><span class="s1">var vLeftTop = trans.inverseTransformPoint(leftTop);</span><span class="s3">\n\n  </span><span class="s1">this.setLocation(vLeftTop.x, vLeftTop.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getLeft = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x + this.rect.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getTop = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y + this.rect.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getParent = function () {</span><span class="s3">\n  </span><span class="s1">if (this.owner == null) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return this.owner.getParent();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LNode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 4 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function PointD(x, y) {</span><span class="s3">\n  </span><span class="s1">if (x == null &amp;&amp; y == null) {</span><span class="s3">\n    </span><span class="s1">this.x = 0;</span><span class="s3">\n    </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.setX = function (x) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.setY = function (y) {</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getDifference = function (pt) {</span><span class="s3">\n  </span><span class="s1">return new DimensionD(this.x - pt.x, this.y - pt.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getCopy = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.x, this.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.translate = function (dim) {</span><span class="s3">\n  </span><span class="s1">this.x += dim.width;</span><span class="s3">\n  </span><span class="s1">this.y += dim.height;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = PointD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 5 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var LGraphManager = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">var Point = __webpack_require__(12);</span><span class="s3">\n</span><span class="s1">var LinkedList = __webpack_require__(11);</span><span class="s3">\n\n</span><span class="s1">function LGraph(parent, obj2, vGraph) {</span><span class="s3">\n  </span><span class="s1">LGraphObject.call(this, vGraph);</span><span class="s3">\n  </span><span class="s1">this.estimatedSize = Integer.MIN_VALUE;</span><span class="s3">\n  </span><span class="s1">this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n  </span><span class="s1">this.nodes = [];</span><span class="s3">\n  </span><span class="s1">this.isConnected = false;</span><span class="s3">\n  </span><span class="s1">this.parent = parent;</span><span class="s3">\n\n  </span><span class="s1">if (obj2 != null &amp;&amp; obj2 instanceof LGraphManager) {</span><span class="s3">\n    </span><span class="s1">this.graphManager = obj2;</span><span class="s3">\n  </span><span class="s1">} else if (obj2 != null &amp;&amp; obj2 instanceof Layout) {</span><span class="s3">\n    </span><span class="s1">this.graphManager = obj2.graphManager;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LGraph[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getNodes = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.edges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getParent = function () {</span><span class="s3">\n  </span><span class="s1">return this.parent;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getLeft = function () {</span><span class="s3">\n  </span><span class="s1">return this.left;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.right;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getTop = function () {</span><span class="s3">\n  </span><span class="s1">return this.top;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.bottom;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.isConnected = function () {</span><span class="s3">\n  </span><span class="s1">return this.isConnected;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.add = function (obj1, sourceNode, targetNode) {</span><span class="s3">\n  </span><span class="s1">if (sourceNode == null &amp;&amp; targetNode == null) {</span><span class="s3">\n    </span><span class="s1">var newNode = obj1;</span><span class="s3">\n    </span><span class="s1">if (this.graphManager == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph has no graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.getNodes().indexOf(newNode) &gt; -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node already in graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newNode.owner = this;</span><span class="s3">\n    </span><span class="s1">this.getNodes().push(newNode);</span><span class="s3">\n\n    </span><span class="s1">return newNode;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var newEdge = obj1;</span><span class="s3">\n    </span><span class="s1">if (!(this.getNodes().indexOf(sourceNode) &gt; -1 &amp;&amp; this.getNodes().indexOf(targetNode) &gt; -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source or target not in graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!(sourceNode.owner == targetNode.owner &amp;&amp; sourceNode.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Both owners must be this graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceNode.owner != targetNode.owner) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// set source and target</span><span class="s3">\n    </span><span class="s1">newEdge.source = sourceNode;</span><span class="s3">\n    </span><span class="s1">newEdge.target = targetNode;</span><span class="s3">\n\n    </span><span class="s1">// set as intra-graph edge</span><span class="s3">\n    </span><span class="s1">newEdge.isInterGraph = false;</span><span class="s3">\n\n    </span><span class="s1">// add to graph edge list</span><span class="s3">\n    </span><span class="s1">this.getEdges().push(newEdge);</span><span class="s3">\n\n    </span><span class="s1">// add to incidency lists</span><span class="s3">\n    </span><span class="s1">sourceNode.edges.push(newEdge);</span><span class="s3">\n\n    </span><span class="s1">if (targetNode != sourceNode) {</span><span class="s3">\n      </span><span class="s1">targetNode.edges.push(newEdge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return newEdge;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.remove = function (obj) {</span><span class="s3">\n  </span><span class="s1">var node = obj;</span><span class="s3">\n  </span><span class="s1">if (obj instanceof LNode) {</span><span class="s3">\n    </span><span class="s1">if (node == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(node.owner != null &amp;&amp; node.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Owner graph is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.graphManager == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Owner graph manager is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// remove incident edges first (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var edgesToBeRemoved = node.edges.slice();</span><span class="s3">\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var s = edgesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">edge = edgesToBeRemoved[i];</span><span class="s3">\n\n      </span><span class="s1">if (edge.isInterGraph) {</span><span class="s3">\n        </span><span class="s1">this.graphManager.remove(edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">edge.source.owner.remove(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now the node itself</span><span class="s3">\n    </span><span class="s1">var index = this.nodes.indexOf(node);</span><span class="s3">\n    </span><span class="s1">if (index == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node not in owner node list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.nodes.splice(index, 1);</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">var edge = obj;</span><span class="s3">\n    </span><span class="s1">if (edge == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source != null &amp;&amp; edge.target != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source.owner != null &amp;&amp; edge.target.owner != null &amp;&amp; edge.source.owner == this &amp;&amp; edge.target.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target owner is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var sourceIndex = edge.source.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">var targetIndex = edge.target.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">if (!(sourceIndex &gt; -1 &amp;&amp; targetIndex &gt; -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target doesn't know this edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edge.source.edges.splice(sourceIndex, 1);</span><span class="s3">\n\n    </span><span class="s1">if (edge.target != edge.source) {</span><span class="s3">\n      </span><span class="s1">edge.target.edges.splice(targetIndex, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.owner.getEdges().indexOf(edge);</span><span class="s3">\n    </span><span class="s1">if (index == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not in owner's edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edge.source.owner.getEdges().splice(index, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateLeftTop = function () {</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var margin;</span><span class="s3">\n\n  </span><span class="s1">var nodes = this.getNodes();</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Do we have any nodes in this graph?</span><span class="s3">\n  </span><span class="s1">if (top == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nodes[0].getParent().paddingLeft != undefined) {</span><span class="s3">\n    </span><span class="s1">margin = nodes[0].getParent().paddingLeft;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">margin = this.margin;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.left = left - margin;</span><span class="s3">\n  </span><span class="s1">this.top = top - margin;</span><span class="s3">\n\n  </span><span class="s1">// Apply the margins and return the result</span><span class="s3">\n  </span><span class="s1">return new Point(this.left, this.top);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateBounds = function (recursive) {</span><span class="s3">\n  </span><span class="s1">// calculate bounds</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var right = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var bottom = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var nodeRight;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeBottom;</span><span class="s3">\n  </span><span class="s1">var margin;</span><span class="s3">\n\n  </span><span class="s1">var nodes = this.nodes;</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">if (recursive &amp;&amp; lNode.child != null) {</span><span class="s3">\n      </span><span class="s1">lNode.updateBounds();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n    </span><span class="s1">nodeRight = lNode.getRight();</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeBottom = lNode.getBottom();</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (right &lt; nodeRight) {</span><span class="s3">\n      </span><span class="s1">right = nodeRight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bottom &lt; nodeBottom) {</span><span class="s3">\n      </span><span class="s1">bottom = nodeBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var boundingRect = new RectangleD(left, top, right - left, bottom - top);</span><span class="s3">\n  </span><span class="s1">if (left == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">this.left = this.parent.getLeft();</span><span class="s3">\n    </span><span class="s1">this.right = this.parent.getRight();</span><span class="s3">\n    </span><span class="s1">this.top = this.parent.getTop();</span><span class="s3">\n    </span><span class="s1">this.bottom = this.parent.getBottom();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nodes[0].getParent().paddingLeft != undefined) {</span><span class="s3">\n    </span><span class="s1">margin = nodes[0].getParent().paddingLeft;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">margin = this.margin;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.left = boundingRect.x - margin;</span><span class="s3">\n  </span><span class="s1">this.right = boundingRect.x + boundingRect.width + margin;</span><span class="s3">\n  </span><span class="s1">this.top = boundingRect.y - margin;</span><span class="s3">\n  </span><span class="s1">this.bottom = boundingRect.y + boundingRect.height + margin;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.calculateBounds = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var right = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var bottom = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var nodeRight;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeBottom;</span><span class="s3">\n\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n    </span><span class="s1">nodeRight = lNode.getRight();</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeBottom = lNode.getBottom();</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (right &lt; nodeRight) {</span><span class="s3">\n      </span><span class="s1">right = nodeRight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bottom &lt; nodeBottom) {</span><span class="s3">\n      </span><span class="s1">bottom = nodeBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var boundingRect = new RectangleD(left, top, right - left, bottom - top);</span><span class="s3">\n\n  </span><span class="s1">return boundingRect;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getInclusionTreeDepth = function () {</span><span class="s3">\n  </span><span class="s1">if (this == this.graphManager.getRoot()) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return this.parent.getInclusionTreeDepth();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.estimatedSize == Integer.MIN_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.calcEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">var size = 0;</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes;</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">size += lNode.calcEstimatedSize();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (size == 0) {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = size / Math.sqrt(this.nodes.length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateConnected = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">if (this.nodes.length == 0) {</span><span class="s3">\n    </span><span class="s1">this.isConnected = true;</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var currentNode = this.nodes[0];</span><span class="s3">\n  </span><span class="s1">var neighborEdges;</span><span class="s3">\n  </span><span class="s1">var currentNeighbor;</span><span class="s3">\n  </span><span class="s1">var childrenOfNode = currentNode.withChildren();</span><span class="s3">\n  </span><span class="s1">childrenOfNode.forEach(function (node) {</span><span class="s3">\n    </span><span class="s1">queue.push(node);</span><span class="s3">\n    </span><span class="s1">visited.add(node);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">while (queue.length !== 0) {</span><span class="s3">\n    </span><span class="s1">currentNode = queue.shift();</span><span class="s3">\n\n    </span><span class="s1">// Traverse all neighbors of this node</span><span class="s3">\n    </span><span class="s1">neighborEdges = currentNode.getEdges();</span><span class="s3">\n    </span><span class="s1">var size = neighborEdges.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; size; i++) {</span><span class="s3">\n      </span><span class="s1">var neighborEdge = neighborEdges[i];</span><span class="s3">\n      </span><span class="s1">currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);</span><span class="s3">\n\n      </span><span class="s1">// Add unvisited neighbors to the list to visit</span><span class="s3">\n      </span><span class="s1">if (currentNeighbor != null &amp;&amp; !visited.has(currentNeighbor)) {</span><span class="s3">\n        </span><span class="s1">var childrenOfNeighbor = currentNeighbor.withChildren();</span><span class="s3">\n\n        </span><span class="s1">childrenOfNeighbor.forEach(function (node) {</span><span class="s3">\n          </span><span class="s1">queue.push(node);</span><span class="s3">\n          </span><span class="s1">visited.add(node);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.isConnected = false;</span><span class="s3">\n\n  </span><span class="s1">if (visited.size &gt;= this.nodes.length) {</span><span class="s3">\n    </span><span class="s1">var noOfVisitedInThisGraph = 0;</span><span class="s3">\n\n    </span><span class="s1">visited.forEach(function (visitedNode) {</span><span class="s3">\n      </span><span class="s1">if (visitedNode.owner == self) {</span><span class="s3">\n        </span><span class="s1">noOfVisitedInThisGraph++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (noOfVisitedInThisGraph == this.nodes.length) {</span><span class="s3">\n      </span><span class="s1">this.isConnected = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraph;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 6 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraph;</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n\n</span><span class="s1">function LGraphManager(layout) {</span><span class="s3">\n  </span><span class="s1">LGraph = __webpack_require__(5); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.</span><span class="s3">\n  </span><span class="s1">this.layout = layout;</span><span class="s3">\n\n  </span><span class="s1">this.graphs = [];</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.addRoot = function () {</span><span class="s3">\n  </span><span class="s1">var ngraph = this.layout.newGraph();</span><span class="s3">\n  </span><span class="s1">var nnode = this.layout.newNode(null);</span><span class="s3">\n  </span><span class="s1">var root = this.add(ngraph, nnode);</span><span class="s3">\n  </span><span class="s1">this.setRootGraph(root);</span><span class="s3">\n  </span><span class="s1">return this.rootGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {</span><span class="s3">\n  </span><span class="s1">//there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge</span><span class="s3">\n  </span><span class="s1">if (newEdge == null &amp;&amp; sourceNode == null &amp;&amp; targetNode == null) {</span><span class="s3">\n    </span><span class="s1">if (newGraph == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Parent node is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.graphs.indexOf(newGraph) &gt; -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph already in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.graphs.push(newGraph);</span><span class="s3">\n\n    </span><span class="s1">if (newGraph.parent != null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Already has a parent!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parentNode.child != null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Already has a child!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">newGraph.parent = parentNode;</span><span class="s3">\n    </span><span class="s1">parentNode.child = newGraph;</span><span class="s3">\n\n    </span><span class="s1">return newGraph;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">//change the order of the parameters</span><span class="s3">\n    </span><span class="s1">targetNode = newEdge;</span><span class="s3">\n    </span><span class="s1">sourceNode = parentNode;</span><span class="s3">\n    </span><span class="s1">newEdge = newGraph;</span><span class="s3">\n    </span><span class="s1">var sourceGraph = sourceNode.getOwner();</span><span class="s3">\n    </span><span class="s1">var targetGraph = targetNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">if (!(sourceGraph != null &amp;&amp; sourceGraph.getGraphManager() == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(targetGraph != null &amp;&amp; targetGraph.getGraphManager() == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Target not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceGraph == targetGraph) {</span><span class="s3">\n      </span><span class="s1">newEdge.isInterGraph = false;</span><span class="s3">\n      </span><span class="s1">return sourceGraph.add(newEdge, sourceNode, targetNode);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newEdge.isInterGraph = true;</span><span class="s3">\n\n      </span><span class="s1">// set source and target</span><span class="s3">\n      </span><span class="s1">newEdge.source = sourceNode;</span><span class="s3">\n      </span><span class="s1">newEdge.target = targetNode;</span><span class="s3">\n\n      </span><span class="s1">// add edge to inter-graph edge list</span><span class="s3">\n      </span><span class="s1">if (this.edges.indexOf(newEdge) &gt; -1) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge already in inter-graph edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.edges.push(newEdge);</span><span class="s3">\n\n      </span><span class="s1">// add edge to source and target incidency lists</span><span class="s3">\n      </span><span class="s1">if (!(newEdge.source != null &amp;&amp; newEdge.target != null)) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!(newEdge.source.edges.indexOf(newEdge) == -1 &amp;&amp; newEdge.target.edges.indexOf(newEdge) == -1)) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge already in source and/or target incidency list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">newEdge.source.edges.push(newEdge);</span><span class="s3">\n      </span><span class="s1">newEdge.target.edges.push(newEdge);</span><span class="s3">\n\n      </span><span class="s1">return newEdge;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.remove = function (lObj) {</span><span class="s3">\n  </span><span class="s1">if (lObj instanceof LGraph) {</span><span class="s3">\n    </span><span class="s1">var graph = lObj;</span><span class="s3">\n    </span><span class="s1">if (graph.getGraphManager() != this) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph not in this graph mgr</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(graph == this.rootGraph || graph.parent != null &amp;&amp; graph.parent.graphManager == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Invalid parent node!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// first the edges (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var edgesToBeRemoved = [];</span><span class="s3">\n\n    </span><span class="s1">edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());</span><span class="s3">\n\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var s = edgesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">edge = edgesToBeRemoved[i];</span><span class="s3">\n      </span><span class="s1">graph.remove(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// then the nodes (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var nodesToBeRemoved = [];</span><span class="s3">\n\n    </span><span class="s1">nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());</span><span class="s3">\n\n    </span><span class="s1">var node;</span><span class="s3">\n    </span><span class="s1">s = nodesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">node = nodesToBeRemoved[i];</span><span class="s3">\n      </span><span class="s1">graph.remove(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check if graph is the root</span><span class="s3">\n    </span><span class="s1">if (graph == this.rootGraph) {</span><span class="s3">\n      </span><span class="s1">this.setRootGraph(null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now remove the graph itself</span><span class="s3">\n    </span><span class="s1">var index = this.graphs.indexOf(graph);</span><span class="s3">\n    </span><span class="s1">this.graphs.splice(index, 1);</span><span class="s3">\n\n    </span><span class="s1">// also reset the parent of the graph</span><span class="s3">\n    </span><span class="s1">graph.parent = null;</span><span class="s3">\n  </span><span class="s1">} else if (lObj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">edge = lObj;</span><span class="s3">\n    </span><span class="s1">if (edge == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!edge.isInterGraph) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not an inter-graph edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source != null &amp;&amp; edge.target != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// remove edge from source and target nodes' incidency lists</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source.edges.indexOf(edge) != -1 &amp;&amp; edge.target.edges.indexOf(edge) != -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target doesn't know this edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.source.edges.splice(index, 1);</span><span class="s3">\n    </span><span class="s1">index = edge.target.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.target.edges.splice(index, 1);</span><span class="s3">\n\n    </span><span class="s1">// remove edge from owner graph manager's inter-graph edge list</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source.owner != null &amp;&amp; edge.source.owner.getGraphManager() != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge owner graph or owner graph manager is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not in owner graph manager's edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.owner.getGraphManager().edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.source.owner.getGraphManager().edges.splice(index, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.updateBounds = function () {</span><span class="s3">\n  </span><span class="s1">this.rootGraph.updateBounds(true);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getGraphs = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphs;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">if (this.allNodes == null) {</span><span class="s3">\n    </span><span class="s1">var nodeList = [];</span><span class="s3">\n    </span><span class="s1">var graphs = this.getGraphs();</span><span class="s3">\n    </span><span class="s1">var s = graphs.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">nodeList = nodeList.concat(graphs[i].getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.allNodes = nodeList;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.allNodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">this.allNodes = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">this.allEdges = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">this.allNodesToApplyGravitation = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">if (this.allEdges == null) {</span><span class="s3">\n    </span><span class="s1">var edgeList = [];</span><span class="s3">\n    </span><span class="s1">var graphs = this.getGraphs();</span><span class="s3">\n    </span><span class="s1">var s = graphs.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; graphs.length; i++) {</span><span class="s3">\n      </span><span class="s1">edgeList = edgeList.concat(graphs[i].getEdges());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edgeList = edgeList.concat(this.edges);</span><span class="s3">\n\n    </span><span class="s1">this.allEdges = edgeList;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.allEdges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">return this.allNodesToApplyGravitation;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {</span><span class="s3">\n  </span><span class="s1">if (this.allNodesToApplyGravitation != null) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.allNodesToApplyGravitation = nodeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getRoot = function () {</span><span class="s3">\n  </span><span class="s1">return this.rootGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.setRootGraph = function (graph) {</span><span class="s3">\n  </span><span class="s1">if (graph.getGraphManager() != this) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Root not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.rootGraph = graph;</span><span class="s3">\n  </span><span class="s1">// root graph must have a root node associated with it for convenience</span><span class="s3">\n  </span><span class="s1">if (graph.parent == null) {</span><span class="s3">\n    </span><span class="s1">graph.parent = this.layout.newNode(</span><span class="s3">\&quot;</span><span class="s1">Root node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getLayout = function () {</span><span class="s3">\n  </span><span class="s1">return this.layout;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {</span><span class="s3">\n  </span><span class="s1">if (!(firstNode != null &amp;&amp; secondNode != null)) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (firstNode == secondNode) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Is second node an ancestor of the first one?</span><span class="s3">\n  </span><span class="s1">var ownerGraph = firstNode.getOwner();</span><span class="s3">\n  </span><span class="s1">var parentNode;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">parentNode = ownerGraph.getParent();</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == secondNode) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">ownerGraph = parentNode.getOwner();</span><span class="s3">\n    </span><span class="s1">if (ownerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n  </span><span class="s1">// Is first node an ancestor of the second one?</span><span class="s3">\n  </span><span class="s1">ownerGraph = secondNode.getOwner();</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">parentNode = ownerGraph.getParent();</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == firstNode) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">ownerGraph = parentNode.getOwner();</span><span class="s3">\n    </span><span class="s1">if (ownerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcLowestCommonAncestors = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var sourceNode;</span><span class="s3">\n  </span><span class="s1">var targetNode;</span><span class="s3">\n  </span><span class="s1">var sourceAncestorGraph;</span><span class="s3">\n  </span><span class="s1">var targetAncestorGraph;</span><span class="s3">\n\n  </span><span class="s1">var edges = this.getAllEdges();</span><span class="s3">\n  </span><span class="s1">var s = edges.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">edge = edges[i];</span><span class="s3">\n\n    </span><span class="s1">sourceNode = edge.source;</span><span class="s3">\n    </span><span class="s1">targetNode = edge.target;</span><span class="s3">\n    </span><span class="s1">edge.lca = null;</span><span class="s3">\n    </span><span class="s1">edge.sourceInLca = sourceNode;</span><span class="s3">\n    </span><span class="s1">edge.targetInLca = targetNode;</span><span class="s3">\n\n    </span><span class="s1">if (sourceNode == targetNode) {</span><span class="s3">\n      </span><span class="s1">edge.lca = sourceNode.getOwner();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">sourceAncestorGraph = sourceNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">while (edge.lca == null) {</span><span class="s3">\n      </span><span class="s1">edge.targetInLca = targetNode;</span><span class="s3">\n      </span><span class="s1">targetAncestorGraph = targetNode.getOwner();</span><span class="s3">\n\n      </span><span class="s1">while (edge.lca == null) {</span><span class="s3">\n        </span><span class="s1">if (targetAncestorGraph == sourceAncestorGraph) {</span><span class="s3">\n          </span><span class="s1">edge.lca = targetAncestorGraph;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (targetAncestorGraph == this.rootGraph) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (edge.lca != null) {</span><span class="s3">\n          </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">edge.targetInLca = targetAncestorGraph.getParent();</span><span class="s3">\n        </span><span class="s1">targetAncestorGraph = edge.targetInLca.getOwner();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (sourceAncestorGraph == this.rootGraph) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (edge.lca == null) {</span><span class="s3">\n        </span><span class="s1">edge.sourceInLca = sourceAncestorGraph.getParent();</span><span class="s3">\n        </span><span class="s1">sourceAncestorGraph = edge.sourceInLca.getOwner();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (edge.lca == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {</span><span class="s3">\n  </span><span class="s1">if (firstNode == secondNode) {</span><span class="s3">\n    </span><span class="s1">return firstNode.getOwner();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var firstOwnerGraph = firstNode.getOwner();</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">if (firstOwnerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var secondOwnerGraph = secondNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (secondOwnerGraph == null) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (secondOwnerGraph == firstOwnerGraph) {</span><span class="s3">\n        </span><span class="s1">return secondOwnerGraph;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">secondOwnerGraph = secondOwnerGraph.getParent().getOwner();</span><span class="s3">\n    </span><span class="s1">} while (true);</span><span class="s3">\n\n    </span><span class="s1">firstOwnerGraph = firstOwnerGraph.getParent().getOwner();</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n\n  </span><span class="s1">return firstOwnerGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {</span><span class="s3">\n  </span><span class="s1">if (graph == null &amp;&amp; depth == null) {</span><span class="s3">\n    </span><span class="s1">graph = this.rootGraph;</span><span class="s3">\n    </span><span class="s1">depth = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">var nodes = graph.getNodes();</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">node = nodes[i];</span><span class="s3">\n    </span><span class="s1">node.inclusionTreeDepth = depth;</span><span class="s3">\n\n    </span><span class="s1">if (node.child != null) {</span><span class="s3">\n      </span><span class="s1">this.calcInclusionTreeDepths(node.child, depth + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.includesInvalidEdge = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n\n  </span><span class="s1">var s = this.edges.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">edge = this.edges[i];</span><span class="s3">\n\n    </span><span class="s1">if (this.isOneAncestorOfOther(edge.source, edge.target)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraphManager;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 7 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutConstants() {}</span><span class="s3">\n\n</span><span class="s1">//FDLayoutConstants inherits static props in LayoutConstants</span><span class="s3">\n</span><span class="s1">for (var prop in LayoutConstants) {</span><span class="s3">\n  </span><span class="s1">FDLayoutConstants[prop] = LayoutConstants[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutConstants.MAX_ITERATIONS = 2500;</span><span class="s3">\n\n</span><span class="s1">FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MIN_EDGE_LENGTH = 1;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 8 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class maintains a list of static geometry related utility methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright: i-Vis Research Group, Bilkent University, 2007 - present</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var Point = __webpack_require__(12);</span><span class="s3">\n\n</span><span class="s1">function IGeometry() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates *half* the amount in x and y directions of the two</span><span class="s3">\n </span><span class="s1">* input rectangles needed to separate them keeping their respective</span><span class="s3">\n </span><span class="s1">* positioning, and returns the result in the input array. An input</span><span class="s3">\n </span><span class="s1">* separation buffer added to the amount in both directions. We assume that</span><span class="s3">\n </span><span class="s1">* the two rectangles do intersect.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {</span><span class="s3">\n  </span><span class="s1">if (!rectA.intersects(rectB)) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var directions = new Array(2);</span><span class="s3">\n\n  </span><span class="s1">this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);</span><span class="s3">\n\n  </span><span class="s1">overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);</span><span class="s3">\n  </span><span class="s1">overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);</span><span class="s3">\n\n  </span><span class="s1">// update the overlapping amounts for the following cases:</span><span class="s3">\n  </span><span class="s1">if (rectA.getX() &lt;= rectB.getX() &amp;&amp; rectA.getRight() &gt;= rectB.getRight()) {</span><span class="s3">\n    </span><span class="s1">/* Case x.1:</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">* rectA</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|                       |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        _________      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        |       |      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|________|_______|______|</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t\t\t </span><span class="s1">|       |</span><span class="s3">\n    </span><span class="s1">*           |       |</span><span class="s3">\n    </span><span class="s1">*        rectB</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());</span><span class="s3">\n  </span><span class="s1">} else if (rectB.getX() &lt;= rectA.getX() &amp;&amp; rectB.getRight() &gt;= rectA.getRight()) {</span><span class="s3">\n    </span><span class="s1">/* Case x.2:</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">* rectB</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|                       |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        _________      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        |       |      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|________|_______|______|</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t\t\t </span><span class="s1">|       |</span><span class="s3">\n    </span><span class="s1">*           |       |</span><span class="s3">\n    </span><span class="s1">*        rectA</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rectA.getY() &lt;= rectB.getY() &amp;&amp; rectA.getBottom() &gt;= rectB.getBottom()) {</span><span class="s3">\n    </span><span class="s1">/* Case y.1:</span><span class="s3">\n     </span><span class="s1">*          ________ rectA</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*   ______|____  rectB</span><span class="s3">\n     </span><span class="s1">*         |    |</span><span class="s3">\n     </span><span class="s1">*         |    |</span><span class="s3">\n     </span><span class="s1">*   ______|____|</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |________</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());</span><span class="s3">\n  </span><span class="s1">} else if (rectB.getY() &lt;= rectA.getY() &amp;&amp; rectB.getBottom() &gt;= rectA.getBottom()) {</span><span class="s3">\n    </span><span class="s1">/* Case y.2:</span><span class="s3">\n    </span><span class="s1">*          ________ rectB</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*   ______|____  rectA</span><span class="s3">\n    </span><span class="s1">*         |    |</span><span class="s3">\n    </span><span class="s1">*         |    |</span><span class="s3">\n    </span><span class="s1">*   ______|____|</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |________</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// find slope of the line passes two centers</span><span class="s3">\n  </span><span class="s1">var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));</span><span class="s3">\n  </span><span class="s1">// if centers are overlapped</span><span class="s3">\n  </span><span class="s1">if (rectB.getCenterY() === rectA.getCenterY() &amp;&amp; rectB.getCenterX() === rectA.getCenterX()) {</span><span class="s3">\n    </span><span class="s1">// assume the slope is 1 (45 degree)</span><span class="s3">\n    </span><span class="s1">slope = 1.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var moveByY = slope * overlapAmount[0];</span><span class="s3">\n  </span><span class="s1">var moveByX = overlapAmount[1] / slope;</span><span class="s3">\n  </span><span class="s1">if (overlapAmount[0] &lt; moveByX) {</span><span class="s3">\n    </span><span class="s1">moveByX = overlapAmount[0];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">moveByY = overlapAmount[1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// return half the amount so that if each rectangle is moved by these</span><span class="s3">\n  </span><span class="s1">// amounts in opposite directions, overlap will be resolved</span><span class="s3">\n  </span><span class="s1">overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);</span><span class="s3">\n  </span><span class="s1">overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method decides the separation direction of overlapping nodes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* if directions[0] = -1, then rectA goes left</span><span class="s3">\n </span><span class="s1">* if directions[0] = 1,  then rectA goes right</span><span class="s3">\n </span><span class="s1">* if directions[1] = -1, then rectA goes up</span><span class="s3">\n </span><span class="s1">* if directions[1] = 1,  then rectA goes down</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {</span><span class="s3">\n  </span><span class="s1">if (rectA.getCenterX() &lt; rectB.getCenterX()) {</span><span class="s3">\n    </span><span class="s1">directions[0] = -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">directions[0] = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (rectA.getCenterY() &lt; rectB.getCenterY()) {</span><span class="s3">\n    </span><span class="s1">directions[1] = -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">directions[1] = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates the intersection (clipping) points of the two</span><span class="s3">\n </span><span class="s1">* input rectangles with line segment defined by the centers of these two</span><span class="s3">\n </span><span class="s1">* rectangles. The clipping points are saved in the input double array and</span><span class="s3">\n </span><span class="s1">* whether or not the two rectangles overlap is returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getIntersection2 = function (rectA, rectB, result) {</span><span class="s3">\n  </span><span class="s1">//result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB</span><span class="s3">\n  </span><span class="s1">var p1x = rectA.getCenterX();</span><span class="s3">\n  </span><span class="s1">var p1y = rectA.getCenterY();</span><span class="s3">\n  </span><span class="s1">var p2x = rectB.getCenterX();</span><span class="s3">\n  </span><span class="s1">var p2y = rectB.getCenterY();</span><span class="s3">\n\n  </span><span class="s1">//if two rectangles intersect, then clipping points are centers</span><span class="s3">\n  </span><span class="s1">if (rectA.intersects(rectB)) {</span><span class="s3">\n    </span><span class="s1">result[0] = p1x;</span><span class="s3">\n    </span><span class="s1">result[1] = p1y;</span><span class="s3">\n    </span><span class="s1">result[2] = p2x;</span><span class="s3">\n    </span><span class="s1">result[3] = p2y;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//variables for rectA</span><span class="s3">\n  </span><span class="s1">var topLeftAx = rectA.getX();</span><span class="s3">\n  </span><span class="s1">var topLeftAy = rectA.getY();</span><span class="s3">\n  </span><span class="s1">var topRightAx = rectA.getRight();</span><span class="s3">\n  </span><span class="s1">var bottomLeftAx = rectA.getX();</span><span class="s3">\n  </span><span class="s1">var bottomLeftAy = rectA.getBottom();</span><span class="s3">\n  </span><span class="s1">var bottomRightAx = rectA.getRight();</span><span class="s3">\n  </span><span class="s1">var halfWidthA = rectA.getWidthHalf();</span><span class="s3">\n  </span><span class="s1">var halfHeightA = rectA.getHeightHalf();</span><span class="s3">\n  </span><span class="s1">//variables for rectB</span><span class="s3">\n  </span><span class="s1">var topLeftBx = rectB.getX();</span><span class="s3">\n  </span><span class="s1">var topLeftBy = rectB.getY();</span><span class="s3">\n  </span><span class="s1">var topRightBx = rectB.getRight();</span><span class="s3">\n  </span><span class="s1">var bottomLeftBx = rectB.getX();</span><span class="s3">\n  </span><span class="s1">var bottomLeftBy = rectB.getBottom();</span><span class="s3">\n  </span><span class="s1">var bottomRightBx = rectB.getRight();</span><span class="s3">\n  </span><span class="s1">var halfWidthB = rectB.getWidthHalf();</span><span class="s3">\n  </span><span class="s1">var halfHeightB = rectB.getHeightHalf();</span><span class="s3">\n\n  </span><span class="s1">//flag whether clipping points are found</span><span class="s3">\n  </span><span class="s1">var clipPointAFound = false;</span><span class="s3">\n  </span><span class="s1">var clipPointBFound = false;</span><span class="s3">\n\n  </span><span class="s1">// line is vertical</span><span class="s3">\n  </span><span class="s1">if (p1x === p2x) {</span><span class="s3">\n    </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n      </span><span class="s1">result[0] = p1x;</span><span class="s3">\n      </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n      </span><span class="s1">result[2] = p2x;</span><span class="s3">\n      </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else if (p1y &lt; p2y) {</span><span class="s3">\n      </span><span class="s1">result[0] = p1x;</span><span class="s3">\n      </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n      </span><span class="s1">result[2] = p2x;</span><span class="s3">\n      </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">//not line, return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// line is horizontal</span><span class="s3">\n  </span><span class="s1">else if (p1y === p2y) {</span><span class="s3">\n      </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n        </span><span class="s1">result[0] = topLeftAx;</span><span class="s3">\n        </span><span class="s1">result[1] = p1y;</span><span class="s3">\n        </span><span class="s1">result[2] = topRightBx;</span><span class="s3">\n        </span><span class="s1">result[3] = p2y;</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} else if (p1x &lt; p2x) {</span><span class="s3">\n        </span><span class="s1">result[0] = topRightAx;</span><span class="s3">\n        </span><span class="s1">result[1] = p1y;</span><span class="s3">\n        </span><span class="s1">result[2] = topLeftBx;</span><span class="s3">\n        </span><span class="s1">result[3] = p2y;</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">//not valid line, return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">//slopes of rectA's and rectB's diagonals</span><span class="s3">\n      </span><span class="s1">var slopeA = rectA.height / rectA.width;</span><span class="s3">\n      </span><span class="s1">var slopeB = rectB.height / rectB.width;</span><span class="s3">\n\n      </span><span class="s1">//slope of line between center of rectA and center of rectB</span><span class="s3">\n      </span><span class="s1">var slopePrime = (p2y - p1y) / (p2x - p1x);</span><span class="s3">\n      </span><span class="s1">var cardinalDirectionA = void 0;</span><span class="s3">\n      </span><span class="s1">var cardinalDirectionB = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointAx = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointAy = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointBx = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointBy = void 0;</span><span class="s3">\n\n      </span><span class="s1">//determine whether clipping point is the corner of nodeA</span><span class="s3">\n      </span><span class="s1">if (-slopeA === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n          </span><span class="s1">result[0] = bottomLeftAx;</span><span class="s3">\n          </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[0] = topRightAx;</span><span class="s3">\n          </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (slopeA === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n          </span><span class="s1">result[0] = topLeftAx;</span><span class="s3">\n          </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[0] = bottomRightAx;</span><span class="s3">\n          </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//determine whether clipping point is the corner of nodeB</span><span class="s3">\n      </span><span class="s1">if (-slopeB === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p2x &gt; p1x) {</span><span class="s3">\n          </span><span class="s1">result[2] = bottomLeftBx;</span><span class="s3">\n          </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[2] = topRightBx;</span><span class="s3">\n          </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (slopeB === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p2x &gt; p1x) {</span><span class="s3">\n          </span><span class="s1">result[2] = topLeftBx;</span><span class="s3">\n          </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[2] = bottomRightBx;</span><span class="s3">\n          </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//if both clipping points are corners</span><span class="s3">\n      </span><span class="s1">if (clipPointAFound &amp;&amp; clipPointBFound) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//determine Cardinal Direction of rectangles</span><span class="s3">\n      </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n        </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">//calculate clipping Point if it is not found before</span><span class="s3">\n      </span><span class="s1">if (!clipPointAFound) {</span><span class="s3">\n        </span><span class="s1">switch (cardinalDirectionA) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">tempPointAy = topLeftAy;</span><span class="s3">\n            </span><span class="s1">tempPointAx = p1x + -halfHeightA / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">tempPointAx = bottomRightAx;</span><span class="s3">\n            </span><span class="s1">tempPointAy = p1y + halfWidthA * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">tempPointAy = bottomLeftAy;</span><span class="s3">\n            </span><span class="s1">tempPointAx = p1x + halfHeightA / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">tempPointAx = bottomLeftAx;</span><span class="s3">\n            </span><span class="s1">tempPointAy = p1y + -halfWidthA * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!clipPointBFound) {</span><span class="s3">\n        </span><span class="s1">switch (cardinalDirectionB) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">tempPointBy = topLeftBy;</span><span class="s3">\n            </span><span class="s1">tempPointBx = p2x + -halfHeightB / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">tempPointBx = bottomRightBx;</span><span class="s3">\n            </span><span class="s1">tempPointBy = p2y + halfWidthB * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">tempPointBy = bottomLeftBy;</span><span class="s3">\n            </span><span class="s1">tempPointBx = p2x + halfHeightB / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">tempPointBx = bottomLeftBx;</span><span class="s3">\n            </span><span class="s1">tempPointBy = p2y + -halfWidthB * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns in which cardinal direction does input point stays</span><span class="s3">\n </span><span class="s1">* 1: North</span><span class="s3">\n </span><span class="s1">* 2: East</span><span class="s3">\n </span><span class="s1">* 3: South</span><span class="s3">\n </span><span class="s1">* 4: West</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getCardinalDirection = function (slope, slopePrime, line) {</span><span class="s3">\n  </span><span class="s1">if (slope &gt; slopePrime) {</span><span class="s3">\n    </span><span class="s1">return line;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 1 + line % 4;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates the intersection of the two lines defined by</span><span class="s3">\n </span><span class="s1">* point pairs (s1,s2) and (f1,f2).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getIntersection = function (s1, s2, f1, f2) {</span><span class="s3">\n  </span><span class="s1">if (f2 == null) {</span><span class="s3">\n    </span><span class="s1">return this.getIntersection2(s1, s2, f1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var x1 = s1.x;</span><span class="s3">\n  </span><span class="s1">var y1 = s1.y;</span><span class="s3">\n  </span><span class="s1">var x2 = s2.x;</span><span class="s3">\n  </span><span class="s1">var y2 = s2.y;</span><span class="s3">\n  </span><span class="s1">var x3 = f1.x;</span><span class="s3">\n  </span><span class="s1">var y3 = f1.y;</span><span class="s3">\n  </span><span class="s1">var x4 = f2.x;</span><span class="s3">\n  </span><span class="s1">var y4 = f2.y;</span><span class="s3">\n  </span><span class="s1">var x = void 0,</span><span class="s3">\n      </span><span class="s1">y = void 0; // intersection point</span><span class="s3">\n  </span><span class="s1">var a1 = void 0,</span><span class="s3">\n      </span><span class="s1">a2 = void 0,</span><span class="s3">\n      </span><span class="s1">b1 = void 0,</span><span class="s3">\n      </span><span class="s1">b2 = void 0,</span><span class="s3">\n      </span><span class="s1">c1 = void 0,</span><span class="s3">\n      </span><span class="s1">c2 = void 0; // coefficients of line eqns.</span><span class="s3">\n  </span><span class="s1">var denom = void 0;</span><span class="s3">\n\n  </span><span class="s1">a1 = y2 - y1;</span><span class="s3">\n  </span><span class="s1">b1 = x1 - x2;</span><span class="s3">\n  </span><span class="s1">c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }</span><span class="s3">\n\n  </span><span class="s1">a2 = y4 - y3;</span><span class="s3">\n  </span><span class="s1">b2 = x3 - x4;</span><span class="s3">\n  </span><span class="s1">c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }</span><span class="s3">\n\n  </span><span class="s1">denom = a1 * b2 - a2 * b1;</span><span class="s3">\n\n  </span><span class="s1">if (denom === 0) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">x = (b1 * c2 - b2 * c1) / denom;</span><span class="s3">\n  </span><span class="s1">y = (a2 * c1 - a1 * c2) / denom;</span><span class="s3">\n\n  </span><span class="s1">return new Point(x, y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method finds and returns the angle of the vector from the + x-axis</span><span class="s3">\n </span><span class="s1">* in clockwise direction (compatible w/ Java coordinate system!).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {</span><span class="s3">\n  </span><span class="s1">var C_angle = void 0;</span><span class="s3">\n\n  </span><span class="s1">if (Cx !== Nx) {</span><span class="s3">\n    </span><span class="s1">C_angle = Math.atan((Ny - Cy) / (Nx - Cx));</span><span class="s3">\n\n    </span><span class="s1">if (Nx &lt; Cx) {</span><span class="s3">\n      </span><span class="s1">C_angle += Math.PI;</span><span class="s3">\n    </span><span class="s1">} else if (Ny &lt; Cy) {</span><span class="s3">\n      </span><span class="s1">C_angle += this.TWO_PI;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (Ny &lt; Cy) {</span><span class="s3">\n    </span><span class="s1">C_angle = this.ONE_AND_HALF_PI; // 270 degrees</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">C_angle = this.HALF_PI; // 90 degrees</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return C_angle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method checks whether the given two line segments (one with point</span><span class="s3">\n </span><span class="s1">* p1 and p2, the other with point p3 and p4) intersect at a point other</span><span class="s3">\n </span><span class="s1">* than these points.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.doIntersect = function (p1, p2, p3, p4) {</span><span class="s3">\n  </span><span class="s1">var a = p1.x;</span><span class="s3">\n  </span><span class="s1">var b = p1.y;</span><span class="s3">\n  </span><span class="s1">var c = p2.x;</span><span class="s3">\n  </span><span class="s1">var d = p2.y;</span><span class="s3">\n  </span><span class="s1">var p = p3.x;</span><span class="s3">\n  </span><span class="s1">var q = p3.y;</span><span class="s3">\n  </span><span class="s1">var r = p4.x;</span><span class="s3">\n  </span><span class="s1">var s = p4.y;</span><span class="s3">\n  </span><span class="s1">var det = (c - a) * (s - q) - (r - p) * (d - b);</span><span class="s3">\n\n  </span><span class="s1">if (det === 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;</span><span class="s3">\n    </span><span class="s1">var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;</span><span class="s3">\n    </span><span class="s1">return 0 &lt; lambda &amp;&amp; lambda &lt; 1 &amp;&amp; 0 &lt; gamma &amp;&amp; gamma &lt; 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: Class Constants</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Some useful pre-calculated constants</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.HALF_PI = 0.5 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.TWO_PI = 2.0 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.THREE_PI = 3.0 * Math.PI;</span><span class="s3">\n\n</span><span class="s1">module.exports = IGeometry;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 9 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function IMath() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns the sign of the input value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IMath.sign = function (value) {</span><span class="s3">\n  </span><span class="s1">if (value &gt; 0) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else if (value &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">IMath.floor = function (value) {</span><span class="s3">\n  </span><span class="s1">return value &lt; 0 ? Math.ceil(value) : Math.floor(value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">IMath.ceil = function (value) {</span><span class="s3">\n  </span><span class="s1">return value &lt; 0 ? Math.floor(value) : Math.ceil(value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = IMath;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 10 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function Integer() {}</span><span class="s3">\n\n</span><span class="s1">Integer.MAX_VALUE = 2147483647;</span><span class="s3">\n</span><span class="s1">Integer.MIN_VALUE = -2147483648;</span><span class="s3">\n\n</span><span class="s1">module.exports = Integer;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 11 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">var nodeFrom = function nodeFrom(value) {</span><span class="s3">\n  </span><span class="s1">return { value: value, next: null, prev: null };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var add = function add(prev, node, next, list) {</span><span class="s3">\n  </span><span class="s1">if (prev !== null) {</span><span class="s3">\n    </span><span class="s1">prev.next = node;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.head = node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (next !== null) {</span><span class="s3">\n    </span><span class="s1">next.prev = node;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.tail = node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">node.prev = prev;</span><span class="s3">\n  </span><span class="s1">node.next = next;</span><span class="s3">\n\n  </span><span class="s1">list.length++;</span><span class="s3">\n\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var _remove = function _remove(node, list) {</span><span class="s3">\n  </span><span class="s1">var prev = node.prev,</span><span class="s3">\n      </span><span class="s1">next = node.next;</span><span class="s3">\n\n\n  </span><span class="s1">if (prev !== null) {</span><span class="s3">\n    </span><span class="s1">prev.next = next;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.head = next;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (next !== null) {</span><span class="s3">\n    </span><span class="s1">next.prev = prev;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.tail = prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">node.prev = node.next = null;</span><span class="s3">\n\n  </span><span class="s1">list.length--;</span><span class="s3">\n\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var LinkedList = function () {</span><span class="s3">\n  </span><span class="s1">function LinkedList(vals) {</span><span class="s3">\n    </span><span class="s1">var _this = this;</span><span class="s3">\n\n    </span><span class="s1">_classCallCheck(this, LinkedList);</span><span class="s3">\n\n    </span><span class="s1">this.length = 0;</span><span class="s3">\n    </span><span class="s1">this.head = null;</span><span class="s3">\n    </span><span class="s1">this.tail = null;</span><span class="s3">\n\n    </span><span class="s1">if (vals != null) {</span><span class="s3">\n      </span><span class="s1">vals.forEach(function (v) {</span><span class="s3">\n        </span><span class="s1">return _this.push(v);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_createClass(LinkedList, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function size() {</span><span class="s3">\n      </span><span class="s1">return this.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertBefore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertBefore(val, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode.prev, nodeFrom(val), otherNode, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertAfter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertAfter(val, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode, nodeFrom(val), otherNode.next, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertNodeBefore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertNodeBefore(newNode, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode.prev, newNode, otherNode, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertNodeAfter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertNodeAfter(newNode, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode, newNode, otherNode.next, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">push</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function push(val) {</span><span class="s3">\n      </span><span class="s1">return add(this.tail, nodeFrom(val), null, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">unshift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function unshift(val) {</span><span class="s3">\n      </span><span class="s1">return add(null, nodeFrom(val), this.head, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">remove</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function remove(node) {</span><span class="s3">\n      </span><span class="s1">return _remove(node, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">pop</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function pop() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.tail, this).value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">popNode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function popNode() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.tail, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">shift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function shift() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.head, this).value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">shiftNode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function shiftNode() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.head, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">get_object_at</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function get_object_at(index) {</span><span class="s3">\n      </span><span class="s1">if (index &lt;= this.length()) {</span><span class="s3">\n        </span><span class="s1">var i = 1;</span><span class="s3">\n        </span><span class="s1">var current = this.head;</span><span class="s3">\n        </span><span class="s1">while (i &lt; index) {</span><span class="s3">\n          </span><span class="s1">current = current.next;</span><span class="s3">\n          </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return current.value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">set_object_at</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function set_object_at(index, value) {</span><span class="s3">\n      </span><span class="s1">if (index &lt;= this.length()) {</span><span class="s3">\n        </span><span class="s1">var i = 1;</span><span class="s3">\n        </span><span class="s1">var current = this.head;</span><span class="s3">\n        </span><span class="s1">while (i &lt; index) {</span><span class="s3">\n          </span><span class="s1">current = current.next;</span><span class="s3">\n          </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">current.value = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n\n  </span><span class="s1">return LinkedList;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = LinkedList;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 12 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">*This class is the javascript implementation of the Point.java class in jdk</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Point(x, y, p) {</span><span class="s3">\n  </span><span class="s1">this.x = null;</span><span class="s3">\n  </span><span class="s1">this.y = null;</span><span class="s3">\n  </span><span class="s1">if (x == null &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">this.x = 0;</span><span class="s3">\n    </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">} else if (typeof x == 'number' &amp;&amp; typeof y == 'number' &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n  </span><span class="s1">} else if (x.constructor.name == 'Point' &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">p = x;</span><span class="s3">\n    </span><span class="s1">this.x = p.x;</span><span class="s3">\n    </span><span class="s1">this.y = p.y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getLocation = function () {</span><span class="s3">\n  </span><span class="s1">return new Point(this.x, this.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.setLocation = function (x, y, p) {</span><span class="s3">\n  </span><span class="s1">if (x.constructor.name == 'Point' &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">p = x;</span><span class="s3">\n    </span><span class="s1">this.setLocation(p.x, p.y);</span><span class="s3">\n  </span><span class="s1">} else if (typeof x == 'number' &amp;&amp; typeof y == 'number' &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">//if both parameters are integer just move (x,y) location</span><span class="s3">\n    </span><span class="s1">if (parseInt(x) == x &amp;&amp; parseInt(y) == y) {</span><span class="s3">\n      </span><span class="s1">this.move(x, y);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.x = Math.floor(x + 0.5);</span><span class="s3">\n      </span><span class="s1">this.y = Math.floor(y + 0.5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.move = function (x, y) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.translate = function (dx, dy) {</span><span class="s3">\n  </span><span class="s1">this.x += dx;</span><span class="s3">\n  </span><span class="s1">this.y += dy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.equals = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (obj.constructor.name == </span><span class="s3">\&quot;</span><span class="s1">Point</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">var pt = obj;</span><span class="s3">\n    </span><span class="s1">return this.x == pt.x &amp;&amp; this.y == pt.y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this == obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.toString = function () {</span><span class="s3">\n  </span><span class="s1">return new Point().constructor.name + </span><span class="s3">\&quot;</span><span class="s1">[x=</span><span class="s3">\&quot; </span><span class="s1">+ this.x + </span><span class="s3">\&quot;</span><span class="s1">,y=</span><span class="s3">\&quot; </span><span class="s1">+ this.y + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Point;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 13 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function RectangleD(x, y, width, height) {</span><span class="s3">\n  </span><span class="s1">this.x = 0;</span><span class="s3">\n  </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">this.width = 0;</span><span class="s3">\n  </span><span class="s1">this.height = 0;</span><span class="s3">\n\n  </span><span class="s1">if (x != null &amp;&amp; y != null &amp;&amp; width != null &amp;&amp; height != null) {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n    </span><span class="s1">this.width = width;</span><span class="s3">\n    </span><span class="s1">this.height = height;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setX = function (x) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setY = function (y) {</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.x + this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.y + this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.intersects = function (a) {</span><span class="s3">\n  </span><span class="s1">if (this.getRight() &lt; a.x) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.getBottom() &lt; a.y) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (a.getRight() &lt; this.x) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (a.getBottom() &lt; this.y) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getCenterX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x + this.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMinX = function () {</span><span class="s3">\n  </span><span class="s1">return this.getX();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMaxX = function () {</span><span class="s3">\n  </span><span class="s1">return this.getX() + this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getCenterY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y + this.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMinY = function () {</span><span class="s3">\n  </span><span class="s1">return this.getY();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMaxY = function () {</span><span class="s3">\n  </span><span class="s1">return this.getY() + this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getWidthHalf = function () {</span><span class="s3">\n  </span><span class="s1">return this.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getHeightHalf = function () {</span><span class="s3">\n  </span><span class="s1">return this.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = RectangleD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 14 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _typeof = typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; typeof Symbol.iterator === </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">: typeof obj; };</span><span class="s3">\n\n</span><span class="s1">function UniqueIDGeneretor() {}</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.lastID = 0;</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.createID = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (UniqueIDGeneretor.isPrimitive(obj)) {</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (obj.uniqueID != null) {</span><span class="s3">\n    </span><span class="s1">return obj.uniqueID;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">obj.uniqueID = UniqueIDGeneretor.getString();</span><span class="s3">\n  </span><span class="s1">UniqueIDGeneretor.lastID++;</span><span class="s3">\n  </span><span class="s1">return obj.uniqueID;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.getString = function (id) {</span><span class="s3">\n  </span><span class="s1">if (id == null) id = UniqueIDGeneretor.lastID;</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">Object#</span><span class="s3">\&quot; </span><span class="s1">+ id + </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.isPrimitive = function (arg) {</span><span class="s3">\n  </span><span class="s1">var type = typeof arg === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(arg);</span><span class="s3">\n  </span><span class="s1">return arg == null || type != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; type != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = UniqueIDGeneretor;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 15 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }</span><span class="s3">\n\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var LGraphManager = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var LGraph = __webpack_require__(5);</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">var Transform = __webpack_require__(17);</span><span class="s3">\n</span><span class="s1">var Emitter = __webpack_require__(27);</span><span class="s3">\n\n</span><span class="s1">function Layout(isRemoteUse) {</span><span class="s3">\n  </span><span class="s1">Emitter.call(this);</span><span class="s3">\n\n  </span><span class="s1">//Layout Quality: 0:draft, 1:default, 2:proof</span><span class="s3">\n  </span><span class="s1">this.layoutQuality = LayoutConstants.QUALITY;</span><span class="s3">\n  </span><span class="s1">//Whether layout should create bendpoints as needed or not</span><span class="s3">\n  </span><span class="s1">this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n  </span><span class="s1">//Whether layout should be incremental or not</span><span class="s3">\n  </span><span class="s1">this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">//Whether we animate from before to after layout node positions</span><span class="s3">\n  </span><span class="s1">this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;</span><span class="s3">\n  </span><span class="s1">//Whether we animate the layout process or not</span><span class="s3">\n  </span><span class="s1">this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;</span><span class="s3">\n  </span><span class="s1">//Number iterations that should be done between two successive animations</span><span class="s3">\n  </span><span class="s1">this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\r\n   </span><span class="s1">* Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When</span><span class="s3">\r\n   </span><span class="s1">* they are, both spring and repulsion forces between two leaf nodes can be</span><span class="s3">\r\n   </span><span class="s1">* calculated without the expensive clipping point calculations, resulting</span><span class="s3">\r\n   </span><span class="s1">* in major speed-up.</span><span class="s3">\r\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\r\n   </span><span class="s1">* This is used for creation of bendpoints by using dummy nodes and edges.</span><span class="s3">\r\n   </span><span class="s1">* Maps an LEdge to its dummy bendpoint path.</span><span class="s3">\r\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">this.edgeToDummyNodes = new Map();</span><span class="s3">\n  </span><span class="s1">this.graphManager = new LGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.isLayoutFinished = false;</span><span class="s3">\n  </span><span class="s1">this.isSubLayout = false;</span><span class="s3">\n  </span><span class="s1">this.isRemoteUse = false;</span><span class="s3">\n\n  </span><span class="s1">if (isRemoteUse != null) {</span><span class="s3">\n    </span><span class="s1">this.isRemoteUse = isRemoteUse;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Layout.RANDOM_SEED = 1;</span><span class="s3">\n\n</span><span class="s1">Layout.prototype = Object.create(Emitter.prototype);</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllNodes();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllEdges();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllNodesToApplyGravitation();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">var gm = new LGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n  </span><span class="s1">return gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newGraph = function (vGraph) {</span><span class="s3">\n  </span><span class="s1">return new LGraph(null, this.graphManager, vGraph);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newNode = function (vNode) {</span><span class="s3">\n  </span><span class="s1">return new LNode(this.graphManager, vNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newEdge = function (vEdge) {</span><span class="s3">\n  </span><span class="s1">return new LEdge(null, null, vEdge);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.checkLayoutSuccess = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.runLayout = function () {</span><span class="s3">\n  </span><span class="s1">this.isLayoutFinished = false;</span><span class="s3">\n\n  </span><span class="s1">if (this.tilingPreLayout) {</span><span class="s3">\n    </span><span class="s1">this.tilingPreLayout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.initParameters();</span><span class="s3">\n  </span><span class="s1">var isLayoutSuccessfull;</span><span class="s3">\n\n  </span><span class="s1">if (this.checkLayoutSuccess()) {</span><span class="s3">\n    </span><span class="s1">isLayoutSuccessfull = false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">isLayoutSuccessfull = this.layout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (LayoutConstants.ANIMATE === 'during') {</span><span class="s3">\n    </span><span class="s1">// If this is a 'during' layout animation. Layout is not finished yet. </span><span class="s3">\n    </span><span class="s1">// We need to perform these in index.js when layout is really finished.</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isLayoutSuccessfull) {</span><span class="s3">\n    </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n      </span><span class="s1">this.doPostLayout();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.tilingPostLayout) {</span><span class="s3">\n    </span><span class="s1">this.tilingPostLayout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.isLayoutFinished = true;</span><span class="s3">\n\n  </span><span class="s1">return isLayoutSuccessfull;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method performs the operations required after layout.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.doPostLayout = function () {</span><span class="s3">\n  </span><span class="s1">//assert !isSubLayout : </span><span class="s3">\&quot;</span><span class="s1">Should not be called on sub-layout!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// Propagate geometric changes to v-level objects</span><span class="s3">\n  </span><span class="s1">if (!this.incremental) {</span><span class="s3">\n    </span><span class="s1">this.transform();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.update();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method updates the geometry of the target graph according to</span><span class="s3">\r\n </span><span class="s1">* calculated layout.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.update2 = function () {</span><span class="s3">\n  </span><span class="s1">// update bend points</span><span class="s3">\n  </span><span class="s1">if (this.createBendsAsNeeded) {</span><span class="s3">\n    </span><span class="s1">this.createBendpointsFromDummyNodes();</span><span class="s3">\n\n    </span><span class="s1">// reset all edges, since the topology has changed</span><span class="s3">\n    </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// perform edge, node and root updates if layout is not called</span><span class="s3">\n  </span><span class="s1">// remotely</span><span class="s3">\n  </span><span class="s1">if (!this.isRemoteUse) {</span><span class="s3">\n    </span><span class="s1">// update all edges</span><span class="s3">\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var allEdges = this.graphManager.getAllEdges();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; allEdges.length; i++) {</span><span class="s3">\n      </span><span class="s1">edge = allEdges[i];</span><span class="s3">\n      </span><span class="s1">//      this.update(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// recursively update nodes</span><span class="s3">\n    </span><span class="s1">var node;</span><span class="s3">\n    </span><span class="s1">var nodes = this.graphManager.getRoot().getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = nodes[i];</span><span class="s3">\n      </span><span class="s1">//      this.update(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// update root graph</span><span class="s3">\n    </span><span class="s1">this.update(this.graphManager.getRoot());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.update = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (obj == null) {</span><span class="s3">\n    </span><span class="s1">this.update2();</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LNode) {</span><span class="s3">\n    </span><span class="s1">var node = obj;</span><span class="s3">\n    </span><span class="s1">if (node.getChild() != null) {</span><span class="s3">\n      </span><span class="s1">// since node is compound, recursively update child nodes</span><span class="s3">\n      </span><span class="s1">var nodes = node.getChild().getNodes();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">update(nodes[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the l-level node is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level node implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n    </span><span class="s1">if (node.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vNode = node.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vNode.update(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">var edge = obj;</span><span class="s3">\n    </span><span class="s1">// if the l-level edge is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level edge implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n\n    </span><span class="s1">if (edge.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vEdge = edge.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vEdge.update(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LGraph) {</span><span class="s3">\n    </span><span class="s1">var graph = obj;</span><span class="s3">\n    </span><span class="s1">// if the l-level graph is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level object implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n\n    </span><span class="s1">if (graph.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vGraph = graph.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vGraph.update(graph);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method is used to set all layout parameters to default values</span><span class="s3">\r\n </span><span class="s1">* determined at compile time.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">this.layoutQuality = LayoutConstants.QUALITY;</span><span class="s3">\n    </span><span class="s1">this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;</span><span class="s3">\n    </span><span class="s1">this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;</span><span class="s3">\n    </span><span class="s1">this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;</span><span class="s3">\n    </span><span class="s1">this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;</span><span class="s3">\n    </span><span class="s1">this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n    </span><span class="s1">this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.animationDuringLayout) {</span><span class="s3">\n    </span><span class="s1">this.animationOnLayout = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.transform = function (newLeftTop) {</span><span class="s3">\n  </span><span class="s1">if (newLeftTop == undefined) {</span><span class="s3">\n    </span><span class="s1">this.transform(new PointD(0, 0));</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// create a transformation object (from Eclipse to layout). When an</span><span class="s3">\n    </span><span class="s1">// inverse transform is applied, we get upper-left coordinate of the</span><span class="s3">\n    </span><span class="s1">// drawing or the root graph at given input coordinate (some margins</span><span class="s3">\n    </span><span class="s1">// already included in calculation of left-top).</span><span class="s3">\n\n    </span><span class="s1">var trans = new Transform();</span><span class="s3">\n    </span><span class="s1">var leftTop = this.graphManager.getRoot().updateLeftTop();</span><span class="s3">\n\n    </span><span class="s1">if (leftTop != null) {</span><span class="s3">\n      </span><span class="s1">trans.setWorldOrgX(newLeftTop.x);</span><span class="s3">\n      </span><span class="s1">trans.setWorldOrgY(newLeftTop.y);</span><span class="s3">\n\n      </span><span class="s1">trans.setDeviceOrgX(leftTop.x);</span><span class="s3">\n      </span><span class="s1">trans.setDeviceOrgY(leftTop.y);</span><span class="s3">\n\n      </span><span class="s1">var nodes = this.getAllNodes();</span><span class="s3">\n      </span><span class="s1">var node;</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">node = nodes[i];</span><span class="s3">\n        </span><span class="s1">node.transform(trans);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.positionNodesRandomly = function (graph) {</span><span class="s3">\n\n  </span><span class="s1">if (graph == undefined) {</span><span class="s3">\n    </span><span class="s1">//assert !this.incremental;</span><span class="s3">\n    </span><span class="s1">this.positionNodesRandomly(this.getGraphManager().getRoot());</span><span class="s3">\n    </span><span class="s1">this.getGraphManager().getRoot().updateBounds(true);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lNode;</span><span class="s3">\n    </span><span class="s1">var childGraph;</span><span class="s3">\n\n    </span><span class="s1">var nodes = graph.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">lNode = nodes[i];</span><span class="s3">\n      </span><span class="s1">childGraph = lNode.getChild();</span><span class="s3">\n\n      </span><span class="s1">if (childGraph == null) {</span><span class="s3">\n        </span><span class="s1">lNode.scatter();</span><span class="s3">\n      </span><span class="s1">} else if (childGraph.getNodes().length == 0) {</span><span class="s3">\n        </span><span class="s1">lNode.scatter();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.positionNodesRandomly(childGraph);</span><span class="s3">\n        </span><span class="s1">lNode.updateBounds();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method returns a list of trees where each tree is represented as a</span><span class="s3">\r\n </span><span class="s1">* list of l-nodes. The method returns a list of size 0 when:</span><span class="s3">\r\n </span><span class="s1">* - The graph is not flat or</span><span class="s3">\r\n </span><span class="s1">* - One of the component(s) of the graph is not a tree.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.getFlatForest = function () {</span><span class="s3">\n  </span><span class="s1">var flatForest = [];</span><span class="s3">\n  </span><span class="s1">var isForest = true;</span><span class="s3">\n\n  </span><span class="s1">// Quick reference for all nodes in the graph manager associated with</span><span class="s3">\n  </span><span class="s1">// this layout. The list should not be changed.</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getRoot().getNodes();</span><span class="s3">\n\n  </span><span class="s1">// First be sure that the graph is flat</span><span class="s3">\n  </span><span class="s1">var isFlat = true;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (allNodes[i].getChild() != null) {</span><span class="s3">\n      </span><span class="s1">isFlat = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Return empty forest if the graph is not flat.</span><span class="s3">\n  </span><span class="s1">if (!isFlat) {</span><span class="s3">\n    </span><span class="s1">return flatForest;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Run BFS for each component of the graph.</span><span class="s3">\n\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var toBeVisited = [];</span><span class="s3">\n  </span><span class="s1">var parents = new Map();</span><span class="s3">\n  </span><span class="s1">var unProcessedNodes = [];</span><span class="s3">\n\n  </span><span class="s1">unProcessedNodes = unProcessedNodes.concat(allNodes);</span><span class="s3">\n\n  </span><span class="s1">// Each iteration of this loop finds a component of the graph and</span><span class="s3">\n  </span><span class="s1">// decides whether it is a tree or not. If it is a tree, adds it to the</span><span class="s3">\n  </span><span class="s1">// forest and continued with the next component.</span><span class="s3">\n\n  </span><span class="s1">while (unProcessedNodes.length &gt; 0 &amp;&amp; isForest) {</span><span class="s3">\n    </span><span class="s1">toBeVisited.push(unProcessedNodes[0]);</span><span class="s3">\n\n    </span><span class="s1">// Start the BFS. Each iteration of this loop visits a node in a</span><span class="s3">\n    </span><span class="s1">// BFS manner.</span><span class="s3">\n    </span><span class="s1">while (toBeVisited.length &gt; 0 &amp;&amp; isForest) {</span><span class="s3">\n      </span><span class="s1">//pool operation</span><span class="s3">\n      </span><span class="s1">var currentNode = toBeVisited[0];</span><span class="s3">\n      </span><span class="s1">toBeVisited.splice(0, 1);</span><span class="s3">\n      </span><span class="s1">visited.add(currentNode);</span><span class="s3">\n\n      </span><span class="s1">// Traverse all neighbors of this node</span><span class="s3">\n      </span><span class="s1">var neighborEdges = currentNode.getEdges();</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; neighborEdges.length; i++) {</span><span class="s3">\n        </span><span class="s1">var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);</span><span class="s3">\n\n        </span><span class="s1">// If BFS is not growing from this neighbor.</span><span class="s3">\n        </span><span class="s1">if (parents.get(currentNode) != currentNeighbor) {</span><span class="s3">\n          </span><span class="s1">// We haven't previously visited this neighbor.</span><span class="s3">\n          </span><span class="s1">if (!visited.has(currentNeighbor)) {</span><span class="s3">\n            </span><span class="s1">toBeVisited.push(currentNeighbor);</span><span class="s3">\n            </span><span class="s1">parents.set(currentNeighbor, currentNode);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Since we have previously visited this neighbor and</span><span class="s3">\n          </span><span class="s1">// this neighbor is not parent of currentNode, given</span><span class="s3">\n          </span><span class="s1">// graph contains a component that is not tree, hence</span><span class="s3">\n          </span><span class="s1">// it is not a forest.</span><span class="s3">\n          </span><span class="s1">else {</span><span class="s3">\n              </span><span class="s1">isForest = false;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The graph contains a component that is not a tree. Empty</span><span class="s3">\n    </span><span class="s1">// previously found trees. The method will end.</span><span class="s3">\n    </span><span class="s1">if (!isForest) {</span><span class="s3">\n      </span><span class="s1">flatForest = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Save currently visited nodes as a tree in our forest. Reset</span><span class="s3">\n    </span><span class="s1">// visited and parents lists. Continue with the next component of</span><span class="s3">\n    </span><span class="s1">// the graph, if any.</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">var temp = [].concat(_toConsumableArray(visited));</span><span class="s3">\n        </span><span class="s1">flatForest.push(temp);</span><span class="s3">\n        </span><span class="s1">//flatForest = flatForest.concat(temp);</span><span class="s3">\n        </span><span class="s1">//unProcessedNodes.removeAll(visited);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; temp.length; i++) {</span><span class="s3">\n          </span><span class="s1">var value = temp[i];</span><span class="s3">\n          </span><span class="s1">var index = unProcessedNodes.indexOf(value);</span><span class="s3">\n          </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n            </span><span class="s1">unProcessedNodes.splice(index, 1);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">visited = new Set();</span><span class="s3">\n        </span><span class="s1">parents = new Map();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return flatForest;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method creates dummy nodes (an l-level node with minimal dimensions)</span><span class="s3">\r\n </span><span class="s1">* for the given edge (one per bendpoint). The existing l-level structure</span><span class="s3">\r\n </span><span class="s1">* is updated accordingly.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.createDummyNodesForBendpoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">var dummyNodes = [];</span><span class="s3">\n  </span><span class="s1">var prev = edge.source;</span><span class="s3">\n\n  </span><span class="s1">var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; edge.bendpoints.length; i++) {</span><span class="s3">\n    </span><span class="s1">// create new dummy node</span><span class="s3">\n    </span><span class="s1">var dummyNode = this.newNode(null);</span><span class="s3">\n    </span><span class="s1">dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));</span><span class="s3">\n\n    </span><span class="s1">graph.add(dummyNode);</span><span class="s3">\n\n    </span><span class="s1">// create new dummy edge between prev and dummy node</span><span class="s3">\n    </span><span class="s1">var dummyEdge = this.newEdge(null);</span><span class="s3">\n    </span><span class="s1">this.graphManager.add(dummyEdge, prev, dummyNode);</span><span class="s3">\n\n    </span><span class="s1">dummyNodes.add(dummyNode);</span><span class="s3">\n    </span><span class="s1">prev = dummyNode;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var dummyEdge = this.newEdge(null);</span><span class="s3">\n  </span><span class="s1">this.graphManager.add(dummyEdge, prev, edge.target);</span><span class="s3">\n\n  </span><span class="s1">this.edgeToDummyNodes.set(edge, dummyNodes);</span><span class="s3">\n\n  </span><span class="s1">// remove real edge from graph manager if it is inter-graph</span><span class="s3">\n  </span><span class="s1">if (edge.isInterGraph()) {</span><span class="s3">\n    </span><span class="s1">this.graphManager.remove(edge);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// else, remove the edge from the current graph</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">graph.remove(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return dummyNodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method creates bendpoints for edges from the dummy nodes</span><span class="s3">\r\n </span><span class="s1">* at l-level.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.createBendpointsFromDummyNodes = function () {</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">edges = edges.concat(this.graphManager.getAllEdges());</span><span class="s3">\n  </span><span class="s1">edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);</span><span class="s3">\n\n  </span><span class="s1">for (var k = 0; k &lt; edges.length; k++) {</span><span class="s3">\n    </span><span class="s1">var lEdge = edges[k];</span><span class="s3">\n\n    </span><span class="s1">if (lEdge.bendpoints.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var path = this.edgeToDummyNodes.get(lEdge);</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; path.length; i++) {</span><span class="s3">\n        </span><span class="s1">var dummyNode = path[i];</span><span class="s3">\n        </span><span class="s1">var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());</span><span class="s3">\n\n        </span><span class="s1">// update bendpoint's location according to dummy node</span><span class="s3">\n        </span><span class="s1">var ebp = lEdge.bendpoints.get(i);</span><span class="s3">\n        </span><span class="s1">ebp.x = p.x;</span><span class="s3">\n        </span><span class="s1">ebp.y = p.y;</span><span class="s3">\n\n        </span><span class="s1">// remove the dummy node, dummy edges incident with this</span><span class="s3">\n        </span><span class="s1">// dummy node is also removed (within the remove method)</span><span class="s3">\n        </span><span class="s1">dummyNode.getOwner().remove(dummyNode);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// add the real edge to graph</span><span class="s3">\n      </span><span class="s1">this.graphManager.add(lEdge, lEdge.source, lEdge.target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {</span><span class="s3">\n  </span><span class="s1">if (minDiv != undefined &amp;&amp; maxMul != undefined) {</span><span class="s3">\n    </span><span class="s1">var value = defaultValue;</span><span class="s3">\n\n    </span><span class="s1">if (sliderValue &lt;= 50) {</span><span class="s3">\n      </span><span class="s1">var minValue = defaultValue / minDiv;</span><span class="s3">\n      </span><span class="s1">value -= (defaultValue - minValue) / 50 * (50 - sliderValue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var maxValue = defaultValue * maxMul;</span><span class="s3">\n      </span><span class="s1">value += (maxValue - defaultValue) / 50 * (sliderValue - 50);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var a, b;</span><span class="s3">\n\n    </span><span class="s1">if (sliderValue &lt;= 50) {</span><span class="s3">\n      </span><span class="s1">a = 9.0 * defaultValue / 500.0;</span><span class="s3">\n      </span><span class="s1">b = defaultValue / 10.0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">a = 9.0 * defaultValue / 50.0;</span><span class="s3">\n      </span><span class="s1">b = -8 * defaultValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return a * sliderValue + b;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method finds and returns the center of the given nodes, assuming</span><span class="s3">\r\n </span><span class="s1">* that the given nodes form a tree in themselves.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.findCenterOfTree = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var list = [];</span><span class="s3">\n  </span><span class="s1">list = list.concat(nodes);</span><span class="s3">\n\n  </span><span class="s1">var removedNodes = [];</span><span class="s3">\n  </span><span class="s1">var remainingDegrees = new Map();</span><span class="s3">\n  </span><span class="s1">var foundCenter = false;</span><span class="s3">\n  </span><span class="s1">var centerNode = null;</span><span class="s3">\n\n  </span><span class="s1">if (list.length == 1 || list.length == 2) {</span><span class="s3">\n    </span><span class="s1">foundCenter = true;</span><span class="s3">\n    </span><span class="s1">centerNode = list[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = list[i];</span><span class="s3">\n    </span><span class="s1">var degree = node.getNeighborsList().size;</span><span class="s3">\n    </span><span class="s1">remainingDegrees.set(node, node.getNeighborsList().size);</span><span class="s3">\n\n    </span><span class="s1">if (degree == 1) {</span><span class="s3">\n      </span><span class="s1">removedNodes.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var tempList = [];</span><span class="s3">\n  </span><span class="s1">tempList = tempList.concat(removedNodes);</span><span class="s3">\n\n  </span><span class="s1">while (!foundCenter) {</span><span class="s3">\n    </span><span class="s1">var tempList2 = [];</span><span class="s3">\n    </span><span class="s1">tempList2 = tempList2.concat(tempList);</span><span class="s3">\n    </span><span class="s1">tempList = [];</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s3">\n      </span><span class="s1">var node = list[i];</span><span class="s3">\n\n      </span><span class="s1">var index = list.indexOf(node);</span><span class="s3">\n      </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">list.splice(index, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var neighbours = node.getNeighborsList();</span><span class="s3">\n\n      </span><span class="s1">neighbours.forEach(function (neighbour) {</span><span class="s3">\n        </span><span class="s1">if (removedNodes.indexOf(neighbour) &lt; 0) {</span><span class="s3">\n          </span><span class="s1">var otherDegree = remainingDegrees.get(neighbour);</span><span class="s3">\n          </span><span class="s1">var newDegree = otherDegree - 1;</span><span class="s3">\n\n          </span><span class="s1">if (newDegree == 1) {</span><span class="s3">\n            </span><span class="s1">tempList.push(neighbour);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">remainingDegrees.set(neighbour, newDegree);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">removedNodes = removedNodes.concat(tempList);</span><span class="s3">\n\n    </span><span class="s1">if (list.length == 1 || list.length == 2) {</span><span class="s3">\n      </span><span class="s1">foundCenter = true;</span><span class="s3">\n      </span><span class="s1">centerNode = list[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return centerNode;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* During the coarsening process, this layout may be referenced by two graph managers</span><span class="s3">\r\n </span><span class="s1">* this setter function grants access to change the currently being used graph manager</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.setGraphManager = function (gm) {</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Layout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 16 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function RandomSeed() {}</span><span class="s3">\n</span><span class="s1">// adapted from: https://stackoverflow.com/a/19303725</span><span class="s3">\n</span><span class="s1">RandomSeed.seed = 1;</span><span class="s3">\n</span><span class="s1">RandomSeed.x = 0;</span><span class="s3">\n\n</span><span class="s1">RandomSeed.nextDouble = function () {</span><span class="s3">\n  </span><span class="s1">RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;</span><span class="s3">\n  </span><span class="s1">return RandomSeed.x - Math.floor(RandomSeed.x);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = RandomSeed;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 17 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var PointD = __webpack_require__(4);</span><span class="s3">\n\n</span><span class="s1">function Transform(x, y) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgX = 0.0;</span><span class="s3">\n  </span><span class="s1">this.lworldOrgY = 0.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgX = 0.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgY = 0.0;</span><span class="s3">\n  </span><span class="s1">this.lworldExtX = 1.0;</span><span class="s3">\n  </span><span class="s1">this.lworldExtY = 1.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtX = 1.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtY = 1.0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldOrgX = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldOrgX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldOrgX = function (wox) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgX = wox;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldOrgY = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldOrgY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldOrgY = function (woy) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgY = woy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldExtX = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldExtX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldExtX = function (wex) {</span><span class="s3">\n  </span><span class="s1">this.lworldExtX = wex;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldExtY = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldExtY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldExtY = function (wey) {</span><span class="s3">\n  </span><span class="s1">this.lworldExtY = wey;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* Device related */</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceOrgX = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceOrgX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceOrgX = function (dox) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgX = dox;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceOrgY = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceOrgY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceOrgY = function (doy) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgY = doy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceExtX = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceExtX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceExtX = function (dex) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtX = dex;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceExtY = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceExtY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceExtY = function (dey) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtY = dey;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.transformX = function (x) {</span><span class="s3">\n  </span><span class="s1">var xDevice = 0.0;</span><span class="s3">\n  </span><span class="s1">var worldExtX = this.lworldExtX;</span><span class="s3">\n  </span><span class="s1">if (worldExtX != 0.0) {</span><span class="s3">\n    </span><span class="s1">xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return xDevice;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.transformY = function (y) {</span><span class="s3">\n  </span><span class="s1">var yDevice = 0.0;</span><span class="s3">\n  </span><span class="s1">var worldExtY = this.lworldExtY;</span><span class="s3">\n  </span><span class="s1">if (worldExtY != 0.0) {</span><span class="s3">\n    </span><span class="s1">yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return yDevice;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformX = function (x) {</span><span class="s3">\n  </span><span class="s1">var xWorld = 0.0;</span><span class="s3">\n  </span><span class="s1">var deviceExtX = this.ldeviceExtX;</span><span class="s3">\n  </span><span class="s1">if (deviceExtX != 0.0) {</span><span class="s3">\n    </span><span class="s1">xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return xWorld;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformY = function (y) {</span><span class="s3">\n  </span><span class="s1">var yWorld = 0.0;</span><span class="s3">\n  </span><span class="s1">var deviceExtY = this.ldeviceExtY;</span><span class="s3">\n  </span><span class="s1">if (deviceExtY != 0.0) {</span><span class="s3">\n    </span><span class="s1">yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return yWorld;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformPoint = function (inPoint) {</span><span class="s3">\n  </span><span class="s1">var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));</span><span class="s3">\n  </span><span class="s1">return outPoint;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Transform;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 18 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }</span><span class="s3">\n\n</span><span class="s1">var Layout = __webpack_require__(15);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(7);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(9);</span><span class="s3">\n\n</span><span class="s1">function FDLayout() {</span><span class="s3">\n  </span><span class="s1">Layout.call(this);</span><span class="s3">\n\n  </span><span class="s1">this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;</span><span class="s3">\n  </span><span class="s1">this.idealEdgeLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n  </span><span class="s1">this.springConstant = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.repulsionConstant = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n  </span><span class="s1">this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n  </span><span class="s1">this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;</span><span class="s3">\n  </span><span class="s1">this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">this.totalDisplacement = 0.0;</span><span class="s3">\n  </span><span class="s1">this.oldTotalDisplacement = 0.0;</span><span class="s3">\n  </span><span class="s1">this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype = Object.create(Layout.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in Layout) {</span><span class="s3">\n  </span><span class="s1">FDLayout[prop] = Layout[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">Layout.prototype.initParameters.call(this, arguments);</span><span class="s3">\n\n  </span><span class="s1">this.totalIterations = 0;</span><span class="s3">\n  </span><span class="s1">this.notAnimatedIterations = 0;</span><span class="s3">\n\n  </span><span class="s1">this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;</span><span class="s3">\n\n  </span><span class="s1">this.grid = [];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcIdealEdgeLengths = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var lcaDepth;</span><span class="s3">\n  </span><span class="s1">var source;</span><span class="s3">\n  </span><span class="s1">var target;</span><span class="s3">\n  </span><span class="s1">var sizeOfSourceInLca;</span><span class="s3">\n  </span><span class="s1">var sizeOfTargetInLca;</span><span class="s3">\n\n  </span><span class="s1">var allEdges = this.getGraphManager().getAllEdges();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allEdges.length; i++) {</span><span class="s3">\n    </span><span class="s1">edge = allEdges[i];</span><span class="s3">\n\n    </span><span class="s1">edge.idealLength = this.idealEdgeLength;</span><span class="s3">\n\n    </span><span class="s1">if (edge.isInterGraph) {</span><span class="s3">\n      </span><span class="s1">source = edge.getSource();</span><span class="s3">\n      </span><span class="s1">target = edge.getTarget();</span><span class="s3">\n\n      </span><span class="s1">sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();</span><span class="s3">\n      </span><span class="s1">sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();</span><span class="s3">\n\n      </span><span class="s1">if (this.useSmartIdealEdgeLengthCalculation) {</span><span class="s3">\n        </span><span class="s1">edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">lcaDepth = edge.getLca().getInclusionTreeDepth();</span><span class="s3">\n\n      </span><span class="s1">edge.idealLength += FDLayoutConstants.DEFAULT_EDGE_LENGTH * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.initSpringEmbedder = function () {</span><span class="s3">\n\n  </span><span class="s1">var s = this.getAllNodes().length;</span><span class="s3">\n  </span><span class="s1">if (this.incremental) {</span><span class="s3">\n    </span><span class="s1">if (s &gt; FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (s &gt; FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = 1.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.initialCoolingFactor = this.coolingFactor;</span><span class="s3">\n    </span><span class="s1">this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);</span><span class="s3">\n\n  </span><span class="s1">this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;</span><span class="s3">\n\n  </span><span class="s1">this.repulsionRange = this.calcRepulsionRange();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcSpringForces = function () {</span><span class="s3">\n  </span><span class="s1">var lEdges = this.getAllEdges();</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lEdges.length; i++) {</span><span class="s3">\n    </span><span class="s1">edge = lEdges[i];</span><span class="s3">\n\n    </span><span class="s1">this.calcSpringForce(edge, edge.idealLength);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionForces = function () {</span><span class="s3">\n  </span><span class="s1">var gridUpdateAllowed = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;</span><span class="s3">\n  </span><span class="s1">var forceToNodeSurroundingUpdate = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;</span><span class="s3">\n\n  </span><span class="s1">var i, j;</span><span class="s3">\n  </span><span class="s1">var nodeA, nodeB;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var processedNodeSet;</span><span class="s3">\n\n  </span><span class="s1">if (this.useFRGridVariant) {</span><span class="s3">\n    </span><span class="s1">if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 &amp;&amp; gridUpdateAllowed) {</span><span class="s3">\n      </span><span class="s1">this.updateGrid();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">processedNodeSet = new Set();</span><span class="s3">\n\n    </span><span class="s1">// calculate repulsion forces between each nodes and its surrounding</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n      </span><span class="s1">this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);</span><span class="s3">\n      </span><span class="s1">processedNodeSet.add(nodeA);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n\n      </span><span class="s1">for (j = i + 1; j &lt; lNodes.length; j++) {</span><span class="s3">\n        </span><span class="s1">nodeB = lNodes[j];</span><span class="s3">\n\n        </span><span class="s1">// If both nodes are not members of the same graph, skip.</span><span class="s3">\n        </span><span class="s1">if (nodeA.getOwner() != nodeB.getOwner()) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">this.calcRepulsionForce(nodeA, nodeB);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGravitationalForces = function () {</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodesToApplyGravitation();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">this.calcGravitationalForce(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.moveNodes = function () {</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">node.move();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcSpringForce = function (edge, idealLength) {</span><span class="s3">\n  </span><span class="s1">var sourceNode = edge.getSource();</span><span class="s3">\n  </span><span class="s1">var targetNode = edge.getTarget();</span><span class="s3">\n\n  </span><span class="s1">var length;</span><span class="s3">\n  </span><span class="s1">var springForce;</span><span class="s3">\n  </span><span class="s1">var springForceX;</span><span class="s3">\n  </span><span class="s1">var springForceY;</span><span class="s3">\n\n  </span><span class="s1">// Update edge length</span><span class="s3">\n  </span><span class="s1">if (this.uniformLeafNodeSizes &amp;&amp; sourceNode.getChild() == null &amp;&amp; targetNode.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">edge.updateLengthSimple();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">edge.updateLength();</span><span class="s3">\n\n    </span><span class="s1">if (edge.isOverlapingSourceAndTarget) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">length = edge.getLength();</span><span class="s3">\n\n  </span><span class="s1">if (length == 0) return;</span><span class="s3">\n\n  </span><span class="s1">// Calculate spring forces</span><span class="s3">\n  </span><span class="s1">springForce = this.springConstant * (length - idealLength);</span><span class="s3">\n\n  </span><span class="s1">// Project force onto x and y axes</span><span class="s3">\n  </span><span class="s1">springForceX = springForce * (edge.lengthX / length);</span><span class="s3">\n  </span><span class="s1">springForceY = springForce * (edge.lengthY / length);</span><span class="s3">\n\n  </span><span class="s1">// Apply forces on the end nodes</span><span class="s3">\n  </span><span class="s1">sourceNode.springForceX += springForceX;</span><span class="s3">\n  </span><span class="s1">sourceNode.springForceY += springForceY;</span><span class="s3">\n  </span><span class="s1">targetNode.springForceX -= springForceX;</span><span class="s3">\n  </span><span class="s1">targetNode.springForceY -= springForceY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {</span><span class="s3">\n  </span><span class="s1">var rectA = nodeA.getRect();</span><span class="s3">\n  </span><span class="s1">var rectB = nodeB.getRect();</span><span class="s3">\n  </span><span class="s1">var overlapAmount = new Array(2);</span><span class="s3">\n  </span><span class="s1">var clipPoints = new Array(4);</span><span class="s3">\n  </span><span class="s1">var distanceX;</span><span class="s3">\n  </span><span class="s1">var distanceY;</span><span class="s3">\n  </span><span class="s1">var distanceSquared;</span><span class="s3">\n  </span><span class="s1">var distance;</span><span class="s3">\n  </span><span class="s1">var repulsionForce;</span><span class="s3">\n  </span><span class="s1">var repulsionForceX;</span><span class="s3">\n  </span><span class="s1">var repulsionForceY;</span><span class="s3">\n\n  </span><span class="s1">if (rectA.intersects(rectB)) // two nodes overlap</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">// calculate separation amount in x and y directions</span><span class="s3">\n      </span><span class="s1">IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);</span><span class="s3">\n\n      </span><span class="s1">repulsionForceX = 2 * overlapAmount[0];</span><span class="s3">\n      </span><span class="s1">repulsionForceY = 2 * overlapAmount[1];</span><span class="s3">\n\n      </span><span class="s1">var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);</span><span class="s3">\n\n      </span><span class="s1">// Apply forces on the two nodes</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceX -= childrenConstant * repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceY -= childrenConstant * repulsionForceY;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceX += childrenConstant * repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceY += childrenConstant * repulsionForceY;</span><span class="s3">\n    </span><span class="s1">} else // no overlap</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">// calculate distance</span><span class="s3">\n\n      </span><span class="s1">if (this.uniformLeafNodeSizes &amp;&amp; nodeA.getChild() == null &amp;&amp; nodeB.getChild() == null) // simply base repulsion on distance of node centers</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">distanceX = rectB.getCenterX() - rectA.getCenterX();</span><span class="s3">\n          </span><span class="s1">distanceY = rectB.getCenterY() - rectA.getCenterY();</span><span class="s3">\n        </span><span class="s1">} else // use clipping points</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">IGeometry.getIntersection(rectA, rectB, clipPoints);</span><span class="s3">\n\n          </span><span class="s1">distanceX = clipPoints[2] - clipPoints[0];</span><span class="s3">\n          </span><span class="s1">distanceY = clipPoints[3] - clipPoints[1];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// No repulsion range. FR grid variant should take care of this.</span><span class="s3">\n      </span><span class="s1">if (Math.abs(distanceX) &lt; FDLayoutConstants.MIN_REPULSION_DIST) {</span><span class="s3">\n        </span><span class="s1">distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (Math.abs(distanceY) &lt; FDLayoutConstants.MIN_REPULSION_DIST) {</span><span class="s3">\n        </span><span class="s1">distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">distanceSquared = distanceX * distanceX + distanceY * distanceY;</span><span class="s3">\n      </span><span class="s1">distance = Math.sqrt(distanceSquared);</span><span class="s3">\n\n      </span><span class="s1">repulsionForce = this.repulsionConstant * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;</span><span class="s3">\n\n      </span><span class="s1">// Project force onto x and y axes</span><span class="s3">\n      </span><span class="s1">repulsionForceX = repulsionForce * distanceX / distance;</span><span class="s3">\n      </span><span class="s1">repulsionForceY = repulsionForce * distanceY / distance;</span><span class="s3">\n\n      </span><span class="s1">// Apply forces on the two nodes    </span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceX -= repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceY -= repulsionForceY;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceX += repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceY += repulsionForceY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGravitationalForce = function (node) {</span><span class="s3">\n  </span><span class="s1">var ownerGraph;</span><span class="s3">\n  </span><span class="s1">var ownerCenterX;</span><span class="s3">\n  </span><span class="s1">var ownerCenterY;</span><span class="s3">\n  </span><span class="s1">var distanceX;</span><span class="s3">\n  </span><span class="s1">var distanceY;</span><span class="s3">\n  </span><span class="s1">var absDistanceX;</span><span class="s3">\n  </span><span class="s1">var absDistanceY;</span><span class="s3">\n  </span><span class="s1">var estimatedSize;</span><span class="s3">\n  </span><span class="s1">ownerGraph = node.getOwner();</span><span class="s3">\n\n  </span><span class="s1">ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;</span><span class="s3">\n  </span><span class="s1">ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;</span><span class="s3">\n  </span><span class="s1">distanceX = node.getCenterX() - ownerCenterX;</span><span class="s3">\n  </span><span class="s1">distanceY = node.getCenterY() - ownerCenterY;</span><span class="s3">\n  </span><span class="s1">absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;</span><span class="s3">\n  </span><span class="s1">absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;</span><span class="s3">\n\n  </span><span class="s1">if (node.getOwner() == this.graphManager.getRoot()) // in the root graph</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;</span><span class="s3">\n\n      </span><span class="s1">if (absDistanceX &gt; estimatedSize || absDistanceY &gt; estimatedSize) {</span><span class="s3">\n        </span><span class="s1">node.gravitationForceX = -this.gravityConstant * distanceX;</span><span class="s3">\n        </span><span class="s1">node.gravitationForceY = -this.gravityConstant * distanceY;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else // inside a compound</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;</span><span class="s3">\n\n      </span><span class="s1">if (absDistanceX &gt; estimatedSize || absDistanceY &gt; estimatedSize) {</span><span class="s3">\n        </span><span class="s1">node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;</span><span class="s3">\n        </span><span class="s1">node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.isConverged = function () {</span><span class="s3">\n  </span><span class="s1">var converged;</span><span class="s3">\n  </span><span class="s1">var oscilating = false;</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations &gt; this.maxIterations / 3) {</span><span class="s3">\n    </span><span class="s1">oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) &lt; 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">converged = this.totalDisplacement &lt; this.totalDisplacementThreshold;</span><span class="s3">\n\n  </span><span class="s1">this.oldTotalDisplacement = this.totalDisplacement;</span><span class="s3">\n\n  </span><span class="s1">return converged || oscilating;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.animate = function () {</span><span class="s3">\n  </span><span class="s1">if (this.animationDuringLayout &amp;&amp; !this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">if (this.notAnimatedIterations == this.animationPeriod) {</span><span class="s3">\n      </span><span class="s1">this.update();</span><span class="s3">\n      </span><span class="s1">this.notAnimatedIterations = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.notAnimatedIterations++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//This method calculates the number of children (weight) for all nodes</span><span class="s3">\n</span><span class="s1">FDLayout.prototype.calcNoOfChildrenForAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">node.noOfChildren = node.getNoOfChildren();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: FR-Grid Variant Repulsion Force Calculation</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGrid = function (graph) {</span><span class="s3">\n\n  </span><span class="s1">var sizeX = 0;</span><span class="s3">\n  </span><span class="s1">var sizeY = 0;</span><span class="s3">\n\n  </span><span class="s1">sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));</span><span class="s3">\n\n  </span><span class="s1">var grid = new Array(sizeX);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; sizeX; i++) {</span><span class="s3">\n    </span><span class="s1">grid[i] = new Array(sizeY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; sizeX; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; sizeY; j++) {</span><span class="s3">\n      </span><span class="s1">grid[i][j] = new Array();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return grid;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.addNodeToGrid = function (v, left, top) {</span><span class="s3">\n\n  </span><span class="s1">var startX = 0;</span><span class="s3">\n  </span><span class="s1">var finishX = 0;</span><span class="s3">\n  </span><span class="s1">var startY = 0;</span><span class="s3">\n  </span><span class="s1">var finishY = 0;</span><span class="s3">\n\n  </span><span class="s1">startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));</span><span class="s3">\n\n  </span><span class="s1">for (var i = startX; i &lt;= finishX; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = startY; j &lt;= finishY; j++) {</span><span class="s3">\n      </span><span class="s1">this.grid[i][j].push(v);</span><span class="s3">\n      </span><span class="s1">v.setGridCoordinates(startX, finishX, startY, finishY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.updateGrid = function () {</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">var nodeA;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">this.grid = this.calcGrid(this.graphManager.getRoot());</span><span class="s3">\n\n  </span><span class="s1">// put all nodes to proper grid cells</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n    </span><span class="s1">this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 &amp;&amp; gridUpdateAllowed || forceToNodeSurroundingUpdate) {</span><span class="s3">\n    </span><span class="s1">var surrounding = new Set();</span><span class="s3">\n    </span><span class="s1">nodeA.surrounding = new Array();</span><span class="s3">\n    </span><span class="s1">var nodeB;</span><span class="s3">\n    </span><span class="s1">var grid = this.grid;</span><span class="s3">\n\n    </span><span class="s1">for (var i = nodeA.startX - 1; i &lt; nodeA.finishX + 2; i++) {</span><span class="s3">\n      </span><span class="s1">for (var j = nodeA.startY - 1; j &lt; nodeA.finishY + 2; j++) {</span><span class="s3">\n        </span><span class="s1">if (!(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length)) {</span><span class="s3">\n          </span><span class="s1">for (var k = 0; k &lt; grid[i][j].length; k++) {</span><span class="s3">\n            </span><span class="s1">nodeB = grid[i][j][k];</span><span class="s3">\n\n            </span><span class="s1">// If both nodes are not members of the same graph, </span><span class="s3">\n            </span><span class="s1">// or both nodes are the same, skip.</span><span class="s3">\n            </span><span class="s1">if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {</span><span class="s3">\n              </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// check if the repulsion force between</span><span class="s3">\n            </span><span class="s1">// nodeA and nodeB has already been calculated</span><span class="s3">\n            </span><span class="s1">if (!processedNodeSet.has(nodeB) &amp;&amp; !surrounding.has(nodeB)) {</span><span class="s3">\n              </span><span class="s1">var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);</span><span class="s3">\n              </span><span class="s1">var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);</span><span class="s3">\n\n              </span><span class="s1">// if the distance between nodeA and nodeB </span><span class="s3">\n              </span><span class="s1">// is less then calculation range</span><span class="s3">\n              </span><span class="s1">if (distanceX &lt;= this.repulsionRange &amp;&amp; distanceY &lt;= this.repulsionRange) {</span><span class="s3">\n                </span><span class="s1">//then add nodeB to surrounding of nodeA</span><span class="s3">\n                </span><span class="s1">surrounding.add(nodeB);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">nodeA.surrounding = [].concat(_toConsumableArray(surrounding));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; nodeA.surrounding.length; i++) {</span><span class="s3">\n    </span><span class="s1">this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionRange = function () {</span><span class="s3">\n  </span><span class="s1">return 0.0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 19 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(7);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">LEdge.call(this, source, target, vEdge);</span><span class="s3">\n  </span><span class="s1">this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutEdge.prototype = Object.create(LEdge.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LEdge) {</span><span class="s3">\n  </span><span class="s1">FDLayoutEdge[prop] = LEdge[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 20 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutNode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">// alternative constructor is handled inside LNode</span><span class="s3">\n  </span><span class="s1">LNode.call(this, gm, loc, size, vNode);</span><span class="s3">\n  </span><span class="s1">//Spring, repulsion and gravitational forces acting on this node</span><span class="s3">\n  </span><span class="s1">this.springForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.springForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceY = 0;</span><span class="s3">\n  </span><span class="s1">//Amount by which this node is to be moved in this iteration</span><span class="s3">\n  </span><span class="s1">this.displacementX = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementY = 0;</span><span class="s3">\n\n  </span><span class="s1">//Start and finish grid coordinates that this node is fallen into</span><span class="s3">\n  </span><span class="s1">this.startX = 0;</span><span class="s3">\n  </span><span class="s1">this.finishX = 0;</span><span class="s3">\n  </span><span class="s1">this.startY = 0;</span><span class="s3">\n  </span><span class="s1">this.finishY = 0;</span><span class="s3">\n\n  </span><span class="s1">//Geometric neighbors of this node</span><span class="s3">\n  </span><span class="s1">this.surrounding = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutNode.prototype = Object.create(LNode.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LNode) {</span><span class="s3">\n  </span><span class="s1">FDLayoutNode[prop] = LNode[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {</span><span class="s3">\n  </span><span class="s1">this.startX = _startX;</span><span class="s3">\n  </span><span class="s1">this.finishX = _finishX;</span><span class="s3">\n  </span><span class="s1">this.startY = _startY;</span><span class="s3">\n  </span><span class="s1">this.finishY = _finishY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutNode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 21 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function DimensionD(width, height) {</span><span class="s3">\n  </span><span class="s1">this.width = 0;</span><span class="s3">\n  </span><span class="s1">this.height = 0;</span><span class="s3">\n  </span><span class="s1">if (width !== null &amp;&amp; height !== null) {</span><span class="s3">\n    </span><span class="s1">this.height = height;</span><span class="s3">\n    </span><span class="s1">this.width = width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = DimensionD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 22 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n\n</span><span class="s1">function HashMap() {</span><span class="s3">\n  </span><span class="s1">this.map = {};</span><span class="s3">\n  </span><span class="s1">this.keys = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.put = function (key, value) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">if (!this.contains(theId)) {</span><span class="s3">\n    </span><span class="s1">this.map[theId] = value;</span><span class="s3">\n    </span><span class="s1">this.keys.push(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.contains = function (key) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">return this.map[key] != null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.get = function (key) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">return this.map[theId];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.keySet = function () {</span><span class="s3">\n  </span><span class="s1">return this.keys;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = HashMap;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 23 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n\n</span><span class="s1">function HashSet() {</span><span class="s3">\n  </span><span class="s1">this.set = {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.add = function (obj) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(obj);</span><span class="s3">\n  </span><span class="s1">if (!this.contains(theId)) this.set[theId] = obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.remove = function (obj) {</span><span class="s3">\n  </span><span class="s1">delete this.set[UniqueIDGeneretor.createID(obj)];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.clear = function () {</span><span class="s3">\n  </span><span class="s1">this.set = {};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.contains = function (obj) {</span><span class="s3">\n  </span><span class="s1">return this.set[UniqueIDGeneretor.createID(obj)] == obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.isEmpty = function () {</span><span class="s3">\n  </span><span class="s1">return this.size() === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.size = function () {</span><span class="s3">\n  </span><span class="s1">return Object.keys(this.set).length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//concats this.set to the given list</span><span class="s3">\n</span><span class="s1">HashSet.prototype.addAllTo = function (list) {</span><span class="s3">\n  </span><span class="s1">var keys = Object.keys(this.set);</span><span class="s3">\n  </span><span class="s1">var length = keys.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; length; i++) {</span><span class="s3">\n    </span><span class="s1">list.push(this.set[keys[i]]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.size = function () {</span><span class="s3">\n  </span><span class="s1">return Object.keys(this.set).length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.addAll = function (list) {</span><span class="s3">\n  </span><span class="s1">var s = list.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var v = list[i];</span><span class="s3">\n    </span><span class="s1">this.add(v);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = HashSet;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 24 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A classic Quicksort algorithm with Hoare's partition</span><span class="s3">\n </span><span class="s1">* - Works also on LinkedList objects</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright: i-Vis Research Group, Bilkent University, 2007 - present</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var LinkedList = __webpack_require__(11);</span><span class="s3">\n\n</span><span class="s1">var Quicksort = function () {</span><span class="s3">\n    </span><span class="s1">function Quicksort(A, compareFunction) {</span><span class="s3">\n        </span><span class="s1">_classCallCheck(this, Quicksort);</span><span class="s3">\n\n        </span><span class="s1">if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;</span><span class="s3">\n\n        </span><span class="s1">var length = void 0;</span><span class="s3">\n        </span><span class="s1">if (A instanceof LinkedList) length = A.size();else length = A.length;</span><span class="s3">\n\n        </span><span class="s1">this._quicksort(A, 0, length - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">_createClass(Quicksort, [{</span><span class="s3">\n        </span><span class="s1">key: '_quicksort',</span><span class="s3">\n        </span><span class="s1">value: function _quicksort(A, p, r) {</span><span class="s3">\n            </span><span class="s1">if (p &lt; r) {</span><span class="s3">\n                </span><span class="s1">var q = this._partition(A, p, r);</span><span class="s3">\n                </span><span class="s1">this._quicksort(A, p, q);</span><span class="s3">\n                </span><span class="s1">this._quicksort(A, q + 1, r);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_partition',</span><span class="s3">\n        </span><span class="s1">value: function _partition(A, p, r) {</span><span class="s3">\n            </span><span class="s1">var x = this._get(A, p);</span><span class="s3">\n            </span><span class="s1">var i = p;</span><span class="s3">\n            </span><span class="s1">var j = r;</span><span class="s3">\n            </span><span class="s1">while (true) {</span><span class="s3">\n                </span><span class="s1">while (this.compareFunction(x, this._get(A, j))) {</span><span class="s3">\n                    </span><span class="s1">j--;</span><span class="s3">\n                </span><span class="s1">}while (this.compareFunction(this._get(A, i), x)) {</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                </span><span class="s1">}if (i &lt; j) {</span><span class="s3">\n                    </span><span class="s1">this._swap(A, i, j);</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                    </span><span class="s1">j--;</span><span class="s3">\n                </span><span class="s1">} else return j;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_get',</span><span class="s3">\n        </span><span class="s1">value: function _get(object, index) {</span><span class="s3">\n            </span><span class="s1">if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_set',</span><span class="s3">\n        </span><span class="s1">value: function _set(object, index, value) {</span><span class="s3">\n            </span><span class="s1">if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_swap',</span><span class="s3">\n        </span><span class="s1">value: function _swap(A, i, j) {</span><span class="s3">\n            </span><span class="s1">var temp = this._get(A, i);</span><span class="s3">\n            </span><span class="s1">this._set(A, i, this._get(A, j));</span><span class="s3">\n            </span><span class="s1">this._set(A, j, temp);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_defaultCompareFunction',</span><span class="s3">\n        </span><span class="s1">value: function _defaultCompareFunction(a, b) {</span><span class="s3">\n            </span><span class="s1">return b &gt; a;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}]);</span><span class="s3">\n\n    </span><span class="s1">return Quicksort;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = Quicksort;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 25 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string</span><span class="s3">\n </span><span class="s1">*   sequences by S.B.Needleman and C.D.Wunsch (1970).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   Aside from the inputs, you can assign the scores for,</span><span class="s3">\n </span><span class="s1">*   - Match: The two characters at the current index are same.</span><span class="s3">\n </span><span class="s1">*   - Mismatch: The two characters at the current index are different.</span><span class="s3">\n </span><span class="s1">*   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var NeedlemanWunsch = function () {</span><span class="s3">\n    </span><span class="s1">function NeedlemanWunsch(sequence1, sequence2) {</span><span class="s3">\n        </span><span class="s1">var match_score = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 1;</span><span class="s3">\n        </span><span class="s1">var mismatch_penalty = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : -1;</span><span class="s3">\n        </span><span class="s1">var gap_penalty = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : -1;</span><span class="s3">\n\n        </span><span class="s1">_classCallCheck(this, NeedlemanWunsch);</span><span class="s3">\n\n        </span><span class="s1">this.sequence1 = sequence1;</span><span class="s3">\n        </span><span class="s1">this.sequence2 = sequence2;</span><span class="s3">\n        </span><span class="s1">this.match_score = match_score;</span><span class="s3">\n        </span><span class="s1">this.mismatch_penalty = mismatch_penalty;</span><span class="s3">\n        </span><span class="s1">this.gap_penalty = gap_penalty;</span><span class="s3">\n\n        </span><span class="s1">// Just the remove redundancy</span><span class="s3">\n        </span><span class="s1">this.iMax = sequence1.length + 1;</span><span class="s3">\n        </span><span class="s1">this.jMax = sequence2.length + 1;</span><span class="s3">\n\n        </span><span class="s1">// Grid matrix of scores</span><span class="s3">\n        </span><span class="s1">this.grid = new Array(this.iMax);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; this.iMax; i++) {</span><span class="s3">\n            </span><span class="s1">this.grid[i] = new Array(this.jMax);</span><span class="s3">\n\n            </span><span class="s1">for (var j = 0; j &lt; this.jMax; j++) {</span><span class="s3">\n                </span><span class="s1">this.grid[i][j] = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)</span><span class="s3">\n        </span><span class="s1">this.tracebackGrid = new Array(this.iMax);</span><span class="s3">\n        </span><span class="s1">for (var _i = 0; _i &lt; this.iMax; _i++) {</span><span class="s3">\n            </span><span class="s1">this.tracebackGrid[_i] = new Array(this.jMax);</span><span class="s3">\n\n            </span><span class="s1">for (var _j = 0; _j &lt; this.jMax; _j++) {</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[_i][_j] = [null, null, null];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// The aligned sequences (return multiple possibilities)</span><span class="s3">\n        </span><span class="s1">this.alignments = [];</span><span class="s3">\n\n        </span><span class="s1">// Final alignment score</span><span class="s3">\n        </span><span class="s1">this.score = -1;</span><span class="s3">\n\n        </span><span class="s1">// Calculate scores and tracebacks</span><span class="s3">\n        </span><span class="s1">this.computeGrids();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">_createClass(NeedlemanWunsch, [{</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getScore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getScore() {</span><span class="s3">\n            </span><span class="s1">return this.score;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAlignments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getAlignments() {</span><span class="s3">\n            </span><span class="s1">return this.alignments;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Main dynamic programming procedure</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">computeGrids</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function computeGrids() {</span><span class="s3">\n            </span><span class="s1">// Fill in the first row</span><span class="s3">\n            </span><span class="s1">for (var j = 1; j &lt; this.jMax; j++) {</span><span class="s3">\n                </span><span class="s1">this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[0][j] = [false, false, true];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Fill in the first column</span><span class="s3">\n            </span><span class="s1">for (var i = 1; i &lt; this.iMax; i++) {</span><span class="s3">\n                </span><span class="s1">this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[i][0] = [false, true, false];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Fill the rest of the grid</span><span class="s3">\n            </span><span class="s1">for (var _i2 = 1; _i2 &lt; this.iMax; _i2++) {</span><span class="s3">\n                </span><span class="s1">for (var _j2 = 1; _j2 &lt; this.jMax; _j2++) {</span><span class="s3">\n                    </span><span class="s1">// Find the max score(s) among [`Diag`, `Up`, `Left`]</span><span class="s3">\n                    </span><span class="s1">var diag = void 0;</span><span class="s3">\n                    </span><span class="s1">if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;</span><span class="s3">\n\n                    </span><span class="s1">var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;</span><span class="s3">\n                    </span><span class="s1">var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;</span><span class="s3">\n\n                    </span><span class="s1">// If there exists multiple max values, capture them for multiple paths</span><span class="s3">\n                    </span><span class="s1">var maxOf = [diag, up, left];</span><span class="s3">\n                    </span><span class="s1">var indices = this.arrayAllMaxIndexes(maxOf);</span><span class="s3">\n\n                    </span><span class="s1">// Update Grids</span><span class="s3">\n                    </span><span class="s1">this.grid[_i2][_j2] = maxOf[indices[0]];</span><span class="s3">\n                    </span><span class="s1">this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Update alignment score</span><span class="s3">\n            </span><span class="s1">this.score = this.grid[this.iMax - 1][this.jMax - 1];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Gets all possible valid sequence combinations</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">alignmentTraceback</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function alignmentTraceback() {</span><span class="s3">\n            </span><span class="s1">var inProcessAlignments = [];</span><span class="s3">\n\n            </span><span class="s1">inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],</span><span class="s3">\n                </span><span class="s1">seq1: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">seq2: </span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">});</span><span class="s3">\n\n            </span><span class="s1">while (inProcessAlignments[0]) {</span><span class="s3">\n                </span><span class="s1">var current = inProcessAlignments[0];</span><span class="s3">\n                </span><span class="s1">var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];</span><span class="s3">\n\n                </span><span class="s1">if (directions[0]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],</span><span class="s3">\n                        </span><span class="s1">seq1: this.sequence1[current.pos[0] - 1] + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: this.sequence2[current.pos[1] - 1] + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (directions[1]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],</span><span class="s3">\n                        </span><span class="s1">seq1: this.sequence1[current.pos[0] - 1] + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: '-' + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (directions[2]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],</span><span class="s3">\n                        </span><span class="s1">seq1: '-' + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: this.sequence2[current.pos[1] - 1] + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">if (current.pos[0] === 0 &amp;&amp; current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,</span><span class="s3">\n                    </span><span class="s1">sequence2: current.seq2</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n\n                </span><span class="s1">inProcessAlignments.shift();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return this.alignments;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Helper Functions</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAllIndexes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getAllIndexes(arr, val) {</span><span class="s3">\n            </span><span class="s1">var indexes = [],</span><span class="s3">\n                </span><span class="s1">i = -1;</span><span class="s3">\n            </span><span class="s1">while ((i = arr.indexOf(val, i + 1)) !== -1) {</span><span class="s3">\n                </span><span class="s1">indexes.push(i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return indexes;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">arrayAllMaxIndexes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function arrayAllMaxIndexes(array) {</span><span class="s3">\n            </span><span class="s1">return this.getAllIndexes(array, Math.max.apply(null, array));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}]);</span><span class="s3">\n\n    </span><span class="s1">return NeedlemanWunsch;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = NeedlemanWunsch;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 26 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var layoutBase = function layoutBase() {</span><span class="s3">\n  </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">layoutBase.FDLayout = __webpack_require__(18);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutConstants = __webpack_require__(7);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutEdge = __webpack_require__(19);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutNode = __webpack_require__(20);</span><span class="s3">\n</span><span class="s1">layoutBase.DimensionD = __webpack_require__(21);</span><span class="s3">\n</span><span class="s1">layoutBase.HashMap = __webpack_require__(22);</span><span class="s3">\n</span><span class="s1">layoutBase.HashSet = __webpack_require__(23);</span><span class="s3">\n</span><span class="s1">layoutBase.IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">layoutBase.IMath = __webpack_require__(9);</span><span class="s3">\n</span><span class="s1">layoutBase.Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">layoutBase.Point = __webpack_require__(12);</span><span class="s3">\n</span><span class="s1">layoutBase.PointD = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">layoutBase.RandomSeed = __webpack_require__(16);</span><span class="s3">\n</span><span class="s1">layoutBase.RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">layoutBase.Transform = __webpack_require__(17);</span><span class="s3">\n</span><span class="s1">layoutBase.UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n</span><span class="s1">layoutBase.Quicksort = __webpack_require__(24);</span><span class="s3">\n</span><span class="s1">layoutBase.LinkedList = __webpack_require__(11);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraph = __webpack_require__(5);</span><span class="s3">\n</span><span class="s1">layoutBase.LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraphManager = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">layoutBase.LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">layoutBase.Layout = __webpack_require__(15);</span><span class="s3">\n</span><span class="s1">layoutBase.LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">layoutBase.NeedlemanWunsch = __webpack_require__(25);</span><span class="s3">\n\n</span><span class="s1">module.exports = layoutBase;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 27 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function Emitter() {</span><span class="s3">\n  </span><span class="s1">this.listeners = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var p = Emitter.prototype;</span><span class="s3">\n\n</span><span class="s1">p.addListener = function (event, callback) {</span><span class="s3">\n  </span><span class="s1">this.listeners.push({</span><span class="s3">\n    </span><span class="s1">event: event,</span><span class="s3">\n    </span><span class="s1">callback: callback</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">p.removeListener = function (event, callback) {</span><span class="s3">\n  </span><span class="s1">for (var i = this.listeners.length; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var l = this.listeners[i];</span><span class="s3">\n\n    </span><span class="s1">if (l.event === event &amp;&amp; l.callback === callback) {</span><span class="s3">\n      </span><span class="s1">this.listeners.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">p.emit = function (event, data) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.listeners.length; i++) {</span><span class="s3">\n    </span><span class="s1">var l = this.listeners[i];</span><span class="s3">\n\n    </span><span class="s1">if (event === l.event) {</span><span class="s3">\n      </span><span class="s1">l.callback(data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Emitter;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ]);</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">createText</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-C3MQ5ANM.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">parseFontSize</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-O4NI6UNU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">selectSvgElement</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7B677QYD.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">defaultConfig_default,</span><span class="s3">\n  </span><span class="s1">getConfig2 as getConfig,</span><span class="s3">\n  </span><span class="s1">log,</span><span class="s3">\n  </span><span class="s1">sanitizeText,</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/parser/mindmap.jison</span><span class="s3">\n</span><span class="s1">var parser = function() {</span><span class="s3">\n  </span><span class="s1">var o = /* @__PURE__ */ __name(function(k, v, o2, l) {</span><span class="s3">\n    </span><span class="s1">for (o2 = o2 || {}, l = k.length; l--; o2[k[l]] = v) ;</span><span class="s3">\n    </span><span class="s1">return o2;</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">o</span><span class="s3">\&quot;</span><span class="s1">), $V0 = [1, 4], $V1 = [1, 13], $V2 = [1, 12], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 20], $V6 = [1, 19], $V7 = [6, 7, 8], $V8 = [1, 26], $V9 = [1, 24], $Va = [1, 25], $Vb = [6, 7, 11], $Vc = [1, 6, 13, 15, 16, 19, 22], $Vd = [1, 33], $Ve = [1, 34], $Vf = [1, 6, 7, 11, 13, 15, 16, 19, 22];</span><span class="s3">\n  </span><span class="s1">var parser2 = {</span><span class="s3">\n    </span><span class="s1">trace: /* @__PURE__ */ __name(function trace() {</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">trace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">yy: {},</span><span class="s3">\n    </span><span class="s1">symbols_: { </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">: 2, </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">: 3, </span><span class="s3">\&quot;</span><span class="s1">mindMap</span><span class="s3">\&quot;</span><span class="s1">: 4, </span><span class="s3">\&quot;</span><span class="s1">spaceLines</span><span class="s3">\&quot;</span><span class="s1">: 5, </span><span class="s3">\&quot;</span><span class="s1">SPACELINE</span><span class="s3">\&quot;</span><span class="s1">: 6, </span><span class="s3">\&quot;</span><span class="s1">NL</span><span class="s3">\&quot;</span><span class="s1">: 7, </span><span class="s3">\&quot;</span><span class="s1">MINDMAP</span><span class="s3">\&quot;</span><span class="s1">: 8, </span><span class="s3">\&quot;</span><span class="s1">document</span><span class="s3">\&quot;</span><span class="s1">: 9, </span><span class="s3">\&quot;</span><span class="s1">stop</span><span class="s3">\&quot;</span><span class="s1">: 10, </span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">: 11, </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">: 12, </span><span class="s3">\&quot;</span><span class="s1">SPACELIST</span><span class="s3">\&quot;</span><span class="s1">: 13, </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">: 14, </span><span class="s3">\&quot;</span><span class="s1">ICON</span><span class="s3">\&quot;</span><span class="s1">: 15, </span><span class="s3">\&quot;</span><span class="s1">CLASS</span><span class="s3">\&quot;</span><span class="s1">: 16, </span><span class="s3">\&quot;</span><span class="s1">nodeWithId</span><span class="s3">\&quot;</span><span class="s1">: 17, </span><span class="s3">\&quot;</span><span class="s1">nodeWithoutId</span><span class="s3">\&quot;</span><span class="s1">: 18, </span><span class="s3">\&quot;</span><span class="s1">NODE_DSTART</span><span class="s3">\&quot;</span><span class="s1">: 19, </span><span class="s3">\&quot;</span><span class="s1">NODE_DESCR</span><span class="s3">\&quot;</span><span class="s1">: 20, </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">: 21, </span><span class="s3">\&quot;</span><span class="s1">NODE_ID</span><span class="s3">\&quot;</span><span class="s1">: 22, </span><span class="s3">\&quot;</span><span class="s1">$accept</span><span class="s3">\&quot;</span><span class="s1">: 0, </span><span class="s3">\&quot;</span><span class="s1">$end</span><span class="s3">\&quot;</span><span class="s1">: 1 },</span><span class="s3">\n    </span><span class="s1">terminals_: { 2: </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, 6: </span><span class="s3">\&quot;</span><span class="s1">SPACELINE</span><span class="s3">\&quot;</span><span class="s1">, 7: </span><span class="s3">\&quot;</span><span class="s1">NL</span><span class="s3">\&quot;</span><span class="s1">, 8: </span><span class="s3">\&quot;</span><span class="s1">MINDMAP</span><span class="s3">\&quot;</span><span class="s1">, 11: </span><span class="s3">\&quot;</span><span class="s1">EOF</span><span class="s3">\&quot;</span><span class="s1">, 13: </span><span class="s3">\&quot;</span><span class="s1">SPACELIST</span><span class="s3">\&quot;</span><span class="s1">, 15: </span><span class="s3">\&quot;</span><span class="s1">ICON</span><span class="s3">\&quot;</span><span class="s1">, 16: </span><span class="s3">\&quot;</span><span class="s1">CLASS</span><span class="s3">\&quot;</span><span class="s1">, 19: </span><span class="s3">\&quot;</span><span class="s1">NODE_DSTART</span><span class="s3">\&quot;</span><span class="s1">, 20: </span><span class="s3">\&quot;</span><span class="s1">NODE_DESCR</span><span class="s3">\&quot;</span><span class="s1">, 21: </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">, 22: </span><span class="s3">\&quot;</span><span class="s1">NODE_ID</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">productions_: [0, [3, 1], [3, 2], [5, 1], [5, 2], [5, 2], [4, 2], [4, 3], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [9, 3], [9, 2], [12, 2], [12, 2], [12, 2], [12, 1], [12, 1], [12, 1], [12, 1], [12, 1], [14, 1], [14, 1], [18, 3], [17, 1], [17, 4]],</span><span class="s3">\n    </span><span class="s1">performAction: /* @__PURE__ */ __name(function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {</span><span class="s3">\n      </span><span class="s1">var $0 = $$.length - 1;</span><span class="s3">\n      </span><span class="s1">switch (yystate) {</span><span class="s3">\n        </span><span class="s1">case 6:</span><span class="s3">\n        </span><span class="s1">case 7:</span><span class="s3">\n          </span><span class="s1">return yy;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 8:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Stop NL </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 9:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Stop EOF </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 11:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Stop NL2 </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 12:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Stop EOF2 </span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 15:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().info(</span><span class="s3">\&quot;</span><span class="s1">Node: </span><span class="s3">\&quot;</span><span class="s1">, $$[$0].id);</span><span class="s3">\n          </span><span class="s1">yy.addNode($$[$0 - 1].length, $$[$0].id, $$[$0].descr, $$[$0].type);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 16:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Icon: </span><span class="s3">\&quot;</span><span class="s1">, $$[$0]);</span><span class="s3">\n          </span><span class="s1">yy.decorateNode({ icon: $$[$0] });</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 17:</span><span class="s3">\n        </span><span class="s1">case 21:</span><span class="s3">\n          </span><span class="s1">yy.decorateNode({ class: $$[$0] });</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 18:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">SPACELIST</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 19:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Node: </span><span class="s3">\&quot;</span><span class="s1">, $$[$0].id);</span><span class="s3">\n          </span><span class="s1">yy.addNode(0, $$[$0].id, $$[$0].descr, $$[$0].type);</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 20:</span><span class="s3">\n          </span><span class="s1">yy.decorateNode({ icon: $$[$0] });</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 25:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node found ..</span><span class="s3">\&quot;</span><span class="s1">, $$[$0 - 2]);</span><span class="s3">\n          </span><span class="s1">this.$ = { id: $$[$0 - 1], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 26:</span><span class="s3">\n          </span><span class="s1">this.$ = { id: $$[$0], descr: $$[$0], type: yy.nodeType.DEFAULT };</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 27:</span><span class="s3">\n          </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node found ..</span><span class="s3">\&quot;</span><span class="s1">, $$[$0 - 3]);</span><span class="s3">\n          </span><span class="s1">this.$ = { id: $$[$0 - 3], descr: $$[$0 - 1], type: yy.getType($$[$0 - 2], $$[$0]) };</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">anonymous</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">table: [{ 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: $V0 }, { 1: [3] }, { 1: [2, 1] }, { 4: 6, 6: [1, 7], 7: [1, 8], 8: $V0 }, { 6: $V1, 7: [1, 10], 9: 9, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($V7, [2, 3]), { 1: [2, 2] }, o($V7, [2, 4]), o($V7, [2, 5]), { 1: [2, 6], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V1, 9: 22, 12: 11, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, { 6: $V8, 7: $V9, 10: 23, 11: $Va }, o($Vb, [2, 22], { 17: 17, 18: 18, 14: 27, 15: [1, 28], 16: [1, 29], 19: $V5, 22: $V6 }), o($Vb, [2, 18]), o($Vb, [2, 19]), o($Vb, [2, 20]), o($Vb, [2, 21]), o($Vb, [2, 23]), o($Vb, [2, 24]), o($Vb, [2, 26], { 19: [1, 30] }), { 20: [1, 31] }, { 6: $V8, 7: $V9, 10: 32, 11: $Va }, { 1: [2, 7], 6: $V1, 12: 21, 13: $V2, 14: 14, 15: $V3, 16: $V4, 17: 17, 18: 18, 19: $V5, 22: $V6 }, o($Vc, [2, 14], { 7: $Vd, 11: $Ve }), o($Vf, [2, 8]), o($Vf, [2, 9]), o($Vf, [2, 10]), o($Vb, [2, 15]), o($Vb, [2, 16]), o($Vb, [2, 17]), { 20: [1, 35] }, { 21: [1, 36] }, o($Vc, [2, 13], { 7: $Vd, 11: $Ve }), o($Vf, [2, 11]), o($Vf, [2, 12]), { 21: [1, 37] }, o($Vb, [2, 25]), o($Vb, [2, 27])],</span><span class="s3">\n    </span><span class="s1">defaultActions: { 2: [2, 1], 6: [2, 2] },</span><span class="s3">\n    </span><span class="s1">parseError: /* @__PURE__ */ __name(function parseError(str, hash) {</span><span class="s3">\n      </span><span class="s1">if (hash.recoverable) {</span><span class="s3">\n        </span><span class="s1">this.trace(str);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var error = new Error(str);</span><span class="s3">\n        </span><span class="s1">error.hash = hash;</span><span class="s3">\n        </span><span class="s1">throw error;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parseError</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n    </span><span class="s1">parse: /* @__PURE__ */ __name(function parse(input) {</span><span class="s3">\n      </span><span class="s1">var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;</span><span class="s3">\n      </span><span class="s1">var args = lstack.slice.call(arguments, 1);</span><span class="s3">\n      </span><span class="s1">var lexer2 = Object.create(this.lexer);</span><span class="s3">\n      </span><span class="s1">var sharedState = { yy: {} };</span><span class="s3">\n      </span><span class="s1">for (var k in this.yy) {</span><span class="s3">\n        </span><span class="s1">if (Object.prototype.hasOwnProperty.call(this.yy, k)) {</span><span class="s3">\n          </span><span class="s1">sharedState.yy[k] = this.yy[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">lexer2.setInput(input, sharedState.yy);</span><span class="s3">\n      </span><span class="s1">sharedState.yy.lexer = lexer2;</span><span class="s3">\n      </span><span class="s1">sharedState.yy.parser = this;</span><span class="s3">\n      </span><span class="s1">if (typeof lexer2.yylloc == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">lexer2.yylloc = {};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var yyloc = lexer2.yylloc;</span><span class="s3">\n      </span><span class="s1">lstack.push(yyloc);</span><span class="s3">\n      </span><span class="s1">var ranges = lexer2.options &amp;&amp; lexer2.options.ranges;</span><span class="s3">\n      </span><span class="s1">if (typeof sharedState.yy.parseError === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.parseError = sharedState.yy.parseError;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.parseError = Object.getPrototypeOf(this).parseError;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">function popStack(n) {</span><span class="s3">\n        </span><span class="s1">stack.length = stack.length - 2 * n;</span><span class="s3">\n        </span><span class="s1">vstack.length = vstack.length - n;</span><span class="s3">\n        </span><span class="s1">lstack.length = lstack.length - n;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">__name(popStack, </span><span class="s3">\&quot;</span><span class="s1">popStack</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">function lex() {</span><span class="s3">\n        </span><span class="s1">var token;</span><span class="s3">\n        </span><span class="s1">token = tstack.pop() || lexer2.lex() || EOF;</span><span class="s3">\n        </span><span class="s1">if (typeof token !== </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (token instanceof Array) {</span><span class="s3">\n            </span><span class="s1">tstack = token;</span><span class="s3">\n            </span><span class="s1">token = tstack.pop();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">token = self.symbols_[token] || token;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return token;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">__name(lex, </span><span class="s3">\&quot;</span><span class="s1">lex</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;</span><span class="s3">\n      </span><span class="s1">while (true) {</span><span class="s3">\n        </span><span class="s1">state = stack[stack.length - 1];</span><span class="s3">\n        </span><span class="s1">if (this.defaultActions[state]) {</span><span class="s3">\n          </span><span class="s1">action = this.defaultActions[state];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">if (symbol === null || typeof symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">symbol = lex();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">action = table[state] &amp;&amp; table[state][symbol];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof action === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">|| !action.length || !action[0]) {</span><span class="s3">\n          </span><span class="s1">var errStr = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">expected = [];</span><span class="s3">\n          </span><span class="s1">for (p in table[state]) {</span><span class="s3">\n            </span><span class="s1">if (this.terminals_[p] &amp;&amp; p &gt; TERROR) {</span><span class="s3">\n              </span><span class="s1">expected.push(</span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">+ this.terminals_[p] + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (lexer2.showPosition) {</span><span class="s3">\n            </span><span class="s1">errStr = </span><span class="s3">\&quot;</span><span class="s1">Parse error on line </span><span class="s3">\&quot; </span><span class="s1">+ (yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ lexer2.showPosition() + </span><span class="s3">\&quot;\\</span><span class="s1">nExpecting </span><span class="s3">\&quot; </span><span class="s1">+ expected.join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">, got '</span><span class="s3">\&quot; </span><span class="s1">+ (this.terminals_[symbol] || symbol) + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">errStr = </span><span class="s3">\&quot;</span><span class="s1">Parse error on line </span><span class="s3">\&quot; </span><span class="s1">+ (yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">: Unexpected </span><span class="s3">\&quot; </span><span class="s1">+ (symbol == EOF ? </span><span class="s3">\&quot;</span><span class="s1">end of input</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot; </span><span class="s1">+ (this.terminals_[symbol] || symbol) + </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">this.parseError(errStr, {</span><span class="s3">\n            </span><span class="s1">text: lexer2.match,</span><span class="s3">\n            </span><span class="s1">token: this.terminals_[symbol] || symbol,</span><span class="s3">\n            </span><span class="s1">line: lexer2.yylineno,</span><span class="s3">\n            </span><span class="s1">loc: yyloc,</span><span class="s3">\n            </span><span class="s1">expected</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (action[0] instanceof Array &amp;&amp; action.length &gt; 1) {</span><span class="s3">\n          </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Parse Error: multiple actions possible at state: </span><span class="s3">\&quot; </span><span class="s1">+ state + </span><span class="s3">\&quot;</span><span class="s1">, token: </span><span class="s3">\&quot; </span><span class="s1">+ symbol);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">switch (action[0]) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">stack.push(symbol);</span><span class="s3">\n            </span><span class="s1">vstack.push(lexer2.yytext);</span><span class="s3">\n            </span><span class="s1">lstack.push(lexer2.yylloc);</span><span class="s3">\n            </span><span class="s1">stack.push(action[1]);</span><span class="s3">\n            </span><span class="s1">symbol = null;</span><span class="s3">\n            </span><span class="s1">if (!preErrorSymbol) {</span><span class="s3">\n              </span><span class="s1">yyleng = lexer2.yyleng;</span><span class="s3">\n              </span><span class="s1">yytext = lexer2.yytext;</span><span class="s3">\n              </span><span class="s1">yylineno = lexer2.yylineno;</span><span class="s3">\n              </span><span class="s1">yyloc = lexer2.yylloc;</span><span class="s3">\n              </span><span class="s1">if (recovering &gt; 0) {</span><span class="s3">\n                </span><span class="s1">recovering--;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">symbol = preErrorSymbol;</span><span class="s3">\n              </span><span class="s1">preErrorSymbol = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">len = this.productions_[action[1]][1];</span><span class="s3">\n            </span><span class="s1">yyval.$ = vstack[vstack.length - len];</span><span class="s3">\n            </span><span class="s1">yyval._$ = {</span><span class="s3">\n              </span><span class="s1">first_line: lstack[lstack.length - (len || 1)].first_line,</span><span class="s3">\n              </span><span class="s1">last_line: lstack[lstack.length - 1].last_line,</span><span class="s3">\n              </span><span class="s1">first_column: lstack[lstack.length - (len || 1)].first_column,</span><span class="s3">\n              </span><span class="s1">last_column: lstack[lstack.length - 1].last_column</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">if (ranges) {</span><span class="s3">\n              </span><span class="s1">yyval._$.range = [</span><span class="s3">\n                </span><span class="s1">lstack[lstack.length - (len || 1)].range[0],</span><span class="s3">\n                </span><span class="s1">lstack[lstack.length - 1].range[1]</span><span class="s3">\n              </span><span class="s1">];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">r = this.performAction.apply(yyval, [</span><span class="s3">\n              </span><span class="s1">yytext,</span><span class="s3">\n              </span><span class="s1">yyleng,</span><span class="s3">\n              </span><span class="s1">yylineno,</span><span class="s3">\n              </span><span class="s1">sharedState.yy,</span><span class="s3">\n              </span><span class="s1">action[1],</span><span class="s3">\n              </span><span class="s1">vstack,</span><span class="s3">\n              </span><span class="s1">lstack</span><span class="s3">\n            </span><span class="s1">].concat(args));</span><span class="s3">\n            </span><span class="s1">if (typeof r !== </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">return r;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (len) {</span><span class="s3">\n              </span><span class="s1">stack = stack.slice(0, -1 * len * 2);</span><span class="s3">\n              </span><span class="s1">vstack = vstack.slice(0, -1 * len);</span><span class="s3">\n              </span><span class="s1">lstack = lstack.slice(0, -1 * len);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">stack.push(this.productions_[action[1]][0]);</span><span class="s3">\n            </span><span class="s1">vstack.push(yyval.$);</span><span class="s3">\n            </span><span class="s1">lstack.push(yyval._$);</span><span class="s3">\n            </span><span class="s1">newState = table[stack[stack.length - 2]][stack[stack.length - 1]];</span><span class="s3">\n            </span><span class="s1">stack.push(newState);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parse</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var lexer = /* @__PURE__ */ function() {</span><span class="s3">\n    </span><span class="s1">var lexer2 = {</span><span class="s3">\n      </span><span class="s1">EOF: 1,</span><span class="s3">\n      </span><span class="s1">parseError: /* @__PURE__ */ __name(function parseError(str, hash) {</span><span class="s3">\n        </span><span class="s1">if (this.yy.parser) {</span><span class="s3">\n          </span><span class="s1">this.yy.parser.parseError(str, hash);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">throw new Error(str);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parseError</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// resets the lexer, sets new input</span><span class="s3">\n      </span><span class="s1">setInput: /* @__PURE__ */ __name(function(input, yy) {</span><span class="s3">\n        </span><span class="s1">this.yy = yy || this.yy || {};</span><span class="s3">\n        </span><span class="s1">this._input = input;</span><span class="s3">\n        </span><span class="s1">this._more = this._backtrack = this.done = false;</span><span class="s3">\n        </span><span class="s1">this.yylineno = this.yyleng = 0;</span><span class="s3">\n        </span><span class="s1">this.yytext = this.matched = this.match = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.conditionStack = [</span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: 1,</span><span class="s3">\n          </span><span class="s1">first_column: 0,</span><span class="s3">\n          </span><span class="s1">last_line: 1,</span><span class="s3">\n          </span><span class="s1">last_column: 0</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [0, 0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.offset = 0;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">setInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// consumes and returns one char from the input</span><span class="s3">\n      </span><span class="s1">input: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var ch = this._input[0];</span><span class="s3">\n        </span><span class="s1">this.yytext += ch;</span><span class="s3">\n        </span><span class="s1">this.yyleng++;</span><span class="s3">\n        </span><span class="s1">this.offset++;</span><span class="s3">\n        </span><span class="s1">this.match += ch;</span><span class="s3">\n        </span><span class="s1">this.matched += ch;</span><span class="s3">\n        </span><span class="s1">var lines = ch.match(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n).*/g);</span><span class="s3">\n        </span><span class="s1">if (lines) {</span><span class="s3">\n          </span><span class="s1">this.yylineno++;</span><span class="s3">\n          </span><span class="s1">this.yylloc.last_line++;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">this.yylloc.last_column++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range[1]++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._input = this._input.slice(1);</span><span class="s3">\n        </span><span class="s1">return ch;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// unshifts one char (or a string) into the input</span><span class="s3">\n      </span><span class="s1">unput: /* @__PURE__ */ __name(function(ch) {</span><span class="s3">\n        </span><span class="s1">var len = ch.length;</span><span class="s3">\n        </span><span class="s1">var lines = ch.split(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n)/g);</span><span class="s3">\n        </span><span class="s1">this._input = ch + this._input;</span><span class="s3">\n        </span><span class="s1">this.yytext = this.yytext.substr(0, this.yytext.length - len);</span><span class="s3">\n        </span><span class="s1">this.offset -= len;</span><span class="s3">\n        </span><span class="s1">var oldLines = this.match.split(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n)/g);</span><span class="s3">\n        </span><span class="s1">this.match = this.match.substr(0, this.match.length - 1);</span><span class="s3">\n        </span><span class="s1">this.matched = this.matched.substr(0, this.matched.length - 1);</span><span class="s3">\n        </span><span class="s1">if (lines.length - 1) {</span><span class="s3">\n          </span><span class="s1">this.yylineno -= lines.length - 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var r = this.yylloc.range;</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: this.yylloc.first_line,</span><span class="s3">\n          </span><span class="s1">last_line: this.yylineno + 1,</span><span class="s3">\n          </span><span class="s1">first_column: this.yylloc.first_column,</span><span class="s3">\n          </span><span class="s1">last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [r[0], r[0] + this.yyleng - len];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.yyleng = this.yytext.length;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">unput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// When called from action, caches matched text and appends it on next action</span><span class="s3">\n      </span><span class="s1">more: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">this._more = true;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">more</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.</span><span class="s3">\n      </span><span class="s1">reject: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n          </span><span class="s1">this._backtrack = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.parseError(</span><span class="s3">\&quot;</span><span class="s1">Lexical error on line </span><span class="s3">\&quot; </span><span class="s1">+ (this.yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ this.showPosition(), {</span><span class="s3">\n            </span><span class="s1">text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">token: null,</span><span class="s3">\n            </span><span class="s1">line: this.yylineno</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">reject</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// retain first n characters of the match</span><span class="s3">\n      </span><span class="s1">less: /* @__PURE__ */ __name(function(n) {</span><span class="s3">\n        </span><span class="s1">this.unput(this.match.slice(n));</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">less</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays already matched input, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">pastInput: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var past = this.matched.substr(0, this.matched.length - this.match.length);</span><span class="s3">\n        </span><span class="s1">return (past.length &gt; 20 ? </span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + past.substr(-20).replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">pastInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays upcoming input, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">upcomingInput: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var next = this.match;</span><span class="s3">\n        </span><span class="s1">if (next.length &lt; 20) {</span><span class="s3">\n          </span><span class="s1">next += this._input.substr(0, 20 - next.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (next.substr(0, 20) + (next.length &gt; 20 ? </span><span class="s3">\&quot;</span><span class="s1">...</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">)).replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">upcomingInput</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// displays the character position where the lexing error occurred, i.e. for error messages</span><span class="s3">\n      </span><span class="s1">showPosition: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">var pre = this.pastInput();</span><span class="s3">\n        </span><span class="s1">var c = new Array(pre.length + 1).join(</span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return pre + this.upcomingInput() + </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ c + </span><span class="s3">\&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">showPosition</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// test the lexed token: return FALSE when not a match, otherwise return token</span><span class="s3">\n      </span><span class="s1">test_match: /* @__PURE__ */ __name(function(match, indexed_rule) {</span><span class="s3">\n        </span><span class="s1">var token, lines, backup;</span><span class="s3">\n        </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n          </span><span class="s1">backup = {</span><span class="s3">\n            </span><span class="s1">yylineno: this.yylineno,</span><span class="s3">\n            </span><span class="s1">yylloc: {</span><span class="s3">\n              </span><span class="s1">first_line: this.yylloc.first_line,</span><span class="s3">\n              </span><span class="s1">last_line: this.last_line,</span><span class="s3">\n              </span><span class="s1">first_column: this.yylloc.first_column,</span><span class="s3">\n              </span><span class="s1">last_column: this.yylloc.last_column</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">yytext: this.yytext,</span><span class="s3">\n            </span><span class="s1">match: this.match,</span><span class="s3">\n            </span><span class="s1">matches: this.matches,</span><span class="s3">\n            </span><span class="s1">matched: this.matched,</span><span class="s3">\n            </span><span class="s1">yyleng: this.yyleng,</span><span class="s3">\n            </span><span class="s1">offset: this.offset,</span><span class="s3">\n            </span><span class="s1">_more: this._more,</span><span class="s3">\n            </span><span class="s1">_input: this._input,</span><span class="s3">\n            </span><span class="s1">yy: this.yy,</span><span class="s3">\n            </span><span class="s1">conditionStack: this.conditionStack.slice(0),</span><span class="s3">\n            </span><span class="s1">done: this.done</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n            </span><span class="s1">backup.yylloc.range = this.yylloc.range.slice(0);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">lines = match[0].match(/(?:</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n).*/g);</span><span class="s3">\n        </span><span class="s1">if (lines) {</span><span class="s3">\n          </span><span class="s1">this.yylineno += lines.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.yylloc = {</span><span class="s3">\n          </span><span class="s1">first_line: this.yylloc.last_line,</span><span class="s3">\n          </span><span class="s1">last_line: this.yylineno + 1,</span><span class="s3">\n          </span><span class="s1">first_column: this.yylloc.last_column,</span><span class="s3">\n          </span><span class="s1">last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/</span><span class="s3">\\</span><span class="s1">r?</span><span class="s3">\\</span><span class="s1">n?/)[0].length : this.yylloc.last_column + match[0].length</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.yytext += match[0];</span><span class="s3">\n        </span><span class="s1">this.match += match[0];</span><span class="s3">\n        </span><span class="s1">this.matches = match;</span><span class="s3">\n        </span><span class="s1">this.yyleng = this.yytext.length;</span><span class="s3">\n        </span><span class="s1">if (this.options.ranges) {</span><span class="s3">\n          </span><span class="s1">this.yylloc.range = [this.offset, this.offset += this.yyleng];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._more = false;</span><span class="s3">\n        </span><span class="s1">this._backtrack = false;</span><span class="s3">\n        </span><span class="s1">this._input = this._input.slice(match[0].length);</span><span class="s3">\n        </span><span class="s1">this.matched += match[0];</span><span class="s3">\n        </span><span class="s1">token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);</span><span class="s3">\n        </span><span class="s1">if (this.done &amp;&amp; this._input) {</span><span class="s3">\n          </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (token) {</span><span class="s3">\n          </span><span class="s1">return token;</span><span class="s3">\n        </span><span class="s1">} else if (this._backtrack) {</span><span class="s3">\n          </span><span class="s1">for (var k in backup) {</span><span class="s3">\n            </span><span class="s1">this[k] = backup[k];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">test_match</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return next match in input</span><span class="s3">\n      </span><span class="s1">next: /* @__PURE__ */ __name(function() {</span><span class="s3">\n        </span><span class="s1">if (this.done) {</span><span class="s3">\n          </span><span class="s1">return this.EOF;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this._input) {</span><span class="s3">\n          </span><span class="s1">this.done = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var token, match, tempMatch, index;</span><span class="s3">\n        </span><span class="s1">if (!this._more) {</span><span class="s3">\n          </span><span class="s1">this.yytext = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">this.match = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var rules = this._currentRules();</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; rules.length; i++) {</span><span class="s3">\n          </span><span class="s1">tempMatch = this._input.match(this.rules[rules[i]]);</span><span class="s3">\n          </span><span class="s1">if (tempMatch &amp;&amp; (!match || tempMatch[0].length &gt; match[0].length)) {</span><span class="s3">\n            </span><span class="s1">match = tempMatch;</span><span class="s3">\n            </span><span class="s1">index = i;</span><span class="s3">\n            </span><span class="s1">if (this.options.backtrack_lexer) {</span><span class="s3">\n              </span><span class="s1">token = this.test_match(tempMatch, rules[i]);</span><span class="s3">\n              </span><span class="s1">if (token !== false) {</span><span class="s3">\n                </span><span class="s1">return token;</span><span class="s3">\n              </span><span class="s1">} else if (this._backtrack) {</span><span class="s3">\n                </span><span class="s1">match = false;</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else if (!this.options.flex) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (match) {</span><span class="s3">\n          </span><span class="s1">token = this.test_match(match, rules[index]);</span><span class="s3">\n          </span><span class="s1">if (token !== false) {</span><span class="s3">\n            </span><span class="s1">return token;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._input === </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">return this.EOF;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.parseError(</span><span class="s3">\&quot;</span><span class="s1">Lexical error on line </span><span class="s3">\&quot; </span><span class="s1">+ (this.yylineno + 1) + </span><span class="s3">\&quot;</span><span class="s1">. Unrecognized text.</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ this.showPosition(), {</span><span class="s3">\n            </span><span class="s1">text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">token: null,</span><span class="s3">\n            </span><span class="s1">line: this.yylineno</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return next match that has a token</span><span class="s3">\n      </span><span class="s1">lex: /* @__PURE__ */ __name(function lex() {</span><span class="s3">\n        </span><span class="s1">var r = this.next();</span><span class="s3">\n        </span><span class="s1">if (r) {</span><span class="s3">\n          </span><span class="s1">return r;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.lex();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">lex</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)</span><span class="s3">\n      </span><span class="s1">begin: /* @__PURE__ */ __name(function begin(condition) {</span><span class="s3">\n        </span><span class="s1">this.conditionStack.push(condition);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">begin</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// pop the previously active lexer condition state off the condition stack</span><span class="s3">\n      </span><span class="s1">popState: /* @__PURE__ */ __name(function popState() {</span><span class="s3">\n        </span><span class="s1">var n = this.conditionStack.length - 1;</span><span class="s3">\n        </span><span class="s1">if (n &gt; 0) {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack.pop();</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">popState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// produce the lexer rule set which is active for the currently active lexer condition state</span><span class="s3">\n      </span><span class="s1">_currentRules: /* @__PURE__ */ __name(function _currentRules() {</span><span class="s3">\n        </span><span class="s1">if (this.conditionStack.length &amp;&amp; this.conditionStack[this.conditionStack.length - 1]) {</span><span class="s3">\n          </span><span class="s1">return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return this.conditions[</span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">].rules;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">_currentRules</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available</span><span class="s3">\n      </span><span class="s1">topState: /* @__PURE__ */ __name(function topState(n) {</span><span class="s3">\n        </span><span class="s1">n = this.conditionStack.length - 1 - Math.abs(n || 0);</span><span class="s3">\n        </span><span class="s1">if (n &gt;= 0) {</span><span class="s3">\n          </span><span class="s1">return this.conditionStack[n];</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">topState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// alias for begin(condition)</span><span class="s3">\n      </span><span class="s1">pushState: /* @__PURE__ */ __name(function pushState(condition) {</span><span class="s3">\n        </span><span class="s1">this.begin(condition);</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">pushState</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// return the number of states currently on the stack</span><span class="s3">\n      </span><span class="s1">stateStackSize: /* @__PURE__ */ __name(function stateStackSize() {</span><span class="s3">\n        </span><span class="s1">return this.conditionStack.length;</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">stateStackSize</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">options: { </span><span class="s3">\&quot;</span><span class="s1">case-insensitive</span><span class="s3">\&quot;</span><span class="s1">: true },</span><span class="s3">\n      </span><span class="s1">performAction: /* @__PURE__ */ __name(function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {</span><span class="s3">\n        </span><span class="s1">var YYSTATE = YY_START;</span><span class="s3">\n        </span><span class="s1">switch ($avoiding_name_collisions) {</span><span class="s3">\n          </span><span class="s1">case 0:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Found comment</span><span class="s3">\&quot;</span><span class="s1">, yy_.yytext);</span><span class="s3">\n            </span><span class="s1">return 6;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">return 8;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">CLASS</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">return 16;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 5:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Begin icon</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">ICON</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 6:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">SPACELINE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 6;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 7:</span><span class="s3">\n            </span><span class="s1">return 7;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 8:</span><span class="s3">\n            </span><span class="s1">return 15;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 9:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">end icon</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 10:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Exploding node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 11:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Cloud</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 12:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Explosion Bang</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 13:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Cloud Bang</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 14:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 15:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 16:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 17:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return 19;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 18:</span><span class="s3">\n            </span><span class="s1">return 13;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 19:</span><span class="s3">\n            </span><span class="s1">return 22;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 20:</span><span class="s3">\n            </span><span class="s1">return 11;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 21:</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NSTR2</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 22:</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DESCR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 23:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 24:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Starting NSTR</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">this.begin(</span><span class="s3">\&quot;</span><span class="s1">NSTR</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 25:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">description:</span><span class="s3">\&quot;</span><span class="s1">, yy_.yytext);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DESCR</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 26:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 27:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end ))</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 28:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end )</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 29:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end ...</span><span class="s3">\&quot;</span><span class="s1">, yy_.yytext);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 30:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end ((</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 31:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end (-</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 32:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end (-</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 33:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end ((</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 34:</span><span class="s3">\n            </span><span class="s1">this.popState();</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">node end ((</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">NODE_DEND</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 35:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Long description:</span><span class="s3">\&quot;</span><span class="s1">, yy_.yytext);</span><span class="s3">\n            </span><span class="s1">return 20;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 36:</span><span class="s3">\n            </span><span class="s1">yy.getLogger().trace(</span><span class="s3">\&quot;</span><span class="s1">Long description:</span><span class="s3">\&quot;</span><span class="s1">, yy_.yytext);</span><span class="s3">\n            </span><span class="s1">return 20;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">anonymous</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">rules: [/^(?:</span><span class="s3">\\</span><span class="s1">s*%%.*)/i, /^(?:mindmap</span><span class="s3">\\</span><span class="s1">b)/i, /^(?::::)/i, /^(?:.+)/i, /^(?:</span><span class="s3">\\</span><span class="s1">n)/i, /^(?:::icon</span><span class="s3">\\</span><span class="s1">()/i, /^(?:[</span><span class="s3">\\</span><span class="s1">s]+[</span><span class="s3">\\</span><span class="s1">n])/i, /^(?:[</span><span class="s3">\\</span><span class="s1">n]+)/i, /^(?:[^</span><span class="s3">\\</span><span class="s1">)]+)/i, /^(?:</span><span class="s3">\\</span><span class="s1">))/i, /^(?:-</span><span class="s3">\\</span><span class="s1">))/i, /^(?:</span><span class="s3">\\</span><span class="s1">(-)/i, /^(?:</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">))/i, /^(?:</span><span class="s3">\\</span><span class="s1">))/i, /^(?:</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">()/i, /^(?:</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">{)/i, /^(?:</span><span class="s3">\\</span><span class="s1">()/i, /^(?:</span><span class="s3">\\</span><span class="s1">[)/i, /^(?:[</span><span class="s3">\\</span><span class="s1">s]+)/i, /^(?:[^</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">{</span><span class="s3">\\</span><span class="s1">}]+)/i, /^(?:$)/i, /^(?:[</span><span class="s3">\&quot;</span><span class="s1">][`])/i, /^(?:[^`</span><span class="s3">\&quot;</span><span class="s1">]+)/i, /^(?:[`][</span><span class="s3">\&quot;</span><span class="s1">])/i, /^(?:[</span><span class="s3">\&quot;</span><span class="s1">])/i, /^(?:[^</span><span class="s3">\&quot;</span><span class="s1">]+)/i, /^(?:[</span><span class="s3">\&quot;</span><span class="s1">])/i, /^(?:[</span><span class="s3">\\</span><span class="s1">)]</span><span class="s3">\\</span><span class="s1">))/i, /^(?:[</span><span class="s3">\\</span><span class="s1">)])/i, /^(?:[</span><span class="s3">\\</span><span class="s1">]])/i, /^(?:</span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\\</span><span class="s1">})/i, /^(?:</span><span class="s3">\\</span><span class="s1">(-)/i, /^(?:-</span><span class="s3">\\</span><span class="s1">))/i, /^(?:</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">()/i, /^(?:</span><span class="s3">\\</span><span class="s1">()/i, /^(?:[^</span><span class="s3">\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">}]+)/i, /^(?:.+(?!</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">())/i],</span><span class="s3">\n      </span><span class="s1">conditions: { </span><span class="s3">\&quot;</span><span class="s1">CLASS</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [3, 4], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">ICON</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [8, 9], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">NSTR2</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [22, 23], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">NSTR</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [25, 26], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">NODE</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [21, 24, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: false }, </span><span class="s3">\&quot;</span><span class="s1">INITIAL</span><span class="s3">\&quot;</span><span class="s1">: { </span><span class="s3">\&quot;</span><span class="s1">rules</span><span class="s3">\&quot;</span><span class="s1">: [0, 1, 2, 5, 6, 7, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20], </span><span class="s3">\&quot;</span><span class="s1">inclusive</span><span class="s3">\&quot;</span><span class="s1">: true } }</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return lexer2;</span><span class="s3">\n  </span><span class="s1">}();</span><span class="s3">\n  </span><span class="s1">parser2.lexer = lexer;</span><span class="s3">\n  </span><span class="s1">function Parser() {</span><span class="s3">\n    </span><span class="s1">this.yy = {};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">__name(Parser, </span><span class="s3">\&quot;</span><span class="s1">Parser</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">Parser.prototype = parser2;</span><span class="s3">\n  </span><span class="s1">parser2.Parser = Parser;</span><span class="s3">\n  </span><span class="s1">return new Parser();</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n</span><span class="s1">parser.parser = parser;</span><span class="s3">\n</span><span class="s1">var mindmap_default = parser;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/mindmapDb.ts</span><span class="s3">\n</span><span class="s1">var nodes = [];</span><span class="s3">\n</span><span class="s1">var cnt = 0;</span><span class="s3">\n</span><span class="s1">var elements = {};</span><span class="s3">\n</span><span class="s1">var clear = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">nodes = [];</span><span class="s3">\n  </span><span class="s1">cnt = 0;</span><span class="s3">\n  </span><span class="s1">elements = {};</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getParent = /* @__PURE__ */ __name(function(level) {</span><span class="s3">\n  </span><span class="s1">for (let i = nodes.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">if (nodes[i].level &lt; level) {</span><span class="s3">\n      </span><span class="s1">return nodes[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getParent</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getMindmap = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">return nodes.length &gt; 0 ? nodes[0] : null;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getMindmap</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var addNode = /* @__PURE__ */ __name((level, id, descr, type) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">addNode</span><span class="s3">\&quot;</span><span class="s1">, level, id, descr, type);</span><span class="s3">\n  </span><span class="s1">const conf = getConfig();</span><span class="s3">\n  </span><span class="s1">let padding = conf.mindmap?.padding ?? defaultConfig_default.mindmap.padding;</span><span class="s3">\n  </span><span class="s1">switch (type) {</span><span class="s3">\n    </span><span class="s1">case nodeType.ROUNDED_RECT:</span><span class="s3">\n    </span><span class="s1">case nodeType.RECT:</span><span class="s3">\n    </span><span class="s1">case nodeType.HEXAGON:</span><span class="s3">\n      </span><span class="s1">padding *= 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const node = {</span><span class="s3">\n    </span><span class="s1">id: cnt++,</span><span class="s3">\n    </span><span class="s1">nodeId: sanitizeText(id, conf),</span><span class="s3">\n    </span><span class="s1">level,</span><span class="s3">\n    </span><span class="s1">descr: sanitizeText(descr, conf),</span><span class="s3">\n    </span><span class="s1">type,</span><span class="s3">\n    </span><span class="s1">children: [],</span><span class="s3">\n    </span><span class="s1">width: conf.mindmap?.maxNodeWidth ?? defaultConfig_default.mindmap.maxNodeWidth,</span><span class="s3">\n    </span><span class="s1">padding</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">const parent = getParent(level);</span><span class="s3">\n  </span><span class="s1">if (parent) {</span><span class="s3">\n    </span><span class="s1">parent.children.push(node);</span><span class="s3">\n    </span><span class="s1">nodes.push(node);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (nodes.length === 0) {</span><span class="s3">\n      </span><span class="s1">nodes.push(node);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">'There can be only one root. No parent could be found for (</span><span class="s3">\&quot;</span><span class="s1">' + node.descr + '</span><span class="s3">\&quot;</span><span class="s1">)'</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var nodeType = {</span><span class="s3">\n  </span><span class="s1">DEFAULT: 0,</span><span class="s3">\n  </span><span class="s1">NO_BORDER: 0,</span><span class="s3">\n  </span><span class="s1">ROUNDED_RECT: 1,</span><span class="s3">\n  </span><span class="s1">RECT: 2,</span><span class="s3">\n  </span><span class="s1">CIRCLE: 3,</span><span class="s3">\n  </span><span class="s1">CLOUD: 4,</span><span class="s3">\n  </span><span class="s1">BANG: 5,</span><span class="s3">\n  </span><span class="s1">HEXAGON: 6</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getType = /* @__PURE__ */ __name((startStr, endStr) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">In get type</span><span class="s3">\&quot;</span><span class="s1">, startStr, endStr);</span><span class="s3">\n  </span><span class="s1">switch (startStr) {</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return nodeType.RECT;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return endStr === </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">? nodeType.ROUNDED_RECT : nodeType.CLOUD;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">((</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return nodeType.CIRCLE;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return nodeType.CLOUD;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return nodeType.BANG;</span><span class="s3">\n    </span><span class="s1">case </span><span class="s3">\&quot;</span><span class="s1">{{</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n      </span><span class="s1">return nodeType.HEXAGON;</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return nodeType.DEFAULT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getType</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var setElementForId = /* @__PURE__ */ __name((id, element) =&gt; {</span><span class="s3">\n  </span><span class="s1">elements[id] = element;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">setElementForId</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var decorateNode = /* @__PURE__ */ __name((decoration) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (!decoration) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const config = getConfig();</span><span class="s3">\n  </span><span class="s1">const node = nodes[nodes.length - 1];</span><span class="s3">\n  </span><span class="s1">if (decoration.icon) {</span><span class="s3">\n    </span><span class="s1">node.icon = sanitizeText(decoration.icon, config);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (decoration.class) {</span><span class="s3">\n    </span><span class="s1">node.class = sanitizeText(decoration.class, config);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">decorateNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var type2Str = /* @__PURE__ */ __name((type) =&gt; {</span><span class="s3">\n  </span><span class="s1">switch (type) {</span><span class="s3">\n    </span><span class="s1">case nodeType.DEFAULT:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">no-border</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.RECT:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.ROUNDED_RECT:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">rounded-rect</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.CIRCLE:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">circle</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.CLOUD:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">cloud</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.BANG:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bang</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">case nodeType.HEXAGON:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">hexgon</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// cspell: disable-line</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">no-border</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">type2Str</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getLogger = /* @__PURE__ */ __name(() =&gt; log, </span><span class="s3">\&quot;</span><span class="s1">getLogger</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getElementById = /* @__PURE__ */ __name((id) =&gt; elements[id], </span><span class="s3">\&quot;</span><span class="s1">getElementById</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var db = {</span><span class="s3">\n  </span><span class="s1">clear,</span><span class="s3">\n  </span><span class="s1">addNode,</span><span class="s3">\n  </span><span class="s1">getMindmap,</span><span class="s3">\n  </span><span class="s1">nodeType,</span><span class="s3">\n  </span><span class="s1">getType,</span><span class="s3">\n  </span><span class="s1">setElementForId,</span><span class="s3">\n  </span><span class="s1">decorateNode,</span><span class="s3">\n  </span><span class="s1">type2Str,</span><span class="s3">\n  </span><span class="s1">getLogger,</span><span class="s3">\n  </span><span class="s1">getElementById</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var mindmapDb_default = db;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/mindmapRenderer.ts</span><span class="s3">\n</span><span class="s1">import cytoscape from </span><span class="s3">\&quot;</span><span class="s1">cytoscape</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import coseBilkent from </span><span class="s3">\&quot;</span><span class="s1">cytoscape-cose-bilkent</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { select } from </span><span class="s3">\&quot;</span><span class="s1">d3</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/svgDraw.ts</span><span class="s3">\n</span><span class="s1">var MAX_SECTIONS = 12;</span><span class="s3">\n</span><span class="s1">var defaultBkg = /* @__PURE__ */ __name(function(db2, elem, node, section) {</span><span class="s3">\n  </span><span class="s1">const rd = 5;</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\n    \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">`M0 ${node.height - rd} v${-node.height + 2 * rd} q0,-5 5,-5 h${node.width - 2 * rd} q5,0 5,5 v${node.height - rd} H0 Z`</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">line</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-line-</span><span class="s3">\&quot; </span><span class="s1">+ section).attr(</span><span class="s3">\&quot;</span><span class="s1">x1</span><span class="s3">\&quot;</span><span class="s1">, 0).attr(</span><span class="s3">\&quot;</span><span class="s1">y1</span><span class="s3">\&quot;</span><span class="s1">, node.height).attr(</span><span class="s3">\&quot;</span><span class="s1">x2</span><span class="s3">\&quot;</span><span class="s1">, node.width).attr(</span><span class="s3">\&quot;</span><span class="s1">y2</span><span class="s3">\&quot;</span><span class="s1">, node.height);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">defaultBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var rectBkg = /* @__PURE__ */ __name(function(db2, elem, node) {</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, node.height).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, node.width);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">rectBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var cloudBkg = /* @__PURE__ */ __name(function(db2, elem, node) {</span><span class="s3">\n  </span><span class="s1">const w = node.width;</span><span class="s3">\n  </span><span class="s1">const h = node.height;</span><span class="s3">\n  </span><span class="s1">const r1 = 0.15 * w;</span><span class="s3">\n  </span><span class="s1">const r2 = 0.25 * w;</span><span class="s3">\n  </span><span class="s1">const r3 = 0.35 * w;</span><span class="s3">\n  </span><span class="s1">const r4 = 0.2 * w;</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\n    \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">`M0 0 a${r1},${r1} 0 0,1 ${w * 0.25},${-1 * w * 0.1}</span><span class="s3">\n      </span><span class="s1">a${r3},${r3} 1 0,1 ${w * 0.4},${-1 * w * 0.1}</span><span class="s3">\n      </span><span class="s1">a${r2},${r2} 1 0,1 ${w * 0.35},${1 * w * 0.2}</span><span class="s3">\n\n      </span><span class="s1">a${r1},${r1} 1 0,1 ${w * 0.15},${1 * h * 0.35}</span><span class="s3">\n      </span><span class="s1">a${r4},${r4} 1 0,1 ${-1 * w * 0.15},${1 * h * 0.65}</span><span class="s3">\n\n      </span><span class="s1">a${r2},${r1} 1 0,1 ${-1 * w * 0.25},${w * 0.15}</span><span class="s3">\n      </span><span class="s1">a${r3},${r3} 1 0,1 ${-1 * w * 0.5},${0}</span><span class="s3">\n      </span><span class="s1">a${r1},${r1} 1 0,1 ${-1 * w * 0.25},${-1 * w * 0.15}</span><span class="s3">\n\n      </span><span class="s1">a${r1},${r1} 1 0,1 ${-1 * w * 0.1},${-1 * h * 0.35}</span><span class="s3">\n      </span><span class="s1">a${r4},${r4} 1 0,1 ${w * 0.1},${-1 * h * 0.65}</span><span class="s3">\n\n    </span><span class="s1">H0 V0 Z`</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">cloudBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var bangBkg = /* @__PURE__ */ __name(function(db2, elem, node) {</span><span class="s3">\n  </span><span class="s1">const w = node.width;</span><span class="s3">\n  </span><span class="s1">const h = node.height;</span><span class="s3">\n  </span><span class="s1">const r = 0.15 * w;</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\n    \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">`M0 0 a${r},${r} 1 0,0 ${w * 0.25},${-1 * h * 0.1}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${w * 0.25},${0}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${w * 0.25},${0}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${w * 0.25},${1 * h * 0.1}</span><span class="s3">\n\n      </span><span class="s1">a${r},${r} 1 0,0 ${w * 0.15},${1 * h * 0.33}</span><span class="s3">\n      </span><span class="s1">a${r * 0.8},${r * 0.8} 1 0,0 ${0},${1 * h * 0.34}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.15},${1 * h * 0.33}</span><span class="s3">\n\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.25},${h * 0.15}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.25},${0}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.25},${-1 * h * 0.15}</span><span class="s3">\n\n      </span><span class="s1">a${r},${r} 1 0,0 ${-1 * w * 0.1},${-1 * h * 0.33}</span><span class="s3">\n      </span><span class="s1">a${r * 0.8},${r * 0.8} 1 0,0 ${0},${-1 * h * 0.34}</span><span class="s3">\n      </span><span class="s1">a${r},${r} 1 0,0 ${w * 0.1},${-1 * h * 0.33}</span><span class="s3">\n\n    </span><span class="s1">H0 V0 Z`</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">bangBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var circleBkg = /* @__PURE__ */ __name(function(db2, elem, node) {</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">circle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">, node.width / 2);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">circleBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function insertPolygonShape(parent, w, h, points, node) {</span><span class="s3">\n  </span><span class="s1">return parent.insert(</span><span class="s3">\&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">:first-child</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\n    \&quot;</span><span class="s1">points</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">points.map(function(d) {</span><span class="s3">\n      </span><span class="s1">return d.x + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ d.y;</span><span class="s3">\n    </span><span class="s1">}).join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)</span><span class="s3">\n  </span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ (node.width - w) / 2 + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ h + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(insertPolygonShape, </span><span class="s3">\&quot;</span><span class="s1">insertPolygonShape</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var hexagonBkg = /* @__PURE__ */ __name(function(_db, elem, node) {</span><span class="s3">\n  </span><span class="s1">const h = node.height;</span><span class="s3">\n  </span><span class="s1">const f = 4;</span><span class="s3">\n  </span><span class="s1">const m = h / f;</span><span class="s3">\n  </span><span class="s1">const w = node.width - node.padding + 2 * m;</span><span class="s3">\n  </span><span class="s1">const points = [</span><span class="s3">\n    </span><span class="s1">{ x: m, y: 0 },</span><span class="s3">\n    </span><span class="s1">{ x: w - m, y: 0 },</span><span class="s3">\n    </span><span class="s1">{ x: w, y: -h / 2 },</span><span class="s3">\n    </span><span class="s1">{ x: w - m, y: -h },</span><span class="s3">\n    </span><span class="s1">{ x: m, y: -h },</span><span class="s3">\n    </span><span class="s1">{ x: 0, y: -h / 2 }</span><span class="s3">\n  </span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">insertPolygonShape(elem, w, h, points, node);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">hexagonBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var roundedRectBkg = /* @__PURE__ */ __name(function(db2, elem, node) {</span><span class="s3">\n  </span><span class="s1">elem.append(</span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ node.id).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg node-</span><span class="s3">\&quot; </span><span class="s1">+ db2.type2Str(node.type)).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, node.height).attr(</span><span class="s3">\&quot;</span><span class="s1">rx</span><span class="s3">\&quot;</span><span class="s1">, node.padding).attr(</span><span class="s3">\&quot;</span><span class="s1">ry</span><span class="s3">\&quot;</span><span class="s1">, node.padding).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, node.width);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">roundedRectBkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var drawNode = /* @__PURE__ */ __name(async function(db2, elem, node, fullSection, conf) {</span><span class="s3">\n  </span><span class="s1">const htmlLabels = conf.htmlLabels;</span><span class="s3">\n  </span><span class="s1">const section = fullSection % (MAX_SECTIONS - 1);</span><span class="s3">\n  </span><span class="s1">const nodeElem = elem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">node.section = section;</span><span class="s3">\n  </span><span class="s1">let sectionClass = </span><span class="s3">\&quot;</span><span class="s1">section-</span><span class="s3">\&quot; </span><span class="s1">+ section;</span><span class="s3">\n  </span><span class="s1">if (section &lt; 0) {</span><span class="s3">\n    </span><span class="s1">sectionClass += </span><span class="s3">\&quot; </span><span class="s1">section-root</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">nodeElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, (node.class ? node.class + </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">mindmap-node </span><span class="s3">\&quot; </span><span class="s1">+ sectionClass);</span><span class="s3">\n  </span><span class="s1">const bkgElem = nodeElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const textElem = nodeElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const description = node.descr.replace(/(&lt;br</span><span class="s3">\\</span><span class="s1">/*&gt;)/g, </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">await createText(</span><span class="s3">\n    </span><span class="s1">textElem,</span><span class="s3">\n    </span><span class="s1">description,</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">useHtmlLabels: htmlLabels,</span><span class="s3">\n      </span><span class="s1">width: node.width,</span><span class="s3">\n      </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">mindmap-node-label</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">conf</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">if (!htmlLabels) {</span><span class="s3">\n    </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">dy</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">1em</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">alignment-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">dominant-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">text-anchor</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const bbox = textElem.node().getBBox();</span><span class="s3">\n  </span><span class="s1">const [fontSize] = parseFontSize(conf.fontSize);</span><span class="s3">\n  </span><span class="s1">node.height = bbox.height + fontSize * 1.1 * 0.5 + node.padding;</span><span class="s3">\n  </span><span class="s1">node.width = bbox.width + 2 * node.padding;</span><span class="s3">\n  </span><span class="s1">if (node.icon) {</span><span class="s3">\n    </span><span class="s1">if (node.type === db2.nodeType.CIRCLE) {</span><span class="s3">\n      </span><span class="s1">node.height += 50;</span><span class="s3">\n      </span><span class="s1">node.width += 50;</span><span class="s3">\n      </span><span class="s1">const icon = nodeElem.append(</span><span class="s3">\&quot;</span><span class="s1">foreignObject</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">50px</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, node.width).attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">text-align: center;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">icon.append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">icon-container</span><span class="s3">\&quot;</span><span class="s1">).append(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-icon-</span><span class="s3">\&quot; </span><span class="s1">+ section + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ node.icon);</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\n        \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ node.width / 2 + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ (node.height / 2 - 1.5 * node.padding) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">node.width += 50;</span><span class="s3">\n      </span><span class="s1">const orgHeight = node.height;</span><span class="s3">\n      </span><span class="s1">node.height = Math.max(orgHeight, 60);</span><span class="s3">\n      </span><span class="s1">const heightDiff = Math.abs(node.height - orgHeight);</span><span class="s3">\n      </span><span class="s1">const icon = nodeElem.append(</span><span class="s3">\&quot;</span><span class="s1">foreignObject</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">60px</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, node.height).attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">text-align: center;margin-top:</span><span class="s3">\&quot; </span><span class="s1">+ heightDiff / 2 + </span><span class="s3">\&quot;</span><span class="s1">px;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">icon.append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">icon-container</span><span class="s3">\&quot;</span><span class="s1">).append(</span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-icon-</span><span class="s3">\&quot; </span><span class="s1">+ section + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ node.icon);</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\n        \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ (25 + node.width / 2) + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ (heightDiff / 2 + node.padding / 2) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (!htmlLabels) {</span><span class="s3">\n      </span><span class="s1">const dx = node.width / 2;</span><span class="s3">\n      </span><span class="s1">const dy = node.padding / 2;</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ dx + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ dy + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">const dx = (node.width - bbox.width) / 2;</span><span class="s3">\n      </span><span class="s1">const dy = (node.height - bbox.height) / 2;</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ dx + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ dy + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (node.type) {</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.DEFAULT:</span><span class="s3">\n      </span><span class="s1">defaultBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.ROUNDED_RECT:</span><span class="s3">\n      </span><span class="s1">roundedRectBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.RECT:</span><span class="s3">\n      </span><span class="s1">rectBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.CIRCLE:</span><span class="s3">\n      </span><span class="s1">bkgElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ node.width / 2 + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ +node.height / 2 + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">circleBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.CLOUD:</span><span class="s3">\n      </span><span class="s1">cloudBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.BANG:</span><span class="s3">\n      </span><span class="s1">bangBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">case db2.nodeType.HEXAGON:</span><span class="s3">\n      </span><span class="s1">hexagonBkg(db2, bkgElem, node, section);</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">db2.setElementForId(node.id, nodeElem);</span><span class="s3">\n  </span><span class="s1">return node.height;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">drawNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var positionNode = /* @__PURE__ */ __name(function(db2, node) {</span><span class="s3">\n  </span><span class="s1">const nodeElem = db2.getElementById(node.id);</span><span class="s3">\n  </span><span class="s1">const x = node.x || 0;</span><span class="s3">\n  </span><span class="s1">const y = node.y || 0;</span><span class="s3">\n  </span><span class="s1">nodeElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ x + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ y + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">positionNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/mindmapRenderer.ts</span><span class="s3">\n</span><span class="s1">cytoscape.use(coseBilkent);</span><span class="s3">\n</span><span class="s1">async function drawNodes(db2, svg, mindmap, section, conf) {</span><span class="s3">\n  </span><span class="s1">await drawNode(db2, svg, mindmap, section, conf);</span><span class="s3">\n  </span><span class="s1">if (mindmap.children) {</span><span class="s3">\n    </span><span class="s1">await Promise.all(</span><span class="s3">\n      </span><span class="s1">mindmap.children.map(</span><span class="s3">\n        </span><span class="s1">(child, index) =&gt; drawNodes(db2, svg, child, section &lt; 0 ? index : section, conf)</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(drawNodes, </span><span class="s3">\&quot;</span><span class="s1">drawNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function drawEdges(edgesEl, cy) {</span><span class="s3">\n  </span><span class="s1">cy.edges().map((edge, id) =&gt; {</span><span class="s3">\n    </span><span class="s1">const data = edge.data();</span><span class="s3">\n    </span><span class="s1">if (edge[0]._private.bodyBounds) {</span><span class="s3">\n      </span><span class="s1">const bounds = edge[0]._private.rscratch;</span><span class="s3">\n      </span><span class="s1">log.trace(</span><span class="s3">\&quot;</span><span class="s1">Edge: </span><span class="s3">\&quot;</span><span class="s1">, id, data);</span><span class="s3">\n      </span><span class="s1">edgesEl.insert(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\n        \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">`M ${bounds.startX},${bounds.startY} L ${bounds.midX},${bounds.midY} L${bounds.endX},${bounds.endY} `</span><span class="s3">\n      </span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">edge section-edge-</span><span class="s3">\&quot; </span><span class="s1">+ data.section + </span><span class="s3">\&quot; </span><span class="s1">edge-depth-</span><span class="s3">\&quot; </span><span class="s1">+ data.depth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(drawEdges, </span><span class="s3">\&quot;</span><span class="s1">drawEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function addNodes(mindmap, cy, conf, level) {</span><span class="s3">\n  </span><span class="s1">cy.add({</span><span class="s3">\n    </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">data: {</span><span class="s3">\n      </span><span class="s1">id: mindmap.id.toString(),</span><span class="s3">\n      </span><span class="s1">labelText: mindmap.descr,</span><span class="s3">\n      </span><span class="s1">height: mindmap.height,</span><span class="s3">\n      </span><span class="s1">width: mindmap.width,</span><span class="s3">\n      </span><span class="s1">level,</span><span class="s3">\n      </span><span class="s1">nodeId: mindmap.id,</span><span class="s3">\n      </span><span class="s1">padding: mindmap.padding,</span><span class="s3">\n      </span><span class="s1">type: mindmap.type</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">position: {</span><span class="s3">\n      </span><span class="s1">x: mindmap.x,</span><span class="s3">\n      </span><span class="s1">y: mindmap.y</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">if (mindmap.children) {</span><span class="s3">\n    </span><span class="s1">mindmap.children.forEach((child) =&gt; {</span><span class="s3">\n      </span><span class="s1">addNodes(child, cy, conf, level + 1);</span><span class="s3">\n      </span><span class="s1">cy.add({</span><span class="s3">\n        </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">edges</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">data: {</span><span class="s3">\n          </span><span class="s1">id: `${mindmap.id}_${child.id}`,</span><span class="s3">\n          </span><span class="s1">source: mindmap.id,</span><span class="s3">\n          </span><span class="s1">target: child.id,</span><span class="s3">\n          </span><span class="s1">depth: level,</span><span class="s3">\n          </span><span class="s1">section: child.section</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(addNodes, </span><span class="s3">\&quot;</span><span class="s1">addNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function layoutMindmap(node, conf) {</span><span class="s3">\n  </span><span class="s1">return new Promise((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">const renderEl = select(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cy</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">display:none</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const cy = cytoscape({</span><span class="s3">\n      </span><span class="s1">container: document.getElementById(</span><span class="s3">\&quot;</span><span class="s1">cy</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">// container to render in</span><span class="s3">\n      </span><span class="s1">style: [</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">edge</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            \&quot;</span><span class="s1">curve-style</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">bezier</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">renderEl.remove();</span><span class="s3">\n    </span><span class="s1">addNodes(node, cy, conf, 0);</span><span class="s3">\n    </span><span class="s1">cy.nodes().forEach(function(n) {</span><span class="s3">\n      </span><span class="s1">n.layoutDimensions = () =&gt; {</span><span class="s3">\n        </span><span class="s1">const data = n.data();</span><span class="s3">\n        </span><span class="s1">return { w: data.width, h: data.height };</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">cy.layout({</span><span class="s3">\n      </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">cose-bilkent</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">// @ts-ignore Types for cose-bilkent are not correct?</span><span class="s3">\n      </span><span class="s1">quality: </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">styleEnabled: false,</span><span class="s3">\n      </span><span class="s1">animate: false</span><span class="s3">\n    </span><span class="s1">}).run();</span><span class="s3">\n    </span><span class="s1">cy.ready((e) =&gt; {</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Ready</span><span class="s3">\&quot;</span><span class="s1">, e);</span><span class="s3">\n      </span><span class="s1">resolve(cy);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(layoutMindmap, </span><span class="s3">\&quot;</span><span class="s1">layoutMindmap</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function positionNodes(db2, cy) {</span><span class="s3">\n  </span><span class="s1">cy.nodes().map((node, id) =&gt; {</span><span class="s3">\n    </span><span class="s1">const data = node.data();</span><span class="s3">\n    </span><span class="s1">data.x = node.position().x;</span><span class="s3">\n    </span><span class="s1">data.y = node.position().y;</span><span class="s3">\n    </span><span class="s1">positionNode(db2, data);</span><span class="s3">\n    </span><span class="s1">const el = db2.getElementById(data.nodeId);</span><span class="s3">\n    </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Id:</span><span class="s3">\&quot;</span><span class="s1">, id, </span><span class="s3">\&quot;</span><span class="s1">Position: (</span><span class="s3">\&quot;</span><span class="s1">, node.position().x, </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">, node.position().y, </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">, data);</span><span class="s3">\n    </span><span class="s1">el.attr(</span><span class="s3">\n      \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">`translate(${node.position().x - data.width / 2}, ${node.position().y - data.height / 2})`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">el.attr(</span><span class="s3">\&quot;</span><span class="s1">attr</span><span class="s3">\&quot;</span><span class="s1">, `apa-${id})`);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(positionNodes, </span><span class="s3">\&quot;</span><span class="s1">positionNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var draw = /* @__PURE__ */ __name(async (text, id, _version, diagObj) =&gt; {</span><span class="s3">\n  </span><span class="s1">log.debug(</span><span class="s3">\&quot;</span><span class="s1">Rendering mindmap diagram</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">+ text);</span><span class="s3">\n  </span><span class="s1">const db2 = diagObj.db;</span><span class="s3">\n  </span><span class="s1">const mm = db2.getMindmap();</span><span class="s3">\n  </span><span class="s1">if (!mm) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const conf = getConfig();</span><span class="s3">\n  </span><span class="s1">conf.htmlLabels = false;</span><span class="s3">\n  </span><span class="s1">const svg = selectSvgElement(id);</span><span class="s3">\n  </span><span class="s1">const edgesElem = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">edgesElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">mindmap-edges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const nodesElem = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">nodesElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">mindmap-nodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">await drawNodes(db2, nodesElem, mm, -1, conf);</span><span class="s3">\n  </span><span class="s1">const cy = await layoutMindmap(mm, conf);</span><span class="s3">\n  </span><span class="s1">drawEdges(edgesElem, cy);</span><span class="s3">\n  </span><span class="s1">positionNodes(db2, cy);</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox(</span><span class="s3">\n    </span><span class="s1">void 0,</span><span class="s3">\n    </span><span class="s1">svg,</span><span class="s3">\n    </span><span class="s1">conf.mindmap?.padding ?? defaultConfig_default.mindmap.padding,</span><span class="s3">\n    </span><span class="s1">conf.mindmap?.useMaxWidth ?? defaultConfig_default.mindmap.useMaxWidth</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var mindmapRenderer_default = {</span><span class="s3">\n  </span><span class="s1">draw</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/styles.ts</span><span class="s3">\n</span><span class="s1">import { darken, lighten, isDark } from </span><span class="s3">\&quot;</span><span class="s1">khroma</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">var genSections = /* @__PURE__ */ __name((options) =&gt; {</span><span class="s3">\n  </span><span class="s1">let sections = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; options.THEME_COLOR_LIMIT; i++) {</span><span class="s3">\n    </span><span class="s1">options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i] = options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i] || options[</span><span class="s3">\&quot;</span><span class="s1">cScaleInv</span><span class="s3">\&quot; </span><span class="s1">+ i];</span><span class="s3">\n    </span><span class="s1">if (isDark(options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i])) {</span><span class="s3">\n      </span><span class="s1">options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i] = lighten(options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i], 20);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i] = darken(options[</span><span class="s3">\&quot;</span><span class="s1">lineColor</span><span class="s3">\&quot; </span><span class="s1">+ i], 20);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; options.THEME_COLOR_LIMIT; i++) {</span><span class="s3">\n    </span><span class="s1">const sw = </span><span class="s3">\&quot;\&quot; </span><span class="s1">+ (17 - 3 * i);</span><span class="s3">\n    </span><span class="s1">sections += `</span><span class="s3">\n    </span><span class="s1">.section-${i - 1} rect, .section-${i - 1} path, .section-${i - 1} circle, .section-${i - 1} polygon, .section-${i - 1} path  {</span><span class="s3">\n      </span><span class="s1">fill: ${options[</span><span class="s3">\&quot;</span><span class="s1">cScale</span><span class="s3">\&quot; </span><span class="s1">+ i]};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.section-${i - 1} text {</span><span class="s3">\n     </span><span class="s1">fill: ${options[</span><span class="s3">\&quot;</span><span class="s1">cScaleLabel</span><span class="s3">\&quot; </span><span class="s1">+ i]};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.node-icon-${i - 1} {</span><span class="s3">\n      </span><span class="s1">font-size: 40px;</span><span class="s3">\n      </span><span class="s1">color: ${options[</span><span class="s3">\&quot;</span><span class="s1">cScaleLabel</span><span class="s3">\&quot; </span><span class="s1">+ i]};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.section-edge-${i - 1}{</span><span class="s3">\n      </span><span class="s1">stroke: ${options[</span><span class="s3">\&quot;</span><span class="s1">cScale</span><span class="s3">\&quot; </span><span class="s1">+ i]};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.edge-depth-${i - 1}{</span><span class="s3">\n      </span><span class="s1">stroke-width: ${sw};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.section-${i - 1} line {</span><span class="s3">\n      </span><span class="s1">stroke: ${options[</span><span class="s3">\&quot;</span><span class="s1">cScaleInv</span><span class="s3">\&quot; </span><span class="s1">+ i]} ;</span><span class="s3">\n      </span><span class="s1">stroke-width: 3;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">.disabled, .disabled circle, .disabled text {</span><span class="s3">\n      </span><span class="s1">fill: lightgray;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">.disabled text {</span><span class="s3">\n      </span><span class="s1">fill: #efefef;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">`;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return sections;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">genSections</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getStyles = /* @__PURE__ */ __name((options) =&gt; `</span><span class="s3">\n  </span><span class="s1">.edge {</span><span class="s3">\n    </span><span class="s1">stroke-width: 3;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">${genSections(options)}</span><span class="s3">\n  </span><span class="s1">.section-root rect, .section-root path, .section-root circle, .section-root polygon  {</span><span class="s3">\n    </span><span class="s1">fill: ${options.git0};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">.section-root text {</span><span class="s3">\n    </span><span class="s1">fill: ${options.gitBranchLabel0};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">.icon-container {</span><span class="s3">\n    </span><span class="s1">height:100%;</span><span class="s3">\n    </span><span class="s1">display: flex;</span><span class="s3">\n    </span><span class="s1">justify-content: center;</span><span class="s3">\n    </span><span class="s1">align-items: center;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">.edge {</span><span class="s3">\n    </span><span class="s1">fill: none;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">.mindmap-node-label {</span><span class="s3">\n    </span><span class="s1">dy: 1em;</span><span class="s3">\n    </span><span class="s1">alignment-baseline: middle;</span><span class="s3">\n    </span><span class="s1">text-anchor: middle;</span><span class="s3">\n    </span><span class="s1">dominant-baseline: middle;</span><span class="s3">\n    </span><span class="s1">text-align: center;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`, </span><span class="s3">\&quot;</span><span class="s1">getStyles</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var styles_default = getStyles;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/mindmap/mindmap-definition.ts</span><span class="s3">\n</span><span class="s1">var diagram = {</span><span class="s3">\n  </span><span class="s1">db: mindmapDb_default,</span><span class="s3">\n  </span><span class="s1">renderer: mindmapRenderer_default,</span><span class="s3">\n  </span><span class="s1">parser: mindmap_default,</span><span class="s3">\n  </span><span class="s1">styles: styles_default</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">diagram</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>