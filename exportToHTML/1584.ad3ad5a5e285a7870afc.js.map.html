<html>
<head>
<title>1584.ad3ad5a5e285a7870afc.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
1584.ad3ad5a5e285a7870afc.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;1584.ad3ad5a5e285a7870afc.js?v=ad3ad5a5e285a7870afc&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAkG;AAC2C;AACZ;AAC/C;AAC1C;;AAExC;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,oDAAK;AAChB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,yCAAyC,mDAAQ;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAW;AACxB,kCAAkC,0DAAW,sBAAsB,QAAQ,4BAA4B;AACvG;AACA;AACA;AACA,YAAY,0DAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA,8BAA8B,8BAA8B;AAC5D;AACA;AACA,kCAAkC,mDAAQ;AAC1C;AACA;AACA;AACA;AACA,0CAA0C,sCAAsC;AAChF;AACA,sCAAsC,oCAAoC;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA,kCAAkC,+CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iCAAiC,0DAAW;AAC5C;AACA;AACA;AACA,8BAA8B,MAAM,6BAA6B,mDAAQ;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,+CAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mBAAmB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,+CAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,+CAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,6DAA6D,uDAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,4CAA4C;AACjF;AACA;AACA,qDAAqD,uDAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8CAA8C;AAC5D;AACA;AACA;AACA,gFAAgF,wBAAwB;AACxG,wBAAwB,uDAAY;AACpC,mBAAmB,+CAAI;AACvB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,iDAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+CAAI,CAAC,mDAAQ;AAChD,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,WAAW,uDAAY,4BAA4B,4CAA4C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oFAAoF,mBAAmB;AACvG;AACA;AACA;AACA;AACA;AACA,8BAA8B,yDAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,4DAA4D;AAC/G,SAAS;AACT;AACA;AACA;AACA;AACA,iCAAiC,wDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF;AACA;AACA;AACA;AACA,oBAAoB;AACpB,cAAc,mBAAmB,aAAa;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,iEAAiE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,qBAAqB,UAAU;AAC/B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,oDAAK;AACnC,yBAAyB,gDAAgD;AACzE;AACA;AACA;AACA,QAAQ,wDAAU;AAClB;AACA,yCAAyC,6BAA6B;AACtE,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,qBAAqB,YAAY;AACjJ;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,oDAAK;AACxC;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAK;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAW;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gCAAgC,QAAQ,qEAAqE;AAC1J;AACA,yBAAyB,UAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAA2D;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qCAAqC;AACnD;AACA;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8DAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc,aAAa;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,mDAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mBAAmB;AACjD;AACA,qCAAqC,QAAQ;AAC7C,sBAAsB;AACtB;AACA;AACA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mDAAQ;AAClD;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,KAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,2BAA2B,kCAAkC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oBAAoB,IAAI;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,WAAW,0DAAW;AACtB;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2DAA2D;AAC1F;AACA,uCAAuC,2BAA2B;AAClE,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mDAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,8DAA8D;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0DAAW,UAAU,eAAe;AACpE;AACA;AACA;AACA,kCAAkC,0DAAW,UAAU,eAAe;AACtE;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yDAAU;AACzC;AACA,eAAe,wDAAU;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA,oBAAoB,wDAAU,WAAW,uEAAuE;AAChH,yCAAyC,+CAA+C;AACxF;AACA;AACA,yCAAyC;AACzC,oEAAoE;AACpE;AACA;AACA;AACA;AACA,uCAAuC,OAAO;AAC9C,mDAAmD;AACnD,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,KAAK;AACL,kBAAkB,wDAAU;AAC5B;AACA;AACA,4DAA4D,wBAAwB;AACpF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAU;AACzB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,4CAA4C,uDAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,KAAK;AACL;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,uBAAuB;AACvB;AACA;AACA;AACA,gEAAgE,0DAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,qFAAqF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,WAAW,wDAAU,gBAAgB,6DAA6D,EAAE,UAAU,EAAE,yBAAyB,EAAE,OAAO;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,+BAA+B,UAAU,KAAK;AAC1G,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2CAA2C;AACnE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,sDAAsD;AAC5D,MAAM,wDAAwD;AAC9D,MAAM,iCAAiC;AACvC,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,oDAAK;AACrC,sBAAsB,OAAO,gEAAa;AAC1C,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;AACA;AACA,4BAA4B,kCAAkC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wDAAU,WAAW,uCAAuC,wDAAU;AACtG,sBAAsB;AACtB,OAAO;AACP,iCAAiC,wDAAU;AAC3C;AACA;AACA;AACA;AACA,gBAAgB;AAChB,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,mDAAmD;AACnD;AACA,kBAAkB,wDAAU;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,8DAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,UAAU,mBAAmB;AAC7B;AACA;AACA,QAAQ,wDAAM;AACd;AACA,4BAA4B,QAAQ,wFAAwF,uDAAQ,SAAS;AAC7I;AACA;AACA,aAAa;AACb,4DAA4D,uBAAuB;AACnF;AACA;AACA;AACA;AACA,wCAAwC,kCAAkC;AAC1E;AACA;AACA;AACA;AACA,wCAAwC,+BAA+B;AACvE;AACA;AACA;AACA,mBAAmB;AACnB,SAAS;AACT;AACA;AACA;AACA,iCAAiC,wDAAU;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAc;AACnC;AACA,sDAAsD,WAAW,WAAW;AAC5E,SAAS;AACT;AACA,SAAS;AACT,oCAAoC,2DAAW;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA,sCAAsC,oDAAK;AAC3C,yCAAyC,oDAAK;AAC9C,sBAAsB;AACtB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAU;AAC/B;AACA;AACA;AACA;AACA;AACA,4CAA4C,wDAAU;AACtD,+BAA+B,wDAAU;AACzC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wDAAU;AAC7B,0BAA0B,8DAAe;AACzC,mBAAmB,WAAW;AAC9B,YAAY,+DAAa;AACzB,wFAAwF,wDAAU,QAAQ,cAAc;AACxH,aAAa;AACb;AACA;AACA;AACA;AACA,qCAAqC,mDAAI,mBAAmB,wDAAU;AACtE;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,MAAM,KAAK,kDAAI;AACf,0BAA0B;AAC1B,MAAM,KAAK,kDAAI;AACf,qCAAqC;AACrC,MAAM,KAAK,kDAAI;AACf;AACA,4BAA4B;AAC5B,MAAM,KAAK,kDAAI;AACf,6BAA6B;AAC7B,MAAM,KAAK,kDAAI;AACf,4BAA4B;AAC5B,MAAM,KAAK,kDAAI;AACf,wCAAwC;AACxC,MAAM,KAAK,kDAAI;AACf,uBAAuB;AACvB,MAAM,MAAM,kDAAI,OAAO,kDAAI,OAAO,kDAAI,MAAM,kDAAI,mBAAmB,kDAAI;AACvE,uBAAuB;AACvB,MAAM,MAAM,kDAAI,UAAU,kDAAI;AAC9B,uBAAuB;AACvB,MAAM,MAAM,kDAAI,SAAS,kDAAI;AAC7B,uBAAuB;AACvB,MAAM,MAAM,kDAAI,SAAS,kDAAI,sBAAsB,kDAAI,SAAS,kDAAI;AACpE,uBAAuB;AACvB,MAAM,kBAAkB,kDAAI,YAAY,kDAAI;AAC5C,uBAAuB;AACvB,MAAM,kBAAkB,kDAAI,OAAO,kDAAI;AACvC,uBAAuB;AACvB,MAAM,MAAM,kDAAI,WAAW,kDAAI;AAC/B,uBAAuB;AACvB,MAAM,KAAK,kDAAI;AACf,uBAAuB;AACvB,MAAM,mBAAmB,kDAAI,SAAS,kDAAI,gBAAgB,kDAAI;AAC9D,uBAAuB;AACvB,MAAM,kBAAkB,kDAAI,YAAY,kDAAI;AAC5C,uBAAuB;AACvB,MAAM,KAAK,kDAAI;AACf,uBAAuB;AACvB,MAAM,KAAK,kDAAI;AACf;AACA;;AAEA,+BAA+B,wDAAU;AACzC,0CAA0C,8BAA8B;AACxE,6CAA6C;AAC7C,CAAC;AACD,wDAAwD;AACxD,2CAA2C,oDAAK;AAChD;AACA,eAAe,gEAAa;AAC5B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD,kCAAkC,wDAAU,QAAQ,6BAA6B,kCAAkC,wDAAU,QAAQ,gCAAgC;AACrK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,yDAAU;AACpD,eAAe,OAAO,wDAAU,QAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wDAAU;AACzB,KAAK;AACL,kBAAkB,wDAAU;AAC5B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,mDAAQ;AACvD;AACA,qCAAqC,mDAAQ,YAAY,mDAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA,yBAAyB,KAAK;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sCAAsC,yCAAyC;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,yCAAyC;AACzH;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,2BAA2B,mDAAmD;AAC9E;AACA;AACA;AACA;AACA,wFAAwF,YAAY;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,yBAAyB,0BAA0B,4CAA4C;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oCAAoC;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iDAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mDAAQ,GAAG,eAAe;AACxD;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,cAAc,sBAAsB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,iBAAiB;AACjB,2CAA2C,QAAQ;AACnD;AACA,qCAAqC,+CAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,QAAQ;AACnD;AACA,yCAAyC,+CAAI;AAC7C;AACA;AACA;AACA,sBAAsB,+CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa,yFAAyF,+CAAI;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,YAAY,iCAAiC,eAAe;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+CAAI;AACvB;AACA;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mDAAQ;AAC3B,iCAAiC,kDAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kDAAI;AAC5C;AACA,8DAA8D,KAAK;AACnE;AACA;AACA;AACA,kDAAkD,MAAM;AACxD;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,mDAAQ;AACpC;AACA;AACA,gBAAgB,2DAAS,GAAG,gBAAgB;AAC5C,KAAK;AACL;AACA;AACA;AACA;AACA,eAAe,mDAAQ,UAAU;AACjC;AACA;AACA,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,oDAAK,UAAU,wCAAwC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,kCAAkC,wDAAU;AAC5C;AACA;AACA,kCAAkC,uDAAS;AAC3C,6BAA6B,wDAAU;AACvC;AACA;AACA,kGAAkG,wDAAU;AAC5G;AACA;AACA;AACA,yCAAyC,uDAAS;AAClD,+BAA+B,wDAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,0IAA0I,wDAAU;AACpJ;AACA,gBAAgB,wDAAU;AAC1B,YAAY,mDAAI,QAAQ,wDAAU;AAClC;AACA,CAAC;AACD;AACA,mBAAmB,8DAAe;AAClC;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA,yCAAyC,mDAAQ;AACjD;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,yCAAyC,oCAAoC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,wDAAU,QAAQ,gDAAgD,YAAY,eAAe,uDAAS,MAAM;AAClI,sBAAsB,wDAAU,QAAQ,gDAAgD,YAAY,eAAe,uDAAS,MAAM;AAClI,uBAAuB,wDAAU,QAAQ,gDAAgD,aAAa,qBAAqB;AAC3H;;AAEwyB;;;;;;;;;;;ACrmFxyB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,0BAA0B,2BAA2B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ;;AAEjB;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV,8GAA8G;AAC9G;AACA;AACA;AACA;AACA,uBAAuB,wBAAwB;AAC/C;AACA;;AAEA;AACA;;AAEA;AACA;AACA,eAAe;;AAEf;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2EAA2E,eAAe;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kDAAkD;AAClD,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D;AAC3D,IAAI,iBAAiB;AACrB;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,yBAAyB,KAAK&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/language/dist/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/style-mod/src/style-mod.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { NodeProp, IterMode, Tree, TreeFragment, Parser, NodeType, NodeSet } from '@lezer/common';</span><span class="s3">\n</span><span class="s1">import { StateEffect, StateField, Facet, EditorState, countColumn, combineConfig, RangeSet, RangeSetBuilder, Prec } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import { ViewPlugin, logException, EditorView, Decoration, WidgetType, gutter, GutterMarker, Direction } from '@codemirror/view';</span><span class="s3">\n</span><span class="s1">import { tags, tagHighlighter, highlightTree, styleTags } from '@lezer/highlight';</span><span class="s3">\n</span><span class="s1">import { StyleModule } from 'style-mod';</span><span class="s3">\n\n</span><span class="s1">var _a;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Node prop stored in a parser's top syntax node to provide the</span><span class="s3">\n</span><span class="s1">facet that stores language-specific data for that language.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const languageDataProp = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Helper function to define a facet (to be added to the top syntax</span><span class="s3">\n</span><span class="s1">node(s) for a language via</span><span class="s3">\n</span><span class="s1">[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be</span><span class="s3">\n</span><span class="s1">used to associate language data with the language. You</span><span class="s3">\n</span><span class="s1">probably only need this when subclassing</span><span class="s3">\n</span><span class="s1">[`Language`](https://codemirror.net/6/docs/ref/#language.Language).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function defineLanguageFacet(baseData) {</span><span class="s3">\n    </span><span class="s1">return Facet.define({</span><span class="s3">\n        </span><span class="s1">combine: baseData ? values =&gt; values.concat(baseData) : undefined</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Syntax node prop used to register sublanguages. Should be added to</span><span class="s3">\n</span><span class="s1">the top level node type for the language.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const sublanguageProp = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A language object manages parsing and per-language</span><span class="s3">\n</span><span class="s1">[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is</span><span class="s3">\n</span><span class="s1">managed as a [Lezer](https://lezer.codemirror.net) tree. The class</span><span class="s3">\n</span><span class="s1">can be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)</span><span class="s3">\n</span><span class="s1">subclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or</span><span class="s3">\n</span><span class="s1">via the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass</span><span class="s3">\n</span><span class="s1">for stream parsers.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Language {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Construct a language object. If you need to invoke this</span><span class="s3">\n    </span><span class="s1">directly, first define a data facet with</span><span class="s3">\n    </span><span class="s1">[`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then</span><span class="s3">\n    </span><span class="s1">configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it</span><span class="s3">\n    </span><span class="s1">to the language's outer syntax node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet</span><span class="s3">\n    </span><span class="s1">used for this language.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">data, parser, extraExtensions = [], </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A language name.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">name = </span><span class="s3">\&quot;\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">this.data = data;</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">// Kludge to define EditorState.tree as a debugging helper,</span><span class="s3">\n        </span><span class="s1">// without the EditorState package actually knowing about</span><span class="s3">\n        </span><span class="s1">// languages and lezer trees.</span><span class="s3">\n        </span><span class="s1">if (!EditorState.prototype.hasOwnProperty(</span><span class="s3">\&quot;</span><span class="s1">tree</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">Object.defineProperty(EditorState.prototype, </span><span class="s3">\&quot;</span><span class="s1">tree</span><span class="s3">\&quot;</span><span class="s1">, { get() { return syntaxTree(this); } });</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.extension = [</span><span class="s3">\n            </span><span class="s1">language.of(this),</span><span class="s3">\n            </span><span class="s1">EditorState.languageData.of((state, pos, side) =&gt; {</span><span class="s3">\n                </span><span class="s1">let top = topNodeAt(state, pos, side), data = top.type.prop(languageDataProp);</span><span class="s3">\n                </span><span class="s1">if (!data)</span><span class="s3">\n                    </span><span class="s1">return [];</span><span class="s3">\n                </span><span class="s1">let base = state.facet(data), sub = top.type.prop(sublanguageProp);</span><span class="s3">\n                </span><span class="s1">if (sub) {</span><span class="s3">\n                    </span><span class="s1">let innerNode = top.resolve(pos - top.from, side);</span><span class="s3">\n                    </span><span class="s1">for (let sublang of sub)</span><span class="s3">\n                        </span><span class="s1">if (sublang.test(innerNode, state)) {</span><span class="s3">\n                            </span><span class="s1">let data = state.facet(sublang.facet);</span><span class="s3">\n                            </span><span class="s1">return sublang.type == </span><span class="s3">\&quot;</span><span class="s1">replace</span><span class="s3">\&quot; </span><span class="s1">? data : data.concat(base);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return base;</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">].concat(extraExtensions);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Query whether this language is active at the given position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isActiveAt(state, pos, side = -1) {</span><span class="s3">\n        </span><span class="s1">return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the document regions that were parsed using this language.</span><span class="s3">\n    </span><span class="s1">The returned regions will _include_ any nested languages rooted</span><span class="s3">\n    </span><span class="s1">in this language, when those exist.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">findRegions(state) {</span><span class="s3">\n        </span><span class="s1">let lang = state.facet(language);</span><span class="s3">\n        </span><span class="s1">if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data)</span><span class="s3">\n            </span><span class="s1">return [{ from: 0, to: state.doc.length }];</span><span class="s3">\n        </span><span class="s1">if (!lang || !lang.allowsNesting)</span><span class="s3">\n            </span><span class="s1">return [];</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">let explore = (tree, from) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (tree.prop(languageDataProp) == this.data) {</span><span class="s3">\n                </span><span class="s1">result.push({ from, to: from + tree.length });</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let mount = tree.prop(NodeProp.mounted);</span><span class="s3">\n            </span><span class="s1">if (mount) {</span><span class="s3">\n                </span><span class="s1">if (mount.tree.prop(languageDataProp) == this.data) {</span><span class="s3">\n                    </span><span class="s1">if (mount.overlay)</span><span class="s3">\n                        </span><span class="s1">for (let r of mount.overlay)</span><span class="s3">\n                            </span><span class="s1">result.push({ from: r.from + from, to: r.to + from });</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">result.push({ from: from, to: from + tree.length });</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (mount.overlay) {</span><span class="s3">\n                    </span><span class="s1">let size = result.length;</span><span class="s3">\n                    </span><span class="s1">explore(mount.tree, mount.overlay[0].from + from);</span><span class="s3">\n                    </span><span class="s1">if (result.length &gt; size)</span><span class="s3">\n                        </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; tree.children.length; i++) {</span><span class="s3">\n                </span><span class="s1">let ch = tree.children[i];</span><span class="s3">\n                </span><span class="s1">if (ch instanceof Tree)</span><span class="s3">\n                    </span><span class="s1">explore(ch, tree.positions[i] + from);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">explore(syntaxTree(state), 0);</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether this language allows nested languages. The</span><span class="s3">\n    </span><span class="s1">default implementation returns true.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get allowsNesting() { return true; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">@internal</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Language.setState = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">function topNodeAt(state, pos, side) {</span><span class="s3">\n    </span><span class="s1">let topLang = state.facet(language), tree = syntaxTree(state).topNode;</span><span class="s3">\n    </span><span class="s1">if (!topLang || topLang.allowsNesting) {</span><span class="s3">\n        </span><span class="s1">for (let node = tree; node; node = node.enter(pos, side, IterMode.ExcludeBuffers))</span><span class="s3">\n            </span><span class="s1">if (node.type.isTop)</span><span class="s3">\n                </span><span class="s1">tree = node;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tree;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer</span><span class="s3">\n</span><span class="s1">[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)</span><span class="s3">\n</span><span class="s1">parsers.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LRLanguage extends Language {</span><span class="s3">\n    </span><span class="s1">constructor(data, parser, name) {</span><span class="s3">\n        </span><span class="s1">super(data, parser, [], name);</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a language from a parser.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(spec) {</span><span class="s3">\n        </span><span class="s1">let data = defineLanguageFacet(spec.languageData);</span><span class="s3">\n        </span><span class="s1">return new LRLanguage(data, spec.parser.configure({</span><span class="s3">\n            </span><span class="s1">props: [languageDataProp.add(type =&gt; type.isTop ? data : undefined)]</span><span class="s3">\n        </span><span class="s1">}), spec.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a new instance of this language with a reconfigured</span><span class="s3">\n    </span><span class="s1">version of its parser and optionally a new name.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">configure(options, name) {</span><span class="s3">\n        </span><span class="s1">return new LRLanguage(this.data, this.parser.configure(options), name || this.name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get allowsNesting() { return this.parser.hasWrappers(); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the syntax tree for a state, which is the current (possibly</span><span class="s3">\n</span><span class="s1">incomplete) parse tree of the active</span><span class="s3">\n</span><span class="s1">[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no</span><span class="s3">\n</span><span class="s1">language available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function syntaxTree(state) {</span><span class="s3">\n    </span><span class="s1">let field = state.field(Language.state, false);</span><span class="s3">\n    </span><span class="s1">return field ? field.tree : Tree.empty;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Try to get a parse tree that spans at least up to `upto`. The</span><span class="s3">\n</span><span class="s1">method will do at most `timeout` milliseconds of work to parse</span><span class="s3">\n</span><span class="s1">up to that point if the tree isn't already available.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function ensureSyntaxTree(state, upto, timeout = 50) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;</span><span class="s3">\n    </span><span class="s1">if (!parse)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let oldVieport = parse.viewport;</span><span class="s3">\n    </span><span class="s1">parse.updateViewport({ from: 0, to: upto });</span><span class="s3">\n    </span><span class="s1">let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;</span><span class="s3">\n    </span><span class="s1">parse.updateViewport(oldVieport);</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Queries whether there is a full syntax tree available up to the</span><span class="s3">\n</span><span class="s1">given document position. If there isn't, the background parse</span><span class="s3">\n</span><span class="s1">process _might_ still be working and update the tree further, but</span><span class="s3">\n</span><span class="s1">there is no guarantee of that—the parser will [stop</span><span class="s3">\n</span><span class="s1">working](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a</span><span class="s3">\n</span><span class="s1">certain amount of time or has moved beyond the visible viewport.</span><span class="s3">\n</span><span class="s1">Always returns false if no language has been enabled.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function syntaxTreeAvailable(state, upto = state.doc.length) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move parsing forward, and update the editor state afterwards to</span><span class="s3">\n</span><span class="s1">reflect the new tree. Will work for at most `timeout`</span><span class="s3">\n</span><span class="s1">milliseconds. Returns true if the parser managed get to the given</span><span class="s3">\n</span><span class="s1">position in that time.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function forceParsing(view, upto = view.viewport.to, timeout = 100) {</span><span class="s3">\n    </span><span class="s1">let success = ensureSyntaxTree(view.state, upto, timeout);</span><span class="s3">\n    </span><span class="s1">if (success != syntaxTree(view.state))</span><span class="s3">\n        </span><span class="s1">view.dispatch({});</span><span class="s3">\n    </span><span class="s1">return !!success;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Tells you whether the language parser is planning to do more</span><span class="s3">\n</span><span class="s1">parsing work (in a `requestIdleCallback` pseudo-thread) or has</span><span class="s3">\n</span><span class="s1">stopped running, either because it parsed the entire document,</span><span class="s3">\n</span><span class="s1">because it spent too much time and was cut off, or because there</span><span class="s3">\n</span><span class="s1">is no language parser enabled.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function syntaxParserRunning(view) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Lezer-style</span><span class="s3">\n</span><span class="s1">[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)</span><span class="s3">\n</span><span class="s1">object for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class DocInput {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an input object for the given document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(doc) {</span><span class="s3">\n        </span><span class="s1">this.doc = doc;</span><span class="s3">\n        </span><span class="s1">this.cursorPos = 0;</span><span class="s3">\n        </span><span class="s1">this.string = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.cursor = doc.iter();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() { return this.doc.length; }</span><span class="s3">\n    </span><span class="s1">syncTo(pos) {</span><span class="s3">\n        </span><span class="s1">this.string = this.cursor.next(pos - this.cursorPos).value;</span><span class="s3">\n        </span><span class="s1">this.cursorPos = pos + this.string.length;</span><span class="s3">\n        </span><span class="s1">return this.cursorPos - this.string.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chunk(pos) {</span><span class="s3">\n        </span><span class="s1">this.syncTo(pos);</span><span class="s3">\n        </span><span class="s1">return this.string;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineChunks() { return true; }</span><span class="s3">\n    </span><span class="s1">read(from, to) {</span><span class="s3">\n        </span><span class="s1">let stringStart = this.cursorPos - this.string.length;</span><span class="s3">\n        </span><span class="s1">if (from &lt; stringStart || to &gt;= this.cursorPos)</span><span class="s3">\n            </span><span class="s1">return this.doc.sliceString(from, to);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return this.string.slice(from - stringStart, to - stringStart);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let currentContext = null;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A parse context provided to parsers working on the editor content.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ParseContext {</span><span class="s3">\n    </span><span class="s1">constructor(parser, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current editor state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">state, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Tree fragments that can be reused by incremental re-parses.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">fragments = [], </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">tree, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">treeLen, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current editor viewport (or some overapproximation</span><span class="s3">\n    </span><span class="s1">thereof). Intended to be used for opportunistically avoiding</span><span class="s3">\n    </span><span class="s1">work (in which case</span><span class="s3">\n    </span><span class="s1">[`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)</span><span class="s3">\n    </span><span class="s1">should be called to make sure the parser is restarted when the</span><span class="s3">\n    </span><span class="s1">skipped region becomes visible).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">viewport, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">skipped, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This is where skipping parsers can register a promise that,</span><span class="s3">\n    </span><span class="s1">when resolved, will schedule a new parse. It is cleared when</span><span class="s3">\n    </span><span class="s1">the parse worker picks up the promise. @internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scheduleOn) {</span><span class="s3">\n        </span><span class="s1">this.parser = parser;</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.tree = tree;</span><span class="s3">\n        </span><span class="s1">this.treeLen = treeLen;</span><span class="s3">\n        </span><span class="s1">this.viewport = viewport;</span><span class="s3">\n        </span><span class="s1">this.skipped = skipped;</span><span class="s3">\n        </span><span class="s1">this.scheduleOn = scheduleOn;</span><span class="s3">\n        </span><span class="s1">this.parse = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.tempSkipped = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(parser, state, viewport) {</span><span class="s3">\n        </span><span class="s1">return new ParseContext(parser, state, [], Tree.empty, 0, viewport, [], null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">startParse() {</span><span class="s3">\n        </span><span class="s1">return this.parser.startParse(new DocInput(this.state.doc), this.fragments);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">work(until, upto) {</span><span class="s3">\n        </span><span class="s1">if (upto != null &amp;&amp; upto &gt;= this.state.doc.length)</span><span class="s3">\n            </span><span class="s1">upto = undefined;</span><span class="s3">\n        </span><span class="s1">if (this.tree != Tree.empty &amp;&amp; this.isDone(upto !== null &amp;&amp; upto !== void 0 ? upto : this.state.doc.length)) {</span><span class="s3">\n            </span><span class="s1">this.takeTree();</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.withContext(() =&gt; {</span><span class="s3">\n            </span><span class="s1">var _a;</span><span class="s3">\n            </span><span class="s1">if (typeof until == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">let endTime = Date.now() + until;</span><span class="s3">\n                </span><span class="s1">until = () =&gt; Date.now() &gt; endTime;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.parse)</span><span class="s3">\n                </span><span class="s1">this.parse = this.startParse();</span><span class="s3">\n            </span><span class="s1">if (upto != null &amp;&amp; (this.parse.stoppedAt == null || this.parse.stoppedAt &gt; upto) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">upto &lt; this.state.doc.length)</span><span class="s3">\n                </span><span class="s1">this.parse.stopAt(upto);</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">let done = this.parse.advance();</span><span class="s3">\n                </span><span class="s1">if (done) {</span><span class="s3">\n                    </span><span class="s1">this.fragments = this.withoutTempSkipped(TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));</span><span class="s3">\n                    </span><span class="s1">this.treeLen = (_a = this.parse.stoppedAt) !== null &amp;&amp; _a !== void 0 ? _a : this.state.doc.length;</span><span class="s3">\n                    </span><span class="s1">this.tree = done;</span><span class="s3">\n                    </span><span class="s1">this.parse = null;</span><span class="s3">\n                    </span><span class="s1">if (this.treeLen &lt; (upto !== null &amp;&amp; upto !== void 0 ? upto : this.state.doc.length))</span><span class="s3">\n                        </span><span class="s1">this.parse = this.startParse();</span><span class="s3">\n                    </span><span class="s1">else</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (until())</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">takeTree() {</span><span class="s3">\n        </span><span class="s1">let pos, tree;</span><span class="s3">\n        </span><span class="s1">if (this.parse &amp;&amp; (pos = this.parse.parsedPos) &gt;= this.treeLen) {</span><span class="s3">\n            </span><span class="s1">if (this.parse.stoppedAt == null || this.parse.stoppedAt &gt; pos)</span><span class="s3">\n                </span><span class="s1">this.parse.stopAt(pos);</span><span class="s3">\n            </span><span class="s1">this.withContext(() =&gt; { while (!(tree = this.parse.advance())) { } });</span><span class="s3">\n            </span><span class="s1">this.treeLen = pos;</span><span class="s3">\n            </span><span class="s1">this.tree = tree;</span><span class="s3">\n            </span><span class="s1">this.fragments = this.withoutTempSkipped(TreeFragment.addTree(this.tree, this.fragments, true));</span><span class="s3">\n            </span><span class="s1">this.parse = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">withContext(f) {</span><span class="s3">\n        </span><span class="s1">let prev = currentContext;</span><span class="s3">\n        </span><span class="s1">currentContext = this;</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">return f();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">finally {</span><span class="s3">\n            </span><span class="s1">currentContext = prev;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">withoutTempSkipped(fragments) {</span><span class="s3">\n        </span><span class="s1">for (let r; r = this.tempSkipped.pop();)</span><span class="s3">\n            </span><span class="s1">fragments = cutFragments(fragments, r.from, r.to);</span><span class="s3">\n        </span><span class="s1">return fragments;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">changes(changes, newState) {</span><span class="s3">\n        </span><span class="s1">let { fragments, tree, treeLen, viewport, skipped } = this;</span><span class="s3">\n        </span><span class="s1">this.takeTree();</span><span class="s3">\n        </span><span class="s1">if (!changes.empty) {</span><span class="s3">\n            </span><span class="s1">let ranges = [];</span><span class="s3">\n            </span><span class="s1">changes.iterChangedRanges((fromA, toA, fromB, toB) =&gt; ranges.push({ fromA, toA, fromB, toB }));</span><span class="s3">\n            </span><span class="s1">fragments = TreeFragment.applyChanges(fragments, ranges);</span><span class="s3">\n            </span><span class="s1">tree = Tree.empty;</span><span class="s3">\n            </span><span class="s1">treeLen = 0;</span><span class="s3">\n            </span><span class="s1">viewport = { from: changes.mapPos(viewport.from, -1), to: changes.mapPos(viewport.to, 1) };</span><span class="s3">\n            </span><span class="s1">if (this.skipped.length) {</span><span class="s3">\n                </span><span class="s1">skipped = [];</span><span class="s3">\n                </span><span class="s1">for (let r of this.skipped) {</span><span class="s3">\n                    </span><span class="s1">let from = changes.mapPos(r.from, 1), to = changes.mapPos(r.to, -1);</span><span class="s3">\n                    </span><span class="s1">if (from &lt; to)</span><span class="s3">\n                        </span><span class="s1">skipped.push({ from, to });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateViewport(viewport) {</span><span class="s3">\n        </span><span class="s1">if (this.viewport.from == viewport.from &amp;&amp; this.viewport.to == viewport.to)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.viewport = viewport;</span><span class="s3">\n        </span><span class="s1">let startLen = this.skipped.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.skipped.length; i++) {</span><span class="s3">\n            </span><span class="s1">let { from, to } = this.skipped[i];</span><span class="s3">\n            </span><span class="s1">if (from &lt; viewport.to &amp;&amp; to &gt; viewport.from) {</span><span class="s3">\n                </span><span class="s1">this.fragments = cutFragments(this.fragments, from, to);</span><span class="s3">\n                </span><span class="s1">this.skipped.splice(i--, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.skipped.length &gt;= startLen)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">this.reset();</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reset() {</span><span class="s3">\n        </span><span class="s1">if (this.parse) {</span><span class="s3">\n            </span><span class="s1">this.takeTree();</span><span class="s3">\n            </span><span class="s1">this.parse = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Notify the parse scheduler that the given region was skipped</span><span class="s3">\n    </span><span class="s1">because it wasn't in view, and the parse should be restarted</span><span class="s3">\n    </span><span class="s1">when it comes into view.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">skipUntilInView(from, to) {</span><span class="s3">\n        </span><span class="s1">this.skipped.push({ from, to });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns a parser intended to be used as placeholder when</span><span class="s3">\n    </span><span class="s1">asynchronously loading a nested parser. It'll skip its input and</span><span class="s3">\n    </span><span class="s1">mark it as not-really-parsed, so that the next update will parse</span><span class="s3">\n    </span><span class="s1">it again.</span><span class="s3">\n    \n    </span><span class="s1">When `until` is given, a reparse will be scheduled when that</span><span class="s3">\n    </span><span class="s1">promise resolves.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static getSkippingParser(until) {</span><span class="s3">\n        </span><span class="s1">return new class extends Parser {</span><span class="s3">\n            </span><span class="s1">createParse(input, fragments, ranges) {</span><span class="s3">\n                </span><span class="s1">let from = ranges[0].from, to = ranges[ranges.length - 1].to;</span><span class="s3">\n                </span><span class="s1">let parser = {</span><span class="s3">\n                    </span><span class="s1">parsedPos: from,</span><span class="s3">\n                    </span><span class="s1">advance() {</span><span class="s3">\n                        </span><span class="s1">let cx = currentContext;</span><span class="s3">\n                        </span><span class="s1">if (cx) {</span><span class="s3">\n                            </span><span class="s1">for (let r of ranges)</span><span class="s3">\n                                </span><span class="s1">cx.tempSkipped.push(r);</span><span class="s3">\n                            </span><span class="s1">if (until)</span><span class="s3">\n                                </span><span class="s1">cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">this.parsedPos = to;</span><span class="s3">\n                        </span><span class="s1">return new Tree(NodeType.none, [], [], to - from);</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                    </span><span class="s1">stoppedAt: null,</span><span class="s3">\n                    </span><span class="s1">stopAt() { }</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">return parser;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isDone(upto) {</span><span class="s3">\n        </span><span class="s1">upto = Math.min(upto, this.state.doc.length);</span><span class="s3">\n        </span><span class="s1">let frags = this.fragments;</span><span class="s3">\n        </span><span class="s1">return this.treeLen &gt;= upto &amp;&amp; frags.length &amp;&amp; frags[0].from == 0 &amp;&amp; frags[0].to &gt;= upto;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the context for the current parse, or `null` if no editor</span><span class="s3">\n    </span><span class="s1">parse is in progress.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static get() { return currentContext; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cutFragments(fragments, from, to) {</span><span class="s3">\n    </span><span class="s1">return TreeFragment.applyChanges(fragments, [{ fromA: from, toA: to, fromB: from, toB: to }]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LanguageState {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">// A mutable parse state that is used to preserve work done during</span><span class="s3">\n    </span><span class="s1">// the lifetime of a state when moving to the next state.</span><span class="s3">\n    </span><span class="s1">context) {</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n        </span><span class="s1">this.tree = context.tree;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">apply(tr) {</span><span class="s3">\n        </span><span class="s1">if (!tr.docChanged &amp;&amp; this.tree == this.context.tree)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let newCx = this.context.changes(tr.changes, tr.state);</span><span class="s3">\n        </span><span class="s1">// If the previous parse wasn't done, go forward only up to its</span><span class="s3">\n        </span><span class="s1">// end position or the end of the viewport, to avoid slowing down</span><span class="s3">\n        </span><span class="s1">// state updates with parse work beyond the viewport.</span><span class="s3">\n        </span><span class="s1">let upto = this.context.treeLen == tr.startState.doc.length ? undefined</span><span class="s3">\n            </span><span class="s1">: Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);</span><span class="s3">\n        </span><span class="s1">if (!newCx.work(20 /* Work.Apply */, upto))</span><span class="s3">\n            </span><span class="s1">newCx.takeTree();</span><span class="s3">\n        </span><span class="s1">return new LanguageState(newCx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static init(state) {</span><span class="s3">\n        </span><span class="s1">let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);</span><span class="s3">\n        </span><span class="s1">let parseState = ParseContext.create(state.facet(language).parser, state, { from: 0, to: vpTo });</span><span class="s3">\n        </span><span class="s1">if (!parseState.work(20 /* Work.Apply */, vpTo))</span><span class="s3">\n            </span><span class="s1">parseState.takeTree();</span><span class="s3">\n        </span><span class="s1">return new LanguageState(parseState);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Language.state = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create: LanguageState.init,</span><span class="s3">\n    </span><span class="s1">update(value, tr) {</span><span class="s3">\n        </span><span class="s1">for (let e of tr.effects)</span><span class="s3">\n            </span><span class="s1">if (e.is(Language.setState))</span><span class="s3">\n                </span><span class="s1">return e.value;</span><span class="s3">\n        </span><span class="s1">if (tr.startState.facet(language) != tr.state.facet(language))</span><span class="s3">\n            </span><span class="s1">return LanguageState.init(tr.state);</span><span class="s3">\n        </span><span class="s1">return value.apply(tr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">let requestIdle = (callback) =&gt; {</span><span class="s3">\n    </span><span class="s1">let timeout = setTimeout(() =&gt; callback(), 500 /* Work.MaxPause */);</span><span class="s3">\n    </span><span class="s1">return () =&gt; clearTimeout(timeout);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">if (typeof requestIdleCallback != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">requestIdle = (callback) =&gt; {</span><span class="s3">\n        </span><span class="s1">let idle = -1, timeout = setTimeout(() =&gt; {</span><span class="s3">\n            </span><span class="s1">idle = requestIdleCallback(callback, { timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */ });</span><span class="s3">\n        </span><span class="s1">}, 100 /* Work.MinPause */);</span><span class="s3">\n        </span><span class="s1">return () =&gt; idle &lt; 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const isInputPending = typeof navigator != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending)</span><span class="s3">\n    </span><span class="s1">? () =&gt; navigator.scheduling.isInputPending() : null;</span><span class="s3">\n</span><span class="s1">const parseWorker = /*@__PURE__*/ViewPlugin.fromClass(class ParseWorker {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.working = null;</span><span class="s3">\n        </span><span class="s1">this.workScheduled = 0;</span><span class="s3">\n        </span><span class="s1">// End of the current time chunk</span><span class="s3">\n        </span><span class="s1">this.chunkEnd = -1;</span><span class="s3">\n        </span><span class="s1">// Milliseconds of budget left for this chunk</span><span class="s3">\n        </span><span class="s1">this.chunkBudget = -1;</span><span class="s3">\n        </span><span class="s1">this.work = this.work.bind(this);</span><span class="s3">\n        </span><span class="s1">this.scheduleWork();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let cx = this.view.state.field(Language.state).context;</span><span class="s3">\n        </span><span class="s1">if (cx.updateViewport(update.view.viewport) || this.view.viewport.to &gt; cx.treeLen)</span><span class="s3">\n            </span><span class="s1">this.scheduleWork();</span><span class="s3">\n        </span><span class="s1">if (update.docChanged || update.selectionSet) {</span><span class="s3">\n            </span><span class="s1">if (this.view.hasFocus)</span><span class="s3">\n                </span><span class="s1">this.chunkBudget += 50 /* Work.ChangeBonus */;</span><span class="s3">\n            </span><span class="s1">this.scheduleWork();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.checkAsyncSchedule(cx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scheduleWork() {</span><span class="s3">\n        </span><span class="s1">if (this.working)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let { state } = this.view, field = state.field(Language.state);</span><span class="s3">\n        </span><span class="s1">if (field.tree != field.context.tree || !field.context.isDone(state.doc.length))</span><span class="s3">\n            </span><span class="s1">this.working = requestIdle(this.work);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">work(deadline) {</span><span class="s3">\n        </span><span class="s1">this.working = null;</span><span class="s3">\n        </span><span class="s1">let now = Date.now();</span><span class="s3">\n        </span><span class="s1">if (this.chunkEnd &lt; now &amp;&amp; (this.chunkEnd &lt; 0 || this.view.hasFocus)) { // Start a new chunk</span><span class="s3">\n            </span><span class="s1">this.chunkEnd = now + 30000 /* Work.ChunkTime */;</span><span class="s3">\n            </span><span class="s1">this.chunkBudget = 3000 /* Work.ChunkBudget */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.chunkBudget &lt;= 0)</span><span class="s3">\n            </span><span class="s1">return; // No more budget</span><span class="s3">\n        </span><span class="s1">let { state, viewport: { to: vpTo } } = this.view, field = state.field(Language.state);</span><span class="s3">\n        </span><span class="s1">if (field.tree == field.context.tree &amp;&amp; field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline &amp;&amp; !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);</span><span class="s3">\n        </span><span class="s1">let viewportFirst = field.context.treeLen &lt; vpTo &amp;&amp; state.doc.length &gt; vpTo + 1000;</span><span class="s3">\n        </span><span class="s1">let done = field.context.work(() =&gt; {</span><span class="s3">\n            </span><span class="s1">return isInputPending &amp;&amp; isInputPending() || Date.now() &gt; endTime;</span><span class="s3">\n        </span><span class="s1">}, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));</span><span class="s3">\n        </span><span class="s1">this.chunkBudget -= Date.now() - now;</span><span class="s3">\n        </span><span class="s1">if (done || this.chunkBudget &lt;= 0) {</span><span class="s3">\n            </span><span class="s1">field.context.takeTree();</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({ effects: Language.setState.of(new LanguageState(field.context)) });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.chunkBudget &gt; 0 &amp;&amp; !(done &amp;&amp; !viewportFirst))</span><span class="s3">\n            </span><span class="s1">this.scheduleWork();</span><span class="s3">\n        </span><span class="s1">this.checkAsyncSchedule(field.context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkAsyncSchedule(cx) {</span><span class="s3">\n        </span><span class="s1">if (cx.scheduleOn) {</span><span class="s3">\n            </span><span class="s1">this.workScheduled++;</span><span class="s3">\n            </span><span class="s1">cx.scheduleOn</span><span class="s3">\n                </span><span class="s1">.then(() =&gt; this.scheduleWork())</span><span class="s3">\n                </span><span class="s1">.catch(err =&gt; logException(this.view.state, err))</span><span class="s3">\n                </span><span class="s1">.then(() =&gt; this.workScheduled--);</span><span class="s3">\n            </span><span class="s1">cx.scheduleOn = null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">destroy() {</span><span class="s3">\n        </span><span class="s1">if (this.working)</span><span class="s3">\n            </span><span class="s1">this.working();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isWorking() {</span><span class="s3">\n        </span><span class="s1">return !!(this.working || this.workScheduled &gt; 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">eventHandlers: { focus() { this.scheduleWork(); } }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The facet used to associate a language with an editor state. Used</span><span class="s3">\n</span><span class="s1">by `Language` object's `extension` property (so you don't need to</span><span class="s3">\n</span><span class="s1">manually wrap your languages in this). Can be used to access the</span><span class="s3">\n</span><span class="s1">current language on a state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const language = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(languages) { return languages.length ? languages[0] : null; },</span><span class="s3">\n    </span><span class="s1">enables: language =&gt; [</span><span class="s3">\n        </span><span class="s1">Language.state,</span><span class="s3">\n        </span><span class="s1">parseWorker,</span><span class="s3">\n        </span><span class="s1">EditorView.contentAttributes.compute([language], state =&gt; {</span><span class="s3">\n            </span><span class="s1">let lang = state.facet(language);</span><span class="s3">\n            </span><span class="s1">return lang &amp;&amp; lang.name ? { </span><span class="s3">\&quot;</span><span class="s1">data-language</span><span class="s3">\&quot;</span><span class="s1">: lang.name } : {};</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an</span><span class="s3">\n</span><span class="s1">optional set of supporting extensions. Language packages are</span><span class="s3">\n</span><span class="s1">encouraged to export a function that optionally takes a</span><span class="s3">\n</span><span class="s1">configuration object and returns a `LanguageSupport` instance, as</span><span class="s3">\n</span><span class="s1">the main way for client code to use the package.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LanguageSupport {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a language support object.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The language object.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">language, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">An optional set of supporting extensions. When nesting a</span><span class="s3">\n    </span><span class="s1">language in another language, the outer language is encouraged</span><span class="s3">\n    </span><span class="s1">to include the supporting extensions for its inner languages</span><span class="s3">\n    </span><span class="s1">in its own set of support extensions.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">support = []) {</span><span class="s3">\n        </span><span class="s1">this.language = language;</span><span class="s3">\n        </span><span class="s1">this.support = support;</span><span class="s3">\n        </span><span class="s1">this.extension = [language, support];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Language descriptions are used to store metadata about languages</span><span class="s3">\n</span><span class="s1">and to dynamically load them. Their main role is finding the</span><span class="s3">\n</span><span class="s1">appropriate language for a filename or dynamically loading nested</span><span class="s3">\n</span><span class="s1">parsers.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class LanguageDescription {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The name of this language.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">name, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Alternative names for the mode (lowercased, includes `this.name`).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">alias, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">File extensions associated with this language.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">extensions, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Optional filename pattern that should be associated with this</span><span class="s3">\n    </span><span class="s1">language.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">filename, loadFunc, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If the language has been loaded, this will hold its value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">support = undefined) {</span><span class="s3">\n        </span><span class="s1">this.name = name;</span><span class="s3">\n        </span><span class="s1">this.alias = alias;</span><span class="s3">\n        </span><span class="s1">this.extensions = extensions;</span><span class="s3">\n        </span><span class="s1">this.filename = filename;</span><span class="s3">\n        </span><span class="s1">this.loadFunc = loadFunc;</span><span class="s3">\n        </span><span class="s1">this.support = support;</span><span class="s3">\n        </span><span class="s1">this.loading = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Start loading the the language. Will return a promise that</span><span class="s3">\n    </span><span class="s1">resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)</span><span class="s3">\n    </span><span class="s1">object when the language successfully loads.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">load() {</span><span class="s3">\n        </span><span class="s1">return this.loading || (this.loading = this.loadFunc().then(support =&gt; this.support = support, err =&gt; { this.loading = null; throw err; }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a language description.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static of(spec) {</span><span class="s3">\n        </span><span class="s1">let { load, support } = spec;</span><span class="s3">\n        </span><span class="s1">if (!load) {</span><span class="s3">\n            </span><span class="s1">if (!support)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Must pass either 'load' or 'support' to LanguageDescription.of</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">load = () =&gt; Promise.resolve(support);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s =&gt; s.toLowerCase()), spec.extensions || [], spec.filename, load, support);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Look for a language in the given array of descriptions that</span><span class="s3">\n    </span><span class="s1">matches the filename. Will first match</span><span class="s3">\n    </span><span class="s1">[`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,</span><span class="s3">\n    </span><span class="s1">and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),</span><span class="s3">\n    </span><span class="s1">and return the first language that matches.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static matchFilename(descs, filename) {</span><span class="s3">\n        </span><span class="s1">for (let d of descs)</span><span class="s3">\n            </span><span class="s1">if (d.filename &amp;&amp; d.filename.test(filename))</span><span class="s3">\n                </span><span class="s1">return d;</span><span class="s3">\n        </span><span class="s1">let ext = /</span><span class="s3">\\</span><span class="s1">.([^.]+)$/.exec(filename);</span><span class="s3">\n        </span><span class="s1">if (ext)</span><span class="s3">\n            </span><span class="s1">for (let d of descs)</span><span class="s3">\n                </span><span class="s1">if (d.extensions.indexOf(ext[1]) &gt; -1)</span><span class="s3">\n                    </span><span class="s1">return d;</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Look for a language whose name or alias matches the the given</span><span class="s3">\n    </span><span class="s1">name (case-insensitively). If `fuzzy` is true, and no direct</span><span class="s3">\n    </span><span class="s1">matchs is found, this'll also search for a language whose name</span><span class="s3">\n    </span><span class="s1">or alias occurs in the string (for names shorter than three</span><span class="s3">\n    </span><span class="s1">characters, only when surrounded by non-word characters).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static matchLanguageName(descs, name, fuzzy = true) {</span><span class="s3">\n        </span><span class="s1">name = name.toLowerCase();</span><span class="s3">\n        </span><span class="s1">for (let d of descs)</span><span class="s3">\n            </span><span class="s1">if (d.alias.some(a =&gt; a == name))</span><span class="s3">\n                </span><span class="s1">return d;</span><span class="s3">\n        </span><span class="s1">if (fuzzy)</span><span class="s3">\n            </span><span class="s1">for (let d of descs)</span><span class="s3">\n                </span><span class="s1">for (let a of d.alias) {</span><span class="s3">\n                    </span><span class="s1">let found = name.indexOf(a);</span><span class="s3">\n                    </span><span class="s1">if (found &gt; -1 &amp;&amp; (a.length &gt; 2 || !/</span><span class="s3">\\</span><span class="s1">w/.test(name[found - 1]) &amp;&amp; !/</span><span class="s3">\\</span><span class="s1">w/.test(name[found + a.length])))</span><span class="s3">\n                        </span><span class="s1">return d;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet that defines a way to provide a function that computes the</span><span class="s3">\n</span><span class="s1">appropriate indentation depth, as a column number (see</span><span class="s3">\n</span><span class="s1">[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given</span><span class="s3">\n</span><span class="s1">line. A return value of `null` indicates no indentation can be</span><span class="s3">\n</span><span class="s1">determined, and the line should inherit the indentation of the one</span><span class="s3">\n</span><span class="s1">above it. A return value of `undefined` defers to the next indent</span><span class="s3">\n</span><span class="s1">service.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentService = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet for overriding the unit by which indentation happens. Should</span><span class="s3">\n</span><span class="s1">be a string consisting either entirely of the same whitespace</span><span class="s3">\n</span><span class="s1">character. When not set, this defaults to 2 spaces.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentUnit = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!values.length)</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;  \&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let unit = values[0];</span><span class="s3">\n        </span><span class="s1">if (!unit || /</span><span class="s3">\\</span><span class="s1">S/.test(unit) || Array.from(unit).some(e =&gt; e != unit[0]))</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Invalid indent unit: </span><span class="s3">\&quot; </span><span class="s1">+ JSON.stringify(values[0]));</span><span class="s3">\n        </span><span class="s1">return unit;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Return the _column width_ of an indent unit in the state.</span><span class="s3">\n</span><span class="s1">Determined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)</span><span class="s3">\n</span><span class="s1">facet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that</span><span class="s3">\n</span><span class="s1">contains tabs.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getIndentUnit(state) {</span><span class="s3">\n    </span><span class="s1">let unit = state.facet(indentUnit);</span><span class="s3">\n    </span><span class="s1">return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an indentation string that covers columns 0 to `cols`.</span><span class="s3">\n</span><span class="s1">Will use tabs for as much of the columns as possible when the</span><span class="s3">\n</span><span class="s1">[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains</span><span class="s3">\n</span><span class="s1">tabs.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function indentString(state, cols) {</span><span class="s3">\n    </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">, ts = state.tabSize, ch = state.facet(indentUnit)[0];</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">while (cols &gt;= ts) {</span><span class="s3">\n            </span><span class="s1">result += </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">cols -= ts;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">ch = </span><span class="s3">\&quot; \&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; cols; i++)</span><span class="s3">\n        </span><span class="s1">result += ch;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the indentation, as a column number, at the given position.</span><span class="s3">\n</span><span class="s1">Will first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)</span><span class="s3">\n</span><span class="s1">that are registered, and if none of those return an indentation,</span><span class="s3">\n</span><span class="s1">this will check the syntax tree for the [indent node</span><span class="s3">\n</span><span class="s1">prop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a</span><span class="s3">\n</span><span class="s1">number when an indentation could be determined, and null</span><span class="s3">\n</span><span class="s1">otherwise.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getIndentation(context, pos) {</span><span class="s3">\n    </span><span class="s1">if (context instanceof EditorState)</span><span class="s3">\n        </span><span class="s1">context = new IndentContext(context);</span><span class="s3">\n    </span><span class="s1">for (let service of context.state.facet(indentService)) {</span><span class="s3">\n        </span><span class="s1">let result = service(context, pos);</span><span class="s3">\n        </span><span class="s1">if (result !== undefined)</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(context.state);</span><span class="s3">\n    </span><span class="s1">return tree.length &gt;= pos ? syntaxIndentation(context, tree, pos) : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create a change set that auto-indents all lines touched by the</span><span class="s3">\n</span><span class="s1">given document range.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function indentRange(state, from, to) {</span><span class="s3">\n    </span><span class="s1">let updated = Object.create(null);</span><span class="s3">\n    </span><span class="s1">let context = new IndentContext(state, { overrideIndentation: start =&gt; { var _a; return (_a = updated[start]) !== null &amp;&amp; _a !== void 0 ? _a : -1; } });</span><span class="s3">\n    </span><span class="s1">let changes = [];</span><span class="s3">\n    </span><span class="s1">for (let pos = from; pos &lt;= to;) {</span><span class="s3">\n        </span><span class="s1">let line = state.doc.lineAt(pos);</span><span class="s3">\n        </span><span class="s1">pos = line.to + 1;</span><span class="s3">\n        </span><span class="s1">let indent = getIndentation(context, line.from);</span><span class="s3">\n        </span><span class="s1">if (indent == null)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (!/</span><span class="s3">\\</span><span class="s1">S/.test(line.text))</span><span class="s3">\n            </span><span class="s1">indent = 0;</span><span class="s3">\n        </span><span class="s1">let cur = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(line.text)[0];</span><span class="s3">\n        </span><span class="s1">let norm = indentString(state, indent);</span><span class="s3">\n        </span><span class="s1">if (cur != norm) {</span><span class="s3">\n            </span><span class="s1">updated[line.from] = indent;</span><span class="s3">\n            </span><span class="s1">changes.push({ from: line.from, to: line.from + cur.length, insert: norm });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return state.changes(changes);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Indentation contexts are used when calling [indentation</span><span class="s3">\n</span><span class="s1">services](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities</span><span class="s3">\n</span><span class="s1">useful in indentation logic, and can selectively override the</span><span class="s3">\n</span><span class="s1">indentation reported for some lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class IndentContext {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an indent context.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The editor state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">state, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">options = {}) {</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.options = options;</span><span class="s3">\n        </span><span class="s1">this.unit = getIndentUnit(state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a description of the line at the given position, taking</span><span class="s3">\n    </span><span class="s1">[simulated line</span><span class="s3">\n    </span><span class="s1">breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)</span><span class="s3">\n    </span><span class="s1">into account. If there is such a break at `pos`, the `bias`</span><span class="s3">\n    </span><span class="s1">argument determines whether the part of the line line before or</span><span class="s3">\n    </span><span class="s1">after the break is used.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineAt(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">let line = this.state.doc.lineAt(pos);</span><span class="s3">\n        </span><span class="s1">let { simulateBreak, simulateDoubleBreak } = this.options;</span><span class="s3">\n        </span><span class="s1">if (simulateBreak != null &amp;&amp; simulateBreak &gt;= line.from &amp;&amp; simulateBreak &lt;= line.to) {</span><span class="s3">\n            </span><span class="s1">if (simulateDoubleBreak &amp;&amp; simulateBreak == pos)</span><span class="s3">\n                </span><span class="s1">return { text: </span><span class="s3">\&quot;\&quot;</span><span class="s1">, from: pos };</span><span class="s3">\n            </span><span class="s1">else if (bias &lt; 0 ? simulateBreak &lt; pos : simulateBreak &lt;= pos)</span><span class="s3">\n                </span><span class="s1">return { text: line.text.slice(simulateBreak - line.from), from: simulateBreak };</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">return { text: line.text.slice(0, simulateBreak - line.from), from: line.from };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return line;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the text directly after `pos`, either the entire line</span><span class="s3">\n    </span><span class="s1">or the next 100 characters, whichever is shorter.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">textAfterPos(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">if (this.options.simulateDoubleBreak &amp;&amp; pos == this.options.simulateBreak)</span><span class="s3">\n            </span><span class="s1">return </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">let { text, from } = this.lineAt(pos, bias);</span><span class="s3">\n        </span><span class="s1">return text.slice(pos - from, Math.min(text.length, pos + 100 - from));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the column for the given position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">column(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">let { text, from } = this.lineAt(pos, bias);</span><span class="s3">\n        </span><span class="s1">let result = this.countColumn(text, pos - from);</span><span class="s3">\n        </span><span class="s1">let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;</span><span class="s3">\n        </span><span class="s1">if (override &gt; -1)</span><span class="s3">\n            </span><span class="s1">result += override - this.countColumn(text, text.search(/</span><span class="s3">\\</span><span class="s1">S|$/));</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the column position (taking tabs into account) of the given</span><span class="s3">\n    </span><span class="s1">position in the given string.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">countColumn(line, pos = line.length) {</span><span class="s3">\n        </span><span class="s1">return countColumn(line, this.state.tabSize, pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the indentation column of the line at the given point.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineIndent(pos, bias = 1) {</span><span class="s3">\n        </span><span class="s1">let { text, from } = this.lineAt(pos, bias);</span><span class="s3">\n        </span><span class="s1">let override = this.options.overrideIndentation;</span><span class="s3">\n        </span><span class="s1">if (override) {</span><span class="s3">\n            </span><span class="s1">let overriden = override(from);</span><span class="s3">\n            </span><span class="s1">if (overriden &gt; -1)</span><span class="s3">\n                </span><span class="s1">return overriden;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.countColumn(text, text.search(/</span><span class="s3">\\</span><span class="s1">S|$/));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns the [simulated line</span><span class="s3">\n    </span><span class="s1">break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)</span><span class="s3">\n    </span><span class="s1">for this context, if any.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get simulatedBreak() {</span><span class="s3">\n        </span><span class="s1">return this.options.simulateBreak || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A syntax tree node prop used to associate indentation strategies</span><span class="s3">\n</span><span class="s1">with node types. Such a strategy is a function from an indentation</span><span class="s3">\n</span><span class="s1">context to a column number (see also</span><span class="s3">\n</span><span class="s1">[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null</span><span class="s3">\n</span><span class="s1">indicates that no definitive indentation can be determined.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const indentNodeProp = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">// Compute the indentation for a given position from the syntax tree.</span><span class="s3">\n</span><span class="s1">function syntaxIndentation(cx, ast, pos) {</span><span class="s3">\n    </span><span class="s1">let stack = ast.resolveStack(pos);</span><span class="s3">\n    </span><span class="s1">let inner = ast.resolveInner(pos, -1).resolve(pos, 0).enterUnfinishedNodesBefore(pos);</span><span class="s3">\n    </span><span class="s1">if (inner != stack.node) {</span><span class="s3">\n        </span><span class="s1">let add = [];</span><span class="s3">\n        </span><span class="s1">for (let cur = inner; cur != stack.node; cur = cur.parent)</span><span class="s3">\n            </span><span class="s1">add.push(cur);</span><span class="s3">\n        </span><span class="s1">for (let i = add.length - 1; i &gt;= 0; i--)</span><span class="s3">\n            </span><span class="s1">stack = { node: add[i], next: stack };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return indentFor(stack, cx, pos);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function indentFor(stack, cx, pos) {</span><span class="s3">\n    </span><span class="s1">for (let cur = stack; cur; cur = cur.next) {</span><span class="s3">\n        </span><span class="s1">let strategy = indentStrategy(cur.node);</span><span class="s3">\n        </span><span class="s1">if (strategy)</span><span class="s3">\n            </span><span class="s1">return strategy(TreeIndentContext.create(cx, pos, cur));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ignoreClosed(cx) {</span><span class="s3">\n    </span><span class="s1">return cx.pos == cx.options.simulateBreak &amp;&amp; cx.options.simulateDoubleBreak;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function indentStrategy(tree) {</span><span class="s3">\n    </span><span class="s1">let strategy = tree.type.prop(indentNodeProp);</span><span class="s3">\n    </span><span class="s1">if (strategy)</span><span class="s3">\n        </span><span class="s1">return strategy;</span><span class="s3">\n    </span><span class="s1">let first = tree.firstChild, close;</span><span class="s3">\n    </span><span class="s1">if (first &amp;&amp; (close = first.type.prop(NodeProp.closedBy))) {</span><span class="s3">\n        </span><span class="s1">let last = tree.lastChild, closed = last &amp;&amp; close.indexOf(last.name) &gt; -1;</span><span class="s3">\n        </span><span class="s1">return cx =&gt; delimitedStrategy(cx, true, 1, undefined, closed &amp;&amp; !ignoreClosed(cx) ? last.from : undefined);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tree.parent == null ? topIndent : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function topIndent() { return 0; }</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Objects of this type provide context information and helper</span><span class="s3">\n</span><span class="s1">methods to indentation functions registered on syntax nodes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class TreeIndentContext extends IndentContext {</span><span class="s3">\n    </span><span class="s1">constructor(base, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The position at which indentation is being computed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">pos, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">context) {</span><span class="s3">\n        </span><span class="s1">super(base.state, base.options);</span><span class="s3">\n        </span><span class="s1">this.base = base;</span><span class="s3">\n        </span><span class="s1">this.pos = pos;</span><span class="s3">\n        </span><span class="s1">this.context = context;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The syntax tree node to which the indentation strategy</span><span class="s3">\n    </span><span class="s1">applies.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get node() { return this.context.node; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(base, pos, context) {</span><span class="s3">\n        </span><span class="s1">return new TreeIndentContext(base, pos, context);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the text directly after `this.pos`, either the entire line</span><span class="s3">\n    </span><span class="s1">or the next 100 characters, whichever is shorter.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get textAfter() {</span><span class="s3">\n        </span><span class="s1">return this.textAfterPos(this.pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the indentation at the reference line for `this.node`, which</span><span class="s3">\n    </span><span class="s1">is the line on which it starts, unless there is a node that is</span><span class="s3">\n    </span><span class="s1">_not_ a parent of this node covering the start of that line. If</span><span class="s3">\n    </span><span class="s1">so, the line at the start of that node is tried, again skipping</span><span class="s3">\n    </span><span class="s1">on if it is covered by another such node.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get baseIndent() {</span><span class="s3">\n        </span><span class="s1">return this.baseIndentFor(this.node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the indentation for the reference line of the given node</span><span class="s3">\n    </span><span class="s1">(see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">baseIndentFor(node) {</span><span class="s3">\n        </span><span class="s1">let line = this.state.doc.lineAt(node.from);</span><span class="s3">\n        </span><span class="s1">// Skip line starts that are covered by a sibling (or cousin, etc)</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let atBreak = node.resolve(line.from);</span><span class="s3">\n            </span><span class="s1">while (atBreak.parent &amp;&amp; atBreak.parent.from == atBreak.from)</span><span class="s3">\n                </span><span class="s1">atBreak = atBreak.parent;</span><span class="s3">\n            </span><span class="s1">if (isParent(atBreak, node))</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">line = this.state.doc.lineAt(atBreak.from);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.lineIndent(line.from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Continue looking for indentations in the node's parent nodes,</span><span class="s3">\n    </span><span class="s1">and return the result of that.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">continue() {</span><span class="s3">\n        </span><span class="s1">return indentFor(this.context.next, this.base, this.pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isParent(parent, of) {</span><span class="s3">\n    </span><span class="s1">for (let cur = of; cur; cur = cur.parent)</span><span class="s3">\n        </span><span class="s1">if (parent == cur)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Check whether a delimited node is aligned (meaning there are</span><span class="s3">\n</span><span class="s1">// non-skipped nodes on the same line as the opening delimiter). And</span><span class="s3">\n</span><span class="s1">// if so, return the opening token.</span><span class="s3">\n</span><span class="s1">function bracketedAligned(context) {</span><span class="s3">\n    </span><span class="s1">let tree = context.node;</span><span class="s3">\n    </span><span class="s1">let openToken = tree.childAfter(tree.from), last = tree.lastChild;</span><span class="s3">\n    </span><span class="s1">if (!openToken)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let sim = context.options.simulateBreak;</span><span class="s3">\n    </span><span class="s1">let openLine = context.state.doc.lineAt(openToken.from);</span><span class="s3">\n    </span><span class="s1">let lineEnd = sim == null || sim &lt;= openLine.from ? openLine.to : Math.min(openLine.to, sim);</span><span class="s3">\n    </span><span class="s1">for (let pos = openToken.to;;) {</span><span class="s3">\n        </span><span class="s1">let next = tree.childAfter(pos);</span><span class="s3">\n        </span><span class="s1">if (!next || next == last)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">if (!next.type.isSkipped) {</span><span class="s3">\n            </span><span class="s1">if (next.from &gt;= lineEnd)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">let space = /^ */.exec(openLine.text.slice(openToken.to - openLine.from))[0].length;</span><span class="s3">\n            </span><span class="s1">return { from: openToken.from, to: openToken.to + space };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos = next.to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An indentation strategy for delimited (usually bracketed) nodes.</span><span class="s3">\n</span><span class="s1">Will, by default, indent one unit more than the parent's base</span><span class="s3">\n</span><span class="s1">indent unless the line starts with a closing token. When `align`</span><span class="s3">\n</span><span class="s1">is true and there are non-skipped nodes on the node's opening</span><span class="s3">\n</span><span class="s1">line, the content of the node will be aligned with the end of the</span><span class="s3">\n</span><span class="s1">opening node, like this:</span><span class="s3">\n\n    </span><span class="s1">foo(bar,</span><span class="s3">\n        </span><span class="s1">baz)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function delimitedIndent({ closing, align = true, units = 1 }) {</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; delimitedStrategy(context, align, units, closing);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function delimitedStrategy(context, align, units, closing, closedAt) {</span><span class="s3">\n    </span><span class="s1">let after = context.textAfter, space = after.match(/^</span><span class="s3">\\</span><span class="s1">s*/)[0].length;</span><span class="s3">\n    </span><span class="s1">let closed = closing &amp;&amp; after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;</span><span class="s3">\n    </span><span class="s1">let aligned = align ? bracketedAligned(context) : null;</span><span class="s3">\n    </span><span class="s1">if (aligned)</span><span class="s3">\n        </span><span class="s1">return closed ? context.column(aligned.from) : context.column(aligned.to);</span><span class="s3">\n    </span><span class="s1">return context.baseIndent + (closed ? 0 : context.unit * units);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An indentation strategy that aligns a node's content to its base</span><span class="s3">\n</span><span class="s1">indentation.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const flatIndent = (context) =&gt; context.baseIndent;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Creates an indentation strategy that, by default, indents</span><span class="s3">\n</span><span class="s1">continued lines one unit more than the node's base indentation.</span><span class="s3">\n</span><span class="s1">You can provide `except` to prevent indentation of lines that</span><span class="s3">\n</span><span class="s1">match a pattern (for example `/^else</span><span class="s3">\\</span><span class="s1">b/` in `if`/`else`</span><span class="s3">\n</span><span class="s1">constructs), and you can change the amount of units used with the</span><span class="s3">\n</span><span class="s1">`units` option.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function continuedIndent({ except, units = 1 } = {}) {</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; {</span><span class="s3">\n        </span><span class="s1">let matchExcept = except &amp;&amp; except.test(context.textAfter);</span><span class="s3">\n        </span><span class="s1">return context.baseIndent + (matchExcept ? 0 : units * context.unit);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const DontIndentBeyond = 200;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Enables reindentation on input. When a language defines an</span><span class="s3">\n</span><span class="s1">`indentOnInput` field in its [language</span><span class="s3">\n</span><span class="s1">data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular</span><span class="s3">\n</span><span class="s1">expression, the line at the cursor will be reindented whenever new</span><span class="s3">\n</span><span class="s1">text is typed and the input from the start of the line up to the</span><span class="s3">\n</span><span class="s1">cursor matches that regexp.</span><span class="s3">\n\n</span><span class="s1">To avoid unneccesary reindents, it is recommended to start the</span><span class="s3">\n</span><span class="s1">regexp with `^` (usually followed by `</span><span class="s3">\\</span><span class="s1">s*`), and end it with `$`.</span><span class="s3">\n</span><span class="s1">For example, `/^</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">}$/` will reindent when a closing brace is</span><span class="s3">\n</span><span class="s1">added at the start of a line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function indentOnInput() {</span><span class="s3">\n    </span><span class="s1">return EditorState.transactionFilter.of(tr =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!tr.docChanged || !tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; !tr.isUserEvent(</span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">return tr;</span><span class="s3">\n        </span><span class="s1">let rules = tr.startState.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">indentOnInput</span><span class="s3">\&quot;</span><span class="s1">, tr.startState.selection.main.head);</span><span class="s3">\n        </span><span class="s1">if (!rules.length)</span><span class="s3">\n            </span><span class="s1">return tr;</span><span class="s3">\n        </span><span class="s1">let doc = tr.newDoc, { head } = tr.newSelection.main, line = doc.lineAt(head);</span><span class="s3">\n        </span><span class="s1">if (head &gt; line.from + DontIndentBeyond)</span><span class="s3">\n            </span><span class="s1">return tr;</span><span class="s3">\n        </span><span class="s1">let lineStart = doc.sliceString(line.from, head);</span><span class="s3">\n        </span><span class="s1">if (!rules.some(r =&gt; r.test(lineStart)))</span><span class="s3">\n            </span><span class="s1">return tr;</span><span class="s3">\n        </span><span class="s1">let { state } = tr, last = -1, changes = [];</span><span class="s3">\n        </span><span class="s1">for (let { head } of state.selection.ranges) {</span><span class="s3">\n            </span><span class="s1">let line = state.doc.lineAt(head);</span><span class="s3">\n            </span><span class="s1">if (line.from == last)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">last = line.from;</span><span class="s3">\n            </span><span class="s1">let indent = getIndentation(state, line.from);</span><span class="s3">\n            </span><span class="s1">if (indent == null)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let cur = /^</span><span class="s3">\\</span><span class="s1">s*/.exec(line.text)[0];</span><span class="s3">\n            </span><span class="s1">let norm = indentString(state, indent);</span><span class="s3">\n            </span><span class="s1">if (cur != norm)</span><span class="s3">\n                </span><span class="s1">changes.push({ from: line.from, to: line.from + cur.length, insert: norm });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return changes.length ? [tr, { changes, sequential: true }] : tr;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet that registers a code folding service. When called with</span><span class="s3">\n</span><span class="s1">the extent of a line, such a function should return a foldable</span><span class="s3">\n</span><span class="s1">range that starts on that line (but continues beyond it), if one</span><span class="s3">\n</span><span class="s1">can be found.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldService = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This node prop is used to associate folding information with</span><span class="s3">\n</span><span class="s1">syntax node types. Given a syntax node, it should check whether</span><span class="s3">\n</span><span class="s1">that tree is foldable and return the range that can be collapsed</span><span class="s3">\n</span><span class="s1">when it is.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldNodeProp = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but</span><span class="s3">\n</span><span class="s1">the first and the last child of a syntax node. Useful for nodes</span><span class="s3">\n</span><span class="s1">that start and end with delimiters.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function foldInside(node) {</span><span class="s3">\n    </span><span class="s1">let first = node.firstChild, last = node.lastChild;</span><span class="s3">\n    </span><span class="s1">return first &amp;&amp; first.to &lt; last.from ? { from: first.to, to: last.type.isError ? node.to : last.from } : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function syntaxFolding(state, start, end) {</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state);</span><span class="s3">\n    </span><span class="s1">if (tree.length &lt; end)</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let stack = tree.resolveStack(end, 1);</span><span class="s3">\n    </span><span class="s1">let found = null;</span><span class="s3">\n    </span><span class="s1">for (let iter = stack; iter; iter = iter.next) {</span><span class="s3">\n        </span><span class="s1">let cur = iter.node;</span><span class="s3">\n        </span><span class="s1">if (cur.to &lt;= end || cur.from &gt; end)</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">if (found &amp;&amp; cur.from &lt; start)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">let prop = cur.type.prop(foldNodeProp);</span><span class="s3">\n        </span><span class="s1">if (prop &amp;&amp; (cur.to &lt; tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {</span><span class="s3">\n            </span><span class="s1">let value = prop(cur, state);</span><span class="s3">\n            </span><span class="s1">if (value &amp;&amp; value.from &lt;= end &amp;&amp; value.from &gt;= start &amp;&amp; value.to &gt; end)</span><span class="s3">\n                </span><span class="s1">found = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isUnfinished(node) {</span><span class="s3">\n    </span><span class="s1">let ch = node.lastChild;</span><span class="s3">\n    </span><span class="s1">return ch &amp;&amp; ch.to == node.to &amp;&amp; ch.type.isError;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Check whether the given line is foldable. First asks any fold</span><span class="s3">\n</span><span class="s1">services registered through</span><span class="s3">\n</span><span class="s1">[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return</span><span class="s3">\n</span><span class="s1">a result, tries to query the [fold node</span><span class="s3">\n</span><span class="s1">prop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end</span><span class="s3">\n</span><span class="s1">of the line.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function foldable(state, lineStart, lineEnd) {</span><span class="s3">\n    </span><span class="s1">for (let service of state.facet(foldService)) {</span><span class="s3">\n        </span><span class="s1">let result = service(state, lineStart, lineEnd);</span><span class="s3">\n        </span><span class="s1">if (result)</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return syntaxFolding(state, lineStart, lineEnd);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapRange(range, mapping) {</span><span class="s3">\n    </span><span class="s1">let from = mapping.mapPos(range.from, 1), to = mapping.mapPos(range.to, -1);</span><span class="s3">\n    </span><span class="s1">return from &gt;= to ? undefined : { from, to };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">State effect that can be attached to a transaction to fold the</span><span class="s3">\n</span><span class="s1">given range. (You probably only need this in exceptional</span><span class="s3">\n</span><span class="s1">circumstances—usually you'll just want to let</span><span class="s3">\n</span><span class="s1">[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold</span><span class="s3">\n</span><span class="s1">gutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">State effect that unfolds the given range (if it was folded).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const unfoldEffect = /*@__PURE__*/StateEffect.define({ map: mapRange });</span><span class="s3">\n</span><span class="s1">function selectedLines(view) {</span><span class="s3">\n    </span><span class="s1">let lines = [];</span><span class="s3">\n    </span><span class="s1">for (let { head } of view.state.selection.ranges) {</span><span class="s3">\n        </span><span class="s1">if (lines.some(l =&gt; l.from &lt;= head &amp;&amp; l.to &gt;= head))</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">lines.push(view.lineBlockAt(head));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return lines;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The state field that stores the folded ranges (as a [decoration</span><span class="s3">\n</span><span class="s1">set](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to</span><span class="s3">\n</span><span class="s1">[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and</span><span class="s3">\n</span><span class="s1">[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold</span><span class="s3">\n</span><span class="s1">state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() {</span><span class="s3">\n        </span><span class="s1">return Decoration.none;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">update(folded, tr) {</span><span class="s3">\n        </span><span class="s1">folded = folded.map(tr.changes);</span><span class="s3">\n        </span><span class="s1">for (let e of tr.effects) {</span><span class="s3">\n            </span><span class="s1">if (e.is(foldEffect) &amp;&amp; !foldExists(folded, e.value.from, e.value.to)) {</span><span class="s3">\n                </span><span class="s1">let { preparePlaceholder } = tr.state.facet(foldConfig);</span><span class="s3">\n                </span><span class="s1">let widget = !preparePlaceholder ? foldWidget :</span><span class="s3">\n                    </span><span class="s1">Decoration.replace({ widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value)) });</span><span class="s3">\n                </span><span class="s1">folded = folded.update({ add: [widget.range(e.value.from, e.value.to)] });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (e.is(unfoldEffect)) {</span><span class="s3">\n                </span><span class="s1">folded = folded.update({ filter: (from, to) =&gt; e.value.from != from || e.value.to != to,</span><span class="s3">\n                    </span><span class="s1">filterFrom: e.value.from, filterTo: e.value.to });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Clear folded ranges that cover the selection head</span><span class="s3">\n        </span><span class="s1">if (tr.selection) {</span><span class="s3">\n            </span><span class="s1">let onSelection = false, { head } = tr.selection.main;</span><span class="s3">\n            </span><span class="s1">folded.between(head, head, (a, b) =&gt; { if (a &lt; head &amp;&amp; b &gt; head)</span><span class="s3">\n                </span><span class="s1">onSelection = true; });</span><span class="s3">\n            </span><span class="s1">if (onSelection)</span><span class="s3">\n                </span><span class="s1">folded = folded.update({</span><span class="s3">\n                    </span><span class="s1">filterFrom: head,</span><span class="s3">\n                    </span><span class="s1">filterTo: head,</span><span class="s3">\n                    </span><span class="s1">filter: (a, b) =&gt; b &lt;= head || a &gt;= head</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return folded;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; EditorView.decorations.from(f),</span><span class="s3">\n    </span><span class="s1">toJSON(folded, state) {</span><span class="s3">\n        </span><span class="s1">let ranges = [];</span><span class="s3">\n        </span><span class="s1">folded.between(0, state.doc.length, (from, to) =&gt; { ranges.push(from, to); });</span><span class="s3">\n        </span><span class="s1">return ranges;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">fromJSON(value) {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(value) || value.length % 2)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON for fold state</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let ranges = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; value.length;) {</span><span class="s3">\n            </span><span class="s1">let from = value[i++], to = value[i++];</span><span class="s3">\n            </span><span class="s1">if (typeof from != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof to != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON for fold state</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">ranges.push(foldWidget.range(from, to));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Decoration.set(ranges, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges</span><span class="s3">\n</span><span class="s1">in the given state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function foldedRanges(state) {</span><span class="s3">\n    </span><span class="s1">return state.field(foldState, false) || RangeSet.empty;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findFold(state, from, to) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let found = null;</span><span class="s3">\n    </span><span class="s1">(_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!found || found.from &gt; from)</span><span class="s3">\n            </span><span class="s1">found = { from, to };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function foldExists(folded, from, to) {</span><span class="s3">\n    </span><span class="s1">let found = false;</span><span class="s3">\n    </span><span class="s1">folded.between(from, from, (a, b) =&gt; { if (a == from &amp;&amp; b == to)</span><span class="s3">\n        </span><span class="s1">found = true; });</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maybeEnable(state, other) {</span><span class="s3">\n    </span><span class="s1">return state.field(foldState, false) ? other : other.concat(StateEffect.appendConfig.of(codeFolding()));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Fold the lines that are selected, if possible.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldCode = view =&gt; {</span><span class="s3">\n    </span><span class="s1">for (let line of selectedLines(view)) {</span><span class="s3">\n        </span><span class="s1">let range = foldable(view.state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (range) {</span><span class="s3">\n            </span><span class="s1">view.dispatch({ effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)]) });</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Unfold folded ranges on selected lines.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const unfoldCode = view =&gt; {</span><span class="s3">\n    </span><span class="s1">if (!view.state.field(foldState, false))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let effects = [];</span><span class="s3">\n    </span><span class="s1">for (let line of selectedLines(view)) {</span><span class="s3">\n        </span><span class="s1">let folded = findFold(view.state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (folded)</span><span class="s3">\n            </span><span class="s1">effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (effects.length)</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects });</span><span class="s3">\n    </span><span class="s1">return effects.length &gt; 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function announceFold(view, range, fold = true) {</span><span class="s3">\n    </span><span class="s1">let lineFrom = view.state.doc.lineAt(range.from).number, lineTo = view.state.doc.lineAt(range.to).number;</span><span class="s3">\n    </span><span class="s1">return EditorView.announce.of(`${view.state.phrase(fold ? </span><span class="s3">\&quot;</span><span class="s1">Folded lines</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unfolded lines</span><span class="s3">\&quot;</span><span class="s1">)} ${lineFrom} ${view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">to</span><span class="s3">\&quot;</span><span class="s1">)} ${lineTo}.`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Fold all top-level foldable ranges. Note that, in most cases,</span><span class="s3">\n</span><span class="s1">folding information will depend on the [syntax</span><span class="s3">\n</span><span class="s1">tree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work</span><span class="s3">\n</span><span class="s1">reliably when the document hasn't been fully parsed (either</span><span class="s3">\n</span><span class="s1">because the editor state was only just initialized, or because the</span><span class="s3">\n</span><span class="s1">document is so big that the parser decided not to parse it</span><span class="s3">\n</span><span class="s1">entirely).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldAll = view =&gt; {</span><span class="s3">\n    </span><span class="s1">let { state } = view, effects = [];</span><span class="s3">\n    </span><span class="s1">for (let pos = 0; pos &lt; state.doc.length;) {</span><span class="s3">\n        </span><span class="s1">let line = view.lineBlockAt(pos), range = foldable(state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (range)</span><span class="s3">\n            </span><span class="s1">effects.push(foldEffect.of(range));</span><span class="s3">\n        </span><span class="s1">pos = (range ? view.lineBlockAt(range.to) : line).to + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (effects.length)</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects: maybeEnable(view.state, effects) });</span><span class="s3">\n    </span><span class="s1">return !!effects.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Unfold all folded code.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const unfoldAll = view =&gt; {</span><span class="s3">\n    </span><span class="s1">let field = view.state.field(foldState, false);</span><span class="s3">\n    </span><span class="s1">if (!field || !field.size)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let effects = [];</span><span class="s3">\n    </span><span class="s1">field.between(0, view.state.doc.length, (from, to) =&gt; { effects.push(unfoldEffect.of({ from, to })); });</span><span class="s3">\n    </span><span class="s1">view.dispatch({ effects });</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">// Find the foldable region containing the given line, if one exists</span><span class="s3">\n</span><span class="s1">function foldableContainer(view, lineBlock) {</span><span class="s3">\n    </span><span class="s1">// Look backwards through line blocks until we find a foldable region that</span><span class="s3">\n    </span><span class="s1">// intersects with the line</span><span class="s3">\n    </span><span class="s1">for (let line = lineBlock;;) {</span><span class="s3">\n        </span><span class="s1">let foldableRegion = foldable(view.state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (foldableRegion &amp;&amp; foldableRegion.to &gt; lineBlock.from)</span><span class="s3">\n            </span><span class="s1">return foldableRegion;</span><span class="s3">\n        </span><span class="s1">if (!line.from)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">line = view.lineBlockAt(line.from - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Toggle folding at cursors. Unfolds if there is an existing fold</span><span class="s3">\n</span><span class="s1">starting in that line, tries to find a foldable range around it</span><span class="s3">\n</span><span class="s1">otherwise.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const toggleFold = (view) =&gt; {</span><span class="s3">\n    </span><span class="s1">let effects = [];</span><span class="s3">\n    </span><span class="s1">for (let line of selectedLines(view)) {</span><span class="s3">\n        </span><span class="s1">let folded = findFold(view.state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (folded) {</span><span class="s3">\n            </span><span class="s1">effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let foldRange = foldableContainer(view, line);</span><span class="s3">\n            </span><span class="s1">if (foldRange)</span><span class="s3">\n                </span><span class="s1">effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (effects.length &gt; 0)</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects: maybeEnable(view.state, effects) });</span><span class="s3">\n    </span><span class="s1">return !!effects.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Default fold-related key bindings.</span><span class="s3">\n\n </span><span class="s1">- Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).</span><span class="s3">\n </span><span class="s1">- Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).</span><span class="s3">\n </span><span class="s1">- Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).</span><span class="s3">\n </span><span class="s1">- Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const foldKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Shift-[</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-Alt-[</span><span class="s3">\&quot;</span><span class="s1">, run: foldCode },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Shift-]</span><span class="s3">\&quot;</span><span class="s1">, mac: </span><span class="s3">\&quot;</span><span class="s1">Cmd-Alt-]</span><span class="s3">\&quot;</span><span class="s1">, run: unfoldCode },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Alt-[</span><span class="s3">\&quot;</span><span class="s1">, run: foldAll },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Ctrl-Alt-]</span><span class="s3">\&quot;</span><span class="s1">, run: unfoldAll }</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">const defaultConfig = {</span><span class="s3">\n    </span><span class="s1">placeholderDOM: null,</span><span class="s3">\n    </span><span class="s1">preparePlaceholder: null,</span><span class="s3">\n    </span><span class="s1">placeholderText: </span><span class="s3">\&quot;</span><span class="s1">…</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const foldConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(values) { return combineConfig(values, defaultConfig); }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an extension that configures code folding.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function codeFolding(config) {</span><span class="s3">\n    </span><span class="s1">let result = [foldState, baseTheme$1];</span><span class="s3">\n    </span><span class="s1">if (config)</span><span class="s3">\n        </span><span class="s1">result.push(foldConfig.of(config));</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function widgetToDOM(view, prepared) {</span><span class="s3">\n    </span><span class="s1">let { state } = view, conf = state.facet(foldConfig);</span><span class="s3">\n    </span><span class="s1">let onclick = (event) =&gt; {</span><span class="s3">\n        </span><span class="s1">let line = view.lineBlockAt(view.posAtDOM(event.target));</span><span class="s3">\n        </span><span class="s1">let folded = findFold(view.state, line.from, line.to);</span><span class="s3">\n        </span><span class="s1">if (folded)</span><span class="s3">\n            </span><span class="s1">view.dispatch({ effects: unfoldEffect.of(folded) });</span><span class="s3">\n        </span><span class="s1">event.preventDefault();</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (conf.placeholderDOM)</span><span class="s3">\n        </span><span class="s1">return conf.placeholderDOM(view, onclick, prepared);</span><span class="s3">\n    </span><span class="s1">let element = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">element.textContent = conf.placeholderText;</span><span class="s3">\n    </span><span class="s1">element.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">, state.phrase(</span><span class="s3">\&quot;</span><span class="s1">folded code</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">element.title = state.phrase(</span><span class="s3">\&quot;</span><span class="s1">unfold</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">element.className = </span><span class="s3">\&quot;</span><span class="s1">cm-foldPlaceholder</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">element.onclick = onclick;</span><span class="s3">\n    </span><span class="s1">return element;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const foldWidget = /*@__PURE__*/Decoration.replace({ widget: /*@__PURE__*/new class extends WidgetType {</span><span class="s3">\n        </span><span class="s1">toDOM(view) { return widgetToDOM(view, null); }</span><span class="s3">\n    </span><span class="s1">} });</span><span class="s3">\n</span><span class="s1">class PreparedFoldWidget extends WidgetType {</span><span class="s3">\n    </span><span class="s1">constructor(value) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return this.value == other.value; }</span><span class="s3">\n    </span><span class="s1">toDOM(view) { return widgetToDOM(view, this.value); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const foldGutterDefaults = {</span><span class="s3">\n    </span><span class="s1">openText: </span><span class="s3">\&quot;</span><span class="s1">⌄</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">closedText: </span><span class="s3">\&quot;</span><span class="s1">›</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">markerDOM: null,</span><span class="s3">\n    </span><span class="s1">domEventHandlers: {},</span><span class="s3">\n    </span><span class="s1">foldingChanged: () =&gt; false</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class FoldMarker extends GutterMarker {</span><span class="s3">\n    </span><span class="s1">constructor(config, open) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.config = config;</span><span class="s3">\n        </span><span class="s1">this.open = open;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">eq(other) { return this.config == other.config &amp;&amp; this.open == other.open; }</span><span class="s3">\n    </span><span class="s1">toDOM(view) {</span><span class="s3">\n        </span><span class="s1">if (this.config.markerDOM)</span><span class="s3">\n            </span><span class="s1">return this.config.markerDOM(this.open);</span><span class="s3">\n        </span><span class="s1">let span = document.createElement(</span><span class="s3">\&quot;</span><span class="s1">span</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">span.textContent = this.open ? this.config.openText : this.config.closedText;</span><span class="s3">\n        </span><span class="s1">span.title = view.state.phrase(this.open ? </span><span class="s3">\&quot;</span><span class="s1">Fold line</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Unfold line</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return span;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an extension that registers a fold gutter, which shows a</span><span class="s3">\n</span><span class="s1">fold status indicator before foldable lines (which can be clicked</span><span class="s3">\n</span><span class="s1">to fold or unfold the line).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function foldGutter(config = {}) {</span><span class="s3">\n    </span><span class="s1">let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);</span><span class="s3">\n    </span><span class="s1">let canFold = new FoldMarker(fullConfig, true), canUnfold = new FoldMarker(fullConfig, false);</span><span class="s3">\n    </span><span class="s1">let markers = ViewPlugin.fromClass(class {</span><span class="s3">\n        </span><span class="s1">constructor(view) {</span><span class="s3">\n            </span><span class="s1">this.from = view.viewport.from;</span><span class="s3">\n            </span><span class="s1">this.markers = this.buildMarkers(view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">update(update) {</span><span class="s3">\n            </span><span class="s1">if (update.docChanged || update.viewportChanged ||</span><span class="s3">\n                </span><span class="s1">update.startState.facet(language) != update.state.facet(language) ||</span><span class="s3">\n                </span><span class="s1">update.startState.field(foldState, false) != update.state.field(foldState, false) ||</span><span class="s3">\n                </span><span class="s1">syntaxTree(update.startState) != syntaxTree(update.state) ||</span><span class="s3">\n                </span><span class="s1">fullConfig.foldingChanged(update))</span><span class="s3">\n                </span><span class="s1">this.markers = this.buildMarkers(update.view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">buildMarkers(view) {</span><span class="s3">\n            </span><span class="s1">let builder = new RangeSetBuilder();</span><span class="s3">\n            </span><span class="s1">for (let line of view.viewportLineBlocks) {</span><span class="s3">\n                </span><span class="s1">let mark = findFold(view.state, line.from, line.to) ? canUnfold</span><span class="s3">\n                    </span><span class="s1">: foldable(view.state, line.from, line.to) ? canFold : null;</span><span class="s3">\n                </span><span class="s1">if (mark)</span><span class="s3">\n                    </span><span class="s1">builder.add(line.from, line.from, mark);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return builder.finish();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">let { domEventHandlers } = fullConfig;</span><span class="s3">\n    </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">markers,</span><span class="s3">\n        </span><span class="s1">gutter({</span><span class="s3">\n            </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-foldGutter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">markers(view) { var _a; return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || RangeSet.empty; },</span><span class="s3">\n            </span><span class="s1">initialSpacer() {</span><span class="s3">\n                </span><span class="s1">return new FoldMarker(fullConfig, false);</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), { click: (view, line, event) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (domEventHandlers.click &amp;&amp; domEventHandlers.click(view, line, event))</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                    </span><span class="s1">let folded = findFold(view.state, line.from, line.to);</span><span class="s3">\n                    </span><span class="s1">if (folded) {</span><span class="s3">\n                        </span><span class="s1">view.dispatch({ effects: unfoldEffect.of(folded) });</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">let range = foldable(view.state, line.from, line.to);</span><span class="s3">\n                    </span><span class="s1">if (range) {</span><span class="s3">\n                        </span><span class="s1">view.dispatch({ effects: foldEffect.of(range) });</span><span class="s3">\n                        </span><span class="s1">return true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return false;</span><span class="s3">\n                </span><span class="s1">} })</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">codeFolding()</span><span class="s3">\n    </span><span class="s1">];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-foldPlaceholder</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#eee</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">1px solid #ddd</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#888</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">borderRadius: </span><span class="s3">\&quot;</span><span class="s1">.2em</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">margin: </span><span class="s3">\&quot;</span><span class="s1">0 1px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">0 1px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">cursor: </span><span class="s3">\&quot;</span><span class="s1">pointer</span><span class="s3">\&quot;\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-foldGutter span</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">0 1px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">cursor: </span><span class="s3">\&quot;</span><span class="s1">pointer</span><span class="s3">\&quot;\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A highlight style associates CSS styles with higlighting</span><span class="s3">\n</span><span class="s1">[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class HighlightStyle {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The tag styles used to create this highlight style.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">specs, options) {</span><span class="s3">\n        </span><span class="s1">this.specs = specs;</span><span class="s3">\n        </span><span class="s1">let modSpec;</span><span class="s3">\n        </span><span class="s1">function def(spec) {</span><span class="s3">\n            </span><span class="s1">let cls = StyleModule.newName();</span><span class="s3">\n            </span><span class="s1">(modSpec || (modSpec = Object.create(null)))[</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">+ cls] = spec;</span><span class="s3">\n            </span><span class="s1">return cls;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const all = typeof options.all == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? options.all : options.all ? def(options.all) : undefined;</span><span class="s3">\n        </span><span class="s1">const scopeOpt = options.scope;</span><span class="s3">\n        </span><span class="s1">this.scope = scopeOpt instanceof Language ? (type) =&gt; type.prop(languageDataProp) == scopeOpt.data</span><span class="s3">\n            </span><span class="s1">: scopeOpt ? (type) =&gt; type == scopeOpt : undefined;</span><span class="s3">\n        </span><span class="s1">this.style = tagHighlighter(specs.map(style =&gt; ({</span><span class="s3">\n            </span><span class="s1">tag: style.tag,</span><span class="s3">\n            </span><span class="s1">class: style.class || def(Object.assign({}, style, { tag: null }))</span><span class="s3">\n        </span><span class="s1">})), {</span><span class="s3">\n            </span><span class="s1">all,</span><span class="s3">\n        </span><span class="s1">}).style;</span><span class="s3">\n        </span><span class="s1">this.module = modSpec ? new StyleModule(modSpec) : null;</span><span class="s3">\n        </span><span class="s1">this.themeType = options.themeType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a highlighter style that associates the given styles to</span><span class="s3">\n    </span><span class="s1">the given tags. The specs must be objects that hold a style tag</span><span class="s3">\n    </span><span class="s1">or array of tags in their `tag` property, and either a single</span><span class="s3">\n    </span><span class="s1">`class` property providing a static CSS class (for highlighter</span><span class="s3">\n    </span><span class="s1">that rely on external styling), or a</span><span class="s3">\n    </span><span class="s1">[`style-mod`](https://github.com/marijnh/style-mod#documentation)-style</span><span class="s3">\n    </span><span class="s1">set of CSS properties (which define the styling for those tags).</span><span class="s3">\n    \n    </span><span class="s1">The CSS rules created for a highlighter will be emitted in the</span><span class="s3">\n    </span><span class="s1">order of the spec's properties. That means that for elements that</span><span class="s3">\n    </span><span class="s1">have multiple tags associated with them, styles defined further</span><span class="s3">\n    </span><span class="s1">down in the list will have a higher CSS precedence than styles</span><span class="s3">\n    </span><span class="s1">defined earlier.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(specs, options) {</span><span class="s3">\n        </span><span class="s1">return new HighlightStyle(specs, options || {});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const highlighterFacet = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const fallbackHighlighter = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(values) { return values.length ? [values[0]] : null; }</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function getHighlighters(state) {</span><span class="s3">\n    </span><span class="s1">let main = state.facet(highlighterFacet);</span><span class="s3">\n    </span><span class="s1">return main.length ? main : state.facet(fallbackHighlighter);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Wrap a highlighter in an editor extension that uses it to apply</span><span class="s3">\n</span><span class="s1">syntax highlighting to the editor content.</span><span class="s3">\n\n</span><span class="s1">When multiple (non-fallback) styles are provided, the styling</span><span class="s3">\n</span><span class="s1">applied is the union of the classes they emit.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function syntaxHighlighting(highlighter, options) {</span><span class="s3">\n    </span><span class="s1">let ext = [treeHighlighter], themeType;</span><span class="s3">\n    </span><span class="s1">if (highlighter instanceof HighlightStyle) {</span><span class="s3">\n        </span><span class="s1">if (highlighter.module)</span><span class="s3">\n            </span><span class="s1">ext.push(EditorView.styleModule.of(highlighter.module));</span><span class="s3">\n        </span><span class="s1">themeType = highlighter.themeType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options === null || options === void 0 ? void 0 : options.fallback)</span><span class="s3">\n        </span><span class="s1">ext.push(fallbackHighlighter.of(highlighter));</span><span class="s3">\n    </span><span class="s1">else if (themeType)</span><span class="s3">\n        </span><span class="s1">ext.push(highlighterFacet.computeN([EditorView.darkTheme], state =&gt; {</span><span class="s3">\n            </span><span class="s1">return state.facet(EditorView.darkTheme) == (themeType == </span><span class="s3">\&quot;</span><span class="s1">dark</span><span class="s3">\&quot;</span><span class="s1">) ? [highlighter] : [];</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">ext.push(highlighterFacet.of(highlighter));</span><span class="s3">\n    </span><span class="s1">return ext;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns the CSS classes (if any) that the highlighters active in</span><span class="s3">\n</span><span class="s1">the state would assign to the given style</span><span class="s3">\n</span><span class="s1">[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and</span><span class="s3">\n</span><span class="s1">(optional) language</span><span class="s3">\n</span><span class="s1">[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightingFor(state, tags, scope) {</span><span class="s3">\n    </span><span class="s1">let highlighters = getHighlighters(state);</span><span class="s3">\n    </span><span class="s1">let result = null;</span><span class="s3">\n    </span><span class="s1">if (highlighters)</span><span class="s3">\n        </span><span class="s1">for (let highlighter of highlighters) {</span><span class="s3">\n            </span><span class="s1">if (!highlighter.scope || scope &amp;&amp; highlighter.scope(scope)) {</span><span class="s3">\n                </span><span class="s1">let cls = highlighter.style(tags);</span><span class="s3">\n                </span><span class="s1">if (cls)</span><span class="s3">\n                    </span><span class="s1">result = result ? result + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ cls : cls;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class TreeHighlighter {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.markCache = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.tree = syntaxTree(view.state);</span><span class="s3">\n        </span><span class="s1">this.decorations = this.buildDeco(view, getHighlighters(view.state));</span><span class="s3">\n        </span><span class="s1">this.decoratedTo = view.viewport.to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let tree = syntaxTree(update.state), highlighters = getHighlighters(update.state);</span><span class="s3">\n        </span><span class="s1">let styleChange = highlighters != getHighlighters(update.startState);</span><span class="s3">\n        </span><span class="s1">let { viewport } = update.view, decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);</span><span class="s3">\n        </span><span class="s1">if (tree.length &lt; viewport.to &amp;&amp; !styleChange &amp;&amp; tree.type == this.tree.type &amp;&amp; decoratedToMapped &gt;= viewport.to) {</span><span class="s3">\n            </span><span class="s1">this.decorations = this.decorations.map(update.changes);</span><span class="s3">\n            </span><span class="s1">this.decoratedTo = decoratedToMapped;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (tree != this.tree || update.viewportChanged || styleChange) {</span><span class="s3">\n            </span><span class="s1">this.tree = tree;</span><span class="s3">\n            </span><span class="s1">this.decorations = this.buildDeco(update.view, highlighters);</span><span class="s3">\n            </span><span class="s1">this.decoratedTo = viewport.to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">buildDeco(view, highlighters) {</span><span class="s3">\n        </span><span class="s1">if (!highlighters || !this.tree.length)</span><span class="s3">\n            </span><span class="s1">return Decoration.none;</span><span class="s3">\n        </span><span class="s1">let builder = new RangeSetBuilder();</span><span class="s3">\n        </span><span class="s1">for (let { from, to } of view.visibleRanges) {</span><span class="s3">\n            </span><span class="s1">highlightTree(this.tree, highlighters, (from, to, style) =&gt; {</span><span class="s3">\n                </span><span class="s1">builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));</span><span class="s3">\n            </span><span class="s1">}, from, to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return builder.finish();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const treeHighlighter = /*@__PURE__*/Prec.high(/*@__PURE__*/ViewPlugin.fromClass(TreeHighlighter, {</span><span class="s3">\n    </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A default highlight style (works well with light themes).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([</span><span class="s3">\n    </span><span class="s1">{ tag: tags.meta,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#404740</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.link,</span><span class="s3">\n        </span><span class="s1">textDecoration: </span><span class="s3">\&quot;</span><span class="s1">underline</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.heading,</span><span class="s3">\n        </span><span class="s1">textDecoration: </span><span class="s3">\&quot;</span><span class="s1">underline</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">fontWeight: </span><span class="s3">\&quot;</span><span class="s1">bold</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.emphasis,</span><span class="s3">\n        </span><span class="s1">fontStyle: </span><span class="s3">\&quot;</span><span class="s1">italic</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.strong,</span><span class="s3">\n        </span><span class="s1">fontWeight: </span><span class="s3">\&quot;</span><span class="s1">bold</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.strikethrough,</span><span class="s3">\n        </span><span class="s1">textDecoration: </span><span class="s3">\&quot;</span><span class="s1">line-through</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.keyword,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#708</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#219</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.literal, tags.inserted],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#164</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.string, tags.deleted],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#a11</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.regexp, tags.escape, /*@__PURE__*/tags.special(tags.string)],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#e40</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: /*@__PURE__*/tags.definition(tags.variableName),</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#00f</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: /*@__PURE__*/tags.local(tags.variableName),</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#30a</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [tags.typeName, tags.namespace],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#085</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.className,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#167</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: [/*@__PURE__*/tags.special(tags.variableName), tags.macroName],</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#256</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: /*@__PURE__*/tags.definition(tags.propertyName),</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#00c</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.comment,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#940</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ tag: tags.invalid,</span><span class="s3">\n        </span><span class="s1">color: </span><span class="s3">\&quot;</span><span class="s1">#f00</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n\n</span><span class="s1">const baseTheme = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;.cm-focused .cm-matchingBracket</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#328c8252</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;.cm-focused .cm-nonmatchingBracket</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#bb555544</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const DefaultScanDist = 10000, DefaultBrackets = </span><span class="s3">\&quot;</span><span class="s1">()[]{}</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const bracketMatchingConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">afterCursor: true,</span><span class="s3">\n            </span><span class="s1">brackets: DefaultBrackets,</span><span class="s3">\n            </span><span class="s1">maxScanDistance: DefaultScanDist,</span><span class="s3">\n            </span><span class="s1">renderMatch: defaultRenderMatch</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const matchingMark = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-matchingBracket</span><span class="s3">\&quot; </span><span class="s1">}), nonmatchingMark = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-nonmatchingBracket</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function defaultRenderMatch(match) {</span><span class="s3">\n    </span><span class="s1">let decorations = [];</span><span class="s3">\n    </span><span class="s1">let mark = match.matched ? matchingMark : nonmatchingMark;</span><span class="s3">\n    </span><span class="s1">decorations.push(mark.range(match.start.from, match.start.to));</span><span class="s3">\n    </span><span class="s1">if (match.end)</span><span class="s3">\n        </span><span class="s1">decorations.push(mark.range(match.end.from, match.end.to));</span><span class="s3">\n    </span><span class="s1">return decorations;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const bracketMatchingState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return Decoration.none; },</span><span class="s3">\n    </span><span class="s1">update(deco, tr) {</span><span class="s3">\n        </span><span class="s1">if (!tr.docChanged &amp;&amp; !tr.selection)</span><span class="s3">\n            </span><span class="s1">return deco;</span><span class="s3">\n        </span><span class="s1">let decorations = [];</span><span class="s3">\n        </span><span class="s1">let config = tr.state.facet(bracketMatchingConfig);</span><span class="s3">\n        </span><span class="s1">for (let range of tr.state.selection.ranges) {</span><span class="s3">\n            </span><span class="s1">if (!range.empty)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">let match = matchBrackets(tr.state, range.head, -1, config)</span><span class="s3">\n                </span><span class="s1">|| (range.head &gt; 0 &amp;&amp; matchBrackets(tr.state, range.head - 1, 1, config))</span><span class="s3">\n                </span><span class="s1">|| (config.afterCursor &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(matchBrackets(tr.state, range.head, 1, config) ||</span><span class="s3">\n                        </span><span class="s1">(range.head &lt; tr.state.doc.length &amp;&amp; matchBrackets(tr.state, range.head + 1, -1, config))));</span><span class="s3">\n            </span><span class="s1">if (match)</span><span class="s3">\n                </span><span class="s1">decorations = decorations.concat(config.renderMatch(match, tr.state));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Decoration.set(decorations, true);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; EditorView.decorations.from(f)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const bracketMatchingUnique = [</span><span class="s3">\n    </span><span class="s1">bracketMatchingState,</span><span class="s3">\n    </span><span class="s1">baseTheme</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Create an extension that enables bracket matching. Whenever the</span><span class="s3">\n</span><span class="s1">cursor is next to a bracket, that bracket and the one it matches</span><span class="s3">\n</span><span class="s1">are highlighted. Or, when no matching bracket is found, another</span><span class="s3">\n</span><span class="s1">highlighting style is used to indicate this.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function bracketMatching(config = {}) {</span><span class="s3">\n    </span><span class="s1">return [bracketMatchingConfig.of(config), bracketMatchingUnique];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">When larger syntax nodes, such as HTML tags, are marked as</span><span class="s3">\n</span><span class="s1">opening/closing, it can be a bit messy to treat the whole node as</span><span class="s3">\n</span><span class="s1">a matchable bracket. This node prop allows you to define, for such</span><span class="s3">\n</span><span class="s1">a node, a ‘handle’—the part of the node that is highlighted, and</span><span class="s3">\n</span><span class="s1">that the cursor must be on to activate highlighting in the first</span><span class="s3">\n</span><span class="s1">place.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const bracketMatchingHandle = /*@__PURE__*/new NodeProp();</span><span class="s3">\n</span><span class="s1">function matchingNodes(node, dir, brackets) {</span><span class="s3">\n    </span><span class="s1">let byProp = node.prop(dir &lt; 0 ? NodeProp.openedBy : NodeProp.closedBy);</span><span class="s3">\n    </span><span class="s1">if (byProp)</span><span class="s3">\n        </span><span class="s1">return byProp;</span><span class="s3">\n    </span><span class="s1">if (node.name.length == 1) {</span><span class="s3">\n        </span><span class="s1">let index = brackets.indexOf(node.name);</span><span class="s3">\n        </span><span class="s1">if (index &gt; -1 &amp;&amp; index % 2 == (dir &lt; 0 ? 1 : 0))</span><span class="s3">\n            </span><span class="s1">return [brackets[index + dir]];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findHandle(node) {</span><span class="s3">\n    </span><span class="s1">let hasHandle = node.type.prop(bracketMatchingHandle);</span><span class="s3">\n    </span><span class="s1">return hasHandle ? hasHandle(node.node) : node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Find the matching bracket for the token at `pos`, scanning</span><span class="s3">\n</span><span class="s1">direction `dir`. Only the `brackets` and `maxScanDistance`</span><span class="s3">\n</span><span class="s1">properties are used from `config`, if given. Returns null if no</span><span class="s3">\n</span><span class="s1">bracket was found at `pos`, or a match result otherwise.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function matchBrackets(state, pos, dir, config = {}) {</span><span class="s3">\n    </span><span class="s1">let maxScanDistance = config.maxScanDistance || DefaultScanDist, brackets = config.brackets || DefaultBrackets;</span><span class="s3">\n    </span><span class="s1">let tree = syntaxTree(state), node = tree.resolveInner(pos, dir);</span><span class="s3">\n    </span><span class="s1">for (let cur = node; cur; cur = cur.parent) {</span><span class="s3">\n        </span><span class="s1">let matches = matchingNodes(cur.type, dir, brackets);</span><span class="s3">\n        </span><span class="s1">if (matches &amp;&amp; cur.from &lt; cur.to) {</span><span class="s3">\n            </span><span class="s1">let handle = findHandle(cur);</span><span class="s3">\n            </span><span class="s1">if (handle &amp;&amp; (dir &gt; 0 ? pos &gt;= handle.from &amp;&amp; pos &lt; handle.to : pos &gt; handle.from &amp;&amp; pos &lt;= handle.to))</span><span class="s3">\n                </span><span class="s1">return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {</span><span class="s3">\n    </span><span class="s1">let parent = token.parent, firstToken = { from: handle.from, to: handle.to };</span><span class="s3">\n    </span><span class="s1">let depth = 0, cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();</span><span class="s3">\n    </span><span class="s1">if (cursor &amp;&amp; (dir &lt; 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to)))</span><span class="s3">\n        </span><span class="s1">do {</span><span class="s3">\n            </span><span class="s1">if (dir &lt; 0 ? cursor.to &lt;= token.from : cursor.from &gt;= token.to) {</span><span class="s3">\n                </span><span class="s1">if (depth == 0 &amp;&amp; matching.indexOf(cursor.type.name) &gt; -1 &amp;&amp; cursor.from &lt; cursor.to) {</span><span class="s3">\n                    </span><span class="s1">let endHandle = findHandle(cursor);</span><span class="s3">\n                    </span><span class="s1">return { start: firstToken, end: endHandle ? { from: endHandle.from, to: endHandle.to } : undefined, matched: true };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (matchingNodes(cursor.type, dir, brackets)) {</span><span class="s3">\n                    </span><span class="s1">depth++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (matchingNodes(cursor.type, -dir, brackets)) {</span><span class="s3">\n                    </span><span class="s1">if (depth == 0) {</span><span class="s3">\n                        </span><span class="s1">let endHandle = findHandle(cursor);</span><span class="s3">\n                        </span><span class="s1">return {</span><span class="s3">\n                            </span><span class="s1">start: firstToken,</span><span class="s3">\n                            </span><span class="s1">end: endHandle &amp;&amp; endHandle.from &lt; endHandle.to ? { from: endHandle.from, to: endHandle.to } : undefined,</span><span class="s3">\n                            </span><span class="s1">matched: false</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">depth--;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} while (dir &lt; 0 ? cursor.prevSibling() : cursor.nextSibling());</span><span class="s3">\n    </span><span class="s1">return { start: firstToken, matched: false };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {</span><span class="s3">\n    </span><span class="s1">let startCh = dir &lt; 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);</span><span class="s3">\n    </span><span class="s1">let bracket = brackets.indexOf(startCh);</span><span class="s3">\n    </span><span class="s1">if (bracket &lt; 0 || (bracket % 2 == 0) != (dir &gt; 0))</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">let startToken = { from: dir &lt; 0 ? pos - 1 : pos, to: dir &gt; 0 ? pos + 1 : pos };</span><span class="s3">\n    </span><span class="s1">let iter = state.doc.iterRange(pos, dir &gt; 0 ? state.doc.length : 0), depth = 0;</span><span class="s3">\n    </span><span class="s1">for (let distance = 0; !(iter.next()).done &amp;&amp; distance &lt;= maxScanDistance;) {</span><span class="s3">\n        </span><span class="s1">let text = iter.value;</span><span class="s3">\n        </span><span class="s1">if (dir &lt; 0)</span><span class="s3">\n            </span><span class="s1">distance += text.length;</span><span class="s3">\n        </span><span class="s1">let basePos = pos + distance * dir;</span><span class="s3">\n        </span><span class="s1">for (let pos = dir &gt; 0 ? 0 : text.length - 1, end = dir &gt; 0 ? text.length : -1; pos != end; pos += dir) {</span><span class="s3">\n            </span><span class="s1">let found = brackets.indexOf(text[pos]);</span><span class="s3">\n            </span><span class="s1">if (found &lt; 0 || tree.resolveInner(basePos + pos, 1).type != tokenType)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if ((found % 2 == 0) == (dir &gt; 0)) {</span><span class="s3">\n                </span><span class="s1">depth++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (depth == 1) { // Closing</span><span class="s3">\n                </span><span class="s1">return { start: startToken, end: { from: basePos + pos, to: basePos + pos + 1 }, matched: (found &gt;&gt; 1) == (bracket &gt;&gt; 1) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">depth--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (dir &gt; 0)</span><span class="s3">\n            </span><span class="s1">distance += text.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return iter.done ? { start: startToken, matched: false } : null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Counts the column offset in a string, taking tabs into account.</span><span class="s3">\n</span><span class="s1">// Used mostly to find indentation.</span><span class="s3">\n</span><span class="s1">function countCol(string, end, tabSize, startIndex = 0, startValue = 0) {</span><span class="s3">\n    </span><span class="s1">if (end == null) {</span><span class="s3">\n        </span><span class="s1">end = string.search(/[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">u00a0]/);</span><span class="s3">\n        </span><span class="s1">if (end == -1)</span><span class="s3">\n            </span><span class="s1">end = string.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let n = startValue;</span><span class="s3">\n    </span><span class="s1">for (let i = startIndex; i &lt; end; i++) {</span><span class="s3">\n        </span><span class="s1">if (string.charCodeAt(i) == 9)</span><span class="s3">\n            </span><span class="s1">n += tabSize - (n % tabSize);</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">n++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return n;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Encapsulates a single line of input. Given to stream syntax code,</span><span class="s3">\n</span><span class="s1">which uses it to tokenize the content.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class StringStream {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a stream.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">string, tabSize, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current indent unit size.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">indentUnit, overrideIndent) {</span><span class="s3">\n        </span><span class="s1">this.string = string;</span><span class="s3">\n        </span><span class="s1">this.tabSize = tabSize;</span><span class="s3">\n        </span><span class="s1">this.indentUnit = indentUnit;</span><span class="s3">\n        </span><span class="s1">this.overrideIndent = overrideIndent;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">The current position on the line.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.pos = 0;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">The start position of the current token.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.start = 0;</span><span class="s3">\n        </span><span class="s1">this.lastColumnPos = 0;</span><span class="s3">\n        </span><span class="s1">this.lastColumnValue = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True if we are at the end of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eol() { return this.pos &gt;= this.string.length; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True if we are at the start of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sol() { return this.pos == 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the next code unit after the current position, or undefined</span><span class="s3">\n    </span><span class="s1">if we're at the end of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">peek() { return this.string.charAt(this.pos) || undefined; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Read the next code unit and advance `this.pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">if (this.pos &lt; this.string.length)</span><span class="s3">\n            </span><span class="s1">return this.string.charAt(this.pos++);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Match the next character against the given string, regular</span><span class="s3">\n    </span><span class="s1">expression, or predicate. Consume and return it if it matches.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eat(match) {</span><span class="s3">\n        </span><span class="s1">let ch = this.string.charAt(this.pos);</span><span class="s3">\n        </span><span class="s1">let ok;</span><span class="s3">\n        </span><span class="s1">if (typeof match == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">ok = ch == match;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">ok = ch &amp;&amp; (match instanceof RegExp ? match.test(ch) : match(ch));</span><span class="s3">\n        </span><span class="s1">if (ok) {</span><span class="s3">\n            </span><span class="s1">++this.pos;</span><span class="s3">\n            </span><span class="s1">return ch;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Continue matching characters that match the given string,</span><span class="s3">\n    </span><span class="s1">regular expression, or predicate function. Return true if any</span><span class="s3">\n    </span><span class="s1">characters were consumed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eatWhile(match) {</span><span class="s3">\n        </span><span class="s1">let start = this.pos;</span><span class="s3">\n        </span><span class="s1">while (this.eat(match)) { }</span><span class="s3">\n        </span><span class="s1">return this.pos &gt; start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Consume whitespace ahead of `this.pos`. Return true if any was</span><span class="s3">\n    </span><span class="s1">found.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eatSpace() {</span><span class="s3">\n        </span><span class="s1">let start = this.pos;</span><span class="s3">\n        </span><span class="s1">while (/[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">u00a0]/.test(this.string.charAt(this.pos)))</span><span class="s3">\n            </span><span class="s1">++this.pos;</span><span class="s3">\n        </span><span class="s1">return this.pos &gt; start;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the end of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">skipToEnd() { this.pos = this.string.length; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to directly before the given character, if found on the</span><span class="s3">\n    </span><span class="s1">current line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">skipTo(ch) {</span><span class="s3">\n        </span><span class="s1">let found = this.string.indexOf(ch, this.pos);</span><span class="s3">\n        </span><span class="s1">if (found &gt; -1) {</span><span class="s3">\n            </span><span class="s1">this.pos = found;</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move back `n` characters.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">backUp(n) { this.pos -= n; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the column position at `this.pos`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">column() {</span><span class="s3">\n        </span><span class="s1">if (this.lastColumnPos &lt; this.start) {</span><span class="s3">\n            </span><span class="s1">this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);</span><span class="s3">\n            </span><span class="s1">this.lastColumnPos = this.start;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.lastColumnValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the indentation column of the current line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">indentation() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return (_a = this.overrideIndent) !== null &amp;&amp; _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Match the input against the given string or regular expression</span><span class="s3">\n    </span><span class="s1">(which should start with a `^`). Return true or the regexp match</span><span class="s3">\n    </span><span class="s1">if it matches.</span><span class="s3">\n    \n    </span><span class="s1">Unless `consume` is set to `false`, this will move `this.pos`</span><span class="s3">\n    </span><span class="s1">past the matched text.</span><span class="s3">\n    \n    </span><span class="s1">When matching a string `caseInsensitive` can be set to true to</span><span class="s3">\n    </span><span class="s1">make the match case-insensitive.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">match(pattern, consume, caseInsensitive) {</span><span class="s3">\n        </span><span class="s1">if (typeof pattern == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">let cased = (str) =&gt; caseInsensitive ? str.toLowerCase() : str;</span><span class="s3">\n            </span><span class="s1">let substr = this.string.substr(this.pos, pattern.length);</span><span class="s3">\n            </span><span class="s1">if (cased(substr) == cased(pattern)) {</span><span class="s3">\n                </span><span class="s1">if (consume !== false)</span><span class="s3">\n                    </span><span class="s1">this.pos += pattern.length;</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let match = this.string.slice(this.pos).match(pattern);</span><span class="s3">\n            </span><span class="s1">if (match &amp;&amp; match.index &gt; 0)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">if (match &amp;&amp; consume !== false)</span><span class="s3">\n                </span><span class="s1">this.pos += match[0].length;</span><span class="s3">\n            </span><span class="s1">return match;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the current token.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">current() { return this.string.slice(this.start, this.pos); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function fullParser(spec) {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">name: spec.name || </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">token: spec.token,</span><span class="s3">\n        </span><span class="s1">blankLine: spec.blankLine || (() =&gt; { }),</span><span class="s3">\n        </span><span class="s1">startState: spec.startState || (() =&gt; true),</span><span class="s3">\n        </span><span class="s1">copyState: spec.copyState || defaultCopyState,</span><span class="s3">\n        </span><span class="s1">indent: spec.indent || (() =&gt; null),</span><span class="s3">\n        </span><span class="s1">languageData: spec.languageData || {},</span><span class="s3">\n        </span><span class="s1">tokenTable: spec.tokenTable || noTokens</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultCopyState(state) {</span><span class="s3">\n    </span><span class="s1">if (typeof state != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">return state;</span><span class="s3">\n    </span><span class="s1">let newState = {};</span><span class="s3">\n    </span><span class="s1">for (let prop in state) {</span><span class="s3">\n        </span><span class="s1">let val = state[prop];</span><span class="s3">\n        </span><span class="s1">newState[prop] = (val instanceof Array ? val.slice() : val);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newState;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const IndentedFrom = /*@__PURE__*/new WeakMap();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror</span><span class="s3">\n</span><span class="s1">5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class StreamLanguage extends Language {</span><span class="s3">\n    </span><span class="s1">constructor(parser) {</span><span class="s3">\n        </span><span class="s1">let data = defineLanguageFacet(parser.languageData);</span><span class="s3">\n        </span><span class="s1">let p = fullParser(parser), self;</span><span class="s3">\n        </span><span class="s1">let impl = new class extends Parser {</span><span class="s3">\n            </span><span class="s1">createParse(input, fragments, ranges) {</span><span class="s3">\n                </span><span class="s1">return new Parse(self, input, fragments, ranges);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">super(data, impl, [], parser.name);</span><span class="s3">\n        </span><span class="s1">this.topNode = docID(data, this);</span><span class="s3">\n        </span><span class="s1">self = this;</span><span class="s3">\n        </span><span class="s1">this.streamParser = p;</span><span class="s3">\n        </span><span class="s1">this.stateAfter = new NodeProp({ perNode: true });</span><span class="s3">\n        </span><span class="s1">this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a stream language.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(spec) { return new StreamLanguage(spec); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getIndent(cx) {</span><span class="s3">\n        </span><span class="s1">let from = undefined;</span><span class="s3">\n        </span><span class="s1">let { overrideIndentation } = cx.options;</span><span class="s3">\n        </span><span class="s1">if (overrideIndentation) {</span><span class="s3">\n            </span><span class="s1">from = IndentedFrom.get(cx.state);</span><span class="s3">\n            </span><span class="s1">if (from != null &amp;&amp; from &lt; cx.pos - 1e4)</span><span class="s3">\n                </span><span class="s1">from = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let start = findState(this, cx.node.tree, cx.node.from, cx.node.from, from !== null &amp;&amp; from !== void 0 ? from : cx.pos), statePos, state;</span><span class="s3">\n        </span><span class="s1">if (start) {</span><span class="s3">\n            </span><span class="s1">state = start.state;</span><span class="s3">\n            </span><span class="s1">statePos = start.pos + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">state = this.streamParser.startState(cx.unit);</span><span class="s3">\n            </span><span class="s1">statePos = cx.node.from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cx.pos - statePos &gt; 10000 /* C.MaxIndentScanDist */)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">while (statePos &lt; cx.pos) {</span><span class="s3">\n            </span><span class="s1">let line = cx.state.doc.lineAt(statePos), end = Math.min(cx.pos, line.to);</span><span class="s3">\n            </span><span class="s1">if (line.length) {</span><span class="s3">\n                </span><span class="s1">let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;</span><span class="s3">\n                </span><span class="s1">let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation &lt; 0 ? undefined : indentation);</span><span class="s3">\n                </span><span class="s1">while (stream.pos &lt; end - line.from)</span><span class="s3">\n                    </span><span class="s1">readToken(this.streamParser.token, stream, state);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.streamParser.blankLine(state, cx.unit);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (end == cx.pos)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">statePos = line.to + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let line = cx.lineAt(cx.pos);</span><span class="s3">\n        </span><span class="s1">if (overrideIndentation &amp;&amp; from == null)</span><span class="s3">\n            </span><span class="s1">IndentedFrom.set(cx.state, line.from);</span><span class="s3">\n        </span><span class="s1">return this.streamParser.indent(state, /^</span><span class="s3">\\</span><span class="s1">s*(.*)/.exec(line.text)[1], cx);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get allowsNesting() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findState(lang, tree, off, startPos, before) {</span><span class="s3">\n    </span><span class="s1">let state = off &gt;= startPos &amp;&amp; off + tree.length &lt;= before &amp;&amp; tree.prop(lang.stateAfter);</span><span class="s3">\n    </span><span class="s1">if (state)</span><span class="s3">\n        </span><span class="s1">return { state: lang.streamParser.copyState(state), pos: off + tree.length };</span><span class="s3">\n    </span><span class="s1">for (let i = tree.children.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let child = tree.children[i], pos = off + tree.positions[i];</span><span class="s3">\n        </span><span class="s1">let found = child instanceof Tree &amp;&amp; pos &lt; before &amp;&amp; findState(lang, child, pos, startPos, before);</span><span class="s3">\n        </span><span class="s1">if (found)</span><span class="s3">\n            </span><span class="s1">return found;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cutTree(lang, tree, from, to, inside) {</span><span class="s3">\n    </span><span class="s1">if (inside &amp;&amp; from &lt;= 0 &amp;&amp; to &gt;= tree.length)</span><span class="s3">\n        </span><span class="s1">return tree;</span><span class="s3">\n    </span><span class="s1">if (!inside &amp;&amp; from == 0 &amp;&amp; tree.type == lang.topNode)</span><span class="s3">\n        </span><span class="s1">inside = true;</span><span class="s3">\n    </span><span class="s1">for (let i = tree.children.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let pos = tree.positions[i], child = tree.children[i], inner;</span><span class="s3">\n        </span><span class="s1">if (pos &lt; to &amp;&amp; child instanceof Tree) {</span><span class="s3">\n            </span><span class="s1">if (!(inner = cutTree(lang, child, from - pos, to - pos, inside)))</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">return !inside ? inner</span><span class="s3">\n                </span><span class="s1">: new Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findStartInFragments(lang, fragments, startPos, endPos, editorState) {</span><span class="s3">\n    </span><span class="s1">for (let f of fragments) {</span><span class="s3">\n        </span><span class="s1">let from = f.from + (f.openStart ? 25 : 0), to = f.to - (f.openEnd ? 25 : 0);</span><span class="s3">\n        </span><span class="s1">let found = from &lt;= startPos &amp;&amp; to &gt; startPos &amp;&amp; findState(lang, f.tree, 0 - f.offset, startPos, to), tree;</span><span class="s3">\n        </span><span class="s1">if (found &amp;&amp; found.pos &lt;= endPos &amp;&amp; (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false)))</span><span class="s3">\n            </span><span class="s1">return { state: found.state, tree };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4), tree: Tree.empty };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Parse {</span><span class="s3">\n    </span><span class="s1">constructor(lang, input, fragments, ranges) {</span><span class="s3">\n        </span><span class="s1">this.lang = lang;</span><span class="s3">\n        </span><span class="s1">this.input = input;</span><span class="s3">\n        </span><span class="s1">this.fragments = fragments;</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = null;</span><span class="s3">\n        </span><span class="s1">this.chunks = [];</span><span class="s3">\n        </span><span class="s1">this.chunkPos = [];</span><span class="s3">\n        </span><span class="s1">this.chunk = [];</span><span class="s3">\n        </span><span class="s1">this.chunkReused = undefined;</span><span class="s3">\n        </span><span class="s1">this.rangeIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.to = ranges[ranges.length - 1].to;</span><span class="s3">\n        </span><span class="s1">let context = ParseContext.get(), from = ranges[0].from;</span><span class="s3">\n        </span><span class="s1">let { state, tree } = findStartInFragments(lang, fragments, from, this.to, context === null || context === void 0 ? void 0 : context.state);</span><span class="s3">\n        </span><span class="s1">this.state = state;</span><span class="s3">\n        </span><span class="s1">this.parsedPos = this.chunkStart = from + tree.length;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; tree.children.length; i++) {</span><span class="s3">\n            </span><span class="s1">this.chunks.push(tree.children[i]);</span><span class="s3">\n            </span><span class="s1">this.chunkPos.push(tree.positions[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (context &amp;&amp; this.parsedPos &lt; context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">ranges.some(r =&gt; r.from &lt;= context.viewport.from &amp;&amp; r.to &gt;= context.viewport.from)) {</span><span class="s3">\n            </span><span class="s1">this.state = this.lang.streamParser.startState(getIndentUnit(context.state));</span><span class="s3">\n            </span><span class="s1">context.skipUntilInView(this.parsedPos, context.viewport.from);</span><span class="s3">\n            </span><span class="s1">this.parsedPos = context.viewport.from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.moveRangeIndex();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">advance() {</span><span class="s3">\n        </span><span class="s1">let context = ParseContext.get();</span><span class="s3">\n        </span><span class="s1">let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);</span><span class="s3">\n        </span><span class="s1">let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);</span><span class="s3">\n        </span><span class="s1">if (context)</span><span class="s3">\n            </span><span class="s1">end = Math.min(end, context.viewport.to);</span><span class="s3">\n        </span><span class="s1">while (this.parsedPos &lt; end)</span><span class="s3">\n            </span><span class="s1">this.parseLine(context);</span><span class="s3">\n        </span><span class="s1">if (this.chunkStart &lt; this.parsedPos)</span><span class="s3">\n            </span><span class="s1">this.finishChunk();</span><span class="s3">\n        </span><span class="s1">if (this.parsedPos &gt;= parseEnd)</span><span class="s3">\n            </span><span class="s1">return this.finish();</span><span class="s3">\n        </span><span class="s1">if (context &amp;&amp; this.parsedPos &gt;= context.viewport.to) {</span><span class="s3">\n            </span><span class="s1">context.skipUntilInView(this.parsedPos, parseEnd);</span><span class="s3">\n            </span><span class="s1">return this.finish();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stopAt(pos) {</span><span class="s3">\n        </span><span class="s1">this.stoppedAt = pos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineAfter(pos) {</span><span class="s3">\n        </span><span class="s1">let chunk = this.input.chunk(pos);</span><span class="s3">\n        </span><span class="s1">if (!this.input.lineChunks) {</span><span class="s3">\n            </span><span class="s1">let eol = chunk.indexOf(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (eol &gt; -1)</span><span class="s3">\n                </span><span class="s1">chunk = chunk.slice(0, eol);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (chunk == </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">chunk = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return pos + chunk.length &lt;= this.to ? chunk : chunk.slice(0, this.to - pos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextLine() {</span><span class="s3">\n        </span><span class="s1">let from = this.parsedPos, line = this.lineAfter(from), end = from + line.length;</span><span class="s3">\n        </span><span class="s1">for (let index = this.rangeIndex;;) {</span><span class="s3">\n            </span><span class="s1">let rangeEnd = this.ranges[index].to;</span><span class="s3">\n            </span><span class="s1">if (rangeEnd &gt;= end)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">line = line.slice(0, rangeEnd - (end - line.length));</span><span class="s3">\n            </span><span class="s1">index++;</span><span class="s3">\n            </span><span class="s1">if (index == this.ranges.length)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">let rangeStart = this.ranges[index].from;</span><span class="s3">\n            </span><span class="s1">let after = this.lineAfter(rangeStart);</span><span class="s3">\n            </span><span class="s1">line += after;</span><span class="s3">\n            </span><span class="s1">end = rangeStart + after.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { line, end };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">skipGapsTo(pos, offset, side) {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let end = this.ranges[this.rangeIndex].to, offPos = pos + offset;</span><span class="s3">\n            </span><span class="s1">if (side &gt; 0 ? end &gt; offPos : end &gt;= offPos)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">let start = this.ranges[++this.rangeIndex].from;</span><span class="s3">\n            </span><span class="s1">offset += start - end;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">moveRangeIndex() {</span><span class="s3">\n        </span><span class="s1">while (this.ranges[this.rangeIndex].to &lt; this.parsedPos)</span><span class="s3">\n            </span><span class="s1">this.rangeIndex++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">emitToken(id, from, to, offset) {</span><span class="s3">\n        </span><span class="s1">let size = 4;</span><span class="s3">\n        </span><span class="s1">if (this.ranges.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">offset = this.skipGapsTo(from, offset, 1);</span><span class="s3">\n            </span><span class="s1">from += offset;</span><span class="s3">\n            </span><span class="s1">let len0 = this.chunk.length;</span><span class="s3">\n            </span><span class="s1">offset = this.skipGapsTo(to, offset, -1);</span><span class="s3">\n            </span><span class="s1">to += offset;</span><span class="s3">\n            </span><span class="s1">size += this.chunk.length - len0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let last = this.chunk.length - 4;</span><span class="s3">\n        </span><span class="s1">if (size == 4 &amp;&amp; last &gt;= 0 &amp;&amp; this.chunk[last] == id &amp;&amp; this.chunk[last + 2] == from)</span><span class="s3">\n            </span><span class="s1">this.chunk[last + 2] = to;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.chunk.push(id, from, to, size);</span><span class="s3">\n        </span><span class="s1">return offset;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parseLine(context) {</span><span class="s3">\n        </span><span class="s1">let { line, end } = this.nextLine(), offset = 0, { streamParser } = this.lang;</span><span class="s3">\n        </span><span class="s1">let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);</span><span class="s3">\n        </span><span class="s1">if (stream.eol()) {</span><span class="s3">\n            </span><span class="s1">streamParser.blankLine(this.state, stream.indentUnit);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n                </span><span class="s1">let token = readToken(streamParser.token, stream, this.state);</span><span class="s3">\n                </span><span class="s1">if (token)</span><span class="s3">\n                    </span><span class="s1">offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, offset);</span><span class="s3">\n                </span><span class="s1">if (stream.start &gt; 10000 /* C.MaxLineLength */)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.parsedPos = end;</span><span class="s3">\n        </span><span class="s1">this.moveRangeIndex();</span><span class="s3">\n        </span><span class="s1">if (this.parsedPos &lt; this.to)</span><span class="s3">\n            </span><span class="s1">this.parsedPos++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finishChunk() {</span><span class="s3">\n        </span><span class="s1">let tree = Tree.build({</span><span class="s3">\n            </span><span class="s1">buffer: this.chunk,</span><span class="s3">\n            </span><span class="s1">start: this.chunkStart,</span><span class="s3">\n            </span><span class="s1">length: this.parsedPos - this.chunkStart,</span><span class="s3">\n            </span><span class="s1">nodeSet,</span><span class="s3">\n            </span><span class="s1">topID: 0,</span><span class="s3">\n            </span><span class="s1">maxBufferLength: 2048 /* C.ChunkSize */,</span><span class="s3">\n            </span><span class="s1">reused: this.chunkReused</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">tree = new Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);</span><span class="s3">\n        </span><span class="s1">this.chunks.push(tree);</span><span class="s3">\n        </span><span class="s1">this.chunkPos.push(this.chunkStart - this.ranges[0].from);</span><span class="s3">\n        </span><span class="s1">this.chunk = [];</span><span class="s3">\n        </span><span class="s1">this.chunkReused = undefined;</span><span class="s3">\n        </span><span class="s1">this.chunkStart = this.parsedPos;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">finish() {</span><span class="s3">\n        </span><span class="s1">return new Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readToken(token, stream, state) {</span><span class="s3">\n    </span><span class="s1">stream.start = stream.pos;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; 10; i++) {</span><span class="s3">\n        </span><span class="s1">let result = token(stream, state);</span><span class="s3">\n        </span><span class="s1">if (stream.pos &gt; stream.start)</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Stream parser failed to advance stream.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const noTokens = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">const typeArray = [NodeType.none];</span><span class="s3">\n</span><span class="s1">const nodeSet = /*@__PURE__*/new NodeSet(typeArray);</span><span class="s3">\n</span><span class="s1">const warned = [];</span><span class="s3">\n</span><span class="s1">// Cache of node types by name and tags</span><span class="s3">\n</span><span class="s1">const byTag = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">const defaultTable = /*@__PURE__*/Object.create(null);</span><span class="s3">\n</span><span class="s1">for (let [legacyName, name] of [</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variableName</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">variable-2</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">string-2</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variableName.definition</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">tagName</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">attributeName</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">typeName</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">builtin</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">variableName.standard</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">modifier</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">invalid</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">header</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">heading</span><span class="s3">\&quot;</span><span class="s1">],</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">propertyName</span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\n</span><span class="s1">])</span><span class="s3">\n    </span><span class="s1">defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);</span><span class="s3">\n</span><span class="s1">class TokenTable {</span><span class="s3">\n    </span><span class="s1">constructor(extra) {</span><span class="s3">\n        </span><span class="s1">this.extra = extra;</span><span class="s3">\n        </span><span class="s1">this.table = Object.assign(Object.create(null), defaultTable);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">resolve(tag) {</span><span class="s3">\n        </span><span class="s1">return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);</span><span class="s3">\n</span><span class="s1">function warnForPart(part, msg) {</span><span class="s3">\n    </span><span class="s1">if (warned.indexOf(part) &gt; -1)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">warned.push(part);</span><span class="s3">\n    </span><span class="s1">console.warn(msg);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function createTokenType(extra, tagStr) {</span><span class="s3">\n    </span><span class="s1">let tags$1 = [];</span><span class="s3">\n    </span><span class="s1">for (let name of tagStr.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">let found = [];</span><span class="s3">\n        </span><span class="s1">for (let part of name.split(</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">let value = (extra[part] || tags[part]);</span><span class="s3">\n            </span><span class="s1">if (!value) {</span><span class="s3">\n                </span><span class="s1">warnForPart(part, `Unknown highlighting tag ${part}`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (typeof value == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">if (!found.length)</span><span class="s3">\n                    </span><span class="s1">warnForPart(part, `Modifier ${part} used at start of tag`);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">found = found.map(value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (found.length)</span><span class="s3">\n                    </span><span class="s1">warnForPart(part, `Tag ${part} used as modifier`);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">found = Array.isArray(value) ? value : [value];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let tag of found)</span><span class="s3">\n            </span><span class="s1">tags$1.push(tag);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!tags$1.length)</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">let name = tagStr.replace(/ /g, </span><span class="s3">\&quot;</span><span class="s1">_</span><span class="s3">\&quot;</span><span class="s1">), key = name + </span><span class="s3">\&quot; \&quot; </span><span class="s1">+ tags$1.map(t =&gt; t.id);</span><span class="s3">\n    </span><span class="s1">let known = byTag[key];</span><span class="s3">\n    </span><span class="s1">if (known)</span><span class="s3">\n        </span><span class="s1">return known.id;</span><span class="s3">\n    </span><span class="s1">let type = byTag[key] = NodeType.define({</span><span class="s3">\n        </span><span class="s1">id: typeArray.length,</span><span class="s3">\n        </span><span class="s1">name,</span><span class="s3">\n        </span><span class="s1">props: [styleTags({ [name]: tags$1 })]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">typeArray.push(type);</span><span class="s3">\n    </span><span class="s1">return type.id;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function docID(data, lang) {</span><span class="s3">\n    </span><span class="s1">let type = NodeType.define({ id: typeArray.length, name: </span><span class="s3">\&quot;</span><span class="s1">Document</span><span class="s3">\&quot;</span><span class="s1">, props: [</span><span class="s3">\n            </span><span class="s1">languageDataProp.add(() =&gt; data),</span><span class="s3">\n            </span><span class="s1">indentNodeProp.add(() =&gt; cx =&gt; lang.getIndent(cx))</span><span class="s3">\n        </span><span class="s1">], top: true });</span><span class="s3">\n    </span><span class="s1">typeArray.push(type);</span><span class="s3">\n    </span><span class="s1">return type;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function buildForLine(line) {</span><span class="s3">\n    </span><span class="s1">return line.length &lt;= 4096 &amp;&amp; /[</span><span class="s3">\\</span><span class="s1">u0590-</span><span class="s3">\\</span><span class="s1">u05f4</span><span class="s3">\\</span><span class="s1">u0600-</span><span class="s3">\\</span><span class="s1">u06ff</span><span class="s3">\\</span><span class="s1">u0700-</span><span class="s3">\\</span><span class="s1">u08ac</span><span class="s3">\\</span><span class="s1">ufb50-</span><span class="s3">\\</span><span class="s1">ufdff]/.test(line);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function textHasRTL(text) {</span><span class="s3">\n    </span><span class="s1">for (let i = text.iter(); !i.next().done;)</span><span class="s3">\n        </span><span class="s1">if (buildForLine(i.value))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function changeAddsRTL(change) {</span><span class="s3">\n    </span><span class="s1">let added = false;</span><span class="s3">\n    </span><span class="s1">change.iterChanges((fA, tA, fB, tB, ins) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!added &amp;&amp; textHasRTL(ins))</span><span class="s3">\n            </span><span class="s1">added = true;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return added;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const alwaysIsolate = /*@__PURE__*/Facet.define({ combine: values =&gt; values.some(x =&gt; x) });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Make sure nodes</span><span class="s3">\n</span><span class="s1">[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)</span><span class="s3">\n</span><span class="s1">as isolating for bidirectional text are rendered in a way that</span><span class="s3">\n</span><span class="s1">isolates them from the surrounding text.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function bidiIsolates(options = {}) {</span><span class="s3">\n    </span><span class="s1">let extensions = [isolateMarks];</span><span class="s3">\n    </span><span class="s1">if (options.alwaysIsolate)</span><span class="s3">\n        </span><span class="s1">extensions.push(alwaysIsolate.of(true));</span><span class="s3">\n    </span><span class="s1">return extensions;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const isolateMarks = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.always = view.state.facet(alwaysIsolate) ||</span><span class="s3">\n            </span><span class="s1">view.textDirection != Direction.LTR ||</span><span class="s3">\n            </span><span class="s1">view.state.facet(EditorView.perLineTextDirection);</span><span class="s3">\n        </span><span class="s1">this.hasRTL = !this.always &amp;&amp; textHasRTL(view.state.doc);</span><span class="s3">\n        </span><span class="s1">this.tree = syntaxTree(view.state);</span><span class="s3">\n        </span><span class="s1">this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : Decoration.none;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let always = update.state.facet(alwaysIsolate) ||</span><span class="s3">\n            </span><span class="s1">update.view.textDirection != Direction.LTR ||</span><span class="s3">\n            </span><span class="s1">update.state.facet(EditorView.perLineTextDirection);</span><span class="s3">\n        </span><span class="s1">if (!always &amp;&amp; !this.hasRTL &amp;&amp; changeAddsRTL(update.changes))</span><span class="s3">\n            </span><span class="s1">this.hasRTL = true;</span><span class="s3">\n        </span><span class="s1">if (!always &amp;&amp; !this.hasRTL)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let tree = syntaxTree(update.state);</span><span class="s3">\n        </span><span class="s1">if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {</span><span class="s3">\n            </span><span class="s1">this.tree = tree;</span><span class="s3">\n            </span><span class="s1">this.always = always;</span><span class="s3">\n            </span><span class="s1">this.decorations = buildDeco(update.view, tree, always);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">provide: plugin =&gt; {</span><span class="s3">\n        </span><span class="s1">function access(view) {</span><span class="s3">\n            </span><span class="s1">var _a, _b;</span><span class="s3">\n            </span><span class="s1">return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null &amp;&amp; _b !== void 0 ? _b : Decoration.none;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return [EditorView.outerDecorations.of(access),</span><span class="s3">\n            </span><span class="s1">Prec.lowest(EditorView.bidiIsolatedRanges.of(access))];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function buildDeco(view, tree, always) {</span><span class="s3">\n    </span><span class="s1">let deco = new RangeSetBuilder();</span><span class="s3">\n    </span><span class="s1">let ranges = view.visibleRanges;</span><span class="s3">\n    </span><span class="s1">if (!always)</span><span class="s3">\n        </span><span class="s1">ranges = clipRTLLines(ranges, view.state.doc);</span><span class="s3">\n    </span><span class="s1">for (let { from, to } of ranges) {</span><span class="s3">\n        </span><span class="s1">tree.iterate({</span><span class="s3">\n            </span><span class="s1">enter: node =&gt; {</span><span class="s3">\n                </span><span class="s1">let iso = node.type.prop(NodeProp.isolate);</span><span class="s3">\n                </span><span class="s1">if (iso)</span><span class="s3">\n                    </span><span class="s1">deco.add(node.from, node.to, marks[iso]);</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">from, to</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return deco.finish();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clipRTLLines(ranges, doc) {</span><span class="s3">\n    </span><span class="s1">let cur = doc.iter(), pos = 0, result = [], last = null;</span><span class="s3">\n    </span><span class="s1">for (let { from, to } of ranges) {</span><span class="s3">\n        </span><span class="s1">if (last &amp;&amp; last.to &gt; from) {</span><span class="s3">\n            </span><span class="s1">from = last.to;</span><span class="s3">\n            </span><span class="s1">if (from &gt;= to)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos + cur.value.length &lt; from) {</span><span class="s3">\n            </span><span class="s1">cur.next(from - (pos + cur.value.length));</span><span class="s3">\n            </span><span class="s1">pos = from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let start = pos, end = pos + cur.value.length;</span><span class="s3">\n            </span><span class="s1">if (!cur.lineBreak &amp;&amp; buildForLine(cur.value)) {</span><span class="s3">\n                </span><span class="s1">if (last &amp;&amp; last.to &gt; start - 10)</span><span class="s3">\n                    </span><span class="s1">last.to = Math.min(to, end);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">result.push(last = { from: start, to: Math.min(to, end) });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (end &gt;= to)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">pos = end;</span><span class="s3">\n            </span><span class="s1">cur.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const marks = {</span><span class="s3">\n    </span><span class="s1">rtl: /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-iso</span><span class="s3">\&quot;</span><span class="s1">, inclusive: true, attributes: { dir: </span><span class="s3">\&quot;</span><span class="s1">rtl</span><span class="s3">\&quot; </span><span class="s1">}, bidiIsolate: Direction.RTL }),</span><span class="s3">\n    </span><span class="s1">ltr: /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-iso</span><span class="s3">\&quot;</span><span class="s1">, inclusive: true, attributes: { dir: </span><span class="s3">\&quot;</span><span class="s1">ltr</span><span class="s3">\&quot; </span><span class="s1">}, bidiIsolate: Direction.LTR }),</span><span class="s3">\n    </span><span class="s1">auto: /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-iso</span><span class="s3">\&quot;</span><span class="s1">, inclusive: true, attributes: { dir: </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot; </span><span class="s1">}, bidiIsolate: null })</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export { DocInput, HighlightStyle, IndentContext, LRLanguage, Language, LanguageDescription, LanguageSupport, ParseContext, StreamLanguage, StringStream, TreeIndentContext, bidiIsolates, bracketMatching, bracketMatchingHandle, codeFolding, continuedIndent, defaultHighlightStyle, defineLanguageFacet, delimitedIndent, ensureSyntaxTree, flatIndent, foldAll, foldCode, foldEffect, foldGutter, foldInside, foldKeymap, foldNodeProp, foldService, foldState, foldable, foldedRanges, forceParsing, getIndentUnit, getIndentation, highlightingFor, indentNodeProp, indentOnInput, indentRange, indentService, indentString, indentUnit, language, languageDataProp, matchBrackets, sublanguageProp, syntaxHighlighting, syntaxParserRunning, syntaxTree, syntaxTreeAvailable, toggleFold, unfoldAll, unfoldCode, unfoldEffect };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const C = </span><span class="s3">\&quot;\\</span><span class="s1">u037c</span><span class="s3">\&quot;\n</span><span class="s1">const COUNT = typeof Symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">__</span><span class="s3">\&quot; </span><span class="s1">+ C : Symbol.for(C)</span><span class="s3">\n</span><span class="s1">const SET = typeof Symbol == </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">__styleSet</span><span class="s3">\&quot; </span><span class="s1">+ Math.floor(Math.random() * 1e8) : Symbol(</span><span class="s3">\&quot;</span><span class="s1">styleSet</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">const top = typeof globalThis != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? globalThis : typeof window != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? window : {}</span><span class="s3">\n\n</span><span class="s1">// :: - Style modules encapsulate a set of CSS rules defined from</span><span class="s3">\n</span><span class="s1">// JavaScript. Their definitions are only available in a given DOM</span><span class="s3">\n</span><span class="s1">// root after it has been _mounted_ there with `StyleModule.mount`.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Style modules should be created once and stored somewhere, as</span><span class="s3">\n</span><span class="s1">// opposed to re-creating them every time you need them. The amount of</span><span class="s3">\n</span><span class="s1">// CSS rules generated for a given DOM root is bounded by the amount</span><span class="s3">\n</span><span class="s1">// of style modules that were used. So to avoid leaking rules, don't</span><span class="s3">\n</span><span class="s1">// create these dynamically, but treat them as one-time allocations.</span><span class="s3">\n</span><span class="s1">export class StyleModule {</span><span class="s3">\n  </span><span class="s1">// :: (Object&lt;Style&gt;, ?{finish: ?(string) → string})</span><span class="s3">\n  </span><span class="s1">// Create a style module from the given spec.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// When `finish` is given, it is called on regular (non-`@`)</span><span class="s3">\n  </span><span class="s1">// selectors (after `&amp;` expansion) to compute the final selector.</span><span class="s3">\n  </span><span class="s1">constructor(spec, options) {</span><span class="s3">\n    </span><span class="s1">this.rules = []</span><span class="s3">\n    </span><span class="s1">let {finish} = options || {}</span><span class="s3">\n\n    </span><span class="s1">function splitSelector(selector) {</span><span class="s3">\n      </span><span class="s1">return /^@/.test(selector) ? [selector] : selector.split(/,</span><span class="s3">\\</span><span class="s1">s*/)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">function render(selectors, spec, target, isKeyframes) {</span><span class="s3">\n      </span><span class="s1">let local = [], isAt = /^@(</span><span class="s3">\\</span><span class="s1">w+)</span><span class="s3">\\</span><span class="s1">b/.exec(selectors[0]), keyframes = isAt &amp;&amp; isAt[1] == </span><span class="s3">\&quot;</span><span class="s1">keyframes</span><span class="s3">\&quot;\n      </span><span class="s1">if (isAt &amp;&amp; spec == null) return target.push(selectors[0] + </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">for (let prop in spec) {</span><span class="s3">\n        </span><span class="s1">let value = spec[prop]</span><span class="s3">\n        </span><span class="s1">if (/&amp;/.test(prop)) {</span><span class="s3">\n          </span><span class="s1">render(prop.split(/,</span><span class="s3">\\</span><span class="s1">s*/).map(part =&gt; selectors.map(sel =&gt; part.replace(/&amp;/, sel))).reduce((a, b) =&gt; a.concat(b)),</span><span class="s3">\n                 </span><span class="s1">value, target)</span><span class="s3">\n        </span><span class="s1">} else if (value &amp;&amp; typeof value == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (!isAt) throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">The value of a property (</span><span class="s3">\&quot; </span><span class="s1">+ prop + </span><span class="s3">\&quot;</span><span class="s1">) should be a primitive value.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n          </span><span class="s1">render(splitSelector(prop), value, local, keyframes)</span><span class="s3">\n        </span><span class="s1">} else if (value != null) {</span><span class="s3">\n          </span><span class="s1">local.push(prop.replace(/_.*/, </span><span class="s3">\&quot;\&quot;</span><span class="s1">).replace(/[A-Z]/g, l =&gt; </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">+ l.toLowerCase()) + </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot; </span><span class="s1">+ value + </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (local.length || keyframes) {</span><span class="s3">\n        </span><span class="s1">target.push((finish &amp;&amp; !isAt &amp;&amp; !isKeyframes ? selectors.map(finish) : selectors).join(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">) +</span><span class="s3">\n                    \&quot; </span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">+ local.join(</span><span class="s3">\&quot; \&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (let prop in spec) render(splitSelector(prop), spec[prop], this.rules)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// :: () → string</span><span class="s3">\n  </span><span class="s1">// Returns a string containing the module's CSS rules.</span><span class="s3">\n  </span><span class="s1">getRules() { return this.rules.join(</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) }</span><span class="s3">\n\n  </span><span class="s1">// :: () → string</span><span class="s3">\n  </span><span class="s1">// Generate a new unique CSS class name.</span><span class="s3">\n  </span><span class="s1">static newName() {</span><span class="s3">\n    </span><span class="s1">let id = top[COUNT] || 1</span><span class="s3">\n    </span><span class="s1">top[COUNT] = id + 1</span><span class="s3">\n    </span><span class="s1">return C + id.toString(36)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// :: (union&lt;Document, ShadowRoot&gt;, union&lt;[StyleModule], StyleModule&gt;, ?{nonce: ?string})</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Mount the given set of modules in the given DOM root, which ensures</span><span class="s3">\n  </span><span class="s1">// that the CSS rules defined by the module are available in that</span><span class="s3">\n  </span><span class="s1">// context.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Rules are only added to the document once per root.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// Rule order will follow the order of the modules, so that rules from</span><span class="s3">\n  </span><span class="s1">// modules later in the array take precedence of those from earlier</span><span class="s3">\n  </span><span class="s1">// modules. If you call this function multiple times for the same root</span><span class="s3">\n  </span><span class="s1">// in a way that changes the order of already mounted modules, the old</span><span class="s3">\n  </span><span class="s1">// order will be changed.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// If a Content Security Policy nonce is provided, it is added to</span><span class="s3">\n  </span><span class="s1">// the `&lt;style&gt;` tag generated by the library.</span><span class="s3">\n  </span><span class="s1">static mount(root, modules, options) {</span><span class="s3">\n    </span><span class="s1">let set = root[SET], nonce = options &amp;&amp; options.nonce</span><span class="s3">\n    </span><span class="s1">if (!set) set = new StyleSet(root, nonce)</span><span class="s3">\n    </span><span class="s1">else if (nonce) set.setNonce(nonce)</span><span class="s3">\n    </span><span class="s1">set.mount(Array.isArray(modules) ? modules : [modules])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let adoptedSet = new Map //&lt;Document, StyleSet&gt;</span><span class="s3">\n\n</span><span class="s1">class StyleSet {</span><span class="s3">\n  </span><span class="s1">constructor(root, nonce) {</span><span class="s3">\n    </span><span class="s1">let doc = root.ownerDocument || root, win = doc.defaultView</span><span class="s3">\n    </span><span class="s1">if (!root.head &amp;&amp; root.adoptedStyleSheets &amp;&amp; win.CSSStyleSheet) {</span><span class="s3">\n      </span><span class="s1">let adopted = adoptedSet.get(doc)</span><span class="s3">\n      </span><span class="s1">if (adopted) {</span><span class="s3">\n        </span><span class="s1">root.adoptedStyleSheets = [adopted.sheet, ...root.adoptedStyleSheets]</span><span class="s3">\n        </span><span class="s1">return root[SET] = adopted</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.sheet = new win.CSSStyleSheet</span><span class="s3">\n      </span><span class="s1">root.adoptedStyleSheets = [this.sheet, ...root.adoptedStyleSheets]</span><span class="s3">\n      </span><span class="s1">adoptedSet.set(doc, this)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.styleTag = doc.createElement(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">if (nonce) this.styleTag.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">, nonce)</span><span class="s3">\n      </span><span class="s1">let target = root.head || root</span><span class="s3">\n      </span><span class="s1">target.insertBefore(this.styleTag, target.firstChild)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.modules = []</span><span class="s3">\n    </span><span class="s1">root[SET] = this</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">mount(modules) {</span><span class="s3">\n    </span><span class="s1">let sheet = this.sheet</span><span class="s3">\n    </span><span class="s1">let pos = 0 /* Current rule offset */, j = 0 /* Index into this.modules */</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; modules.length; i++) {</span><span class="s3">\n      </span><span class="s1">let mod = modules[i], index = this.modules.indexOf(mod)</span><span class="s3">\n      </span><span class="s1">if (index &lt; j &amp;&amp; index &gt; -1) { // Ordering conflict</span><span class="s3">\n        </span><span class="s1">this.modules.splice(index, 1)</span><span class="s3">\n        </span><span class="s1">j--</span><span class="s3">\n        </span><span class="s1">index = -1</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (index == -1) {</span><span class="s3">\n        </span><span class="s1">this.modules.splice(j++, 0, mod)</span><span class="s3">\n        </span><span class="s1">if (sheet) for (let k = 0; k &lt; mod.rules.length; k++)</span><span class="s3">\n          </span><span class="s1">sheet.insertRule(mod.rules[k], pos++)</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">while (j &lt; index) pos += this.modules[j++].rules.length</span><span class="s3">\n        </span><span class="s1">pos += mod.rules.length</span><span class="s3">\n        </span><span class="s1">j++</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!sheet) {</span><span class="s3">\n      </span><span class="s1">let text = </span><span class="s3">\&quot;\&quot;\n      </span><span class="s1">for (let i = 0; i &lt; this.modules.length; i++)</span><span class="s3">\n        </span><span class="s1">text += this.modules[i].getRules() + </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;\n      </span><span class="s1">this.styleTag.textContent = text</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">setNonce(nonce) {</span><span class="s3">\n    </span><span class="s1">if (this.styleTag &amp;&amp; this.styleTag.getAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">) != nonce)</span><span class="s3">\n      </span><span class="s1">this.styleTag.setAttribute(</span><span class="s3">\&quot;</span><span class="s1">nonce</span><span class="s3">\&quot;</span><span class="s1">, nonce)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Style::Object&lt;union&lt;Style,string&gt;&gt;</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A style is an object that, in the simple case, maps CSS property</span><span class="s3">\n</span><span class="s1">// names to strings holding their values, as in `{color: </span><span class="s3">\&quot;</span><span class="s1">red</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n</span><span class="s1">// fontWeight: </span><span class="s3">\&quot;</span><span class="s1">bold</span><span class="s3">\&quot;</span><span class="s1">}`. The property names can be given in</span><span class="s3">\n</span><span class="s1">// camel-case—the library will insert a dash before capital letters</span><span class="s3">\n</span><span class="s1">// when converting them to CSS.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// If you include an underscore in a property name, it and everything</span><span class="s3">\n</span><span class="s1">// after it will be removed from the output, which can be useful when</span><span class="s3">\n</span><span class="s1">// providing a property multiple times, for browser compatibility</span><span class="s3">\n</span><span class="s1">// reasons.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// A property in a style object can also be a sub-selector, which</span><span class="s3">\n</span><span class="s1">// extends the current context to add a pseudo-selector or a child</span><span class="s3">\n</span><span class="s1">// selector. Such a property should contain a `&amp;` character, which</span><span class="s3">\n</span><span class="s1">// will be replaced by the current selector. For example `{</span><span class="s3">\&quot;</span><span class="s1">&amp;:before</span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\n</span><span class="s1">// {content: '</span><span class="s3">\&quot;</span><span class="s1">hi</span><span class="s3">\&quot;</span><span class="s1">'}}`. Sub-selectors and regular properties can</span><span class="s3">\n</span><span class="s1">// freely be mixed in a given object. Any property containing a `&amp;` is</span><span class="s3">\n</span><span class="s1">// assumed to be a sub-selector.</span><span class="s3">\n</span><span class="s1">//</span><span class="s3">\n</span><span class="s1">// Finally, a property can specify an @-block to be wrapped around the</span><span class="s3">\n</span><span class="s1">// styles defined inside the object that's the property's value. For</span><span class="s3">\n</span><span class="s1">// example to create a media query you can do `{</span><span class="s3">\&quot;</span><span class="s1">@media screen and</span><span class="s3">\n</span><span class="s1">// (min-width: 400px)</span><span class="s3">\&quot;</span><span class="s1">: {...}}`.</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>