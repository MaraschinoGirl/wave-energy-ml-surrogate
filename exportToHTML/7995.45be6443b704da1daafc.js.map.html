<html>
<head>
<title>7995.45be6443b704da1daafc.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
7995.45be6443b704da1daafc.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;7995.45be6443b704da1daafc.js?v=45be6443b704da1daafc&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACP;;AC/B4D;AAC1B;AAClC;AACA;AACA;AACA,sBAAsB;AACtB,2BAA2B;AAC3B;AACA;AACe,mCAAmC,oBAAoB;AACtE;AACA;AACA;AACA;AACA,oBAAoB,aAAa,IAAI,QAAQ;AAC7C;AACA;AACA;AACA,oBAAoB,cAAc,IAAI,QAAQ;AAC9C,qBAAqB;AACrB;AACA,iBAAiB;AACjB,KAAK,IAAI,kBAAkB;AAC3B;AACA;;ACxB0C;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACe,wCAAwC;AACvD;AACA;AACA;AACA,YAAY,oBAAoB,EAAE,YAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzBiD;AACR;AACzC;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,SAAS,UAAU;AACnB;AACA,iBAAiB,UAAU;AAC3B,SAAS;AACT;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA,QAAQ,uBAAa;AACrB;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;;;;;AC9B6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,WAAW,qBAAW;AACtB;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,KAAK;AACL;AACA;;;;;;;;;;;;;AClBsC;AACP;AACO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,sBAAsB,cAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACe,mDAAmD;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,KAAK;AAChE;AACA,oBAAoB,eAAe;AACnC;AACA,2DAA2D,KAAK;AAChE;AACA,gBAAgB,OAAO;AACvB,8DAA8D,OAAO;AACrE;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChD6B;AACgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,sBAAsB,aAAG;AACzB;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA,kCAAkC,aAAG,UAAU,cAAc,yBAAyB;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnC6B;AACA;AACU;AACO;AAC6C;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA,qCAAqC,oCAAoC;AACzE,QAAQ,kBAAQ;AAChB;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA,kCAAkC,aAAG,UAAU,cAAc;AAC7D,0BAA0B,aAAG;AAC7B,kCAAkC,aAAG,UAAU,cAAc,yBAAyB;AACtF;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpFoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,WAAW,iBAAiB;AAC5B;AACA;;;;;;;;;;;;;;;;;;;;;;;ACf6B;AACU;AACvC;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,wBAAwB,aAAG;AAC3B,QAAQ,kBAAQ;AAChB;AACA;AACA;AACA,qEAAqE,mBAAmB;AACxF;AACA;AACA;AACA;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5BoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,UAAU,OAAO;AACjB;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCiC;AACU;AACC;AACV;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,gCAAgC,SAAS;AACzC;AACA,0CAA0C;AAC1C,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA,aAAa,aAAa,uBAAuB,aAAa;AAC9D,oBAAoB,YAAY;AAChC;AACA;AACA;AACA,uBAAuB,eAAK;AAC5B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AClC6B;AACQ;AACR;AACI;AACQ;AACR;AACY;AACd;AACkB;AACqI;AAC5F;AACT;AAC5C;AACF;AACQ;AACmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACe,0DAA0D;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,YAAY,0EAA0E;AACtF,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,YAAY;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,6CAA6C,eAAK;AAClD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gBAAgB;AACxB;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,UAAU;AAClB;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,QAAQ;AACjB;AACA;AACA;AACA;AACA,QAAQ,OAAO;AACf,gBAAgB,uBAAuB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,oBAAoB;AAC9C,2BAA2B;AAC3B;AACA,QAAQ,cAAc;AACtB;AACA,6BAA6B,mBAAS,gBAAgB,cAAc;AACpE;AACA;AACA;AACA,SAAS,IAAI;AACb,QAAQ,eAAK,cAAc,cAAI,CAAC,qBAAW;AAC3C,2BAA2B,oBAAoB,cAAc;AAC7D;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,iBAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA,kCAAkC,QAAQ;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,mEAAmE,MAAM,aAAG,+BAA+B,OAAO,IAAI;AACtH;AACA;AACA,yCAAyC;AACzC;AACA,qBAAqB,UAAU,mCAAmC,UAAU;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,MAAM,SAAS,CAAC,aAAG;AAC5D;AACA;AACA;AACA,qCAAqC,MAAM,SAAS,CAAC,aAAG;AACxD;AACA;AACA;AACA;AACA,QAAQ,aAAG,0BAA0B,wBAAwB;AAC7D,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,SAAS,QAAQ;AACjB,kBAAkB;AAClB;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,iCAAiC,aAAU;AAC3C;AACA,iBAAiB;AACjB;AACA;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,uBAAuB,sBAAsB;AAC7C;AACA,4CAA4C,YAAY;AACxD;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,kCAAkC,aAAG;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA,gBAAgB,4BAA4B;AAC5C,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,2CAA2C;AAC3D;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yBAAyB;AAC9D,kCAAkC;AAClC;AACA,kCAAkC,YAAY;AAC9C,KAAK;AACL;AACA;;AC5d6B;AACA;AACU;AACA;AACA;AACJ;AACF;AAC6B;AACU;AACO;AAC1C;AAC4C;AACU;AAC3F;AACA;AACA;AACO;AACP;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,yEAAyE;AAChF;AACA;AACA,YAAY,kBAAQ;AACpB,0BAA0B,gBAAM;AAChC,kCAAkC,aAAG;AACrC;AACA;AACA;AACA,oBAAoB,aAAG,QAAQ,OAAO;AACtC,sCAAsC,cAAc;AACpD,wGAAwG;AACxG;AACA,qBAAqB,aAAG,QAAQ,UAAU,KAAK,aAAG,QAAQ,UAAU;AACpE,gCAAgC,aAAG,QAAQ,UAAU,IAAI,UAAU,GAAG,UAAU;AAChF,0CAA0C,+BAA+B;AACzE;AACA,mFAAmF,aAAG;AACtF;AACA;AACA,oGAAoG;AACpG;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,iBAAiB,kBAAQ,iCAAiC,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,eAAe,oBAAoB;AACnC,KAAK;AACL,qCAAqC,oCAAoC;AACzE,QAAQ,kBAAQ;AAChB;AACA;AACA;AACA;AACA;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,eAAK;AACb;AACA;AACA;AACA,YAAY,YAAY;AACxB,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,KAAK,IAAI,yCAAyC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACe;AACf,kGAAkG,QAAQ;AAC1G;AACA;;ACV6B;AACK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ;AAChB,oCAAoC,aAAa;AACjD;AACA,4DAA4D,aAAG,oBAAoB,EAAE,aAAG;AACxF;AACA,SAAS;AACT;AACA;AACA;AACA;;AC1CkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,0CAA0C;AAC1C,mCAAmC,QAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kBAAkB,UAAU;AACjC;AACA;;AClCwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACe;AACf,uEAAuE,SAAS;AAChF;AACA;;ACVuC;AACO;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACe,uDAAuD;AACtE,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,mFAAmF,UAAU;AAC7F;AACA;AACA;AACA;;ACpBkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;;ACd6B;AACQ;AACsF;AAChE;AACO;AACe;AACpC;AACV;AACQ;AAC0B;AAC1B;AACA;AACC;AAC2B;AACvE;AACA;AACO;AACP;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,QAAQ;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qKAAqK;AACrK,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA,kBAAkB,iBAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,iDAAiD,4CAA4C,oHAAoH,IAAI;AAC5N;AACA,sBAAsB,QAAQ,gCAAgC;AAC9D,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;AACA;AACA,QAAQ,QAAQ,cAAc,QAAQ;AACtC;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA,aAAa,WAAW;AACxB;AACA;AACA,aAAa,OAAO;AACpB,+BAA+B,OAAO;AACtC;AACA;AACA;AACA,8BAA8B,oBAAoB;AAClD;AACA;AACA,aAAa,gBAAgB;AAC7B,+BAA+B,mBAAmB;AAClD,6CAA6C;AAC7C;AACA,aAAa,YAAY;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,aAAa,UAAU;AACvB,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D,gCAAgC,wBAAwB,wBAAwB,iBAAO;AACvF,0BAA0B,YAAY;AACtC;AACA,aAAa,UAAU;AACvB,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA,8BAA8B,+BAA+B;AAC7D,gCAAgC,wBAAwB,wBAAwB,iBAAO;AACvF,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,0NAA0N,UAAU;AACpO,kBAAkB,cAAc;AAChC;AACA,+EAA+E;AAC/E;AACA;AACA;AACA,mEAAmE,aAAG,mBAAmB,cAAc;AACvG;AACA;AACA;AACA;AACA,oCAAoC,aAAG;AACvC,iCAAiC,aAAG;AACpC;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAG;AAC3C,qCAAqC,aAAG;AACxC;AACA,qBAAqB;AACrB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,aAAG;AAC/C;AACA,yBAAyB;AACzB,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,SAAS,QAAQ;AACjB;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC,QAAQ,QAAQ;AAChB,eAAe,yBAAyB;AACxC;AACA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;ACjW0C;AAC1C;AACA;AACA;AACA;AACA;AACe,qCAAqC;AACpD;AACA;AACA;AACA,gBAAgB,YAAY,cAAc,YAAY;AACtD;AACA;;ACZ6C;AACC;AAC9C;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACe,sDAAsD;AACrE,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;;ACpB2D;AACd;AACF;AACI;AACL;AACE;AAC5C;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,2BAA2B;AAC3B;AACA;AACe,yDAAyD;AACxE,sBAAsB,YAAY;AAClC,YAAY,eAAe;AAC3B;AACA,uBAAuB,aAAa;AACpC;AACA;AACA,YAAY,aAAa;AACzB,gBAAgB,YAAY;AAC5B,gBAAgB,cAAc;AAC9B;AACA;AACA;AACA;AACA,8CAA8C,aAAa;AAC3D;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;ACtCqC;AACM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,YAAY,iDAAiD;AAC7D;AACA;AACA,SAAS,iBAAO;AAChB,sBAAsB,YAAY;AAClC;AACA;AACA,aAAa;AACb;AACA;;AC3B6B;AACA;AAC0B;AACT;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kEAAkE;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACe,wFAAwF;AACvG;AACA;AACA;AACA,QAAQ,aAAG,YAAY,cAAc;AACrC;AACA;AACA,YAAY,aAAG,YAAY,cAAc;AACzC,+BAA+B,aAAG,YAAY,cAAc,IAAI;AAChE;AACA,oBAAoB,aAAG;AACvB;AACA;AACA,aAAa;AACb;AACA,iCAAiC,aAAG,YAAY,cAAc,IAAI;AAClE;AACA;AACA;AACA,8BAA8B,aAAG;AACjC,iCAAiC,aAAG,aAAa,cAAc,UAAU;AACzE,iCAAiC,aAAG,aAAa,cAAc,UAAU;AACzE;AACA,gBAAgB,aAAG,iBAAiB,OAAO;AAC3C,iCAAiC,cAAc;AAC/C;AACA,gBAAgB,aAAG,iBAAiB,OAAO;AAC3C,iCAAiC,cAAc;AAC/C;AACA;AACA,wCAAwC,aAAG;AAC3C,wCAAwC,aAAG;AAC3C;AACA;AACA,oBAAoB,aAAG;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,aAAG;AAChD,6CAA6C,aAAG;AAChD;AACA;AACA;AACA;AACA;AACA,iCAAiC,aAAG;AACpC;AACA;AACA;AACA;AACA,2CAA2C,aAAG;AAC9C,2CAA2C,aAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,aAAG,mCAAmC,aAAG;AACtD,6BAA6B,aAAG;AAChC,6BAA6B,aAAG;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,aAAG,iBAAiB,OAAO;AAC3C,iCAAiC,cAAc;AAC/C;AACA,gBAAgB,aAAG,iBAAiB,OAAO;AAC3C,iCAAiC,cAAc;AAC/C;AACA;AACA,kCAAkC,aAAG;AACrC,kCAAkC,aAAG;AACrC;AACA;AACA,iCAAiC,aAAG;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChL6B;AACQ;AACmE;AACrE;AACW;AACD;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO,cAAc,gBAAgB,cAAc,UAAU;AACrE,wBAAwB,cAAc;AACtC,iEAAiE,iBAAO;AACxE;AACA;AACA;AACA;AACA,QAAQ,SAAS,eAAe,aAAG,UAAU,SAAS,EAAE,OAAO;AAC/D,6CAA6C,aAAG,SAAS,SAAS;AAClE;AACA;AACA,uBAAuB;AACvB,QAAQ,aAAa,yBAAyB,cAAc;AAC5D;AACA,0BAA0B,aAAG,UAAU,cAAc;AACrD,qCAAqC,MAAM;AAC3C,2DAA2D,QAAQ,oBAAoB;AACvF;AACA;AACA,YAAY,aAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;AC1D6B;AACQ;AACR;AACiK;AAC7G;AACf;AACpB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,OAAO,cAAc,gBAAgB,cAAc,UAAU;AACrE,wBAAwB,cAAc;AACtC,iEAAiE,iBAAO;AACxE;AACA;AACA;AACA;AACA;AACA,SAAS,QAAQ;AACjB;AACA,QAAQ,UAAU,cAAc,UAAU;AAC1C,sBAAsB,UAAU;AAChC,8BAA8B,+BAA+B;AAC7D,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yBAAyB,qBAAqB,yBAAyB;AAC/E,QAAQ,aAAG,aAAa,8BAA8B;AACtD;AACA,QAAQ,SAAS;AACjB,gBAAgB,6DAA6D;AAC7E;AACA;AACA;AACA,uFAAuF,KAAK,GAAG,EAAE;AACjG;AACA;AACA,8FAA8F,KAAK,GAAG,EAAE;AACxG;AACA;AACA,wEAAwE,KAAK,GAAG,EAAE;AAClF;AACA,aAAa;AACb;AACA;AACA;AACA,gFAAgF,KAAK,GAAG,EAAE;AAC1F,aAAa;AACb;AACA;AACA,aAAa,cAAc;AAC3B;AACA,0BAA0B,aAAG,UAAU,cAAc;AACrD,6EAA6E,KAAK,GAAG,SAAS;AAC9F;AACA;AACA,YAAY,aAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;ACtFwD;AACR;AACkB;AACJ;AACV;AACV;AACE;AACV;AACsB;AACV;AACoB;AAC5B;AACI;AAC4M;AACtP;;ACdsC;AACgO;AACtQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,aAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,4FAA4F;AAC3G;AACA;AACA;;AC9MA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,gEAAgE,MAAM;AACtE,iBAAiB;AACjB;AACA;AACA,iBAAiB,QAAQ,8BAA8B;AACvD;AACA;AACA;;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,qEAAqE,UAAU;AAC/E;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;ACtBgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,WAAW,uBAAuB;AAClC;AACA;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpBqC;AAC6B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,kBAAkB,wBAAwB;AAC1C;AACA,uCAAuC,iBAAO;AAC9C;AACA,WAAW,iBAAO;AAClB;AACA;;ACrBqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,sCAAsC,iBAAO;AAC7C;AACA,WAAW,iBAAO;AAClB;AACA;;ACb4D;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA,8BAA8B,qBAAqB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACrBkE;AACjC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,kBAAkB,wBAAwB;AAC1C,SAAS,eAAK;AACd;AACA,0CAA0C,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACtByC;AACZ;AACA;AACY;AACzC;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAG;AACtC;AACA;AACA,YAAY,aAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mBAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAG,aAAa,UAAU;AACnD;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAG,aAAa,UAAU;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,aAAG,aAAa,UAAU;AAClC;AACA;AACA;AACA;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,yCAAyC;AACrD,qBAAqB;AACrB,uBAAuB;AACvB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,2CAA2C,IAAI,+CAA+C,IAAI,+CAA+C;AAChL;AACA;AACA;AACA;;AC9BA,2CAA2C,2CAA2C;AACtF,gDAAgD,yDAAyD;AACzG;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnBoC;AACpC;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACe,wDAAwD;AACvE;AACA;AACA,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3CqD;AACX;AAC1C;AACA;AACO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACe,6CAA6C;AAC5D,sBAAsB,YAAY;AAClC,+BAA+B,sBAAsB;AACrD,kCAAkC,sBAAsB;AACxD,iBAAiB;AACjB;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACe,mDAAmD;AAClE,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBgD;AACV;AACP;AACF;AACA;AACe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAG;AAC1B;AACA;AACA;AACA,0BAA0B,mBAAmB;AAC7C,mBAAmB,mBAAI,YAAY,WAAW,+BAA+B,YAAY;AACzF;AACA,QAAQ,aAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACe,yDAAyD;AACxE,iBAAiB,aAAa;AAC9B;AACA,mBAAmB,qBAAoB,CAAC,2BAAa;AACrD,QAAQ,eAAc;AACtB;AACA;AACA;AACA,0DAA0D,cAAc;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,cAAc,KAAK;AAC5D;AACA;;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;;AC5BoC;AACpC;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACe,yDAAyD;AACxE;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtBuC;AACF;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAQ,eAAe,MAAM;AAC/C,cAAc,MAAM,IAAI,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,2CAA2C,eAAe;AAC1D,cAAc,aAAa,EAAE,mBAAmB,EAAE,WAAW,EAAE,SAAS;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,cAAc,GAAG,GAAG,YAAY;AAChC;AACA;;ACxEe;AACf;AACA;AACA;;ACHA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;;ACRkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,QAAQ,QAAQ;AAChB;AACA;AACA,QAAQ,SAAS;AACjB;AACA;AACA;AACA;AACA;;ACjBsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,yCAAyC,YAAoB,mBAAmB,EAE3E;AACL;AACA;AACA;AACA,qBAAqB;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,0BAA0B,UAAU;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;ACnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT,mEAAmE,iBAAiB,kBAAkB,OAAO;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,oBAAoB;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,eAAe;AAC3B,YAAY,UAAU,uBAAuB,UAAU;AACvD;AACA;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,YAAY,qDAAqD;AACjE;AACA;AACA;AACA;AACA;;ACbiD;AACR;AACzC;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA,QAAQ,UAAU;AAClB,iDAAiD,UAAU;AAC3D,iCAAiC,oBAAoB;AACrD;AACA;AACA;AACA,0BAA0B,UAAU,EAAE,QAAQ;AAC9C;AACA,SAAS;AACT;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA,gBAAgB,uBAAa;AAC7B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;ACjCmC;AACmB;AACtD;AACA;AACA,MAAM,uDAAuD;AAC7D,MAAM,uDAAuD;AAC7D,MAAM,uDAAuD;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa,SAAS,4BAA4B;AAClD,aAAa,SAAS,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,wBAAwB,kBAAkB;AAC1C;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA,iDAAiD,gBAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;ACxCiD;AACjD;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uBAAa;AAC7B;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,KAAK,IAAI;AACT;AACA;;ACvBwB;AACxB;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,GAAG;AACpB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,eAAe,GAAG;AAClB,gBAAgB,GAAG;AACnB,cAAc,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IAAI;AACxD;AACA;;ACzBqC;AACK;AACF;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,YAAY,iDAAiD;AAC7D,iBAAiB,WAAW;AAC5B;AACA,SAAS,iBAAO;AAChB,sBAAsB,YAAY;AAClC;AACA;AACA,aAAa;AACb;AACA;;ACzB0D;AACnB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B,2BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA,QAAQ,kBAAQ;AAChB,uCAAuC,eAAe;AACtD;AACA;AACA;AACA;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gDAAgD;AACjD;;;;;AC3E6B;AACQ;AACC;AACO;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,aAAa;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAG,SAAS,MAAM;AACtC,mCAAmC,YAAY,MAAM;AACrD;AACA;AACA;AACA;AACA,kBAAkB,iBAAO;AACzB;AACA;AACA,6EAA6E,IAAI;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAO;AACpB;AACA;AACA,+BAA+B,aAAa;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5FqC;AACA;AACoB;AACT;AAC4C;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA,gEAAgE,iBAAO;AACvE;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA,oBAAoB,cAAc,WAAW,cAAc;AAC3D,oBAAoB,iBAAO,QAAQ,cAAc;AACjD;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,gBAAgB,SAAS;AACzB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACe;AACf,0BAA0B,eAAe;AACzC;AACA;AACA;AACA;AACA;;AC/C0C;AAClB;AACxB;;ACF0D;AACxB;AACE;AACkB;AACF;AACR;AACN;AAC0B;AACE;AACA;AACN;AACE;AACI;AACZ;AACI;AACF;AACwB;AACpC;AACA;AACkB;AACtB;AACE;AACN;AACA;AACQ;AACR;AAC+E;AAC7E;AACQ;AACJ;AACR;AACI;AACA;AAC8B;AAC1B;AACA;AACF;AACQ;AACxB;AACwB;AACZ;AAC4B;AACA;AACtB;AACJ;AACI;AACF;AACI;AACU;AAChB;AACkB;AACR;AAC0C;AAClE;AACA;AACI;AACH;AACA;AAC68B;AACt+B;;;;;;;;AC3Da;;AAEb;;AAEA,cAAc,mBAAO,EAAE,KAAmB;AAC1C,kBAAkB,mBAAO,EAAE,IAA2B;AACtD,cAAc,mBAAO,EAAE,KAAsB;;;AAG7C;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa;AACb,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,UAAU,QAAQ;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;ACnNa;;AAEb;;AAEA,UAAU,mBAAO,EAAE,KAAa;AAChC,WAAW,mBAAO,EAAE,KAAmB;AACvC,kBAAkB,mBAAO,EAAE,IAA2B;AACtD,cAAc,mBAAO,EAAE,KAAsB;;;AAG7C;;AAEA;AACA;AACA;AACA;AACA,UAAU,iBAAiB;AAC3B,UAAU,iBAAiB;AAC3B,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;AC9GA,cAAc,mBAAO,CAAC,KAAgB;AACtC,aAAa,mBAAO,CAAC,KAAe;AACpC,WAAW,mBAAO,CAAC,KAAa;AAChC,eAAe,mBAAO,CAAC,KAAiB;AACxC,eAAe,mBAAO,CAAC,KAAiB;AACxC,uBAAuB,mBAAO,CAAC,KAAyB;AACxD,oBAAoB,mBAAO,CAAC,KAAsB;AAClD,gBAAgB,mBAAO,CAAC,IAAkB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D,iEAAiE;AACjE;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACvLA,gBAAgB,mBAAO,CAAC,KAAgB;AACxC,oBAAoB,mBAAO,CAAC,KAAoB;AAChD,sBAAsB,mBAAO,CAAC,KAAsB;AACpD,aAAa,mBAAO,CAAC,KAAa;AAClC,iBAAiB,mBAAO,CAAC,KAAiB;AAC1C,gBAAgB,mBAAO,CAAC,KAAgB;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AC3CA,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C,gBAAgB,mBAAO,CAAC,KAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,IAAW;;AAEvB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;AChGA,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C,gBAAgB,mBAAO,CAAC,KAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,EAAE,mBAAO,CAAC,IAAW;;AAEvB;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;AC/EA,kBAAkB,mBAAO,CAAC,KAAkB;AAC5C,gBAAgB,mBAAO,CAAC,KAAqB;AAC7C,mBAAmB,mBAAO,CAAC,KAAa;AACxC,qBAAqB,mBAAO,CAAC,KAAqB;AAClD,gBAAgB,mBAAO,CAAC,KAAgB;AACxC,oBAAoB,mBAAO,CAAC,KAAoB;AAChD,qBAAqB,mBAAO,CAAC,KAAqB;AAClD,yBAAyB,mBAAO,CAAC,KAAyB;AAC1D,gBAAgB,mBAAO,CAAC,KAAgB;AACxC,sBAAsB,mBAAO,CAAC,KAAsB;AACpD,gBAAgB,mBAAO,CAAC,KAAgB;AACxC,eAAe,mBAAO,CAAC,KAAe;AACtC,aAAa,mBAAO,CAAC,KAAa;AAClC,iBAAiB,mBAAO,CAAC,KAAiB;;AAE1C,2BAA2B,mBAAO,CAAC,KAAgC;AACnE,sBAAsB,mBAAO,CAAC,KAA2B;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK,IAAI,UAAU;AACnB;AACA;;AAEA;AACA,QAAQ,sBAAsB;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;;AAEA;AACA;AACA;AACA;AACA,KAAK,KAAK;;AAEV;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK,IAAI;AACT,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;ACtVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,wCAAwC,QAAQ;AAChD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA,WAAW;AACX,WAAW;AACX,eAAe;;;;;;;;ACnGf,eAAe,mBAAO,CAAC,KAAa;AACpC,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AC1BA,kBAAkB,mBAAO,CAAC,IAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,SAAS,mBAAO,CAAC,KAAM;;AAEvB;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA,eAAe,mBAAO,CAAC,KAAa;AACpC,oBAAoB,mBAAO,CAAC,KAAkB;AAC9C,wBAAwB,mBAAO,CAAC,KAAsB;AACtD,eAAe,mBAAO,CAAC,KAAa;AACpC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClEA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,qBAAqB,mBAAO,CAAC,KAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,cAAc;AAC3B;AACA;;AAEA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,SAAS;AACpB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvBA,oBAAoB,mBAAO,CAAC,KAAkB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;;AAEA;;;;;;;;ACfA,cAAc,mBAAO,CAAC,KAAY;AAClC,WAAW,mBAAO,CAAC,KAAQ;;AAE3B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,oBAAoB,mBAAO,CAAC,KAAkB;AAC9C,gBAAgB,mBAAO,CAAC,IAAc;AACtC,oBAAoB,mBAAO,CAAC,KAAkB;;AAE9C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA,eAAe,mBAAO,CAAC,KAAa;AACpC,oBAAoB,mBAAO,CAAC,KAAkB;AAC9C,wBAAwB,mBAAO,CAAC,KAAsB;AACtD,eAAe,mBAAO,CAAC,KAAa;AACpC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzEA,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,YAAY,mBAAO,CAAC,KAAU;AAC9B,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,iBAAiB,mBAAO,CAAC,GAAe;AACxC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,aAAa,mBAAO,CAAC,IAAW;AAChC,cAAc,mBAAO,CAAC,KAAW;AACjC,eAAe,mBAAO,CAAC,KAAY;AACnC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClFA,YAAY,mBAAO,CAAC,KAAU;AAC9B,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7DA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACXA,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,0BAA0B,mBAAO,CAAC,KAAwB;AAC1D,eAAe,mBAAO,CAAC,KAAY;AACnC,cAAc,mBAAO,CAAC,KAAW;AACjC,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC9BA,eAAe,mBAAO,CAAC,KAAa;AACpC,kBAAkB,mBAAO,CAAC,KAAe;;AAEzC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACrBA,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,8BAA8B,mBAAO,CAAC,KAA4B;;AAElE;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrBA,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,UAAU,mBAAO,CAAC,KAAO;AACzB,YAAY,mBAAO,CAAC,KAAS;AAC7B,YAAY,mBAAO,CAAC,KAAU;AAC9B,yBAAyB,mBAAO,CAAC,KAAuB;AACxD,8BAA8B,mBAAO,CAAC,KAA4B;AAClE,YAAY,mBAAO,CAAC,KAAU;;AAE9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA,YAAY,mBAAO,CAAC,KAAU;AAC9B,uBAAuB,mBAAO,CAAC,KAAqB;AACpD,cAAc,mBAAO,CAAC,KAAY;AAClC,oBAAoB,mBAAO,CAAC,KAAkB;AAC9C,eAAe,mBAAO,CAAC,KAAY;AACnC,aAAa,mBAAO,CAAC,KAAU;AAC/B,cAAc,mBAAO,CAAC,KAAY;;AAElC;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACzCA,uBAAuB,mBAAO,CAAC,KAAqB;AACpD,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,gBAAgB,mBAAO,CAAC,KAAc;AACtC,sBAAsB,mBAAO,CAAC,IAAoB;AAClD,kBAAkB,mBAAO,CAAC,IAAe;AACzC,cAAc,mBAAO,CAAC,KAAW;AACjC,wBAAwB,mBAAO,CAAC,KAAqB;AACrD,eAAe,mBAAO,CAAC,KAAY;AACnC,iBAAiB,mBAAO,CAAC,KAAc;AACvC,eAAe,mBAAO,CAAC,KAAY;AACnC,oBAAoB,mBAAO,CAAC,KAAiB;AAC7C,mBAAmB,mBAAO,CAAC,KAAgB;AAC3C,cAAc,mBAAO,CAAC,KAAY;AAClC,oBAAoB,mBAAO,CAAC,KAAiB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7FA,eAAe,mBAAO,CAAC,KAAa;AACpC,cAAc,mBAAO,CAAC,KAAY;AAClC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,cAAc,mBAAO,CAAC,KAAY;AAClC,iBAAiB,mBAAO,CAAC,KAAe;AACxC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,eAAe,mBAAO,CAAC,KAAY;AACnC,cAAc,mBAAO,CAAC,KAAW;;AAEjC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,8BAA8B;AACzC,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,aAAa;AACb,GAAG;;AAEH;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;AChDA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA,cAAc,mBAAO,CAAC,KAAY;;AAElC;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACfA,eAAe,mBAAO,CAAC,KAAa;AACpC,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,sBAAsB,mBAAO,CAAC,KAAoB;AAClD,gBAAgB,mBAAO,CAAC,KAAc;AACtC,gBAAgB,mBAAO,CAAC,KAAc;;AAEtC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClDA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,WAAW,SAAS;AACpB;AACA,WAAW,UAAU;AACrB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACtBA,eAAe,mBAAO,CAAC,KAAY;AACnC,eAAe,mBAAO,CAAC,KAAa;AACpC,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACpBA,sBAAsB,mBAAO,CAAC,KAAoB;;AAElD;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA,eAAe,mBAAO,CAAC,KAAa;AACpC,oBAAoB,mBAAO,CAAC,KAAkB;AAC9C,wBAAwB,mBAAO,CAAC,KAAsB;AACtD,eAAe,mBAAO,CAAC,KAAa;AACpC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvEA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;;;;;;;;ACZA,wBAAwB,mBAAO,CAAC,KAAqB;;AAErD;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,cAAc;AAC3B;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxCA,uBAAuB,mBAAO,CAAC,KAAqB;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,oBAAoB;AAC/B,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3CA,eAAe,mBAAO,CAAC,IAAa;AACpC,qBAAqB,mBAAO,CAAC,KAAmB;;AAEhD;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;;;;;;ACpCA,kBAAkB,mBAAO,CAAC,KAAe;;AAEzC;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,UAAU,mBAAO,CAAC,KAAQ;AAC1B,WAAW,mBAAO,CAAC,KAAQ;AAC3B,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB;AACA,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,eAAe,mBAAO,CAAC,KAAa;AACpC,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnFA,aAAa,mBAAO,CAAC,KAAW;AAChC,iBAAiB,mBAAO,CAAC,KAAe;AACxC,SAAS,mBAAO,CAAC,KAAM;AACvB,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,iBAAiB,mBAAO,CAAC,KAAe;AACxC,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/GA,iBAAiB,mBAAO,CAAC,KAAe;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzFA,yBAAyB,mBAAO,CAAC,KAAuB;AACxD,WAAW,mBAAO,CAAC,KAAQ;;AAE3B;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;ACvBA,SAAS,mBAAO,CAAC,KAAM;AACvB,kBAAkB,mBAAO,CAAC,KAAe;AACzC,cAAc,mBAAO,CAAC,KAAY;AAClC,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACdA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,GAAG;AACd,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACnBA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACpBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;;;;;;;;ACbA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,GAAG;AACd,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,aAAa,QAAQ;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;AClBA,eAAe,mBAAO,CAAC,IAAa;AACpC,SAAS,mBAAO,CAAC,KAAM;AACvB,qBAAqB,mBAAO,CAAC,KAAmB;AAChD,aAAa,mBAAO,CAAC,KAAU;;AAE/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,gBAAgB,QAAQ,IAAI,QAAQ,IAAI,QAAQ;AAChD,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;;;;;;;;AC/DA,YAAY,mBAAO,CAAC,KAAU;AAC9B,eAAe,mBAAO,CAAC,IAAa;AACpC,0BAA0B,mBAAO,CAAC,KAAwB;AAC1D,gBAAgB,mBAAO,CAAC,KAAa;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,oBAAoB,OAAO,UAAU,IAAI,OAAO,kBAAkB;AAClE,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC7BA,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,eAAe,mBAAO,CAAC,KAAa;AACpC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,cAAc,mBAAO,CAAC,KAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,eAAe,gBAAgB;AAC/B;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxCA,eAAe,mBAAO,CAAC,KAAa;AACpC,uBAAuB,mBAAO,CAAC,KAAqB;AACpD,eAAe,mBAAO,CAAC,IAAa;AACpC,0BAA0B,mBAAO,CAAC,KAAwB;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC7BA,eAAe,mBAAO,CAAC,KAAa;AACpC,uBAAuB,mBAAO,CAAC,KAAqB;AACpD,eAAe,mBAAO,CAAC,IAAa;AACpC,0BAA0B,mBAAO,CAAC,KAAwB;AAC1D,WAAW,mBAAO,CAAC,KAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA,oBAAoB,gBAAgB,IAAI,gBAAgB;AACxD,mBAAmB,gBAAgB,IAAI,gBAAgB;AACvD;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACxCA,kBAAkB,mBAAO,CAAC,KAAe;AACzC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChCA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClCA,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,WAAW,UAAU;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACrCA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,cAAc,mBAAO,CAAC,KAAW;AACjC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC7BA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,aAAa,QAAQ;AACrB;AACA;AACA;AACA,aAAa,QAAQ,IAAI,QAAQ;AACjC;AACA;AACA;AACA,aAAa,QAAQ,IAAI,QAAQ;AACjC;AACA;AACA;AACA,WAAW,QAAQ,gBAAgB,IAAI,gBAAgB;AACvD;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACtCA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,qBAAqB,mBAAO,CAAC,IAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,WAAW;AACtB,WAAW,UAAU;AACrB,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,iBAAiB;AACjB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AChBA,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,uBAAuB,mBAAO,CAAC,KAAqB;AACpD,YAAY,mBAAO,CAAC,KAAU;AAC9B,YAAY,mBAAO,CAAC,KAAU;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,UAAU;AACvB;AACA;AACA;AACA,OAAO,OAAO,UAAU;AACxB,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA,kBAAkB,mBAAO,CAAC,KAAgB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC5BA,kBAAkB,mBAAO,CAAC,IAAgB;AAC1C,eAAe,mBAAO,CAAC,KAAa;AACpC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,iBAAiB,mBAAO,CAAC,KAAe;AACxC,cAAc,mBAAO,CAAC,KAAW;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc,wBAAwB;AACtC;AACA;AACA,IAAI,IAAI;AACR,WAAW,8BAA8B;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AClDA,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,eAAe,mBAAO,CAAC,IAAa;AACpC,qBAAqB,mBAAO,CAAC,KAAmB;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,0BAA0B;AACrC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO,6BAA6B;AACpC,OAAO;AACP;AACA;AACA,kCAAkC,gBAAgB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;AC/CA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,gBAAgB,mBAAO,CAAC,KAAa;;AAErC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AClDA,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACzCA,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;ACnCA,eAAe,mBAAO,CAAC,KAAa;AACpC,eAAe,mBAAO,CAAC,KAAY;AACnC,eAAe,mBAAO,CAAC,KAAY;;AAEnC;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC/DA,iBAAiB,mBAAO,CAAC,KAAe;AACxC,aAAa,mBAAO,CAAC,KAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,GAAG;AACd,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA,cAAc,QAAQ;AACtB,WAAW;AACX;AACA;AACA;AACA;;AAEA;;;;;;;;AC/BA,gBAAgB,mBAAO,CAAC,KAAc;AACtC,iBAAiB,mBAAO,CAAC,KAAe;AACxC,iBAAiB,mBAAO,CAAC,KAAe;AACxC,mBAAmB,mBAAO,CAAC,KAAiB;AAC5C,mBAAmB,mBAAO,CAAC,IAAiB;AAC5C,cAAc,mBAAO,CAAC,KAAW;AACjC,eAAe,mBAAO,CAAC,KAAY;AACnC,iBAAiB,mBAAO,CAAC,KAAc;AACvC,eAAe,mBAAO,CAAC,KAAY;AACnC,mBAAmB,mBAAO,CAAC,KAAgB;;AAE3C;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,UAAU;AACrB,WAAW,GAAG;AACd,aAAa,GAAG;AAChB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA,IAAI,IAAI;AACR,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;;;;;;;AChEA,kBAAkB,mBAAO,CAAC,KAAgB;AAC1C,eAAe,mBAAO,CAAC,IAAa;AACpC,eAAe,mBAAO,CAAC,KAAa;AACpC,wBAAwB,mBAAO,CAAC,KAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;ACzBA,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACxBA,eAAe,mBAAO,CAAC,KAAa;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,UAAU;AACrB,aAAa,OAAO;AACpB;AACA;AACA,oBAAoB,gBAAgB,IAAI,gBAAgB,IAAI,gBAAgB;AAC5E;AACA;AACA,YAAY,gBAAgB,IAAI,gBAAgB;AAChD;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;AC3BA,qBAAqB,mBAAO,CAAC,KAAmB;AAChD,eAAe,mBAAO,CAAC,IAAa;AACpC,wBAAwB,mBAAO,CAAC,KAAqB;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACa,8bAA8b;AAC3c,cAAc,kCAAkC,iBAAiB,UAAU,0BAA0B,4CAA4C,kCAAkC,mDAAmD,kBAAkB,kBAAkB,uBAAuB,GAAG,uBAAuB,GAAG,eAAe,GAAG,kBAAkB,GAAG,gBAAgB,GAAG,YAAY,GAAG,YAAY,GAAG,cAAc,GAAG,gBAAgB,GAAG,kBAAkB,GAAG,gBAAgB;AAC/d,oBAAoB,GAAG,mBAAmB,YAAY,UAAU,wBAAwB,YAAY,UAAU,yBAAyB,aAAa,iBAAiB,yBAAyB,aAAa,iBAAiB,iBAAiB,aAAa,qDAAqD,oBAAoB,aAAa,iBAAiB,kBAAkB,aAAa,iBAAiB,cAAc,aAAa,iBAAiB,cAAc,aAAa;AACxd,gBAAgB,aAAa,iBAAiB,kBAAkB,aAAa,iBAAiB,oBAAoB,aAAa,iBAAiB,kBAAkB,aAAa,iBAAiB,sBAAsB,aAAa;AACnO,0BAA0B,aAAa,2PAA2P,cAAc;;;;;;;;;ACbnS;;AAEb,IAAI,IAAqC;AACzC,EAAE,2CAA4D;AAC9D,EAAE,KAAK,EAEN;;;;;;;;;ACNY;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;AAEF;;AAEA;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,cAAc,mBAAO,EAAE,KAAmB;AAC1C,aAAa,mBAAO,EAAE,KAAqB;;;AAG3C;;AAEA;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;;AAEA,eAAe,mBAAO,EAAE,IAAoB;;;AAG5C;;AAEA;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA;;;;;;;;;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA,UAAU,GAAG;AACb,YAAY,SAAS;AACrB;AACA;AACA;AACA,EAAE;;;AAGF;;AAEA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/isObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/allowAdditionalItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/asNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/constants.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getUiOptions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/canExpand.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/createErrorHandler.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/deepEquals.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/findSchemaDefinition.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getOptionMatchingSimpleDiscriminator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/getMatchingOption.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/getFirstMatchingOption.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getDiscriminatorFieldFromSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/guessType.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getSchemaType.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/mergeSchemas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/retrieveSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/getClosestMatchingOption.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/isFixedItems.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/mergeDefaultsWithFormData.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/mergeObjects.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/isConstant.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/isSelect.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/isMultiSelect.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/getDefaultFormState.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/isCustomWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/isFilesArray.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/getDisplayLabel.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/mergeValidationData.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/sanitizeDataForNewSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/toIdSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/toPathSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schema/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/createSchemaUtils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/dataURItoBlob.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/replaceStringParameters.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/englishStringTranslator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enumOptionsValueForIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enumOptionsDeselectValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enumOptionsIsSelected.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enumOptionsIndexForValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enumOptionsSelectValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/ErrorSchemaBuilder.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getDateElementProps.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/rangeSpec.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getInputProps.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getSubmitButtonOptions.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getTemplate.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/getWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/hashForSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/hasWidget.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/idGenerators.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/labelValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/localToUTC.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/toConstant.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/optionsList.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/orderProperties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/pad.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/parseDateString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/schemaRequiresTrueValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/shouldRender.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/toDateString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/toErrorList.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/toErrorSchema.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/unwrapErrorHandler.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/utcToLocal.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/validationDataMerge.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/withIdRefPrefix.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/enums.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/parser/ParserValidator.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/parser/schemaParser.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/parser/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@rjsf/utils/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/compute-gcd/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/compute-lcm/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-compare/src/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-merge-allof/src/common.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-merge-allof/src/complex-resolvers/items.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-merge-allof/src/complex-resolvers/properties.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/json-schema-merge-allof/src/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/jsonpointer/jsonpointer.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_SetCache.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_arrayIncludes.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_arrayIncludesWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_arrayReduce.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_arraySome.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_assignMergeValue.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseDifference.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseEach.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseFindIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseFor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseForOwn.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIndexOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIndexOfWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIntersection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsEqual.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsEqualDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsMatch.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIsNaN.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseIteratee.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseMap.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseMatches.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseMatchesProperty.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseMerge.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseMergeDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseOrderBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseProperty.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_basePropertyDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_basePullAll.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseReduce.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseRest.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseSortBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseTrim.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_baseUniq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_cacheHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_castArrayLikeObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_castFunction.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_compareAscending.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_compareMultiple.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_createAssigner.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_createBaseEach.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_createBaseFor.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_createSet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_customDefaultsMerge.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalArrays.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalByTag.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_equalObjects.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_getMatchData.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_isIterateeCall.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_isStrictComparable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_mapToArray.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_matchesStrictComparable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_safeGet.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setCacheAdd.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setCacheHas.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_setToArray.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_strictIndexOf.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/_trimmedEndIndex.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/defaults.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/defaultsDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/flattenDeep.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/forEach.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/intersection.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/intersectionWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isArrayLikeObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isBoolean.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isEqual.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isEqualWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isNil.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/isString.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/merge.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/mergeWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/noop.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/property.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/pullAll.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/reduce.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/sortBy.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/times.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/toFinite.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/toInteger.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/toNumber.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/toPlainObject.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/transform.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/union.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/uniq.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/uniqWith.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lodash/without.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/react-is/cjs/react-is.production.min.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/react-is/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/validate.io-array/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/validate.io-function/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/validate.io-integer-array/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/validate.io-integer/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/validate.io-number/lib/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/** Determines whether a `thing` is an object for the purposes of RSJF. In this case, `thing` is an object if it has</span><span class="s3">\n </span><span class="s1">* the type `object` but is NOT null, an array or a File.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param thing - The thing to check to see whether it is an object</span><span class="s3">\n </span><span class="s1">* @returns - True if it is a non-null, non-array, non-File object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isObject(thing) {</span><span class="s3">\n    </span><span class="s1">if (typeof File !== 'undefined' &amp;&amp; thing instanceof File) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof Date !== 'undefined' &amp;&amp; thing instanceof Date) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return typeof thing === 'object' &amp;&amp; thing !== null &amp;&amp; !Array.isArray(thing);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isObject.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Checks the schema to see if it is allowing additional items, by verifying that `schema.additionalItems` is an</span><span class="s3">\n </span><span class="s1">* object. The user is warned in the console if `schema.additionalItems` has the value `true`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema object to check</span><span class="s3">\n </span><span class="s1">* @returns - True if additional items is allowed, otherwise false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function allowAdditionalItems(schema) {</span><span class="s3">\n    </span><span class="s1">if (schema.additionalItems === true) {</span><span class="s3">\n        </span><span class="s1">console.warn('additionalItems=true is currently not supported');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isObject(schema.additionalItems);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=allowAdditionalItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Attempts to convert the string into a number. If an empty string is provided, then `undefined` is returned. If a</span><span class="s3">\n </span><span class="s1">* `null` is provided, it is returned. If the string ends in a `.` then the string is returned because the user may be</span><span class="s3">\n </span><span class="s1">* in the middle of typing a float number. If a number ends in a pattern like `.0`, `.20`, `.030`, string is returned</span><span class="s3">\n </span><span class="s1">* because the user may be typing number that will end in a non-zero digit. Otherwise, the string is wrapped by</span><span class="s3">\n </span><span class="s1">* `Number()` and if that result is not `NaN`, that number will be returned, otherwise the string `value` will be.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The string or null value to convert to a number</span><span class="s3">\n </span><span class="s1">* @returns - The `value` converted to a number when appropriate, otherwise the `value`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function asNumber(value) {</span><span class="s3">\n    </span><span class="s1">if (value === '') {</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value === null) {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">.$/.test(value)) {</span><span class="s3">\n        </span><span class="s1">// '3.' can't really be considered a number even if it parses in js. The</span><span class="s3">\n        </span><span class="s1">// user is most likely entering a float.</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">.0$/.test(value)) {</span><span class="s3">\n        </span><span class="s1">// we need to return this as a string here, to allow for input like 3.07</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*0$/.test(value)) {</span><span class="s3">\n        </span><span class="s1">// It's a number, that's cool - but we need it as a string so it doesn't screw</span><span class="s3">\n        </span><span class="s1">// with the user when entering dollar amounts or other values (such as those with</span><span class="s3">\n        </span><span class="s1">// specific precision or number of significant digits)</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const n = Number(value);</span><span class="s3">\n    </span><span class="s1">const valid = typeof n === 'number' &amp;&amp; !Number.isNaN(n);</span><span class="s3">\n    </span><span class="s1">return valid ? n : value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=asNumber.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Below are the list of all the keys into various elements of a RJSFSchema or UiSchema that are used by the various</span><span class="s3">\n </span><span class="s1">* utility functions. In addition to those keys, there are the special `ADDITIONAL_PROPERTY_FLAG` and</span><span class="s3">\n </span><span class="s1">* `RJSF_ADDITONAL_PROPERTIES_FLAG` flags that is added to a schema under certain conditions by the `retrieveSchema()`</span><span class="s3">\n </span><span class="s1">* utility.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const ADDITIONAL_PROPERTY_FLAG = '__additional_property';</span><span class="s3">\n</span><span class="s1">export const ADDITIONAL_PROPERTIES_KEY = 'additionalProperties';</span><span class="s3">\n</span><span class="s1">export const ALL_OF_KEY = 'allOf';</span><span class="s3">\n</span><span class="s1">export const ANY_OF_KEY = 'anyOf';</span><span class="s3">\n</span><span class="s1">export const CONST_KEY = 'const';</span><span class="s3">\n</span><span class="s1">export const DEFAULT_KEY = 'default';</span><span class="s3">\n</span><span class="s1">export const DEFINITIONS_KEY = 'definitions';</span><span class="s3">\n</span><span class="s1">export const DEPENDENCIES_KEY = 'dependencies';</span><span class="s3">\n</span><span class="s1">export const ENUM_KEY = 'enum';</span><span class="s3">\n</span><span class="s1">export const ERRORS_KEY = '__errors';</span><span class="s3">\n</span><span class="s1">export const ID_KEY = '$id';</span><span class="s3">\n</span><span class="s1">export const IF_KEY = 'if';</span><span class="s3">\n</span><span class="s1">export const ITEMS_KEY = 'items';</span><span class="s3">\n</span><span class="s1">export const JUNK_OPTION_ID = '_$junk_option_schema_id$_';</span><span class="s3">\n</span><span class="s1">export const NAME_KEY = '$name';</span><span class="s3">\n</span><span class="s1">export const ONE_OF_KEY = 'oneOf';</span><span class="s3">\n</span><span class="s1">export const PROPERTIES_KEY = 'properties';</span><span class="s3">\n</span><span class="s1">export const REQUIRED_KEY = 'required';</span><span class="s3">\n</span><span class="s1">export const SUBMIT_BTN_OPTIONS_KEY = 'submitButtonOptions';</span><span class="s3">\n</span><span class="s1">export const REF_KEY = '$ref';</span><span class="s3">\n</span><span class="s1">export const RJSF_ADDITONAL_PROPERTIES_FLAG = '__rjsf_additionalProperties';</span><span class="s3">\n</span><span class="s1">export const ROOT_SCHEMA_PREFIX = '__rjsf_rootSchema';</span><span class="s3">\n</span><span class="s1">export const UI_FIELD_KEY = 'ui:field';</span><span class="s3">\n</span><span class="s1">export const UI_WIDGET_KEY = 'ui:widget';</span><span class="s3">\n</span><span class="s1">export const UI_OPTIONS_KEY = 'ui:options';</span><span class="s3">\n</span><span class="s1">export const UI_GLOBAL_OPTIONS_KEY = 'ui:globalOptions';</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=constants.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { UI_OPTIONS_KEY, UI_WIDGET_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Get all passed options from ui:options, and ui:&lt;optionName&gt;, returning them in an object with the `ui:`</span><span class="s3">\n </span><span class="s1">* stripped off. Any `globalOptions` will always be returned, unless they are overridden by options in the `uiSchema`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param [uiSchema={}] - The UI Schema from which to get any `ui:xxx` options</span><span class="s3">\n </span><span class="s1">* @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options</span><span class="s3">\n </span><span class="s1">* @returns - An object containing all the `ui:xxx` options with the `ui:` stripped off along with all `globalOptions`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getUiOptions(uiSchema = {}, globalOptions = {}) {</span><span class="s3">\n    </span><span class="s1">return Object.keys(uiSchema)</span><span class="s3">\n        </span><span class="s1">.filter((key) =&gt; key.indexOf('ui:') === 0)</span><span class="s3">\n        </span><span class="s1">.reduce((options, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">const value = uiSchema[key];</span><span class="s3">\n        </span><span class="s1">if (key === UI_WIDGET_KEY &amp;&amp; isObject(value)) {</span><span class="s3">\n            </span><span class="s1">console.error('Setting options via ui:widget object is no longer supported, use ui:options instead');</span><span class="s3">\n            </span><span class="s1">return options;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (key === UI_OPTIONS_KEY &amp;&amp; isObject(value)) {</span><span class="s3">\n            </span><span class="s1">return { ...options, ...value };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { ...options, [key.substring(3)]: value };</span><span class="s3">\n    </span><span class="s1">}, { ...globalOptions });</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getUiOptions.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import getUiOptions from './getUiOptions';</span><span class="s3">\n</span><span class="s1">/** Checks whether the field described by `schema`, having the `uiSchema` and `formData` supports expanding. The UI for</span><span class="s3">\n </span><span class="s1">* the field can expand if it has additional properties, is not forced as non-expandable by the `uiSchema` and the</span><span class="s3">\n </span><span class="s1">* `formData` object doesn't already have `schema.maxProperties` elements.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for the field that is being checked</span><span class="s3">\n </span><span class="s1">* @param [uiSchema={}] - The uiSchema for the field</span><span class="s3">\n </span><span class="s1">* @param [formData] - The formData for the field</span><span class="s3">\n </span><span class="s1">* @returns - True if the schema element has additionalProperties, is expandable, and not at the maxProperties limit</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function canExpand(schema, uiSchema = {}, formData) {</span><span class="s3">\n    </span><span class="s1">if (!schema.additionalProperties) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { expandable = true } = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">if (expandable === false) {</span><span class="s3">\n        </span><span class="s1">return expandable;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// if ui:options.expandable was not explicitly set to false, we can add</span><span class="s3">\n    </span><span class="s1">// another property if we have not exceeded maxProperties yet</span><span class="s3">\n    </span><span class="s1">if (schema.maxProperties !== undefined &amp;&amp; formData) {</span><span class="s3">\n        </span><span class="s1">return Object.keys(formData).length &lt; schema.maxProperties;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=canExpand.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isPlainObject from 'lodash/isPlainObject';</span><span class="s3">\n</span><span class="s1">import { ERRORS_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Given a `formData` object, recursively creates a `FormValidation` error handling structure around it</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param formData - The form data around which the error handler is created</span><span class="s3">\n </span><span class="s1">* @returns - A `FormValidation` object based on the `formData` structure</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function createErrorHandler(formData) {</span><span class="s3">\n    </span><span class="s1">const handler = {</span><span class="s3">\n        </span><span class="s1">// We store the list of errors for this node in a property named __errors</span><span class="s3">\n        </span><span class="s1">// to avoid name collision with a possible sub schema field named</span><span class="s3">\n        </span><span class="s1">// 'errors' (see `utils.toErrorSchema`).</span><span class="s3">\n        </span><span class="s1">[ERRORS_KEY]: [],</span><span class="s3">\n        </span><span class="s1">addError(message) {</span><span class="s3">\n            </span><span class="s1">this[ERRORS_KEY].push(message);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(formData)) {</span><span class="s3">\n        </span><span class="s1">return formData.reduce((acc, value, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">return { ...acc, [key]: createErrorHandler(value) };</span><span class="s3">\n        </span><span class="s1">}, handler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isPlainObject(formData)) {</span><span class="s3">\n        </span><span class="s1">const formObject = formData;</span><span class="s3">\n        </span><span class="s1">return Object.keys(formObject).reduce((acc, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">return { ...acc, [key]: createErrorHandler(formObject[key]) };</span><span class="s3">\n        </span><span class="s1">}, handler);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return handler;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=createErrorHandler.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isEqualWith from 'lodash/isEqualWith';</span><span class="s3">\n</span><span class="s1">/** Implements a deep equals using the `lodash.isEqualWith` function, that provides a customized comparator that</span><span class="s3">\n </span><span class="s1">* assumes all functions are equivalent.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param a - The first element to compare</span><span class="s3">\n </span><span class="s1">* @param b - The second element to compare</span><span class="s3">\n </span><span class="s1">* @returns - True if the `a` and `b` are deeply equal, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function deepEquals(a, b) {</span><span class="s3">\n    </span><span class="s1">return isEqualWith(a, b, (obj, other) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (typeof obj === 'function' &amp;&amp; typeof other === 'function') {</span><span class="s3">\n            </span><span class="s1">// Assume all functions are equivalent</span><span class="s3">\n            </span><span class="s1">// see https://github.com/rjsf-team/react-jsonschema-form/issues/255</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return undefined; // fallback to default isEquals behavior</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=deepEquals.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import jsonpointer from 'jsonpointer';</span><span class="s3">\n</span><span class="s1">import omit from 'lodash/omit';</span><span class="s3">\n</span><span class="s1">import { REF_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Splits out the value at the `key` in `object` from the `object`, returning an array that contains in the first</span><span class="s3">\n </span><span class="s1">* location, the `object` minus the `key: value` and in the second location the `value`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param key - The key from the object to extract</span><span class="s3">\n </span><span class="s1">* @param object - The object from which to extract the element</span><span class="s3">\n </span><span class="s1">* @returns - An array with the first value being the object minus the `key` element and the second element being the</span><span class="s3">\n </span><span class="s1">*      value from `object[key]`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function splitKeyElementFromObject(key, object) {</span><span class="s3">\n    </span><span class="s1">const value = object[key];</span><span class="s3">\n    </span><span class="s1">const remaining = omit(object, [key]);</span><span class="s3">\n    </span><span class="s1">return [remaining, value];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Given the name of a `$ref` from within a schema, using the `rootSchema`, look up and return the sub-schema using the</span><span class="s3">\n </span><span class="s1">* path provided by that reference. If `#` is not the first character of the reference, or the path does not exist in</span><span class="s3">\n </span><span class="s1">* the schema, then throw an Error. Otherwise return the sub-schema. Also deals with nested `$ref`s in the sub-schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param $ref - The ref string for which the schema definition is desired</span><span class="s3">\n </span><span class="s1">* @param [rootSchema={}] - The root schema in which to search for the definition</span><span class="s3">\n </span><span class="s1">* @returns - The sub-schema within the `rootSchema` which matches the `$ref` if it exists</span><span class="s3">\n </span><span class="s1">* @throws - Error indicating that no schema for that reference exists</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function findSchemaDefinition($ref, rootSchema = {}) {</span><span class="s3">\n    </span><span class="s1">let ref = $ref || '';</span><span class="s3">\n    </span><span class="s1">if (ref.startsWith('#')) {</span><span class="s3">\n        </span><span class="s1">// Decode URI fragment representation.</span><span class="s3">\n        </span><span class="s1">ref = decodeURIComponent(ref.substring(1));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Could not find a definition for ${$ref}.`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const current = jsonpointer.get(rootSchema, ref);</span><span class="s3">\n    </span><span class="s1">if (current === undefined) {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Could not find a definition for ${$ref}.`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (current[REF_KEY]) {</span><span class="s3">\n        </span><span class="s1">const [remaining, theRef] = splitKeyElementFromObject(REF_KEY, current);</span><span class="s3">\n        </span><span class="s1">const subSchema = findSchemaDefinition(theRef, rootSchema);</span><span class="s3">\n        </span><span class="s1">if (Object.keys(remaining).length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">return { ...remaining, ...subSchema };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return subSchema;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return current;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=findSchemaDefinition.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import { PROPERTIES_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Compares the value of `discriminatorField` within `formData` against the value of `discriminatorField` within schema for each `option`.</span><span class="s3">\n </span><span class="s1">* Returns index of first `option` whose discriminator matches formData. Returns `undefined` if there is no match.</span><span class="s3">\n </span><span class="s1">* This function does not work with discriminators of `</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">` and `</span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">array</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param formData - The current formData, if any, used to figure out a match</span><span class="s3">\n </span><span class="s1">* @param options - The list of options to find a matching options from</span><span class="s3">\n </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n </span><span class="s1">*          determine which option is selected</span><span class="s3">\n </span><span class="s1">* @returns - The index of the matched option or undefined if there is no match</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">if (formData &amp;&amp; discriminatorField) {</span><span class="s3">\n        </span><span class="s1">const value = get(formData, discriminatorField);</span><span class="s3">\n        </span><span class="s1">if (value === undefined) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; options.length; i++) {</span><span class="s3">\n            </span><span class="s1">const option = options[i];</span><span class="s3">\n            </span><span class="s1">const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});</span><span class="s3">\n            </span><span class="s1">if (discriminator.type === 'object' || discriminator.type === 'array') {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (discriminator.const === value) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if ((_a = discriminator.enum) === null || _a === void 0 ? void 0 : _a.includes(value)) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getOptionMatchingSimpleDiscriminator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import has from 'lodash/has';</span><span class="s3">\n</span><span class="s1">import isNumber from 'lodash/isNumber';</span><span class="s3">\n</span><span class="s1">import { PROPERTIES_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';</span><span class="s3">\n</span><span class="s1">/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.</span><span class="s3">\n </span><span class="s1">* Deprecated, use `getFirstMatchingOption()` instead.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param formData - The current formData, if any, used to figure out a match</span><span class="s3">\n </span><span class="s1">* @param options - The list of options to find a matching options from</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n </span><span class="s1">*          determine which option is selected</span><span class="s3">\n </span><span class="s1">* @returns - The index of the matched option or 0 if none is available</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getMatchingOption(validator, formData, options, rootSchema, discriminatorField) {</span><span class="s3">\n    </span><span class="s1">// For performance, skip validating subschemas if formData is undefined. We just</span><span class="s3">\n    </span><span class="s1">// want to get the first option in that case.</span><span class="s3">\n    </span><span class="s1">if (formData === undefined) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);</span><span class="s3">\n    </span><span class="s1">if (isNumber(simpleDiscriminatorMatch)) {</span><span class="s3">\n        </span><span class="s1">return simpleDiscriminatorMatch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; options.length; i++) {</span><span class="s3">\n        </span><span class="s1">const option = options[i];</span><span class="s3">\n        </span><span class="s1">// If we have a discriminator field, then we will use this to make the determination</span><span class="s3">\n        </span><span class="s1">if (discriminatorField &amp;&amp; has(option, [PROPERTIES_KEY, discriminatorField])) {</span><span class="s3">\n            </span><span class="s1">const value = get(formData, discriminatorField);</span><span class="s3">\n            </span><span class="s1">const discriminator = get(option, [PROPERTIES_KEY, discriminatorField], {});</span><span class="s3">\n            </span><span class="s1">if (validator.isValid(discriminator, value, rootSchema)) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (option[PROPERTIES_KEY]) {</span><span class="s3">\n            </span><span class="s1">// If the schema describes an object then we need to add slightly more</span><span class="s3">\n            </span><span class="s1">// strict matching to the schema, because unless the schema uses the</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">requires</span><span class="s3">\&quot; </span><span class="s1">keyword, an object will match the schema as long as it</span><span class="s3">\n            </span><span class="s1">// doesn't have matching keys with a conflicting type. To do this we use an</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">anyOf</span><span class="s3">\&quot; </span><span class="s1">with an array of requires. This augmentation expresses that the</span><span class="s3">\n            </span><span class="s1">// schema should match if any of the keys in the schema are present on the</span><span class="s3">\n            </span><span class="s1">// object and pass validation.</span><span class="s3">\n            </span><span class="s1">//</span><span class="s3">\n            </span><span class="s1">// Create an </span><span class="s3">\&quot;</span><span class="s1">anyOf</span><span class="s3">\&quot; </span><span class="s1">schema that requires at least one of the keys in the</span><span class="s3">\n            </span><span class="s1">// </span><span class="s3">\&quot;</span><span class="s1">properties</span><span class="s3">\&quot; </span><span class="s1">object</span><span class="s3">\n            </span><span class="s1">const requiresAnyOf = {</span><span class="s3">\n                </span><span class="s1">anyOf: Object.keys(option[PROPERTIES_KEY]).map((key) =&gt; ({</span><span class="s3">\n                    </span><span class="s1">required: [key],</span><span class="s3">\n                </span><span class="s1">})),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">let augmentedSchema;</span><span class="s3">\n            </span><span class="s1">// If the </span><span class="s3">\&quot;</span><span class="s1">anyOf</span><span class="s3">\&quot; </span><span class="s1">keyword already exists, wrap the augmentation in an </span><span class="s3">\&quot;</span><span class="s1">allOf</span><span class="s3">\&quot;\n            </span><span class="s1">if (option.anyOf) {</span><span class="s3">\n                </span><span class="s1">// Create a shallow clone of the option</span><span class="s3">\n                </span><span class="s1">const { ...shallowClone } = option;</span><span class="s3">\n                </span><span class="s1">if (!shallowClone.allOf) {</span><span class="s3">\n                    </span><span class="s1">shallowClone.allOf = [];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// If </span><span class="s3">\&quot;</span><span class="s1">allOf</span><span class="s3">\&quot; </span><span class="s1">already exists, shallow clone the array</span><span class="s3">\n                    </span><span class="s1">shallowClone.allOf = shallowClone.allOf.slice();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">shallowClone.allOf.push(requiresAnyOf);</span><span class="s3">\n                </span><span class="s1">augmentedSchema = shallowClone;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">augmentedSchema = Object.assign({}, option, requiresAnyOf);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Remove the </span><span class="s3">\&quot;</span><span class="s1">required</span><span class="s3">\&quot; </span><span class="s1">field as it's likely that not all fields have</span><span class="s3">\n            </span><span class="s1">// been filled in yet, which will mean that the schema is not valid</span><span class="s3">\n            </span><span class="s1">delete augmentedSchema.required;</span><span class="s3">\n            </span><span class="s1">if (validator.isValid(augmentedSchema, formData, rootSchema)) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (validator.isValid(option, formData, rootSchema)) {</span><span class="s3">\n            </span><span class="s1">return i;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getMatchingOption.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import getMatchingOption from './getMatchingOption';</span><span class="s3">\n</span><span class="s1">/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.</span><span class="s3">\n </span><span class="s1">* Always returns the first option if there is nothing that matches.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param formData - The current formData, if any, used to figure out a match</span><span class="s3">\n </span><span class="s1">* @param options - The list of options to find a matching options from</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n </span><span class="s1">*          determine which option is selected</span><span class="s3">\n </span><span class="s1">* @returns - The index of the first matched option or 0 if none is available</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getFirstMatchingOption(validator, formData, options, rootSchema, discriminatorField) {</span><span class="s3">\n    </span><span class="s1">return getMatchingOption(validator, formData, options, rootSchema, discriminatorField);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getFirstMatchingOption.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isString from 'lodash/isString';</span><span class="s3">\n</span><span class="s1">/** Returns the `discriminator.propertyName` when defined in the `schema` if it is a string. A warning is generated when</span><span class="s3">\n </span><span class="s1">* it is not a string. Returns `undefined` when a valid discriminator is not present.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which the discriminator is potentially obtained</span><span class="s3">\n </span><span class="s1">* @returns - The `discriminator.propertyName` if it exists in the schema, otherwise `undefined`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getDiscriminatorFieldFromSchema(schema) {</span><span class="s3">\n    </span><span class="s1">let discriminator;</span><span class="s3">\n    </span><span class="s1">const maybeString = get(schema, 'discriminator.propertyName', undefined);</span><span class="s3">\n    </span><span class="s1">if (isString(maybeString)) {</span><span class="s3">\n        </span><span class="s1">discriminator = maybeString;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (maybeString !== undefined) {</span><span class="s3">\n        </span><span class="s1">console.warn(`Expecting discriminator to be a string, got </span><span class="s3">\&quot;</span><span class="s1">${typeof maybeString}</span><span class="s3">\&quot; </span><span class="s1">instead`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return discriminator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getDiscriminatorFieldFromSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Given a specific `value` attempts to guess the type of a schema element. In the case where we have to implicitly</span><span class="s3">\n </span><span class="s1">*  create a schema, it is useful to know what type to use based on the data we are defining.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value from which to guess the type</span><span class="s3">\n </span><span class="s1">* @returns - The best guess for the object type</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function guessType(value) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(value)) {</span><span class="s3">\n        </span><span class="s1">return 'array';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'string') {</span><span class="s3">\n        </span><span class="s1">return 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (value == null) {</span><span class="s3">\n        </span><span class="s1">return 'null';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'boolean') {</span><span class="s3">\n        </span><span class="s1">return 'boolean';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!isNaN(value)) {</span><span class="s3">\n        </span><span class="s1">return 'number';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof value === 'object') {</span><span class="s3">\n        </span><span class="s1">return 'object';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Default to string if we can't figure it out</span><span class="s3">\n    </span><span class="s1">return 'string';</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=guessType.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import guessType from './guessType';</span><span class="s3">\n</span><span class="s1">/** Gets the type of a given `schema`. If the type is not explicitly defined, then an attempt is made to infer it from</span><span class="s3">\n </span><span class="s1">* other elements of the schema as follows:</span><span class="s3">\n </span><span class="s1">* - schema.const: Returns the `guessType()` of that value</span><span class="s3">\n </span><span class="s1">* - schema.enum: Returns `string`</span><span class="s3">\n </span><span class="s1">* - schema.properties: Returns `object`</span><span class="s3">\n </span><span class="s1">* - schema.additionalProperties: Returns `object`</span><span class="s3">\n </span><span class="s1">* - type is an array with a length of 2 and one type is 'null': Returns the other type</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which to get the type</span><span class="s3">\n </span><span class="s1">* @returns - The type of the schema</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getSchemaType(schema) {</span><span class="s3">\n    </span><span class="s1">let { type } = schema;</span><span class="s3">\n    </span><span class="s1">if (!type &amp;&amp; schema.const) {</span><span class="s3">\n        </span><span class="s1">return guessType(schema.const);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!type &amp;&amp; schema.enum) {</span><span class="s3">\n        </span><span class="s1">return 'string';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!type &amp;&amp; (schema.properties || schema.additionalProperties)) {</span><span class="s3">\n        </span><span class="s1">return 'object';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(type)) {</span><span class="s3">\n        </span><span class="s1">if (type.length === 2 &amp;&amp; type.includes('null')) {</span><span class="s3">\n            </span><span class="s1">type = type.find((type) =&gt; type !== 'null');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">type = type[0];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return type;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getSchemaType.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import union from 'lodash/union';</span><span class="s3">\n</span><span class="s1">import { REQUIRED_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">import getSchemaType from './getSchemaType';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Recursively merge deeply nested schemas. The difference between `mergeSchemas` and `mergeObjects` is that</span><span class="s3">\n </span><span class="s1">* `mergeSchemas` only concats arrays for values under the 'required' keyword, and when it does, it doesn't include</span><span class="s3">\n </span><span class="s1">* duplicate values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param obj1 - The first schema object to merge</span><span class="s3">\n </span><span class="s1">* @param obj2 - The second schema object to merge</span><span class="s3">\n </span><span class="s1">* @returns - The merged schema object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function mergeSchemas(obj1, obj2) {</span><span class="s3">\n    </span><span class="s1">const acc = Object.assign({}, obj1); // Prevent mutation of source object.</span><span class="s3">\n    </span><span class="s1">return Object.keys(obj2).reduce((acc, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">const left = obj1 ? obj1[key] : {}, right = obj2[key];</span><span class="s3">\n        </span><span class="s1">if (obj1 &amp;&amp; key in obj1 &amp;&amp; isObject(right)) {</span><span class="s3">\n            </span><span class="s1">acc[key] = mergeSchemas(left, right);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (obj1 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">obj2 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(getSchemaType(obj1) === 'object' || getSchemaType(obj2) === 'object') &amp;&amp;</span><span class="s3">\n            </span><span class="s1">key === REQUIRED_KEY &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Array.isArray(left) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">Array.isArray(right)) {</span><span class="s3">\n            </span><span class="s1">// Don't include duplicate values when merging 'required' fields.</span><span class="s3">\n            </span><span class="s1">acc[key] = union(left, right);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">acc[key] = right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return acc;</span><span class="s3">\n    </span><span class="s1">}, acc);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=mergeSchemas.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import times from 'lodash/times';</span><span class="s3">\n</span><span class="s1">import transform from 'lodash/transform';</span><span class="s3">\n</span><span class="s1">import merge from 'lodash/merge';</span><span class="s3">\n</span><span class="s1">import flattenDeep from 'lodash/flattenDeep';</span><span class="s3">\n</span><span class="s1">import uniq from 'lodash/uniq';</span><span class="s3">\n</span><span class="s1">import mergeAllOf from 'json-schema-merge-allof';</span><span class="s3">\n</span><span class="s1">import { ADDITIONAL_PROPERTIES_KEY, ADDITIONAL_PROPERTY_FLAG, ALL_OF_KEY, ANY_OF_KEY, DEPENDENCIES_KEY, IF_KEY, ONE_OF_KEY, REF_KEY, PROPERTIES_KEY, ITEMS_KEY, } from '../constants';</span><span class="s3">\n</span><span class="s1">import findSchemaDefinition, { splitKeyElementFromObject } from '../findSchemaDefinition';</span><span class="s3">\n</span><span class="s1">import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';</span><span class="s3">\n</span><span class="s1">import guessType from '../guessType';</span><span class="s3">\n</span><span class="s1">import isObject from '../isObject';</span><span class="s3">\n</span><span class="s1">import mergeSchemas from '../mergeSchemas';</span><span class="s3">\n</span><span class="s1">import getFirstMatchingOption from './getFirstMatchingOption';</span><span class="s3">\n</span><span class="s1">/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and dependencies</span><span class="s3">\n </span><span class="s1">* resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData` that is used to do the</span><span class="s3">\n </span><span class="s1">* potentially recursive resolution.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which retrieving a schema is desired</span><span class="s3">\n </span><span class="s1">* @param [rootSchema={}] - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param [rawFormData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The schema having its conditions, additional properties, references and dependencies resolved</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function retrieveSchema(validator, schema, rootSchema = {}, rawFormData) {</span><span class="s3">\n    </span><span class="s1">return retrieveSchemaInternal(validator, schema, rootSchema, rawFormData)[0];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves a conditional block (if/else/then) by removing the condition and merging the appropriate conditional branch</span><span class="s3">\n </span><span class="s1">* with the rest of the schema. If `expandAllBranches` is true, then the `retrieveSchemaInteral()` results for both</span><span class="s3">\n </span><span class="s1">* conditions will be returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that is used to detect valid schema conditions</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a condition is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and</span><span class="s3">\n </span><span class="s1">*          dependencies as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - A list of schemas with the appropriate conditions resolved, possibly with all branches expanded</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveCondition(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">const { if: expression, then, else: otherwise, ...resolvedSchemaLessConditional } = schema;</span><span class="s3">\n    </span><span class="s1">const conditionValue = validator.isValid(expression, formData || {}, rootSchema);</span><span class="s3">\n    </span><span class="s1">let resolvedSchemas = [resolvedSchemaLessConditional];</span><span class="s3">\n    </span><span class="s1">let schemas = [];</span><span class="s3">\n    </span><span class="s1">if (expandAllBranches) {</span><span class="s3">\n        </span><span class="s1">if (then &amp;&amp; typeof then !== 'boolean') {</span><span class="s3">\n            </span><span class="s1">schemas = schemas.concat(retrieveSchemaInternal(validator, then, rootSchema, formData, expandAllBranches, recurseList));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (otherwise &amp;&amp; typeof otherwise !== 'boolean') {</span><span class="s3">\n            </span><span class="s1">schemas = schemas.concat(retrieveSchemaInternal(validator, otherwise, rootSchema, formData, expandAllBranches, recurseList));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">const conditionalSchema = conditionValue ? then : otherwise;</span><span class="s3">\n        </span><span class="s1">if (conditionalSchema &amp;&amp; typeof conditionalSchema !== 'boolean') {</span><span class="s3">\n            </span><span class="s1">schemas = schemas.concat(retrieveSchemaInternal(validator, conditionalSchema, rootSchema, formData, expandAllBranches, recurseList));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schemas.length) {</span><span class="s3">\n        </span><span class="s1">resolvedSchemas = schemas.map((s) =&gt; mergeSchemas(resolvedSchemaLessConditional, s));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return resolvedSchemas.flatMap((s) =&gt; retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Given a list of lists of allOf, anyOf or oneOf values, create a list of lists of all permutations of the values. The</span><span class="s3">\n </span><span class="s1">* `listOfLists` is expected to be all resolved values of the 1st...nth schemas within an `allOf`, `anyOf` or `oneOf`.</span><span class="s3">\n </span><span class="s1">* From those lists, build a matrix for each `xxxOf` where there is more than one schema for a row in the list of lists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* For example:</span><span class="s3">\n </span><span class="s1">* - If there are three xxxOf rows (A, B, C) and they have been resolved such that there is only one A, two B and three</span><span class="s3">\n </span><span class="s1">*   C schemas then:</span><span class="s3">\n </span><span class="s1">*   - The permutation for the first row is `[[A]]`</span><span class="s3">\n </span><span class="s1">*   - The permutations for the second row are `[[A,B1], [A,B2]]`</span><span class="s3">\n </span><span class="s1">*   - The permutations for the third row are `[[A,B1,C1], [A,B1,C2], [A,B1,C3], [A,B2,C1], [A,B2,C2], [A,B2,C3]]`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param listOfLists - The list of lists of elements that represent the allOf, anyOf or oneOf resolved values in order</span><span class="s3">\n </span><span class="s1">* @returns - The list of all permutations of schemas for a set of `xxxOf`s</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getAllPermutationsOfXxxOf(listOfLists) {</span><span class="s3">\n    </span><span class="s1">const allPermutations = listOfLists.reduce((permutations, list) =&gt; {</span><span class="s3">\n        </span><span class="s1">// When there are more than one set of schemas for a row, duplicate the set of permutations and add in the values</span><span class="s3">\n        </span><span class="s1">if (list.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">return list.flatMap((element) =&gt; times(permutations.length, (i) =&gt; [...permutations[i]].concat(element)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Otherwise just push in the single value into the current set of permutations</span><span class="s3">\n        </span><span class="s1">permutations.forEach((permutation) =&gt; permutation.push(list[0]));</span><span class="s3">\n        </span><span class="s1">return permutations;</span><span class="s3">\n    </span><span class="s1">}, [[]] // Start with an empty list</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return allPermutations;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves references and dependencies within a schema and its 'allOf' children. Passes the `expandAllBranches` flag</span><span class="s3">\n </span><span class="s1">* down to the `retrieveSchemaInternal()`, `resolveReference()` and `resolveDependencies()` helper calls. If</span><span class="s3">\n </span><span class="s1">* `expandAllBranches` is true, then all possible dependencies and/or allOf branches are returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a schema is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The list of schemas having its references, dependencies and allOf schemas resolved</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">const updatedSchemas = resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData);</span><span class="s3">\n    </span><span class="s1">if (updatedSchemas.length &gt; 1 || updatedSchemas[0] !== schema) {</span><span class="s3">\n        </span><span class="s1">// return the updatedSchemas array if it has either multiple schemas within it</span><span class="s3">\n        </span><span class="s1">// OR the first schema is not the same as the original schema</span><span class="s3">\n        </span><span class="s1">return updatedSchemas;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (DEPENDENCIES_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const resolvedSchemas = resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData);</span><span class="s3">\n        </span><span class="s1">return resolvedSchemas.flatMap((s) =&gt; {</span><span class="s3">\n            </span><span class="s1">return retrieveSchemaInternal(validator, s, rootSchema, formData, expandAllBranches, recurseList);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ALL_OF_KEY in schema &amp;&amp; Array.isArray(schema.allOf)) {</span><span class="s3">\n        </span><span class="s1">const allOfSchemaElements = schema.allOf.map((allOfSubschema) =&gt; retrieveSchemaInternal(validator, allOfSubschema, rootSchema, formData, expandAllBranches, recurseList));</span><span class="s3">\n        </span><span class="s1">const allPermutations = getAllPermutationsOfXxxOf(allOfSchemaElements);</span><span class="s3">\n        </span><span class="s1">return allPermutations.map((permutation) =&gt; ({ ...schema, allOf: permutation }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// No $ref or dependencies or allOf attribute was found, returning the original schema.</span><span class="s3">\n    </span><span class="s1">return [schema];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves all references within a schema and then returns the `retrieveSchemaInternal()` if the resolved schema is</span><span class="s3">\n </span><span class="s1">* actually different than the original. Passes the `expandAllBranches` flag down to the `retrieveSchemaInternal()`</span><span class="s3">\n </span><span class="s1">* helper call.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a reference is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The list schemas retrieved after having all references resolved</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveReference(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">const updatedSchema = resolveAllReferences(schema, rootSchema, recurseList);</span><span class="s3">\n    </span><span class="s1">if (updatedSchema !== schema) {</span><span class="s3">\n        </span><span class="s1">// Only call this if the schema was actually changed by the `resolveAllReferences()` function</span><span class="s3">\n        </span><span class="s1">return retrieveSchemaInternal(validator, updatedSchema, rootSchema, formData, expandAllBranches, recurseList);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [schema];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves all references within the schema itself as well as any of its properties and array items.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving all references is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param recurseList - List of $refs already resolved to prevent recursion</span><span class="s3">\n </span><span class="s1">* @returns - given schema will all references resolved or the original schema if no internal `$refs` were resolved</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveAllReferences(schema, rootSchema, recurseList) {</span><span class="s3">\n    </span><span class="s1">if (!isObject(schema)) {</span><span class="s3">\n        </span><span class="s1">return schema;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let resolvedSchema = schema;</span><span class="s3">\n    </span><span class="s1">// resolve top level ref</span><span class="s3">\n    </span><span class="s1">if (REF_KEY in resolvedSchema) {</span><span class="s3">\n        </span><span class="s1">const { $ref, ...localSchema } = resolvedSchema;</span><span class="s3">\n        </span><span class="s1">// Check for a recursive reference and stop the loop</span><span class="s3">\n        </span><span class="s1">if (recurseList.includes($ref)) {</span><span class="s3">\n            </span><span class="s1">return resolvedSchema;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">recurseList.push($ref);</span><span class="s3">\n        </span><span class="s1">// Retrieve the referenced schema definition.</span><span class="s3">\n        </span><span class="s1">const refSchema = findSchemaDefinition($ref, rootSchema);</span><span class="s3">\n        </span><span class="s1">resolvedSchema = { ...refSchema, ...localSchema };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (PROPERTIES_KEY in resolvedSchema) {</span><span class="s3">\n        </span><span class="s1">const childrenLists = [];</span><span class="s3">\n        </span><span class="s1">const updatedProps = transform(resolvedSchema[PROPERTIES_KEY], (result, value, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">const childList = [...recurseList];</span><span class="s3">\n            </span><span class="s1">result[key] = resolveAllReferences(value, rootSchema, childList);</span><span class="s3">\n            </span><span class="s1">childrenLists.push(childList);</span><span class="s3">\n        </span><span class="s1">}, {});</span><span class="s3">\n        </span><span class="s1">merge(recurseList, uniq(flattenDeep(childrenLists)));</span><span class="s3">\n        </span><span class="s1">resolvedSchema = { ...resolvedSchema, [PROPERTIES_KEY]: updatedProps };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ITEMS_KEY in resolvedSchema &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!Array.isArray(resolvedSchema.items) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">typeof resolvedSchema.items !== 'boolean') {</span><span class="s3">\n        </span><span class="s1">resolvedSchema = {</span><span class="s3">\n            </span><span class="s1">...resolvedSchema,</span><span class="s3">\n            </span><span class="s1">items: resolveAllReferences(resolvedSchema.items, rootSchema, recurseList),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isEqual(schema, resolvedSchema) ? schema : resolvedSchema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Creates new 'properties' items for each key in the `formData`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param theSchema - The schema for which the existing additional properties is desired</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s * @param validator</span><span class="s3">\n </span><span class="s1">* @param [aFormData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The updated schema with additional properties stubbed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function stubExistingAdditionalProperties(validator, theSchema, rootSchema, aFormData) {</span><span class="s3">\n    </span><span class="s1">// Clone the schema so that we don't ruin the consumer's original</span><span class="s3">\n    </span><span class="s1">const schema = {</span><span class="s3">\n        </span><span class="s1">...theSchema,</span><span class="s3">\n        </span><span class="s1">properties: { ...theSchema.properties },</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">// make sure formData is an object</span><span class="s3">\n    </span><span class="s1">const formData = aFormData &amp;&amp; isObject(aFormData) ? aFormData : {};</span><span class="s3">\n    </span><span class="s1">Object.keys(formData).forEach((key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (key in schema.properties) {</span><span class="s3">\n            </span><span class="s1">// No need to stub, our schema already has the property</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let additionalProperties = {};</span><span class="s3">\n        </span><span class="s1">if (typeof schema.additionalProperties !== 'boolean') {</span><span class="s3">\n            </span><span class="s1">if (REF_KEY in schema.additionalProperties) {</span><span class="s3">\n                </span><span class="s1">additionalProperties = retrieveSchema(validator, { $ref: get(schema.additionalProperties, [REF_KEY]) }, rootSchema, formData);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if ('type' in schema.additionalProperties) {</span><span class="s3">\n                </span><span class="s1">additionalProperties = { ...schema.additionalProperties };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (ANY_OF_KEY in schema.additionalProperties || ONE_OF_KEY in schema.additionalProperties) {</span><span class="s3">\n                </span><span class="s1">additionalProperties = {</span><span class="s3">\n                    </span><span class="s1">type: 'object',</span><span class="s3">\n                    </span><span class="s1">...schema.additionalProperties,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">additionalProperties = { type: guessType(get(formData, [key])) };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">additionalProperties = { type: guessType(get(formData, [key])) };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// The type of our new key should match the additionalProperties value;</span><span class="s3">\n        </span><span class="s1">schema.properties[key] = additionalProperties;</span><span class="s3">\n        </span><span class="s1">// Set our additional property flag so we know it was dynamically added</span><span class="s3">\n        </span><span class="s1">set(schema.properties, [key, ADDITIONAL_PROPERTY_FLAG], true);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return schema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Internal handler that retrieves an expanded schema that has had all of its conditions, additional properties,</span><span class="s3">\n </span><span class="s1">* references and dependencies resolved and merged into the `schema` given a `validator`, `rootSchema` and `rawFormData`</span><span class="s3">\n </span><span class="s1">* that is used to do the potentially recursive resolution. If `expandAllBranches` is true, then all possible branches</span><span class="s3">\n </span><span class="s1">* of the schema and its references, conditions and dependencies are returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which retrieving a schema is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param [rawFormData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @param [expandAllBranches=false] - Flag, if true, will return all possible branches of conditions, any/oneOf and</span><span class="s3">\n </span><span class="s1">*          dependencies as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param [recurseList=[]] - The optional, list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @returns - The schema(s) resulting from having its conditions, additional properties, references and dependencies</span><span class="s3">\n </span><span class="s1">*          resolved. Multiple schemas may be returned if `expandAllBranches` is true.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function retrieveSchemaInternal(validator, schema, rootSchema, rawFormData, expandAllBranches = false, recurseList = []) {</span><span class="s3">\n    </span><span class="s1">if (!isObject(schema)) {</span><span class="s3">\n        </span><span class="s1">return [{}];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const resolvedSchemas = resolveSchema(validator, schema, rootSchema, expandAllBranches, recurseList, rawFormData);</span><span class="s3">\n    </span><span class="s1">return resolvedSchemas.flatMap((s) =&gt; {</span><span class="s3">\n        </span><span class="s1">let resolvedSchema = s;</span><span class="s3">\n        </span><span class="s1">if (IF_KEY in resolvedSchema) {</span><span class="s3">\n            </span><span class="s1">return resolveCondition(validator, resolvedSchema, rootSchema, expandAllBranches, recurseList, rawFormData);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (ALL_OF_KEY in resolvedSchema) {</span><span class="s3">\n            </span><span class="s1">// resolve allOf schemas</span><span class="s3">\n            </span><span class="s1">if (expandAllBranches) {</span><span class="s3">\n                </span><span class="s1">const { allOf, ...restOfSchema } = resolvedSchema;</span><span class="s3">\n                </span><span class="s1">return [...allOf, restOfSchema];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">resolvedSchema = mergeAllOf(resolvedSchema, {</span><span class="s3">\n                    </span><span class="s1">deep: false,</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">console.warn('could not merge subschemas in allOf:</span><span class="s3">\\</span><span class="s1">n', e);</span><span class="s3">\n                </span><span class="s1">const { allOf, ...resolvedSchemaWithoutAllOf } = resolvedSchema;</span><span class="s3">\n                </span><span class="s1">return resolvedSchemaWithoutAllOf;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const hasAdditionalProperties = ADDITIONAL_PROPERTIES_KEY in resolvedSchema &amp;&amp; resolvedSchema.additionalProperties !== false;</span><span class="s3">\n        </span><span class="s1">if (hasAdditionalProperties) {</span><span class="s3">\n            </span><span class="s1">return stubExistingAdditionalProperties(validator, resolvedSchema, rootSchema, rawFormData);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return resolvedSchema;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves an `anyOf` or `oneOf` within a schema (if present) to the list of schemas returned from</span><span class="s3">\n </span><span class="s1">* `retrieveSchemaInternal()` for the best matching option. If `expandAllBranches` is true, then a list of schemas for ALL</span><span class="s3">\n </span><span class="s1">* options are retrieved and returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which retrieving a schema is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param [rawFormData] - The current formData, if any, to assist retrieving a schema, defaults to an empty object</span><span class="s3">\n </span><span class="s1">* @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveAnyOrOneOfSchemas(validator, schema, rootSchema, expandAllBranches, rawFormData) {</span><span class="s3">\n    </span><span class="s1">let anyOrOneOf;</span><span class="s3">\n    </span><span class="s1">const { oneOf, anyOf, ...remaining } = schema;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(oneOf)) {</span><span class="s3">\n        </span><span class="s1">anyOrOneOf = oneOf;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (Array.isArray(anyOf)) {</span><span class="s3">\n        </span><span class="s1">anyOrOneOf = anyOf;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (anyOrOneOf) {</span><span class="s3">\n        </span><span class="s1">// Ensure that during expand all branches we pass an object rather than undefined so that all options are interrogated</span><span class="s3">\n        </span><span class="s1">const formData = rawFormData === undefined &amp;&amp; expandAllBranches ? {} : rawFormData;</span><span class="s3">\n        </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(schema);</span><span class="s3">\n        </span><span class="s1">anyOrOneOf = anyOrOneOf.map((s) =&gt; {</span><span class="s3">\n            </span><span class="s1">// Due to anyOf/oneOf possibly using the same $ref we always pass a fresh recurse list array so that each option</span><span class="s3">\n            </span><span class="s1">// can resolve recursive references independently</span><span class="s3">\n            </span><span class="s1">return resolveAllReferences(s, rootSchema, []);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Call this to trigger the set of isValid() calls that the schema parser will need</span><span class="s3">\n        </span><span class="s1">const option = getFirstMatchingOption(validator, formData, anyOrOneOf, rootSchema, discriminator);</span><span class="s3">\n        </span><span class="s1">if (expandAllBranches) {</span><span class="s3">\n            </span><span class="s1">return anyOrOneOf.map((item) =&gt; mergeSchemas(remaining, item));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">schema = mergeSchemas(remaining, anyOrOneOf[option]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [schema];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Resolves dependencies within a schema and its 'anyOf/oneOf' children. Passes the `expandAllBranches` flag down to</span><span class="s3">\n </span><span class="s1">* the `resolveAnyOrOneOfSchema()` and `processDependencies()` helper calls.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a dependency is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The list of schemas with their dependencies resolved</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function resolveDependencies(validator, schema, rootSchema, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">// Drop the dependencies from the source schema.</span><span class="s3">\n    </span><span class="s1">const { dependencies, ...remainingSchema } = schema;</span><span class="s3">\n    </span><span class="s1">const resolvedSchemas = resolveAnyOrOneOfSchemas(validator, remainingSchema, rootSchema, expandAllBranches, formData);</span><span class="s3">\n    </span><span class="s1">return resolvedSchemas.flatMap((resolvedSchema) =&gt; processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Processes all the `dependencies` recursively into the list of `resolvedSchema`s as needed. Passes the</span><span class="s3">\n </span><span class="s1">* `expandAllBranches` flag down to the `withDependentSchema()` and the recursive `processDependencies()` helper calls.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param dependencies - The set of dependencies that needs to be processed</span><span class="s3">\n </span><span class="s1">* @param resolvedSchema - The schema for which processing dependencies is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The schema with the `dependencies` resolved into it</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function processDependencies(validator, dependencies, resolvedSchema, rootSchema, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">let schemas = [resolvedSchema];</span><span class="s3">\n    </span><span class="s1">// Process dependencies updating the local schema properties as appropriate.</span><span class="s3">\n    </span><span class="s1">for (const dependencyKey in dependencies) {</span><span class="s3">\n        </span><span class="s1">// Skip this dependency if its trigger property is not present.</span><span class="s3">\n        </span><span class="s1">if (!expandAllBranches &amp;&amp; get(formData, [dependencyKey]) === undefined) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)</span><span class="s3">\n        </span><span class="s1">if (resolvedSchema.properties &amp;&amp; !(dependencyKey in resolvedSchema.properties)) {</span><span class="s3">\n            </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const [remainingDependencies, dependencyValue] = splitKeyElementFromObject(dependencyKey, dependencies);</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(dependencyValue)) {</span><span class="s3">\n            </span><span class="s1">schemas[0] = withDependentProperties(resolvedSchema, dependencyValue);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isObject(dependencyValue)) {</span><span class="s3">\n            </span><span class="s1">schemas = withDependentSchema(validator, resolvedSchema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return schemas.flatMap((schema) =&gt; processDependencies(validator, remainingDependencies, schema, rootSchema, expandAllBranches, recurseList, formData));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return schemas;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Updates a schema with additionally required properties added</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a dependent properties is desired</span><span class="s3">\n </span><span class="s1">* @param [additionallyRequired] - An optional array of additionally required names</span><span class="s3">\n </span><span class="s1">* @returns - The schema with the additional required values merged in</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function withDependentProperties(schema, additionallyRequired) {</span><span class="s3">\n    </span><span class="s1">if (!additionallyRequired) {</span><span class="s3">\n        </span><span class="s1">return schema;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const required = Array.isArray(schema.required)</span><span class="s3">\n        </span><span class="s1">? Array.from(new Set([...schema.required, ...additionallyRequired]))</span><span class="s3">\n        </span><span class="s1">: additionallyRequired;</span><span class="s3">\n    </span><span class="s1">return { ...schema, required: required };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Merges a dependent schema into the `schema` dealing with oneOfs and references. Passes the `expandAllBranches` flag</span><span class="s3">\n </span><span class="s1">* down to the `retrieveSchemaInternal()`, `resolveReference()` and `withExactlyOneSubschema()` helper calls.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a dependent schema is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param dependencyKey - The key name of the dependency</span><span class="s3">\n </span><span class="s1">* @param dependencyValue - The potentially dependent schema</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData]- The current formData to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The list of schemas with the dependent schema resolved into them</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function withDependentSchema(validator, schema, rootSchema, dependencyKey, dependencyValue, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">const dependentSchemas = retrieveSchemaInternal(validator, dependencyValue, rootSchema, formData, expandAllBranches, recurseList);</span><span class="s3">\n    </span><span class="s1">return dependentSchemas.flatMap((dependent) =&gt; {</span><span class="s3">\n        </span><span class="s1">const { oneOf, ...dependentSchema } = dependent;</span><span class="s3">\n        </span><span class="s1">schema = mergeSchemas(schema, dependentSchema);</span><span class="s3">\n        </span><span class="s1">// Since it does not contain oneOf, we return the original schema.</span><span class="s3">\n        </span><span class="s1">if (oneOf === undefined) {</span><span class="s3">\n            </span><span class="s1">return schema;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Resolve $refs inside oneOf.</span><span class="s3">\n        </span><span class="s1">const resolvedOneOfs = oneOf.map((subschema) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (typeof subschema === 'boolean' || !(REF_KEY in subschema)) {</span><span class="s3">\n                </span><span class="s1">return [subschema];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return resolveReference(validator, subschema, rootSchema, expandAllBranches, recurseList, formData);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const allPermutations = getAllPermutationsOfXxxOf(resolvedOneOfs);</span><span class="s3">\n        </span><span class="s1">return allPermutations.flatMap((resolvedOneOf) =&gt; withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, resolvedOneOf, expandAllBranches, recurseList, formData));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Returns a list of `schema`s with the best choice from the `oneOf` options merged into it. If `expandAllBranches` is</span><span class="s3">\n </span><span class="s1">* true, then a list of schemas for ALL options are retrieved and returned. Passes the `expandAllBranches` flag down to</span><span class="s3">\n </span><span class="s1">* the `retrieveSchemaInternal()` helper call.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used to validate oneOf options</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which resolving a oneOf subschema is desired</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param dependencyKey - The key name of the oneOf dependency</span><span class="s3">\n </span><span class="s1">* @param oneOf - The list of schemas representing the oneOf options</span><span class="s3">\n </span><span class="s1">* @param expandAllBranches - Flag, if true, will return all possible branches of conditions, any/oneOf and dependencies</span><span class="s3">\n </span><span class="s1">*          as a list of schemas</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of recursive references already processed</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - Either an array containing the best matching option or all options if `expandAllBranches` is true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function withExactlyOneSubschema(validator, schema, rootSchema, dependencyKey, oneOf, expandAllBranches, recurseList, formData) {</span><span class="s3">\n    </span><span class="s1">const validSubschemas = oneOf.filter((subschema) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (typeof subschema === 'boolean' || !subschema || !subschema.properties) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const { [dependencyKey]: conditionPropertySchema } = subschema.properties;</span><span class="s3">\n        </span><span class="s1">if (conditionPropertySchema) {</span><span class="s3">\n            </span><span class="s1">const conditionSchema = {</span><span class="s3">\n                </span><span class="s1">type: 'object',</span><span class="s3">\n                </span><span class="s1">properties: {</span><span class="s3">\n                    </span><span class="s1">[dependencyKey]: conditionPropertySchema,</span><span class="s3">\n                </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">return validator.isValid(conditionSchema, formData, rootSchema) || expandAllBranches;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!expandAllBranches &amp;&amp; validSubschemas.length !== 1) {</span><span class="s3">\n        </span><span class="s1">console.warn(</span><span class="s3">\&quot;</span><span class="s1">ignoring oneOf in dependencies because there isn't exactly one subschema that is valid</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return [schema];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return validSubschemas.flatMap((s) =&gt; {</span><span class="s3">\n        </span><span class="s1">const subschema = s;</span><span class="s3">\n        </span><span class="s1">const [dependentSubschema] = splitKeyElementFromObject(dependencyKey, subschema.properties);</span><span class="s3">\n        </span><span class="s1">const dependentSchema = { ...subschema, properties: dependentSubschema };</span><span class="s3">\n        </span><span class="s1">const schemas = retrieveSchemaInternal(validator, dependentSchema, rootSchema, formData, expandAllBranches, recurseList);</span><span class="s3">\n        </span><span class="s1">return schemas.map((s) =&gt; mergeSchemas(schema, s));</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=retrieveSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import has from 'lodash/has';</span><span class="s3">\n</span><span class="s1">import isNumber from 'lodash/isNumber';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">import isString from 'lodash/isString';</span><span class="s3">\n</span><span class="s1">import reduce from 'lodash/reduce';</span><span class="s3">\n</span><span class="s1">import times from 'lodash/times';</span><span class="s3">\n</span><span class="s1">import getFirstMatchingOption from './getFirstMatchingOption';</span><span class="s3">\n</span><span class="s1">import retrieveSchema, { resolveAllReferences } from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">import { ONE_OF_KEY, REF_KEY, JUNK_OPTION_ID, ANY_OF_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import guessType from '../guessType';</span><span class="s3">\n</span><span class="s1">import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';</span><span class="s3">\n</span><span class="s1">import getOptionMatchingSimpleDiscriminator from '../getOptionMatchingSimpleDiscriminator';</span><span class="s3">\n</span><span class="s1">/** A junk option used to determine when the getFirstMatchingOption call really matches an option rather than returning</span><span class="s3">\n </span><span class="s1">* the first item</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const JUNK_OPTION = {</span><span class="s3">\n    </span><span class="s1">type: 'object',</span><span class="s3">\n    </span><span class="s1">$id: JUNK_OPTION_ID,</span><span class="s3">\n    </span><span class="s1">properties: {</span><span class="s3">\n        </span><span class="s1">__not_really_there__: {</span><span class="s3">\n            </span><span class="s1">type: 'number',</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/** Recursive function that calculates the score of a `formData` against the given `schema`. The computation is fairly</span><span class="s3">\n </span><span class="s1">* simple. Initially the total score is 0. When `schema.properties` object exists, then all the `key/value` pairs within</span><span class="s3">\n </span><span class="s1">* the object are processed as follows after obtaining the formValue from `formData` using the `key`:</span><span class="s3">\n </span><span class="s1">* - If the `value` contains a `$ref`, `calculateIndexScore()` is called recursively with the formValue and the new</span><span class="s3">\n </span><span class="s1">*   schema that is the result of the ref in the schema being resolved and that sub-schema's resulting score is added to</span><span class="s3">\n </span><span class="s1">*   the total.</span><span class="s3">\n </span><span class="s1">* - If the `value` contains a `oneOf` and there is a formValue, then score based on the index returned from calling</span><span class="s3">\n </span><span class="s1">*   `getClosestMatchingOption()` of that oneOf.</span><span class="s3">\n </span><span class="s1">* - If the type of the `value` is 'object', `calculateIndexScore()` is called recursively with the formValue and the</span><span class="s3">\n </span><span class="s1">*   `value` itself as the sub-schema, and the score is added to the total.</span><span class="s3">\n </span><span class="s1">* - If the type of the `value` matches the guessed-type of the `formValue`, the score is incremented by 1, UNLESS the</span><span class="s3">\n </span><span class="s1">*   value has a `default` or `const`. In those case, if the `default` or `const` and the `formValue` match, the score</span><span class="s3">\n </span><span class="s1">*   is incremented by another 1 otherwise it is decremented by 1.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root JSON schema of the entire form</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the score is being calculated</span><span class="s3">\n </span><span class="s1">* @param formData - The form data associated with the schema, used to calculate the score</span><span class="s3">\n </span><span class="s1">* @returns - The score a schema against the formData</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function calculateIndexScore(validator, rootSchema, schema, formData = {}) {</span><span class="s3">\n    </span><span class="s1">let totalScore = 0;</span><span class="s3">\n    </span><span class="s1">if (schema) {</span><span class="s3">\n        </span><span class="s1">if (isObject(schema.properties)) {</span><span class="s3">\n            </span><span class="s1">totalScore += reduce(schema.properties, (score, value, key) =&gt; {</span><span class="s3">\n                </span><span class="s1">const formValue = get(formData, key);</span><span class="s3">\n                </span><span class="s1">if (typeof value === 'boolean') {</span><span class="s3">\n                    </span><span class="s1">return score;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (has(value, REF_KEY)) {</span><span class="s3">\n                    </span><span class="s1">const newSchema = retrieveSchema(validator, value, rootSchema, formValue);</span><span class="s3">\n                    </span><span class="s1">return score + calculateIndexScore(validator, rootSchema, newSchema, formValue || {});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if ((has(value, ONE_OF_KEY) || has(value, ANY_OF_KEY)) &amp;&amp; formValue) {</span><span class="s3">\n                    </span><span class="s1">const key = has(value, ONE_OF_KEY) ? ONE_OF_KEY : ANY_OF_KEY;</span><span class="s3">\n                    </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(value);</span><span class="s3">\n                    </span><span class="s1">return (score +</span><span class="s3">\n                        </span><span class="s1">getClosestMatchingOption(validator, rootSchema, formValue, get(value, key), -1, discriminator));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (value.type === 'object') {</span><span class="s3">\n                    </span><span class="s1">return score + calculateIndexScore(validator, rootSchema, value, formValue || {});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (value.type === guessType(formValue)) {</span><span class="s3">\n                    </span><span class="s1">// If the types match, then we bump the score by one</span><span class="s3">\n                    </span><span class="s1">let newScore = score + 1;</span><span class="s3">\n                    </span><span class="s1">if (value.default) {</span><span class="s3">\n                        </span><span class="s1">// If the schema contains a readonly default value score the value that matches the default higher and</span><span class="s3">\n                        </span><span class="s1">// any non-matching value lower</span><span class="s3">\n                        </span><span class="s1">newScore += formValue === value.default ? 1 : -1;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (value.const) {</span><span class="s3">\n                        </span><span class="s1">// If the schema contains a const value score the value that matches the default higher and</span><span class="s3">\n                        </span><span class="s1">// any non-matching value lower</span><span class="s3">\n                        </span><span class="s1">newScore += formValue === value.const ? 1 : -1;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">// TODO eventually, deal with enums/arrays</span><span class="s3">\n                    </span><span class="s1">return newScore;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return score;</span><span class="s3">\n            </span><span class="s1">}, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isString(schema.type) &amp;&amp; schema.type === guessType(formData)) {</span><span class="s3">\n            </span><span class="s1">totalScore += 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return totalScore;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Determines which of the given `options` provided most closely matches the `formData`. Using</span><span class="s3">\n </span><span class="s1">* `getFirstMatchingOption()` to match two schemas that differ only by the readOnly, default or const value of a field</span><span class="s3">\n </span><span class="s1">* based on the `formData` and returns 0 when there is no match. Rather than passing in all the `options` at once to</span><span class="s3">\n </span><span class="s1">* this utility, instead an array of valid option indexes is created by iterating over the list of options, call</span><span class="s3">\n </span><span class="s1">* `getFirstMatchingOptions` with a list of one junk option and one good option, seeing if the good option is considered</span><span class="s3">\n </span><span class="s1">* matched.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Once the list of valid indexes is created, if there is only one valid index, just return it. Otherwise, if there are</span><span class="s3">\n </span><span class="s1">* no valid indexes, then fill the valid indexes array with the indexes of all the options. Next, the index of the</span><span class="s3">\n </span><span class="s1">* option with the highest score is determined by iterating over the list of valid options, calling</span><span class="s3">\n </span><span class="s1">* `calculateIndexScore()` on each, comparing it against the current best score, and returning the index of the one that</span><span class="s3">\n </span><span class="s1">* eventually has the best score.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root JSON schema of the entire form</span><span class="s3">\n </span><span class="s1">* @param formData - The form data associated with the schema</span><span class="s3">\n </span><span class="s1">* @param options - The list of options that can be selected from</span><span class="s3">\n </span><span class="s1">* @param [selectedOption=-1] - The index of the currently selected option, defaulted to -1 if not specified</span><span class="s3">\n </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n </span><span class="s1">*          determine which option is selected</span><span class="s3">\n </span><span class="s1">* @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getClosestMatchingOption(validator, rootSchema, formData, options, selectedOption = -1, discriminatorField) {</span><span class="s3">\n    </span><span class="s1">// First resolve any refs in the options</span><span class="s3">\n    </span><span class="s1">const resolvedOptions = options.map((option) =&gt; {</span><span class="s3">\n        </span><span class="s1">return resolveAllReferences(option, rootSchema, []);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">const simpleDiscriminatorMatch = getOptionMatchingSimpleDiscriminator(formData, options, discriminatorField);</span><span class="s3">\n    </span><span class="s1">if (isNumber(simpleDiscriminatorMatch)) {</span><span class="s3">\n        </span><span class="s1">return simpleDiscriminatorMatch;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Reduce the array of options down to a list of the indexes that are considered matching options</span><span class="s3">\n    </span><span class="s1">const allValidIndexes = resolvedOptions.reduce((validList, option, index) =&gt; {</span><span class="s3">\n        </span><span class="s1">const testOptions = [JUNK_OPTION, option];</span><span class="s3">\n        </span><span class="s1">const match = getFirstMatchingOption(validator, formData, testOptions, rootSchema, discriminatorField);</span><span class="s3">\n        </span><span class="s1">// The match is the real option, so add its index to list of valid indexes</span><span class="s3">\n        </span><span class="s1">if (match === 1) {</span><span class="s3">\n            </span><span class="s1">validList.push(index);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return validList;</span><span class="s3">\n    </span><span class="s1">}, []);</span><span class="s3">\n    </span><span class="s1">// There is only one valid index, so return it!</span><span class="s3">\n    </span><span class="s1">if (allValidIndexes.length === 1) {</span><span class="s3">\n        </span><span class="s1">return allValidIndexes[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!allValidIndexes.length) {</span><span class="s3">\n        </span><span class="s1">// No indexes were valid, so we'll score all the options, add all the indexes</span><span class="s3">\n        </span><span class="s1">times(resolvedOptions.length, (i) =&gt; allValidIndexes.push(i));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const scoreCount = new Set();</span><span class="s3">\n    </span><span class="s1">// Score all the options in the list of valid indexes and return the index with the best score</span><span class="s3">\n    </span><span class="s1">const { bestIndex } = allValidIndexes.reduce((scoreData, index) =&gt; {</span><span class="s3">\n        </span><span class="s1">const { bestScore } = scoreData;</span><span class="s3">\n        </span><span class="s1">const option = resolvedOptions[index];</span><span class="s3">\n        </span><span class="s1">const score = calculateIndexScore(validator, rootSchema, option, formData);</span><span class="s3">\n        </span><span class="s1">scoreCount.add(score);</span><span class="s3">\n        </span><span class="s1">if (score &gt; bestScore) {</span><span class="s3">\n            </span><span class="s1">return { bestIndex: index, bestScore: score };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return scoreData;</span><span class="s3">\n    </span><span class="s1">}, { bestIndex: selectedOption, bestScore: 0 });</span><span class="s3">\n    </span><span class="s1">// if all scores are the same go with selectedOption</span><span class="s3">\n    </span><span class="s1">if (scoreCount.size === 1 &amp;&amp; selectedOption &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">return selectedOption;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return bestIndex;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getClosestMatchingOption.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Detects whether the given `schema` contains fixed items. This is the case when `schema.items` is a non-empty array</span><span class="s3">\n </span><span class="s1">* that only contains objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema in which to check for fixed items</span><span class="s3">\n </span><span class="s1">* @returns - True if there are fixed items in the schema, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isFixedItems(schema) {</span><span class="s3">\n    </span><span class="s1">return Array.isArray(schema.items) &amp;&amp; schema.items.length &gt; 0 &amp;&amp; schema.items.every((item) =&gt; isObject(item));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isFixedItems.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Merges the `defaults` object of type `T` into the `formData` of type `T`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* When merging defaults and form data, we want to merge in this specific way:</span><span class="s3">\n </span><span class="s1">* - objects are deeply merged</span><span class="s3">\n </span><span class="s1">* - arrays are merged in such a way that:</span><span class="s3">\n </span><span class="s1">*   - when the array is set in form data, only array entries set in form data</span><span class="s3">\n </span><span class="s1">*     are deeply merged; additional entries from the defaults are ignored unless `mergeExtraArrayDefaults` is true, in</span><span class="s3">\n </span><span class="s1">*     which case the extras are appended onto the end of the form data</span><span class="s3">\n </span><span class="s1">*   - when the array is not set in form data, the default is copied over</span><span class="s3">\n </span><span class="s1">* - scalars are overwritten/set by form data</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param [defaults] - The defaults to merge</span><span class="s3">\n </span><span class="s1">* @param [formData] - The form data into which the defaults will be merged</span><span class="s3">\n </span><span class="s1">* @param [mergeExtraArrayDefaults=false] - If true, any additional default array entries are appended onto the formData</span><span class="s3">\n </span><span class="s1">* @returns - The resulting merged form data with defaults</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function mergeDefaultsWithFormData(defaults, formData, mergeExtraArrayDefaults = false) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(formData)) {</span><span class="s3">\n        </span><span class="s1">const defaultsArray = Array.isArray(defaults) ? defaults : [];</span><span class="s3">\n        </span><span class="s1">const mapped = formData.map((value, idx) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (defaultsArray[idx]) {</span><span class="s3">\n                </span><span class="s1">return mergeDefaultsWithFormData(defaultsArray[idx], value, mergeExtraArrayDefaults);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return value;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// Merge any extra defaults when mergeExtraArrayDefaults is true</span><span class="s3">\n        </span><span class="s1">if (mergeExtraArrayDefaults &amp;&amp; mapped.length &lt; defaultsArray.length) {</span><span class="s3">\n            </span><span class="s1">mapped.push(...defaultsArray.slice(mapped.length));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return mapped;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isObject(formData)) {</span><span class="s3">\n        </span><span class="s1">const acc = Object.assign({}, defaults); // Prevent mutation of source object.</span><span class="s3">\n        </span><span class="s1">return Object.keys(formData).reduce((acc, key) =&gt; {</span><span class="s3">\n            </span><span class="s1">acc[key] = mergeDefaultsWithFormData(defaults ? get(defaults, key) : {}, get(formData, key), mergeExtraArrayDefaults);</span><span class="s3">\n            </span><span class="s1">return acc;</span><span class="s3">\n        </span><span class="s1">}, acc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return formData;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=mergeDefaultsWithFormData.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">/** Recursively merge deeply nested objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param obj1 - The first object to merge</span><span class="s3">\n </span><span class="s1">* @param obj2 - The second object to merge</span><span class="s3">\n </span><span class="s1">* @param [concatArrays=false] - Optional flag that, when true, will cause arrays to be concatenated. Use</span><span class="s3">\n </span><span class="s1">*          </span><span class="s3">\&quot;</span><span class="s1">preventDuplicates</span><span class="s3">\&quot; </span><span class="s1">to merge arrays in a manner that prevents any duplicate entries from being merged.</span><span class="s3">\n </span><span class="s1">*          NOTE: Uses shallow comparison for the duplicate checking.</span><span class="s3">\n </span><span class="s1">* @returns - A new object that is the merge of the two given objects</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function mergeObjects(obj1, obj2, concatArrays = false) {</span><span class="s3">\n    </span><span class="s1">return Object.keys(obj2).reduce((acc, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">const left = obj1 ? obj1[key] : {}, right = obj2[key];</span><span class="s3">\n        </span><span class="s1">if (obj1 &amp;&amp; key in obj1 &amp;&amp; isObject(right)) {</span><span class="s3">\n            </span><span class="s1">acc[key] = mergeObjects(left, right, concatArrays);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (concatArrays &amp;&amp; Array.isArray(left) &amp;&amp; Array.isArray(right)) {</span><span class="s3">\n            </span><span class="s1">let toMerge = right;</span><span class="s3">\n            </span><span class="s1">if (concatArrays === 'preventDuplicates') {</span><span class="s3">\n                </span><span class="s1">toMerge = right.reduce((result, value) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (!left.includes(value)) {</span><span class="s3">\n                        </span><span class="s1">result.push(value);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return result;</span><span class="s3">\n                </span><span class="s1">}, []);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">acc[key] = left.concat(toMerge);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">acc[key] = right;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return acc;</span><span class="s3">\n    </span><span class="s1">}, Object.assign({}, obj1)); // Prevent mutation of source object.</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=mergeObjects.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { CONST_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** This function checks if the given `schema` matches a single constant value. This happens when either the schema has</span><span class="s3">\n </span><span class="s1">* an `enum` array with a single value or there is a `const` defined.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for a field</span><span class="s3">\n </span><span class="s1">* @returns - True if the `schema` has a single constant value, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isConstant(schema) {</span><span class="s3">\n    </span><span class="s1">return (Array.isArray(schema.enum) &amp;&amp; schema.enum.length === 1) || CONST_KEY in schema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isConstant.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isConstant from '../isConstant';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">/** Checks to see if the `schema` combination represents a select</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param theSchema - The schema for which check for a select flag is desired</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @returns - True if schema contains a select, otherwise false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isSelect(validator, theSchema, rootSchema = {}) {</span><span class="s3">\n    </span><span class="s1">const schema = retrieveSchema(validator, theSchema, rootSchema, undefined);</span><span class="s3">\n    </span><span class="s1">const altSchemas = schema.oneOf || schema.anyOf;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(schema.enum)) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(altSchemas)) {</span><span class="s3">\n        </span><span class="s1">return altSchemas.every((altSchemas) =&gt; typeof altSchemas !== 'boolean' &amp;&amp; isConstant(altSchemas));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isSelect.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isSelect from './isSelect';</span><span class="s3">\n</span><span class="s1">/** Checks to see if the `schema` combination represents a multi-select</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which check for a multi-select flag is desired</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @returns - True if schema contains a multi-select, otherwise false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isMultiSelect(validator, schema, rootSchema) {</span><span class="s3">\n    </span><span class="s1">if (!schema.uniqueItems || !schema.items || typeof schema.items === 'boolean') {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isSelect(validator, schema.items, rootSchema);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isMultiSelect.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEmpty from 'lodash/isEmpty';</span><span class="s3">\n</span><span class="s1">import { ANY_OF_KEY, DEFAULT_KEY, DEPENDENCIES_KEY, PROPERTIES_KEY, ONE_OF_KEY, REF_KEY, ALL_OF_KEY, } from '../constants';</span><span class="s3">\n</span><span class="s1">import findSchemaDefinition from '../findSchemaDefinition';</span><span class="s3">\n</span><span class="s1">import getClosestMatchingOption from './getClosestMatchingOption';</span><span class="s3">\n</span><span class="s1">import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';</span><span class="s3">\n</span><span class="s1">import getSchemaType from '../getSchemaType';</span><span class="s3">\n</span><span class="s1">import isObject from '../isObject';</span><span class="s3">\n</span><span class="s1">import isFixedItems from '../isFixedItems';</span><span class="s3">\n</span><span class="s1">import mergeDefaultsWithFormData from '../mergeDefaultsWithFormData';</span><span class="s3">\n</span><span class="s1">import mergeObjects from '../mergeObjects';</span><span class="s3">\n</span><span class="s1">import mergeSchemas from '../mergeSchemas';</span><span class="s3">\n</span><span class="s1">import isMultiSelect from './isMultiSelect';</span><span class="s3">\n</span><span class="s1">import retrieveSchema, { resolveDependencies } from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">/** Enum that indicates how `schema.additionalItems` should be handled by the `getInnerSchemaForArrayItem()` function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var AdditionalItemsHandling;</span><span class="s3">\n</span><span class="s1">(function (AdditionalItemsHandling) {</span><span class="s3">\n    </span><span class="s1">AdditionalItemsHandling[AdditionalItemsHandling[</span><span class="s3">\&quot;</span><span class="s1">Ignore</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Ignore</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">AdditionalItemsHandling[AdditionalItemsHandling[</span><span class="s3">\&quot;</span><span class="s1">Invert</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Invert</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">AdditionalItemsHandling[AdditionalItemsHandling[</span><span class="s3">\&quot;</span><span class="s1">Fallback</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">Fallback</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(AdditionalItemsHandling || (AdditionalItemsHandling = {}));</span><span class="s3">\n</span><span class="s1">/** Given a `schema` will return an inner schema that for an array item. This is computed differently based on the</span><span class="s3">\n </span><span class="s1">* `additionalItems` enum and the value of `idx`. There are four possible returns:</span><span class="s3">\n </span><span class="s1">* 1. If `idx` is &gt;= 0, then if `schema.items` is an array the `idx`th element of the array is returned if it is a valid</span><span class="s3">\n </span><span class="s1">*    index and not a boolean, otherwise it falls through to 3.</span><span class="s3">\n </span><span class="s1">* 2. If `schema.items` is not an array AND truthy and not a boolean, then `schema.items` is returned since it actually</span><span class="s3">\n </span><span class="s1">*    is a schema, otherwise it falls through to 3.</span><span class="s3">\n </span><span class="s1">* 3. If `additionalItems` is not `AdditionalItemsHandling.Ignore` and `schema.additionalItems` is an object, then</span><span class="s3">\n </span><span class="s1">*    `schema.additionalItems` is returned since it actually is a schema, otherwise it falls through to 4.</span><span class="s3">\n </span><span class="s1">* 4. {} is returned representing an empty schema</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which to get the particular item</span><span class="s3">\n </span><span class="s1">* @param [additionalItems=AdditionalItemsHandling.Ignore] - How do we want to handle additional items?</span><span class="s3">\n </span><span class="s1">* @param [idx=-1] - Index, if non-negative, will be used to return the idx-th element in a `schema.items` array</span><span class="s3">\n </span><span class="s1">* @returns - The best fit schema object from the `schema` given the `additionalItems` and `idx` modifiers</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function getInnerSchemaForArrayItem(schema, additionalItems = AdditionalItemsHandling.Ignore, idx = -1) {</span><span class="s3">\n    </span><span class="s1">if (idx &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(schema.items) &amp;&amp; idx &lt; schema.items.length) {</span><span class="s3">\n            </span><span class="s1">const item = schema.items[idx];</span><span class="s3">\n            </span><span class="s1">if (typeof item !== 'boolean') {</span><span class="s3">\n                </span><span class="s1">return item;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (schema.items &amp;&amp; !Array.isArray(schema.items) &amp;&amp; typeof schema.items !== 'boolean') {</span><span class="s3">\n        </span><span class="s1">return schema.items;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (additionalItems !== AdditionalItemsHandling.Ignore &amp;&amp; isObject(schema.additionalItems)) {</span><span class="s3">\n        </span><span class="s1">return schema.additionalItems;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Either add `computedDefault` at `key` into `obj` or not add it based on its value, the value of</span><span class="s3">\n </span><span class="s1">* `includeUndefinedValues`, the value of `emptyObjectFields` and if its parent field is required. Generally undefined</span><span class="s3">\n </span><span class="s1">* `computedDefault` values are added only when `includeUndefinedValues` is either true/</span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;</span><span class="s1">. If `</span><span class="s3">\n </span><span class="s1">* includeUndefinedValues` is false and `emptyObjectFields` is not </span><span class="s3">\&quot;</span><span class="s1">skipDefaults</span><span class="s3">\&quot;</span><span class="s1">, then non-undefined and non-empty-object</span><span class="s3">\n </span><span class="s1">* values will be added based on certain conditions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param obj - The object into which the computed default may be added</span><span class="s3">\n </span><span class="s1">* @param key - The key into the object at which the computed default may be added</span><span class="s3">\n </span><span class="s1">* @param computedDefault - The computed default value that maybe should be added to the obj</span><span class="s3">\n </span><span class="s1">* @param includeUndefinedValues - Optional flag, if true, cause undefined values to be added as defaults.</span><span class="s3">\n </span><span class="s1">*          If </span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;</span><span class="s1">, cause undefined values for this object and pass `includeUndefinedValues` as</span><span class="s3">\n </span><span class="s1">*          false when computing defaults for any nested object properties. If </span><span class="s3">\&quot;</span><span class="s1">allowEmptyObject</span><span class="s3">\&quot;</span><span class="s1">, prevents undefined</span><span class="s3">\n </span><span class="s1">*          values in this object while allow the object itself to be empty and passing `includeUndefinedValues` as</span><span class="s3">\n </span><span class="s1">*          false when computing defaults for any nested object properties.</span><span class="s3">\n </span><span class="s1">* @param isParentRequired - The optional boolean that indicates whether the parent field is required</span><span class="s3">\n </span><span class="s1">* @param requiredFields - The list of fields that are required</span><span class="s3">\n </span><span class="s1">* @param experimental_defaultFormStateBehavior - Optional configuration object, if provided, allows users to override</span><span class="s3">\n </span><span class="s1">*        default form state behavior</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function maybeAddDefaultToObject(obj, key, computedDefault, includeUndefinedValues, isParentRequired, requiredFields = [], experimental_defaultFormStateBehavior = {}) {</span><span class="s3">\n    </span><span class="s1">const { emptyObjectFields = 'populateAllDefaults' } = experimental_defaultFormStateBehavior;</span><span class="s3">\n    </span><span class="s1">if (includeUndefinedValues) {</span><span class="s3">\n        </span><span class="s1">obj[key] = computedDefault;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (emptyObjectFields !== 'skipDefaults') {</span><span class="s3">\n        </span><span class="s1">if (isObject(computedDefault)) {</span><span class="s3">\n            </span><span class="s1">// If isParentRequired is undefined, then we are at the root level of the schema so defer to the requiredness of</span><span class="s3">\n            </span><span class="s1">// the field key itself in the `requiredField` list</span><span class="s3">\n            </span><span class="s1">const isSelfOrParentRequired = isParentRequired === undefined ? requiredFields.includes(key) : isParentRequired;</span><span class="s3">\n            </span><span class="s1">// Store computedDefault if it's a non-empty object(e.g. not {}) and satisfies certain conditions</span><span class="s3">\n            </span><span class="s1">// Condition 1: If computedDefault is not empty or if the key is a required field</span><span class="s3">\n            </span><span class="s1">// Condition 2: If the parent object is required or emptyObjectFields is not 'populateRequiredDefaults'</span><span class="s3">\n            </span><span class="s1">if ((!isEmpty(computedDefault) || requiredFields.includes(key)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(isSelfOrParentRequired || emptyObjectFields !== 'populateRequiredDefaults')) {</span><span class="s3">\n                </span><span class="s1">obj[key] = computedDefault;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (</span><span class="s3">\n        </span><span class="s1">// Store computedDefault if it's a defined primitive (e.g., true) and satisfies certain conditions</span><span class="s3">\n        </span><span class="s1">// Condition 1: computedDefault is not undefined</span><span class="s3">\n        </span><span class="s1">// Condition 2: If emptyObjectFields is 'populateAllDefaults' or if the key is a required field</span><span class="s3">\n        </span><span class="s1">computedDefault !== undefined &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(emptyObjectFields === 'populateAllDefaults' || requiredFields.includes(key))) {</span><span class="s3">\n            </span><span class="s1">obj[key] = computedDefault;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Computes the defaults for the current `schema` given the `rawFormData` and `parentDefaults` if any. This drills into</span><span class="s3">\n </span><span class="s1">* each level of the schema, recursively, to fill out every level of defaults provided by the schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - an implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param rawSchema - The schema for which the default state is desired</span><span class="s3">\n </span><span class="s1">* @param [props] - Optional props for this function</span><span class="s3">\n </span><span class="s1">* @param [props.parentDefaults] - Any defaults provided by the parent field in the schema</span><span class="s3">\n </span><span class="s1">* @param [props.rootSchema] - The options root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [props.rawFormData] - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n </span><span class="s1">* @param [props.includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.</span><span class="s3">\n </span><span class="s1">*          If </span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;</span><span class="s1">, cause undefined values for this object and pass `includeUndefinedValues` as</span><span class="s3">\n </span><span class="s1">*          false when computing defaults for any nested object properties.</span><span class="s3">\n </span><span class="s1">* @param [props._recurseList=[]] - The list of ref names currently being recursed, used to prevent infinite recursion</span><span class="s3">\n </span><span class="s1">* @param [props.experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior</span><span class="s3">\n </span><span class="s1">* @param [props.required] - Optional flag, if true, indicates this schema was required in the parent schema.</span><span class="s3">\n </span><span class="s1">* @returns - The resulting `formData` with all the defaults provided</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function computeDefaults(validator, rawSchema, { parentDefaults, rawFormData, rootSchema = {}, includeUndefinedValues = false, _recurseList = [], experimental_defaultFormStateBehavior = undefined, required, } = {}) {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">const formData = (isObject(rawFormData) ? rawFormData : {});</span><span class="s3">\n    </span><span class="s1">const schema = isObject(rawSchema) ? rawSchema : {};</span><span class="s3">\n    </span><span class="s1">// Compute the defaults recursively: give highest priority to deepest nodes.</span><span class="s3">\n    </span><span class="s1">let defaults = parentDefaults;</span><span class="s3">\n    </span><span class="s1">// If we get a new schema, then we need to recompute defaults again for the new schema found.</span><span class="s3">\n    </span><span class="s1">let schemaToCompute = null;</span><span class="s3">\n    </span><span class="s1">let updatedRecurseList = _recurseList;</span><span class="s3">\n    </span><span class="s1">if (isObject(defaults) &amp;&amp; isObject(schema.default)) {</span><span class="s3">\n        </span><span class="s1">// For object defaults, only override parent defaults that are defined in</span><span class="s3">\n        </span><span class="s1">// schema.default.</span><span class="s3">\n        </span><span class="s1">defaults = mergeObjects(defaults, schema.default);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (DEFAULT_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">defaults = schema.default;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (REF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const refName = schema[REF_KEY];</span><span class="s3">\n        </span><span class="s1">// Use referenced schema defaults for this node.</span><span class="s3">\n        </span><span class="s1">if (!_recurseList.includes(refName)) {</span><span class="s3">\n            </span><span class="s1">updatedRecurseList = _recurseList.concat(refName);</span><span class="s3">\n            </span><span class="s1">schemaToCompute = findSchemaDefinition(refName, rootSchema);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (DEPENDENCIES_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const resolvedSchema = resolveDependencies(validator, schema, rootSchema, false, [], formData);</span><span class="s3">\n        </span><span class="s1">schemaToCompute = resolvedSchema[0]; // pick the first element from resolve dependencies</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isFixedItems(schema)) {</span><span class="s3">\n        </span><span class="s1">defaults = schema.items.map((itemSchema, idx) =&gt; computeDefaults(validator, itemSchema, {</span><span class="s3">\n            </span><span class="s1">rootSchema,</span><span class="s3">\n            </span><span class="s1">includeUndefinedValues,</span><span class="s3">\n            </span><span class="s1">_recurseList,</span><span class="s3">\n            </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n            </span><span class="s1">parentDefaults: Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined,</span><span class="s3">\n            </span><span class="s1">rawFormData: formData,</span><span class="s3">\n            </span><span class="s1">required,</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ONE_OF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const { oneOf, ...remaining } = schema;</span><span class="s3">\n        </span><span class="s1">if (oneOf.length === 0) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(schema);</span><span class="s3">\n        </span><span class="s1">schemaToCompute = oneOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, oneOf, 0, discriminator)];</span><span class="s3">\n        </span><span class="s1">schemaToCompute = mergeSchemas(remaining, schemaToCompute);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (ANY_OF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const { anyOf, ...remaining } = schema;</span><span class="s3">\n        </span><span class="s1">if (anyOf.length === 0) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(schema);</span><span class="s3">\n        </span><span class="s1">schemaToCompute = anyOf[getClosestMatchingOption(validator, rootSchema, isEmpty(formData) ? undefined : formData, anyOf, 0, discriminator)];</span><span class="s3">\n        </span><span class="s1">schemaToCompute = mergeSchemas(remaining, schemaToCompute);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schemaToCompute) {</span><span class="s3">\n        </span><span class="s1">return computeDefaults(validator, schemaToCompute, {</span><span class="s3">\n            </span><span class="s1">rootSchema,</span><span class="s3">\n            </span><span class="s1">includeUndefinedValues,</span><span class="s3">\n            </span><span class="s1">_recurseList: updatedRecurseList,</span><span class="s3">\n            </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n            </span><span class="s1">parentDefaults: defaults,</span><span class="s3">\n            </span><span class="s1">rawFormData: formData,</span><span class="s3">\n            </span><span class="s1">required,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// No defaults defined for this node, fallback to generic typed ones.</span><span class="s3">\n    </span><span class="s1">if (defaults === undefined) {</span><span class="s3">\n        </span><span class="s1">defaults = schema.default;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">switch (getSchemaType(schema)) {</span><span class="s3">\n        </span><span class="s1">// We need to recurse for object schema inner default values.</span><span class="s3">\n        </span><span class="s1">case 'object': {</span><span class="s3">\n            </span><span class="s1">// This is a custom addition that fixes this issue:</span><span class="s3">\n            </span><span class="s1">// https://github.com/rjsf-team/react-jsonschema-form/issues/3832</span><span class="s3">\n            </span><span class="s1">const retrievedSchema = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.allOf) === 'populateDefaults' &amp;&amp; ALL_OF_KEY in schema</span><span class="s3">\n                </span><span class="s1">? retrieveSchema(validator, schema, rootSchema, formData)</span><span class="s3">\n                </span><span class="s1">: schema;</span><span class="s3">\n            </span><span class="s1">const objectDefaults = Object.keys(retrievedSchema.properties || {}).reduce((acc, key) =&gt; {</span><span class="s3">\n                </span><span class="s1">var _a;</span><span class="s3">\n                </span><span class="s1">// Compute the defaults for this node, with the parent defaults we might</span><span class="s3">\n                </span><span class="s1">// have from a previous run: defaults[key].</span><span class="s3">\n                </span><span class="s1">const computedDefault = computeDefaults(validator, get(retrievedSchema, [PROPERTIES_KEY, key]), {</span><span class="s3">\n                    </span><span class="s1">rootSchema,</span><span class="s3">\n                    </span><span class="s1">_recurseList,</span><span class="s3">\n                    </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n                    </span><span class="s1">includeUndefinedValues: includeUndefinedValues === true,</span><span class="s3">\n                    </span><span class="s1">parentDefaults: get(defaults, [key]),</span><span class="s3">\n                    </span><span class="s1">rawFormData: get(formData, [key]),</span><span class="s3">\n                    </span><span class="s1">required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key),</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">maybeAddDefaultToObject(acc, key, computedDefault, includeUndefinedValues, required, retrievedSchema.required, experimental_defaultFormStateBehavior);</span><span class="s3">\n                </span><span class="s1">return acc;</span><span class="s3">\n            </span><span class="s1">}, {});</span><span class="s3">\n            </span><span class="s1">if (retrievedSchema.additionalProperties) {</span><span class="s3">\n                </span><span class="s1">// as per spec additionalProperties may be either schema or boolean</span><span class="s3">\n                </span><span class="s1">const additionalPropertiesSchema = isObject(retrievedSchema.additionalProperties)</span><span class="s3">\n                    </span><span class="s1">? retrievedSchema.additionalProperties</span><span class="s3">\n                    </span><span class="s1">: {};</span><span class="s3">\n                </span><span class="s1">const keys = new Set();</span><span class="s3">\n                </span><span class="s1">if (isObject(defaults)) {</span><span class="s3">\n                    </span><span class="s1">Object.keys(defaults)</span><span class="s3">\n                        </span><span class="s1">.filter((key) =&gt; !retrievedSchema.properties || !retrievedSchema.properties[key])</span><span class="s3">\n                        </span><span class="s1">.forEach((key) =&gt; keys.add(key));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const formDataRequired = [];</span><span class="s3">\n                </span><span class="s1">Object.keys(formData)</span><span class="s3">\n                    </span><span class="s1">.filter((key) =&gt; !retrievedSchema.properties || !retrievedSchema.properties[key])</span><span class="s3">\n                    </span><span class="s1">.forEach((key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">keys.add(key);</span><span class="s3">\n                    </span><span class="s1">formDataRequired.push(key);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">keys.forEach((key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">var _a;</span><span class="s3">\n                    </span><span class="s1">const computedDefault = computeDefaults(validator, additionalPropertiesSchema, {</span><span class="s3">\n                        </span><span class="s1">rootSchema,</span><span class="s3">\n                        </span><span class="s1">_recurseList,</span><span class="s3">\n                        </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n                        </span><span class="s1">includeUndefinedValues: includeUndefinedValues === true,</span><span class="s3">\n                        </span><span class="s1">parentDefaults: get(defaults, [key]),</span><span class="s3">\n                        </span><span class="s1">rawFormData: get(formData, [key]),</span><span class="s3">\n                        </span><span class="s1">required: (_a = retrievedSchema.required) === null || _a === void 0 ? void 0 : _a.includes(key),</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">// Since these are additional properties we don't need to add the `experimental_defaultFormStateBehavior` prop</span><span class="s3">\n                    </span><span class="s1">maybeAddDefaultToObject(objectDefaults, key, computedDefault, includeUndefinedValues, required, formDataRequired);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return objectDefaults;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'array': {</span><span class="s3">\n            </span><span class="s1">const neverPopulate = ((_a = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _a === void 0 ? void 0 : _a.populate) === 'never';</span><span class="s3">\n            </span><span class="s1">const ignoreMinItemsFlagSet = ((_b = experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) === null || _b === void 0 ? void 0 : _b.populate) === 'requiredOnly';</span><span class="s3">\n            </span><span class="s1">// Inject defaults into existing array defaults</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(defaults)) {</span><span class="s3">\n                </span><span class="s1">defaults = defaults.map((item, idx) =&gt; {</span><span class="s3">\n                    </span><span class="s1">const schemaItem = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Fallback, idx);</span><span class="s3">\n                    </span><span class="s1">return computeDefaults(validator, schemaItem, {</span><span class="s3">\n                        </span><span class="s1">rootSchema,</span><span class="s3">\n                        </span><span class="s1">_recurseList,</span><span class="s3">\n                        </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n                        </span><span class="s1">parentDefaults: item,</span><span class="s3">\n                        </span><span class="s1">required,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Deeply inject defaults into already existing form data</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(rawFormData)) {</span><span class="s3">\n                </span><span class="s1">const schemaItem = getInnerSchemaForArrayItem(schema);</span><span class="s3">\n                </span><span class="s1">if (neverPopulate) {</span><span class="s3">\n                    </span><span class="s1">defaults = rawFormData;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">defaults = rawFormData.map((item, idx) =&gt; {</span><span class="s3">\n                        </span><span class="s1">return computeDefaults(validator, schemaItem, {</span><span class="s3">\n                            </span><span class="s1">rootSchema,</span><span class="s3">\n                            </span><span class="s1">_recurseList,</span><span class="s3">\n                            </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n                            </span><span class="s1">rawFormData: item,</span><span class="s3">\n                            </span><span class="s1">parentDefaults: get(defaults, [idx]),</span><span class="s3">\n                            </span><span class="s1">required,</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (neverPopulate) {</span><span class="s3">\n                </span><span class="s1">return defaults !== null &amp;&amp; defaults !== void 0 ? defaults : [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (ignoreMinItemsFlagSet &amp;&amp; !required) {</span><span class="s3">\n                </span><span class="s1">// If no form data exists or defaults are set leave the field empty/non-existent, otherwise</span><span class="s3">\n                </span><span class="s1">// return form data/defaults</span><span class="s3">\n                </span><span class="s1">return defaults ? defaults : undefined;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const defaultsLength = Array.isArray(defaults) ? defaults.length : 0;</span><span class="s3">\n            </span><span class="s1">if (!schema.minItems ||</span><span class="s3">\n                </span><span class="s1">isMultiSelect(validator, schema, rootSchema) ||</span><span class="s3">\n                </span><span class="s1">schema.minItems &lt;= defaultsLength) {</span><span class="s3">\n                </span><span class="s1">return defaults ? defaults : [];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const defaultEntries = (defaults || []);</span><span class="s3">\n            </span><span class="s1">const fillerSchema = getInnerSchemaForArrayItem(schema, AdditionalItemsHandling.Invert);</span><span class="s3">\n            </span><span class="s1">const fillerDefault = fillerSchema.default;</span><span class="s3">\n            </span><span class="s1">// Calculate filler entries for remaining items (minItems - existing raw data/defaults)</span><span class="s3">\n            </span><span class="s1">const fillerEntries = new Array(schema.minItems - defaultsLength).fill(computeDefaults(validator, fillerSchema, {</span><span class="s3">\n                </span><span class="s1">parentDefaults: fillerDefault,</span><span class="s3">\n                </span><span class="s1">rootSchema,</span><span class="s3">\n                </span><span class="s1">_recurseList,</span><span class="s3">\n                </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n                </span><span class="s1">required,</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">// then fill up the rest with either the item default or empty, up to minItems</span><span class="s3">\n            </span><span class="s1">return defaultEntries.concat(fillerEntries);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return defaults;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have</span><span class="s3">\n </span><span class="s1">* computed to have defaults provided in the `schema`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param theSchema - The schema for which the default state is desired</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.</span><span class="s3">\n </span><span class="s1">*          If </span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;</span><span class="s1">, cause undefined values for this object and pass `includeUndefinedValues` as</span><span class="s3">\n </span><span class="s1">*          false when computing defaults for any nested object properties.</span><span class="s3">\n </span><span class="s1">* @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior</span><span class="s3">\n </span><span class="s1">* @returns - The resulting `formData` with all the defaults provided</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getDefaultFormState(validator, theSchema, formData, rootSchema, includeUndefinedValues = false, experimental_defaultFormStateBehavior) {</span><span class="s3">\n    </span><span class="s1">if (!isObject(theSchema)) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invalid schema: ' + theSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const schema = retrieveSchema(validator, theSchema, rootSchema, formData);</span><span class="s3">\n    </span><span class="s1">const defaults = computeDefaults(validator, schema, {</span><span class="s3">\n        </span><span class="s1">rootSchema,</span><span class="s3">\n        </span><span class="s1">includeUndefinedValues,</span><span class="s3">\n        </span><span class="s1">experimental_defaultFormStateBehavior,</span><span class="s3">\n        </span><span class="s1">rawFormData: formData,</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (formData === undefined || formData === null || (typeof formData === 'number' &amp;&amp; isNaN(formData))) {</span><span class="s3">\n        </span><span class="s1">// No form data? Use schema defaults.</span><span class="s3">\n        </span><span class="s1">return defaults;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { mergeExtraDefaults } = (experimental_defaultFormStateBehavior === null || experimental_defaultFormStateBehavior === void 0 ? void 0 : experimental_defaultFormStateBehavior.arrayMinItems) || {};</span><span class="s3">\n    </span><span class="s1">if (isObject(formData)) {</span><span class="s3">\n        </span><span class="s1">return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(formData)) {</span><span class="s3">\n        </span><span class="s1">return mergeDefaultsWithFormData(defaults, formData, mergeExtraDefaults);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return formData;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getDefaultFormState.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import getUiOptions from './getUiOptions';</span><span class="s3">\n</span><span class="s1">/** Checks to see if the `uiSchema` contains the `widget` field and that the widget is not `hidden`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param uiSchema - The UI Schema from which to detect if it is customized</span><span class="s3">\n </span><span class="s1">* @returns - True if the `uiSchema` describes a custom widget, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isCustomWidget(uiSchema = {}) {</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">// TODO: Remove the `&amp;&amp; uiSchema['ui:widget'] !== 'hidden'` once we support hidden widgets for arrays.</span><span class="s3">\n    </span><span class="s1">// https://rjsf-team.github.io/react-jsonschema-form/docs/usage/widgets/#hidden-widgets</span><span class="s3">\n    </span><span class="s1">'widget' in getUiOptions(uiSchema) &amp;&amp; getUiOptions(uiSchema)['widget'] !== 'hidden');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isCustomWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { UI_WIDGET_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">/** Checks to see if the `schema` and `uiSchema` combination represents an array of files</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which check for array of files flag is desired</span><span class="s3">\n </span><span class="s1">* @param [uiSchema={}] - The UI schema from which to check the widget</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @returns - True if schema/uiSchema contains an array of files, otherwise false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function isFilesArray(validator, schema, uiSchema = {}, rootSchema) {</span><span class="s3">\n    </span><span class="s1">if (uiSchema[UI_WIDGET_KEY] === 'files') {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schema.items) {</span><span class="s3">\n        </span><span class="s1">const itemsSchema = retrieveSchema(validator, schema.items, rootSchema);</span><span class="s3">\n        </span><span class="s1">return itemsSchema.type === 'string' &amp;&amp; itemsSchema.format === 'data-url';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=isFilesArray.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { UI_FIELD_KEY, UI_WIDGET_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import getSchemaType from '../getSchemaType';</span><span class="s3">\n</span><span class="s1">import getUiOptions from '../getUiOptions';</span><span class="s3">\n</span><span class="s1">import isCustomWidget from '../isCustomWidget';</span><span class="s3">\n</span><span class="s1">import isFilesArray from './isFilesArray';</span><span class="s3">\n</span><span class="s1">import isMultiSelect from './isMultiSelect';</span><span class="s3">\n</span><span class="s1">/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`</span><span class="s3">\n </span><span class="s1">* should be displayed in a UI.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the display label flag is desired</span><span class="s3">\n </span><span class="s1">* @param [uiSchema={}] - The UI schema from which to derive potentially displayable information</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options</span><span class="s3">\n </span><span class="s1">* @returns - True if the label should be displayed or false if it should not</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getDisplayLabel(validator, schema, uiSchema = {}, rootSchema, globalOptions) {</span><span class="s3">\n    </span><span class="s1">const uiOptions = getUiOptions(uiSchema, globalOptions);</span><span class="s3">\n    </span><span class="s1">const { label = true } = uiOptions;</span><span class="s3">\n    </span><span class="s1">let displayLabel = !!label;</span><span class="s3">\n    </span><span class="s1">const schemaType = getSchemaType(schema);</span><span class="s3">\n    </span><span class="s1">if (schemaType === 'array') {</span><span class="s3">\n        </span><span class="s1">displayLabel =</span><span class="s3">\n            </span><span class="s1">isMultiSelect(validator, schema, rootSchema) ||</span><span class="s3">\n                </span><span class="s1">isFilesArray(validator, schema, uiSchema, rootSchema) ||</span><span class="s3">\n                </span><span class="s1">isCustomWidget(uiSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schemaType === 'object') {</span><span class="s3">\n        </span><span class="s1">displayLabel = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schemaType === 'boolean' &amp;&amp; !uiSchema[UI_WIDGET_KEY]) {</span><span class="s3">\n        </span><span class="s1">displayLabel = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (uiSchema[UI_FIELD_KEY]) {</span><span class="s3">\n        </span><span class="s1">displayLabel = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return displayLabel;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getDisplayLabel.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isEmpty from 'lodash/isEmpty';</span><span class="s3">\n</span><span class="s1">import mergeObjects from '../mergeObjects';</span><span class="s3">\n</span><span class="s1">/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the</span><span class="s3">\n </span><span class="s1">* two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling</span><span class="s3">\n </span><span class="s1">* `validator.toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then</span><span class="s3">\n </span><span class="s1">* `validationData` is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - The validator used to convert an ErrorSchema to a list of errors</span><span class="s3">\n </span><span class="s1">* @param validationData - The current `ValidationData` into which to merge the additional errors</span><span class="s3">\n </span><span class="s1">* @param [additionalErrorSchema] - The additional set of errors in an `ErrorSchema`</span><span class="s3">\n </span><span class="s1">* @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.</span><span class="s3">\n </span><span class="s1">* @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be</span><span class="s3">\n </span><span class="s1">*        removed in the next major release.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function mergeValidationData(validator, validationData, additionalErrorSchema) {</span><span class="s3">\n    </span><span class="s1">if (!additionalErrorSchema) {</span><span class="s3">\n        </span><span class="s1">return validationData;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;</span><span class="s3">\n    </span><span class="s1">let errors = validator.toErrorList(additionalErrorSchema);</span><span class="s3">\n    </span><span class="s1">let errorSchema = additionalErrorSchema;</span><span class="s3">\n    </span><span class="s1">if (!isEmpty(oldErrorSchema)) {</span><span class="s3">\n        </span><span class="s1">errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true);</span><span class="s3">\n        </span><span class="s1">errors = [...oldErrors].concat(errors);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { errorSchema, errors };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=mergeValidationData.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import has from 'lodash/has';</span><span class="s3">\n</span><span class="s1">import { PROPERTIES_KEY, REF_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">const NO_VALUE = Symbol('no Value');</span><span class="s3">\n</span><span class="s1">/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the new</span><span class="s3">\n </span><span class="s1">* schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the nature</span><span class="s3">\n </span><span class="s1">* of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the old schema</span><span class="s3">\n </span><span class="s1">* that are non-existent in the new schema are set to `undefined`. The data sanitization process has the following flow:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* - If the new schema is an object that contains a `properties` object then:</span><span class="s3">\n </span><span class="s1">*   - Create a `removeOldSchemaData` object, setting each key in the `oldSchema.properties` having `data` to undefined</span><span class="s3">\n </span><span class="s1">*   - Create an empty `nestedData` object for use in the key filtering below:</span><span class="s3">\n </span><span class="s1">*   - Iterate over each key in the `newSchema.properties` as follows:</span><span class="s3">\n </span><span class="s1">*     - Get the `formValue` of the key from the `data`</span><span class="s3">\n </span><span class="s1">*     - Get the `oldKeySchema` and `newKeyedSchema` for the key, defaulting to `{}` when it doesn't exist</span><span class="s3">\n </span><span class="s1">*     - Retrieve the schema for any refs within each `oldKeySchema` and/or `newKeySchema`</span><span class="s3">\n </span><span class="s1">*     - Get the types of the old and new keyed schemas and if the old doesn't exist or the old &amp; new are the same then:</span><span class="s3">\n </span><span class="s1">*       - If `removeOldSchemaData` has an entry for the key, delete it since the new schema has the same property</span><span class="s3">\n </span><span class="s1">*       - If type of the key in the new schema is `object`:</span><span class="s3">\n </span><span class="s1">*         - Store the value from the recursive `sanitizeDataForNewSchema` call in `nestedData[key]`</span><span class="s3">\n </span><span class="s1">*       - Otherwise, check for default or const values:</span><span class="s3">\n </span><span class="s1">*         - Get the old and new `default` values from the schema and check:</span><span class="s3">\n </span><span class="s1">*           - If the new `default` value does not match the form value:</span><span class="s3">\n </span><span class="s1">*             - If the old `default` value DOES match the form value, then:</span><span class="s3">\n </span><span class="s1">*               - Replace `removeOldSchemaData[key]` with the new `default`</span><span class="s3">\n </span><span class="s1">*               - Otherwise, if the new schema is `readOnly` then replace `removeOldSchemaData[key]` with undefined</span><span class="s3">\n </span><span class="s1">*         - Get the old and new `const` values from the schema and check:</span><span class="s3">\n </span><span class="s1">*           - If the new `const` value does not match the form value:</span><span class="s3">\n </span><span class="s1">*           - If the old `const` value DOES match the form value, then:</span><span class="s3">\n </span><span class="s1">*             - Replace `removeOldSchemaData[key]` with the new `const`</span><span class="s3">\n </span><span class="s1">*             - Otherwise, replace `removeOldSchemaData[key]` with undefined</span><span class="s3">\n </span><span class="s1">*   - Once all keys have been processed, return an object built as follows:</span><span class="s3">\n </span><span class="s1">*     - `{ ...removeOldSchemaData, ...nestedData, ...pick(data, keysToKeep) }`</span><span class="s3">\n </span><span class="s1">* - If the new and old schema types are array and the `data` is an array then:</span><span class="s3">\n </span><span class="s1">*   - If the type of the old and new schema `items` are a non-array objects:</span><span class="s3">\n </span><span class="s1">*     - Retrieve the schema for any refs within each `oldKeySchema.items` and/or `newKeySchema.items`</span><span class="s3">\n </span><span class="s1">*     - If the `type`s of both items are the same (or the old does not have a type):</span><span class="s3">\n </span><span class="s1">*       - If the type is </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">, then:</span><span class="s3">\n </span><span class="s1">*         - For each element in the `data` recursively sanitize the data, stopping at `maxItems` if specified</span><span class="s3">\n </span><span class="s1">*       - Otherwise, just return the `data` removing any values after `maxItems` if it is set</span><span class="s3">\n </span><span class="s1">*   - If the type of the old and new schema `items` are booleans of the same value, return `data` as is</span><span class="s3">\n </span><span class="s1">* - Otherwise return `undefined`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root JSON schema of the entire form</span><span class="s3">\n </span><span class="s1">* @param [newSchema] - The new schema for which the data is being sanitized</span><span class="s3">\n </span><span class="s1">* @param [oldSchema] - The old schema from which the data originated</span><span class="s3">\n </span><span class="s1">* @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined</span><span class="s3">\n </span><span class="s1">* @returns - The new form data, with all the fields uniquely associated with the old schema set</span><span class="s3">\n </span><span class="s1">*      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function sanitizeDataForNewSchema(validator, rootSchema, newSchema, oldSchema, data = {}) {</span><span class="s3">\n    </span><span class="s1">// By default, we will clear the form data</span><span class="s3">\n    </span><span class="s1">let newFormData;</span><span class="s3">\n    </span><span class="s1">// If the new schema is of type object and that object contains a list of properties</span><span class="s3">\n    </span><span class="s1">if (has(newSchema, PROPERTIES_KEY)) {</span><span class="s3">\n        </span><span class="s1">// Create an object containing root-level keys in the old schema, setting each key to undefined to remove the data</span><span class="s3">\n        </span><span class="s1">const removeOldSchemaData = {};</span><span class="s3">\n        </span><span class="s1">if (has(oldSchema, PROPERTIES_KEY)) {</span><span class="s3">\n            </span><span class="s1">const properties = get(oldSchema, PROPERTIES_KEY, {});</span><span class="s3">\n            </span><span class="s1">Object.keys(properties).forEach((key) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (has(data, key)) {</span><span class="s3">\n                    </span><span class="s1">removeOldSchemaData[key] = undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const keys = Object.keys(get(newSchema, PROPERTIES_KEY, {}));</span><span class="s3">\n        </span><span class="s1">// Create a place to store nested data that will be a side-effect of the filter</span><span class="s3">\n        </span><span class="s1">const nestedData = {};</span><span class="s3">\n        </span><span class="s1">keys.forEach((key) =&gt; {</span><span class="s3">\n            </span><span class="s1">const formValue = get(data, key);</span><span class="s3">\n            </span><span class="s1">let oldKeyedSchema = get(oldSchema, [PROPERTIES_KEY, key], {});</span><span class="s3">\n            </span><span class="s1">let newKeyedSchema = get(newSchema, [PROPERTIES_KEY, key], {});</span><span class="s3">\n            </span><span class="s1">// Resolve the refs if they exist</span><span class="s3">\n            </span><span class="s1">if (has(oldKeyedSchema, REF_KEY)) {</span><span class="s3">\n                </span><span class="s1">oldKeyedSchema = retrieveSchema(validator, oldKeyedSchema, rootSchema, formValue);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (has(newKeyedSchema, REF_KEY)) {</span><span class="s3">\n                </span><span class="s1">newKeyedSchema = retrieveSchema(validator, newKeyedSchema, rootSchema, formValue);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Now get types and see if they are the same</span><span class="s3">\n            </span><span class="s1">const oldSchemaTypeForKey = get(oldKeyedSchema, 'type');</span><span class="s3">\n            </span><span class="s1">const newSchemaTypeForKey = get(newKeyedSchema, 'type');</span><span class="s3">\n            </span><span class="s1">// Check if the old option has the same key with the same type</span><span class="s3">\n            </span><span class="s1">if (!oldSchemaTypeForKey || oldSchemaTypeForKey === newSchemaTypeForKey) {</span><span class="s3">\n                </span><span class="s1">if (has(removeOldSchemaData, key)) {</span><span class="s3">\n                    </span><span class="s1">// SIDE-EFFECT: remove the undefined value for a key that has the same type between the old and new schemas</span><span class="s3">\n                    </span><span class="s1">delete removeOldSchemaData[key];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// If it is an object, we'll recurse and store the resulting sanitized data for the key</span><span class="s3">\n                </span><span class="s1">if (newSchemaTypeForKey === 'object' || (newSchemaTypeForKey === 'array' &amp;&amp; Array.isArray(formValue))) {</span><span class="s3">\n                    </span><span class="s1">// SIDE-EFFECT: process the new schema type of object recursively to save iterations</span><span class="s3">\n                    </span><span class="s1">const itemData = sanitizeDataForNewSchema(validator, rootSchema, newKeyedSchema, oldKeyedSchema, formValue);</span><span class="s3">\n                    </span><span class="s1">if (itemData !== undefined || newSchemaTypeForKey === 'array') {</span><span class="s3">\n                        </span><span class="s1">// only put undefined values for the array type and not the object type</span><span class="s3">\n                        </span><span class="s1">nestedData[key] = itemData;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">// Ok, the non-object types match, let's make sure that a default or a const of a different value is replaced</span><span class="s3">\n                    </span><span class="s1">// with the new default or const. This allows the case where two schemas differ that only by the default/const</span><span class="s3">\n                    </span><span class="s1">// value to be properly selected</span><span class="s3">\n                    </span><span class="s1">const newOptionDefault = get(newKeyedSchema, 'default', NO_VALUE);</span><span class="s3">\n                    </span><span class="s1">const oldOptionDefault = get(oldKeyedSchema, 'default', NO_VALUE);</span><span class="s3">\n                    </span><span class="s1">if (newOptionDefault !== NO_VALUE &amp;&amp; newOptionDefault !== formValue) {</span><span class="s3">\n                        </span><span class="s1">if (oldOptionDefault === formValue) {</span><span class="s3">\n                            </span><span class="s1">// If the old default matches the formValue, we'll update the new value to match the new default</span><span class="s3">\n                            </span><span class="s1">removeOldSchemaData[key] = newOptionDefault;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else if (get(newKeyedSchema, 'readOnly') === true) {</span><span class="s3">\n                            </span><span class="s1">// If the new schema has the default set to read-only, treat it like a const and remove the value</span><span class="s3">\n                            </span><span class="s1">removeOldSchemaData[key] = undefined;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const newOptionConst = get(newKeyedSchema, 'const', NO_VALUE);</span><span class="s3">\n                    </span><span class="s1">const oldOptionConst = get(oldKeyedSchema, 'const', NO_VALUE);</span><span class="s3">\n                    </span><span class="s1">if (newOptionConst !== NO_VALUE &amp;&amp; newOptionConst !== formValue) {</span><span class="s3">\n                        </span><span class="s1">// Since this is a const, if the old value matches, replace the value with the new const otherwise clear it</span><span class="s3">\n                        </span><span class="s1">removeOldSchemaData[key] = oldOptionConst === formValue ? newOptionConst : undefined;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">newFormData = {</span><span class="s3">\n            </span><span class="s1">...(typeof data == 'string' || Array.isArray(data) ? undefined : data),</span><span class="s3">\n            </span><span class="s1">...removeOldSchemaData,</span><span class="s3">\n            </span><span class="s1">...nestedData,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">// First apply removing the old schema data, then apply the nested data, then apply the old data keys to keep</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (get(oldSchema, 'type') === 'array' &amp;&amp; get(newSchema, 'type') === 'array' &amp;&amp; Array.isArray(data)) {</span><span class="s3">\n        </span><span class="s1">let oldSchemaItems = get(oldSchema, 'items');</span><span class="s3">\n        </span><span class="s1">let newSchemaItems = get(newSchema, 'items');</span><span class="s3">\n        </span><span class="s1">// If any of the array types `items` are arrays (remember arrays are objects) then we'll just drop the data</span><span class="s3">\n        </span><span class="s1">// Eventually, we may want to deal with when either of the `items` are arrays since those tuple validations</span><span class="s3">\n        </span><span class="s1">if (typeof oldSchemaItems === 'object' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof newSchemaItems === 'object' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!Array.isArray(oldSchemaItems) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">!Array.isArray(newSchemaItems)) {</span><span class="s3">\n            </span><span class="s1">if (has(oldSchemaItems, REF_KEY)) {</span><span class="s3">\n                </span><span class="s1">oldSchemaItems = retrieveSchema(validator, oldSchemaItems, rootSchema, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (has(newSchemaItems, REF_KEY)) {</span><span class="s3">\n                </span><span class="s1">newSchemaItems = retrieveSchema(validator, newSchemaItems, rootSchema, data);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Now get types and see if they are the same</span><span class="s3">\n            </span><span class="s1">const oldSchemaType = get(oldSchemaItems, 'type');</span><span class="s3">\n            </span><span class="s1">const newSchemaType = get(newSchemaItems, 'type');</span><span class="s3">\n            </span><span class="s1">// Check if the old option has the same key with the same type</span><span class="s3">\n            </span><span class="s1">if (!oldSchemaType || oldSchemaType === newSchemaType) {</span><span class="s3">\n                </span><span class="s1">const maxItems = get(newSchema, 'maxItems', -1);</span><span class="s3">\n                </span><span class="s1">if (newSchemaType === 'object') {</span><span class="s3">\n                    </span><span class="s1">newFormData = data.reduce((newValue, aValue) =&gt; {</span><span class="s3">\n                        </span><span class="s1">const itemValue = sanitizeDataForNewSchema(validator, rootSchema, newSchemaItems, oldSchemaItems, aValue);</span><span class="s3">\n                        </span><span class="s1">if (itemValue !== undefined &amp;&amp; (maxItems &lt; 0 || newValue.length &lt; maxItems)) {</span><span class="s3">\n                            </span><span class="s1">newValue.push(itemValue);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">return newValue;</span><span class="s3">\n                    </span><span class="s1">}, []);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">newFormData = maxItems &gt; 0 &amp;&amp; data.length &gt; maxItems ? data.slice(0, maxItems) : data;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (typeof oldSchemaItems === 'boolean' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">typeof newSchemaItems === 'boolean' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">oldSchemaItems === newSchemaItems) {</span><span class="s3">\n            </span><span class="s1">// If they are both booleans and have the same value just return the data as is otherwise fall-thru to undefined</span><span class="s3">\n            </span><span class="s1">newFormData = data;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Also probably want to deal with `prefixItems` as tuples with the latest 2020 draft</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return newFormData;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=sanitizeDataForNewSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import { ALL_OF_KEY, DEPENDENCIES_KEY, ID_KEY, ITEMS_KEY, PROPERTIES_KEY, REF_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import isObject from '../isObject';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">import getSchemaType from '../getSchemaType';</span><span class="s3">\n</span><span class="s1">/** An internal helper that generates an `IdSchema` object for the `schema`, recursively with protection against</span><span class="s3">\n </span><span class="s1">* infinite recursion</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the `IdSchema` is desired</span><span class="s3">\n </span><span class="s1">* @param idPrefix - The prefix to use for the id</span><span class="s3">\n </span><span class="s1">* @param idSeparator - The separator to use for the path segments in the id</span><span class="s3">\n </span><span class="s1">* @param [id] - The base id for the schema</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion</span><span class="s3">\n </span><span class="s1">* @returns - The `IdSchema` object for the `schema`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList = []) {</span><span class="s3">\n    </span><span class="s1">if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const _schema = retrieveSchema(validator, schema, rootSchema, formData);</span><span class="s3">\n        </span><span class="s1">const sameSchemaIndex = _recurseList.findIndex((item) =&gt; isEqual(item, _schema));</span><span class="s3">\n        </span><span class="s1">if (sameSchemaIndex === -1) {</span><span class="s3">\n            </span><span class="s1">return toIdSchemaInternal(validator, _schema, idPrefix, idSeparator, id, rootSchema, formData, _recurseList.concat(_schema));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ITEMS_KEY in schema &amp;&amp; !get(schema, [ITEMS_KEY, REF_KEY])) {</span><span class="s3">\n        </span><span class="s1">return toIdSchemaInternal(validator, get(schema, ITEMS_KEY), idPrefix, idSeparator, id, rootSchema, formData, _recurseList);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const $id = id || idPrefix;</span><span class="s3">\n    </span><span class="s1">const idSchema = { $id };</span><span class="s3">\n    </span><span class="s1">if (getSchemaType(schema) === 'object' &amp;&amp; PROPERTIES_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">for (const name in schema.properties) {</span><span class="s3">\n            </span><span class="s1">const field = get(schema, [PROPERTIES_KEY, name]);</span><span class="s3">\n            </span><span class="s1">const fieldId = idSchema[ID_KEY] + idSeparator + name;</span><span class="s3">\n            </span><span class="s1">idSchema[name] = toIdSchemaInternal(validator, isObject(field) ? field : {}, idPrefix, idSeparator, fieldId, rootSchema, </span><span class="s3">\n            </span><span class="s1">// It's possible that formData is not an object -- this can happen if an</span><span class="s3">\n            </span><span class="s1">// array item has just been added, but not populated with data yet</span><span class="s3">\n            </span><span class="s1">get(formData, [name]), _recurseList);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return idSchema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Generates an `IdSchema` object for the `schema`, recursively</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the `IdSchema` is desired</span><span class="s3">\n </span><span class="s1">* @param [id] - The base id for the schema</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @param [idPrefix='root'] - The prefix to use for the id</span><span class="s3">\n </span><span class="s1">* @param [idSeparator='_'] - The separator to use for the path segments in the id</span><span class="s3">\n </span><span class="s1">* @returns - The `IdSchema` object for the `schema`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toIdSchema(validator, schema, id, rootSchema, formData, idPrefix = 'root', idSeparator = '_') {</span><span class="s3">\n    </span><span class="s1">return toIdSchemaInternal(validator, schema, idPrefix, idSeparator, id, rootSchema, formData);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toIdSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import { ALL_OF_KEY, ANY_OF_KEY, ADDITIONAL_PROPERTIES_KEY, DEPENDENCIES_KEY, ITEMS_KEY, NAME_KEY, ONE_OF_KEY, PROPERTIES_KEY, REF_KEY, RJSF_ADDITONAL_PROPERTIES_FLAG, } from '../constants';</span><span class="s3">\n</span><span class="s1">import getDiscriminatorFieldFromSchema from '../getDiscriminatorFieldFromSchema';</span><span class="s3">\n</span><span class="s1">import getClosestMatchingOption from './getClosestMatchingOption';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">/** An internal helper that generates an `PathSchema` object for the `schema`, recursively with protection against</span><span class="s3">\n </span><span class="s1">* infinite recursion</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the `PathSchema` is desired</span><span class="s3">\n </span><span class="s1">* @param [name=''] - The base name for the schema</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @param [_recurseList=[]] - The list of retrieved schemas currently being recursed, used to prevent infinite recursion</span><span class="s3">\n </span><span class="s1">* @returns - The `PathSchema` object for the `schema`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toPathSchemaInternal(validator, schema, name, rootSchema, formData, _recurseList = []) {</span><span class="s3">\n    </span><span class="s1">if (REF_KEY in schema || DEPENDENCIES_KEY in schema || ALL_OF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const _schema = retrieveSchema(validator, schema, rootSchema, formData);</span><span class="s3">\n        </span><span class="s1">const sameSchemaIndex = _recurseList.findIndex((item) =&gt; isEqual(item, _schema));</span><span class="s3">\n        </span><span class="s1">if (sameSchemaIndex === -1) {</span><span class="s3">\n            </span><span class="s1">return toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList.concat(_schema));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let pathSchema = {</span><span class="s3">\n        </span><span class="s1">[NAME_KEY]: name.replace(/^</span><span class="s3">\\</span><span class="s1">./, ''),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (ONE_OF_KEY in schema || ANY_OF_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">const xxxOf = ONE_OF_KEY in schema ? schema.oneOf : schema.anyOf;</span><span class="s3">\n        </span><span class="s1">const discriminator = getDiscriminatorFieldFromSchema(schema);</span><span class="s3">\n        </span><span class="s1">const index = getClosestMatchingOption(validator, rootSchema, formData, xxxOf, 0, discriminator);</span><span class="s3">\n        </span><span class="s1">const _schema = xxxOf[index];</span><span class="s3">\n        </span><span class="s1">pathSchema = {</span><span class="s3">\n            </span><span class="s1">...pathSchema,</span><span class="s3">\n            </span><span class="s1">...toPathSchemaInternal(validator, _schema, name, rootSchema, formData, _recurseList),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ADDITIONAL_PROPERTIES_KEY in schema &amp;&amp; schema[ADDITIONAL_PROPERTIES_KEY] !== false) {</span><span class="s3">\n        </span><span class="s1">set(pathSchema, RJSF_ADDITONAL_PROPERTIES_FLAG, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (ITEMS_KEY in schema &amp;&amp; Array.isArray(formData)) {</span><span class="s3">\n        </span><span class="s1">const { items: schemaItems, additionalItems: schemaAdditionalItems } = schema;</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(schemaItems)) {</span><span class="s3">\n            </span><span class="s1">formData.forEach((element, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (schemaItems[i]) {</span><span class="s3">\n                    </span><span class="s1">pathSchema[i] = toPathSchemaInternal(validator, schemaItems[i], `${name}.${i}`, rootSchema, element, _recurseList);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (schemaAdditionalItems) {</span><span class="s3">\n                    </span><span class="s1">pathSchema[i] = toPathSchemaInternal(validator, schemaAdditionalItems, `${name}.${i}`, rootSchema, element, _recurseList);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">console.warn(`Unable to generate path schema for </span><span class="s3">\&quot;</span><span class="s1">${name}.${i}</span><span class="s3">\&quot;</span><span class="s1">. No schema defined for it`);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">formData.forEach((element, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">pathSchema[i] = toPathSchemaInternal(validator, schemaItems, `${name}.${i}`, rootSchema, element, _recurseList);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (PROPERTIES_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">for (const property in schema.properties) {</span><span class="s3">\n            </span><span class="s1">const field = get(schema, [PROPERTIES_KEY, property]);</span><span class="s3">\n            </span><span class="s1">pathSchema[property] = toPathSchemaInternal(validator, field, `${name}.${property}`, rootSchema, </span><span class="s3">\n            </span><span class="s1">// It's possible that formData is not an object -- this can happen if an</span><span class="s3">\n            </span><span class="s1">// array item has just been added, but not populated with data yet</span><span class="s3">\n            </span><span class="s1">get(formData, [property]), _recurseList);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pathSchema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Generates an `PathSchema` object for the `schema`, recursively</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be used when necessary</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the `PathSchema` is desired</span><span class="s3">\n </span><span class="s1">* @param [name=''] - The base name for the schema</span><span class="s3">\n </span><span class="s1">* @param [rootSchema] - The root schema, used to primarily to look up `$ref`s</span><span class="s3">\n </span><span class="s1">* @param [formData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n </span><span class="s1">* @returns - The `PathSchema` object for the `schema`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toPathSchema(validator, schema, name = '', rootSchema, formData) {</span><span class="s3">\n    </span><span class="s1">return toPathSchemaInternal(validator, schema, name, rootSchema, formData);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toPathSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import getDefaultFormState from './getDefaultFormState';</span><span class="s3">\n</span><span class="s1">import getDisplayLabel from './getDisplayLabel';</span><span class="s3">\n</span><span class="s1">import getClosestMatchingOption from './getClosestMatchingOption';</span><span class="s3">\n</span><span class="s1">import getFirstMatchingOption from './getFirstMatchingOption';</span><span class="s3">\n</span><span class="s1">import getMatchingOption from './getMatchingOption';</span><span class="s3">\n</span><span class="s1">import isFilesArray from './isFilesArray';</span><span class="s3">\n</span><span class="s1">import isMultiSelect from './isMultiSelect';</span><span class="s3">\n</span><span class="s1">import isSelect from './isSelect';</span><span class="s3">\n</span><span class="s1">import mergeValidationData from './mergeValidationData';</span><span class="s3">\n</span><span class="s1">import retrieveSchema from './retrieveSchema';</span><span class="s3">\n</span><span class="s1">import sanitizeDataForNewSchema from './sanitizeDataForNewSchema';</span><span class="s3">\n</span><span class="s1">import toIdSchema from './toIdSchema';</span><span class="s3">\n</span><span class="s1">import toPathSchema from './toPathSchema';</span><span class="s3">\n</span><span class="s1">export { getDefaultFormState, getDisplayLabel, getClosestMatchingOption, getFirstMatchingOption, getMatchingOption, isFilesArray, isMultiSelect, isSelect, mergeValidationData, retrieveSchema, sanitizeDataForNewSchema, toIdSchema, toPathSchema, };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import deepEquals from './deepEquals';</span><span class="s3">\n</span><span class="s1">import { getDefaultFormState, getDisplayLabel, getClosestMatchingOption, getFirstMatchingOption, getMatchingOption, isFilesArray, isMultiSelect, isSelect, mergeValidationData, retrieveSchema, sanitizeDataForNewSchema, toIdSchema, toPathSchema, } from './schema';</span><span class="s3">\n</span><span class="s1">/** The `SchemaUtils` class provides a wrapper around the publicly exported APIs in the `utils/schema` directory such</span><span class="s3">\n </span><span class="s1">* that one does not have to explicitly pass the `validator`, `rootSchema`, or `experimental_defaultFormStateBehavior` to each method.</span><span class="s3">\n </span><span class="s1">* Since these generally do not change across a `Form`, this allows for providing a simplified set of APIs to the</span><span class="s3">\n </span><span class="s1">* `@rjsf/core` components and the various themes as well. This class implements the `SchemaUtilsType` interface.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SchemaUtils {</span><span class="s3">\n    </span><span class="s1">/** Constructs the `SchemaUtils` instance with the given `validator` and `rootSchema` stored as instance variables</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n     </span><span class="s1">* @param experimental_defaultFormStateBehavior - Configuration flags to allow users to override default form state behavior</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(validator, rootSchema, experimental_defaultFormStateBehavior) {</span><span class="s3">\n        </span><span class="s1">this.rootSchema = rootSchema;</span><span class="s3">\n        </span><span class="s1">this.validator = validator;</span><span class="s3">\n        </span><span class="s1">this.experimental_defaultFormStateBehavior = experimental_defaultFormStateBehavior;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the `ValidatorType` in the `SchemaUtilsType`</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns - The `ValidatorType`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getValidator() {</span><span class="s3">\n        </span><span class="s1">return this.validator;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines whether either the `validator` and `rootSchema` differ from the ones associated with this instance of</span><span class="s3">\n     </span><span class="s1">* the `SchemaUtilsType`. If either `validator` or `rootSchema` are falsy, then return false to prevent the creation</span><span class="s3">\n     </span><span class="s1">* of a new `SchemaUtilsType` with incomplete properties.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param validator - An implementation of the `ValidatorType` interface that will be compared against the current one</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema that will be compared against the current one</span><span class="s3">\n     </span><span class="s1">* @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior</span><span class="s3">\n     </span><span class="s1">* @returns - True if the `SchemaUtilsType` differs from the given `validator` or `rootSchema`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">doesSchemaUtilsDiffer(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {</span><span class="s3">\n        </span><span class="s1">if (!validator || !rootSchema) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (this.validator !== validator ||</span><span class="s3">\n            </span><span class="s1">!deepEquals(this.rootSchema, rootSchema) ||</span><span class="s3">\n            </span><span class="s1">!deepEquals(this.experimental_defaultFormStateBehavior, experimental_defaultFormStateBehavior));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the superset of `formData` that includes the given set updated to include any missing fields that have</span><span class="s3">\n     </span><span class="s1">* computed to have defaults provided in the `schema`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which the default state is desired</span><span class="s3">\n     </span><span class="s1">* @param [formData] - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n     </span><span class="s1">* @param [includeUndefinedValues=false] - Optional flag, if true, cause undefined values to be added as defaults.</span><span class="s3">\n     </span><span class="s1">*          If </span><span class="s3">\&quot;</span><span class="s1">excludeObjectChildren</span><span class="s3">\&quot;</span><span class="s1">, pass `includeUndefinedValues` as false when computing defaults for any nested</span><span class="s3">\n     </span><span class="s1">*          object properties.</span><span class="s3">\n     </span><span class="s1">* @returns - The resulting `formData` with all the defaults provided</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getDefaultFormState(schema, formData, includeUndefinedValues = false) {</span><span class="s3">\n        </span><span class="s1">return getDefaultFormState(this.validator, schema, formData, this.rootSchema, includeUndefinedValues, this.experimental_defaultFormStateBehavior);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines whether the combination of `schema` and `uiSchema` properties indicates that the label for the `schema`</span><span class="s3">\n     </span><span class="s1">* should be displayed in a UI.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which the display label flag is desired</span><span class="s3">\n     </span><span class="s1">* @param [uiSchema] - The UI schema from which to derive potentially displayable information</span><span class="s3">\n     </span><span class="s1">* @param [globalOptions={}] - The optional Global UI Schema from which to get any fallback `xxx` options</span><span class="s3">\n     </span><span class="s1">* @returns - True if the label should be displayed or false if it should not</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getDisplayLabel(schema, uiSchema, globalOptions) {</span><span class="s3">\n        </span><span class="s1">return getDisplayLabel(this.validator, schema, uiSchema, this.rootSchema, globalOptions);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Determines which of the given `options` provided most closely matches the `formData`.</span><span class="s3">\n     </span><span class="s1">* Returns the index of the option that is valid and is the closest match, or 0 if there is no match.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The closest match is determined using the number of matching properties, and more heavily favors options with</span><span class="s3">\n     </span><span class="s1">* matching readOnly, default, or const values.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The form data associated with the schema</span><span class="s3">\n     </span><span class="s1">* @param options - The list of options that can be selected from</span><span class="s3">\n     </span><span class="s1">* @param [selectedOption] - The index of the currently selected option, defaulted to -1 if not specified</span><span class="s3">\n     </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n     </span><span class="s1">*          determine which option is selected</span><span class="s3">\n     </span><span class="s1">* @returns - The index of the option that is the closest match to the `formData` or the `selectedOption` if no match</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getClosestMatchingOption(formData, options, selectedOption, discriminatorField) {</span><span class="s3">\n        </span><span class="s1">return getClosestMatchingOption(this.validator, this.rootSchema, formData, options, selectedOption, discriminatorField);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Given the `formData` and list of `options`, attempts to find the index of the first option that matches the data.</span><span class="s3">\n     </span><span class="s1">* Always returns the first option if there is nothing that matches.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The current formData, if any, used to figure out a match</span><span class="s3">\n     </span><span class="s1">* @param options - The list of options to find a matching options from</span><span class="s3">\n     </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n     </span><span class="s1">*          determine which option is selected</span><span class="s3">\n     </span><span class="s1">* @returns - The firstindex of the matched option or 0 if none is available</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getFirstMatchingOption(formData, options, discriminatorField) {</span><span class="s3">\n        </span><span class="s1">return getFirstMatchingOption(this.validator, formData, options, this.rootSchema, discriminatorField);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Given the `formData` and list of `options`, attempts to find the index of the option that best matches the data.</span><span class="s3">\n     </span><span class="s1">* Deprecated, use `getFirstMatchingOption()` instead.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param formData - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n     </span><span class="s1">* @param options - The list of options to find a matching options from</span><span class="s3">\n     </span><span class="s1">* @param [discriminatorField] - The optional name of the field within the options object whose value is used to</span><span class="s3">\n     </span><span class="s1">*          determine which option is selected</span><span class="s3">\n     </span><span class="s1">* @returns - The index of the matched option or 0 if none is available</span><span class="s3">\n     </span><span class="s1">* @deprecated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getMatchingOption(formData, options, discriminatorField) {</span><span class="s3">\n        </span><span class="s1">return getMatchingOption(this.validator, formData, options, this.rootSchema, discriminatorField);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Checks to see if the `schema` and `uiSchema` combination represents an array of files</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which check for array of files flag is desired</span><span class="s3">\n     </span><span class="s1">* @param [uiSchema] - The UI schema from which to check the widget</span><span class="s3">\n     </span><span class="s1">* @returns - True if schema/uiSchema contains an array of files, otherwise false</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isFilesArray(schema, uiSchema) {</span><span class="s3">\n        </span><span class="s1">return isFilesArray(this.validator, schema, uiSchema, this.rootSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Checks to see if the `schema` combination represents a multi-select</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which check for a multi-select flag is desired</span><span class="s3">\n     </span><span class="s1">* @returns - True if schema contains a multi-select, otherwise false</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isMultiSelect(schema) {</span><span class="s3">\n        </span><span class="s1">return isMultiSelect(this.validator, schema, this.rootSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Checks to see if the `schema` combination represents a select</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which check for a select flag is desired</span><span class="s3">\n     </span><span class="s1">* @returns - True if schema contains a select, otherwise false</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isSelect(schema) {</span><span class="s3">\n        </span><span class="s1">return isSelect(this.validator, schema, this.rootSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in</span><span class="s3">\n     </span><span class="s1">* the two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling</span><span class="s3">\n     </span><span class="s1">* `getValidator().toErrorList()` onto the `errors` in the `validationData`. If no `additionalErrorSchema` is passed,</span><span class="s3">\n     </span><span class="s1">* then `validationData` is returned.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param validationData - The current `ValidationData` into which to merge the additional errors</span><span class="s3">\n     </span><span class="s1">* @param [additionalErrorSchema] - The additional set of errors</span><span class="s3">\n     </span><span class="s1">* @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.</span><span class="s3">\n     </span><span class="s1">* @deprecated - Use the `validationDataMerge()` function exported from `@rjsf/utils` instead. This function will be</span><span class="s3">\n     </span><span class="s1">*        removed in the next major release.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mergeValidationData(validationData, additionalErrorSchema) {</span><span class="s3">\n        </span><span class="s1">return mergeValidationData(this.validator, validationData, additionalErrorSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Retrieves an expanded schema that has had all of its conditions, additional properties, references and</span><span class="s3">\n     </span><span class="s1">* dependencies resolved and merged into the `schema` given a `rawFormData` that is used to do the potentially</span><span class="s3">\n     </span><span class="s1">* recursive resolution.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which retrieving a schema is desired</span><span class="s3">\n     </span><span class="s1">* @param [rawFormData] - The current formData, if any, to assist retrieving a schema</span><span class="s3">\n     </span><span class="s1">* @returns - The schema having its conditions, additional properties, references and dependencies resolved</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">retrieveSchema(schema, rawFormData) {</span><span class="s3">\n        </span><span class="s1">return retrieveSchema(this.validator, schema, this.rootSchema, rawFormData);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Sanitize the `data` associated with the `oldSchema` so it is considered appropriate for the `newSchema`. If the</span><span class="s3">\n     </span><span class="s1">* new schema does not contain any properties, then `undefined` is returned to clear all the form data. Due to the</span><span class="s3">\n     </span><span class="s1">* nature of schemas, this sanitization happens recursively for nested objects of data. Also, any properties in the</span><span class="s3">\n     </span><span class="s1">* old schemas that are non-existent in the new schema are set to `undefined`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param [newSchema] - The new schema for which the data is being sanitized</span><span class="s3">\n     </span><span class="s1">* @param [oldSchema] - The old schema from which the data originated</span><span class="s3">\n     </span><span class="s1">* @param [data={}] - The form data associated with the schema, defaulting to an empty object when undefined</span><span class="s3">\n     </span><span class="s1">* @returns - The new form data, with all the fields uniquely associated with the old schema set</span><span class="s3">\n     </span><span class="s1">*      to `undefined`. Will return `undefined` if the new schema is not an object containing properties.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sanitizeDataForNewSchema(newSchema, oldSchema, data) {</span><span class="s3">\n        </span><span class="s1">return sanitizeDataForNewSchema(this.validator, this.rootSchema, newSchema, oldSchema, data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Generates an `IdSchema` object for the `schema`, recursively</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which the display label flag is desired</span><span class="s3">\n     </span><span class="s1">* @param [id] - The base id for the schema</span><span class="s3">\n     </span><span class="s1">* @param [formData] - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n     </span><span class="s1">* @param [idPrefix='root'] - The prefix to use for the id</span><span class="s3">\n     </span><span class="s1">* @param [idSeparator='_'] - The separator to use for the path segments in the id</span><span class="s3">\n     </span><span class="s1">* @returns - The `IdSchema` object for the `schema`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toIdSchema(schema, id, formData, idPrefix = 'root', idSeparator = '_') {</span><span class="s3">\n        </span><span class="s1">return toIdSchema(this.validator, schema, id, this.rootSchema, formData, idPrefix, idSeparator);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Generates an `PathSchema` object for the `schema`, recursively</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema for which the display label flag is desired</span><span class="s3">\n     </span><span class="s1">* @param [name] - The base name for the schema</span><span class="s3">\n     </span><span class="s1">* @param [formData] - The current formData, if any, onto which to provide any missing defaults</span><span class="s3">\n     </span><span class="s1">* @returns - The `PathSchema` object for the `schema`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toPathSchema(schema, name, formData) {</span><span class="s3">\n        </span><span class="s1">return toPathSchema(this.validator, schema, name, this.rootSchema, formData);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Creates a `SchemaUtilsType` interface that is based around the given `validator` and `rootSchema` parameters. The</span><span class="s3">\n </span><span class="s1">* resulting interface implementation will forward the `validator` and `rootSchema` to all the wrapped APIs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - an implementation of the `ValidatorType` interface that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema that will be forwarded to all the APIs</span><span class="s3">\n </span><span class="s1">* @param [experimental_defaultFormStateBehavior] Optional configuration object, if provided, allows users to override default form state behavior</span><span class="s3">\n </span><span class="s1">* @returns - An implementation of a `SchemaUtilsType` interface</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function createSchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior = {}) {</span><span class="s3">\n    </span><span class="s1">return new SchemaUtils(validator, rootSchema, experimental_defaultFormStateBehavior);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=createSchemaUtils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Given the `FileReader.readAsDataURL()` based `dataURI` extracts that data into an actual Blob along with the name</span><span class="s3">\n </span><span class="s1">* of that Blob if provided in the URL. If no name is provided, then the name falls back to `unknown`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param dataURI - The `DataUrl` potentially containing name and raw data to be converted to a Blob</span><span class="s3">\n </span><span class="s1">* @returns - an object containing a Blob and its name, extracted from the URI</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function dataURItoBlob(dataURI) {</span><span class="s3">\n    </span><span class="s1">// Split metadata from data</span><span class="s3">\n    </span><span class="s1">const splitted = dataURI.split(',');</span><span class="s3">\n    </span><span class="s1">// Split params</span><span class="s3">\n    </span><span class="s1">const params = splitted[0].split(';');</span><span class="s3">\n    </span><span class="s1">// Get mime-type from params</span><span class="s3">\n    </span><span class="s1">const type = params[0].replace('data:', '');</span><span class="s3">\n    </span><span class="s1">// Filter the name property from params</span><span class="s3">\n    </span><span class="s1">const properties = params.filter((param) =&gt; {</span><span class="s3">\n        </span><span class="s1">return param.split('=')[0] === 'name';</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">// Look for the name and use unknown if no name property.</span><span class="s3">\n    </span><span class="s1">let name;</span><span class="s3">\n    </span><span class="s1">if (properties.length !== 1) {</span><span class="s3">\n        </span><span class="s1">name = 'unknown';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// Because we filtered out the other property,</span><span class="s3">\n        </span><span class="s1">// we only have the name case here, which we decode to make it human-readable</span><span class="s3">\n        </span><span class="s1">name = decodeURI(properties[0].split('=')[1]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Built the Uint8Array Blob parameter from the base64 string.</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">const binary = atob(splitted[1]);</span><span class="s3">\n        </span><span class="s1">const array = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; binary.length; i++) {</span><span class="s3">\n            </span><span class="s1">array.push(binary.charCodeAt(i));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Create the blob object</span><span class="s3">\n        </span><span class="s1">const blob = new window.Blob([new Uint8Array(array)], { type });</span><span class="s3">\n        </span><span class="s1">return { blob, name };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (error) {</span><span class="s3">\n        </span><span class="s1">return { blob: { size: 0, type: error.message }, name: dataURI };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=dataURItoBlob.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Potentially substitutes all replaceable parameters with the associated value(s) from the `params` if available. When</span><span class="s3">\n </span><span class="s1">* a `params` array is provided, each value in the array is used to replace any of the replaceable parameters in the</span><span class="s3">\n </span><span class="s1">* `inputString` using the `%1`, `%2`, etc. replacement specifiers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param inputString - The string which will be potentially updated with replacement parameters</span><span class="s3">\n </span><span class="s1">* @param params - The optional list of replaceable parameter values to substitute into the english string</span><span class="s3">\n </span><span class="s1">* @returns - The updated string with any replacement specifiers replaced</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function replaceStringParameters(inputString, params) {</span><span class="s3">\n    </span><span class="s1">let output = inputString;</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(params)) {</span><span class="s3">\n        </span><span class="s1">const parts = output.split(/(%</span><span class="s3">\\</span><span class="s1">d)/);</span><span class="s3">\n        </span><span class="s1">params.forEach((param, index) =&gt; {</span><span class="s3">\n            </span><span class="s1">const partIndex = parts.findIndex((part) =&gt; part === `%${index + 1}`);</span><span class="s3">\n            </span><span class="s1">if (partIndex &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">parts[partIndex] = param;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">output = parts.join('');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return output;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=replaceStringParameters.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import replaceStringParameters from './replaceStringParameters';</span><span class="s3">\n</span><span class="s1">/** Translates a `TranslatableString` value `stringToTranslate` into english. When a `params` array is provided, each</span><span class="s3">\n </span><span class="s1">* value in the array is used to replace any of the replaceable parameters in the `stringToTranslate` using the `%1`,</span><span class="s3">\n </span><span class="s1">* `%2`, etc. replacement specifiers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param stringToTranslate - The `TranslatableString` value to convert to english</span><span class="s3">\n </span><span class="s1">* @param params - The optional list of replaceable parameter values to substitute into the english string</span><span class="s3">\n </span><span class="s1">* @returns - The `stringToTranslate` itself with any replaceable parameter values substituted</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function englishStringTranslator(stringToTranslate, params) {</span><span class="s3">\n    </span><span class="s1">return replaceStringParameters(stringToTranslate, params);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=englishStringTranslator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Returns the value(s) from `allEnumOptions` at the index(es) provided by `valueIndex`. If `valueIndex` is not an</span><span class="s3">\n </span><span class="s1">* array AND the index is not valid for `allEnumOptions`, `emptyValue` is returned. If `valueIndex` is an array, AND it</span><span class="s3">\n </span><span class="s1">* contains an invalid index, the returned array will have the resulting undefined values filtered out, leaving only</span><span class="s3">\n </span><span class="s1">* valid values or in the worst case, an empty array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param valueIndex - The index(es) of the value(s) that should be returned</span><span class="s3">\n </span><span class="s1">* @param [allEnumOptions=[]] - The list of all the known enumOptions</span><span class="s3">\n </span><span class="s1">* @param [emptyValue] - The value to return when the non-array `valueIndex` does not refer to a real option</span><span class="s3">\n </span><span class="s1">* @returns - The single or list of values specified by the single or list of indexes if they are valid. Otherwise,</span><span class="s3">\n </span><span class="s1">*        `emptyValue` or an empty list.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function enumOptionsValueForIndex(valueIndex, allEnumOptions = [], emptyValue) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(valueIndex)) {</span><span class="s3">\n        </span><span class="s1">return valueIndex.map((index) =&gt; enumOptionsValueForIndex(index, allEnumOptions)).filter((val) =&gt; val);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// So Number(null) and Number('') both return 0, so use emptyValue for those two values</span><span class="s3">\n    </span><span class="s1">const index = valueIndex === '' || valueIndex === null ? -1 : Number(valueIndex);</span><span class="s3">\n    </span><span class="s1">const option = allEnumOptions[index];</span><span class="s3">\n    </span><span class="s1">return option ? option.value : emptyValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enumOptionsValueForIndex.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import enumOptionsValueForIndex from './enumOptionsValueForIndex';</span><span class="s3">\n</span><span class="s1">/** Removes the enum option value at the `valueIndex` from the currently `selected` (list of) value(s). If `selected` is</span><span class="s3">\n </span><span class="s1">* a list, then that list is updated to remove the enum option value with the `valueIndex` in `allEnumOptions`. If it is</span><span class="s3">\n </span><span class="s1">* a single value, then if the enum option value with the `valueIndex` in `allEnumOptions` matches `selected`, undefined</span><span class="s3">\n </span><span class="s1">* is returned, otherwise the `selected` value is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param valueIndex - The index of the value to be removed from the selected list or single value</span><span class="s3">\n </span><span class="s1">* @param selected - The current (list of) selected value(s)</span><span class="s3">\n </span><span class="s1">* @param [allEnumOptions=[]] - The list of all the known enumOptions</span><span class="s3">\n </span><span class="s1">* @returns - The updated `selected` with the enum option value at `valueIndex` in `allEnumOptions` removed from it,</span><span class="s3">\n </span><span class="s1">*        unless `selected` is a single value. In that case, if the `valueIndex` value matches `selected`, returns</span><span class="s3">\n </span><span class="s1">*        undefined, otherwise `selected`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function enumOptionsDeselectValue(valueIndex, selected, allEnumOptions = []) {</span><span class="s3">\n    </span><span class="s1">const value = enumOptionsValueForIndex(valueIndex, allEnumOptions);</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(selected)) {</span><span class="s3">\n        </span><span class="s1">return selected.filter((v) =&gt; !isEqual(v, value));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isEqual(value, selected) ? undefined : selected;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enumOptionsDeselectValue.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">/** Determines whether the given `value` is (one of) the `selected` value(s).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The value being checked to see if it is selected</span><span class="s3">\n </span><span class="s1">* @param selected - The current selected value or list of values</span><span class="s3">\n </span><span class="s1">* @returns - true if the `value` is one of the `selected` ones, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function enumOptionsIsSelected(value, selected) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(selected)) {</span><span class="s3">\n        </span><span class="s1">return selected.some((sel) =&gt; isEqual(sel, value));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return isEqual(selected, value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enumOptionsIsSelected.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import enumOptionsIsSelected from './enumOptionsIsSelected';</span><span class="s3">\n</span><span class="s1">/** Returns the index(es) of the options in `allEnumOptions` whose value(s) match the ones in `value`. All the</span><span class="s3">\n </span><span class="s1">* `enumOptions` are filtered based on whether they are a </span><span class="s3">\&quot;</span><span class="s1">selected</span><span class="s3">\&quot; </span><span class="s1">`value` and the index of each selected one is then</span><span class="s3">\n </span><span class="s1">* stored in an array. If `multiple` is true, that array is returned, otherwise the first element in the array is</span><span class="s3">\n </span><span class="s1">* returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param value - The single value or list of values for which indexes are desired</span><span class="s3">\n </span><span class="s1">* @param [allEnumOptions=[]] - The list of all the known enumOptions</span><span class="s3">\n </span><span class="s1">* @param [multiple=false] - Optional flag, if true will return a list of index, otherwise a single one</span><span class="s3">\n </span><span class="s1">* @returns - A single string index for the first `value` in `allEnumOptions`, if not `multiple`. Otherwise, the list</span><span class="s3">\n </span><span class="s1">*        of indexes for (each of) the value(s) in `value`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function enumOptionsIndexForValue(value, allEnumOptions = [], multiple = false) {</span><span class="s3">\n    </span><span class="s1">const selectedIndexes = allEnumOptions</span><span class="s3">\n        </span><span class="s1">.map((opt, index) =&gt; (enumOptionsIsSelected(opt.value, value) ? String(index) : undefined))</span><span class="s3">\n        </span><span class="s1">.filter((opt) =&gt; typeof opt !== 'undefined');</span><span class="s3">\n    </span><span class="s1">if (!multiple) {</span><span class="s3">\n        </span><span class="s1">return selectedIndexes[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return selectedIndexes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enumOptionsIndexForValue.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import enumOptionsValueForIndex from './enumOptionsValueForIndex';</span><span class="s3">\n</span><span class="s1">import isNil from 'lodash/isNil';</span><span class="s3">\n</span><span class="s1">/** Add the enum option value at the `valueIndex` to the list of `selected` values in the proper order as defined by</span><span class="s3">\n </span><span class="s1">* `allEnumOptions`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param valueIndex - The index of the value that should be selected</span><span class="s3">\n </span><span class="s1">* @param selected - The current list of selected values</span><span class="s3">\n </span><span class="s1">* @param [allEnumOptions=[]] - The list of all the known enumOptions</span><span class="s3">\n </span><span class="s1">* @returns - The updated list of selected enum values with enum value at the `valueIndex` added to it</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function enumOptionsSelectValue(valueIndex, selected, allEnumOptions = []) {</span><span class="s3">\n    </span><span class="s1">const value = enumOptionsValueForIndex(valueIndex, allEnumOptions);</span><span class="s3">\n    </span><span class="s1">if (!isNil(value)) {</span><span class="s3">\n        </span><span class="s1">const index = allEnumOptions.findIndex((opt) =&gt; value === opt.value);</span><span class="s3">\n        </span><span class="s1">const all = allEnumOptions.map(({ value: val }) =&gt; val);</span><span class="s3">\n        </span><span class="s1">const updated = selected.slice(0, index).concat(value, selected.slice(index));</span><span class="s3">\n        </span><span class="s1">// As inserting values at predefined index positions doesn't work with empty</span><span class="s3">\n        </span><span class="s1">// arrays, we need to reorder the updated selection to match the initial order</span><span class="s3">\n        </span><span class="s1">return updated.sort((a, b) =&gt; Number(all.indexOf(a) &gt; all.indexOf(b)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return selected;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enumOptionsSelectValue.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import cloneDeep from 'lodash/cloneDeep';</span><span class="s3">\n</span><span class="s1">import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import { ERRORS_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** The `ErrorSchemaBuilder&lt;T&gt;` is used to build an `ErrorSchema&lt;T&gt;` since the definition of the `ErrorSchema` type is</span><span class="s3">\n </span><span class="s1">* designed for reading information rather than writing it. Use this class to add, replace or clear errors in an error</span><span class="s3">\n </span><span class="s1">* schema by using either dotted path or an array of path names. Once you are done building the `ErrorSchema`, you can</span><span class="s3">\n </span><span class="s1">* get the result and/or reset all the errors back to an initial set and start again.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class ErrorSchemaBuilder {</span><span class="s3">\n    </span><span class="s1">/** Construct an `ErrorSchemaBuilder` with an optional initial set of errors in an `ErrorSchema`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param [initialSchema] - The optional set of initial errors, that will be cloned into the class</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(initialSchema) {</span><span class="s3">\n        </span><span class="s1">/** The error schema being built</span><span class="s3">\n         </span><span class="s1">*</span><span class="s3">\n         </span><span class="s1">* @private</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.errorSchema = {};</span><span class="s3">\n        </span><span class="s1">this.resetAllErrors(initialSchema);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the `ErrorSchema` that has been updated by the methods of the `ErrorSchemaBuilder`</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get ErrorSchema() {</span><span class="s3">\n        </span><span class="s1">return this.errorSchema;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Will get an existing `ErrorSchema` at the specified `pathOfError` or create and return one.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)</span><span class="s3">\n     </span><span class="s1">* @returns - The error block for the given `pathOfError` or the root if not provided</span><span class="s3">\n     </span><span class="s1">* @private</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getOrCreateErrorBlock(pathOfError) {</span><span class="s3">\n        </span><span class="s1">const hasPath = (Array.isArray(pathOfError) &amp;&amp; pathOfError.length &gt; 0) || typeof pathOfError === 'string';</span><span class="s3">\n        </span><span class="s1">let errorBlock = hasPath ? get(this.errorSchema, pathOfError) : this.errorSchema;</span><span class="s3">\n        </span><span class="s1">if (!errorBlock &amp;&amp; pathOfError) {</span><span class="s3">\n            </span><span class="s1">errorBlock = {};</span><span class="s3">\n            </span><span class="s1">set(this.errorSchema, pathOfError, errorBlock);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return errorBlock;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Resets all errors in the `ErrorSchemaBuilder` back to the `initialSchema` if provided, otherwise an empty set.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param [initialSchema] - The optional set of initial errors, that will be cloned into the class</span><span class="s3">\n     </span><span class="s1">* @returns - The `ErrorSchemaBuilder` object for chaining purposes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">resetAllErrors(initialSchema) {</span><span class="s3">\n        </span><span class="s1">this.errorSchema = initialSchema ? cloneDeep(initialSchema) : {};</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Adds the `errorOrList` to the list of errors in the `ErrorSchema` at either the root level or the location within</span><span class="s3">\n     </span><span class="s1">* the schema described by the `pathOfError`. For more information about how to specify the path see the</span><span class="s3">\n     </span><span class="s1">* [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param errorOrList - The error or list of errors to add into the `ErrorSchema`</span><span class="s3">\n     </span><span class="s1">* @param [pathOfError] - The optional path into the `ErrorSchema` at which to add the error(s)</span><span class="s3">\n     </span><span class="s1">* @returns - The `ErrorSchemaBuilder` object for chaining purposes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addErrors(errorOrList, pathOfError) {</span><span class="s3">\n        </span><span class="s1">const errorBlock = this.getOrCreateErrorBlock(pathOfError);</span><span class="s3">\n        </span><span class="s1">let errorsList = get(errorBlock, ERRORS_KEY);</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(errorsList)) {</span><span class="s3">\n            </span><span class="s1">errorsList = [];</span><span class="s3">\n            </span><span class="s1">errorBlock[ERRORS_KEY] = errorsList;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(errorOrList)) {</span><span class="s3">\n            </span><span class="s1">errorsList.push(...errorOrList);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">errorsList.push(errorOrList);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Sets/replaces the `errorOrList` as the error(s) in the `ErrorSchema` at either the root level or the location</span><span class="s3">\n     </span><span class="s1">* within the schema described by the `pathOfError`. For more information about how to specify the path see the</span><span class="s3">\n     </span><span class="s1">* [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param errorOrList - The error or list of errors to set into the `ErrorSchema`</span><span class="s3">\n     </span><span class="s1">* @param [pathOfError] - The optional path into the `ErrorSchema` at which to set the error(s)</span><span class="s3">\n     </span><span class="s1">* @returns - The `ErrorSchemaBuilder` object for chaining purposes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setErrors(errorOrList, pathOfError) {</span><span class="s3">\n        </span><span class="s1">const errorBlock = this.getOrCreateErrorBlock(pathOfError);</span><span class="s3">\n        </span><span class="s1">// Effectively clone the array being given to prevent accidental outside manipulation of the given list</span><span class="s3">\n        </span><span class="s1">const listToAdd = Array.isArray(errorOrList) ? [...errorOrList] : [errorOrList];</span><span class="s3">\n        </span><span class="s1">set(errorBlock, ERRORS_KEY, listToAdd);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Clears the error(s) in the `ErrorSchema` at either the root level or the location within the schema described by</span><span class="s3">\n     </span><span class="s1">* the `pathOfError`. For more information about how to specify the path see the</span><span class="s3">\n     </span><span class="s1">* [eslint lodash plugin docs](https://github.com/wix/eslint-plugin-lodash/blob/master/docs/rules/path-style.md).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param [pathOfError] - The optional path into the `ErrorSchema` at which to clear the error(s)</span><span class="s3">\n     </span><span class="s1">* @returns - The `ErrorSchemaBuilder` object for chaining purposes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clearErrors(pathOfError) {</span><span class="s3">\n        </span><span class="s1">const errorBlock = this.getOrCreateErrorBlock(pathOfError);</span><span class="s3">\n        </span><span class="s1">set(errorBlock, ERRORS_KEY, []);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ErrorSchemaBuilder.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Given date &amp; time information with optional yearRange &amp; format, returns props for DateElement</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param date - Object containing date with optional time information</span><span class="s3">\n </span><span class="s1">* @param time - Determines whether to include time or not</span><span class="s3">\n </span><span class="s1">* @param [yearRange=[1900, new Date().getFullYear() + 2]] - Controls the list of years to be displayed</span><span class="s3">\n </span><span class="s1">* @param [format='YMD'] - Controls the order in which day, month and year input element will be displayed</span><span class="s3">\n </span><span class="s1">* @returns Array of props for DateElement</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getDateElementProps(date, time, yearRange = [1900, new Date().getFullYear() + 2], format = 'YMD') {</span><span class="s3">\n    </span><span class="s1">const { day, month, year, hour, minute, second } = date;</span><span class="s3">\n    </span><span class="s1">const dayObj = { type: 'day', range: [1, 31], value: day };</span><span class="s3">\n    </span><span class="s1">const monthObj = { type: 'month', range: [1, 12], value: month };</span><span class="s3">\n    </span><span class="s1">const yearObj = { type: 'year', range: yearRange, value: year };</span><span class="s3">\n    </span><span class="s1">const dateElementProp = [];</span><span class="s3">\n    </span><span class="s1">switch (format) {</span><span class="s3">\n        </span><span class="s1">case 'MDY':</span><span class="s3">\n            </span><span class="s1">dateElementProp.push(monthObj, dayObj, yearObj);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'DMY':</span><span class="s3">\n            </span><span class="s1">dateElementProp.push(dayObj, monthObj, yearObj);</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">case 'YMD':</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">dateElementProp.push(yearObj, monthObj, dayObj);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (time) {</span><span class="s3">\n        </span><span class="s1">dateElementProp.push({ type: 'hour', range: [0, 23], value: hour }, { type: 'minute', range: [0, 59], value: minute }, { type: 'second', range: [0, 59], value: second });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return dateElementProp;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getDateElementProps.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Extracts the range spec information `{ step?: number, min?: number, max?: number }` that can be spread onto an HTML</span><span class="s3">\n </span><span class="s1">* input from the range analog in the schema `{ multipleOf?: number, minimum?: number, maximum?: number }`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which to extract the range spec</span><span class="s3">\n </span><span class="s1">* @returns - A range specification from the schema</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function rangeSpec(schema) {</span><span class="s3">\n    </span><span class="s1">const spec = {};</span><span class="s3">\n    </span><span class="s1">if (schema.multipleOf) {</span><span class="s3">\n        </span><span class="s1">spec.step = schema.multipleOf;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schema.minimum || schema.minimum === 0) {</span><span class="s3">\n        </span><span class="s1">spec.min = schema.minimum;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schema.maximum || schema.maximum === 0) {</span><span class="s3">\n        </span><span class="s1">spec.max = schema.maximum;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return spec;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=rangeSpec.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import rangeSpec from './rangeSpec';</span><span class="s3">\n</span><span class="s1">/** Using the `schema`, `defaultType` and `options`, extract out the props for the &lt;input&gt; element that make sense.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for the field provided by the widget</span><span class="s3">\n </span><span class="s1">* @param [defaultType] - The default type, if any, for the field provided by the widget</span><span class="s3">\n </span><span class="s1">* @param [options={}] - The UI Options for the field provided by the widget</span><span class="s3">\n </span><span class="s1">* @param [autoDefaultStepAny=true] - Determines whether to auto-default step=any when the type is number and no step</span><span class="s3">\n </span><span class="s1">* @returns - The extracted `InputPropsType` object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getInputProps(schema, defaultType, options = {}, autoDefaultStepAny = true) {</span><span class="s3">\n    </span><span class="s1">const inputProps = {</span><span class="s3">\n        </span><span class="s1">type: defaultType || 'text',</span><span class="s3">\n        </span><span class="s1">...rangeSpec(schema),</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">// If options.inputType is set use that as the input type</span><span class="s3">\n    </span><span class="s1">if (options.inputType) {</span><span class="s3">\n        </span><span class="s1">inputProps.type = options.inputType;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!defaultType) {</span><span class="s3">\n        </span><span class="s1">// If the schema is of type number or integer, set the input type to number</span><span class="s3">\n        </span><span class="s1">if (schema.type === 'number') {</span><span class="s3">\n            </span><span class="s1">inputProps.type = 'number';</span><span class="s3">\n            </span><span class="s1">// Only add step if one isn't already defined and we are auto-defaulting the </span><span class="s3">\&quot;</span><span class="s1">any</span><span class="s3">\&quot; </span><span class="s1">step</span><span class="s3">\n            </span><span class="s1">if (autoDefaultStepAny &amp;&amp; inputProps.step === undefined) {</span><span class="s3">\n                </span><span class="s1">// Setting step to 'any' fixes a bug in Safari where decimals are not</span><span class="s3">\n                </span><span class="s1">// allowed in number inputs</span><span class="s3">\n                </span><span class="s1">inputProps.step = 'any';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (schema.type === 'integer') {</span><span class="s3">\n            </span><span class="s1">inputProps.type = 'number';</span><span class="s3">\n            </span><span class="s1">// Only add step if one isn't already defined</span><span class="s3">\n            </span><span class="s1">if (inputProps.step === undefined) {</span><span class="s3">\n                </span><span class="s1">// Since this is integer, you always want to step up or down in multiples of 1</span><span class="s3">\n                </span><span class="s1">inputProps.step = 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (options.autocomplete) {</span><span class="s3">\n        </span><span class="s1">inputProps.autoComplete = options.autocomplete;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return inputProps;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getInputProps.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { SUBMIT_BTN_OPTIONS_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">import getUiOptions from './getUiOptions';</span><span class="s3">\n</span><span class="s1">/** The default submit button options, exported for testing purposes</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const DEFAULT_OPTIONS = {</span><span class="s3">\n    </span><span class="s1">props: {</span><span class="s3">\n        </span><span class="s1">disabled: false,</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">submitText: 'Submit',</span><span class="s3">\n    </span><span class="s1">norender: false,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/** Extracts any `ui:submitButtonOptions` from the `uiSchema` and merges them onto the `DEFAULT_OPTIONS`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param [uiSchema={}] - the UI Schema from which to extract submit button props</span><span class="s3">\n </span><span class="s1">* @returns - The merging of the `DEFAULT_OPTIONS` with any custom ones</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getSubmitButtonOptions(uiSchema = {}) {</span><span class="s3">\n    </span><span class="s1">const uiOptions = getUiOptions(uiSchema);</span><span class="s3">\n    </span><span class="s1">if (uiOptions &amp;&amp; uiOptions[SUBMIT_BTN_OPTIONS_KEY]) {</span><span class="s3">\n        </span><span class="s1">const options = uiOptions[SUBMIT_BTN_OPTIONS_KEY];</span><span class="s3">\n        </span><span class="s1">return { ...DEFAULT_OPTIONS, ...options };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return DEFAULT_OPTIONS;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getSubmitButtonOptions.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Returns the template with the given `name` from either the `uiSchema` if it is defined or from the `registry`</span><span class="s3">\n </span><span class="s1">* otherwise. NOTE, since `ButtonTemplates` are not overridden in `uiSchema` only those in the `registry` are returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param name - The name of the template to fetch, restricted to the keys of `TemplatesType`</span><span class="s3">\n </span><span class="s1">* @param registry - The `Registry` from which to read the template</span><span class="s3">\n </span><span class="s1">* @param [uiOptions={}] - The `UIOptionsType` from which to read an alternate template</span><span class="s3">\n </span><span class="s1">* @returns - The template from either the `uiSchema` or `registry` for the `name`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getTemplate(name, registry, uiOptions = {}) {</span><span class="s3">\n    </span><span class="s1">const { templates } = registry;</span><span class="s3">\n    </span><span class="s1">if (name === 'ButtonTemplates') {</span><span class="s3">\n        </span><span class="s1">return templates[name];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return (</span><span class="s3">\n    </span><span class="s1">// Evaluating uiOptions[name] results in TS2590: Expression produces a union type that is too complex to represent</span><span class="s3">\n    </span><span class="s1">// To avoid that, we cast uiOptions to `any` before accessing the name field</span><span class="s3">\n    </span><span class="s1">uiOptions[name] || templates[name]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getTemplate.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { jsx as _jsx } from </span><span class="s3">\&quot;</span><span class="s1">react/jsx-runtime</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { createElement } from 'react';</span><span class="s3">\n</span><span class="s1">import ReactIs from 'react-is';</span><span class="s3">\n</span><span class="s1">import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import set from 'lodash/set';</span><span class="s3">\n</span><span class="s1">import getSchemaType from './getSchemaType';</span><span class="s3">\n</span><span class="s1">/** The map of schema types to widget type to widget name</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const widgetMap = {</span><span class="s3">\n    </span><span class="s1">boolean: {</span><span class="s3">\n        </span><span class="s1">checkbox: 'CheckboxWidget',</span><span class="s3">\n        </span><span class="s1">radio: 'RadioWidget',</span><span class="s3">\n        </span><span class="s1">select: 'SelectWidget',</span><span class="s3">\n        </span><span class="s1">hidden: 'HiddenWidget',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">string: {</span><span class="s3">\n        </span><span class="s1">text: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">password: 'PasswordWidget',</span><span class="s3">\n        </span><span class="s1">email: 'EmailWidget',</span><span class="s3">\n        </span><span class="s1">hostname: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">ipv4: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">ipv6: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">uri: 'URLWidget',</span><span class="s3">\n        </span><span class="s1">'data-url': 'FileWidget',</span><span class="s3">\n        </span><span class="s1">radio: 'RadioWidget',</span><span class="s3">\n        </span><span class="s1">select: 'SelectWidget',</span><span class="s3">\n        </span><span class="s1">textarea: 'TextareaWidget',</span><span class="s3">\n        </span><span class="s1">hidden: 'HiddenWidget',</span><span class="s3">\n        </span><span class="s1">date: 'DateWidget',</span><span class="s3">\n        </span><span class="s1">datetime: 'DateTimeWidget',</span><span class="s3">\n        </span><span class="s1">'date-time': 'DateTimeWidget',</span><span class="s3">\n        </span><span class="s1">'alt-date': 'AltDateWidget',</span><span class="s3">\n        </span><span class="s1">'alt-datetime': 'AltDateTimeWidget',</span><span class="s3">\n        </span><span class="s1">time: 'TimeWidget',</span><span class="s3">\n        </span><span class="s1">color: 'ColorWidget',</span><span class="s3">\n        </span><span class="s1">file: 'FileWidget',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">number: {</span><span class="s3">\n        </span><span class="s1">text: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">select: 'SelectWidget',</span><span class="s3">\n        </span><span class="s1">updown: 'UpDownWidget',</span><span class="s3">\n        </span><span class="s1">range: 'RangeWidget',</span><span class="s3">\n        </span><span class="s1">radio: 'RadioWidget',</span><span class="s3">\n        </span><span class="s1">hidden: 'HiddenWidget',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">integer: {</span><span class="s3">\n        </span><span class="s1">text: 'TextWidget',</span><span class="s3">\n        </span><span class="s1">select: 'SelectWidget',</span><span class="s3">\n        </span><span class="s1">updown: 'UpDownWidget',</span><span class="s3">\n        </span><span class="s1">range: 'RangeWidget',</span><span class="s3">\n        </span><span class="s1">radio: 'RadioWidget',</span><span class="s3">\n        </span><span class="s1">hidden: 'HiddenWidget',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">array: {</span><span class="s3">\n        </span><span class="s1">select: 'SelectWidget',</span><span class="s3">\n        </span><span class="s1">checkboxes: 'CheckboxesWidget',</span><span class="s3">\n        </span><span class="s1">files: 'FileWidget',</span><span class="s3">\n        </span><span class="s1">hidden: 'HiddenWidget',</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/** Wraps the given widget with stateless functional component that will merge any `defaultProps.options` with the</span><span class="s3">\n </span><span class="s1">* `options` that are provided in the props. It will add the wrapper component as a `MergedWidget` property onto the</span><span class="s3">\n </span><span class="s1">* `Widget` so that future attempts to wrap `AWidget` will return the already existing wrapper.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param AWidget - A widget that will be wrapped or one that is already wrapped</span><span class="s3">\n </span><span class="s1">* @returns - The wrapper widget</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mergeWidgetOptions(AWidget) {</span><span class="s3">\n    </span><span class="s1">let MergedWidget = get(AWidget, 'MergedWidget');</span><span class="s3">\n    </span><span class="s1">// cache return value as property of widget for proper react reconciliation</span><span class="s3">\n    </span><span class="s1">if (!MergedWidget) {</span><span class="s3">\n        </span><span class="s1">const defaultOptions = (AWidget.defaultProps &amp;&amp; AWidget.defaultProps.options) || {};</span><span class="s3">\n        </span><span class="s1">MergedWidget = ({ options, ...props }) =&gt; {</span><span class="s3">\n            </span><span class="s1">return _jsx(AWidget, { options: { ...defaultOptions, ...options }, ...props });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">set(AWidget, 'MergedWidget', MergedWidget);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return MergedWidget;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Given a schema representing a field to render and either the name or actual `Widget` implementation, returns the</span><span class="s3">\n </span><span class="s1">* React component that is used to render the widget. If the `widget` is already a React component, then it is wrapped</span><span class="s3">\n </span><span class="s1">* with a `MergedWidget`. Otherwise an attempt is made to look up the widget inside of the `registeredWidgets` map based</span><span class="s3">\n </span><span class="s1">* on the schema type and `widget` name. If no widget component can be found an `Error` is thrown.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for the field</span><span class="s3">\n </span><span class="s1">* @param [widget] - Either the name of the widget OR a `Widget` implementation to use</span><span class="s3">\n </span><span class="s1">* @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation</span><span class="s3">\n </span><span class="s1">* @returns - The `Widget` component to use</span><span class="s3">\n </span><span class="s1">* @throws - An error if there is no `Widget` component that can be returned</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function getWidget(schema, widget, registeredWidgets = {}) {</span><span class="s3">\n    </span><span class="s1">const type = getSchemaType(schema);</span><span class="s3">\n    </span><span class="s1">if (typeof widget === 'function' ||</span><span class="s3">\n        </span><span class="s1">(widget &amp;&amp; ReactIs.isForwardRef(createElement(widget))) ||</span><span class="s3">\n        </span><span class="s1">ReactIs.isMemo(widget)) {</span><span class="s3">\n        </span><span class="s1">return mergeWidgetOptions(widget);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof widget !== 'string') {</span><span class="s3">\n        </span><span class="s1">throw new Error(`Unsupported widget definition: ${typeof widget}`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (widget in registeredWidgets) {</span><span class="s3">\n        </span><span class="s1">const registeredWidget = registeredWidgets[widget];</span><span class="s3">\n        </span><span class="s1">return getWidget(schema, registeredWidget, registeredWidgets);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (typeof type === 'string') {</span><span class="s3">\n        </span><span class="s1">if (!(type in widgetMap)) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`No widget for type '${type}'`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (widget in widgetMap[type]) {</span><span class="s3">\n            </span><span class="s1">const registeredWidget = registeredWidgets[widgetMap[type][widget]];</span><span class="s3">\n            </span><span class="s1">return getWidget(schema, registeredWidget, registeredWidgets);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error(`No widget '${widget}' for type '${type}'`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=getWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** JS has no built-in hashing function, so rolling our own</span><span class="s3">\n </span><span class="s1">*  based on Java's hashing fn:</span><span class="s3">\n </span><span class="s1">*  http://www.java2s.com/example/nodejs-utility-method/string-hash/hashcode-4dc2b.html</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param string - The string for which to get the hash</span><span class="s3">\n </span><span class="s1">* @returns - The resulting hash of the string in hex format</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function hashString(string) {</span><span class="s3">\n    </span><span class="s1">let hash = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; string.length; i += 1) {</span><span class="s3">\n        </span><span class="s1">const chr = string.charCodeAt(i);</span><span class="s3">\n        </span><span class="s1">hash = (hash &lt;&lt; 5) - hash + chr;</span><span class="s3">\n        </span><span class="s1">hash = hash &amp; hash; // Convert to 32bit integer</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return hash.toString(16);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Stringifies the schema and returns the hash of the resulting string. Sorts schema fields</span><span class="s3">\n </span><span class="s1">* in consistent order before stringify to prevent different hash ids for the same schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for which the hash is desired</span><span class="s3">\n </span><span class="s1">* @returns - The string obtained from the hash of the stringified schema</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function hashForSchema(schema) {</span><span class="s3">\n    </span><span class="s1">const allKeys = new Set();</span><span class="s3">\n    </span><span class="s1">// solution source: https://stackoverflow.com/questions/16167581/sort-object-properties-and-json-stringify/53593328#53593328</span><span class="s3">\n    </span><span class="s1">JSON.stringify(schema, (key, value) =&gt; (allKeys.add(key), value));</span><span class="s3">\n    </span><span class="s1">return hashString(JSON.stringify(schema, Array.from(allKeys).sort()));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=hashForSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import getWidget from './getWidget';</span><span class="s3">\n</span><span class="s1">/** Detects whether the `widget` exists for the `schema` with the associated `registryWidgets` and returns true if it</span><span class="s3">\n </span><span class="s1">* does, or false if it doesn't.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema for the field</span><span class="s3">\n </span><span class="s1">* @param widget - Either the name of the widget OR a `Widget` implementation to use</span><span class="s3">\n </span><span class="s1">* @param [registeredWidgets={}] - A registry of widget name to `Widget` implementation</span><span class="s3">\n </span><span class="s1">* @returns - True if the widget exists, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function hasWidget(schema, widget, registeredWidgets = {}) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">getWidget(schema, widget, registeredWidgets);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (e) {</span><span class="s3">\n        </span><span class="s1">const err = e;</span><span class="s3">\n        </span><span class="s1">if (err.message &amp;&amp; (err.message.startsWith('No widget') || err.message.startsWith('Unsupported widget'))) {</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">throw e;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=hasWidget.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isString from 'lodash/isString';</span><span class="s3">\n</span><span class="s1">import { ID_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Generates a consistent `id` pattern for a given `id` and a `suffix`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @param suffix - The suffix to append to the id</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function idGenerator(id, suffix) {</span><span class="s3">\n    </span><span class="s1">const theId = isString(id) ? id : id[ID_KEY];</span><span class="s3">\n    </span><span class="s1">return `${theId}__${suffix}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the field description element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @returns - The consistent id for the field description element from the given `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function descriptionId(id) {</span><span class="s3">\n    </span><span class="s1">return idGenerator(id, 'description');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the field error element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @returns - The consistent id for the field error element from the given `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function errorId(id) {</span><span class="s3">\n    </span><span class="s1">return idGenerator(id, 'error');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the field examples element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @returns - The consistent id for the field examples element from the given `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function examplesId(id) {</span><span class="s3">\n    </span><span class="s1">return idGenerator(id, 'examples');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the field help element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @returns - The consistent id for the field help element from the given `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function helpId(id) {</span><span class="s3">\n    </span><span class="s1">return idGenerator(id, 'help');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the field title element</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @returns - The consistent id for the field title element from the given `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function titleId(id) {</span><span class="s3">\n    </span><span class="s1">return idGenerator(id, 'title');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a list of element ids that contain additional information about the field that can be used to as the aria</span><span class="s3">\n </span><span class="s1">* description of the field. This is correctly omitting `titleId` which would be </span><span class="s3">\&quot;</span><span class="s1">labeling</span><span class="s3">\&quot; </span><span class="s1">rather than </span><span class="s3">\&quot;</span><span class="s1">describing</span><span class="s3">\&quot; </span><span class="s1">the</span><span class="s3">\n </span><span class="s1">* element.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - Either simple string id or an IdSchema from which to extract it</span><span class="s3">\n </span><span class="s1">* @param [includeExamples=false] - Optional flag, if true, will add the `examplesId` into the list</span><span class="s3">\n </span><span class="s1">* @returns - The string containing the list of ids for use in an `aria-describedBy` attribute</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function ariaDescribedByIds(id, includeExamples = false) {</span><span class="s3">\n    </span><span class="s1">const examples = includeExamples ? ` ${examplesId(id)}` : '';</span><span class="s3">\n    </span><span class="s1">return `${errorId(id)} ${descriptionId(id)} ${helpId(id)}${examples}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Return a consistent `id` for the `optionIndex`s of a `Radio` or `Checkboxes` widget</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param id - The id of the parent component for the option</span><span class="s3">\n </span><span class="s1">* @param optionIndex - The index of the option for which the id is desired</span><span class="s3">\n </span><span class="s1">* @returns - An id for the option index based on the parent `id`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export function optionId(id, optionIndex) {</span><span class="s3">\n    </span><span class="s1">return `${id}-${optionIndex}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=idGenerators.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;export default function labelValue(label, hideLabel, fallback) {</span><span class="s3">\n    </span><span class="s1">return hideLabel ? fallback : label;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=labelValue.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Converts a local Date string into a UTC date string</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param dateString - The string representation of a date as accepted by the `Date()` constructor</span><span class="s3">\n </span><span class="s1">* @returns - A UTC date string if `dateString` is truthy, otherwise undefined</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function localToUTC(dateString) {</span><span class="s3">\n    </span><span class="s1">return dateString ? new Date(dateString).toJSON() : undefined;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=localToUTC.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { CONST_KEY, ENUM_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Returns the constant value from the schema when it is either a single value enum or has a const key. Otherwise</span><span class="s3">\n </span><span class="s1">* throws an error.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which to obtain the constant value</span><span class="s3">\n </span><span class="s1">* @returns - The constant value for the schema</span><span class="s3">\n </span><span class="s1">* @throws - Error when the schema does not have a constant value</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toConstant(schema) {</span><span class="s3">\n    </span><span class="s1">if (ENUM_KEY in schema &amp;&amp; Array.isArray(schema.enum) &amp;&amp; schema.enum.length === 1) {</span><span class="s3">\n        </span><span class="s1">return schema.enum[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (CONST_KEY in schema) {</span><span class="s3">\n        </span><span class="s1">return schema.const;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">throw new Error('schema cannot be inferred as a constant');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toConstant.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import toConstant from './toConstant';</span><span class="s3">\n</span><span class="s1">/** Gets the list of options from the schema. If the schema has an enum list, then those enum values are returned. The</span><span class="s3">\n </span><span class="s1">* labels for the options will be extracted from the non-standard, RJSF-deprecated `enumNames` if it exists, otherwise</span><span class="s3">\n </span><span class="s1">* the label will be the same as the `value`. If the schema has a `oneOf` or `anyOf`, then the value is the list of</span><span class="s3">\n </span><span class="s1">* `const` values from the schema and the label is either the `schema.title` or the value.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema from which to extract the options list</span><span class="s3">\n </span><span class="s1">* @returns - The list of options from the schema</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function optionsList(schema) {</span><span class="s3">\n    </span><span class="s1">// enumNames was deprecated in v5 and is intentionally omitted from the RJSFSchema type.</span><span class="s3">\n    </span><span class="s1">// Cast the type to include enumNames so the feature still works.</span><span class="s3">\n    </span><span class="s1">const schemaWithEnumNames = schema;</span><span class="s3">\n    </span><span class="s1">if (schemaWithEnumNames.enumNames &amp;&amp; process.env.NODE_ENV !== 'production') {</span><span class="s3">\n        </span><span class="s1">console.warn('The enumNames property is deprecated and may be removed in a future major release.');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (schema.enum) {</span><span class="s3">\n        </span><span class="s1">return schema.enum.map((value, i) =&gt; {</span><span class="s3">\n            </span><span class="s1">const label = (schemaWithEnumNames.enumNames &amp;&amp; schemaWithEnumNames.enumNames[i]) || String(value);</span><span class="s3">\n            </span><span class="s1">return { label, value };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const altSchemas = schema.oneOf || schema.anyOf;</span><span class="s3">\n    </span><span class="s1">return (altSchemas &amp;&amp;</span><span class="s3">\n        </span><span class="s1">altSchemas.map((aSchemaDef) =&gt; {</span><span class="s3">\n            </span><span class="s1">const aSchema = aSchemaDef;</span><span class="s3">\n            </span><span class="s1">const value = toConstant(aSchema);</span><span class="s3">\n            </span><span class="s1">const label = aSchema.title || String(value);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">schema: aSchema,</span><span class="s3">\n                </span><span class="s1">label,</span><span class="s3">\n                </span><span class="s1">value,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=optionsList.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Given a list of `properties` and an `order` list, returns a list that contains the `properties` ordered correctly.</span><span class="s3">\n </span><span class="s1">* If `order` is not an array, then the untouched `properties` list is returned. Otherwise `properties` is ordered per</span><span class="s3">\n </span><span class="s1">* the `order` list. If `order` contains a '*' then any `properties` that are not mentioned explicity in `order` will be</span><span class="s3">\n </span><span class="s1">* places in the location of the `*`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param properties - The list of property keys to be ordered</span><span class="s3">\n </span><span class="s1">* @param order - An array of property keys to be ordered first, with an optional '*' property</span><span class="s3">\n </span><span class="s1">* @returns - A list with the `properties` ordered</span><span class="s3">\n </span><span class="s1">* @throws - Error when the properties cannot be ordered correctly</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function orderProperties(properties, order) {</span><span class="s3">\n    </span><span class="s1">if (!Array.isArray(order)) {</span><span class="s3">\n        </span><span class="s1">return properties;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const arrayToHash = (arr) =&gt; arr.reduce((prev, curr) =&gt; {</span><span class="s3">\n        </span><span class="s1">prev[curr] = true;</span><span class="s3">\n        </span><span class="s1">return prev;</span><span class="s3">\n    </span><span class="s1">}, {});</span><span class="s3">\n    </span><span class="s1">const errorPropList = (arr) =&gt; arr.length &gt; 1 ? `properties '${arr.join(</span><span class="s3">\&quot;</span><span class="s1">', '</span><span class="s3">\&quot;</span><span class="s1">)}'` : `property '${arr[0]}'`;</span><span class="s3">\n    </span><span class="s1">const propertyHash = arrayToHash(properties);</span><span class="s3">\n    </span><span class="s1">const orderFiltered = order.filter((prop) =&gt; prop === '*' || propertyHash[prop]);</span><span class="s3">\n    </span><span class="s1">const orderHash = arrayToHash(orderFiltered);</span><span class="s3">\n    </span><span class="s1">const rest = properties.filter((prop) =&gt; !orderHash[prop]);</span><span class="s3">\n    </span><span class="s1">const restIndex = orderFiltered.indexOf('*');</span><span class="s3">\n    </span><span class="s1">if (restIndex === -1) {</span><span class="s3">\n        </span><span class="s1">if (rest.length) {</span><span class="s3">\n            </span><span class="s1">throw new Error(`uiSchema order list does not contain ${errorPropList(rest)}`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return orderFiltered;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (restIndex !== orderFiltered.lastIndexOf('*')) {</span><span class="s3">\n        </span><span class="s1">throw new Error('uiSchema order list contains more than one wildcard item');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const complete = [...orderFiltered];</span><span class="s3">\n    </span><span class="s1">complete.splice(restIndex, 1, ...rest);</span><span class="s3">\n    </span><span class="s1">return complete;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=orderProperties.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Returns a string representation of the `num` that is padded with leading </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">s if necessary</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param num - The number to pad</span><span class="s3">\n </span><span class="s1">* @param width - The width of the string at which no lead padding is necessary</span><span class="s3">\n </span><span class="s1">* @returns - The number converted to a string with leading zero padding if the number of digits is less than `width`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function pad(num, width) {</span><span class="s3">\n    </span><span class="s1">let s = String(num);</span><span class="s3">\n    </span><span class="s1">while (s.length &lt; width) {</span><span class="s3">\n        </span><span class="s1">s = '0' + s;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return s;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=pad.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Parses the `dateString` into a `DateObject`, including the time information when `includeTime` is true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param dateString - The date string to parse into a DateObject</span><span class="s3">\n </span><span class="s1">* @param [includeTime=true] - Optional flag, if false, will not include the time data into the object</span><span class="s3">\n </span><span class="s1">* @returns - The date string converted to a `DateObject`</span><span class="s3">\n </span><span class="s1">* @throws - Error when the date cannot be parsed from the string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function parseDateString(dateString, includeTime = true) {</span><span class="s3">\n    </span><span class="s1">if (!dateString) {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">year: -1,</span><span class="s3">\n            </span><span class="s1">month: -1,</span><span class="s3">\n            </span><span class="s1">day: -1,</span><span class="s3">\n            </span><span class="s1">hour: includeTime ? -1 : 0,</span><span class="s3">\n            </span><span class="s1">minute: includeTime ? -1 : 0,</span><span class="s3">\n            </span><span class="s1">second: includeTime ? -1 : 0,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const date = new Date(dateString);</span><span class="s3">\n    </span><span class="s1">if (Number.isNaN(date.getTime())) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unable to parse date ' + dateString);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">year: date.getUTCFullYear(),</span><span class="s3">\n        </span><span class="s1">month: date.getUTCMonth() + 1,</span><span class="s3">\n        </span><span class="s1">day: date.getUTCDate(),</span><span class="s3">\n        </span><span class="s1">hour: includeTime ? date.getUTCHours() : 0,</span><span class="s3">\n        </span><span class="s1">minute: includeTime ? date.getUTCMinutes() : 0,</span><span class="s3">\n        </span><span class="s1">second: includeTime ? date.getUTCSeconds() : 0,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=parseDateString.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Check to see if a `schema` specifies that a value must be true. This happens when:</span><span class="s3">\n </span><span class="s1">* - `schema.const` is truthy</span><span class="s3">\n </span><span class="s1">* - `schema.enum` == `[true]`</span><span class="s3">\n </span><span class="s1">* - `schema.anyOf` or `schema.oneOf` has a single value which recursively returns true</span><span class="s3">\n </span><span class="s1">* - `schema.allOf` has at least one value which recursively returns true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schema - The schema to check</span><span class="s3">\n </span><span class="s1">* @returns - True if the schema specifies a value that must be true, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function schemaRequiresTrueValue(schema) {</span><span class="s3">\n    </span><span class="s1">// Check if const is a truthy value</span><span class="s3">\n    </span><span class="s1">if (schema.const) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Check if an enum has a single value of true</span><span class="s3">\n    </span><span class="s1">if (schema.enum &amp;&amp; schema.enum.length === 1 &amp;&amp; schema.enum[0] === true) {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If anyOf has a single value, evaluate the subschema</span><span class="s3">\n    </span><span class="s1">if (schema.anyOf &amp;&amp; schema.anyOf.length === 1) {</span><span class="s3">\n        </span><span class="s1">return schemaRequiresTrueValue(schema.anyOf[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// If oneOf has a single value, evaluate the subschema</span><span class="s3">\n    </span><span class="s1">if (schema.oneOf &amp;&amp; schema.oneOf.length === 1) {</span><span class="s3">\n        </span><span class="s1">return schemaRequiresTrueValue(schema.oneOf[0]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Evaluate each subschema in allOf, to see if one of them requires a true value</span><span class="s3">\n    </span><span class="s1">if (schema.allOf) {</span><span class="s3">\n        </span><span class="s1">const schemaSome = (subSchema) =&gt; schemaRequiresTrueValue(subSchema);</span><span class="s3">\n        </span><span class="s1">return schema.allOf.some(schemaSome);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=schemaRequiresTrueValue.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import deepEquals from './deepEquals';</span><span class="s3">\n</span><span class="s1">/** Determines whether the given `component` should be rerendered by comparing its current set of props and state</span><span class="s3">\n </span><span class="s1">* against the next set. If either of those two sets are not the same, then the component should be rerendered.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param component - A React component being checked</span><span class="s3">\n </span><span class="s1">* @param nextProps - The next set of props against which to check</span><span class="s3">\n </span><span class="s1">* @param nextState - The next set of state against which to check</span><span class="s3">\n </span><span class="s1">* @returns - True if the component should be re-rendered, false otherwise</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function shouldRender(component, nextProps, nextState) {</span><span class="s3">\n    </span><span class="s1">const { props, state } = component;</span><span class="s3">\n    </span><span class="s1">return !deepEquals(props, nextProps) || !deepEquals(state, nextState);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=shouldRender.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Returns a UTC date string for the given `dateObject`. If `time` is false, then the time portion of the string is</span><span class="s3">\n </span><span class="s1">* removed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param dateObject - The `DateObject` to convert to a date string</span><span class="s3">\n </span><span class="s1">* @param [time=true] - Optional flag used to remove the time portion of the date string if false</span><span class="s3">\n </span><span class="s1">* @returns - The UTC date string</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toDateString(dateObject, time = true) {</span><span class="s3">\n    </span><span class="s1">const { year, month, day, hour = 0, minute = 0, second = 0 } = dateObject;</span><span class="s3">\n    </span><span class="s1">const utcTime = Date.UTC(year, month - 1, day, hour, minute, second);</span><span class="s3">\n    </span><span class="s1">const datetime = new Date(utcTime).toJSON();</span><span class="s3">\n    </span><span class="s1">return time ? datetime : datetime.slice(0, 10);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toDateString.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isPlainObject from 'lodash/isPlainObject';</span><span class="s3">\n</span><span class="s1">import { ERRORS_KEY } from './constants';</span><span class="s3">\n</span><span class="s1">/** Converts an `errorSchema` into a list of `RJSFValidationErrors`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param errorSchema - The `ErrorSchema` instance to convert</span><span class="s3">\n </span><span class="s1">* @param [fieldPath=[]] - The current field path, defaults to [] if not specified</span><span class="s3">\n </span><span class="s1">* @returns - The list of `RJSFValidationErrors` extracted from the `errorSchema`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toErrorList(errorSchema, fieldPath = []) {</span><span class="s3">\n    </span><span class="s1">if (!errorSchema) {</span><span class="s3">\n        </span><span class="s1">return [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let errorList = [];</span><span class="s3">\n    </span><span class="s1">if (ERRORS_KEY in errorSchema) {</span><span class="s3">\n        </span><span class="s1">errorList = errorList.concat(errorSchema[ERRORS_KEY].map((message) =&gt; {</span><span class="s3">\n            </span><span class="s1">const property = `.${fieldPath.join('.')}`;</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">property,</span><span class="s3">\n                </span><span class="s1">message,</span><span class="s3">\n                </span><span class="s1">stack: `${property} ${message}`,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return Object.keys(errorSchema).reduce((acc, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (key !== ERRORS_KEY) {</span><span class="s3">\n            </span><span class="s1">const childSchema = errorSchema[key];</span><span class="s3">\n            </span><span class="s1">if (isPlainObject(childSchema)) {</span><span class="s3">\n                </span><span class="s1">acc = acc.concat(toErrorList(childSchema, [...fieldPath, key]));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return acc;</span><span class="s3">\n    </span><span class="s1">}, errorList);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toErrorList.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import toPath from 'lodash/toPath';</span><span class="s3">\n</span><span class="s1">import ErrorSchemaBuilder from './ErrorSchemaBuilder';</span><span class="s3">\n</span><span class="s1">/** Transforms a rjsf validation errors list:</span><span class="s3">\n </span><span class="s1">* [</span><span class="s3">\n </span><span class="s1">*   {property: '.level1.level2[2].level3', message: 'err a'},</span><span class="s3">\n </span><span class="s1">*   {property: '.level1.level2[2].level3', message: 'err b'},</span><span class="s3">\n </span><span class="s1">*   {property: '.level1.level2[4].level3', message: 'err b'},</span><span class="s3">\n </span><span class="s1">* ]</span><span class="s3">\n </span><span class="s1">* Into an error tree:</span><span class="s3">\n </span><span class="s1">* {</span><span class="s3">\n </span><span class="s1">*   level1: {</span><span class="s3">\n </span><span class="s1">*     level2: {</span><span class="s3">\n </span><span class="s1">*       2: {level3: {errors: ['err a', 'err b']}},</span><span class="s3">\n </span><span class="s1">*       4: {level3: {errors: ['err b']}},</span><span class="s3">\n </span><span class="s1">*     }</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param errors - The list of RJSFValidationError objects</span><span class="s3">\n </span><span class="s1">* @returns - The `ErrorSchema` built from the list of `RJSFValidationErrors`</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function toErrorSchema(errors) {</span><span class="s3">\n    </span><span class="s1">const builder = new ErrorSchemaBuilder();</span><span class="s3">\n    </span><span class="s1">if (errors.length) {</span><span class="s3">\n        </span><span class="s1">errors.forEach((error) =&gt; {</span><span class="s3">\n            </span><span class="s1">const { property, message } = error;</span><span class="s3">\n            </span><span class="s1">// When the property is the root element, just use an empty array for the path</span><span class="s3">\n            </span><span class="s1">const path = property === '.' ? [] : toPath(property);</span><span class="s3">\n            </span><span class="s1">// If the property is at the root (.level1) then toPath creates</span><span class="s3">\n            </span><span class="s1">// an empty array element at the first index. Remove it.</span><span class="s3">\n            </span><span class="s1">if (path.length &gt; 0 &amp;&amp; path[0] === '') {</span><span class="s3">\n                </span><span class="s1">path.splice(0, 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (message) {</span><span class="s3">\n                </span><span class="s1">builder.addErrors(message, path);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return builder.ErrorSchema;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=toErrorSchema.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isPlainObject from 'lodash/isPlainObject';</span><span class="s3">\n</span><span class="s1">/** Unwraps the `errorHandler` structure into the associated `ErrorSchema`, stripping the `addError()` functions from it</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param errorHandler - The `FormValidation` error handling structure</span><span class="s3">\n </span><span class="s1">* @returns - The `ErrorSchema` resulting from the stripping of the `addError()` function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function unwrapErrorHandler(errorHandler) {</span><span class="s3">\n    </span><span class="s1">return Object.keys(errorHandler).reduce((acc, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (key === 'addError') {</span><span class="s3">\n            </span><span class="s1">return acc;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const childSchema = errorHandler[key];</span><span class="s3">\n            </span><span class="s1">if (isPlainObject(childSchema)) {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">...acc,</span><span class="s3">\n                    </span><span class="s1">[key]: unwrapErrorHandler(childSchema),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return { ...acc, [key]: childSchema };</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=unwrapErrorHandler.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import pad from './pad';</span><span class="s3">\n</span><span class="s1">/** Converts a UTC date string into a local Date format</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param jsonDate - A UTC date string</span><span class="s3">\n </span><span class="s1">* @returns - An empty string when `jsonDate` is falsey, otherwise a date string in local format</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function utcToLocal(jsonDate) {</span><span class="s3">\n    </span><span class="s1">if (!jsonDate) {</span><span class="s3">\n        </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// required format of `'yyyy-MM-ddThh:mm' followed by optional ':ss' or ':ss.SSS'</span><span class="s3">\n    </span><span class="s1">// https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)</span><span class="s3">\n    </span><span class="s1">// &gt; should be a _valid local date and time string_ (not GMT)</span><span class="s3">\n    </span><span class="s1">// Note - date constructor passed local ISO-8601 does not correctly</span><span class="s3">\n    </span><span class="s1">// change time to UTC in node pre-8</span><span class="s3">\n    </span><span class="s1">const date = new Date(jsonDate);</span><span class="s3">\n    </span><span class="s1">const yyyy = pad(date.getFullYear(), 4);</span><span class="s3">\n    </span><span class="s1">const MM = pad(date.getMonth() + 1, 2);</span><span class="s3">\n    </span><span class="s1">const dd = pad(date.getDate(), 2);</span><span class="s3">\n    </span><span class="s1">const hh = pad(date.getHours(), 2);</span><span class="s3">\n    </span><span class="s1">const mm = pad(date.getMinutes(), 2);</span><span class="s3">\n    </span><span class="s1">const ss = pad(date.getSeconds(), 2);</span><span class="s3">\n    </span><span class="s1">const SSS = pad(date.getMilliseconds(), 3);</span><span class="s3">\n    </span><span class="s1">return `${yyyy}-${MM}-${dd}T${hh}:${mm}:${ss}.${SSS}`;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=utcToLocal.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import isEmpty from 'lodash/isEmpty';</span><span class="s3">\n</span><span class="s1">import mergeObjects from './mergeObjects';</span><span class="s3">\n</span><span class="s1">import toErrorList from './toErrorList';</span><span class="s3">\n</span><span class="s1">/** Merges the errors in `additionalErrorSchema` into the existing `validationData` by combining the hierarchies in the</span><span class="s3">\n </span><span class="s1">* two `ErrorSchema`s and then appending the error list from the `additionalErrorSchema` obtained by calling</span><span class="s3">\n </span><span class="s1">* `toErrorList()` on the `errors` in the `validationData`. If no `additionalErrorSchema` is passed, then</span><span class="s3">\n </span><span class="s1">* `validationData` is returned.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validationData - The current `ValidationData` into which to merge the additional errors</span><span class="s3">\n </span><span class="s1">* @param [additionalErrorSchema] - The optional additional set of errors in an `ErrorSchema`</span><span class="s3">\n </span><span class="s1">* @returns - The `validationData` with the additional errors from `additionalErrorSchema` merged into it, if provided.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function validationDataMerge(validationData, additionalErrorSchema) {</span><span class="s3">\n    </span><span class="s1">if (!additionalErrorSchema) {</span><span class="s3">\n        </span><span class="s1">return validationData;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const { errors: oldErrors, errorSchema: oldErrorSchema } = validationData;</span><span class="s3">\n    </span><span class="s1">let errors = toErrorList(additionalErrorSchema);</span><span class="s3">\n    </span><span class="s1">let errorSchema = additionalErrorSchema;</span><span class="s3">\n    </span><span class="s1">if (!isEmpty(oldErrorSchema)) {</span><span class="s3">\n        </span><span class="s1">errorSchema = mergeObjects(oldErrorSchema, additionalErrorSchema, true);</span><span class="s3">\n        </span><span class="s1">errors = [...oldErrors].concat(errors);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { errorSchema, errors };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=validationDataMerge.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import { REF_KEY, ROOT_SCHEMA_PREFIX } from './constants';</span><span class="s3">\n</span><span class="s1">import isObject from 'lodash/isObject';</span><span class="s3">\n</span><span class="s1">/** Takes a `node` object and transforms any contained `$ref` node variables with a prefix, recursively calling</span><span class="s3">\n </span><span class="s1">* `withIdRefPrefix` for any other elements.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function withIdRefPrefixObject(node) {</span><span class="s3">\n    </span><span class="s1">for (const key in node) {</span><span class="s3">\n        </span><span class="s1">const realObj = node;</span><span class="s3">\n        </span><span class="s1">const value = realObj[key];</span><span class="s3">\n        </span><span class="s1">if (key === REF_KEY &amp;&amp; typeof value === 'string' &amp;&amp; value.startsWith('#')) {</span><span class="s3">\n            </span><span class="s1">realObj[key] = ROOT_SCHEMA_PREFIX + value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">realObj[key] = withIdRefPrefix(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Takes a `node` object list and transforms any contained `$ref` node variables with a prefix, recursively calling</span><span class="s3">\n </span><span class="s1">* `withIdRefPrefix` for any other elements.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param node - The list of object nodes to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function withIdRefPrefixArray(node) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; node.length; i++) {</span><span class="s3">\n        </span><span class="s1">node[i] = withIdRefPrefix(node[i]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Recursively prefixes all `$ref`s in a schema with the value of the `ROOT_SCHEMA_PREFIX` constant.</span><span class="s3">\n </span><span class="s1">* This is used in isValid to make references to the rootSchema</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param schemaNode - The object node to which a ROOT_SCHEMA_PREFIX is added when a REF_KEY is part of it</span><span class="s3">\n </span><span class="s1">* @returns - A copy of the `schemaNode` with updated `$ref`s</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function withIdRefPrefix(schemaNode) {</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(schemaNode)) {</span><span class="s3">\n        </span><span class="s1">return withIdRefPrefixArray([...schemaNode]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isObject(schemaNode)) {</span><span class="s3">\n        </span><span class="s1">return withIdRefPrefixObject({ ...schemaNode });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return schemaNode;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=withIdRefPrefix.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/** An enumeration of all the translatable strings used by `@rjsf/core` and its themes. The value of each of the</span><span class="s3">\n </span><span class="s1">* enumeration keys is expected to be the actual english string. Some strings contain replaceable parameter values</span><span class="s3">\n </span><span class="s1">* as indicated by `%1`, `%2`, etc. The number after the `%` indicates the order of the parameter. The ordering of</span><span class="s3">\n </span><span class="s1">* parameters is important because some languages may choose to put the second parameter before the first in its</span><span class="s3">\n </span><span class="s1">* translation. Also, some strings are rendered using `markdown-to-jsx` and thus support markdown and inline html.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export var TranslatableString;</span><span class="s3">\n</span><span class="s1">(function (TranslatableString) {</span><span class="s3">\n    </span><span class="s1">/** Fallback title of an array item, used by ArrayField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">ArrayItemTitle</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Item</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Missing items reason, used by ArrayField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">MissingItems</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Missing items definition</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Yes label, used by BooleanField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">YesLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Yes</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** No label, used by BooleanField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">NoLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">No</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Close label, used by ErrorList */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">CloseLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Close</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Errors label, used by ErrorList */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">ErrorsLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Errors</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** New additionalProperties string default value, used by ObjectField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">NewStringDefault</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">New Value</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Add button title, used by AddButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">AddButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Add</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Add button title, used by AddButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">AddItemButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Add Item</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Copy button title, used by IconButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">CopyButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Copy</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Move down button title, used by IconButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">MoveDownButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Move down</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Move up button title, used by IconButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">MoveUpButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Move up</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Remove button title, used by IconButton */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">RemoveButton</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Remove</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Now label, used by AltDateWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">NowLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Now</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Clear label, used by AltDateWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">ClearLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Clear</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Aria date label, used by DateWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">AriaDateLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Select a date</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** File preview label, used by FileWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">PreviewLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Preview</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Decrement button aria label, used by UpDownWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">DecrementAriaLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Decrease value by 1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Increment button aria label, used by UpDownWidget */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">IncrementAriaLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Increase value by 1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// Strings with replaceable parameters</span><span class="s3">\n    </span><span class="s1">/** Unknown field type reason, where %1 will be replaced with the type as provided by SchemaField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">UnknownFieldType</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Unknown field type %1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Option prefix, where %1 will be replaced with the option index as provided by MultiSchemaField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">OptionPrefix</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Option %1</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Option prefix, where %1 and %2 will be replaced by the schema title and option index, respectively as provided by</span><span class="s3">\n     </span><span class="s1">* MultiSchemaField</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">TitleOptionPrefix</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">%1 option %2</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Key label, where %1 will be replaced by the label as provided by WrapIfAdditionalTemplate */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">KeyLabel</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">%1 Key</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">// Strings with replaceable parameters AND/OR that support markdown and html</span><span class="s3">\n    </span><span class="s1">/** Invalid object field configuration as provided by the ObjectField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">InvalidObjectField</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Invalid </span><span class="s3">\\\&quot;</span><span class="s1">%1</span><span class="s3">\\\&quot; </span><span class="s1">object field configuration: &lt;em&gt;%2&lt;/em&gt;.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Unsupported field schema, used by UnsupportedField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">UnsupportedField</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Unsupported field schema.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Unsupported field schema, where %1 will be replaced by the idSchema.$id as provided by UnsupportedField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">UnsupportedFieldWithId</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Unsupported field schema for field &lt;code&gt;%1&lt;/code&gt;.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Unsupported field schema, where %1 will be replaced by the reason string as provided by UnsupportedField */</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">UnsupportedFieldWithReason</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Unsupported field schema: &lt;em&gt;%1&lt;/em&gt;.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** Unsupported field schema, where %1 and %2 will be replaced by the idSchema.$id and reason strings, respectively,</span><span class="s3">\n     </span><span class="s1">* as provided by UnsupportedField</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">UnsupportedFieldWithIdAndReason</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">Unsupported field schema for field &lt;code&gt;%1&lt;/code&gt;: &lt;em&gt;%2&lt;/em&gt;.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/** File name, type and size info, where %1, %2 and %3 will be replaced by the file name, file type and file size as</span><span class="s3">\n     </span><span class="s1">* provided by FileWidget</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">TranslatableString[</span><span class="s3">\&quot;</span><span class="s1">FilesInfo</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">&lt;strong&gt;%1&lt;/strong&gt; (%2, %3 bytes)</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">})(TranslatableString || (TranslatableString = {}));</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=enums.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import get from 'lodash/get';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import { ID_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import hashForSchema from '../hashForSchema';</span><span class="s3">\n</span><span class="s1">/** An implementation of the `ValidatorType` interface that is designed for use in capturing schemas used by the</span><span class="s3">\n </span><span class="s1">* `isValid()` function. The rest of the implementation of the interface throws errors when it is attempted to be used.</span><span class="s3">\n </span><span class="s1">* An instance of the object allows the caller to capture the schemas used in calls to the `isValid()` function. These</span><span class="s3">\n </span><span class="s1">* captured schema, along with the root schema used to construct the object are stored in the map of schemas keyed by</span><span class="s3">\n </span><span class="s1">* the hashed value of the schema. NOTE: After hashing the schema, an $id with the hash value is added to the</span><span class="s3">\n </span><span class="s1">* schema IF that schema doesn't already have an $id, prior to putting the schema into the map.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default class ParserValidator {</span><span class="s3">\n    </span><span class="s1">/** Construct the ParserValidator for the given `rootSchema`. This `rootSchema` will be stashed in the `schemaMap`</span><span class="s3">\n     </span><span class="s1">* first.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema against which this validator will be executed</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(rootSchema) {</span><span class="s3">\n        </span><span class="s1">/** The map of schemas encountered by the ParserValidator */</span><span class="s3">\n        </span><span class="s1">this.schemaMap = {};</span><span class="s3">\n        </span><span class="s1">this.rootSchema = rootSchema;</span><span class="s3">\n        </span><span class="s1">this.addSchema(rootSchema, hashForSchema(rootSchema));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Adds the given `schema` to the `schemaMap` keyed by the `hash` or `ID_KEY` if present on the `schema`. If the</span><span class="s3">\n     </span><span class="s1">* schema does not have an `ID_KEY`, then the `hash` will be added as the `ID_KEY` to allow the schema to be</span><span class="s3">\n     </span><span class="s1">* associated with it's `hash` for future use (by a schema compiler).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema which is to be added to the map</span><span class="s3">\n     </span><span class="s1">* @param hash - The hash value at which to map the schema</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addSchema(schema, hash) {</span><span class="s3">\n        </span><span class="s1">const key = get(schema, ID_KEY, hash);</span><span class="s3">\n        </span><span class="s1">const identifiedSchema = { ...schema, [ID_KEY]: key };</span><span class="s3">\n        </span><span class="s1">const existing = this.schemaMap[key];</span><span class="s3">\n        </span><span class="s1">if (!existing) {</span><span class="s3">\n            </span><span class="s1">this.schemaMap[key] = identifiedSchema;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (!isEqual(existing, identifiedSchema)) {</span><span class="s3">\n            </span><span class="s1">console.error('existing schema:', JSON.stringify(existing, null, 2));</span><span class="s3">\n            </span><span class="s1">console.error('new schema:', JSON.stringify(identifiedSchema, null, 2));</span><span class="s3">\n            </span><span class="s1">throw new Error(`Two different schemas exist with the same key ${key}! What a bad coincidence. If possible, try adding an $id to one of the schemas`);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Returns the current `schemaMap` to the caller</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getSchemaMap() {</span><span class="s3">\n        </span><span class="s1">return this.schemaMap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Implements the `ValidatorType` `isValid()` method to capture the `schema` in the `schemaMap`. Throws an error when</span><span class="s3">\n     </span><span class="s1">* the `rootSchema` is not the same as the root schema provided during construction.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param schema - The schema to record in the `schemaMap`</span><span class="s3">\n     </span><span class="s1">* @param _formData - The formData parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param rootSchema - The root schema associated with the schema</span><span class="s3">\n     </span><span class="s1">* @throws - Error when the given `rootSchema` differs from the root schema provided during construction</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isValid(schema, _formData, rootSchema) {</span><span class="s3">\n        </span><span class="s1">if (!isEqual(rootSchema, this.rootSchema)) {</span><span class="s3">\n            </span><span class="s1">throw new Error('Unexpectedly calling isValid() with a rootSchema that differs from the construction rootSchema');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.addSchema(schema, hashForSchema(schema));</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Implements the `ValidatorType` `rawValidation()` method to throw an error since it is never supposed to be called</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param _schema - The schema parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _formData - The formData parameter that is ignored</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">rawValidation(_schema, _formData) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpectedly calling the `rawValidation()` method during schema parsing');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Implements the `ValidatorType` `toErrorList()` method to throw an error since it is never supposed to be called</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param _errorSchema - The error schema parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _fieldPath - The field path parameter that is ignored</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toErrorList(_errorSchema, _fieldPath) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpectedly calling the `toErrorList()` method during schema parsing');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/** Implements the `ValidatorType` `validateFormData()` method to throw an error since it is never supposed to be</span><span class="s3">\n     </span><span class="s1">* called</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param _formData - The formData parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _schema - The schema parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _customValidate - The customValidate parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _transformErrors - The transformErrors parameter that is ignored</span><span class="s3">\n     </span><span class="s1">* @param _uiSchema - The uiSchema parameter that is ignored</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">validateFormData(_formData, _schema, _customValidate, _transformErrors, _uiSchema) {</span><span class="s3">\n        </span><span class="s1">throw new Error('Unexpectedly calling the `validateFormData()` method during schema parsing');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ParserValidator.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import forEach from 'lodash/forEach';</span><span class="s3">\n</span><span class="s1">import isEqual from 'lodash/isEqual';</span><span class="s3">\n</span><span class="s1">import { PROPERTIES_KEY, ITEMS_KEY } from '../constants';</span><span class="s3">\n</span><span class="s1">import ParserValidator from './ParserValidator';</span><span class="s3">\n</span><span class="s1">import { retrieveSchemaInternal, resolveAnyOrOneOfSchemas } from '../schema/retrieveSchema';</span><span class="s3">\n</span><span class="s1">/** Recursive function used to parse the given `schema` belonging to the `rootSchema`. The `validator` is used to</span><span class="s3">\n </span><span class="s1">* capture the sub-schemas that the `isValid()` function is called with. For each schema returned by the</span><span class="s3">\n </span><span class="s1">* `retrieveSchemaInternal()`, the `resolveAnyOrOneOfSchemas()` function is called. For each of the schemas returned</span><span class="s3">\n </span><span class="s1">* from THAT call have `properties`, then each of the sub-schema property objects are then recursively parsed.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param validator - The `ParserValidator` implementation used to capture `isValid()` calls during parsing</span><span class="s3">\n </span><span class="s1">* @param recurseList - The list of schemas returned from the `retrieveSchemaInternal`, preventing infinite recursion</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema from which the schema parsing began</span><span class="s3">\n </span><span class="s1">* @param schema - The current schema element being parsed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function parseSchema(validator, recurseList, rootSchema, schema) {</span><span class="s3">\n    </span><span class="s1">const schemas = retrieveSchemaInternal(validator, schema, rootSchema, undefined, true);</span><span class="s3">\n    </span><span class="s1">schemas.forEach((schema) =&gt; {</span><span class="s3">\n        </span><span class="s1">const sameSchemaIndex = recurseList.findIndex((item) =&gt; isEqual(item, schema));</span><span class="s3">\n        </span><span class="s1">if (sameSchemaIndex === -1) {</span><span class="s3">\n            </span><span class="s1">recurseList.push(schema);</span><span class="s3">\n            </span><span class="s1">const allOptions = resolveAnyOrOneOfSchemas(validator, schema, rootSchema, true);</span><span class="s3">\n            </span><span class="s1">allOptions.forEach((s) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (PROPERTIES_KEY in s &amp;&amp; s[PROPERTIES_KEY]) {</span><span class="s3">\n                    </span><span class="s1">forEach(schema[PROPERTIES_KEY], (value) =&gt; {</span><span class="s3">\n                        </span><span class="s1">parseSchema(validator, recurseList, rootSchema, value);</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (ITEMS_KEY in schema &amp;&amp; !Array.isArray(schema.items) &amp;&amp; typeof schema.items !== 'boolean') {</span><span class="s3">\n                </span><span class="s1">parseSchema(validator, recurseList, rootSchema, schema.items);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/** Parses the given `rootSchema` to extract out all the sub-schemas that maybe contained within it. Returns a map of</span><span class="s3">\n </span><span class="s1">* the hash of the schema to schema/sub-schema.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param rootSchema - The root schema to parse for sub-schemas used by `isValid()` calls</span><span class="s3">\n </span><span class="s1">* @returns - The `SchemaMap` of all schemas that were parsed</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export default function schemaParser(rootSchema) {</span><span class="s3">\n    </span><span class="s1">const validator = new ParserValidator(rootSchema);</span><span class="s3">\n    </span><span class="s1">const recurseList = [];</span><span class="s3">\n    </span><span class="s1">parseSchema(validator, recurseList, rootSchema, rootSchema);</span><span class="s3">\n    </span><span class="s1">return validator.getSchemaMap();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=schemaParser.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import schemaParser from './schemaParser';</span><span class="s3">\n</span><span class="s1">export { schemaParser };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;import allowAdditionalItems from './allowAdditionalItems';</span><span class="s3">\n</span><span class="s1">import asNumber from './asNumber';</span><span class="s3">\n</span><span class="s1">import canExpand from './canExpand';</span><span class="s3">\n</span><span class="s1">import createErrorHandler from './createErrorHandler';</span><span class="s3">\n</span><span class="s1">import createSchemaUtils from './createSchemaUtils';</span><span class="s3">\n</span><span class="s1">import dataURItoBlob from './dataURItoBlob';</span><span class="s3">\n</span><span class="s1">import deepEquals from './deepEquals';</span><span class="s3">\n</span><span class="s1">import englishStringTranslator from './englishStringTranslator';</span><span class="s3">\n</span><span class="s1">import enumOptionsDeselectValue from './enumOptionsDeselectValue';</span><span class="s3">\n</span><span class="s1">import enumOptionsIndexForValue from './enumOptionsIndexForValue';</span><span class="s3">\n</span><span class="s1">import enumOptionsIsSelected from './enumOptionsIsSelected';</span><span class="s3">\n</span><span class="s1">import enumOptionsSelectValue from './enumOptionsSelectValue';</span><span class="s3">\n</span><span class="s1">import enumOptionsValueForIndex from './enumOptionsValueForIndex';</span><span class="s3">\n</span><span class="s1">import ErrorSchemaBuilder from './ErrorSchemaBuilder';</span><span class="s3">\n</span><span class="s1">import findSchemaDefinition from './findSchemaDefinition';</span><span class="s3">\n</span><span class="s1">import getDateElementProps from './getDateElementProps';</span><span class="s3">\n</span><span class="s1">import getDiscriminatorFieldFromSchema from './getDiscriminatorFieldFromSchema';</span><span class="s3">\n</span><span class="s1">import getInputProps from './getInputProps';</span><span class="s3">\n</span><span class="s1">import getSchemaType from './getSchemaType';</span><span class="s3">\n</span><span class="s1">import getSubmitButtonOptions from './getSubmitButtonOptions';</span><span class="s3">\n</span><span class="s1">import getTemplate from './getTemplate';</span><span class="s3">\n</span><span class="s1">import getUiOptions from './getUiOptions';</span><span class="s3">\n</span><span class="s1">import getWidget from './getWidget';</span><span class="s3">\n</span><span class="s1">import guessType from './guessType';</span><span class="s3">\n</span><span class="s1">import hashForSchema from './hashForSchema';</span><span class="s3">\n</span><span class="s1">import hasWidget from './hasWidget';</span><span class="s3">\n</span><span class="s1">import { ariaDescribedByIds, descriptionId, errorId, examplesId, helpId, optionId, titleId } from './idGenerators';</span><span class="s3">\n</span><span class="s1">import isConstant from './isConstant';</span><span class="s3">\n</span><span class="s1">import isCustomWidget from './isCustomWidget';</span><span class="s3">\n</span><span class="s1">import isFixedItems from './isFixedItems';</span><span class="s3">\n</span><span class="s1">import isObject from './isObject';</span><span class="s3">\n</span><span class="s1">import labelValue from './labelValue';</span><span class="s3">\n</span><span class="s1">import localToUTC from './localToUTC';</span><span class="s3">\n</span><span class="s1">import mergeDefaultsWithFormData from './mergeDefaultsWithFormData';</span><span class="s3">\n</span><span class="s1">import mergeObjects from './mergeObjects';</span><span class="s3">\n</span><span class="s1">import mergeSchemas from './mergeSchemas';</span><span class="s3">\n</span><span class="s1">import optionsList from './optionsList';</span><span class="s3">\n</span><span class="s1">import orderProperties from './orderProperties';</span><span class="s3">\n</span><span class="s1">import pad from './pad';</span><span class="s3">\n</span><span class="s1">import parseDateString from './parseDateString';</span><span class="s3">\n</span><span class="s1">import rangeSpec from './rangeSpec';</span><span class="s3">\n</span><span class="s1">import replaceStringParameters from './replaceStringParameters';</span><span class="s3">\n</span><span class="s1">import schemaRequiresTrueValue from './schemaRequiresTrueValue';</span><span class="s3">\n</span><span class="s1">import shouldRender from './shouldRender';</span><span class="s3">\n</span><span class="s1">import toConstant from './toConstant';</span><span class="s3">\n</span><span class="s1">import toDateString from './toDateString';</span><span class="s3">\n</span><span class="s1">import toErrorList from './toErrorList';</span><span class="s3">\n</span><span class="s1">import toErrorSchema from './toErrorSchema';</span><span class="s3">\n</span><span class="s1">import unwrapErrorHandler from './unwrapErrorHandler';</span><span class="s3">\n</span><span class="s1">import utcToLocal from './utcToLocal';</span><span class="s3">\n</span><span class="s1">import validationDataMerge from './validationDataMerge';</span><span class="s3">\n</span><span class="s1">import withIdRefPrefix from './withIdRefPrefix';</span><span class="s3">\n</span><span class="s1">import getOptionMatchingSimpleDiscriminator from './getOptionMatchingSimpleDiscriminator';</span><span class="s3">\n</span><span class="s1">export * from './types';</span><span class="s3">\n</span><span class="s1">export * from './enums';</span><span class="s3">\n</span><span class="s1">export * from './constants';</span><span class="s3">\n</span><span class="s1">export * from './parser';</span><span class="s3">\n</span><span class="s1">export * from './schema';</span><span class="s3">\n</span><span class="s1">export { allowAdditionalItems, ariaDescribedByIds, asNumber, canExpand, createErrorHandler, createSchemaUtils, dataURItoBlob, deepEquals, descriptionId, englishStringTranslator, enumOptionsDeselectValue, enumOptionsIndexForValue, enumOptionsIsSelected, enumOptionsSelectValue, enumOptionsValueForIndex, errorId, examplesId, ErrorSchemaBuilder, findSchemaDefinition, getDateElementProps, getDiscriminatorFieldFromSchema, getInputProps, getOptionMatchingSimpleDiscriminator, getSchemaType, getSubmitButtonOptions, getTemplate, getUiOptions, getWidget, guessType, hasWidget, hashForSchema, helpId, isConstant, isCustomWidget, isFixedItems, isObject, labelValue, localToUTC, mergeDefaultsWithFormData, mergeObjects, mergeSchemas, optionId, optionsList, orderProperties, pad, parseDateString, rangeSpec, replaceStringParameters, schemaRequiresTrueValue, shouldRender, titleId, toConstant, toDateString, toErrorList, toErrorSchema, unwrapErrorHandler, utcToLocal, validationDataMerge, withIdRefPrefix, };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">// MODULES //</span><span class="s3">\n\n</span><span class="s1">var isArray = require( 'validate.io-array' ),</span><span class="s3">\n\t</span><span class="s1">isIntegerArray = require( 'validate.io-integer-array' ),</span><span class="s3">\n\t</span><span class="s1">isFunction = require( 'validate.io-function' );</span><span class="s3">\n\n\n</span><span class="s1">// VARIABLES //</span><span class="s3">\n\n</span><span class="s1">var MAXINT = Math.pow( 2, 31 ) - 1;</span><span class="s3">\n\n\n</span><span class="s1">// FUNCTIONS //</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: gcd( a, b )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {Number} a - integer</span><span class="s3">\n</span><span class="s1">* @param {Number} b - integer</span><span class="s3">\n</span><span class="s1">* @returns {Number} greatest common divisor</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function gcd( a, b ) {</span><span class="s3">\n\t</span><span class="s1">var k = 1,</span><span class="s3">\n\t\t</span><span class="s1">t;</span><span class="s3">\n\t</span><span class="s1">// Simple cases:</span><span class="s3">\n\t</span><span class="s1">if ( a === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">return b;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if ( b === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">return a;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...</span><span class="s3">\n\t</span><span class="s1">while ( a%2 === 0 &amp;&amp; b%2 === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">a = a / 2; // right shift</span><span class="s3">\n\t\t</span><span class="s1">b = b / 2; // right shift</span><span class="s3">\n\t\t</span><span class="s1">k = k * 2; // left shift</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Reduce `a` to an odd number...</span><span class="s3">\n\t</span><span class="s1">while ( a%2 === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">a = a / 2; // right shift</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Henceforth, `a` is always odd...</span><span class="s3">\n\t</span><span class="s1">while ( b ) {</span><span class="s3">\n\t\t</span><span class="s1">// Remove all factors of 2 in `b`, as they are not common...</span><span class="s3">\n\t\t</span><span class="s1">while ( b%2 === 0 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">b = b / 2; // right shift</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...</span><span class="s3">\n\t\t</span><span class="s1">if ( a &gt; b ) {</span><span class="s3">\n\t\t\t</span><span class="s1">t = b;</span><span class="s3">\n\t\t\t</span><span class="s1">b = a;</span><span class="s3">\n\t\t\t</span><span class="s1">a = t;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">b = b - a; // b=0 iff b=a</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Restore common factors of 2...</span><span class="s3">\n\t</span><span class="s1">return k * a;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION gcd()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: bitwise( a, b )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Computes the greatest common divisor of two integers `a` and `b`, using the binary GCD algorithm and bitwise operations.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {Number} a - safe integer</span><span class="s3">\n</span><span class="s1">* @param {Number} b - safe integer</span><span class="s3">\n</span><span class="s1">* @returns {Number} greatest common divisor</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function bitwise( a, b ) {</span><span class="s3">\n\t</span><span class="s1">var k = 0,</span><span class="s3">\n\t\t</span><span class="s1">t;</span><span class="s3">\n\t</span><span class="s1">// Simple cases:</span><span class="s3">\n\t</span><span class="s1">if ( a === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">return b;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">if ( b === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">return a;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Reduce `a` and/or `b` to odd numbers and keep track of the greatest power of 2 dividing both `a` and `b`...</span><span class="s3">\n\t</span><span class="s1">while ( (a &amp; 1) === 0 &amp;&amp; (b &amp; 1) === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">a &gt;&gt;&gt;= 1; // right shift</span><span class="s3">\n\t\t</span><span class="s1">b &gt;&gt;&gt;= 1; // right shift</span><span class="s3">\n\t\t</span><span class="s1">k++;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Reduce `a` to an odd number...</span><span class="s3">\n\t</span><span class="s1">while ( (a &amp; 1) === 0 ) {</span><span class="s3">\n\t\t</span><span class="s1">a &gt;&gt;&gt;= 1; // right shift</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Henceforth, `a` is always odd...</span><span class="s3">\n\t</span><span class="s1">while ( b ) {</span><span class="s3">\n\t\t</span><span class="s1">// Remove all factors of 2 in `b`, as they are not common...</span><span class="s3">\n\t\t</span><span class="s1">while ( (b &amp; 1) === 0 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">b &gt;&gt;&gt;= 1; // right shift</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">// `a` and `b` are both odd. Swap values such that `b` is the larger of the two values, and then set `b` to the difference (which is even)...</span><span class="s3">\n\t\t</span><span class="s1">if ( a &gt; b ) {</span><span class="s3">\n\t\t\t</span><span class="s1">t = b;</span><span class="s3">\n\t\t\t</span><span class="s1">b = a;</span><span class="s3">\n\t\t\t</span><span class="s1">a = t;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">b = b - a; // b=0 iff b=a</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Restore common factors of 2...</span><span class="s3">\n\t</span><span class="s1">return a &lt;&lt; k;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION bitwise()</span><span class="s3">\n\n\n</span><span class="s1">// GREATEST COMMON DIVISOR //</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: compute( arr[, clbk] )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Computes the greatest common divisor.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {Number[]|Number} arr - input array of integers</span><span class="s3">\n</span><span class="s1">* @param {Function|Number} [clbk] - accessor function for accessing array values</span><span class="s3">\n</span><span class="s1">* @returns {Number|Null} greatest common divisor or null</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compute() {</span><span class="s3">\n\t</span><span class="s1">var nargs = arguments.length,</span><span class="s3">\n\t\t</span><span class="s1">args,</span><span class="s3">\n\t\t</span><span class="s1">clbk,</span><span class="s3">\n\t\t</span><span class="s1">arr,</span><span class="s3">\n\t\t</span><span class="s1">len,</span><span class="s3">\n\t\t</span><span class="s1">a, b,</span><span class="s3">\n\t\t</span><span class="s1">i;</span><span class="s3">\n\n\t</span><span class="s1">// Copy the input arguments to an array...</span><span class="s3">\n\t</span><span class="s1">args = new Array( nargs );</span><span class="s3">\n\t</span><span class="s1">for ( i = 0; i &lt; nargs; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">args[ i ] = arguments[ i ];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Have we been provided with integer arguments?</span><span class="s3">\n\t</span><span class="s1">if ( isIntegerArray( args ) ) {</span><span class="s3">\n\t\t</span><span class="s1">if ( nargs === 2 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">a = args[ 0 ];</span><span class="s3">\n\t\t\t</span><span class="s1">b = args[ 1 ];</span><span class="s3">\n\t\t\t</span><span class="s1">if ( a &lt; 0 ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">a = -a;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if ( b &lt; 0 ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">b = -b;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if ( a &lt;= MAXINT &amp;&amp; b &lt;= MAXINT ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return bitwise( a, b );</span><span class="s3">\n\t\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return gcd( a, b );</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">arr = args;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// If not integers, ensure the first argument is an array...</span><span class="s3">\n\t</span><span class="s1">else if ( !isArray( args[ 0 ] ) ) {</span><span class="s3">\n\t\t</span><span class="s1">throw new TypeError( 'gcd()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...</span><span class="s3">\n\t</span><span class="s1">else if ( nargs &gt; 1 ) {</span><span class="s3">\n\t\t</span><span class="s1">arr = args[ 0 ];</span><span class="s3">\n\t\t</span><span class="s1">clbk = args[ 1 ];</span><span class="s3">\n\t\t</span><span class="s1">if ( !isFunction( clbk ) ) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError( 'gcd()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// We have been provided an array...</span><span class="s3">\n\t</span><span class="s1">else {</span><span class="s3">\n\t\t</span><span class="s1">arr = args[ 0 ];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">len = arr.length;</span><span class="s3">\n\n\t</span><span class="s1">// Check if a sufficient number of values have been provided...</span><span class="s3">\n\t</span><span class="s1">if ( len &lt; 2 ) {</span><span class="s3">\n\t\t</span><span class="s1">return null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// If an accessor is provided, extract the array values...</span><span class="s3">\n\t</span><span class="s1">if ( clbk ) {</span><span class="s3">\n\t\t</span><span class="s1">a = new Array( len );</span><span class="s3">\n\t\t</span><span class="s1">for ( i = 0; i &lt; len; i++ ) {</span><span class="s3">\n\t\t\t</span><span class="s1">a[ i ] = clbk( arr[ i ], i );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">arr = a;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Given an input array, ensure all array values are integers...</span><span class="s3">\n\t</span><span class="s1">if ( nargs &lt; 3 ) {</span><span class="s3">\n\t\t</span><span class="s1">if ( !isIntegerArray( arr ) ) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError( 'gcd()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Convert any negative integers to positive integers...</span><span class="s3">\n\t</span><span class="s1">for ( i = 0; i &lt; len; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">a = arr[ i ];</span><span class="s3">\n\t\t</span><span class="s1">if ( a &lt; 0 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">arr[ i ] = -a;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Exploit the fact that the gcd is an associative function...</span><span class="s3">\n\t</span><span class="s1">a = arr[ 0 ];</span><span class="s3">\n\t</span><span class="s1">for ( i = 1; i &lt; len; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">b = arr[ i ];</span><span class="s3">\n\t\t</span><span class="s1">if ( b &lt;= MAXINT &amp;&amp; a &lt;= MAXINT ) {</span><span class="s3">\n\t\t\t</span><span class="s1">a = bitwise( a, b );</span><span class="s3">\n\t\t</span><span class="s1">} else {</span><span class="s3">\n\t\t\t</span><span class="s1">a = gcd( a, b );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return a;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION compute()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = compute;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">// MODULES //</span><span class="s3">\n\n</span><span class="s1">var gcd = require( 'compute-gcd' ),</span><span class="s3">\n\t</span><span class="s1">isArray = require( 'validate.io-array' ),</span><span class="s3">\n\t</span><span class="s1">isIntegerArray = require( 'validate.io-integer-array' ),</span><span class="s3">\n\t</span><span class="s1">isFunction = require( 'validate.io-function' );</span><span class="s3">\n\n\n</span><span class="s1">// LEAST COMMON MULTIPLE //</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: lcm( arr[, clbk] )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Computes the least common multiple (lcm).</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {Number[]|Number} arr - input array of integers</span><span class="s3">\n</span><span class="s1">* @param {Function|Number} [accessor] - accessor function for accessing array values</span><span class="s3">\n</span><span class="s1">* @returns {Number|Null} least common multiple or null</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function lcm() {</span><span class="s3">\n\t</span><span class="s1">var nargs = arguments.length,</span><span class="s3">\n\t\t</span><span class="s1">args,</span><span class="s3">\n\t\t</span><span class="s1">clbk,</span><span class="s3">\n\t\t</span><span class="s1">arr,</span><span class="s3">\n\t\t</span><span class="s1">len,</span><span class="s3">\n\t\t</span><span class="s1">a, b,</span><span class="s3">\n\t\t</span><span class="s1">i;</span><span class="s3">\n\n\t</span><span class="s1">// Copy the input arguments to an array...</span><span class="s3">\n\t</span><span class="s1">args = new Array( nargs );</span><span class="s3">\n\t</span><span class="s1">for ( i = 0; i &lt; nargs; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">args[ i ] = arguments[ i ];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Have we been provided with integer arguments?</span><span class="s3">\n\t</span><span class="s1">if ( isIntegerArray( args ) ) {</span><span class="s3">\n\t\t</span><span class="s1">if ( nargs === 2 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">a = args[ 0 ];</span><span class="s3">\n\t\t\t</span><span class="s1">b = args[ 1 ];</span><span class="s3">\n\t\t\t</span><span class="s1">if ( a &lt; 0 ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">a = -a;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if ( b &lt; 0 ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">b = -b;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">if ( a === 0 || b === 0 ) {</span><span class="s3">\n\t\t\t\t</span><span class="s1">return 0;</span><span class="s3">\n\t\t\t</span><span class="s1">}</span><span class="s3">\n\t\t\t</span><span class="s1">return ( a/gcd(a,b) ) * b;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">arr = args;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// If not integers, ensure that the first argument is an array...</span><span class="s3">\n\t</span><span class="s1">else if ( !isArray( args[ 0 ] ) ) {</span><span class="s3">\n\t\t</span><span class="s1">throw new TypeError( 'lcm()::invalid input argument. Must provide an array of integers. Value: `' + args[ 0 ] + '`.' );</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Have we been provided with more than one argument? If so, ensure that the accessor argument is a function...</span><span class="s3">\n\t</span><span class="s1">else if ( nargs &gt; 1 ) {</span><span class="s3">\n\t\t</span><span class="s1">arr = args[ 0 ];</span><span class="s3">\n\t\t</span><span class="s1">clbk = args[ 1 ];</span><span class="s3">\n\t\t</span><span class="s1">if ( !isFunction( clbk ) ) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError( 'lcm()::invalid input argument. Accessor must be a function. Value: `' + clbk + '`.' );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// We have been provided an array...</span><span class="s3">\n\t</span><span class="s1">else {</span><span class="s3">\n\t\t</span><span class="s1">arr = args[ 0 ];</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">len = arr.length;</span><span class="s3">\n\n\t</span><span class="s1">// Check if a sufficient number of values have been provided...</span><span class="s3">\n\t</span><span class="s1">if ( len &lt; 2 ) {</span><span class="s3">\n\t\t</span><span class="s1">return null;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// If an accessor is provided, extract the array values...</span><span class="s3">\n\t</span><span class="s1">if ( clbk ) {</span><span class="s3">\n\t\t</span><span class="s1">a = new Array( len );</span><span class="s3">\n\t\t</span><span class="s1">for ( i = 0; i &lt; len; i++ ) {</span><span class="s3">\n\t\t\t</span><span class="s1">a[ i ] = clbk( arr[ i ], i );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">arr = a;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Given an input array, ensure all array values are integers...</span><span class="s3">\n\t</span><span class="s1">if ( nargs &lt; 3 ) {</span><span class="s3">\n\t\t</span><span class="s1">if ( !isIntegerArray( arr ) ) {</span><span class="s3">\n\t\t\t</span><span class="s1">throw new TypeError( 'lcm()::invalid input argument. Accessed array values must be integers. Value: `' + arr + '`.' );</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Convert any negative integers to positive integers...</span><span class="s3">\n\t</span><span class="s1">for ( i = 0; i &lt; len; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">a = arr[ i ];</span><span class="s3">\n\t\t</span><span class="s1">if ( a &lt; 0 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">arr[ i ] = -a;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">// Exploit the fact that the lcm is an associative function...</span><span class="s3">\n\t</span><span class="s1">a = arr[ 0 ];</span><span class="s3">\n\t</span><span class="s1">for ( i = 1; i &lt; len; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">b = arr[ i ];</span><span class="s3">\n\t\t</span><span class="s1">if ( a === 0 || b === 0 ) {</span><span class="s3">\n\t\t\t</span><span class="s1">return 0;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t\t</span><span class="s1">a = ( a/gcd(a,b) ) * b;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return a;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION lcm()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = lcm;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isEqual = require('lodash/isEqual')</span><span class="s3">\n</span><span class="s1">var sortBy = require('lodash/sortBy')</span><span class="s3">\n</span><span class="s1">var uniq = require('lodash/uniq')</span><span class="s3">\n</span><span class="s1">var uniqWith = require('lodash/uniqWith')</span><span class="s3">\n</span><span class="s1">var defaults = require('lodash/defaults')</span><span class="s3">\n</span><span class="s1">var intersectionWith = require('lodash/intersectionWith')</span><span class="s3">\n</span><span class="s1">var isPlainObject = require('lodash/isPlainObject')</span><span class="s3">\n</span><span class="s1">var isBoolean = require('lodash/isBoolean')</span><span class="s3">\n\n</span><span class="s1">var normalizeArray = val =&gt; Array.isArray(val)</span><span class="s3">\n  </span><span class="s1">? val : [val]</span><span class="s3">\n</span><span class="s1">var undef = val =&gt; val === undefined</span><span class="s3">\n</span><span class="s1">var keys = obj =&gt; isPlainObject(obj) || Array.isArray(obj) ? Object.keys(obj) : []</span><span class="s3">\n</span><span class="s1">var has = (obj, key) =&gt; obj.hasOwnProperty(key)</span><span class="s3">\n</span><span class="s1">var stringArray = arr =&gt; sortBy(uniq(arr))</span><span class="s3">\n</span><span class="s1">var undefEmpty = val =&gt; undef(val) || (Array.isArray(val) &amp;&amp; val.length === 0)</span><span class="s3">\n</span><span class="s1">var keyValEqual = (a, b, key, compare) =&gt; b &amp;&amp; has(b, key) &amp;&amp; a &amp;&amp; has(a, key) &amp;&amp; compare(a[key], b[key])</span><span class="s3">\n</span><span class="s1">var undefAndZero = (a, b) =&gt; (undef(a) &amp;&amp; b === 0) || (undef(b) &amp;&amp; a === 0) || isEqual(a, b)</span><span class="s3">\n</span><span class="s1">var falseUndefined = (a, b) =&gt; (undef(a) &amp;&amp; b === false) || (undef(b) &amp;&amp; a === false) || isEqual(a, b)</span><span class="s3">\n</span><span class="s1">var emptySchema = schema =&gt; undef(schema) || isEqual(schema, {}) || schema === true</span><span class="s3">\n</span><span class="s1">var emptyObjUndef = schema =&gt; undef(schema) || isEqual(schema, {})</span><span class="s3">\n</span><span class="s1">var isSchema = val =&gt; undef(val) || isPlainObject(val) || val === true || val === false</span><span class="s3">\n\n</span><span class="s1">function undefArrayEqual(a, b) {</span><span class="s3">\n  </span><span class="s1">if (undefEmpty(a) &amp;&amp; undefEmpty(b)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return isEqual(stringArray(a), stringArray(b))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unsortedNormalizedArray(a, b) {</span><span class="s3">\n  </span><span class="s1">a = normalizeArray(a)</span><span class="s3">\n  </span><span class="s1">b = normalizeArray(b)</span><span class="s3">\n  </span><span class="s1">return isEqual(stringArray(a), stringArray(b))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function schemaGroup(a, b, key, compare) {</span><span class="s3">\n  </span><span class="s1">var allProps = uniq(keys(a).concat(keys(b)))</span><span class="s3">\n  </span><span class="s1">if (emptyObjUndef(a) &amp;&amp; emptyObjUndef(b)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">} else if (emptyObjUndef(a) &amp;&amp; keys(b).length) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">} else if (emptyObjUndef(b) &amp;&amp; keys(a).length) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return allProps.every(function(key) {</span><span class="s3">\n    </span><span class="s1">var aVal = a[key]</span><span class="s3">\n    </span><span class="s1">var bVal = b[key]</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(aVal) &amp;&amp; Array.isArray(bVal)) {</span><span class="s3">\n      </span><span class="s1">return isEqual(stringArray(a), stringArray(b))</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(aVal) &amp;&amp; !Array.isArray(bVal)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">} else if (Array.isArray(bVal) &amp;&amp; !Array.isArray(aVal)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return keyValEqual(a, b, key, compare)</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function items(a, b, key, compare) {</span><span class="s3">\n  </span><span class="s1">if (isPlainObject(a) &amp;&amp; isPlainObject(b)) {</span><span class="s3">\n    </span><span class="s1">return compare(a, b)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(a) &amp;&amp; Array.isArray(b)) {</span><span class="s3">\n    </span><span class="s1">return schemaGroup(a, b, key, compare)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return isEqual(a, b)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function unsortedArray(a, b, key, compare) {</span><span class="s3">\n  </span><span class="s1">var uniqueA = uniqWith(a, compare)</span><span class="s3">\n  </span><span class="s1">var uniqueB = uniqWith(b, compare)</span><span class="s3">\n  </span><span class="s1">var inter = intersectionWith(uniqueA, uniqueB, compare)</span><span class="s3">\n  </span><span class="s1">return inter.length === Math.max(uniqueA.length, uniqueB.length)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var comparers = {</span><span class="s3">\n  </span><span class="s1">title: isEqual,</span><span class="s3">\n  </span><span class="s1">uniqueItems: falseUndefined,</span><span class="s3">\n  </span><span class="s1">minLength: undefAndZero,</span><span class="s3">\n  </span><span class="s1">minItems: undefAndZero,</span><span class="s3">\n  </span><span class="s1">minProperties: undefAndZero,</span><span class="s3">\n  </span><span class="s1">required: undefArrayEqual,</span><span class="s3">\n  </span><span class="s1">enum: undefArrayEqual,</span><span class="s3">\n  </span><span class="s1">type: unsortedNormalizedArray,</span><span class="s3">\n  </span><span class="s1">items: items,</span><span class="s3">\n  </span><span class="s1">anyOf: unsortedArray,</span><span class="s3">\n  </span><span class="s1">allOf: unsortedArray,</span><span class="s3">\n  </span><span class="s1">oneOf: unsortedArray,</span><span class="s3">\n  </span><span class="s1">properties: schemaGroup,</span><span class="s3">\n  </span><span class="s1">patternProperties: schemaGroup,</span><span class="s3">\n  </span><span class="s1">dependencies: schemaGroup</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var acceptsUndefined = [</span><span class="s3">\n  </span><span class="s1">'properties',</span><span class="s3">\n  </span><span class="s1">'patternProperties',</span><span class="s3">\n  </span><span class="s1">'dependencies',</span><span class="s3">\n  </span><span class="s1">'uniqueItems',</span><span class="s3">\n  </span><span class="s1">'minLength',</span><span class="s3">\n  </span><span class="s1">'minItems',</span><span class="s3">\n  </span><span class="s1">'minProperties',</span><span class="s3">\n  </span><span class="s1">'required'</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">var schemaProps = ['additionalProperties', 'additionalItems', 'contains', 'propertyNames', 'not']</span><span class="s3">\n\n</span><span class="s1">function compare(a, b, options) {</span><span class="s3">\n  </span><span class="s1">options = defaults(options, {</span><span class="s3">\n    </span><span class="s1">ignore: []</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">if (emptySchema(a) &amp;&amp; emptySchema(b)) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!isSchema(a) || !isSchema(b)) {</span><span class="s3">\n    </span><span class="s1">throw new Error('Either of the values are not a JSON schema.')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (a === b) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isBoolean(a) &amp;&amp; isBoolean(b)) {</span><span class="s3">\n    </span><span class="s1">return a === b</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if ((a === undefined &amp;&amp; b === false) || (b === undefined &amp;&amp; a === false)) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if ((undef(a) &amp;&amp; !undef(b)) || (!undef(a) &amp;&amp; undef(b))) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var allKeys = uniq(Object.keys(a).concat(Object.keys(b)))</span><span class="s3">\n\n  </span><span class="s1">if (options.ignore.length) {</span><span class="s3">\n    </span><span class="s1">allKeys = allKeys.filter(k =&gt; options.ignore.indexOf(k) === -1)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (!allKeys.length) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function innerCompare(a, b) {</span><span class="s3">\n    </span><span class="s1">return compare(a, b, options)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return allKeys.every(function(key) {</span><span class="s3">\n    </span><span class="s1">var aValue = a[key]</span><span class="s3">\n    </span><span class="s1">var bValue = b[key]</span><span class="s3">\n\n    </span><span class="s1">if (schemaProps.indexOf(key) !== -1) {</span><span class="s3">\n      </span><span class="s1">return compare(aValue, bValue, options)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var comparer = comparers[key]</span><span class="s3">\n    </span><span class="s1">if (!comparer) {</span><span class="s3">\n      </span><span class="s1">comparer = isEqual</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// do simple lodash check first</span><span class="s3">\n    </span><span class="s1">if (isEqual(aValue, bValue)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (acceptsUndefined.indexOf(key) === -1) {</span><span class="s3">\n      </span><span class="s1">if ((!has(a, key) &amp;&amp; has(b, key)) || (has(a, key) &amp;&amp; !has(b, key))) {</span><span class="s3">\n        </span><span class="s1">return aValue === bValue</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var result = comparer(aValue, bValue, key, innerCompare)</span><span class="s3">\n    </span><span class="s1">if (!isBoolean(result)) {</span><span class="s3">\n      </span><span class="s1">throw new Error('Comparer must return true or false')</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = compare</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const flatten = require('lodash/flatten')</span><span class="s3">\n</span><span class="s1">const flattenDeep = require('lodash/flattenDeep')</span><span class="s3">\n</span><span class="s1">const isPlainObject = require('lodash/isPlainObject')</span><span class="s3">\n</span><span class="s1">const uniq = require('lodash/uniq')</span><span class="s3">\n</span><span class="s1">const uniqWith = require('lodash/uniqWith')</span><span class="s3">\n</span><span class="s1">const without = require('lodash/without')</span><span class="s3">\n\n</span><span class="s1">function deleteUndefinedProps(returnObject) {</span><span class="s3">\n  </span><span class="s1">// cleanup empty</span><span class="s3">\n  </span><span class="s1">for (const prop in returnObject) {</span><span class="s3">\n    </span><span class="s1">if (has(returnObject, prop) &amp;&amp; isEmptySchema(returnObject[prop])) {</span><span class="s3">\n      </span><span class="s1">delete returnObject[prop]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return returnObject</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const allUniqueKeys = (arr) =&gt; uniq(flattenDeep(arr.map(keys)))</span><span class="s3">\n</span><span class="s1">const getValues = (schemas, key) =&gt; schemas.map(schema =&gt; schema &amp;&amp; schema[key])</span><span class="s3">\n</span><span class="s1">const has = (obj, propName) =&gt; Object.prototype.hasOwnProperty.call(obj, propName)</span><span class="s3">\n</span><span class="s1">const keys = obj =&gt; {</span><span class="s3">\n  </span><span class="s1">if (isPlainObject(obj) || Array.isArray(obj)) {</span><span class="s3">\n    </span><span class="s1">return Object.keys(obj)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const notUndefined = (val) =&gt; val !== undefined</span><span class="s3">\n</span><span class="s1">const isSchema = (val) =&gt; isPlainObject(val) || val === true || val === false</span><span class="s3">\n</span><span class="s1">const isEmptySchema = (obj) =&gt; (!keys(obj).length) &amp;&amp; obj !== false &amp;&amp; obj !== true</span><span class="s3">\n</span><span class="s1">const withoutArr = (arr, ...rest) =&gt; without.apply(null, [arr].concat(flatten(rest)))</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">allUniqueKeys,</span><span class="s3">\n  </span><span class="s1">deleteUndefinedProps,</span><span class="s3">\n  </span><span class="s1">getValues,</span><span class="s3">\n  </span><span class="s1">has,</span><span class="s3">\n  </span><span class="s1">isEmptySchema,</span><span class="s3">\n  </span><span class="s1">isSchema,</span><span class="s3">\n  </span><span class="s1">keys,</span><span class="s3">\n  </span><span class="s1">notUndefined,</span><span class="s3">\n  </span><span class="s1">uniqWith,</span><span class="s3">\n  </span><span class="s1">withoutArr</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\n</span><span class="s1">const compare = require('json-schema-compare')</span><span class="s3">\n</span><span class="s1">const forEach = require('lodash/forEach')</span><span class="s3">\n</span><span class="s1">const {</span><span class="s3">\n  </span><span class="s1">allUniqueKeys,</span><span class="s3">\n  </span><span class="s1">deleteUndefinedProps,</span><span class="s3">\n  </span><span class="s1">has,</span><span class="s3">\n  </span><span class="s1">isSchema,</span><span class="s3">\n  </span><span class="s1">notUndefined,</span><span class="s3">\n  </span><span class="s1">uniqWith</span><span class="s3">\n</span><span class="s1">} = require('../common')</span><span class="s3">\n\n</span><span class="s1">function removeFalseSchemasFromArray(target) {</span><span class="s3">\n  </span><span class="s1">forEach(target, function(schema, index) {</span><span class="s3">\n    </span><span class="s1">if (schema === false) {</span><span class="s3">\n      </span><span class="s1">target.splice(index, 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getItemSchemas(subSchemas, key) {</span><span class="s3">\n  </span><span class="s1">return subSchemas.map(function(sub) {</span><span class="s3">\n    </span><span class="s1">if (!sub) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Array.isArray(sub.items)) {</span><span class="s3">\n      </span><span class="s1">const schemaAtPos = sub.items[key]</span><span class="s3">\n      </span><span class="s1">if (isSchema(schemaAtPos)) {</span><span class="s3">\n        </span><span class="s1">return schemaAtPos</span><span class="s3">\n      </span><span class="s1">} else if (has(sub, 'additionalItems')) {</span><span class="s3">\n        </span><span class="s1">return sub.additionalItems</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return sub.items</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return undefined</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAdditionalSchemas(subSchemas) {</span><span class="s3">\n  </span><span class="s1">return subSchemas.map(function(sub) {</span><span class="s3">\n    </span><span class="s1">if (!sub) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (Array.isArray(sub.items)) {</span><span class="s3">\n      </span><span class="s1">return sub.additionalItems</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return sub.items</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Provide source when array</span><span class="s3">\n</span><span class="s1">function mergeItems(group, mergeSchemas, items) {</span><span class="s3">\n  </span><span class="s1">const allKeys = allUniqueKeys(items)</span><span class="s3">\n  </span><span class="s1">return allKeys.reduce(function(all, key) {</span><span class="s3">\n    </span><span class="s1">const schemas = getItemSchemas(group, key)</span><span class="s3">\n    </span><span class="s1">const compacted = uniqWith(schemas.filter(notUndefined), compare)</span><span class="s3">\n    </span><span class="s1">all[key] = mergeSchemas(compacted, key)</span><span class="s3">\n    </span><span class="s1">return all</span><span class="s3">\n  </span><span class="s1">}, [])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">keywords: ['items', 'additionalItems'],</span><span class="s3">\n  </span><span class="s1">resolver(values, parents, mergers) {</span><span class="s3">\n    </span><span class="s1">// const createSubMerger = groupKey =&gt; (schemas, key) =&gt; mergeSchemas(schemas, parents.concat(groupKey, key))</span><span class="s3">\n    </span><span class="s1">const items = values.map(s =&gt; s.items)</span><span class="s3">\n    </span><span class="s1">const itemsCompacted = items.filter(notUndefined)</span><span class="s3">\n    </span><span class="s1">const returnObject = {}</span><span class="s3">\n\n    </span><span class="s1">// if all items keyword values are schemas, we can merge them as simple schemas</span><span class="s3">\n    </span><span class="s1">// if not we need to merge them as mixed</span><span class="s3">\n    </span><span class="s1">if (itemsCompacted.every(isSchema)) {</span><span class="s3">\n      </span><span class="s1">returnObject.items = mergers.items(items)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">returnObject.items = mergeItems(values, mergers.items, items)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">let schemasAtLastPos</span><span class="s3">\n    </span><span class="s1">if (itemsCompacted.every(Array.isArray)) {</span><span class="s3">\n      </span><span class="s1">schemasAtLastPos = values.map(s =&gt; s.additionalItems)</span><span class="s3">\n    </span><span class="s1">} else if (itemsCompacted.some(Array.isArray)) {</span><span class="s3">\n      </span><span class="s1">schemasAtLastPos = getAdditionalSchemas(values)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (schemasAtLastPos) {</span><span class="s3">\n      </span><span class="s1">returnObject.additionalItems = mergers.additionalItems(schemasAtLastPos)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (returnObject.additionalItems === false &amp;&amp; Array.isArray(returnObject.items)) {</span><span class="s3">\n      </span><span class="s1">removeFalseSchemasFromArray(returnObject.items)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return deleteUndefinedProps(returnObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;</span><span class="s3">\n</span><span class="s1">const compare = require('json-schema-compare')</span><span class="s3">\n</span><span class="s1">const forEach = require('lodash/forEach')</span><span class="s3">\n</span><span class="s1">const {</span><span class="s3">\n  </span><span class="s1">allUniqueKeys,</span><span class="s3">\n  </span><span class="s1">deleteUndefinedProps,</span><span class="s3">\n  </span><span class="s1">getValues,</span><span class="s3">\n  </span><span class="s1">keys,</span><span class="s3">\n  </span><span class="s1">notUndefined,</span><span class="s3">\n  </span><span class="s1">uniqWith,</span><span class="s3">\n  </span><span class="s1">withoutArr</span><span class="s3">\n</span><span class="s1">} = require('../common')</span><span class="s3">\n\n</span><span class="s1">function removeFalseSchemas(target) {</span><span class="s3">\n  </span><span class="s1">forEach(target, function(schema, prop) {</span><span class="s3">\n    </span><span class="s1">if (schema === false) {</span><span class="s3">\n      </span><span class="s1">delete target[prop]</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function mergeSchemaGroup(group, mergeSchemas) {</span><span class="s3">\n  </span><span class="s1">const allKeys = allUniqueKeys(group)</span><span class="s3">\n  </span><span class="s1">return allKeys.reduce(function(all, key) {</span><span class="s3">\n    </span><span class="s1">const schemas = getValues(group, key)</span><span class="s3">\n    </span><span class="s1">const compacted = uniqWith(schemas.filter(notUndefined), compare)</span><span class="s3">\n    </span><span class="s1">all[key] = mergeSchemas(compacted, key)</span><span class="s3">\n    </span><span class="s1">return all</span><span class="s3">\n  </span><span class="s1">}, {})</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = {</span><span class="s3">\n  </span><span class="s1">keywords: ['properties', 'patternProperties', 'additionalProperties'],</span><span class="s3">\n  </span><span class="s1">resolver(values, parents, mergers, options) {</span><span class="s3">\n    </span><span class="s1">// first get rid of all non permitted properties</span><span class="s3">\n    </span><span class="s1">if (!options.ignoreAdditionalProperties) {</span><span class="s3">\n      </span><span class="s1">values.forEach(function(subSchema) {</span><span class="s3">\n        </span><span class="s1">const otherSubSchemas = values.filter(s =&gt; s !== subSchema)</span><span class="s3">\n        </span><span class="s1">const ownKeys = keys(subSchema.properties)</span><span class="s3">\n        </span><span class="s1">const ownPatternKeys = keys(subSchema.patternProperties)</span><span class="s3">\n        </span><span class="s1">const ownPatterns = ownPatternKeys.map(k =&gt; new RegExp(k))</span><span class="s3">\n        </span><span class="s1">otherSubSchemas.forEach(function(other) {</span><span class="s3">\n          </span><span class="s1">const allOtherKeys = keys(other.properties)</span><span class="s3">\n          </span><span class="s1">const keysMatchingPattern = allOtherKeys.filter(k =&gt; ownPatterns.some(pk =&gt; pk.test(k)))</span><span class="s3">\n          </span><span class="s1">const additionalKeys = withoutArr(allOtherKeys, ownKeys, keysMatchingPattern)</span><span class="s3">\n          </span><span class="s1">additionalKeys.forEach(function(key) {</span><span class="s3">\n            </span><span class="s1">other.properties[key] = mergers.properties([</span><span class="s3">\n              </span><span class="s1">other.properties[key], subSchema.additionalProperties</span><span class="s3">\n            </span><span class="s1">], key)</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n\n      </span><span class="s1">// remove disallowed patternProperties</span><span class="s3">\n      </span><span class="s1">values.forEach(function(subSchema) {</span><span class="s3">\n        </span><span class="s1">const otherSubSchemas = values.filter(s =&gt; s !== subSchema)</span><span class="s3">\n        </span><span class="s1">const ownPatternKeys = keys(subSchema.patternProperties)</span><span class="s3">\n        </span><span class="s1">if (subSchema.additionalProperties === false) {</span><span class="s3">\n          </span><span class="s1">otherSubSchemas.forEach(function(other) {</span><span class="s3">\n            </span><span class="s1">const allOtherPatterns = keys(other.patternProperties)</span><span class="s3">\n            </span><span class="s1">const additionalPatternKeys = withoutArr(allOtherPatterns, ownPatternKeys)</span><span class="s3">\n            </span><span class="s1">additionalPatternKeys.forEach(key =&gt; delete other.patternProperties[key])</span><span class="s3">\n          </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const returnObject = {</span><span class="s3">\n      </span><span class="s1">additionalProperties: mergers.additionalProperties(values.map(s =&gt; s.additionalProperties)),</span><span class="s3">\n      </span><span class="s1">patternProperties: mergeSchemaGroup(values.map(s =&gt; s.patternProperties), mergers.patternProperties),</span><span class="s3">\n      </span><span class="s1">properties: mergeSchemaGroup(values.map(s =&gt; s.properties), mergers.properties)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (returnObject.additionalProperties === false) {</span><span class="s3">\n      </span><span class="s1">removeFalseSchemas(returnObject.properties)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return deleteUndefinedProps(returnObject)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;const cloneDeep = require('lodash/cloneDeep')</span><span class="s3">\n</span><span class="s1">const compare = require('json-schema-compare')</span><span class="s3">\n</span><span class="s1">const computeLcm = require('compute-lcm')</span><span class="s3">\n</span><span class="s1">const defaultsDeep = require('lodash/defaultsDeep')</span><span class="s3">\n</span><span class="s1">const flatten = require('lodash/flatten')</span><span class="s3">\n</span><span class="s1">const flattenDeep = require('lodash/flattenDeep')</span><span class="s3">\n</span><span class="s1">const intersection = require('lodash/intersection')</span><span class="s3">\n</span><span class="s1">const intersectionWith = require('lodash/intersectionWith')</span><span class="s3">\n</span><span class="s1">const isEqual = require('lodash/isEqual')</span><span class="s3">\n</span><span class="s1">const isPlainObject = require('lodash/isPlainObject')</span><span class="s3">\n</span><span class="s1">const pullAll = require('lodash/pullAll')</span><span class="s3">\n</span><span class="s1">const sortBy = require('lodash/sortBy')</span><span class="s3">\n</span><span class="s1">const uniq = require('lodash/uniq')</span><span class="s3">\n</span><span class="s1">const uniqWith = require('lodash/uniqWith')</span><span class="s3">\n\n</span><span class="s1">const propertiesResolver = require('./complex-resolvers/properties')</span><span class="s3">\n</span><span class="s1">const itemsResolver = require('./complex-resolvers/items')</span><span class="s3">\n\n</span><span class="s1">const contains = (arr, val) =&gt; arr.indexOf(val) !== -1</span><span class="s3">\n</span><span class="s1">const isSchema = (val) =&gt; isPlainObject(val) || val === true || val === false</span><span class="s3">\n</span><span class="s1">const isFalse = (val) =&gt; val === false</span><span class="s3">\n</span><span class="s1">const isTrue = (val) =&gt; val === true</span><span class="s3">\n</span><span class="s1">const schemaResolver = (compacted, key, mergeSchemas) =&gt; mergeSchemas(compacted)</span><span class="s3">\n</span><span class="s1">const stringArray = (values) =&gt; sortBy(uniq(flattenDeep(values)))</span><span class="s3">\n</span><span class="s1">const notUndefined = (val) =&gt; val !== undefined</span><span class="s3">\n</span><span class="s1">const allUniqueKeys = (arr) =&gt; uniq(flattenDeep(arr.map(keys)))</span><span class="s3">\n\n</span><span class="s1">// resolvers</span><span class="s3">\n</span><span class="s1">const first = compacted =&gt; compacted[0]</span><span class="s3">\n</span><span class="s1">const required = compacted =&gt; stringArray(compacted)</span><span class="s3">\n</span><span class="s1">const maximumValue = compacted =&gt; Math.max.apply(Math, compacted)</span><span class="s3">\n</span><span class="s1">const minimumValue = compacted =&gt; Math.min.apply(Math, compacted)</span><span class="s3">\n</span><span class="s1">const uniqueItems = compacted =&gt; compacted.some(isTrue)</span><span class="s3">\n</span><span class="s1">const examples = compacted =&gt; uniqWith(flatten(compacted), isEqual)</span><span class="s3">\n\n</span><span class="s1">function compareProp(key) {</span><span class="s3">\n  </span><span class="s1">return function(a, b) {</span><span class="s3">\n    </span><span class="s1">return compare({</span><span class="s3">\n      </span><span class="s1">[key]: a</span><span class="s3">\n    </span><span class="s1">}, { [key]: b })</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAllOf(schema) {</span><span class="s3">\n  </span><span class="s1">let { allOf = [], ...copy } = schema</span><span class="s3">\n  </span><span class="s1">copy = isPlainObject(schema) ? copy : schema // if schema is boolean</span><span class="s3">\n  </span><span class="s1">return [copy, ...allOf.map(getAllOf)]</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getValues(schemas, key) {</span><span class="s3">\n  </span><span class="s1">return schemas.map(schema =&gt; schema &amp;&amp; schema[key])</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tryMergeSchemaGroups(schemaGroups, mergeSchemas) {</span><span class="s3">\n  </span><span class="s1">return schemaGroups.map(function(schemas, index) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">return mergeSchemas(schemas, index)</span><span class="s3">\n    </span><span class="s1">} catch (e) {</span><span class="s3">\n      </span><span class="s1">return undefined</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}).filter(notUndefined)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function keys(obj) {</span><span class="s3">\n  </span><span class="s1">if (isPlainObject(obj) || Array.isArray(obj)) {</span><span class="s3">\n    </span><span class="s1">return Object.keys(obj)</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return []</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function getAnyOfCombinations(arrOfArrays, combinations) {</span><span class="s3">\n  </span><span class="s1">combinations = combinations || []</span><span class="s3">\n  </span><span class="s1">if (!arrOfArrays.length) {</span><span class="s3">\n    </span><span class="s1">return combinations</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const values = arrOfArrays.slice(0).shift()</span><span class="s3">\n  </span><span class="s1">const rest = arrOfArrays.slice(1)</span><span class="s3">\n  </span><span class="s1">if (combinations.length) {</span><span class="s3">\n    </span><span class="s1">return getAnyOfCombinations(rest, flatten(combinations.map(combination =&gt; values.map(item =&gt; ([item].concat(combination))))))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return getAnyOfCombinations(rest, values.map(item =&gt; (item)))</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function throwIncompatible(values, paths) {</span><span class="s3">\n  </span><span class="s1">let asJSON</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">asJSON = values.map(function(val) {</span><span class="s3">\n      </span><span class="s1">return JSON.stringify(val, null, 2)</span><span class="s3">\n    </span><span class="s1">}).join('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n  </span><span class="s1">} catch (variable) {</span><span class="s3">\n    </span><span class="s1">asJSON = values.join(', ')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw new Error('Could not resolve values for path:</span><span class="s3">\&quot;</span><span class="s1">' + paths.join('.') + '</span><span class="s3">\&quot;</span><span class="s1">. They are probably incompatible. Values: </span><span class="s3">\\</span><span class="s1">n' + asJSON)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function callGroupResolver(complexKeywords, resolverName, schemas, mergeSchemas, options, parents) {</span><span class="s3">\n  </span><span class="s1">if (complexKeywords.length) {</span><span class="s3">\n    </span><span class="s1">const resolverConfig = options.complexResolvers[resolverName]</span><span class="s3">\n    </span><span class="s1">if (!resolverConfig || !resolverConfig.resolver) {</span><span class="s3">\n      </span><span class="s1">throw new Error('No resolver found for ' + resolverName)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// extract all keywords from all the schemas that have one or more</span><span class="s3">\n    </span><span class="s1">// then remove all undefined ones and not unique</span><span class="s3">\n    </span><span class="s1">const extractedKeywordsOnly = schemas.map(schema =&gt; complexKeywords.reduce((all, key) =&gt; {</span><span class="s3">\n      </span><span class="s1">if (schema[key] !== undefined) all[key] = schema[key]</span><span class="s3">\n      </span><span class="s1">return all</span><span class="s3">\n    </span><span class="s1">}, {}))</span><span class="s3">\n    </span><span class="s1">const unique = uniqWith(extractedKeywordsOnly, compare)</span><span class="s3">\n\n    </span><span class="s1">// create mergers that automatically add the path of the keyword for use in the complex resolver</span><span class="s3">\n    </span><span class="s1">const mergers = resolverConfig.keywords.reduce((all, key) =&gt; ({</span><span class="s3">\n      </span><span class="s1">...all,</span><span class="s3">\n      </span><span class="s1">[key]: (schemas, extraKey = []) =&gt; mergeSchemas(schemas, null, parents.concat(key, extraKey))</span><span class="s3">\n    </span><span class="s1">}), {})</span><span class="s3">\n\n    </span><span class="s1">const result = resolverConfig.resolver(unique, parents.concat(resolverName), mergers, options)</span><span class="s3">\n\n    </span><span class="s1">if (!isPlainObject(result)) {</span><span class="s3">\n      </span><span class="s1">throwIncompatible(unique, parents.concat(resolverName))</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return result</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createRequiredMetaArray(arr) {</span><span class="s3">\n  </span><span class="s1">return { required: arr }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const schemaGroupProps = ['properties', 'patternProperties', 'definitions', 'dependencies']</span><span class="s3">\n</span><span class="s1">const schemaArrays = ['anyOf', 'oneOf']</span><span class="s3">\n</span><span class="s1">const schemaProps = [</span><span class="s3">\n  </span><span class="s1">'additionalProperties',</span><span class="s3">\n  </span><span class="s1">'additionalItems',</span><span class="s3">\n  </span><span class="s1">'contains',</span><span class="s3">\n  </span><span class="s1">'propertyNames',</span><span class="s3">\n  </span><span class="s1">'not',</span><span class="s3">\n  </span><span class="s1">'items'</span><span class="s3">\n</span><span class="s1">]</span><span class="s3">\n\n</span><span class="s1">const defaultResolvers = {</span><span class="s3">\n  </span><span class="s1">type(compacted) {</span><span class="s3">\n    </span><span class="s1">if (compacted.some(Array.isArray)) {</span><span class="s3">\n      </span><span class="s1">const normalized = compacted.map(function(val) {</span><span class="s3">\n        </span><span class="s1">return Array.isArray(val)</span><span class="s3">\n          </span><span class="s1">? val</span><span class="s3">\n          </span><span class="s1">: [val]</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">const common = intersection.apply(null, normalized)</span><span class="s3">\n\n      </span><span class="s1">if (common.length === 1) {</span><span class="s3">\n        </span><span class="s1">return common[0]</span><span class="s3">\n      </span><span class="s1">} else if (common.length &gt; 1) {</span><span class="s3">\n        </span><span class="s1">return uniq(common)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">dependencies(compacted, paths, mergeSchemas) {</span><span class="s3">\n    </span><span class="s1">const allChildren = allUniqueKeys(compacted)</span><span class="s3">\n\n    </span><span class="s1">return allChildren.reduce(function(all, childKey) {</span><span class="s3">\n      </span><span class="s1">const childSchemas = getValues(compacted, childKey)</span><span class="s3">\n      </span><span class="s1">let innerCompacted = uniqWith(childSchemas.filter(notUndefined), isEqual)</span><span class="s3">\n\n      </span><span class="s1">// to support dependencies</span><span class="s3">\n      </span><span class="s1">const innerArrays = innerCompacted.filter(Array.isArray)</span><span class="s3">\n\n      </span><span class="s1">if (innerArrays.length) {</span><span class="s3">\n        </span><span class="s1">if (innerArrays.length === innerCompacted.length) {</span><span class="s3">\n          </span><span class="s1">all[childKey] = stringArray(innerCompacted)</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const innerSchemas = innerCompacted.filter(isSchema)</span><span class="s3">\n          </span><span class="s1">const arrayMetaScheams = innerArrays.map(createRequiredMetaArray)</span><span class="s3">\n          </span><span class="s1">all[childKey] = mergeSchemas(innerSchemas.concat(arrayMetaScheams), childKey)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return all</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">innerCompacted = uniqWith(innerCompacted, compare)</span><span class="s3">\n\n      </span><span class="s1">all[childKey] = mergeSchemas(innerCompacted, childKey)</span><span class="s3">\n      </span><span class="s1">return all</span><span class="s3">\n    </span><span class="s1">}, {})</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">oneOf(compacted, paths, mergeSchemas) {</span><span class="s3">\n    </span><span class="s1">const combinations = getAnyOfCombinations(cloneDeep(compacted))</span><span class="s3">\n    </span><span class="s1">const result = tryMergeSchemaGroups(combinations, mergeSchemas)</span><span class="s3">\n    </span><span class="s1">const unique = uniqWith(result, compare)</span><span class="s3">\n\n    </span><span class="s1">if (unique.length) {</span><span class="s3">\n      </span><span class="s1">return unique</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">not(compacted) {</span><span class="s3">\n    </span><span class="s1">return { anyOf: compacted }</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">pattern(compacted) {</span><span class="s3">\n    </span><span class="s1">return compacted.map(r =&gt; '(?=' + r + ')').join('')</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">multipleOf(compacted) {</span><span class="s3">\n    </span><span class="s1">let integers = compacted.slice(0)</span><span class="s3">\n    </span><span class="s1">let factor = 1</span><span class="s3">\n    </span><span class="s1">while (integers.some(n =&gt; !Number.isInteger(n))) {</span><span class="s3">\n      </span><span class="s1">integers = integers.map(n =&gt; n * 10)</span><span class="s3">\n      </span><span class="s1">factor = factor * 10</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return computeLcm(integers) / factor</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">enum(compacted) {</span><span class="s3">\n    </span><span class="s1">const enums = intersectionWith.apply(null, compacted.concat(isEqual))</span><span class="s3">\n    </span><span class="s1">if (enums.length) {</span><span class="s3">\n      </span><span class="s1">return sortBy(enums)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">defaultResolvers.$id = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.$ref = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.$schema = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.additionalItems = schemaResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.additionalProperties = schemaResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.anyOf = defaultResolvers.oneOf</span><span class="s3">\n</span><span class="s1">defaultResolvers.contains = schemaResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.default = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.definitions = defaultResolvers.dependencies</span><span class="s3">\n</span><span class="s1">defaultResolvers.description = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.examples = examples</span><span class="s3">\n</span><span class="s1">defaultResolvers.exclusiveMaximum = minimumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.exclusiveMinimum = maximumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.items = itemsResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.maximum = minimumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.maxItems = minimumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.maxLength = minimumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.maxProperties = minimumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.minimum = maximumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.minItems = maximumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.minLength = maximumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.minProperties = maximumValue</span><span class="s3">\n</span><span class="s1">defaultResolvers.properties = propertiesResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.propertyNames = schemaResolver</span><span class="s3">\n</span><span class="s1">defaultResolvers.required = required</span><span class="s3">\n</span><span class="s1">defaultResolvers.title = first</span><span class="s3">\n</span><span class="s1">defaultResolvers.uniqueItems = uniqueItems</span><span class="s3">\n\n</span><span class="s1">const defaultComplexResolvers = {</span><span class="s3">\n  </span><span class="s1">properties: propertiesResolver,</span><span class="s3">\n  </span><span class="s1">items: itemsResolver</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function merger(rootSchema, options, totalSchemas) {</span><span class="s3">\n  </span><span class="s1">totalSchemas = totalSchemas || []</span><span class="s3">\n  </span><span class="s1">options = defaultsDeep(options, {</span><span class="s3">\n    </span><span class="s1">ignoreAdditionalProperties: false,</span><span class="s3">\n    </span><span class="s1">resolvers: defaultResolvers,</span><span class="s3">\n    </span><span class="s1">complexResolvers: defaultComplexResolvers,</span><span class="s3">\n    </span><span class="s1">deep: true</span><span class="s3">\n  </span><span class="s1">})</span><span class="s3">\n\n  </span><span class="s1">const complexResolvers = Object.entries(options.complexResolvers)</span><span class="s3">\n\n  </span><span class="s1">function mergeSchemas(schemas, base, parents) {</span><span class="s3">\n    </span><span class="s1">schemas = cloneDeep(schemas.filter(notUndefined))</span><span class="s3">\n    </span><span class="s1">parents = parents || []</span><span class="s3">\n    </span><span class="s1">const merged = isPlainObject(base)</span><span class="s3">\n      </span><span class="s1">? base</span><span class="s3">\n      </span><span class="s1">: {}</span><span class="s3">\n\n    </span><span class="s1">// return undefined, an empty schema</span><span class="s3">\n    </span><span class="s1">if (!schemas.length) {</span><span class="s3">\n      </span><span class="s1">return</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (schemas.some(isFalse)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (schemas.every(isTrue)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// there are no false and we don't need the true ones as they accept everything</span><span class="s3">\n    </span><span class="s1">schemas = schemas.filter(isPlainObject)</span><span class="s3">\n\n    </span><span class="s1">const allKeys = allUniqueKeys(schemas)</span><span class="s3">\n    </span><span class="s1">if (options.deep &amp;&amp; contains(allKeys, 'allOf')) {</span><span class="s3">\n      </span><span class="s1">return merger({</span><span class="s3">\n        </span><span class="s1">allOf: schemas</span><span class="s3">\n      </span><span class="s1">}, options, totalSchemas)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">const complexKeysArr = complexResolvers.map(([mainKeyWord, resolverConf]) =&gt;</span><span class="s3">\n      </span><span class="s1">allKeys.filter(k =&gt; resolverConf.keywords.includes(k)))</span><span class="s3">\n\n    </span><span class="s1">// remove all complex keys before simple resolvers</span><span class="s3">\n    </span><span class="s1">complexKeysArr.forEach(keys =&gt; pullAll(allKeys, keys))</span><span class="s3">\n\n    </span><span class="s1">// call all simple resolvers for relevant keywords</span><span class="s3">\n    </span><span class="s1">allKeys.forEach(function(key) {</span><span class="s3">\n      </span><span class="s1">const values = getValues(schemas, key)</span><span class="s3">\n      </span><span class="s1">const compacted = uniqWith(values.filter(notUndefined), compareProp(key))</span><span class="s3">\n\n      </span><span class="s1">// arrayprops like anyOf and oneOf must be merged first, as they contains schemas</span><span class="s3">\n      </span><span class="s1">// allOf is treated differently alltogether</span><span class="s3">\n      </span><span class="s1">if (compacted.length === 1 &amp;&amp; contains(schemaArrays, key)) {</span><span class="s3">\n        </span><span class="s1">merged[key] = compacted[0].map(schema =&gt; mergeSchemas([schema], schema))</span><span class="s3">\n        </span><span class="s1">// prop groups must always be resolved</span><span class="s3">\n      </span><span class="s1">} else if (compacted.length === 1 &amp;&amp; !contains(schemaGroupProps, key) &amp;&amp; !contains(schemaProps, key)) {</span><span class="s3">\n        </span><span class="s1">merged[key] = compacted[0]</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">const resolver = options.resolvers[key] || options.resolvers.defaultResolver</span><span class="s3">\n        </span><span class="s1">if (!resolver) throw new Error('No resolver found for key ' + key + '. You can provide a resolver for this keyword in the options, or provide a default resolver.')</span><span class="s3">\n\n        </span><span class="s1">const merger = (schemas, extraKey = []) =&gt; mergeSchemas(schemas, null, parents.concat(key, extraKey))</span><span class="s3">\n        </span><span class="s1">merged[key] = resolver(compacted, parents.concat(key), merger, options)</span><span class="s3">\n\n        </span><span class="s1">if (merged[key] === undefined) {</span><span class="s3">\n          </span><span class="s1">throwIncompatible(compacted, parents.concat(key))</span><span class="s3">\n        </span><span class="s1">} else if (merged[key] === undefined) {</span><span class="s3">\n          </span><span class="s1">delete merged[key]</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n\n    </span><span class="s1">return complexResolvers.reduce((all, [resolverKeyword, config], index) =&gt; ({</span><span class="s3">\n      </span><span class="s1">...all,</span><span class="s3">\n      </span><span class="s1">...callGroupResolver(complexKeysArr[index], resolverKeyword, schemas, mergeSchemas, options, parents)</span><span class="s3">\n    </span><span class="s1">}), merged)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">const allSchemas = flattenDeep(getAllOf(rootSchema))</span><span class="s3">\n  </span><span class="s1">const merged = mergeSchemas(allSchemas)</span><span class="s3">\n\n  </span><span class="s1">return merged</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">merger.options = {</span><span class="s3">\n  </span><span class="s1">resolvers: defaultResolvers</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = merger</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var hasExcape = /~/</span><span class="s3">\n</span><span class="s1">var escapeMatcher = /~[01]/g</span><span class="s3">\n</span><span class="s1">function escapeReplacer (m) {</span><span class="s3">\n  </span><span class="s1">switch (m) {</span><span class="s3">\n    </span><span class="s1">case '~1': return '/'</span><span class="s3">\n    </span><span class="s1">case '~0': return '~'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">throw new Error('Invalid tilde escape: ' + m)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function untilde (str) {</span><span class="s3">\n  </span><span class="s1">if (!hasExcape.test(str)) return str</span><span class="s3">\n  </span><span class="s1">return str.replace(escapeMatcher, escapeReplacer)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function setter (obj, pointer, value) {</span><span class="s3">\n  </span><span class="s1">var part</span><span class="s3">\n  </span><span class="s1">var hasNextPart</span><span class="s3">\n\n  </span><span class="s1">for (var p = 1, len = pointer.length; p &lt; len;) {</span><span class="s3">\n    </span><span class="s1">if (pointer[p] === 'constructor' || pointer[p] === 'prototype' || pointer[p] === '__proto__') return obj</span><span class="s3">\n\n    </span><span class="s1">part = untilde(pointer[p++])</span><span class="s3">\n    </span><span class="s1">hasNextPart = len &gt; p</span><span class="s3">\n\n    </span><span class="s1">if (typeof obj[part] === 'undefined') {</span><span class="s3">\n      </span><span class="s1">// support setting of /-</span><span class="s3">\n      </span><span class="s1">if (Array.isArray(obj) &amp;&amp; part === '-') {</span><span class="s3">\n        </span><span class="s1">part = obj.length</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// support nested objects/array when setting values</span><span class="s3">\n      </span><span class="s1">if (hasNextPart) {</span><span class="s3">\n        </span><span class="s1">if ((pointer[p] !== '' &amp;&amp; pointer[p] &lt; Infinity) || pointer[p] === '-') obj[part] = []</span><span class="s3">\n        </span><span class="s1">else obj[part] = {}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!hasNextPart) break</span><span class="s3">\n    </span><span class="s1">obj = obj[part]</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var oldValue = obj[part]</span><span class="s3">\n  </span><span class="s1">if (value === undefined) delete obj[part]</span><span class="s3">\n  </span><span class="s1">else obj[part] = value</span><span class="s3">\n  </span><span class="s1">return oldValue</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function compilePointer (pointer) {</span><span class="s3">\n  </span><span class="s1">if (typeof pointer === 'string') {</span><span class="s3">\n    </span><span class="s1">pointer = pointer.split('/')</span><span class="s3">\n    </span><span class="s1">if (pointer[0] === '') return pointer</span><span class="s3">\n    </span><span class="s1">throw new Error('Invalid JSON pointer.')</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(pointer)) {</span><span class="s3">\n    </span><span class="s1">for (const part of pointer) {</span><span class="s3">\n      </span><span class="s1">if (typeof part !== 'string' &amp;&amp; typeof part !== 'number') {</span><span class="s3">\n        </span><span class="s1">throw new Error('Invalid JSON pointer. Must be of type string or number.')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return pointer</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">throw new Error('Invalid JSON pointer.')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function get (obj, pointer) {</span><span class="s3">\n  </span><span class="s1">if (typeof obj !== 'object') throw new Error('Invalid input object.')</span><span class="s3">\n  </span><span class="s1">pointer = compilePointer(pointer)</span><span class="s3">\n  </span><span class="s1">var len = pointer.length</span><span class="s3">\n  </span><span class="s1">if (len === 1) return obj</span><span class="s3">\n\n  </span><span class="s1">for (var p = 1; p &lt; len;) {</span><span class="s3">\n    </span><span class="s1">obj = obj[untilde(pointer[p++])]</span><span class="s3">\n    </span><span class="s1">if (len === p) return obj</span><span class="s3">\n    </span><span class="s1">if (typeof obj !== 'object' || obj === null) return undefined</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function set (obj, pointer, value) {</span><span class="s3">\n  </span><span class="s1">if (typeof obj !== 'object') throw new Error('Invalid input object.')</span><span class="s3">\n  </span><span class="s1">pointer = compilePointer(pointer)</span><span class="s3">\n  </span><span class="s1">if (pointer.length === 0) throw new Error('Invalid JSON pointer for set.')</span><span class="s3">\n  </span><span class="s1">return setter(obj, pointer, value)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function compile (pointer) {</span><span class="s3">\n  </span><span class="s1">var compiled = compilePointer(pointer)</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">get: function (object) {</span><span class="s3">\n      </span><span class="s1">return get(object, compiled)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">set: function (object, value) {</span><span class="s3">\n      </span><span class="s1">return set(object, compiled, value)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">exports.get = get</span><span class="s3">\n</span><span class="s1">exports.set = set</span><span class="s3">\n</span><span class="s1">exports.compile = compile</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var MapCache = require('./_MapCache'),</span><span class="s3">\n    </span><span class="s1">setCacheAdd = require('./_setCacheAdd'),</span><span class="s3">\n    </span><span class="s1">setCacheHas = require('./_setCacheHas');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Creates an array cache object to store unique values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @constructor</span><span class="s3">\n </span><span class="s1">* @param {Array} [values] The values to cache.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function SetCache(values) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = values == null ? 0 : values.length;</span><span class="s3">\n\n  </span><span class="s1">this.__data__ = new MapCache;</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">this.add(values[index]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">// Add methods to `SetCache`.</span><span class="s3">\n</span><span class="s1">SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;</span><span class="s3">\n</span><span class="s1">SetCache.prototype.has = setCacheHas;</span><span class="s3">\n\n</span><span class="s1">module.exports = SetCache;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIndexOf = require('./_baseIndexOf');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.includes` for arrays without support for</span><span class="s3">\n </span><span class="s1">* specifying an index to search from.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} target The value to search for.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `target` is found, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayIncludes(array, value) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return !!length &amp;&amp; baseIndexOf(array, value, 0) &gt; -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = arrayIncludes;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This function is like `arrayIncludes` except that it accepts a comparator.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} target The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparator The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `target` is found, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayIncludesWith(array, value, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (comparator(value, array[index])) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = arrayIncludesWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.reduce` for arrays without support for</span><span class="s3">\n </span><span class="s1">* iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {*} [accumulator] The initial value.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [initAccum] Specify using the first element of `array` as</span><span class="s3">\n </span><span class="s1">*  the initial value.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the accumulated value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arrayReduce(array, iteratee, accumulator, initAccum) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">if (initAccum &amp;&amp; length) {</span><span class="s3">\n    </span><span class="s1">accumulator = array[++index];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">accumulator = iteratee(accumulator, array[index], index, array);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return accumulator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = arrayReduce;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.some` for arrays without support for iteratee</span><span class="s3">\n </span><span class="s1">* shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} [array] The array to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if any element passes the predicate check,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function arraySome(array, predicate) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">length = array == null ? 0 : array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (predicate(array[index], index, array)) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = arraySome;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseAssignValue = require('./_baseAssignValue'),</span><span class="s3">\n    </span><span class="s1">eq = require('./eq');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This function is like `assignValue` except that it doesn't assign</span><span class="s3">\n </span><span class="s1">* `undefined` values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to modify.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to assign.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to assign.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function assignMergeValue(object, key, value) {</span><span class="s3">\n  </span><span class="s1">if ((value !== undefined &amp;&amp; !eq(object[key], value)) ||</span><span class="s3">\n      </span><span class="s1">(value === undefined &amp;&amp; !(key in object))) {</span><span class="s3">\n    </span><span class="s1">baseAssignValue(object, key, value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = assignMergeValue;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var SetCache = require('./_SetCache'),</span><span class="s3">\n    </span><span class="s1">arrayIncludes = require('./_arrayIncludes'),</span><span class="s3">\n    </span><span class="s1">arrayIncludesWith = require('./_arrayIncludesWith'),</span><span class="s3">\n    </span><span class="s1">arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseUnary = require('./_baseUnary'),</span><span class="s3">\n    </span><span class="s1">cacheHas = require('./_cacheHas');</span><span class="s3">\n\n</span><span class="s1">/** Used as the size to enable large array optimizations. */</span><span class="s3">\n</span><span class="s1">var LARGE_ARRAY_SIZE = 200;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of methods like `_.difference` without support</span><span class="s3">\n </span><span class="s1">* for excluding multiple arrays or iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Array} values The values to exclude.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of filtered values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseDifference(array, values, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">includes = arrayIncludes,</span><span class="s3">\n      </span><span class="s1">isCommon = true,</span><span class="s3">\n      </span><span class="s1">length = array.length,</span><span class="s3">\n      </span><span class="s1">result = [],</span><span class="s3">\n      </span><span class="s1">valuesLength = values.length;</span><span class="s3">\n\n  </span><span class="s1">if (!length) {</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (iteratee) {</span><span class="s3">\n    </span><span class="s1">values = arrayMap(values, baseUnary(iteratee));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (comparator) {</span><span class="s3">\n    </span><span class="s1">includes = arrayIncludesWith;</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (values.length &gt;= LARGE_ARRAY_SIZE) {</span><span class="s3">\n    </span><span class="s1">includes = cacheHas;</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">values = new SetCache(values);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">outer:</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">computed = iteratee == null ? value : iteratee(value);</span><span class="s3">\n\n    </span><span class="s1">value = (comparator || value !== 0) ? value : 0;</span><span class="s3">\n    </span><span class="s1">if (isCommon &amp;&amp; computed === computed) {</span><span class="s3">\n      </span><span class="s1">var valuesIndex = valuesLength;</span><span class="s3">\n      </span><span class="s1">while (valuesIndex--) {</span><span class="s3">\n        </span><span class="s1">if (values[valuesIndex] === computed) {</span><span class="s3">\n          </span><span class="s1">continue outer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!includes(values, computed, comparator)) {</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseDifference;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseForOwn = require('./_baseForOwn'),</span><span class="s3">\n    </span><span class="s1">createBaseEach = require('./_createBaseEach');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.forEach` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array|Object} Returns `collection`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var baseEach = createBaseEach(baseForOwn);</span><span class="s3">\n\n</span><span class="s1">module.exports = baseEach;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.findIndex` and `_.findLastIndex` without</span><span class="s3">\n </span><span class="s1">* support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} predicate The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {number} fromIndex The index to search from.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseFindIndex(array, predicate, fromIndex, fromRight) {</span><span class="s3">\n  </span><span class="s1">var length = array.length,</span><span class="s3">\n      </span><span class="s1">index = fromIndex + (fromRight ? 1 : -1);</span><span class="s3">\n\n  </span><span class="s1">while ((fromRight ? index-- : ++index &lt; length)) {</span><span class="s3">\n    </span><span class="s1">if (predicate(array[index], index, array)) {</span><span class="s3">\n      </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseFindIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var createBaseFor = require('./_createBaseFor');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `baseForOwn` which iterates over `object`</span><span class="s3">\n </span><span class="s1">* properties returned by `keysFunc` and invokes `iteratee` for each property.</span><span class="s3">\n </span><span class="s1">* Iteratee functions may exit iteration early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {Function} keysFunc The function to get the keys of `object`.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var baseFor = createBaseFor();</span><span class="s3">\n\n</span><span class="s1">module.exports = baseFor;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseFor = require('./_baseFor'),</span><span class="s3">\n    </span><span class="s1">keys = require('./keys');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.forOwn` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseForOwn(object, iteratee) {</span><span class="s3">\n  </span><span class="s1">return object &amp;&amp; baseFor(object, iteratee, keys);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseForOwn;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseFindIndex = require('./_baseFindIndex'),</span><span class="s3">\n    </span><span class="s1">baseIsNaN = require('./_baseIsNaN'),</span><span class="s3">\n    </span><span class="s1">strictIndexOf = require('./_strictIndexOf');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.indexOf` without `fromIndex` bounds checks.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {number} fromIndex The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIndexOf(array, value, fromIndex) {</span><span class="s3">\n  </span><span class="s1">return value === value</span><span class="s3">\n    </span><span class="s1">? strictIndexOf(array, value, fromIndex)</span><span class="s3">\n    </span><span class="s1">: baseFindIndex(array, baseIsNaN, fromIndex);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIndexOf;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This function is like `baseIndexOf` except that it accepts a comparator.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {number} fromIndex The index to search from.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparator The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIndexOfWith(array, value, fromIndex, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = fromIndex - 1,</span><span class="s3">\n      </span><span class="s1">length = array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (comparator(array[index], value)) {</span><span class="s3">\n      </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIndexOfWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var SetCache = require('./_SetCache'),</span><span class="s3">\n    </span><span class="s1">arrayIncludes = require('./_arrayIncludes'),</span><span class="s3">\n    </span><span class="s1">arrayIncludesWith = require('./_arrayIncludesWith'),</span><span class="s3">\n    </span><span class="s1">arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseUnary = require('./_baseUnary'),</span><span class="s3">\n    </span><span class="s1">cacheHas = require('./_cacheHas');</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMin = Math.min;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of methods like `_.intersection`, without support</span><span class="s3">\n </span><span class="s1">* for iteratee shorthands, that accepts an array of arrays to inspect.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} arrays The arrays to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of shared values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIntersection(arrays, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var includes = comparator ? arrayIncludesWith : arrayIncludes,</span><span class="s3">\n      </span><span class="s1">length = arrays[0].length,</span><span class="s3">\n      </span><span class="s1">othLength = arrays.length,</span><span class="s3">\n      </span><span class="s1">othIndex = othLength,</span><span class="s3">\n      </span><span class="s1">caches = Array(othLength),</span><span class="s3">\n      </span><span class="s1">maxLength = Infinity,</span><span class="s3">\n      </span><span class="s1">result = [];</span><span class="s3">\n\n  </span><span class="s1">while (othIndex--) {</span><span class="s3">\n    </span><span class="s1">var array = arrays[othIndex];</span><span class="s3">\n    </span><span class="s1">if (othIndex &amp;&amp; iteratee) {</span><span class="s3">\n      </span><span class="s1">array = arrayMap(array, baseUnary(iteratee));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maxLength = nativeMin(array.length, maxLength);</span><span class="s3">\n    </span><span class="s1">caches[othIndex] = !comparator &amp;&amp; (iteratee || (length &gt;= 120 &amp;&amp; array.length &gt;= 120))</span><span class="s3">\n      </span><span class="s1">? new SetCache(othIndex &amp;&amp; array)</span><span class="s3">\n      </span><span class="s1">: undefined;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">array = arrays[0];</span><span class="s3">\n\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">seen = caches[0];</span><span class="s3">\n\n  </span><span class="s1">outer:</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length &amp;&amp; result.length &lt; maxLength) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">computed = iteratee ? iteratee(value) : value;</span><span class="s3">\n\n    </span><span class="s1">value = (comparator || value !== 0) ? value : 0;</span><span class="s3">\n    </span><span class="s1">if (!(seen</span><span class="s3">\n          </span><span class="s1">? cacheHas(seen, computed)</span><span class="s3">\n          </span><span class="s1">: includes(result, computed, comparator)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">othIndex = othLength;</span><span class="s3">\n      </span><span class="s1">while (--othIndex) {</span><span class="s3">\n        </span><span class="s1">var cache = caches[othIndex];</span><span class="s3">\n        </span><span class="s1">if (!(cache</span><span class="s3">\n              </span><span class="s1">? cacheHas(cache, computed)</span><span class="s3">\n              </span><span class="s1">: includes(arrays[othIndex], computed, comparator))</span><span class="s3">\n            </span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">continue outer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (seen) {</span><span class="s3">\n        </span><span class="s1">seen.push(computed);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIntersection;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqualDeep = require('./_baseIsEqualDeep'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isEqual` which supports partial comparisons</span><span class="s3">\n </span><span class="s1">* and tracks traversed objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @param {boolean} bitmask The bitmask flags.</span><span class="s3">\n </span><span class="s1">*  1 - Unordered comparison</span><span class="s3">\n </span><span class="s1">*  2 - Partial comparison</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed `value` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsEqual(value, other, bitmask, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">if (value === other) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (value == null || other == null || (!isObjectLike(value) &amp;&amp; !isObjectLike(other))) {</span><span class="s3">\n    </span><span class="s1">return value !== value &amp;&amp; other !== other;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsEqual;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Stack = require('./_Stack'),</span><span class="s3">\n    </span><span class="s1">equalArrays = require('./_equalArrays'),</span><span class="s3">\n    </span><span class="s1">equalByTag = require('./_equalByTag'),</span><span class="s3">\n    </span><span class="s1">equalObjects = require('./_equalObjects'),</span><span class="s3">\n    </span><span class="s1">getTag = require('./_getTag'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">isBuffer = require('./isBuffer'),</span><span class="s3">\n    </span><span class="s1">isTypedArray = require('./isTypedArray');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1;</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var argsTag = '[object Arguments]',</span><span class="s3">\n    </span><span class="s1">arrayTag = '[object Array]',</span><span class="s3">\n    </span><span class="s1">objectTag = '[object Object]';</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqual` for arrays and objects which performs</span><span class="s3">\n </span><span class="s1">* deep comparisons and tracks traversed objects enabling objects with circular</span><span class="s3">\n </span><span class="s1">* references to be compared.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var objIsArr = isArray(object),</span><span class="s3">\n      </span><span class="s1">othIsArr = isArray(other),</span><span class="s3">\n      </span><span class="s1">objTag = objIsArr ? arrayTag : getTag(object),</span><span class="s3">\n      </span><span class="s1">othTag = othIsArr ? arrayTag : getTag(other);</span><span class="s3">\n\n  </span><span class="s1">objTag = objTag == argsTag ? objectTag : objTag;</span><span class="s3">\n  </span><span class="s1">othTag = othTag == argsTag ? objectTag : othTag;</span><span class="s3">\n\n  </span><span class="s1">var objIsObj = objTag == objectTag,</span><span class="s3">\n      </span><span class="s1">othIsObj = othTag == objectTag,</span><span class="s3">\n      </span><span class="s1">isSameTag = objTag == othTag;</span><span class="s3">\n\n  </span><span class="s1">if (isSameTag &amp;&amp; isBuffer(object)) {</span><span class="s3">\n    </span><span class="s1">if (!isBuffer(other)) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">objIsArr = true;</span><span class="s3">\n    </span><span class="s1">objIsObj = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isSameTag &amp;&amp; !objIsObj) {</span><span class="s3">\n    </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n    </span><span class="s1">return (objIsArr || isTypedArray(object))</span><span class="s3">\n      </span><span class="s1">? equalArrays(object, other, bitmask, customizer, equalFunc, stack)</span><span class="s3">\n      </span><span class="s1">: equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!(bitmask &amp; COMPARE_PARTIAL_FLAG)) {</span><span class="s3">\n    </span><span class="s1">var objIsWrapped = objIsObj &amp;&amp; hasOwnProperty.call(object, '__wrapped__'),</span><span class="s3">\n        </span><span class="s1">othIsWrapped = othIsObj &amp;&amp; hasOwnProperty.call(other, '__wrapped__');</span><span class="s3">\n\n    </span><span class="s1">if (objIsWrapped || othIsWrapped) {</span><span class="s3">\n      </span><span class="s1">var objUnwrapped = objIsWrapped ? object.value() : object,</span><span class="s3">\n          </span><span class="s1">othUnwrapped = othIsWrapped ? other.value() : other;</span><span class="s3">\n\n      </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n      </span><span class="s1">return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isSameTag) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n  </span><span class="s1">return equalObjects(object, other, bitmask, customizer, equalFunc, stack);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsEqualDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Stack = require('./_Stack'),</span><span class="s3">\n    </span><span class="s1">baseIsEqual = require('./_baseIsEqual');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isMatch` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The object of property values to match.</span><span class="s3">\n </span><span class="s1">* @param {Array} matchData The property names, values, and compare flags to match.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `object` is a match, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsMatch(object, source, matchData, customizer) {</span><span class="s3">\n  </span><span class="s1">var index = matchData.length,</span><span class="s3">\n      </span><span class="s1">length = index,</span><span class="s3">\n      </span><span class="s1">noCustomizer = !customizer;</span><span class="s3">\n\n  </span><span class="s1">if (object == null) {</span><span class="s3">\n    </span><span class="s1">return !length;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">object = Object(object);</span><span class="s3">\n  </span><span class="s1">while (index--) {</span><span class="s3">\n    </span><span class="s1">var data = matchData[index];</span><span class="s3">\n    </span><span class="s1">if ((noCustomizer &amp;&amp; data[2])</span><span class="s3">\n          </span><span class="s1">? data[1] !== object[data[0]]</span><span class="s3">\n          </span><span class="s1">: !(data[0] in object)</span><span class="s3">\n        </span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">data = matchData[index];</span><span class="s3">\n    </span><span class="s1">var key = data[0],</span><span class="s3">\n        </span><span class="s1">objValue = object[key],</span><span class="s3">\n        </span><span class="s1">srcValue = data[1];</span><span class="s3">\n\n    </span><span class="s1">if (noCustomizer &amp;&amp; data[2]) {</span><span class="s3">\n      </span><span class="s1">if (objValue === undefined &amp;&amp; !(key in object)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var stack = new Stack;</span><span class="s3">\n      </span><span class="s1">if (customizer) {</span><span class="s3">\n        </span><span class="s1">var result = customizer(objValue, srcValue, key, object, source, stack);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!(result === undefined</span><span class="s3">\n            </span><span class="s1">? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)</span><span class="s3">\n            </span><span class="s1">: result</span><span class="s3">\n          </span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsMatch;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.isNaN` without support for number objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIsNaN(value) {</span><span class="s3">\n  </span><span class="s1">return value !== value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIsNaN;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseMatches = require('./_baseMatches'),</span><span class="s3">\n    </span><span class="s1">baseMatchesProperty = require('./_baseMatchesProperty'),</span><span class="s3">\n    </span><span class="s1">identity = require('./identity'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">property = require('./property');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.iteratee`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} [value=_.identity] The value to convert to an iteratee.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the iteratee.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseIteratee(value) {</span><span class="s3">\n  </span><span class="s1">// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.</span><span class="s3">\n  </span><span class="s1">// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.</span><span class="s3">\n  </span><span class="s1">if (typeof value == 'function') {</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (value == null) {</span><span class="s3">\n    </span><span class="s1">return identity;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof value == 'object') {</span><span class="s3">\n    </span><span class="s1">return isArray(value)</span><span class="s3">\n      </span><span class="s1">? baseMatchesProperty(value[0], value[1])</span><span class="s3">\n      </span><span class="s1">: baseMatches(value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return property(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseIteratee;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseEach = require('./_baseEach'),</span><span class="s3">\n    </span><span class="s1">isArrayLike = require('./isArrayLike');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.map` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new mapped array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMap(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = isArrayLike(collection) ? Array(collection.length) : [];</span><span class="s3">\n\n  </span><span class="s1">baseEach(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">result[++index] = iteratee(value, key, collection);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseMap;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsMatch = require('./_baseIsMatch'),</span><span class="s3">\n    </span><span class="s1">getMatchData = require('./_getMatchData'),</span><span class="s3">\n    </span><span class="s1">matchesStrictComparable = require('./_matchesStrictComparable');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.matches` which doesn't clone `source`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} source The object of property values to match.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new spec function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMatches(source) {</span><span class="s3">\n  </span><span class="s1">var matchData = getMatchData(source);</span><span class="s3">\n  </span><span class="s1">if (matchData.length == 1 &amp;&amp; matchData[0][2]) {</span><span class="s3">\n    </span><span class="s1">return matchesStrictComparable(matchData[0][0], matchData[0][1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function(object) {</span><span class="s3">\n    </span><span class="s1">return object === source || baseIsMatch(object, source, matchData);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseMatches;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqual = require('./_baseIsEqual'),</span><span class="s3">\n    </span><span class="s1">get = require('./get'),</span><span class="s3">\n    </span><span class="s1">hasIn = require('./hasIn'),</span><span class="s3">\n    </span><span class="s1">isKey = require('./_isKey'),</span><span class="s3">\n    </span><span class="s1">isStrictComparable = require('./_isStrictComparable'),</span><span class="s3">\n    </span><span class="s1">matchesStrictComparable = require('./_matchesStrictComparable'),</span><span class="s3">\n    </span><span class="s1">toKey = require('./_toKey');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} path The path of the property to get.</span><span class="s3">\n </span><span class="s1">* @param {*} srcValue The value to match.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new spec function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMatchesProperty(path, srcValue) {</span><span class="s3">\n  </span><span class="s1">if (isKey(path) &amp;&amp; isStrictComparable(srcValue)) {</span><span class="s3">\n    </span><span class="s1">return matchesStrictComparable(toKey(path), srcValue);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return function(object) {</span><span class="s3">\n    </span><span class="s1">var objValue = get(object, path);</span><span class="s3">\n    </span><span class="s1">return (objValue === undefined &amp;&amp; objValue === srcValue)</span><span class="s3">\n      </span><span class="s1">? hasIn(object, path)</span><span class="s3">\n      </span><span class="s1">: baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseMatchesProperty;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Stack = require('./_Stack'),</span><span class="s3">\n    </span><span class="s1">assignMergeValue = require('./_assignMergeValue'),</span><span class="s3">\n    </span><span class="s1">baseFor = require('./_baseFor'),</span><span class="s3">\n    </span><span class="s1">baseMergeDeep = require('./_baseMergeDeep'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject'),</span><span class="s3">\n    </span><span class="s1">keysIn = require('./keysIn'),</span><span class="s3">\n    </span><span class="s1">safeGet = require('./_safeGet');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.merge` without support for multiple sources.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The source object.</span><span class="s3">\n </span><span class="s1">* @param {number} srcIndex The index of `source`.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize merged values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed source values and their merged</span><span class="s3">\n </span><span class="s1">*  counterparts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMerge(object, source, srcIndex, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">if (object === source) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">baseFor(source, function(srcValue, key) {</span><span class="s3">\n    </span><span class="s1">stack || (stack = new Stack);</span><span class="s3">\n    </span><span class="s1">if (isObject(srcValue)) {</span><span class="s3">\n      </span><span class="s1">baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">var newValue = customizer</span><span class="s3">\n        </span><span class="s1">? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)</span><span class="s3">\n        </span><span class="s1">: undefined;</span><span class="s3">\n\n      </span><span class="s1">if (newValue === undefined) {</span><span class="s3">\n        </span><span class="s1">newValue = srcValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">assignMergeValue(object, key, newValue);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, keysIn);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseMerge;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var assignMergeValue = require('./_assignMergeValue'),</span><span class="s3">\n    </span><span class="s1">cloneBuffer = require('./_cloneBuffer'),</span><span class="s3">\n    </span><span class="s1">cloneTypedArray = require('./_cloneTypedArray'),</span><span class="s3">\n    </span><span class="s1">copyArray = require('./_copyArray'),</span><span class="s3">\n    </span><span class="s1">initCloneObject = require('./_initCloneObject'),</span><span class="s3">\n    </span><span class="s1">isArguments = require('./isArguments'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">isArrayLikeObject = require('./isArrayLikeObject'),</span><span class="s3">\n    </span><span class="s1">isBuffer = require('./isBuffer'),</span><span class="s3">\n    </span><span class="s1">isFunction = require('./isFunction'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject'),</span><span class="s3">\n    </span><span class="s1">isPlainObject = require('./isPlainObject'),</span><span class="s3">\n    </span><span class="s1">isTypedArray = require('./isTypedArray'),</span><span class="s3">\n    </span><span class="s1">safeGet = require('./_safeGet'),</span><span class="s3">\n    </span><span class="s1">toPlainObject = require('./toPlainObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseMerge` for arrays and objects which performs</span><span class="s3">\n </span><span class="s1">* deep merges and tracks traversed objects enabling objects with circular</span><span class="s3">\n </span><span class="s1">* references to be merged.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The source object.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the value to merge.</span><span class="s3">\n </span><span class="s1">* @param {number} srcIndex The index of `source`.</span><span class="s3">\n </span><span class="s1">* @param {Function} mergeFunc The function to merge values.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize assigned values.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed source values and their merged</span><span class="s3">\n </span><span class="s1">*  counterparts.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {</span><span class="s3">\n  </span><span class="s1">var objValue = safeGet(object, key),</span><span class="s3">\n      </span><span class="s1">srcValue = safeGet(source, key),</span><span class="s3">\n      </span><span class="s1">stacked = stack.get(srcValue);</span><span class="s3">\n\n  </span><span class="s1">if (stacked) {</span><span class="s3">\n    </span><span class="s1">assignMergeValue(object, key, stacked);</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var newValue = customizer</span><span class="s3">\n    </span><span class="s1">? customizer(objValue, srcValue, (key + ''), object, source, stack)</span><span class="s3">\n    </span><span class="s1">: undefined;</span><span class="s3">\n\n  </span><span class="s1">var isCommon = newValue === undefined;</span><span class="s3">\n\n  </span><span class="s1">if (isCommon) {</span><span class="s3">\n    </span><span class="s1">var isArr = isArray(srcValue),</span><span class="s3">\n        </span><span class="s1">isBuff = !isArr &amp;&amp; isBuffer(srcValue),</span><span class="s3">\n        </span><span class="s1">isTyped = !isArr &amp;&amp; !isBuff &amp;&amp; isTypedArray(srcValue);</span><span class="s3">\n\n    </span><span class="s1">newValue = srcValue;</span><span class="s3">\n    </span><span class="s1">if (isArr || isBuff || isTyped) {</span><span class="s3">\n      </span><span class="s1">if (isArray(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = objValue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isArrayLikeObject(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = copyArray(objValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isBuff) {</span><span class="s3">\n        </span><span class="s1">isCommon = false;</span><span class="s3">\n        </span><span class="s1">newValue = cloneBuffer(srcValue, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (isTyped) {</span><span class="s3">\n        </span><span class="s1">isCommon = false;</span><span class="s3">\n        </span><span class="s1">newValue = cloneTypedArray(srcValue, true);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">newValue = [];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isPlainObject(srcValue) || isArguments(srcValue)) {</span><span class="s3">\n      </span><span class="s1">newValue = objValue;</span><span class="s3">\n      </span><span class="s1">if (isArguments(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = toPlainObject(objValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">else if (!isObject(objValue) || isFunction(objValue)) {</span><span class="s3">\n        </span><span class="s1">newValue = initCloneObject(srcValue);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isCommon) {</span><span class="s3">\n    </span><span class="s1">// Recursively merge objects and arrays (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">stack.set(srcValue, newValue);</span><span class="s3">\n    </span><span class="s1">mergeFunc(newValue, srcValue, srcIndex, customizer, stack);</span><span class="s3">\n    </span><span class="s1">stack['delete'](srcValue);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">assignMergeValue(object, key, newValue);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseMergeDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseGet = require('./_baseGet'),</span><span class="s3">\n    </span><span class="s1">baseIteratee = require('./_baseIteratee'),</span><span class="s3">\n    </span><span class="s1">baseMap = require('./_baseMap'),</span><span class="s3">\n    </span><span class="s1">baseSortBy = require('./_baseSortBy'),</span><span class="s3">\n    </span><span class="s1">baseUnary = require('./_baseUnary'),</span><span class="s3">\n    </span><span class="s1">compareMultiple = require('./_compareMultiple'),</span><span class="s3">\n    </span><span class="s1">identity = require('./identity'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.orderBy` without param guards.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.</span><span class="s3">\n </span><span class="s1">* @param {string[]} orders The sort orders of `iteratees`.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new sorted array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseOrderBy(collection, iteratees, orders) {</span><span class="s3">\n  </span><span class="s1">if (iteratees.length) {</span><span class="s3">\n    </span><span class="s1">iteratees = arrayMap(iteratees, function(iteratee) {</span><span class="s3">\n      </span><span class="s1">if (isArray(iteratee)) {</span><span class="s3">\n        </span><span class="s1">return function(value) {</span><span class="s3">\n          </span><span class="s1">return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return iteratee;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">iteratees = [identity];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var index = -1;</span><span class="s3">\n  </span><span class="s1">iteratees = arrayMap(iteratees, baseUnary(baseIteratee));</span><span class="s3">\n\n  </span><span class="s1">var result = baseMap(collection, function(value, key, collection) {</span><span class="s3">\n    </span><span class="s1">var criteria = arrayMap(iteratees, function(iteratee) {</span><span class="s3">\n      </span><span class="s1">return iteratee(value);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return { 'criteria': criteria, 'index': ++index, 'value': value };</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return baseSortBy(result, function(object, other) {</span><span class="s3">\n    </span><span class="s1">return compareMultiple(object, other, orders);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseOrderBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.property` without support for deep paths.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new accessor function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseProperty(key) {</span><span class="s3">\n  </span><span class="s1">return function(object) {</span><span class="s3">\n    </span><span class="s1">return object == null ? undefined : object[key];</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseProperty;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseGet = require('./_baseGet');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseProperty` which supports deep paths.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new accessor function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePropertyDeep(path) {</span><span class="s3">\n  </span><span class="s1">return function(object) {</span><span class="s3">\n    </span><span class="s1">return baseGet(object, path);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = basePropertyDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseIndexOf = require('./_baseIndexOf'),</span><span class="s3">\n    </span><span class="s1">baseIndexOfWith = require('./_baseIndexOfWith'),</span><span class="s3">\n    </span><span class="s1">baseUnary = require('./_baseUnary'),</span><span class="s3">\n    </span><span class="s1">copyArray = require('./_copyArray');</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var arrayProto = Array.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Built-in value references. */</span><span class="s3">\n</span><span class="s1">var splice = arrayProto.splice;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.pullAllBy` without support for iteratee</span><span class="s3">\n </span><span class="s1">* shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to modify.</span><span class="s3">\n </span><span class="s1">* @param {Array} values The values to remove.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function basePullAll(array, values, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var indexOf = comparator ? baseIndexOfWith : baseIndexOf,</span><span class="s3">\n      </span><span class="s1">index = -1,</span><span class="s3">\n      </span><span class="s1">length = values.length,</span><span class="s3">\n      </span><span class="s1">seen = array;</span><span class="s3">\n\n  </span><span class="s1">if (array === values) {</span><span class="s3">\n    </span><span class="s1">values = copyArray(values);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (iteratee) {</span><span class="s3">\n    </span><span class="s1">seen = arrayMap(array, baseUnary(iteratee));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var fromIndex = 0,</span><span class="s3">\n        </span><span class="s1">value = values[index],</span><span class="s3">\n        </span><span class="s1">computed = iteratee ? iteratee(value) : value;</span><span class="s3">\n\n    </span><span class="s1">while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) &gt; -1) {</span><span class="s3">\n      </span><span class="s1">if (seen !== array) {</span><span class="s3">\n        </span><span class="s1">splice.call(seen, fromIndex, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">splice.call(array, fromIndex, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = basePullAll;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.reduce` and `_.reduceRight`, without support</span><span class="s3">\n </span><span class="s1">* for iteratee shorthands, which iterates over `collection` using `eachFunc`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} iteratee The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {*} accumulator The initial value.</span><span class="s3">\n </span><span class="s1">* @param {boolean} initAccum Specify using the first or last element of</span><span class="s3">\n </span><span class="s1">*  `collection` as the initial value.</span><span class="s3">\n </span><span class="s1">* @param {Function} eachFunc The function to iterate over `collection`.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the accumulated value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {</span><span class="s3">\n  </span><span class="s1">eachFunc(collection, function(value, index, collection) {</span><span class="s3">\n    </span><span class="s1">accumulator = initAccum</span><span class="s3">\n      </span><span class="s1">? (initAccum = false, value)</span><span class="s3">\n      </span><span class="s1">: iteratee(accumulator, value, index, collection);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return accumulator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseReduce;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var identity = require('./identity'),</span><span class="s3">\n    </span><span class="s1">overRest = require('./_overRest'),</span><span class="s3">\n    </span><span class="s1">setToString = require('./_setToString');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.rest` which doesn't validate or coerce arguments.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} func The function to apply a rest parameter to.</span><span class="s3">\n </span><span class="s1">* @param {number} [start=func.length-1] The start position of the rest parameter.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseRest(func, start) {</span><span class="s3">\n  </span><span class="s1">return setToString(overRest(func, start, identity), func + '');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseRest;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.sortBy` which uses `comparer` to define the</span><span class="s3">\n </span><span class="s1">* sort order of `array` and replaces criteria objects with their corresponding</span><span class="s3">\n </span><span class="s1">* values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to sort.</span><span class="s3">\n </span><span class="s1">* @param {Function} comparer The function to define sort order.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseSortBy(array, comparer) {</span><span class="s3">\n  </span><span class="s1">var length = array.length;</span><span class="s3">\n\n  </span><span class="s1">array.sort(comparer);</span><span class="s3">\n  </span><span class="s1">while (length--) {</span><span class="s3">\n    </span><span class="s1">array[length] = array[length].value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseSortBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var trimmedEndIndex = require('./_trimmedEndIndex');</span><span class="s3">\n\n</span><span class="s1">/** Used to match leading whitespace. */</span><span class="s3">\n</span><span class="s1">var reTrimStart = /^</span><span class="s3">\\</span><span class="s1">s+/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.trim`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to trim.</span><span class="s3">\n </span><span class="s1">* @returns {string} Returns the trimmed string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseTrim(string) {</span><span class="s3">\n  </span><span class="s1">return string</span><span class="s3">\n    </span><span class="s1">? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')</span><span class="s3">\n    </span><span class="s1">: string;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseTrim;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var SetCache = require('./_SetCache'),</span><span class="s3">\n    </span><span class="s1">arrayIncludes = require('./_arrayIncludes'),</span><span class="s3">\n    </span><span class="s1">arrayIncludesWith = require('./_arrayIncludesWith'),</span><span class="s3">\n    </span><span class="s1">cacheHas = require('./_cacheHas'),</span><span class="s3">\n    </span><span class="s1">createSet = require('./_createSet'),</span><span class="s3">\n    </span><span class="s1">setToArray = require('./_setToArray');</span><span class="s3">\n\n</span><span class="s1">/** Used as the size to enable large array optimizations. */</span><span class="s3">\n</span><span class="s1">var LARGE_ARRAY_SIZE = 200;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The base implementation of `_.uniqBy` without support for iteratee shorthands.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee] The iteratee invoked per element.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new duplicate free array.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function baseUniq(array, iteratee, comparator) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">includes = arrayIncludes,</span><span class="s3">\n      </span><span class="s1">length = array.length,</span><span class="s3">\n      </span><span class="s1">isCommon = true,</span><span class="s3">\n      </span><span class="s1">result = [],</span><span class="s3">\n      </span><span class="s1">seen = result;</span><span class="s3">\n\n  </span><span class="s1">if (comparator) {</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">includes = arrayIncludesWith;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else if (length &gt;= LARGE_ARRAY_SIZE) {</span><span class="s3">\n    </span><span class="s1">var set = iteratee ? null : createSet(array);</span><span class="s3">\n    </span><span class="s1">if (set) {</span><span class="s3">\n      </span><span class="s1">return setToArray(set);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">isCommon = false;</span><span class="s3">\n    </span><span class="s1">includes = cacheHas;</span><span class="s3">\n    </span><span class="s1">seen = new SetCache;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n    </span><span class="s1">seen = iteratee ? [] : result;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">outer:</span><span class="s3">\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var value = array[index],</span><span class="s3">\n        </span><span class="s1">computed = iteratee ? iteratee(value) : value;</span><span class="s3">\n\n    </span><span class="s1">value = (comparator || value !== 0) ? value : 0;</span><span class="s3">\n    </span><span class="s1">if (isCommon &amp;&amp; computed === computed) {</span><span class="s3">\n      </span><span class="s1">var seenIndex = seen.length;</span><span class="s3">\n      </span><span class="s1">while (seenIndex--) {</span><span class="s3">\n        </span><span class="s1">if (seen[seenIndex] === computed) {</span><span class="s3">\n          </span><span class="s1">continue outer;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (iteratee) {</span><span class="s3">\n        </span><span class="s1">seen.push(computed);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (!includes(seen, computed, comparator)) {</span><span class="s3">\n      </span><span class="s1">if (seen !== result) {</span><span class="s3">\n        </span><span class="s1">seen.push(computed);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = baseUniq;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Checks if a `cache` value for `key` exists.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} cache The cache to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the entry to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function cacheHas(cache, key) {</span><span class="s3">\n  </span><span class="s1">return cache.has(key);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = cacheHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isArrayLikeObject = require('./isArrayLikeObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Casts `value` to an empty array if it's not an array like object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array|Object} Returns the cast array-like object.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function castArrayLikeObject(value) {</span><span class="s3">\n  </span><span class="s1">return isArrayLikeObject(value) ? value : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = castArrayLikeObject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var identity = require('./identity');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Casts `value` to `identity` if it's not a function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns cast function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function castFunction(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'function' ? value : identity;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = castFunction;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isSymbol = require('./isSymbol');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compares values to sort them in ascending order.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the sort order indicator for `value`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareAscending(value, other) {</span><span class="s3">\n  </span><span class="s1">if (value !== other) {</span><span class="s3">\n    </span><span class="s1">var valIsDefined = value !== undefined,</span><span class="s3">\n        </span><span class="s1">valIsNull = value === null,</span><span class="s3">\n        </span><span class="s1">valIsReflexive = value === value,</span><span class="s3">\n        </span><span class="s1">valIsSymbol = isSymbol(value);</span><span class="s3">\n\n    </span><span class="s1">var othIsDefined = other !== undefined,</span><span class="s3">\n        </span><span class="s1">othIsNull = other === null,</span><span class="s3">\n        </span><span class="s1">othIsReflexive = other === other,</span><span class="s3">\n        </span><span class="s1">othIsSymbol = isSymbol(other);</span><span class="s3">\n\n    </span><span class="s1">if ((!othIsNull &amp;&amp; !othIsSymbol &amp;&amp; !valIsSymbol &amp;&amp; value &gt; other) ||</span><span class="s3">\n        </span><span class="s1">(valIsSymbol &amp;&amp; othIsDefined &amp;&amp; othIsReflexive &amp;&amp; !othIsNull &amp;&amp; !othIsSymbol) ||</span><span class="s3">\n        </span><span class="s1">(valIsNull &amp;&amp; othIsDefined &amp;&amp; othIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">(!valIsDefined &amp;&amp; othIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">!valIsReflexive) {</span><span class="s3">\n      </span><span class="s1">return 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if ((!valIsNull &amp;&amp; !valIsSymbol &amp;&amp; !othIsSymbol &amp;&amp; value &lt; other) ||</span><span class="s3">\n        </span><span class="s1">(othIsSymbol &amp;&amp; valIsDefined &amp;&amp; valIsReflexive &amp;&amp; !valIsNull &amp;&amp; !valIsSymbol) ||</span><span class="s3">\n        </span><span class="s1">(othIsNull &amp;&amp; valIsDefined &amp;&amp; valIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">(!othIsDefined &amp;&amp; valIsReflexive) ||</span><span class="s3">\n        </span><span class="s1">!othIsReflexive) {</span><span class="s3">\n      </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = compareAscending;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var compareAscending = require('./_compareAscending');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.orderBy` to compare multiple properties of a value to another</span><span class="s3">\n </span><span class="s1">* and stable sort them.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If `orders` is unspecified, all values are sorted in ascending order. Otherwise,</span><span class="s3">\n </span><span class="s1">* specify an order of </span><span class="s3">\&quot;</span><span class="s1">desc</span><span class="s3">\&quot; </span><span class="s1">for descending or </span><span class="s3">\&quot;</span><span class="s1">asc</span><span class="s3">\&quot; </span><span class="s1">for ascending sort order</span><span class="s3">\n </span><span class="s1">* of corresponding values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {boolean[]|string[]} orders The order to sort by for each property.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the sort order indicator for `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function compareMultiple(object, other, orders) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">objCriteria = object.criteria,</span><span class="s3">\n      </span><span class="s1">othCriteria = other.criteria,</span><span class="s3">\n      </span><span class="s1">length = objCriteria.length,</span><span class="s3">\n      </span><span class="s1">ordersLength = orders.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var result = compareAscending(objCriteria[index], othCriteria[index]);</span><span class="s3">\n    </span><span class="s1">if (result) {</span><span class="s3">\n      </span><span class="s1">if (index &gt;= ordersLength) {</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var order = orders[index];</span><span class="s3">\n      </span><span class="s1">return result * (order == 'desc' ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications</span><span class="s3">\n  </span><span class="s1">// that causes it, under certain circumstances, to provide the same value for</span><span class="s3">\n  </span><span class="s1">// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247</span><span class="s3">\n  </span><span class="s1">// for more details.</span><span class="s3">\n  </span><span class="s1">//</span><span class="s3">\n  </span><span class="s1">// This also ensures a stable sort in V8 and other engines.</span><span class="s3">\n  </span><span class="s1">// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.</span><span class="s3">\n  </span><span class="s1">return object.index - other.index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = compareMultiple;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">isIterateeCall = require('./_isIterateeCall');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function like `_.assign`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} assigner The function to assign values.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new assigner function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createAssigner(assigner) {</span><span class="s3">\n  </span><span class="s1">return baseRest(function(object, sources) {</span><span class="s3">\n    </span><span class="s1">var index = -1,</span><span class="s3">\n        </span><span class="s1">length = sources.length,</span><span class="s3">\n        </span><span class="s1">customizer = length &gt; 1 ? sources[length - 1] : undefined,</span><span class="s3">\n        </span><span class="s1">guard = length &gt; 2 ? sources[2] : undefined;</span><span class="s3">\n\n    </span><span class="s1">customizer = (assigner.length &gt; 3 &amp;&amp; typeof customizer == 'function')</span><span class="s3">\n      </span><span class="s1">? (length--, customizer)</span><span class="s3">\n      </span><span class="s1">: undefined;</span><span class="s3">\n\n    </span><span class="s1">if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {</span><span class="s3">\n      </span><span class="s1">customizer = length &lt; 3 ? undefined : customizer;</span><span class="s3">\n      </span><span class="s1">length = 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">object = Object(object);</span><span class="s3">\n    </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n      </span><span class="s1">var source = sources[index];</span><span class="s3">\n      </span><span class="s1">if (source) {</span><span class="s3">\n        </span><span class="s1">assigner(object, source, index, customizer);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = createAssigner;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isArrayLike = require('./isArrayLike');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a `baseEach` or `baseEachRight` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Function} eachFunc The function to iterate over a collection.</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new base function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createBaseEach(eachFunc, fromRight) {</span><span class="s3">\n  </span><span class="s1">return function(collection, iteratee) {</span><span class="s3">\n    </span><span class="s1">if (collection == null) {</span><span class="s3">\n      </span><span class="s1">return collection;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!isArrayLike(collection)) {</span><span class="s3">\n      </span><span class="s1">return eachFunc(collection, iteratee);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var length = collection.length,</span><span class="s3">\n        </span><span class="s1">index = fromRight ? length : -1,</span><span class="s3">\n        </span><span class="s1">iterable = Object(collection);</span><span class="s3">\n\n    </span><span class="s1">while ((fromRight ? index-- : ++index &lt; length)) {</span><span class="s3">\n      </span><span class="s1">if (iteratee(iterable[index], index, iterable) === false) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return collection;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = createBaseEach;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Creates a base function for methods like `_.forIn` and `_.forOwn`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {boolean} [fromRight] Specify iterating from right to left.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new base function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function createBaseFor(fromRight) {</span><span class="s3">\n  </span><span class="s1">return function(object, iteratee, keysFunc) {</span><span class="s3">\n    </span><span class="s1">var index = -1,</span><span class="s3">\n        </span><span class="s1">iterable = Object(object),</span><span class="s3">\n        </span><span class="s1">props = keysFunc(object),</span><span class="s3">\n        </span><span class="s1">length = props.length;</span><span class="s3">\n\n    </span><span class="s1">while (length--) {</span><span class="s3">\n      </span><span class="s1">var key = props[fromRight ? length : ++index];</span><span class="s3">\n      </span><span class="s1">if (iteratee(iterable[key], key, iterable) === false) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return object;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = createBaseFor;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Set = require('./_Set'),</span><span class="s3">\n    </span><span class="s1">noop = require('./noop'),</span><span class="s3">\n    </span><span class="s1">setToArray = require('./_setToArray');</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var INFINITY = 1 / 0;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a set object of `values`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} values The values to add to the set.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the new set.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var createSet = !(Set &amp;&amp; (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {</span><span class="s3">\n  </span><span class="s1">return new Set(values);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = createSet;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseMerge = require('./_baseMerge'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.defaultsDeep` to customize its `_.merge` use to merge source</span><span class="s3">\n </span><span class="s1">* objects into destination objects that are passed thru.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} objValue The destination value.</span><span class="s3">\n </span><span class="s1">* @param {*} srcValue The source value.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to merge.</span><span class="s3">\n </span><span class="s1">* @param {Object} object The parent object of `objValue`.</span><span class="s3">\n </span><span class="s1">* @param {Object} source The parent object of `srcValue`.</span><span class="s3">\n </span><span class="s1">* @param {Object} [stack] Tracks traversed source values and their merged</span><span class="s3">\n </span><span class="s1">*  counterparts.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the value to assign.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {</span><span class="s3">\n  </span><span class="s1">if (isObject(objValue) &amp;&amp; isObject(srcValue)) {</span><span class="s3">\n    </span><span class="s1">// Recursively merge objects and arrays (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">stack.set(srcValue, objValue);</span><span class="s3">\n    </span><span class="s1">baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);</span><span class="s3">\n    </span><span class="s1">stack['delete'](srcValue);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return objValue;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = customDefaultsMerge;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var SetCache = require('./_SetCache'),</span><span class="s3">\n    </span><span class="s1">arraySome = require('./_arraySome'),</span><span class="s3">\n    </span><span class="s1">cacheHas = require('./_cacheHas');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for arrays with support for</span><span class="s3">\n </span><span class="s1">* partial deep comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to compare.</span><span class="s3">\n </span><span class="s1">* @param {Array} other The other array to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `array` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span><span class="s3">\n      </span><span class="s1">arrLength = array.length,</span><span class="s3">\n      </span><span class="s1">othLength = other.length;</span><span class="s3">\n\n  </span><span class="s1">if (arrLength != othLength &amp;&amp; !(isPartial &amp;&amp; othLength &gt; arrLength)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Check that cyclic values are equal.</span><span class="s3">\n  </span><span class="s1">var arrStacked = stack.get(array);</span><span class="s3">\n  </span><span class="s1">var othStacked = stack.get(other);</span><span class="s3">\n  </span><span class="s1">if (arrStacked &amp;&amp; othStacked) {</span><span class="s3">\n    </span><span class="s1">return arrStacked == other &amp;&amp; othStacked == array;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = true,</span><span class="s3">\n      </span><span class="s1">seen = (bitmask &amp; COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;</span><span class="s3">\n\n  </span><span class="s1">stack.set(array, other);</span><span class="s3">\n  </span><span class="s1">stack.set(other, array);</span><span class="s3">\n\n  </span><span class="s1">// Ignore non-index properties.</span><span class="s3">\n  </span><span class="s1">while (++index &lt; arrLength) {</span><span class="s3">\n    </span><span class="s1">var arrValue = array[index],</span><span class="s3">\n        </span><span class="s1">othValue = other[index];</span><span class="s3">\n\n    </span><span class="s1">if (customizer) {</span><span class="s3">\n      </span><span class="s1">var compared = isPartial</span><span class="s3">\n        </span><span class="s1">? customizer(othValue, arrValue, index, other, array, stack)</span><span class="s3">\n        </span><span class="s1">: customizer(arrValue, othValue, index, array, other, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (compared !== undefined) {</span><span class="s3">\n      </span><span class="s1">if (compared) {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Recursively compare arrays (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">if (seen) {</span><span class="s3">\n      </span><span class="s1">if (!arraySome(other, function(othValue, othIndex) {</span><span class="s3">\n            </span><span class="s1">if (!cacheHas(seen, othIndex) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {</span><span class="s3">\n              </span><span class="s1">return seen.push(othIndex);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">})) {</span><span class="s3">\n        </span><span class="s1">result = false;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (!(</span><span class="s3">\n          </span><span class="s1">arrValue === othValue ||</span><span class="s3">\n            </span><span class="s1">equalFunc(arrValue, othValue, bitmask, customizer, stack)</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack['delete'](array);</span><span class="s3">\n  </span><span class="s1">stack['delete'](other);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalArrays;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var Symbol = require('./_Symbol'),</span><span class="s3">\n    </span><span class="s1">Uint8Array = require('./_Uint8Array'),</span><span class="s3">\n    </span><span class="s1">eq = require('./eq'),</span><span class="s3">\n    </span><span class="s1">equalArrays = require('./_equalArrays'),</span><span class="s3">\n    </span><span class="s1">mapToArray = require('./_mapToArray'),</span><span class="s3">\n    </span><span class="s1">setToArray = require('./_setToArray');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1,</span><span class="s3">\n    </span><span class="s1">COMPARE_UNORDERED_FLAG = 2;</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var boolTag = '[object Boolean]',</span><span class="s3">\n    </span><span class="s1">dateTag = '[object Date]',</span><span class="s3">\n    </span><span class="s1">errorTag = '[object Error]',</span><span class="s3">\n    </span><span class="s1">mapTag = '[object Map]',</span><span class="s3">\n    </span><span class="s1">numberTag = '[object Number]',</span><span class="s3">\n    </span><span class="s1">regexpTag = '[object RegExp]',</span><span class="s3">\n    </span><span class="s1">setTag = '[object Set]',</span><span class="s3">\n    </span><span class="s1">stringTag = '[object String]',</span><span class="s3">\n    </span><span class="s1">symbolTag = '[object Symbol]';</span><span class="s3">\n\n</span><span class="s1">var arrayBufferTag = '[object ArrayBuffer]',</span><span class="s3">\n    </span><span class="s1">dataViewTag = '[object DataView]';</span><span class="s3">\n\n</span><span class="s1">/** Used to convert symbols to primitives and strings. */</span><span class="s3">\n</span><span class="s1">var symbolProto = Symbol ? Symbol.prototype : undefined,</span><span class="s3">\n    </span><span class="s1">symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for comparing objects of</span><span class="s3">\n </span><span class="s1">* the same `toStringTag`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This function only supports comparing values with tags of</span><span class="s3">\n </span><span class="s1">* `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {string} tag The `toStringTag` of the objects to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">switch (tag) {</span><span class="s3">\n    </span><span class="s1">case dataViewTag:</span><span class="s3">\n      </span><span class="s1">if ((object.byteLength != other.byteLength) ||</span><span class="s3">\n          </span><span class="s1">(object.byteOffset != other.byteOffset)) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">object = object.buffer;</span><span class="s3">\n      </span><span class="s1">other = other.buffer;</span><span class="s3">\n\n    </span><span class="s1">case arrayBufferTag:</span><span class="s3">\n      </span><span class="s1">if ((object.byteLength != other.byteLength) ||</span><span class="s3">\n          </span><span class="s1">!equalFunc(new Uint8Array(object), new Uint8Array(other))) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n\n    </span><span class="s1">case boolTag:</span><span class="s3">\n    </span><span class="s1">case dateTag:</span><span class="s3">\n    </span><span class="s1">case numberTag:</span><span class="s3">\n      </span><span class="s1">// Coerce booleans to `1` or `0` and dates to milliseconds.</span><span class="s3">\n      </span><span class="s1">// Invalid dates are coerced to `NaN`.</span><span class="s3">\n      </span><span class="s1">return eq(+object, +other);</span><span class="s3">\n\n    </span><span class="s1">case errorTag:</span><span class="s3">\n      </span><span class="s1">return object.name == other.name &amp;&amp; object.message == other.message;</span><span class="s3">\n\n    </span><span class="s1">case regexpTag:</span><span class="s3">\n    </span><span class="s1">case stringTag:</span><span class="s3">\n      </span><span class="s1">// Coerce regexes to strings and treat strings, primitives and objects,</span><span class="s3">\n      </span><span class="s1">// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring</span><span class="s3">\n      </span><span class="s1">// for more details.</span><span class="s3">\n      </span><span class="s1">return object == (other + '');</span><span class="s3">\n\n    </span><span class="s1">case mapTag:</span><span class="s3">\n      </span><span class="s1">var convert = mapToArray;</span><span class="s3">\n\n    </span><span class="s1">case setTag:</span><span class="s3">\n      </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG;</span><span class="s3">\n      </span><span class="s1">convert || (convert = setToArray);</span><span class="s3">\n\n      </span><span class="s1">if (object.size != other.size &amp;&amp; !isPartial) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Assume cyclic values are equal.</span><span class="s3">\n      </span><span class="s1">var stacked = stack.get(object);</span><span class="s3">\n      </span><span class="s1">if (stacked) {</span><span class="s3">\n        </span><span class="s1">return stacked == other;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">bitmask |= COMPARE_UNORDERED_FLAG;</span><span class="s3">\n\n      </span><span class="s1">// Recursively compare objects (susceptible to call stack limits).</span><span class="s3">\n      </span><span class="s1">stack.set(object, other);</span><span class="s3">\n      </span><span class="s1">var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);</span><span class="s3">\n      </span><span class="s1">stack['delete'](object);</span><span class="s3">\n      </span><span class="s1">return result;</span><span class="s3">\n\n    </span><span class="s1">case symbolTag:</span><span class="s3">\n      </span><span class="s1">if (symbolValueOf) {</span><span class="s3">\n        </span><span class="s1">return symbolValueOf.call(object) == symbolValueOf.call(other);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalByTag;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var getAllKeys = require('./_getAllKeys');</span><span class="s3">\n\n</span><span class="s1">/** Used to compose bitmasks for value comparisons. */</span><span class="s3">\n</span><span class="s1">var COMPARE_PARTIAL_FLAG = 1;</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `baseIsEqualDeep` for objects with support for</span><span class="s3">\n </span><span class="s1">* partial deep comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to compare.</span><span class="s3">\n </span><span class="s1">* @param {Object} other The other object to compare.</span><span class="s3">\n </span><span class="s1">* @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @param {Function} equalFunc The function to determine equivalents of values.</span><span class="s3">\n </span><span class="s1">* @param {Object} stack Tracks traversed `object` and `other` objects.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the objects are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {</span><span class="s3">\n  </span><span class="s1">var isPartial = bitmask &amp; COMPARE_PARTIAL_FLAG,</span><span class="s3">\n      </span><span class="s1">objProps = getAllKeys(object),</span><span class="s3">\n      </span><span class="s1">objLength = objProps.length,</span><span class="s3">\n      </span><span class="s1">othProps = getAllKeys(other),</span><span class="s3">\n      </span><span class="s1">othLength = othProps.length;</span><span class="s3">\n\n  </span><span class="s1">if (objLength != othLength &amp;&amp; !isPartial) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = objLength;</span><span class="s3">\n  </span><span class="s1">while (index--) {</span><span class="s3">\n    </span><span class="s1">var key = objProps[index];</span><span class="s3">\n    </span><span class="s1">if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Check that cyclic values are equal.</span><span class="s3">\n  </span><span class="s1">var objStacked = stack.get(object);</span><span class="s3">\n  </span><span class="s1">var othStacked = stack.get(other);</span><span class="s3">\n  </span><span class="s1">if (objStacked &amp;&amp; othStacked) {</span><span class="s3">\n    </span><span class="s1">return objStacked == other &amp;&amp; othStacked == object;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var result = true;</span><span class="s3">\n  </span><span class="s1">stack.set(object, other);</span><span class="s3">\n  </span><span class="s1">stack.set(other, object);</span><span class="s3">\n\n  </span><span class="s1">var skipCtor = isPartial;</span><span class="s3">\n  </span><span class="s1">while (++index &lt; objLength) {</span><span class="s3">\n    </span><span class="s1">key = objProps[index];</span><span class="s3">\n    </span><span class="s1">var objValue = object[key],</span><span class="s3">\n        </span><span class="s1">othValue = other[key];</span><span class="s3">\n\n    </span><span class="s1">if (customizer) {</span><span class="s3">\n      </span><span class="s1">var compared = isPartial</span><span class="s3">\n        </span><span class="s1">? customizer(othValue, objValue, key, other, object, stack)</span><span class="s3">\n        </span><span class="s1">: customizer(objValue, othValue, key, object, other, stack);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Recursively compare objects (susceptible to call stack limits).</span><span class="s3">\n    </span><span class="s1">if (!(compared === undefined</span><span class="s3">\n          </span><span class="s1">? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))</span><span class="s3">\n          </span><span class="s1">: compared</span><span class="s3">\n        </span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">skipCtor || (skipCtor = key == 'constructor');</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (result &amp;&amp; !skipCtor) {</span><span class="s3">\n    </span><span class="s1">var objCtor = object.constructor,</span><span class="s3">\n        </span><span class="s1">othCtor = other.constructor;</span><span class="s3">\n\n    </span><span class="s1">// Non `Object` object instances with different constructors are not equal.</span><span class="s3">\n    </span><span class="s1">if (objCtor != othCtor &amp;&amp;</span><span class="s3">\n        </span><span class="s1">('constructor' in object &amp;&amp; 'constructor' in other) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">!(typeof objCtor == 'function' &amp;&amp; objCtor instanceof objCtor &amp;&amp;</span><span class="s3">\n          </span><span class="s1">typeof othCtor == 'function' &amp;&amp; othCtor instanceof othCtor)) {</span><span class="s3">\n      </span><span class="s1">result = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">stack['delete'](object);</span><span class="s3">\n  </span><span class="s1">stack['delete'](other);</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = equalObjects;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isStrictComparable = require('./_isStrictComparable'),</span><span class="s3">\n    </span><span class="s1">keys = require('./keys');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the property names, values, and compare flags of `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the match data of `object`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getMatchData(object) {</span><span class="s3">\n  </span><span class="s1">var result = keys(object),</span><span class="s3">\n      </span><span class="s1">length = result.length;</span><span class="s3">\n\n  </span><span class="s1">while (length--) {</span><span class="s3">\n    </span><span class="s1">var key = result[length],</span><span class="s3">\n        </span><span class="s1">value = object[key];</span><span class="s3">\n\n    </span><span class="s1">result[length] = [key, value, isStrictComparable(value)];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = getMatchData;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var eq = require('./eq'),</span><span class="s3">\n    </span><span class="s1">isArrayLike = require('./isArrayLike'),</span><span class="s3">\n    </span><span class="s1">isIndex = require('./_isIndex'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if the given arguments are from an iteratee call.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The potential iteratee value argument.</span><span class="s3">\n </span><span class="s1">* @param {*} index The potential iteratee index or key argument.</span><span class="s3">\n </span><span class="s1">* @param {*} object The potential iteratee object argument.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the arguments are from an iteratee call,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isIterateeCall(value, index, object) {</span><span class="s3">\n  </span><span class="s1">if (!isObject(object)) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var type = typeof index;</span><span class="s3">\n  </span><span class="s1">if (type == 'number'</span><span class="s3">\n        </span><span class="s1">? (isArrayLike(object) &amp;&amp; isIndex(index, object.length))</span><span class="s3">\n        </span><span class="s1">: (type == 'string' &amp;&amp; index in object)</span><span class="s3">\n      </span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return eq(object[index], value);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isIterateeCall;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isObject = require('./isObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is suitable for strict equality comparisons, i.e. `===`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` if suitable for strict</span><span class="s3">\n </span><span class="s1">*  equality comparisons, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isStrictComparable(value) {</span><span class="s3">\n  </span><span class="s1">return value === value &amp;&amp; !isObject(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isStrictComparable;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Converts `map` to its key-value pairs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} map The map to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the key-value pairs.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function mapToArray(map) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = Array(map.size);</span><span class="s3">\n\n  </span><span class="s1">map.forEach(function(value, key) {</span><span class="s3">\n    </span><span class="s1">result[++index] = [key, value];</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = mapToArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `matchesProperty` for source values suitable</span><span class="s3">\n </span><span class="s1">* for strict equality comparisons, i.e. `===`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @param {*} srcValue The value to match.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new spec function.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function matchesStrictComparable(key, srcValue) {</span><span class="s3">\n  </span><span class="s1">return function(object) {</span><span class="s3">\n    </span><span class="s1">if (object == null) {</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return object[key] === srcValue &amp;&amp;</span><span class="s3">\n      </span><span class="s1">(srcValue !== undefined || (key in Object(object)));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = matchesStrictComparable;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Gets the value at `key`, unless `key` is </span><span class="s3">\&quot;</span><span class="s1">__proto__</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">constructor</span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to query.</span><span class="s3">\n </span><span class="s1">* @param {string} key The key of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the property value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function safeGet(object, key) {</span><span class="s3">\n  </span><span class="s1">if (key === 'constructor' &amp;&amp; typeof object[key] === 'function') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (key == '__proto__') {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return object[key];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = safeGet;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to stand-in for `undefined` hash values. */</span><span class="s3">\n</span><span class="s1">var HASH_UNDEFINED = '__lodash_hash_undefined__';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Adds `value` to the array cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name add</span><span class="s3">\n </span><span class="s1">* @memberOf SetCache</span><span class="s3">\n </span><span class="s1">* @alias push</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to cache.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the cache instance.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCacheAdd(value) {</span><span class="s3">\n  </span><span class="s1">this.__data__.set(value, HASH_UNDEFINED);</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setCacheAdd;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is in the array cache.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @name has</span><span class="s3">\n </span><span class="s1">* @memberOf SetCache</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns `true` if `value` is found, else `false`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setCacheHas(value) {</span><span class="s3">\n  </span><span class="s1">return this.__data__.has(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setCacheHas;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Converts `set` to an array of its values.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Object} set The set to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the values.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function setToArray(set) {</span><span class="s3">\n  </span><span class="s1">var index = -1,</span><span class="s3">\n      </span><span class="s1">result = Array(set.size);</span><span class="s3">\n\n  </span><span class="s1">set.forEach(function(value) {</span><span class="s3">\n    </span><span class="s1">result[++index] = value;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = setToArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* A specialized version of `_.indexOf` which performs strict equality</span><span class="s3">\n </span><span class="s1">* comparisons of values, i.e. `===`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to search for.</span><span class="s3">\n </span><span class="s1">* @param {number} fromIndex The index to search from.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the matched value, else `-1`.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function strictIndexOf(array, value, fromIndex) {</span><span class="s3">\n  </span><span class="s1">var index = fromIndex - 1,</span><span class="s3">\n      </span><span class="s1">length = array.length;</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">if (array[index] === value) {</span><span class="s3">\n      </span><span class="s1">return index;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = strictIndexOf;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/** Used to match a single whitespace character. */</span><span class="s3">\n</span><span class="s1">var reWhitespace = /</span><span class="s3">\\</span><span class="s1">s/;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace</span><span class="s3">\n </span><span class="s1">* character of `string`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @private</span><span class="s3">\n </span><span class="s1">* @param {string} string The string to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the index of the last non-whitespace character.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function trimmedEndIndex(string) {</span><span class="s3">\n  </span><span class="s1">var index = string.length;</span><span class="s3">\n\n  </span><span class="s1">while (index-- &amp;&amp; reWhitespace.test(string.charAt(index))) {}</span><span class="s3">\n  </span><span class="s1">return index;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = trimmedEndIndex;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">eq = require('./eq'),</span><span class="s3">\n    </span><span class="s1">isIterateeCall = require('./_isIterateeCall'),</span><span class="s3">\n    </span><span class="s1">keysIn = require('./keysIn');</span><span class="s3">\n\n</span><span class="s1">/** Used for built-in method references. */</span><span class="s3">\n</span><span class="s1">var objectProto = Object.prototype;</span><span class="s3">\n\n</span><span class="s1">/** Used to check objects for own properties. */</span><span class="s3">\n</span><span class="s1">var hasOwnProperty = objectProto.hasOwnProperty;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Assigns own and inherited enumerable string keyed properties of source</span><span class="s3">\n </span><span class="s1">* objects to the destination object for all destination properties that</span><span class="s3">\n </span><span class="s1">* resolve to `undefined`. Source objects are applied from left to right.</span><span class="s3">\n </span><span class="s1">* Once a property is set, additional values of the same property are ignored.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.defaultsDeep</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var defaults = baseRest(function(object, sources) {</span><span class="s3">\n  </span><span class="s1">object = Object(object);</span><span class="s3">\n\n  </span><span class="s1">var index = -1;</span><span class="s3">\n  </span><span class="s1">var length = sources.length;</span><span class="s3">\n  </span><span class="s1">var guard = length &gt; 2 ? sources[2] : undefined;</span><span class="s3">\n\n  </span><span class="s1">if (guard &amp;&amp; isIterateeCall(sources[0], sources[1], guard)) {</span><span class="s3">\n    </span><span class="s1">length = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">while (++index &lt; length) {</span><span class="s3">\n    </span><span class="s1">var source = sources[index];</span><span class="s3">\n    </span><span class="s1">var props = keysIn(source);</span><span class="s3">\n    </span><span class="s1">var propsIndex = -1;</span><span class="s3">\n    </span><span class="s1">var propsLength = props.length;</span><span class="s3">\n\n    </span><span class="s1">while (++propsIndex &lt; propsLength) {</span><span class="s3">\n      </span><span class="s1">var key = props[propsIndex];</span><span class="s3">\n      </span><span class="s1">var value = object[key];</span><span class="s3">\n\n      </span><span class="s1">if (value === undefined ||</span><span class="s3">\n          </span><span class="s1">(eq(value, objectProto[key]) &amp;&amp; !hasOwnProperty.call(object, key))) {</span><span class="s3">\n        </span><span class="s1">object[key] = source[key];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return object;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = defaults;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var apply = require('./_apply'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">customDefaultsMerge = require('./_customDefaultsMerge'),</span><span class="s3">\n    </span><span class="s1">mergeWith = require('./mergeWith');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.defaults` except that it recursively assigns</span><span class="s3">\n </span><span class="s1">* default properties.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.10.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @see _.defaults</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': { 'b': 2, 'c': 3 } }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var defaultsDeep = baseRest(function(args) {</span><span class="s3">\n  </span><span class="s1">args.push(undefined, customDefaultsMerge);</span><span class="s3">\n  </span><span class="s1">return apply(mergeWith, undefined, args);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = defaultsDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseFlatten = require('./_baseFlatten');</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var INFINITY = 1 / 0;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Recursively flattens `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to flatten.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new flattened array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.flattenDeep([1, [2, [3, [4]], 5]]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2, 3, 4, 5]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function flattenDeep(array) {</span><span class="s3">\n  </span><span class="s1">var length = array == null ? 0 : array.length;</span><span class="s3">\n  </span><span class="s1">return length ? baseFlatten(array, INFINITY) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = flattenDeep;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayEach = require('./_arrayEach'),</span><span class="s3">\n    </span><span class="s1">baseEach = require('./_baseEach'),</span><span class="s3">\n    </span><span class="s1">castFunction = require('./_castFunction'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Iterates over elements of `collection` and invokes `iteratee` for each element.</span><span class="s3">\n </span><span class="s1">* The iteratee is invoked with three arguments: (value, index|key, collection).</span><span class="s3">\n </span><span class="s1">* Iteratee functions may exit iteration early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** As with other </span><span class="s3">\&quot;</span><span class="s1">Collections</span><span class="s3">\&quot; </span><span class="s1">methods, objects with a </span><span class="s3">\&quot;</span><span class="s1">length</span><span class="s3">\&quot;\n </span><span class="s1">* property are iterated like arrays. To avoid this behavior use `_.forIn`</span><span class="s3">\n </span><span class="s1">* or `_.forOwn` for object iteration.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @alias each</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array|Object} Returns `collection`.</span><span class="s3">\n </span><span class="s1">* @see _.forEachRight</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.forEach([1, 2], function(value) {</span><span class="s3">\n </span><span class="s1">*   console.log(value);</span><span class="s3">\n </span><span class="s1">* });</span><span class="s3">\n </span><span class="s1">* // =&gt; Logs `1` then `2`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {</span><span class="s3">\n </span><span class="s1">*   console.log(key);</span><span class="s3">\n </span><span class="s1">* });</span><span class="s3">\n </span><span class="s1">* // =&gt; Logs 'a' then 'b' (iteration order is not guaranteed).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function forEach(collection, iteratee) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayEach : baseEach;</span><span class="s3">\n  </span><span class="s1">return func(collection, castFunction(iteratee));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = forEach;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseIntersection = require('./_baseIntersection'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">castArrayLikeObject = require('./_castArrayLikeObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of unique values that are included in all given arrays</span><span class="s3">\n </span><span class="s1">* using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons. The order and references of result values are</span><span class="s3">\n </span><span class="s1">* determined by the first array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {...Array} [arrays] The arrays to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of intersecting values.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.intersection([2, 1], [2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var intersection = baseRest(function(arrays) {</span><span class="s3">\n  </span><span class="s1">var mapped = arrayMap(arrays, castArrayLikeObject);</span><span class="s3">\n  </span><span class="s1">return (mapped.length &amp;&amp; mapped[0] === arrays[0])</span><span class="s3">\n    </span><span class="s1">? baseIntersection(mapped)</span><span class="s3">\n    </span><span class="s1">: [];</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = intersection;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayMap = require('./_arrayMap'),</span><span class="s3">\n    </span><span class="s1">baseIntersection = require('./_baseIntersection'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">castArrayLikeObject = require('./_castArrayLikeObject'),</span><span class="s3">\n    </span><span class="s1">last = require('./last');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.intersection` except that it accepts `comparator`</span><span class="s3">\n </span><span class="s1">* which is invoked to compare elements of `arrays`. The order and references</span><span class="s3">\n </span><span class="s1">* of result values are determined by the first array. The comparator is</span><span class="s3">\n </span><span class="s1">* invoked with two arguments: (arrVal, othVal).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {...Array} [arrays] The arrays to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of intersecting values.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];</span><span class="s3">\n </span><span class="s1">* var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.intersectionWith(objects, others, _.isEqual);</span><span class="s3">\n </span><span class="s1">* // =&gt; [{ 'x': 1, 'y': 2 }]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var intersectionWith = baseRest(function(arrays) {</span><span class="s3">\n  </span><span class="s1">var comparator = last(arrays),</span><span class="s3">\n      </span><span class="s1">mapped = arrayMap(arrays, castArrayLikeObject);</span><span class="s3">\n\n  </span><span class="s1">comparator = typeof comparator == 'function' ? comparator : undefined;</span><span class="s3">\n  </span><span class="s1">if (comparator) {</span><span class="s3">\n    </span><span class="s1">mapped.pop();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return (mapped.length &amp;&amp; mapped[0] === arrays[0])</span><span class="s3">\n    </span><span class="s1">? baseIntersection(mapped, undefined, comparator)</span><span class="s3">\n    </span><span class="s1">: [];</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = intersectionWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var isArrayLike = require('./isArrayLike'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.isArrayLike` except that it also checks if `value`</span><span class="s3">\n </span><span class="s1">* is an object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is an array-like object,</span><span class="s3">\n </span><span class="s1">*  else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject([1, 2, 3]);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject(document.body.children);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isArrayLikeObject(_.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isArrayLikeObject(value) {</span><span class="s3">\n  </span><span class="s1">return isObjectLike(value) &amp;&amp; isArrayLike(value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isArrayLikeObject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseGetTag = require('./_baseGetTag'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var boolTag = '[object Boolean]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a boolean primitive or object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a boolean, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isBoolean(false);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isBoolean(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isBoolean(value) {</span><span class="s3">\n  </span><span class="s1">return value === true || value === false ||</span><span class="s3">\n    </span><span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == boolTag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isBoolean;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqual = require('./_baseIsEqual');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Performs a deep comparison between two values to determine if they are</span><span class="s3">\n </span><span class="s1">* equivalent.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method supports comparing arrays, array buffers, booleans,</span><span class="s3">\n </span><span class="s1">* date objects, error objects, maps, numbers, `Object` objects, regexes,</span><span class="s3">\n </span><span class="s1">* sets, strings, symbols, and typed arrays. `Object` objects are compared</span><span class="s3">\n </span><span class="s1">* by their own, not inherited, enumerable properties. Functions and DOM</span><span class="s3">\n </span><span class="s1">* nodes are compared by strict equality, i.e. `===`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': 1 };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isEqual(object, other);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* object === other;</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isEqual(value, other) {</span><span class="s3">\n  </span><span class="s1">return baseIsEqual(value, other);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isEqual;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseIsEqual = require('./_baseIsEqual');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.isEqual` except that it accepts `customizer` which</span><span class="s3">\n </span><span class="s1">* is invoked to compare values. If `customizer` returns `undefined`, comparisons</span><span class="s3">\n </span><span class="s1">* are handled by the method instead. The `customizer` is invoked with up to</span><span class="s3">\n </span><span class="s1">* six arguments: (objValue, othValue [, index|key, object, other, stack]).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to compare.</span><span class="s3">\n </span><span class="s1">* @param {*} other The other value to compare.</span><span class="s3">\n </span><span class="s1">* @param {Function} [customizer] The function to customize comparisons.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if the values are equivalent, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function isGreeting(value) {</span><span class="s3">\n </span><span class="s1">*   return /^h(?:i|ello)$/.test(value);</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function customizer(objValue, othValue) {</span><span class="s3">\n </span><span class="s1">*   if (isGreeting(objValue) &amp;&amp; isGreeting(othValue)) {</span><span class="s3">\n </span><span class="s1">*     return true;</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var array = ['hello', 'goodbye'];</span><span class="s3">\n </span><span class="s1">* var other = ['hi', 'goodbye'];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isEqualWith(array, other, customizer);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isEqualWith(value, other, customizer) {</span><span class="s3">\n  </span><span class="s1">customizer = typeof customizer == 'function' ? customizer : undefined;</span><span class="s3">\n  </span><span class="s1">var result = customizer ? customizer(value, other) : undefined;</span><span class="s3">\n  </span><span class="s1">return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isEqualWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is `null` or `undefined`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is nullish, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNil(null);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNil(void 0);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNil(NaN);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isNil(value) {</span><span class="s3">\n  </span><span class="s1">return value == null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isNil;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseGetTag = require('./_baseGetTag'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var numberTag = '[object Number]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `Number` primitive or object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are</span><span class="s3">\n </span><span class="s1">* classified as numbers, use the `_.isFinite` method.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a number, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNumber(3);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNumber(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNumber(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isNumber('3');</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isNumber(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'number' ||</span><span class="s3">\n    </span><span class="s1">(isObjectLike(value) &amp;&amp; baseGetTag(value) == numberTag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isNumber;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseGetTag = require('./_baseGetTag'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">isObjectLike = require('./isObjectLike');</span><span class="s3">\n\n</span><span class="s1">/** `Object#toString` result references. */</span><span class="s3">\n</span><span class="s1">var stringTag = '[object String]';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Checks if `value` is classified as a `String` primitive or object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to check.</span><span class="s3">\n </span><span class="s1">* @returns {boolean} Returns `true` if `value` is a string, else `false`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString('abc');</span><span class="s3">\n </span><span class="s1">* // =&gt; true</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.isString(1);</span><span class="s3">\n </span><span class="s1">* // =&gt; false</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isString(value) {</span><span class="s3">\n  </span><span class="s1">return typeof value == 'string' ||</span><span class="s3">\n    </span><span class="s1">(!isArray(value) &amp;&amp; isObjectLike(value) &amp;&amp; baseGetTag(value) == stringTag);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = isString;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseMerge = require('./_baseMerge'),</span><span class="s3">\n    </span><span class="s1">createAssigner = require('./_createAssigner');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.assign` except that it recursively merges own and</span><span class="s3">\n </span><span class="s1">* inherited enumerable string keyed properties of source objects into the</span><span class="s3">\n </span><span class="s1">* destination object. Source properties that resolve to `undefined` are</span><span class="s3">\n </span><span class="s1">* skipped if a destination value exists. Array and plain object properties</span><span class="s3">\n </span><span class="s1">* are merged recursively. Other objects and value types are overridden by</span><span class="s3">\n </span><span class="s1">* assignment. Source objects are applied from left to right. Subsequent</span><span class="s3">\n </span><span class="s1">* sources overwrite property assignments of previous sources.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.5.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} [sources] The source objects.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = {</span><span class="s3">\n </span><span class="s1">*   'a': [{ 'b': 2 }, { 'd': 4 }]</span><span class="s3">\n </span><span class="s1">* };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var other = {</span><span class="s3">\n </span><span class="s1">*   'a': [{ 'c': 3 }, { 'e': 5 }]</span><span class="s3">\n </span><span class="s1">* };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.merge(object, other);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var merge = createAssigner(function(object, source, srcIndex) {</span><span class="s3">\n  </span><span class="s1">baseMerge(object, source, srcIndex);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = merge;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseMerge = require('./_baseMerge'),</span><span class="s3">\n    </span><span class="s1">createAssigner = require('./_createAssigner');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.merge` except that it accepts `customizer` which</span><span class="s3">\n </span><span class="s1">* is invoked to produce the merged values of the destination and source</span><span class="s3">\n </span><span class="s1">* properties. If `customizer` returns `undefined`, merging is handled by the</span><span class="s3">\n </span><span class="s1">* method instead. The `customizer` is invoked with six arguments:</span><span class="s3">\n </span><span class="s1">* (objValue, srcValue, key, object, source, stack).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method mutates `object`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The destination object.</span><span class="s3">\n </span><span class="s1">* @param {...Object} sources The source objects.</span><span class="s3">\n </span><span class="s1">* @param {Function} customizer The function to customize assigned values.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns `object`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function customizer(objValue, srcValue) {</span><span class="s3">\n </span><span class="s1">*   if (_.isArray(objValue)) {</span><span class="s3">\n </span><span class="s1">*     return objValue.concat(srcValue);</span><span class="s3">\n </span><span class="s1">*   }</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var object = { 'a': [1], 'b': [2] };</span><span class="s3">\n </span><span class="s1">* var other = { 'a': [3], 'b': [4] };</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.mergeWith(object, other, customizer);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': [1, 3], 'b': [2, 4] }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {</span><span class="s3">\n  </span><span class="s1">baseMerge(object, source, srcIndex, customizer);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = mergeWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* This method returns `undefined`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 2.3.0</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.times(2, _.noop);</span><span class="s3">\n </span><span class="s1">* // =&gt; [undefined, undefined]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function noop() {</span><span class="s3">\n  </span><span class="s1">// No operation performed.</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = noop;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseProperty = require('./_baseProperty'),</span><span class="s3">\n    </span><span class="s1">basePropertyDeep = require('./_basePropertyDeep'),</span><span class="s3">\n    </span><span class="s1">isKey = require('./_isKey'),</span><span class="s3">\n    </span><span class="s1">toKey = require('./_toKey');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a function that returns the value at `path` of a given object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 2.4.0</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {Array|string} path The path of the property to get.</span><span class="s3">\n </span><span class="s1">* @returns {Function} Returns the new accessor function.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [</span><span class="s3">\n </span><span class="s1">*   { 'a': { 'b': 2 } },</span><span class="s3">\n </span><span class="s1">*   { 'a': { 'b': 1 } }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map(objects, _.property('a.b'));</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 1]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');</span><span class="s3">\n </span><span class="s1">* // =&gt; [1, 2]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function property(path) {</span><span class="s3">\n  </span><span class="s1">return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = property;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var basePullAll = require('./_basePullAll');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.pull` except that it accepts an array of values to remove.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** Unlike `_.difference`, this method mutates `array`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to modify.</span><span class="s3">\n </span><span class="s1">* @param {Array} values The values to remove.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns `array`.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var array = ['a', 'b', 'c', 'a', 'b', 'c'];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.pullAll(array, ['a', 'c']);</span><span class="s3">\n </span><span class="s1">* console.log(array);</span><span class="s3">\n </span><span class="s1">* // =&gt; ['b', 'b']</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function pullAll(array, values) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length &amp;&amp; values &amp;&amp; values.length)</span><span class="s3">\n    </span><span class="s1">? basePullAll(array, values)</span><span class="s3">\n    </span><span class="s1">: array;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = pullAll;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayReduce = require('./_arrayReduce'),</span><span class="s3">\n    </span><span class="s1">baseEach = require('./_baseEach'),</span><span class="s3">\n    </span><span class="s1">baseIteratee = require('./_baseIteratee'),</span><span class="s3">\n    </span><span class="s1">baseReduce = require('./_baseReduce'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Reduces `collection` to a value which is the accumulated result of running</span><span class="s3">\n </span><span class="s1">* each element in `collection` thru `iteratee`, where each successive</span><span class="s3">\n </span><span class="s1">* invocation is supplied the return value of the previous. If `accumulator`</span><span class="s3">\n </span><span class="s1">* is not given, the first element of `collection` is used as the initial</span><span class="s3">\n </span><span class="s1">* value. The iteratee is invoked with four arguments:</span><span class="s3">\n </span><span class="s1">* (accumulator, value, index|key, collection).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Many lodash methods are guarded to work as iteratees for methods like</span><span class="s3">\n </span><span class="s1">* `_.reduce`, `_.reduceRight`, and `_.transform`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* The guarded methods are:</span><span class="s3">\n </span><span class="s1">* `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,</span><span class="s3">\n </span><span class="s1">* and `sortBy`</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {*} [accumulator] The initial value.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the accumulated value.</span><span class="s3">\n </span><span class="s1">* @see _.reduceRight</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.reduce([1, 2], function(sum, n) {</span><span class="s3">\n </span><span class="s1">*   return sum + n;</span><span class="s3">\n </span><span class="s1">* }, 0);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {</span><span class="s3">\n </span><span class="s1">*   (result[value] || (result[value] = [])).push(key);</span><span class="s3">\n </span><span class="s1">*   return result;</span><span class="s3">\n </span><span class="s1">* }, {});</span><span class="s3">\n </span><span class="s1">* // =&gt; { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function reduce(collection, iteratee, accumulator) {</span><span class="s3">\n  </span><span class="s1">var func = isArray(collection) ? arrayReduce : baseReduce,</span><span class="s3">\n      </span><span class="s1">initAccum = arguments.length &lt; 3;</span><span class="s3">\n\n  </span><span class="s1">return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = reduce;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseFlatten = require('./_baseFlatten'),</span><span class="s3">\n    </span><span class="s1">baseOrderBy = require('./_baseOrderBy'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">isIterateeCall = require('./_isIterateeCall');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of elements, sorted in ascending order by the results of</span><span class="s3">\n </span><span class="s1">* running each element in a collection thru each iteratee. This method</span><span class="s3">\n </span><span class="s1">* performs a stable sort, that is, it preserves the original sort order of</span><span class="s3">\n </span><span class="s1">* equal elements. The iteratees are invoked with one argument: (value).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Collection</span><span class="s3">\n </span><span class="s1">* @param {Array|Object} collection The collection to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {...(Function|Function[])} [iteratees=[_.identity]]</span><span class="s3">\n </span><span class="s1">*  The iteratees to sort by.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new sorted array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var users = [</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 48 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 36 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'fred',   'age': 30 },</span><span class="s3">\n </span><span class="s1">*   { 'user': 'barney', 'age': 34 }</span><span class="s3">\n </span><span class="s1">* ];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.sortBy(users, [function(o) { return o.user; }]);</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.sortBy(users, ['user', 'age']);</span><span class="s3">\n </span><span class="s1">* // =&gt; objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var sortBy = baseRest(function(collection, iteratees) {</span><span class="s3">\n  </span><span class="s1">if (collection == null) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var length = iteratees.length;</span><span class="s3">\n  </span><span class="s1">if (length &gt; 1 &amp;&amp; isIterateeCall(collection, iteratees[0], iteratees[1])) {</span><span class="s3">\n    </span><span class="s1">iteratees = [];</span><span class="s3">\n  </span><span class="s1">} else if (length &gt; 2 &amp;&amp; isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {</span><span class="s3">\n    </span><span class="s1">iteratees = [iteratees[0]];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return baseOrderBy(collection, baseFlatten(iteratees, 1), []);</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = sortBy;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseTimes = require('./_baseTimes'),</span><span class="s3">\n    </span><span class="s1">castFunction = require('./_castFunction'),</span><span class="s3">\n    </span><span class="s1">toInteger = require('./toInteger');</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var MAX_SAFE_INTEGER = 9007199254740991;</span><span class="s3">\n\n</span><span class="s1">/** Used as references for the maximum length and index of an array. */</span><span class="s3">\n</span><span class="s1">var MAX_ARRAY_LENGTH = 4294967295;</span><span class="s3">\n\n</span><span class="s1">/* Built-in method references for those with the same name as other `lodash` methods. */</span><span class="s3">\n</span><span class="s1">var nativeMin = Math.min;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Invokes the iteratee `n` times, returning an array of the results of</span><span class="s3">\n </span><span class="s1">* each invocation. The iteratee is invoked with one argument; (index).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @category Util</span><span class="s3">\n </span><span class="s1">* @param {number} n The number of times to invoke `iteratee`.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the array of results.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.times(3, String);</span><span class="s3">\n </span><span class="s1">* // =&gt; ['0', '1', '2']</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*  _.times(4, _.constant(0));</span><span class="s3">\n </span><span class="s1">* // =&gt; [0, 0, 0, 0]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function times(n, iteratee) {</span><span class="s3">\n  </span><span class="s1">n = toInteger(n);</span><span class="s3">\n  </span><span class="s1">if (n &lt; 1 || n &gt; MAX_SAFE_INTEGER) {</span><span class="s3">\n    </span><span class="s1">return [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var index = MAX_ARRAY_LENGTH,</span><span class="s3">\n      </span><span class="s1">length = nativeMin(n, MAX_ARRAY_LENGTH);</span><span class="s3">\n\n  </span><span class="s1">iteratee = castFunction(iteratee);</span><span class="s3">\n  </span><span class="s1">n -= MAX_ARRAY_LENGTH;</span><span class="s3">\n\n  </span><span class="s1">var result = baseTimes(length, iteratee);</span><span class="s3">\n  </span><span class="s1">while (++index &lt; n) {</span><span class="s3">\n    </span><span class="s1">iteratee(index);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = times;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var toNumber = require('./toNumber');</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var INFINITY = 1 / 0,</span><span class="s3">\n    </span><span class="s1">MAX_INTEGER = 1.7976931348623157e+308;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a finite number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.12.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toFinite('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toFinite(value) {</span><span class="s3">\n  </span><span class="s1">if (!value) {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = toNumber(value);</span><span class="s3">\n  </span><span class="s1">if (value === INFINITY || value === -INFINITY) {</span><span class="s3">\n    </span><span class="s1">var sign = (value &lt; 0 ? -1 : 1);</span><span class="s3">\n    </span><span class="s1">return sign * MAX_INTEGER;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return value === value ? value : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = toFinite;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var toFinite = require('./toFinite');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to an integer.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** This method is loosely based on</span><span class="s3">\n </span><span class="s1">* [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the converted integer.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 0</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; 1.7976931348623157e+308</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toInteger('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toInteger(value) {</span><span class="s3">\n  </span><span class="s1">var result = toFinite(value),</span><span class="s3">\n      </span><span class="s1">remainder = result % 1;</span><span class="s3">\n\n  </span><span class="s1">return result === result ? (remainder ? result - remainder : result) : 0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = toInteger;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseTrim = require('./_baseTrim'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject'),</span><span class="s3">\n    </span><span class="s1">isSymbol = require('./isSymbol');</span><span class="s3">\n\n</span><span class="s1">/** Used as references for various `Number` constants. */</span><span class="s3">\n</span><span class="s1">var NAN = 0 / 0;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect bad signed hexadecimal string values. */</span><span class="s3">\n</span><span class="s1">var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect binary string values. */</span><span class="s3">\n</span><span class="s1">var reIsBinary = /^0b[01]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Used to detect octal string values. */</span><span class="s3">\n</span><span class="s1">var reIsOctal = /^0o[0-7]+$/i;</span><span class="s3">\n\n</span><span class="s1">/** Built-in method references without a dependency on `root`. */</span><span class="s3">\n</span><span class="s1">var freeParseInt = parseInt;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a number.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to process.</span><span class="s3">\n </span><span class="s1">* @returns {number} Returns the number.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(3.2);</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Number.MIN_VALUE);</span><span class="s3">\n </span><span class="s1">* // =&gt; 5e-324</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber(Infinity);</span><span class="s3">\n </span><span class="s1">* // =&gt; Infinity</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.toNumber('3.2');</span><span class="s3">\n </span><span class="s1">* // =&gt; 3.2</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toNumber(value) {</span><span class="s3">\n  </span><span class="s1">if (typeof value == 'number') {</span><span class="s3">\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isSymbol(value)) {</span><span class="s3">\n    </span><span class="s1">return NAN;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (isObject(value)) {</span><span class="s3">\n    </span><span class="s1">var other = typeof value.valueOf == 'function' ? value.valueOf() : value;</span><span class="s3">\n    </span><span class="s1">value = isObject(other) ? (other + '') : other;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (typeof value != 'string') {</span><span class="s3">\n    </span><span class="s1">return value === 0 ? value : +value;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">value = baseTrim(value);</span><span class="s3">\n  </span><span class="s1">var isBinary = reIsBinary.test(value);</span><span class="s3">\n  </span><span class="s1">return (isBinary || reIsOctal.test(value))</span><span class="s3">\n    </span><span class="s1">? freeParseInt(value.slice(2), isBinary ? 2 : 8)</span><span class="s3">\n    </span><span class="s1">: (reIsBadHex.test(value) ? NAN : +value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = toNumber;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var copyObject = require('./_copyObject'),</span><span class="s3">\n    </span><span class="s1">keysIn = require('./keysIn');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Converts `value` to a plain object flattening inherited enumerable string</span><span class="s3">\n </span><span class="s1">* keyed properties of `value` to own properties of the plain object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 3.0.0</span><span class="s3">\n </span><span class="s1">* @category Lang</span><span class="s3">\n </span><span class="s1">* @param {*} value The value to convert.</span><span class="s3">\n </span><span class="s1">* @returns {Object} Returns the converted plain object.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* function Foo() {</span><span class="s3">\n </span><span class="s1">*   this.b = 2;</span><span class="s3">\n </span><span class="s1">* }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Foo.prototype.c = 3;</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.assign({ 'a': 1 }, new Foo);</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2 }</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.assign({ 'a': 1 }, _.toPlainObject(new Foo));</span><span class="s3">\n </span><span class="s1">* // =&gt; { 'a': 1, 'b': 2, 'c': 3 }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function toPlainObject(value) {</span><span class="s3">\n  </span><span class="s1">return copyObject(value, keysIn(value));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = toPlainObject;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var arrayEach = require('./_arrayEach'),</span><span class="s3">\n    </span><span class="s1">baseCreate = require('./_baseCreate'),</span><span class="s3">\n    </span><span class="s1">baseForOwn = require('./_baseForOwn'),</span><span class="s3">\n    </span><span class="s1">baseIteratee = require('./_baseIteratee'),</span><span class="s3">\n    </span><span class="s1">getPrototype = require('./_getPrototype'),</span><span class="s3">\n    </span><span class="s1">isArray = require('./isArray'),</span><span class="s3">\n    </span><span class="s1">isBuffer = require('./isBuffer'),</span><span class="s3">\n    </span><span class="s1">isFunction = require('./isFunction'),</span><span class="s3">\n    </span><span class="s1">isObject = require('./isObject'),</span><span class="s3">\n    </span><span class="s1">isTypedArray = require('./isTypedArray');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* An alternative to `_.reduce`; this method transforms `object` to a new</span><span class="s3">\n </span><span class="s1">* `accumulator` object which is the result of running each of its own</span><span class="s3">\n </span><span class="s1">* enumerable string keyed properties thru `iteratee`, with each invocation</span><span class="s3">\n </span><span class="s1">* potentially mutating the `accumulator` object. If `accumulator` is not</span><span class="s3">\n </span><span class="s1">* provided, a new object with the same `[[Prototype]]` will be used. The</span><span class="s3">\n </span><span class="s1">* iteratee is invoked with four arguments: (accumulator, value, key, object).</span><span class="s3">\n </span><span class="s1">* Iteratee functions may exit iteration early by explicitly returning `false`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 1.3.0</span><span class="s3">\n </span><span class="s1">* @category Object</span><span class="s3">\n </span><span class="s1">* @param {Object} object The object to iterate over.</span><span class="s3">\n </span><span class="s1">* @param {Function} [iteratee=_.identity] The function invoked per iteration.</span><span class="s3">\n </span><span class="s1">* @param {*} [accumulator] The custom accumulator value.</span><span class="s3">\n </span><span class="s1">* @returns {*} Returns the accumulated value.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.transform([2, 3, 4], function(result, n) {</span><span class="s3">\n </span><span class="s1">*   result.push(n *= n);</span><span class="s3">\n </span><span class="s1">*   return n % 2 == 0;</span><span class="s3">\n </span><span class="s1">* }, []);</span><span class="s3">\n </span><span class="s1">* // =&gt; [4, 9]</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {</span><span class="s3">\n </span><span class="s1">*   (result[value] || (result[value] = [])).push(key);</span><span class="s3">\n </span><span class="s1">* }, {});</span><span class="s3">\n </span><span class="s1">* // =&gt; { '1': ['a', 'c'], '2': ['b'] }</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function transform(object, iteratee, accumulator) {</span><span class="s3">\n  </span><span class="s1">var isArr = isArray(object),</span><span class="s3">\n      </span><span class="s1">isArrLike = isArr || isBuffer(object) || isTypedArray(object);</span><span class="s3">\n\n  </span><span class="s1">iteratee = baseIteratee(iteratee, 4);</span><span class="s3">\n  </span><span class="s1">if (accumulator == null) {</span><span class="s3">\n    </span><span class="s1">var Ctor = object &amp;&amp; object.constructor;</span><span class="s3">\n    </span><span class="s1">if (isArrLike) {</span><span class="s3">\n      </span><span class="s1">accumulator = isArr ? new Ctor : [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else if (isObject(object)) {</span><span class="s3">\n      </span><span class="s1">accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">accumulator = {};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">(isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {</span><span class="s3">\n    </span><span class="s1">return iteratee(accumulator, value, index, object);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return accumulator;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = transform;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseFlatten = require('./_baseFlatten'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">baseUniq = require('./_baseUniq'),</span><span class="s3">\n    </span><span class="s1">isArrayLikeObject = require('./isArrayLikeObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array of unique values, in order, from all given arrays using</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {...Array} [arrays] The arrays to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of combined values.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.union([2], [1, 2]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 1]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var union = baseRest(function(arrays) {</span><span class="s3">\n  </span><span class="s1">return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = union;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseUniq = require('./_baseUniq');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a duplicate-free version of an array, using</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons, in which only the first occurrence of each element</span><span class="s3">\n </span><span class="s1">* is kept. The order of result values is determined by the order they occur</span><span class="s3">\n </span><span class="s1">* in the array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new duplicate free array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniq([2, 1, 2]);</span><span class="s3">\n </span><span class="s1">* // =&gt; [2, 1]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function uniq(array) {</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length) ? baseUniq(array) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = uniq;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseUniq = require('./_baseUniq');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method is like `_.uniq` except that it accepts `comparator` which</span><span class="s3">\n </span><span class="s1">* is invoked to compare elements of `array`. The order of result values is</span><span class="s3">\n </span><span class="s1">* determined by the order they occur in the array.The comparator is invoked</span><span class="s3">\n </span><span class="s1">* with two arguments: (arrVal, othVal).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 4.0.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {Function} [comparator] The comparator invoked per element.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new duplicate free array.</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.uniqWith(objects, _.isEqual);</span><span class="s3">\n </span><span class="s1">* // =&gt; [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function uniqWith(array, comparator) {</span><span class="s3">\n  </span><span class="s1">comparator = typeof comparator == 'function' ? comparator : undefined;</span><span class="s3">\n  </span><span class="s1">return (array &amp;&amp; array.length) ? baseUniq(array, undefined, comparator) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = uniqWith;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;var baseDifference = require('./_baseDifference'),</span><span class="s3">\n    </span><span class="s1">baseRest = require('./_baseRest'),</span><span class="s3">\n    </span><span class="s1">isArrayLikeObject = require('./isArrayLikeObject');</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an array excluding all given values using</span><span class="s3">\n </span><span class="s1">* [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)</span><span class="s3">\n </span><span class="s1">* for equality comparisons.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* **Note:** Unlike `_.pull`, this method returns a new array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @static</span><span class="s3">\n </span><span class="s1">* @memberOf _</span><span class="s3">\n </span><span class="s1">* @since 0.1.0</span><span class="s3">\n </span><span class="s1">* @category Array</span><span class="s3">\n </span><span class="s1">* @param {Array} array The array to inspect.</span><span class="s3">\n </span><span class="s1">* @param {...*} [values] The values to exclude.</span><span class="s3">\n </span><span class="s1">* @returns {Array} Returns the new array of filtered values.</span><span class="s3">\n </span><span class="s1">* @see _.difference, _.xor</span><span class="s3">\n </span><span class="s1">* @example</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* _.without([2, 1, 2, 3], 1, 2);</span><span class="s3">\n </span><span class="s1">* // =&gt; [3]</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var without = baseRest(function(array, values) {</span><span class="s3">\n  </span><span class="s1">return isArrayLikeObject(array)</span><span class="s3">\n    </span><span class="s1">? baseDifference(array, values)</span><span class="s3">\n    </span><span class="s1">: [];</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">module.exports = without;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @license React</span><span class="s3">\n </span><span class="s1">* react-is.production.min.js</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright (c) Facebook, Inc. and its affiliates.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This source code is licensed under the MIT license found in the</span><span class="s3">\n </span><span class="s1">* LICENSE file in the root directory of this source tree.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">'use strict';var b=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.element</span><span class="s3">\&quot;</span><span class="s1">),c=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.portal</span><span class="s3">\&quot;</span><span class="s1">),d=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.fragment</span><span class="s3">\&quot;</span><span class="s1">),e=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.strict_mode</span><span class="s3">\&quot;</span><span class="s1">),f=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.profiler</span><span class="s3">\&quot;</span><span class="s1">),g=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.provider</span><span class="s3">\&quot;</span><span class="s1">),h=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.context</span><span class="s3">\&quot;</span><span class="s1">),k=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.server_context</span><span class="s3">\&quot;</span><span class="s1">),l=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.forward_ref</span><span class="s3">\&quot;</span><span class="s1">),m=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense</span><span class="s3">\&quot;</span><span class="s1">),n=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.suspense_list</span><span class="s3">\&quot;</span><span class="s1">),p=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.memo</span><span class="s3">\&quot;</span><span class="s1">),q=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.lazy</span><span class="s3">\&quot;</span><span class="s1">),t=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.offscreen</span><span class="s3">\&quot;</span><span class="s1">),u;u=Symbol.for(</span><span class="s3">\&quot;</span><span class="s1">react.module.reference</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function v(a){if(</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">===typeof a&amp;&amp;null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&amp;&amp;a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}exports.ContextConsumer=h;exports.ContextProvider=g;exports.Element=b;exports.ForwardRef=l;exports.Fragment=d;exports.Lazy=q;exports.Memo=p;exports.Portal=c;exports.Profiler=f;exports.StrictMode=e;exports.Suspense=m;</span><span class="s3">\n</span><span class="s1">exports.SuspenseList=n;exports.isAsyncMode=function(){return!1};exports.isConcurrentMode=function(){return!1};exports.isContextConsumer=function(a){return v(a)===h};exports.isContextProvider=function(a){return v(a)===g};exports.isElement=function(a){return</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">===typeof a&amp;&amp;null!==a&amp;&amp;a.$$typeof===b};exports.isForwardRef=function(a){return v(a)===l};exports.isFragment=function(a){return v(a)===d};exports.isLazy=function(a){return v(a)===q};exports.isMemo=function(a){return v(a)===p};</span><span class="s3">\n</span><span class="s1">exports.isPortal=function(a){return v(a)===c};exports.isProfiler=function(a){return v(a)===f};exports.isStrictMode=function(a){return v(a)===e};exports.isSuspense=function(a){return v(a)===m};exports.isSuspenseList=function(a){return v(a)===n};</span><span class="s3">\n</span><span class="s1">exports.isValidElementType=function(a){return</span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">===typeof a||</span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||</span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot;</span><span class="s1">===typeof a&amp;&amp;null!==a&amp;&amp;(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?!0:!1};exports.typeOf=v;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">if (process.env.NODE_ENV === 'production') {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react-is.production.min.js');</span><span class="s3">\n</span><span class="s1">} else {</span><span class="s3">\n  </span><span class="s1">module.exports = require('./cjs/react-is.development.js');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;'use strict';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: isArray( value )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Validates if a value is an array.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {*} value - value to be validated</span><span class="s3">\n</span><span class="s1">* @returns {Boolean} boolean indicating whether value is an array</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isArray( value ) {</span><span class="s3">\n\t</span><span class="s1">return Object.prototype.toString.call( value ) === '[object Array]';</span><span class="s3">\n</span><span class="s1">} // end FUNCTION isArray()</span><span class="s3">\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = Array.isArray || isArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">VALIDATE: function</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">DESCRIPTION:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">- Validates if a value is a function.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">NOTES:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">TODO:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">LICENSE:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">MIT</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Copyright (c) 2014. Athan Reines.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">AUTHOR:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">Athan Reines. kgryte@gmail.com. 2014.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">'use strict';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: isFunction( value )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Validates if a value is a function.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {*} value - value to be validated</span><span class="s3">\n</span><span class="s1">* @returns {Boolean} boolean indicating whether value is a function</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isFunction( value ) {</span><span class="s3">\n\t</span><span class="s1">return ( typeof value === 'function' );</span><span class="s3">\n</span><span class="s1">} // end FUNCTION isFunction()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = isFunction;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">VALIDATE: integer-array</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">DESCRIPTION:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">- Validates if a value is an integer array.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">NOTES:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">TODO:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">LICENSE:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">MIT</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Copyright (c) 2015. Athan Reines.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">AUTHOR:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">Athan Reines. kgryte@gmail.com. 2015.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">'use strict';</span><span class="s3">\n\n</span><span class="s1">// MODULES //</span><span class="s3">\n\n</span><span class="s1">var isArray = require( 'validate.io-array' ),</span><span class="s3">\n\t</span><span class="s1">isInteger = require( 'validate.io-integer' );</span><span class="s3">\n\n\n</span><span class="s1">// IS INTEGER ARRAY //</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: isIntegerArray( value )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Validates if a value is an integer array.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {*} value - value to be validated</span><span class="s3">\n</span><span class="s1">* @returns {Boolean} boolean indicating if a value is an integer array</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isIntegerArray( value ) {</span><span class="s3">\n\t</span><span class="s1">var len;</span><span class="s3">\n\t</span><span class="s1">if ( !isArray( value ) ) {</span><span class="s3">\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">len = value.length;</span><span class="s3">\n\t</span><span class="s1">if ( !len ) {</span><span class="s3">\n\t\t</span><span class="s1">return false;</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">for ( var i = 0; i &lt; len; i++ ) {</span><span class="s3">\n\t\t</span><span class="s1">if ( !isInteger( value[i] ) ) {</span><span class="s3">\n\t\t\t</span><span class="s1">return false;</span><span class="s3">\n\t\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">}</span><span class="s3">\n\t</span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION isIntegerArray()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = isIntegerArray;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">VALIDATE: integer</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">DESCRIPTION:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">- Validates if a value is an integer.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">NOTES:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">TODO:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">LICENSE:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">MIT</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Copyright (c) 2014. Athan Reines.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">AUTHOR:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">Athan Reines. kgryte@gmail.com. 2014.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">'use strict';</span><span class="s3">\n\n</span><span class="s1">// MODULES //</span><span class="s3">\n\n</span><span class="s1">var isNumber = require( 'validate.io-number' );</span><span class="s3">\n\n\n</span><span class="s1">// ISINTEGER //</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: isInteger( value )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Validates if a value is an integer.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {Number} value - value to be validated</span><span class="s3">\n</span><span class="s1">* @returns {Boolean} boolean indicating whether value is an integer</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isInteger( value ) {</span><span class="s3">\n\t</span><span class="s1">return isNumber( value ) &amp;&amp; value%1 === 0;</span><span class="s3">\n</span><span class="s1">} // end FUNCTION isInteger()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = isInteger;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">VALIDATE: number</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">DESCRIPTION:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">- Validates if a value is a number.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">NOTES:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">TODO:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">[1]</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">LICENSE:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">MIT</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Copyright (c) 2014. Athan Reines.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">AUTHOR:</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t\t</span><span class="s1">Athan Reines. kgryte@gmail.com. 2014.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">'use strict';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* FUNCTION: isNumber( value )</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\t</span><span class="s1">Validates if a value is a number.</span><span class="s3">\n</span><span class="s1">*</span><span class="s3">\n</span><span class="s1">* @param {*} value - value to be validated</span><span class="s3">\n</span><span class="s1">* @returns {Boolean} boolean indicating whether value is a number</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function isNumber( value ) {</span><span class="s3">\n\t</span><span class="s1">return ( typeof value === 'number' || Object.prototype.toString.call( value ) === '[object Number]' ) &amp;&amp; value.valueOf() === value.valueOf();</span><span class="s3">\n</span><span class="s1">} // end FUNCTION isNumber()</span><span class="s3">\n\n\n</span><span class="s1">// EXPORTS //</span><span class="s3">\n\n</span><span class="s1">module.exports = isNumber;</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>