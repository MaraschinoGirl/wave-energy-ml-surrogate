<html>
<head>
<title>5828.60c141f7a7cb8d509e84.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
5828.60c141f7a7cb8d509e84.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;5828.60c141f7a7cb8d509e84.js?v=60c141f7a7cb8d509e84&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA8H;AAC3E;AACK;AACa;;AAErE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,wDAAwD;AACxD,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kEAAiB;AAChC;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,8BAA8B,yDAAQ;AACtC;AACA,yFAAyF,IAAI,UAAU,sJAAsJ,IAAI,0DAA0D,wDAAwD,UAAU;AAC7X;AACA;AACA,yEAAyE,MAAM;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gBAAgB;AAC7B;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,IAAI;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gEAAU;AACxB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,MAAM;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ,kFAAkF;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,wCAAwC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,+BAA+B;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2EAAO,mFAAmF,oFAAgB;AACrH;;AAEA;AACA;AACA,qBAAqB,gEAAc;AACnC,oCAAoC,qEAAe;AACnD,SAAS;AACT,qBAAqB,8DAAY;AACjC,qCAAqC,SAAS,iFAAiF;AAC/H,iCAAiC,SAAS;AAC1C,SAAS;AACT,qBAAqB,2DAAS;AAC9B,qBAAqB,kDAAI;AACzB,kBAAkB,kDAAI;AACtB,kCAAkC,kDAAI,UAAU,kDAAI;AACpD,kBAAkB,kDAAI;AACtB,mBAAmB,kDAAI;AACvB,kBAAkB,kDAAI;AACtB,kBAAkB,kDAAI;AACtB,oBAAoB,kDAAI;AACxB,oBAAoB,kDAAI;AACxB,wBAAwB,kDAAI;AAC5B,2CAA2C,kDAAI,SAAS,kDAAI;AAC5D,qCAAqC,kDAAI,SAAS,kDAAI;AACtD,yBAAyB,kDAAI;AAC7B,0BAA0B,kDAAI;AAC9B,sBAAsB,kDAAI;AAC1B,gCAAgC,kDAAI;AACpC,mBAAmB,kDAAI;AACvB,gBAAgB,GAAG,kDAAI;AACvB,mBAAmB,kDAAI;AACvB,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAU;AACjC;AACA;AACA,+BAA+B,gCAAgC;AAC/D,aAAa;AACb;AACA,iCAAiC,qBAAqB,2BAA2B;AACjF,iCAAiC,uBAAuB;AACxD;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,eAAe,iEAAe;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAEsJ&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/lang-sql/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;import { syntaxTree, indentNodeProp, continuedIndent, foldNodeProp, LRLanguage, LanguageSupport } from '@codemirror/language';</span><span class="s3">\n</span><span class="s1">import { styleTags, tags } from '@lezer/highlight';</span><span class="s3">\n</span><span class="s1">import { ExternalTokenizer, LRParser } from '@lezer/lr';</span><span class="s3">\n</span><span class="s1">import { ifNotIn, completeFromList } from '@codemirror/autocomplete';</span><span class="s3">\n\n</span><span class="s1">// This file was generated by lezer-generator. You probably shouldn't edit it.</span><span class="s3">\n</span><span class="s1">const whitespace = 36,</span><span class="s3">\n  </span><span class="s1">LineComment = 1,</span><span class="s3">\n  </span><span class="s1">BlockComment = 2,</span><span class="s3">\n  </span><span class="s1">String$1 = 3,</span><span class="s3">\n  </span><span class="s1">Number = 4,</span><span class="s3">\n  </span><span class="s1">Bool = 5,</span><span class="s3">\n  </span><span class="s1">Null = 6,</span><span class="s3">\n  </span><span class="s1">ParenL = 7,</span><span class="s3">\n  </span><span class="s1">ParenR = 8,</span><span class="s3">\n  </span><span class="s1">BraceL = 9,</span><span class="s3">\n  </span><span class="s1">BraceR = 10,</span><span class="s3">\n  </span><span class="s1">BracketL = 11,</span><span class="s3">\n  </span><span class="s1">BracketR = 12,</span><span class="s3">\n  </span><span class="s1">Semi = 13,</span><span class="s3">\n  </span><span class="s1">Dot = 14,</span><span class="s3">\n  </span><span class="s1">Operator = 15,</span><span class="s3">\n  </span><span class="s1">Punctuation = 16,</span><span class="s3">\n  </span><span class="s1">SpecialVar = 17,</span><span class="s3">\n  </span><span class="s1">Identifier = 18,</span><span class="s3">\n  </span><span class="s1">QuotedIdentifier = 19,</span><span class="s3">\n  </span><span class="s1">Keyword = 20,</span><span class="s3">\n  </span><span class="s1">Type = 21,</span><span class="s3">\n  </span><span class="s1">Bits = 22,</span><span class="s3">\n  </span><span class="s1">Bytes = 23,</span><span class="s3">\n  </span><span class="s1">Builtin = 24;</span><span class="s3">\n\n</span><span class="s1">function isAlpha(ch) {</span><span class="s3">\n    </span><span class="s1">return ch &gt;= 65 /* Ch.A */ &amp;&amp; ch &lt;= 90 /* Ch.Z */ || ch &gt;= 97 /* Ch.a */ &amp;&amp; ch &lt;= 122 /* Ch.z */ || ch &gt;= 48 /* Ch._0 */ &amp;&amp; ch &lt;= 57 /* Ch._9 */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function isHexDigit(ch) {</span><span class="s3">\n    </span><span class="s1">return ch &gt;= 48 /* Ch._0 */ &amp;&amp; ch &lt;= 57 /* Ch._9 */ || ch &gt;= 97 /* Ch.a */ &amp;&amp; ch &lt;= 102 /* Ch.f */ || ch &gt;= 65 /* Ch.A */ &amp;&amp; ch &lt;= 70 /* Ch.F */;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readLiteral(input, endQuote, backslashEscapes) {</span><span class="s3">\n    </span><span class="s1">for (let escaped = false;;) {</span><span class="s3">\n        </span><span class="s1">if (input.next &lt; 0)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (input.next == endQuote &amp;&amp; !escaped) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">escaped = backslashEscapes &amp;&amp; !escaped &amp;&amp; input.next == 92 /* Ch.Backslash */;</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readDoubleDollarLiteral(input, tag) {</span><span class="s3">\n    </span><span class="s1">scan: for (;;) {</span><span class="s3">\n        </span><span class="s1">if (input.next &lt; 0)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (input.next == 36 /* Ch.Dollar */) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; tag.length; i++) {</span><span class="s3">\n                </span><span class="s1">if (input.next != tag.charCodeAt(i))</span><span class="s3">\n                    </span><span class="s1">continue scan;</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (input.next == 36 /* Ch.Dollar */) {</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readPLSQLQuotedLiteral(input, openDelim) {</span><span class="s3">\n    </span><span class="s1">let matchingDelim = </span><span class="s3">\&quot;</span><span class="s1">[{&lt;(</span><span class="s3">\&quot;</span><span class="s1">.indexOf(String.fromCharCode(openDelim));</span><span class="s3">\n    </span><span class="s1">let closeDelim = matchingDelim &lt; 0 ? openDelim : </span><span class="s3">\&quot;</span><span class="s1">]}&gt;)</span><span class="s3">\&quot;</span><span class="s1">.charCodeAt(matchingDelim);</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (input.next &lt; 0)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">if (input.next == closeDelim &amp;&amp; input.peek(1) == 39 /* Ch.SingleQuote */) {</span><span class="s3">\n            </span><span class="s1">input.advance(2);</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readWord(input, result) {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (input.next != 95 /* Ch.Underscore */ &amp;&amp; !isAlpha(input.next))</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if (result != null)</span><span class="s3">\n            </span><span class="s1">result += String.fromCharCode(input.next);</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readWordOrQuoted(input) {</span><span class="s3">\n    </span><span class="s1">if (input.next == 39 /* Ch.SingleQuote */ || input.next == 34 /* Ch.DoubleQuote */ || input.next == 96 /* Ch.Backtick */) {</span><span class="s3">\n        </span><span class="s1">let quote = input.next;</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n        </span><span class="s1">readLiteral(input, quote, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">readWord(input);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readBits(input, endQuote) {</span><span class="s3">\n    </span><span class="s1">while (input.next == 48 /* Ch._0 */ || input.next == 49 /* Ch._1 */)</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">if (endQuote &amp;&amp; input.next == endQuote)</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function readNumber(input, sawDot) {</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">if (input.next == 46 /* Ch.Dot */) {</span><span class="s3">\n            </span><span class="s1">if (sawDot)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">sawDot = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (input.next &lt; 48 /* Ch._0 */ || input.next &gt; 57 /* Ch._9 */) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (input.next == 69 /* Ch.E */ || input.next == 101 /* Ch.e */) {</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n        </span><span class="s1">if (input.next == 43 /* Ch.Plus */ || input.next == 45 /* Ch.Dash */)</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n        </span><span class="s1">while (input.next &gt;= 48 /* Ch._0 */ &amp;&amp; input.next &lt;= 57 /* Ch._9 */)</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function eol(input) {</span><span class="s3">\n    </span><span class="s1">while (!(input.next &lt; 0 || input.next == 10 /* Ch.Newline */))</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function inString(ch, str) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; str.length; i++)</span><span class="s3">\n        </span><span class="s1">if (str.charCodeAt(i) == ch)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Space = </span><span class="s3">\&quot; \\</span><span class="s1">t</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">function keywords(keywords, types, builtin) {</span><span class="s3">\n    </span><span class="s1">let result = Object.create(null);</span><span class="s3">\n    </span><span class="s1">result[</span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">] = result[</span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">] = Bool;</span><span class="s3">\n    </span><span class="s1">result[</span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">] = result[</span><span class="s3">\&quot;</span><span class="s1">unknown</span><span class="s3">\&quot;</span><span class="s1">] = Null;</span><span class="s3">\n    </span><span class="s1">for (let kw of keywords.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">if (kw)</span><span class="s3">\n            </span><span class="s1">result[kw] = Keyword;</span><span class="s3">\n    </span><span class="s1">for (let tp of types.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">if (tp)</span><span class="s3">\n            </span><span class="s1">result[tp] = Type;</span><span class="s3">\n    </span><span class="s1">for (let kw of (builtin || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">))</span><span class="s3">\n        </span><span class="s1">if (kw)</span><span class="s3">\n            </span><span class="s1">result[kw] = Builtin;</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const SQLTypes = </span><span class="s3">\&quot;</span><span class="s1">array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const SQLKeywords = </span><span class="s3">\&quot;</span><span class="s1">absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const defaults = {</span><span class="s3">\n    </span><span class="s1">backslashEscapes: false,</span><span class="s3">\n    </span><span class="s1">hashComments: false,</span><span class="s3">\n    </span><span class="s1">spaceAfterDashes: false,</span><span class="s3">\n    </span><span class="s1">slashComments: false,</span><span class="s3">\n    </span><span class="s1">doubleQuotedStrings: false,</span><span class="s3">\n    </span><span class="s1">doubleDollarQuotedStrings: false,</span><span class="s3">\n    </span><span class="s1">unquotedBitLiterals: false,</span><span class="s3">\n    </span><span class="s1">treatBitsAsBytes: false,</span><span class="s3">\n    </span><span class="s1">charSetCasts: false,</span><span class="s3">\n    </span><span class="s1">plsqlQuotingMechanism: false,</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*+</span><span class="s3">\\</span><span class="s1">-%&lt;&gt;!=&amp;|~^/</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">identifierQuotes: '</span><span class="s3">\&quot;</span><span class="s1">',</span><span class="s3">\n    </span><span class="s1">caseInsensitiveIdentifiers: false,</span><span class="s3">\n    </span><span class="s1">words: /*@__PURE__*/keywords(SQLKeywords, SQLTypes)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function dialect(spec, kws, types, builtin) {</span><span class="s3">\n    </span><span class="s1">let dialect = {};</span><span class="s3">\n    </span><span class="s1">for (let prop in defaults)</span><span class="s3">\n        </span><span class="s1">dialect[prop] = (spec.hasOwnProperty(prop) ? spec : defaults)[prop];</span><span class="s3">\n    </span><span class="s1">if (kws)</span><span class="s3">\n        </span><span class="s1">dialect.words = keywords(kws, types || </span><span class="s3">\&quot;\&quot;</span><span class="s1">, builtin);</span><span class="s3">\n    </span><span class="s1">return dialect;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function tokensFor(d) {</span><span class="s3">\n    </span><span class="s1">return new ExternalTokenizer(input =&gt; {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let { next } = input;</span><span class="s3">\n        </span><span class="s1">input.advance();</span><span class="s3">\n        </span><span class="s1">if (inString(next, Space)) {</span><span class="s3">\n            </span><span class="s1">while (inString(input.next, Space))</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">input.acceptToken(whitespace);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 36 /* Ch.Dollar */ &amp;&amp; d.doubleDollarQuotedStrings) {</span><span class="s3">\n            </span><span class="s1">let tag = readWord(input, </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">if (input.next == 36 /* Ch.Dollar */) {</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n                </span><span class="s1">readDoubleDollarLiteral(input, tag);</span><span class="s3">\n                </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 39 /* Ch.SingleQuote */ || next == 34 /* Ch.DoubleQuote */ &amp;&amp; d.doubleQuotedStrings) {</span><span class="s3">\n            </span><span class="s1">readLiteral(input, next, d.backslashEscapes);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 35 /* Ch.Hash */ &amp;&amp; d.hashComments ||</span><span class="s3">\n            </span><span class="s1">next == 47 /* Ch.Slash */ &amp;&amp; input.next == 47 /* Ch.Slash */ &amp;&amp; d.slashComments) {</span><span class="s3">\n            </span><span class="s1">eol(input);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(LineComment);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 45 /* Ch.Dash */ &amp;&amp; input.next == 45 /* Ch.Dash */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!d.spaceAfterDashes || input.peek(1) == 32 /* Ch.Space */)) {</span><span class="s3">\n            </span><span class="s1">eol(input);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(LineComment);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 47 /* Ch.Slash */ &amp;&amp; input.next == 42 /* Ch.Star */) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">for (let depth = 1;;) {</span><span class="s3">\n                </span><span class="s1">let cur = input.next;</span><span class="s3">\n                </span><span class="s1">if (input.next &lt; 0)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n                </span><span class="s1">if (cur == 42 /* Ch.Star */ &amp;&amp; input.next == 47 /* Ch.Slash */) {</span><span class="s3">\n                    </span><span class="s1">depth--;</span><span class="s3">\n                    </span><span class="s1">input.advance();</span><span class="s3">\n                    </span><span class="s1">if (!depth)</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (cur == 47 /* Ch.Slash */ &amp;&amp; input.next == 42 /* Ch.Star */) {</span><span class="s3">\n                    </span><span class="s1">depth++;</span><span class="s3">\n                    </span><span class="s1">input.advance();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">input.acceptToken(BlockComment);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((next == 101 /* Ch.e */ || next == 69 /* Ch.E */) &amp;&amp; input.next == 39 /* Ch.SingleQuote */) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">readLiteral(input, 39 /* Ch.SingleQuote */, true);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((next == 110 /* Ch.n */ || next == 78 /* Ch.N */) &amp;&amp; input.next == 39 /* Ch.SingleQuote */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">d.charSetCasts) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">readLiteral(input, 39 /* Ch.SingleQuote */, d.backslashEscapes);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 95 /* Ch.Underscore */ &amp;&amp; d.charSetCasts) {</span><span class="s3">\n            </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n                </span><span class="s1">if (input.next == 39 /* Ch.SingleQuote */ &amp;&amp; i &gt; 1) {</span><span class="s3">\n                    </span><span class="s1">input.advance();</span><span class="s3">\n                    </span><span class="s1">readLiteral(input, 39 /* Ch.SingleQuote */, d.backslashEscapes);</span><span class="s3">\n                    </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!isAlpha(input.next))</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (d.plsqlQuotingMechanism &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(next == 113 /* Ch.q */ || next == 81 /* Ch.Q */) &amp;&amp; input.next == 39 /* Ch.SingleQuote */ &amp;&amp;</span><span class="s3">\n            </span><span class="s1">input.peek(1) &gt; 0 &amp;&amp; !inString(input.peek(1), Space)) {</span><span class="s3">\n            </span><span class="s1">let openDelim = input.peek(1);</span><span class="s3">\n            </span><span class="s1">input.advance(2);</span><span class="s3">\n            </span><span class="s1">readPLSQLQuotedLiteral(input, openDelim);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(String$1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 40 /* Ch.ParenL */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(ParenL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 41 /* Ch.ParenR */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(ParenR);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 123 /* Ch.BraceL */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(BraceL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 125 /* Ch.BraceR */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(BraceR);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 91 /* Ch.BracketL */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(BracketL);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 93 /* Ch.BracketR */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(BracketR);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 59 /* Ch.Semi */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Semi);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (d.unquotedBitLiterals &amp;&amp; next == 48 /* Ch._0 */ &amp;&amp; input.next == 98 /* Ch.b */) {</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">readBits(input);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Bits);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if ((next == 98 /* Ch.b */ || next == 66 /* Ch.B */) &amp;&amp; (input.next == 39 /* Ch.SingleQuote */ || input.next == 34 /* Ch.DoubleQuote */)) {</span><span class="s3">\n            </span><span class="s1">const quoteStyle = input.next;</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">if (d.treatBitsAsBytes) {</span><span class="s3">\n                </span><span class="s1">readLiteral(input, quoteStyle, d.backslashEscapes);</span><span class="s3">\n                </span><span class="s1">input.acceptToken(Bytes);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">readBits(input, quoteStyle);</span><span class="s3">\n                </span><span class="s1">input.acceptToken(Bits);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 48 /* Ch._0 */ &amp;&amp; (input.next == 120 /* Ch.x */ || input.next == 88 /* Ch.X */) ||</span><span class="s3">\n            </span><span class="s1">(next == 120 /* Ch.x */ || next == 88 /* Ch.X */) &amp;&amp; input.next == 39 /* Ch.SingleQuote */) {</span><span class="s3">\n            </span><span class="s1">let quoted = input.next == 39 /* Ch.SingleQuote */;</span><span class="s3">\n            </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">while (isHexDigit(input.next))</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">if (quoted &amp;&amp; input.next == 39 /* Ch.SingleQuote */)</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Number);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 46 /* Ch.Dot */ &amp;&amp; input.next &gt;= 48 /* Ch._0 */ &amp;&amp; input.next &lt;= 57 /* Ch._9 */) {</span><span class="s3">\n            </span><span class="s1">readNumber(input, true);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Number);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 46 /* Ch.Dot */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Dot);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next &gt;= 48 /* Ch._0 */ &amp;&amp; next &lt;= 57 /* Ch._9 */) {</span><span class="s3">\n            </span><span class="s1">readNumber(input, false);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Number);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (inString(next, d.operatorChars)) {</span><span class="s3">\n            </span><span class="s1">while (inString(input.next, d.operatorChars))</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Operator);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (inString(next, d.specialVar)) {</span><span class="s3">\n            </span><span class="s1">if (input.next == next)</span><span class="s3">\n                </span><span class="s1">input.advance();</span><span class="s3">\n            </span><span class="s1">readWordOrQuoted(input);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(SpecialVar);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (inString(next, d.identifierQuotes)) {</span><span class="s3">\n            </span><span class="s1">readLiteral(input, next, false);</span><span class="s3">\n            </span><span class="s1">input.acceptToken(QuotedIdentifier);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (next == 58 /* Ch.Colon */ || next == 44 /* Ch.Comma */) {</span><span class="s3">\n            </span><span class="s1">input.acceptToken(Punctuation);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isAlpha(next)) {</span><span class="s3">\n            </span><span class="s1">let word = readWord(input, String.fromCharCode(next));</span><span class="s3">\n            </span><span class="s1">input.acceptToken(input.next == 46 /* Ch.Dot */ || input.peek(-word.length - 1) == 46 /* Ch.Dot */</span><span class="s3">\n                </span><span class="s1">? Identifier : (_a = d.words[word.toLowerCase()]) !== null &amp;&amp; _a !== void 0 ? _a : Identifier);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const tokens = /*@__PURE__*/tokensFor(defaults);</span><span class="s3">\n\n</span><span class="s1">// This file was generated by lezer-generator. You probably shouldn't edit it.</span><span class="s3">\n</span><span class="s1">const parser$1 = /*@__PURE__*/LRParser.deserialize({</span><span class="s3">\n  </span><span class="s1">version: 14,</span><span class="s3">\n  </span><span class="s1">states: </span><span class="s3">\&quot;</span><span class="s1">%vQ]QQOOO#wQRO'#DSO$OQQO'#CwO%eQQO'#CxO%lQQO'#CyO%sQQO'#CzOOQQ'#DS'#DSOOQQ'#C}'#C}O'UQRO'#C{OOQQ'#Cv'#CvOOQQ'#C|'#C|Q]QQOOQOQQOOO'`QQO'#DOO(xQRO,59cO)PQQO,59cO)UQQO'#DSOOQQ,59d,59dO)cQQO,59dOOQQ,59e,59eO)jQQO,59eOOQQ,59f,59fO)qQQO,59fOOQQ-E6{-E6{OOQQ,59b,59bOOQQ-E6z-E6zOOQQ,59j,59jOOQQ-E6|-E6|O+VQRO1G.}O+^QQO,59cOOQQ1G/O1G/OOOQQ1G/P1G/POOQQ1G/Q1G/QP+kQQO'#C}O+rQQO1G.}O)PQQO,59cO,PQQO'#Cw</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">stateData: </span><span class="s3">\&quot;</span><span class="s1">,[~OtOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O^]ORvXSvXTvXUvXVvXXvXZvX]vX_vX`vXavXbvXcvXdvXevXfvXgvXhvX~OsvX~P!jOa_Ob_Oc_O~ORUOSUOTUOUUOVROXSOZTO^tO_UO`UOa`Ob`Oc`OdUOeUOfUOgUOhUO~OWaO~P$ZOYcO~P$ZO[eO~P$ZORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUOgUOhUO~O]hOsoX~P%zOajObjOcjO~O^]ORkaSkaTkaUkaVkaXkaZka]ka_ka`kaakabkackadkaekafkagkahka~Oska~P'kO^]O~OWvXYvX[vX~P!jOWnO~P$ZOYoO~P$ZO[pO~P$ZO^]ORkiSkiTkiUkiVkiXkiZki]ki_ki`kiakibkickidkiekifkigkihki~Oski~P)xOWkaYka[ka~P'kO]hO~P$ZOWkiYki[ki~P)xOasObsOcsO~O</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">goto: </span><span class="s3">\&quot;</span><span class="s1">#hwPPPPPPPPPPPPPPPPPPPPPPPPPPx||||!Y!^!d!xPPP#[TYOZeUORSTWZbdfqT[OZQZORiZSWOZQbRQdSQfTZgWbdfqQ^PWk^lmrQl_Qm`RrseVORSTWZbdfq</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">nodeNames: </span><span class="s3">\&quot;</span><span class="s1">⚠ LineComment BlockComment String Number Bool Null ( ) { } [ ] ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Bits Bytes Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">maxTerm: 38,</span><span class="s3">\n  </span><span class="s1">nodeProps: [</span><span class="s3">\n    </span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">isolate</span><span class="s3">\&quot;</span><span class="s1">, -4,1,2,3,19,</span><span class="s3">\&quot;\&quot;</span><span class="s1">]</span><span class="s3">\n  </span><span class="s1">],</span><span class="s3">\n  </span><span class="s1">skippedNodes: [0,1,2],</span><span class="s3">\n  </span><span class="s1">repeatNodeCount: 3,</span><span class="s3">\n  </span><span class="s1">tokenData: </span><span class="s3">\&quot;</span><span class="s1">RORO</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">tokenizers: [0, tokens],</span><span class="s3">\n  </span><span class="s1">topRules: {</span><span class="s3">\&quot;</span><span class="s1">Script</span><span class="s3">\&quot;</span><span class="s1">:[0,25]},</span><span class="s3">\n  </span><span class="s1">tokenPrec: 0</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">function tokenBefore(tree) {</span><span class="s3">\n    </span><span class="s1">let cursor = tree.cursor().moveTo(tree.from, -1);</span><span class="s3">\n    </span><span class="s1">while (/Comment/.test(cursor.name))</span><span class="s3">\n        </span><span class="s1">cursor.moveTo(cursor.from, -1);</span><span class="s3">\n    </span><span class="s1">return cursor.node;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function idName(doc, node) {</span><span class="s3">\n    </span><span class="s1">let text = doc.sliceString(node.from, node.to);</span><span class="s3">\n    </span><span class="s1">let quoted = /^([`'</span><span class="s3">\&quot;</span><span class="s1">])(.*)</span><span class="s3">\\</span><span class="s1">1$/.exec(text);</span><span class="s3">\n    </span><span class="s1">return quoted ? quoted[2] : text;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function plainID(node) {</span><span class="s3">\n    </span><span class="s1">return node &amp;&amp; (node.name == </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot; </span><span class="s1">|| node.name == </span><span class="s3">\&quot;</span><span class="s1">QuotedIdentifier</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function pathFor(doc, id) {</span><span class="s3">\n    </span><span class="s1">if (id.name == </span><span class="s3">\&quot;</span><span class="s1">CompositeIdentifier</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">let path = [];</span><span class="s3">\n        </span><span class="s1">for (let ch = id.firstChild; ch; ch = ch.nextSibling)</span><span class="s3">\n            </span><span class="s1">if (plainID(ch))</span><span class="s3">\n                </span><span class="s1">path.push(idName(doc, ch));</span><span class="s3">\n        </span><span class="s1">return path;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return [idName(doc, id)];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function parentsFor(doc, node) {</span><span class="s3">\n    </span><span class="s1">for (let path = [];;) {</span><span class="s3">\n        </span><span class="s1">if (!node || node.name != </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">return path;</span><span class="s3">\n        </span><span class="s1">let name = tokenBefore(node);</span><span class="s3">\n        </span><span class="s1">if (!plainID(name))</span><span class="s3">\n            </span><span class="s1">return path;</span><span class="s3">\n        </span><span class="s1">path.unshift(idName(doc, name));</span><span class="s3">\n        </span><span class="s1">node = tokenBefore(name);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sourceContext(state, startPos) {</span><span class="s3">\n    </span><span class="s1">let pos = syntaxTree(state).resolveInner(startPos, -1);</span><span class="s3">\n    </span><span class="s1">let aliases = getAliases(state.doc, pos);</span><span class="s3">\n    </span><span class="s1">if (pos.name == </span><span class="s3">\&quot;</span><span class="s1">Identifier</span><span class="s3">\&quot; </span><span class="s1">|| pos.name == </span><span class="s3">\&quot;</span><span class="s1">QuotedIdentifier</span><span class="s3">\&quot; </span><span class="s1">|| pos.name == </span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { from: pos.from,</span><span class="s3">\n            </span><span class="s1">quoted: pos.name == </span><span class="s3">\&quot;</span><span class="s1">QuotedIdentifier</span><span class="s3">\&quot; </span><span class="s1">? state.doc.sliceString(pos.from, pos.from + 1) : null,</span><span class="s3">\n            </span><span class="s1">parents: parentsFor(state.doc, tokenBefore(pos)),</span><span class="s3">\n            </span><span class="s1">aliases };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (pos.name == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return { from: startPos, quoted: null, parents: parentsFor(state.doc, pos), aliases };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">return { from: startPos, quoted: null, parents: [], empty: true, aliases };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const EndFrom = /*@__PURE__*/new Set(/*@__PURE__*/</span><span class="s3">\&quot;</span><span class="s1">where group having order union intersect except all distinct limit offset fetch for</span><span class="s3">\&quot;</span><span class="s1">.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">function getAliases(doc, at) {</span><span class="s3">\n    </span><span class="s1">let statement;</span><span class="s3">\n    </span><span class="s1">for (let parent = at; !statement; parent = parent.parent) {</span><span class="s3">\n        </span><span class="s1">if (!parent)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">if (parent.name == </span><span class="s3">\&quot;</span><span class="s1">Statement</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">statement = parent;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let aliases = null;</span><span class="s3">\n    </span><span class="s1">for (let scan = statement.firstChild, sawFrom = false, prevID = null; scan; scan = scan.nextSibling) {</span><span class="s3">\n        </span><span class="s1">let kw = scan.name == </span><span class="s3">\&quot;</span><span class="s1">Keyword</span><span class="s3">\&quot; </span><span class="s1">? doc.sliceString(scan.from, scan.to).toLowerCase() : null;</span><span class="s3">\n        </span><span class="s1">let alias = null;</span><span class="s3">\n        </span><span class="s1">if (!sawFrom) {</span><span class="s3">\n            </span><span class="s1">sawFrom = kw == </span><span class="s3">\&quot;</span><span class="s1">from</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (kw == </span><span class="s3">\&quot;</span><span class="s1">as</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; prevID &amp;&amp; plainID(scan.nextSibling)) {</span><span class="s3">\n            </span><span class="s1">alias = idName(doc, scan.nextSibling);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (kw &amp;&amp; EndFrom.has(kw)) {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (prevID &amp;&amp; plainID(scan)) {</span><span class="s3">\n            </span><span class="s1">alias = idName(doc, scan);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (alias) {</span><span class="s3">\n            </span><span class="s1">if (!aliases)</span><span class="s3">\n                </span><span class="s1">aliases = Object.create(null);</span><span class="s3">\n            </span><span class="s1">aliases[alias] = pathFor(doc, prevID);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">prevID = /Identifier$/.test(scan.name) ? scan : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return aliases;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function maybeQuoteCompletions(quote, completions) {</span><span class="s3">\n    </span><span class="s1">if (!quote)</span><span class="s3">\n        </span><span class="s1">return completions;</span><span class="s3">\n    </span><span class="s1">return completions.map(c =&gt; (Object.assign(Object.assign({}, c), { label: c.label[0] == quote ? c.label : quote + c.label + quote, apply: undefined })));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Span = /^</span><span class="s3">\\</span><span class="s1">w*$/, QuotedSpan = /^[`'</span><span class="s3">\&quot;</span><span class="s1">]?</span><span class="s3">\\</span><span class="s1">w*[`'</span><span class="s3">\&quot;</span><span class="s1">]?$/;</span><span class="s3">\n</span><span class="s1">function isSelfTag(namespace) {</span><span class="s3">\n    </span><span class="s1">return namespace.self &amp;&amp; typeof namespace.self.label == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CompletionLevel {</span><span class="s3">\n    </span><span class="s1">constructor(idQuote, idCaseInsensitive) {</span><span class="s3">\n        </span><span class="s1">this.idQuote = idQuote;</span><span class="s3">\n        </span><span class="s1">this.idCaseInsensitive = idCaseInsensitive;</span><span class="s3">\n        </span><span class="s1">this.list = [];</span><span class="s3">\n        </span><span class="s1">this.children = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">child(name) {</span><span class="s3">\n        </span><span class="s1">let children = this.children || (this.children = Object.create(null));</span><span class="s3">\n        </span><span class="s1">let found = children[name];</span><span class="s3">\n        </span><span class="s1">if (found)</span><span class="s3">\n            </span><span class="s1">return found;</span><span class="s3">\n        </span><span class="s1">if (name &amp;&amp; !this.list.some(c =&gt; c.label == name))</span><span class="s3">\n            </span><span class="s1">this.list.push(nameCompletion(name, </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot;</span><span class="s1">, this.idQuote, this.idCaseInsensitive));</span><span class="s3">\n        </span><span class="s1">return (children[name] = new CompletionLevel(this.idQuote, this.idCaseInsensitive));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">maybeChild(name) {</span><span class="s3">\n        </span><span class="s1">return this.children ? this.children[name] : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addCompletion(option) {</span><span class="s3">\n        </span><span class="s1">let found = this.list.findIndex(o =&gt; o.label == option.label);</span><span class="s3">\n        </span><span class="s1">if (found &gt; -1)</span><span class="s3">\n            </span><span class="s1">this.list[found] = option;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.list.push(option);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addCompletions(completions) {</span><span class="s3">\n        </span><span class="s1">for (let option of completions)</span><span class="s3">\n            </span><span class="s1">this.addCompletion(typeof option == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? nameCompletion(option, </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">, this.idQuote, this.idCaseInsensitive) : option);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addNamespace(namespace) {</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(namespace)) {</span><span class="s3">\n            </span><span class="s1">this.addCompletions(namespace);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (isSelfTag(namespace)) {</span><span class="s3">\n            </span><span class="s1">this.addNamespace(namespace.children);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.addNamespaceObject(namespace);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addNamespaceObject(namespace) {</span><span class="s3">\n        </span><span class="s1">for (let name of Object.keys(namespace)) {</span><span class="s3">\n            </span><span class="s1">let children = namespace[name], self = null;</span><span class="s3">\n            </span><span class="s1">let parts = name.replace(/</span><span class="s3">\\\\</span><span class="s1">?</span><span class="s3">\\</span><span class="s1">./g, p =&gt; p == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">: p).split(</span><span class="s3">\&quot;\\</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">let scope = this;</span><span class="s3">\n            </span><span class="s1">if (isSelfTag(children)) {</span><span class="s3">\n                </span><span class="s1">self = children.self;</span><span class="s3">\n                </span><span class="s1">children = children.children;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; parts.length; i++) {</span><span class="s3">\n                </span><span class="s1">if (self &amp;&amp; i == parts.length - 1)</span><span class="s3">\n                    </span><span class="s1">scope.addCompletion(self);</span><span class="s3">\n                </span><span class="s1">scope = scope.child(parts[i].replace(/</span><span class="s3">\\\\\\</span><span class="s1">./g, </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">scope.addNamespace(children);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function nameCompletion(label, type, idQuote, idCaseInsensitive) {</span><span class="s3">\n    </span><span class="s1">if ((new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^[a-z_][a-z_</span><span class="s3">\\\\</span><span class="s1">d]*$</span><span class="s3">\&quot;</span><span class="s1">, idCaseInsensitive ? </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">)).test(label))</span><span class="s3">\n        </span><span class="s1">return { label, type };</span><span class="s3">\n    </span><span class="s1">return { label, type, apply: idQuote + label + idQuote };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Some of this is more gnarly than it has to be because we're also</span><span class="s3">\n</span><span class="s1">// supporting the deprecated, not-so-well-considered style of</span><span class="s3">\n</span><span class="s1">// supplying the schema (dotted property names for schemas, separate</span><span class="s3">\n</span><span class="s1">// `tables` and `schemas` completions).</span><span class="s3">\n</span><span class="s1">function completeFromSchema(schema, tables, schemas, defaultTableName, defaultSchemaName, dialect) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let idQuote = ((_a = dialect === null || dialect === void 0 ? void 0 : dialect.spec.identifierQuotes) === null || _a === void 0 ? void 0 : _a[0]) || '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n    </span><span class="s1">let top = new CompletionLevel(idQuote, !!(dialect === null || dialect === void 0 ? void 0 : dialect.spec.caseInsensitiveIdentifiers));</span><span class="s3">\n    </span><span class="s1">let defaultSchema = defaultSchemaName ? top.child(defaultSchemaName) : null;</span><span class="s3">\n    </span><span class="s1">top.addNamespace(schema);</span><span class="s3">\n    </span><span class="s1">if (tables)</span><span class="s3">\n        </span><span class="s1">(defaultSchema || top).addCompletions(tables);</span><span class="s3">\n    </span><span class="s1">if (schemas)</span><span class="s3">\n        </span><span class="s1">top.addCompletions(schemas);</span><span class="s3">\n    </span><span class="s1">if (defaultSchema)</span><span class="s3">\n        </span><span class="s1">top.addCompletions(defaultSchema.list);</span><span class="s3">\n    </span><span class="s1">if (defaultTableName)</span><span class="s3">\n        </span><span class="s1">top.addCompletions((defaultSchema || top).child(defaultTableName).list);</span><span class="s3">\n    </span><span class="s1">return (context) =&gt; {</span><span class="s3">\n        </span><span class="s1">let { parents, from, quoted, empty, aliases } = sourceContext(context.state, context.pos);</span><span class="s3">\n        </span><span class="s1">if (empty &amp;&amp; !context.explicit)</span><span class="s3">\n            </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">if (aliases &amp;&amp; parents.length == 1)</span><span class="s3">\n            </span><span class="s1">parents = aliases[parents[0]] || parents;</span><span class="s3">\n        </span><span class="s1">let level = top;</span><span class="s3">\n        </span><span class="s1">for (let name of parents) {</span><span class="s3">\n            </span><span class="s1">while (!level.children || !level.children[name]) {</span><span class="s3">\n                </span><span class="s1">if (level == top &amp;&amp; defaultSchema)</span><span class="s3">\n                    </span><span class="s1">level = defaultSchema;</span><span class="s3">\n                </span><span class="s1">else if (level == defaultSchema &amp;&amp; defaultTableName)</span><span class="s3">\n                    </span><span class="s1">level = level.child(defaultTableName);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let next = level.maybeChild(name);</span><span class="s3">\n            </span><span class="s1">if (!next)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">level = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let quoteAfter = quoted &amp;&amp; context.state.sliceDoc(context.pos, context.pos + 1) == quoted;</span><span class="s3">\n        </span><span class="s1">let options = level.list;</span><span class="s3">\n        </span><span class="s1">if (level == top &amp;&amp; aliases)</span><span class="s3">\n            </span><span class="s1">options = options.concat(Object.keys(aliases).map(name =&gt; ({ label: name, type: </span><span class="s3">\&quot;</span><span class="s1">constant</span><span class="s3">\&quot; </span><span class="s1">})));</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">from,</span><span class="s3">\n            </span><span class="s1">to: quoteAfter ? context.pos + 1 : undefined,</span><span class="s3">\n            </span><span class="s1">options: maybeQuoteCompletions(quoted, options),</span><span class="s3">\n            </span><span class="s1">validFor: quoted ? QuotedSpan : Span</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function completionType(tokenType) {</span><span class="s3">\n    </span><span class="s1">return tokenType == Type ? </span><span class="s3">\&quot;</span><span class="s1">type</span><span class="s3">\&quot; </span><span class="s1">: tokenType == Keyword ? </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function completeKeywords(keywords, upperCase, build) {</span><span class="s3">\n    </span><span class="s1">let completions = Object.keys(keywords)</span><span class="s3">\n        </span><span class="s1">.map(keyword =&gt; build(upperCase ? keyword.toUpperCase() : keyword, completionType(keywords[keyword])));</span><span class="s3">\n    </span><span class="s1">return ifNotIn([</span><span class="s3">\&quot;</span><span class="s1">QuotedIdentifier</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">SpecialVar</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">String</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">LineComment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">BlockComment</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">], completeFromList(completions));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let parser = /*@__PURE__*/parser$1.configure({</span><span class="s3">\n    </span><span class="s1">props: [</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/indentNodeProp.add({</span><span class="s3">\n            </span><span class="s1">Statement: /*@__PURE__*/continuedIndent()</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/foldNodeProp.add({</span><span class="s3">\n            </span><span class="s1">Statement(tree, state) { return { from: Math.min(tree.from + 100, state.doc.lineAt(tree.from).to), to: tree.to }; },</span><span class="s3">\n            </span><span class="s1">BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }</span><span class="s3">\n        </span><span class="s1">}),</span><span class="s3">\n        </span><span class="s1">/*@__PURE__*/styleTags({</span><span class="s3">\n            </span><span class="s1">Keyword: tags.keyword,</span><span class="s3">\n            </span><span class="s1">Type: tags.typeName,</span><span class="s3">\n            </span><span class="s1">Builtin: /*@__PURE__*/tags.standard(tags.name),</span><span class="s3">\n            </span><span class="s1">Bits: tags.number,</span><span class="s3">\n            </span><span class="s1">Bytes: tags.string,</span><span class="s3">\n            </span><span class="s1">Bool: tags.bool,</span><span class="s3">\n            </span><span class="s1">Null: tags.null,</span><span class="s3">\n            </span><span class="s1">Number: tags.number,</span><span class="s3">\n            </span><span class="s1">String: tags.string,</span><span class="s3">\n            </span><span class="s1">Identifier: tags.name,</span><span class="s3">\n            </span><span class="s1">QuotedIdentifier: /*@__PURE__*/tags.special(tags.string),</span><span class="s3">\n            </span><span class="s1">SpecialVar: /*@__PURE__*/tags.special(tags.name),</span><span class="s3">\n            </span><span class="s1">LineComment: tags.lineComment,</span><span class="s3">\n            </span><span class="s1">BlockComment: tags.blockComment,</span><span class="s3">\n            </span><span class="s1">Operator: tags.operator,</span><span class="s3">\n            \&quot;</span><span class="s1">Semi Punctuation</span><span class="s3">\&quot;</span><span class="s1">: tags.punctuation,</span><span class="s3">\n            \&quot;</span><span class="s1">( )</span><span class="s3">\&quot;</span><span class="s1">: tags.paren,</span><span class="s3">\n            \&quot;</span><span class="s1">{ }</span><span class="s3">\&quot;</span><span class="s1">: tags.brace,</span><span class="s3">\n            \&quot;</span><span class="s1">[ ]</span><span class="s3">\&quot;</span><span class="s1">: tags.squareBracket</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">]</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Represents an SQL dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SQLDialect {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dialect, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The language for this dialect.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">language, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The spec used to define this dialect.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">spec) {</span><span class="s3">\n        </span><span class="s1">this.dialect = dialect;</span><span class="s3">\n        </span><span class="s1">this.language = language;</span><span class="s3">\n        </span><span class="s1">this.spec = spec;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns the language for this dialect as an extension.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get extension() { return this.language.extension; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a new dialect.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(spec) {</span><span class="s3">\n        </span><span class="s1">let d = dialect(spec, spec.keywords, spec.types, spec.builtin);</span><span class="s3">\n        </span><span class="s1">let language = LRLanguage.define({</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">sql</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">parser: parser.configure({</span><span class="s3">\n                </span><span class="s1">tokenizers: [{ from: tokens, to: tokensFor(d) }]</span><span class="s3">\n            </span><span class="s1">}),</span><span class="s3">\n            </span><span class="s1">languageData: {</span><span class="s3">\n                </span><span class="s1">commentTokens: { line: </span><span class="s3">\&quot;</span><span class="s1">--</span><span class="s3">\&quot;</span><span class="s1">, block: { open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot; </span><span class="s1">} },</span><span class="s3">\n                </span><span class="s1">closeBrackets: { brackets: [</span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">, '</span><span class="s3">\&quot;</span><span class="s1">', </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">] }</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return new SQLDialect(d, language, spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultKeyword(label, type) { return { label, type, boost: -1 }; }</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns a completion source that provides keyword completion for</span><span class="s3">\n</span><span class="s1">the given SQL dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function keywordCompletionSource(dialect, upperCase = false, build) {</span><span class="s3">\n    </span><span class="s1">return completeKeywords(dialect.dialect.words, upperCase, build || defaultKeyword);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns a completion sources that provides schema-based completion</span><span class="s3">\n</span><span class="s1">for the given configuration.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function schemaCompletionSource(config) {</span><span class="s3">\n    </span><span class="s1">return config.schema ? completeFromSchema(config.schema, config.tables, config.schemas, config.defaultTable, config.defaultSchema, config.dialect || StandardSQL)</span><span class="s3">\n        </span><span class="s1">: () =&gt; null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function schemaCompletion(config) {</span><span class="s3">\n    </span><span class="s1">return config.schema ? (config.dialect || StandardSQL).language.data.of({</span><span class="s3">\n        </span><span class="s1">autocomplete: schemaCompletionSource(config)</span><span class="s3">\n    </span><span class="s1">}) : [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">SQL language support for the given SQL dialect, with keyword</span><span class="s3">\n</span><span class="s1">completion, and, if provided, schema-based completion as extra</span><span class="s3">\n</span><span class="s1">extensions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function sql(config = {}) {</span><span class="s3">\n    </span><span class="s1">let lang = config.dialect || StandardSQL;</span><span class="s3">\n    </span><span class="s1">return new LanguageSupport(lang.language, [</span><span class="s3">\n        </span><span class="s1">schemaCompletion(config),</span><span class="s3">\n        </span><span class="s1">lang.language.data.of({</span><span class="s3">\n            </span><span class="s1">autocomplete: keywordCompletionSource(lang, config.upperCaseKeywords, config.keywordCompletion)</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The standard SQL dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const StandardSQL = /*@__PURE__*/SQLDialect.define({});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Dialect for [PostgreSQL](https://www.postgresql.org).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PostgreSQL = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">charSetCasts: true,</span><span class="s3">\n    </span><span class="s1">doubleDollarQuotedStrings: true,</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">+-*/&lt;&gt;=~!@#%^&amp;|`?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">abort abs absent access according ada admin aggregate alias also always analyse analyze array_agg array_max_cardinality asensitive assert assignment asymmetric atomic attach attribute attributes avg backward base64 begin_frame begin_partition bernoulli bit_length blocked bom cache called cardinality catalog_name ceil ceiling chain char_length character_length character_set_catalog character_set_name character_set_schema characteristics characters checkpoint class class_origin cluster coalesce cobol collation_catalog collation_name collation_schema collect column_name columns command_function command_function_code comment comments committed concurrently condition_number configuration conflict connection_name constant constraint_catalog constraint_name constraint_schema contains content control conversion convert copy corr cost covar_pop covar_samp csv cume_dist current_catalog current_row current_schema cursor_name database datalink datatype datetime_interval_code datetime_interval_precision db debug defaults defined definer degree delimiter delimiters dense_rank depends derived detach detail dictionary disable discard dispatch dlnewcopy dlpreviouscopy dlurlcomplete dlurlcompleteonly dlurlcompletewrite dlurlpath dlurlpathonly dlurlpathwrite dlurlscheme dlurlserver dlvalue document dump dynamic_function dynamic_function_code element elsif empty enable encoding encrypted end_frame end_partition endexec enforced enum errcode error event every exclude excluding exclusive exp explain expression extension extract family file filter final first_value flag floor following force foreach fortran forward frame_row freeze fs functions fusion generated granted greatest groups handler header hex hierarchy hint id ignore ilike immediately immutable implementation implicit import include including increment indent index indexes info inherit inherits inline insensitive instance instantiable instead integrity intersection invoker isnull key_member key_type label lag last_value lead leakproof least length library like_regex link listen ln load location lock locked log logged lower mapping matched materialized max max_cardinality maxvalue member merge message message_length message_octet_length message_text min minvalue mod mode more move multiset mumps name namespace nfc nfd nfkc nfkd nil normalize normalized nothing notice notify notnull nowait nth_value ntile nullable nullif nulls number occurrences_regex octet_length octets off offset oids operator options ordering others over overlay overriding owned owner parallel parameter_mode parameter_name parameter_ordinal_position parameter_specific_catalog parameter_specific_name parameter_specific_schema parser partition pascal passing passthrough password percent percent_rank percentile_cont percentile_disc perform period permission pg_context pg_datatype_name pg_exception_context pg_exception_detail pg_exception_hint placing plans pli policy portion position position_regex power precedes preceding prepared print_strict_params procedural procedures program publication query quote raise range rank reassign recheck recovery refresh regr_avgx regr_avgy regr_count regr_intercept regr_r2 regr_slope regr_sxx regr_sxy regr_syy reindex rename repeatable replace replica requiring reset respect restart restore result_oid returned_cardinality returned_length returned_octet_length returned_sqlstate returning reverse routine_catalog routine_name routine_schema routines row_count row_number rowtype rule scale schema_name schemas scope scope_catalog scope_name scope_schema security selective self sensitive sequence sequences serializable server server_name setof share show simple skip slice snapshot source specific_name sqlcode sqlerror sqrt stable stacked standalone statement statistics stddev_pop stddev_samp stdin stdout storage strict strip structure style subclass_origin submultiset subscription substring substring_regex succeeds sum symmetric sysid system system_time table_name tables tablesample tablespace temp template ties token top_level_count transaction_active transactions_committed transactions_rolled_back transform transforms translate translate_regex trigger_catalog trigger_name trigger_schema trim trim_array truncate trusted type types uescape unbounded uncommitted unencrypted unlink unlisten unlogged unnamed untyped upper uri use_column use_variable user_defined_type_catalog user_defined_type_code user_defined_type_name user_defined_type_schema vacuum valid validate validator value_of var_pop var_samp varbinary variable_conflict variadic verbose version versioning views volatile warning whitespace width_bucket window within wrapper xmlagg xmlattributes xmlbinary xmlcast xmlcomment xmlconcat xmldeclaration xmldocument xmlelement xmlexists xmlforest xmliterate xmlnamespaces xmlparse xmlpi xmlquery xmlroot xmlschema xmlserialize xmltable xmltext xmlvalidate yes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types: SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">bigint int8 bigserial serial8 varbit bool box bytea cidr circle precision float8 inet int4 json jsonb line lseg macaddr macaddr8 money numeric pg_lsn point polygon float4 int2 smallserial serial2 serial serial4 text timetz timestamptz tsquery tsvector txid_snapshot uuid xml</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const MySQLKeywords = </span><span class="s3">\&quot;</span><span class="s1">accessible algorithm analyze asensitive authors auto_increment autocommit avg avg_row_length binlog btree cache catalog_name chain change changed checkpoint checksum class_origin client_statistics coalesce code collations columns comment committed completion concurrent consistent contains contributors convert database databases day_hour day_microsecond day_minute day_second delay_key_write delayed delimiter des_key_file dev_pop dev_samp deviance directory disable discard distinctrow div dual dumpfile enable enclosed ends engine engines enum errors escaped even event events every explain extended fast field fields flush force found_rows fulltext grants handler hash high_priority hosts hour_microsecond hour_minute hour_second ignore ignore_server_ids import index index_statistics infile innodb insensitive insert_method install invoker iterate keys kill linear lines list load lock logs low_priority master master_heartbeat_period master_ssl_verify_server_cert masters max max_rows maxvalue message_text middleint migrate min min_rows minute_microsecond minute_second mod mode modify mutex mysql_errno no_write_to_binlog offline offset one online optimize optionally outfile pack_keys parser partition partitions password phase plugin plugins prev processlist profile profiles purge query quick range read_write rebuild recover regexp relaylog remove rename reorganize repair repeatable replace require resume rlike row_format rtree schedule schema_name schemas second_microsecond security sensitive separator serializable server share show slave slow snapshot soname spatial sql_big_result sql_buffer_result sql_cache sql_calc_found_rows sql_no_cache sql_small_result ssl starting starts std stddev stddev_pop stddev_samp storage straight_join subclass_origin sum suspend table_name table_statistics tables tablespace terminated triggers truncate uncommitted uninstall unlock upgrade use use_frm user_resources user_statistics utc_date utc_time utc_timestamp variables views warnings xa xor year_month zerofill</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const MySQLTypes = SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int1 int2 int3 int4 int8 float4 float8 varbinary varcharacter precision datetime unsigned signed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">const MySQLBuiltin = </span><span class="s3">\&quot;</span><span class="s1">charset clear edit ego help nopager notee nowarning pager print prompt quit rehash source status system tee</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">[MySQL](https://dev.mysql.com/) dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MySQL = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*+-%&lt;&gt;!=&amp;|^</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">charSetCasts: true,</span><span class="s3">\n    </span><span class="s1">doubleQuotedStrings: true,</span><span class="s3">\n    </span><span class="s1">unquotedBitLiterals: true,</span><span class="s3">\n    </span><span class="s1">hashComments: true,</span><span class="s3">\n    </span><span class="s1">spaceAfterDashes: true,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;</span><span class="s1">@?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">identifierQuotes: </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">group_concat </span><span class="s3">\&quot; </span><span class="s1">+ MySQLKeywords,</span><span class="s3">\n    </span><span class="s1">types: MySQLTypes,</span><span class="s3">\n    </span><span class="s1">builtin: MySQLBuiltin</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Variant of [`MySQL`](https://codemirror.net/6/docs/ref/#lang-sql.MySQL) for</span><span class="s3">\n</span><span class="s1">[MariaDB](https://mariadb.org/).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MariaSQL = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*+-%&lt;&gt;!=&amp;|^</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">charSetCasts: true,</span><span class="s3">\n    </span><span class="s1">doubleQuotedStrings: true,</span><span class="s3">\n    </span><span class="s1">unquotedBitLiterals: true,</span><span class="s3">\n    </span><span class="s1">hashComments: true,</span><span class="s3">\n    </span><span class="s1">spaceAfterDashes: true,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;</span><span class="s1">@?</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">identifierQuotes: </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">always generated groupby_concat hard persistent shutdown soft virtual </span><span class="s3">\&quot; </span><span class="s1">+ MySQLKeywords,</span><span class="s3">\n    </span><span class="s1">types: MySQLTypes,</span><span class="s3">\n    </span><span class="s1">builtin: MySQLBuiltin</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">SQL dialect for Microsoft [SQL</span><span class="s3">\n</span><span class="s1">Server](https://www.microsoft.com/en-us/sql-server).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const MSSQL = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">trigger proc view index for add constraint key primary foreign collate clustered nonclustered declare exec go if use index holdlock nolock nowait paglock pivot readcommitted readcommittedlock readpast readuncommitted repeatableread rowlock serializable snapshot tablock tablockx unpivot updlock with</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types: SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">bigint smallint smallmoney tinyint money real text nvarchar ntext varbinary image hierarchyid uniqueidentifier sql_variant xml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">builtin: </span><span class="s3">\&quot;</span><span class="s1">binary_checksum checksum connectionproperty context_info current_request_id error_line error_message error_number error_procedure error_severity error_state formatmessage get_filestream_transaction_context getansinull host_id host_name isnull isnumeric min_active_rowversion newid newsequentialid rowcount_big xact_state object_id</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*+-%&lt;&gt;!=^&amp;|/</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">[SQLite](https://sqlite.org/) dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const SQLite = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">abort analyze attach autoincrement conflict database detach exclusive fail glob ignore index indexed instead isnull notnull offset plan pragma query raise regexp reindex rename replace temp vacuum virtual</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types: SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">bool blob long longblob longtext medium mediumblob mediumint mediumtext tinyblob tinyint tinytext text bigint int2 int8 unsigned signed real</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">builtin: </span><span class="s3">\&quot;</span><span class="s1">auth backup bail changes clone databases dbinfo dump echo eqp explain fullschema headers help import imposter indexes iotrace lint load log mode nullvalue once print prompt quit restore save scanstats separator shell show stats system tables testcase timeout timer trace vfsinfo vfslist vfsname width</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*+-%&lt;&gt;!=&amp;|/~</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">identifierQuotes: </span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\\\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">specialVar: </span><span class="s3">\&quot;</span><span class="s1">@:?$</span><span class="s3">\&quot;\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Dialect for [Cassandra](https://cassandra.apache.org/)'s SQL-ish query language.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const Cassandra = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">keywords: </span><span class="s3">\&quot;</span><span class="s1">add all allow alter and any apply as asc authorize batch begin by clustering columnfamily compact consistency count create custom delete desc distinct drop each_quorum exists filtering from grant if in index insert into key keyspace keyspaces level limit local_one local_quorum modify nan norecursive nosuperuser not of on one order password permission permissions primary quorum rename revoke schema select set storage superuser table three to token truncate ttl two type unlogged update use user users using values where with writetime infinity NaN</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types: SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">ascii bigint blob counter frozen inet list map static text timeuuid tuple uuid varint</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">slashComments: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">[PL/SQL](https://en.wikipedia.org/wiki/PL/SQL) dialect.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const PLSQL = /*@__PURE__*/SQLDialect.define({</span><span class="s3">\n    </span><span class="s1">keywords: SQLKeywords + </span><span class="s3">\&quot;</span><span class="s1">abort accept access add all alter and any arraylen as asc assert assign at attributes audit authorization avg base_table begin between binary_integer body by case cast char_base check close cluster clusters colauth column comment commit compress connected constant constraint crash create current currval cursor data_base database dba deallocate debugoff debugon declare default definition delay delete desc digits dispose distinct do drop else elseif elsif enable end entry exception exception_init exchange exclusive exists external fast fetch file for force form from function generic goto grant group having identified if immediate in increment index indexes indicator initial initrans insert interface intersect into is key level library like limited local lock log logging loop master maxextents maxtrans member minextents minus mislabel mode modify multiset new next no noaudit nocompress nologging noparallel not nowait number_base of off offline on online only option or order out package parallel partition pctfree pctincrease pctused pls_integer positive positiven pragma primary prior private privileges procedure public raise range raw rebuild record ref references refresh rename replace resource restrict return returning returns reverse revoke rollback row rowid rowlabel rownum rows run savepoint schema segment select separate set share snapshot some space split sql start statement storage subtype successful synonym tabauth table tables tablespace task terminate then to trigger truncate type union unique unlimited unrecoverable unusable update use using validate value values variable view views when whenever where while with work</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">builtin: </span><span class="s3">\&quot;</span><span class="s1">appinfo arraysize autocommit autoprint autorecovery autotrace blockterminator break btitle cmdsep colsep compatibility compute concat copycommit copytypecheck define echo editfile embedded feedback flagger flush heading headsep instance linesize lno loboffset logsource longchunksize markup native newpage numformat numwidth pagesize pause pno recsep recsepchar repfooter repheader serveroutput shiftinout show showmode spool sqlblanklines sqlcase sqlcode sqlcontinue sqlnumber sqlpluscompatibility sqlprefix sqlprompt sqlterminator suffix tab term termout timing trimout trimspool ttitle underline verify version wrap</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">types: SQLTypes + </span><span class="s3">\&quot;</span><span class="s1">ascii bfile bfilename bigserial bit blob dec long number nvarchar nvarchar2 serial smallint string text uid varchar2 xml</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">operatorChars: </span><span class="s3">\&quot;</span><span class="s1">*/+-%&lt;&gt;!=~</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">doubleQuotedStrings: true,</span><span class="s3">\n    </span><span class="s1">charSetCasts: true,</span><span class="s3">\n    </span><span class="s1">plsqlQuotingMechanism: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">export { Cassandra, MSSQL, MariaSQL, MySQL, PLSQL, PostgreSQL, SQLDialect, SQLite, StandardSQL, keywordCompletionSource, schemaCompletionSource, sql };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>