<html>
<head>
<title>5261.f6140b9abfd135c64487.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
5261.f6140b9abfd135c64487.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;5261.f6140b9abfd135c64487.js?v=f6140b9abfd135c64487&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sBAAsB;AAC/B;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ;AACA,IAAI;AACJ,oBAAoB,kBAAkB;AACtC,IAAI;AACJ;AACA;AACA;;;AC3B6G;AACqG;AAC1L;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8BAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,sBAAsB,gCAAa;AACnC,8BAA8B,gCAAa;AAC3C;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;;AAE5D,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB,KAAG,YAAY,kDAAkD;AACjF,cAAc,KAAG;AACjB;AACA;AACA,uCAAuC;AACvC;AACA,gCAAgC,iCAAiC;AACjE;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK,EAAE,KAAG,8DAA8D,KAAG,aAAa,oCAAoC;AAC5H;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,8BAAe;AACvC;AACA,8CAA8C,oBAAU,kCAAkC,aAAa;AACvG;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA,kCAAkC,0BAAW;AAC7C,iCAAiC,yBAAU;AAC3C,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,mBAAS;AAC3B,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAQ;AACxB;AACA;AACA;AACA,yBAAyB,0BAAW;AACpC,wBAAwB,SAAS;AACjC,gBAAgB,sBAAQ;AACxB;AACA;AACA;AACA;AACA;AACA,iCAAiC,oBAAU;AAC3C;AACA;AACA,qBAAqB;AACrB;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,oBAAK;AAC1C;AACA,eAAe,gCAAa;AAC5B;AACA;AACA;AACA,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAU,QAAQ,4BAA4B;AAC7E,mCAAmC,oBAAU,QAAQ,mDAAmD;AACxG;AACA;AACA,kEAAkE,2BAAY;AAC9E,wEAAwE,2BAAY;AACpF;AACA;AACA;AACA,oDAAoD,2BAAY;AAChE,gDAAgD,2BAAY;AAC5D;AACA,sCAAsC,oBAAU;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA,mBAAmB,oBAAU;AAC7B;AACA;AACA;AACA,uBAAuB,oBAAU;AACjC;AACA;AACA,uBAAuB,oBAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,oBAAU;AACjC;AACA,8DAA8D;AAC9D;AACA;AACA;AACA,2BAA2B,oBAAU;AACrC;AACA;AACA;AACA;AACA,2BAA2B,oBAAU;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAU;AACzC;AACA;AACA;AACA,eAAe,oBAAU;AACzB;AACA,CAAC;AACD;AACA,CAAC;AACD,kCAAkC,oBAAU;AAC5C,4BAA4B,8BAA8B;AAC1D,4CAA4C;AAC5C,CAAC;AACD;AACA,sBAAsB,iBAAiB;AACvC,UAAU,YAAY;AACtB,iBAAiB,8BAAe,kEAAkE,8BAAe;AACjH;AACA;AACA,4BAA4B,mBAAmB;AAC/C;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iBAAiB;AACjD,UAAU,SAAS;AACnB;AACA,4BAA4B,iBAAiB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,8BAAe;AAC3D,iBAAiB,oBAAU;AAC3B,KAAK;AACL;AACA;;AAEA,uCAAuC,oBAAK;AAC5C;AACA,eAAe,gCAAa;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAU;AAC9C,SAAS;AACT;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAAW,UAAU,YAAY;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2BAAY;AAC3E,0DAA0D,2BAAY;AACtE,yDAAyD,2BAAY;AACrE,6DAA6D,2BAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,qBAAqB,mCAAgB;AACrC;AACA;AACA,4BAA4B,mCAAgB;AAC5C;AACA;AACA;AACA,8DAA8D,2BAAY;AAC1E,gEAAgE,2BAAY;AAC5E,mFAAmF,2BAAY;AAC/F,uFAAuF,2BAAY;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,0BAAW;AAC/C,iCAAiC,0BAAW;AAC5C,iCAAiC,yBAAU;AAC3C;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kBAAkB,mBAAS;AAC3B,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAU,QAAQ,yBAAyB,oCAAoC,oBAAU,QAAQ,iDAAiD;AACjL,uCAAuC,oBAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B;AACA,mBAAmB,oBAAU;AAC7B,cAAc,OAAO;AACrB,0BAA0B,8BAAe;AACzC,wEAAwE,OAAO;AAC/E,kBAAkB,WAAW;AAC7B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,OAAO;AAC5D,UAAU,KAAK;AACf;AACA;AACA;AACA,oBAAoB,8BAAe;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,yDAAyD,OAAO;AAChE,UAAU,QAAQ,UAAU,OAAO;AACnC;AACA;AACA;AACA,oBAAoB,8BAAe;AACnC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,0DAA0D,OAAO;AACjE;AACA;AACA;AACA;AACA,mBAAmB,8BAAe,wBAAwB,8BAAe;AACzE;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA,kCAAkC,iBAAiB;AACnD;AACA;AACA;AACA,UAAU,WAAW;AACrB;AACA,0EAA0E,iBAAiB;AAC3F;AACA;AACA;AACA;AACA,oBAAoB,8BAAe;AACnC;AACA;AACA,mBAAmB,8BAAe;AAClC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D,UAAU,QAAQ,UAAU,WAAW;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mDAAmD;AAC1E;AACA,qBAAqB,oBAAU;AAC/B;AACA;AACA;AACA,oBAAoB,8BAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA,cAAc,WAAW;AACzB,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,iBAAiB,oBAAU;AAC3B;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,gBAAgB,sBAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA,wFAAwF,0BAAW;AACnG,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,sBAAQ;AACxB;AACA;AACA,oBAAoB,gCAAgC;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAkE;AACxE,MAAM,mGAAmG;AACzG,MAAM,sGAAsG;AAC5G,MAAM,oEAAoE;AAC1E,MAAM,iDAAiD;AACvD,MAAM,iCAAiC;AACvC,MAAM,+DAA+D;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,KAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,4BAA4B,KAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,KAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uBAAuB,KAAG;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,yBAAyB,KAAG;AAC5B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,mBAAmB,KAAG,aAAa,mDAAmD;AACtF;AACA,mBAAmB,KAAG,UAAU,uDAAuD;AACvF;AACA;AACA;AACA;AACA,YAAY,KAAG;AACf,YAAY,KAAG;AACf,YAAY,KAAG;AACf;AACA,gBAAgB,KAAG;AACnB;AACA;AACA;AACA;AACA,YAAY,KAAG;AACf;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA,YAAY,8BAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB;AACA,gCAAgC;AAChC;AACA,uBAAuB;AACvB,+BAA+B,UAAU;AACzC;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,kCAAkC;AACxE;AACA;AACA;AACA;AACA;AACA,WAAW,oBAAU,gBAAgB,mCAAmC,IAAI,MAAM,EAAE,8BAA8B,EAAE,YAAY;AAChI;AACA,+BAA+B,oBAAU;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL,gCAAgC,8BAA8B;AAC9D,+BAA+B,8BAA8B;AAC7D,yCAAyC,8BAA8B;AACvE,wCAAwC;AACxC,CAAC;AACD;AACA;AACA,iBAAiB,mBAAI;AACrB;AACA;;AAEgT&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/crelt/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/search/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;export default function crelt() {</span><span class="s3">\n  </span><span class="s1">var elt = arguments[0]</span><span class="s3">\n  </span><span class="s1">if (typeof elt == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) elt = document.createElement(elt)</span><span class="s3">\n  </span><span class="s1">var i = 1, next = arguments[1]</span><span class="s3">\n  </span><span class="s1">if (next &amp;&amp; typeof next == </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; next.nodeType == null &amp;&amp; !Array.isArray(next)) {</span><span class="s3">\n    </span><span class="s1">for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {</span><span class="s3">\n      </span><span class="s1">var value = next[name]</span><span class="s3">\n      </span><span class="s1">if (typeof value == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) elt.setAttribute(name, value)</span><span class="s3">\n      </span><span class="s1">else if (value != null) elt[name] = value</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">i++</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (; i &lt; arguments.length; i++) add(elt, arguments[i])</span><span class="s3">\n  </span><span class="s1">return elt</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function add(elt, child) {</span><span class="s3">\n  </span><span class="s1">if (typeof child == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">elt.appendChild(document.createTextNode(child))</span><span class="s3">\n  </span><span class="s1">} else if (child == null) {</span><span class="s3">\n  </span><span class="s1">} else if (child.nodeType != null) {</span><span class="s3">\n    </span><span class="s1">elt.appendChild(child)</span><span class="s3">\n  </span><span class="s1">} else if (Array.isArray(child)) {</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; child.length; i++) add(elt, child[i])</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Unsupported child node: </span><span class="s3">\&quot; </span><span class="s1">+ child)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';</span><span class="s3">\n</span><span class="s1">import { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';</span><span class="s3">\n</span><span class="s1">import elt from 'crelt';</span><span class="s3">\n\n</span><span class="s1">const basicNormalize = typeof String.prototype.normalize == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;\n    </span><span class="s1">? x =&gt; x.normalize(</span><span class="s3">\&quot;</span><span class="s1">NFKD</span><span class="s3">\&quot;</span><span class="s1">) : x =&gt; x;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A search cursor provides an iterator over text matches in a</span><span class="s3">\n</span><span class="s1">document.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SearchCursor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a text cursor. The query is the search string, `from` to</span><span class="s3">\n    </span><span class="s1">`to` provides the region to search.</span><span class="s3">\n    \n    </span><span class="s1">When `normalize` is given, it will be called, on both the query</span><span class="s3">\n    </span><span class="s1">string and the content it is matched against, before comparing.</span><span class="s3">\n    </span><span class="s1">You can, for example, create a case-insensitive search by</span><span class="s3">\n    </span><span class="s1">passing `s =&gt; s.toLowerCase()`.</span><span class="s3">\n    \n    </span><span class="s1">Text is always normalized with</span><span class="s3">\n    </span><span class="s1">[`.normalize(</span><span class="s3">\&quot;</span><span class="s1">NFKD</span><span class="s3">\&quot;</span><span class="s1">)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)</span><span class="s3">\n    </span><span class="s1">(when supported).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(text, query, from = 0, to = text.length, normalize, test) {</span><span class="s3">\n        </span><span class="s1">this.test = test;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">The current match (only holds a meaningful value after</span><span class="s3">\n        </span><span class="s1">[`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when</span><span class="s3">\n        </span><span class="s1">`done` is false).</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.value = { from: 0, to: 0 };</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">Whether the end of the iterated region has been reached.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">this.matches = [];</span><span class="s3">\n        </span><span class="s1">this.buffer = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.bufferPos = 0;</span><span class="s3">\n        </span><span class="s1">this.iter = text.iterRange(from, to);</span><span class="s3">\n        </span><span class="s1">this.bufferStart = from;</span><span class="s3">\n        </span><span class="s1">this.normalize = normalize ? x =&gt; normalize(basicNormalize(x)) : basicNormalize;</span><span class="s3">\n        </span><span class="s1">this.query = this.normalize(query);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">peek() {</span><span class="s3">\n        </span><span class="s1">if (this.bufferPos == this.buffer.length) {</span><span class="s3">\n            </span><span class="s1">this.bufferStart += this.buffer.length;</span><span class="s3">\n            </span><span class="s1">this.iter.next();</span><span class="s3">\n            </span><span class="s1">if (this.iter.done)</span><span class="s3">\n                </span><span class="s1">return -1;</span><span class="s3">\n            </span><span class="s1">this.bufferPos = 0;</span><span class="s3">\n            </span><span class="s1">this.buffer = this.iter.value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return codePointAt(this.buffer, this.bufferPos);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Look for the next match. Updates the iterator's</span><span class="s3">\n    </span><span class="s1">[`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and</span><span class="s3">\n    </span><span class="s1">[`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called</span><span class="s3">\n    </span><span class="s1">at least once before using the cursor.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">while (this.matches.length)</span><span class="s3">\n            </span><span class="s1">this.matches.pop();</span><span class="s3">\n        </span><span class="s1">return this.nextOverlapping();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The `next` method will ignore matches that partially overlap a</span><span class="s3">\n    </span><span class="s1">previous match. This method behaves like `next`, but includes</span><span class="s3">\n    </span><span class="s1">such matches.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">nextOverlapping() {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let next = this.peek();</span><span class="s3">\n            </span><span class="s1">if (next &lt; 0) {</span><span class="s3">\n                </span><span class="s1">this.done = true;</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;</span><span class="s3">\n            </span><span class="s1">this.bufferPos += codePointSize(next);</span><span class="s3">\n            </span><span class="s1">let norm = this.normalize(str);</span><span class="s3">\n            </span><span class="s1">if (norm.length)</span><span class="s3">\n                </span><span class="s1">for (let i = 0, pos = start;; i++) {</span><span class="s3">\n                    </span><span class="s1">let code = norm.charCodeAt(i);</span><span class="s3">\n                    </span><span class="s1">let match = this.match(code, pos, this.bufferPos + this.bufferStart);</span><span class="s3">\n                    </span><span class="s1">if (i == norm.length - 1) {</span><span class="s3">\n                        </span><span class="s1">if (match) {</span><span class="s3">\n                            </span><span class="s1">this.value = match;</span><span class="s3">\n                            </span><span class="s1">return this;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (pos == start &amp;&amp; i &lt; str.length &amp;&amp; str.charCodeAt(i) == code)</span><span class="s3">\n                        </span><span class="s1">pos++;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">match(code, pos, end) {</span><span class="s3">\n        </span><span class="s1">let match = null;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.matches.length; i += 2) {</span><span class="s3">\n            </span><span class="s1">let index = this.matches[i], keep = false;</span><span class="s3">\n            </span><span class="s1">if (this.query.charCodeAt(index) == code) {</span><span class="s3">\n                </span><span class="s1">if (index == this.query.length - 1) {</span><span class="s3">\n                    </span><span class="s1">match = { from: this.matches[i + 1], to: end };</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this.matches[i]++;</span><span class="s3">\n                    </span><span class="s1">keep = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!keep) {</span><span class="s3">\n                </span><span class="s1">this.matches.splice(i, 2);</span><span class="s3">\n                </span><span class="s1">i -= 2;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.query.charCodeAt(0) == code) {</span><span class="s3">\n            </span><span class="s1">if (this.query.length == 1)</span><span class="s3">\n                </span><span class="s1">match = { from: pos, to: end };</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">this.matches.push(1, pos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (match &amp;&amp; this.test &amp;&amp; !this.test(match.from, match.to, this.buffer, this.bufferStart))</span><span class="s3">\n            </span><span class="s1">match = null;</span><span class="s3">\n        </span><span class="s1">return match;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">if (typeof Symbol != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">SearchCursor.prototype[Symbol.iterator] = function () { return this; };</span><span class="s3">\n\n</span><span class="s1">const empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(</span><span class="s3">\&quot;\&quot;</span><span class="s1">) };</span><span class="s3">\n</span><span class="s1">const baseFlags = </span><span class="s3">\&quot;</span><span class="s1">gm</span><span class="s3">\&quot; </span><span class="s1">+ (/x/.unicode == null ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)</span><span class="s3">\n</span><span class="s1">but searches for a regular expression pattern instead of a plain</span><span class="s3">\n</span><span class="s1">string.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RegExpCursor {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a cursor that will search the given range in the given</span><span class="s3">\n    </span><span class="s1">document. `query` should be the raw pattern (as you'd pass it to</span><span class="s3">\n    </span><span class="s1">`new RegExp`).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(text, query, options, from = 0, to = text.length) {</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.curLine = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">Set to `true` when the cursor has reached the end of the search</span><span class="s3">\n        </span><span class="s1">range.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">Will contain an object with the extent of the match and the</span><span class="s3">\n        </span><span class="s1">match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)</span><span class="s3">\n        </span><span class="s1">sucessfully finds a match.</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.value = empty;</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\\\</span><span class="s1">[sWDnr]|</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r|</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">^/.test(query))</span><span class="s3">\n            </span><span class="s1">return new MultilineRegExpCursor(text, query, options, from, to);</span><span class="s3">\n        </span><span class="s1">this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">this.test = options === null || options === void 0 ? void 0 : options.test;</span><span class="s3">\n        </span><span class="s1">this.iter = text.iter();</span><span class="s3">\n        </span><span class="s1">let startLine = text.lineAt(from);</span><span class="s3">\n        </span><span class="s1">this.curLineStart = startLine.from;</span><span class="s3">\n        </span><span class="s1">this.matchPos = toCharEnd(text, from);</span><span class="s3">\n        </span><span class="s1">this.getLine(this.curLineStart);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getLine(skip) {</span><span class="s3">\n        </span><span class="s1">this.iter.next(skip);</span><span class="s3">\n        </span><span class="s1">if (this.iter.lineBreak) {</span><span class="s3">\n            </span><span class="s1">this.curLine = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.curLine = this.iter.value;</span><span class="s3">\n            </span><span class="s1">if (this.curLineStart + this.curLine.length &gt; this.to)</span><span class="s3">\n                </span><span class="s1">this.curLine = this.curLine.slice(0, this.to - this.curLineStart);</span><span class="s3">\n            </span><span class="s1">this.iter.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextLine() {</span><span class="s3">\n        </span><span class="s1">this.curLineStart = this.curLineStart + this.curLine.length + 1;</span><span class="s3">\n        </span><span class="s1">if (this.curLineStart &gt; this.to)</span><span class="s3">\n            </span><span class="s1">this.curLine = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">this.getLine(0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Move to the next match, if there is one.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">for (let off = this.matchPos - this.curLineStart;;) {</span><span class="s3">\n            </span><span class="s1">this.re.lastIndex = off;</span><span class="s3">\n            </span><span class="s1">let match = this.matchPos &lt;= this.to &amp;&amp; this.re.exec(this.curLine);</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n                </span><span class="s1">let from = this.curLineStart + match.index, to = from + match[0].length;</span><span class="s3">\n                </span><span class="s1">this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));</span><span class="s3">\n                </span><span class="s1">if (from == this.curLineStart + this.curLine.length)</span><span class="s3">\n                    </span><span class="s1">this.nextLine();</span><span class="s3">\n                </span><span class="s1">if ((from &lt; to || from &gt; this.value.to) &amp;&amp; (!this.test || this.test(from, to, match))) {</span><span class="s3">\n                    </span><span class="s1">this.value = { from, to, match };</span><span class="s3">\n                    </span><span class="s1">return this;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">off = this.matchPos - this.curLineStart;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.curLineStart + this.curLine.length &lt; this.to) {</span><span class="s3">\n                </span><span class="s1">this.nextLine();</span><span class="s3">\n                </span><span class="s1">off = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.done = true;</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const flattened = /*@__PURE__*/new WeakMap();</span><span class="s3">\n</span><span class="s1">// Reusable (partially) flattened document strings</span><span class="s3">\n</span><span class="s1">class FlattenedDoc {</span><span class="s3">\n    </span><span class="s1">constructor(from, text) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get to() { return this.from + this.text.length; }</span><span class="s3">\n    </span><span class="s1">static get(doc, from, to) {</span><span class="s3">\n        </span><span class="s1">let cached = flattened.get(doc);</span><span class="s3">\n        </span><span class="s1">if (!cached || cached.from &gt;= to || cached.to &lt;= from) {</span><span class="s3">\n            </span><span class="s1">let flat = new FlattenedDoc(from, doc.sliceString(from, to));</span><span class="s3">\n            </span><span class="s1">flattened.set(doc, flat);</span><span class="s3">\n            </span><span class="s1">return flat;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cached.from == from &amp;&amp; cached.to == to)</span><span class="s3">\n            </span><span class="s1">return cached;</span><span class="s3">\n        </span><span class="s1">let { text, from: cachedFrom } = cached;</span><span class="s3">\n        </span><span class="s1">if (cachedFrom &gt; from) {</span><span class="s3">\n            </span><span class="s1">text = doc.sliceString(from, cachedFrom) + text;</span><span class="s3">\n            </span><span class="s1">cachedFrom = from;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cached.to &lt; to)</span><span class="s3">\n            </span><span class="s1">text += doc.sliceString(cached.to, to);</span><span class="s3">\n        </span><span class="s1">flattened.set(doc, new FlattenedDoc(cachedFrom, text));</span><span class="s3">\n        </span><span class="s1">return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class MultilineRegExpCursor {</span><span class="s3">\n    </span><span class="s1">constructor(text, query, options, from, to) {</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">this.value = empty;</span><span class="s3">\n        </span><span class="s1">this.matchPos = toCharEnd(text, from);</span><span class="s3">\n        </span><span class="s1">this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? </span><span class="s3">\&quot;</span><span class="s1">i</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">this.test = options === null || options === void 0 ? void 0 : options.test;</span><span class="s3">\n        </span><span class="s1">this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">chunkEnd(pos) {</span><span class="s3">\n        </span><span class="s1">return pos &gt;= this.to ? this.to : this.text.lineAt(pos).to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let off = this.re.lastIndex = this.matchPos - this.flat.from;</span><span class="s3">\n            </span><span class="s1">let match = this.re.exec(this.flat.text);</span><span class="s3">\n            </span><span class="s1">// Skip empty matches directly after the last match</span><span class="s3">\n            </span><span class="s1">if (match &amp;&amp; !match[0] &amp;&amp; match.index == off) {</span><span class="s3">\n                </span><span class="s1">this.re.lastIndex = off + 1;</span><span class="s3">\n                </span><span class="s1">match = this.re.exec(this.flat.text);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (match) {</span><span class="s3">\n                </span><span class="s1">let from = this.flat.from + match.index, to = from + match[0].length;</span><span class="s3">\n                </span><span class="s1">// If a match goes almost to the end of a noncomplete chunk, try</span><span class="s3">\n                </span><span class="s1">// again, since it'll likely be able to match more</span><span class="s3">\n                </span><span class="s1">if ((this.flat.to &gt;= this.to || match.index + match[0].length &lt;= this.flat.text.length - 10) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(!this.test || this.test(from, to, match))) {</span><span class="s3">\n                    </span><span class="s1">this.value = { from, to, match };</span><span class="s3">\n                    </span><span class="s1">this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));</span><span class="s3">\n                    </span><span class="s1">return this;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.flat.to == this.to) {</span><span class="s3">\n                </span><span class="s1">this.done = true;</span><span class="s3">\n                </span><span class="s1">return this;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Grow the flattened doc</span><span class="s3">\n            </span><span class="s1">this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">if (typeof Symbol != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =</span><span class="s3">\n        </span><span class="s1">function () { return this; };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function validRegExp(source) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">new RegExp(source, baseFlags);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch (_a) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function toCharEnd(text, pos) {</span><span class="s3">\n    </span><span class="s1">if (pos &gt;= text.length)</span><span class="s3">\n        </span><span class="s1">return pos;</span><span class="s3">\n    </span><span class="s1">let line = text.lineAt(pos), next;</span><span class="s3">\n    </span><span class="s1">while (pos &lt; line.to &amp;&amp; (next = line.text.charCodeAt(pos - line.from)) &gt;= 0xDC00 &amp;&amp; next &lt; 0xE000)</span><span class="s3">\n        </span><span class="s1">pos++;</span><span class="s3">\n    </span><span class="s1">return pos;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function createLineDialog(view) {</span><span class="s3">\n    </span><span class="s1">let line = String(view.state.doc.lineAt(view.state.selection.main.head).number);</span><span class="s3">\n    </span><span class="s1">let input = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, { class: </span><span class="s3">\&quot;</span><span class="s1">cm-textfield</span><span class="s3">\&quot;</span><span class="s1">, name: </span><span class="s3">\&quot;</span><span class="s1">line</span><span class="s3">\&quot;</span><span class="s1">, value: line });</span><span class="s3">\n    </span><span class="s1">let dom = elt(</span><span class="s3">\&quot;</span><span class="s1">form</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n        </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-gotoLine</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">onkeydown: (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (event.keyCode == 27) { // Escape</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">view.dispatch({ effects: dialogEffect.of(false) });</span><span class="s3">\n                </span><span class="s1">view.focus();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (event.keyCode == 13) { // Enter</span><span class="s3">\n                </span><span class="s1">event.preventDefault();</span><span class="s3">\n                </span><span class="s1">go();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">onsubmit: (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">event.preventDefault();</span><span class="s3">\n            </span><span class="s1">go();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, elt(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">Go to line</span><span class="s3">\&quot;</span><span class="s1">), </span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">, input), </span><span class="s3">\&quot; \&quot;</span><span class="s1">, elt(</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">, { class: </span><span class="s3">\&quot;</span><span class="s1">cm-button</span><span class="s3">\&quot;</span><span class="s1">, type: </span><span class="s3">\&quot;</span><span class="s1">submit</span><span class="s3">\&quot; </span><span class="s1">}, view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">go</span><span class="s3">\&quot;</span><span class="s1">)));</span><span class="s3">\n    </span><span class="s1">function go() {</span><span class="s3">\n        </span><span class="s1">let match = /^([+-])?(</span><span class="s3">\\</span><span class="s1">d+)?(:</span><span class="s3">\\</span><span class="s1">d+)?(%)?$/.exec(input.value);</span><span class="s3">\n        </span><span class="s1">if (!match)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);</span><span class="s3">\n        </span><span class="s1">let [, sign, ln, cl, percent] = match;</span><span class="s3">\n        </span><span class="s1">let col = cl ? +cl.slice(1) : 0;</span><span class="s3">\n        </span><span class="s1">let line = ln ? +ln : startLine.number;</span><span class="s3">\n        </span><span class="s1">if (ln &amp;&amp; percent) {</span><span class="s3">\n            </span><span class="s1">let pc = line / 100;</span><span class="s3">\n            </span><span class="s1">if (sign)</span><span class="s3">\n                </span><span class="s1">pc = pc * (sign == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">? -1 : 1) + (startLine.number / state.doc.lines);</span><span class="s3">\n            </span><span class="s1">line = Math.round(state.doc.lines * pc);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ln &amp;&amp; sign) {</span><span class="s3">\n            </span><span class="s1">line = line * (sign == </span><span class="s3">\&quot;</span><span class="s1">-</span><span class="s3">\&quot; </span><span class="s1">? -1 : 1) + startLine.number;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));</span><span class="s3">\n        </span><span class="s1">let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));</span><span class="s3">\n        </span><span class="s1">view.dispatch({</span><span class="s3">\n            </span><span class="s1">effects: [dialogEffect.of(false), EditorView.scrollIntoView(selection.from, { y: 'center' })],</span><span class="s3">\n            </span><span class="s1">selection,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">view.focus();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return { dom };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const dialogEffect = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const dialogField = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create() { return true; },</span><span class="s3">\n    </span><span class="s1">update(value, tr) {</span><span class="s3">\n        </span><span class="s1">for (let e of tr.effects)</span><span class="s3">\n            </span><span class="s1">if (e.is(dialogEffect))</span><span class="s3">\n                </span><span class="s1">value = e.value;</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; showPanel.from(f, val =&gt; val ? createLineDialog : null)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Command that shows a dialog asking the user for a line number, and</span><span class="s3">\n</span><span class="s1">when a valid position is provided, moves the cursor to that line.</span><span class="s3">\n\n</span><span class="s1">Supports line numbers, relative line offsets prefixed with `+` or</span><span class="s3">\n</span><span class="s1">`-`, document percentages suffixed with `%`, and an optional</span><span class="s3">\n</span><span class="s1">column position by adding `:` and a second number after the line</span><span class="s3">\n</span><span class="s1">number.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const gotoLine = view =&gt; {</span><span class="s3">\n    </span><span class="s1">let panel = getPanel(view, createLineDialog);</span><span class="s3">\n    </span><span class="s1">if (!panel) {</span><span class="s3">\n        </span><span class="s1">let effects = [dialogEffect.of(true)];</span><span class="s3">\n        </span><span class="s1">if (view.state.field(dialogField, false) == null)</span><span class="s3">\n            </span><span class="s1">effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects });</span><span class="s3">\n        </span><span class="s1">panel = getPanel(view, createLineDialog);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (panel)</span><span class="s3">\n        </span><span class="s1">panel.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">).select();</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-panel.cm-gotoLine</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">2px 6px 4px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; label</span><span class="s3">\&quot;</span><span class="s1">: { fontSize: </span><span class="s3">\&quot;</span><span class="s1">80%</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">const defaultHighlightOptions = {</span><span class="s3">\n    </span><span class="s1">highlightWordAroundCursor: false,</span><span class="s3">\n    </span><span class="s1">minSelectionLength: 1,</span><span class="s3">\n    </span><span class="s1">maxMatches: 100,</span><span class="s3">\n    </span><span class="s1">wholeWords: false</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const highlightConfig = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(options) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(options, defaultHighlightOptions, {</span><span class="s3">\n            </span><span class="s1">highlightWordAroundCursor: (a, b) =&gt; a || b,</span><span class="s3">\n            </span><span class="s1">minSelectionLength: Math.min,</span><span class="s3">\n            </span><span class="s1">maxMatches: Math.min</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This extension highlights text that matches the selection. It uses</span><span class="s3">\n</span><span class="s1">the `</span><span class="s3">\&quot;</span><span class="s1">cm-selectionMatch</span><span class="s3">\&quot;</span><span class="s1">` class for the highlighting. When</span><span class="s3">\n</span><span class="s1">`highlightWordAroundCursor` is enabled, the word at the cursor</span><span class="s3">\n</span><span class="s1">itself will be highlighted with `</span><span class="s3">\&quot;</span><span class="s1">cm-selectionMatch-main</span><span class="s3">\&quot;</span><span class="s1">`.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function highlightSelectionMatches(options) {</span><span class="s3">\n    </span><span class="s1">let ext = [defaultTheme, matchHighlighter];</span><span class="s3">\n    </span><span class="s1">if (options)</span><span class="s3">\n        </span><span class="s1">ext.push(highlightConfig.of(options));</span><span class="s3">\n    </span><span class="s1">return ext;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const matchDeco = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-selectionMatch</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-selectionMatch cm-selectionMatch-main</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">// Whether the characters directly outside the given positions are non-word characters</span><span class="s3">\n</span><span class="s1">function insideWordBoundaries(check, state, from, to) {</span><span class="s3">\n    </span><span class="s1">return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &amp;&amp;</span><span class="s3">\n        </span><span class="s1">(to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Whether the characters directly at the given positions are word characters</span><span class="s3">\n</span><span class="s1">function insideWord(check, state, from, to) {</span><span class="s3">\n    </span><span class="s1">return check(state.sliceDoc(from, from + 1)) == CharCategory.Word</span><span class="s3">\n        </span><span class="s1">&amp;&amp; check(state.sliceDoc(to - 1, to)) == CharCategory.Word;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.decorations = this.getDeco(view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">if (update.selectionSet || update.docChanged || update.viewportChanged)</span><span class="s3">\n            </span><span class="s1">this.decorations = this.getDeco(update.view);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getDeco(view) {</span><span class="s3">\n        </span><span class="s1">let conf = view.state.facet(highlightConfig);</span><span class="s3">\n        </span><span class="s1">let { state } = view, sel = state.selection;</span><span class="s3">\n        </span><span class="s1">if (sel.ranges.length &gt; 1)</span><span class="s3">\n            </span><span class="s1">return Decoration.none;</span><span class="s3">\n        </span><span class="s1">let range = sel.main, query, check = null;</span><span class="s3">\n        </span><span class="s1">if (range.empty) {</span><span class="s3">\n            </span><span class="s1">if (!conf.highlightWordAroundCursor)</span><span class="s3">\n                </span><span class="s1">return Decoration.none;</span><span class="s3">\n            </span><span class="s1">let word = state.wordAt(range.head);</span><span class="s3">\n            </span><span class="s1">if (!word)</span><span class="s3">\n                </span><span class="s1">return Decoration.none;</span><span class="s3">\n            </span><span class="s1">check = state.charCategorizer(range.head);</span><span class="s3">\n            </span><span class="s1">query = state.sliceDoc(word.from, word.to);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let len = range.to - range.from;</span><span class="s3">\n            </span><span class="s1">if (len &lt; conf.minSelectionLength || len &gt; 200)</span><span class="s3">\n                </span><span class="s1">return Decoration.none;</span><span class="s3">\n            </span><span class="s1">if (conf.wholeWords) {</span><span class="s3">\n                </span><span class="s1">query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?</span><span class="s3">\n                </span><span class="s1">check = state.charCategorizer(range.head);</span><span class="s3">\n                </span><span class="s1">if (!(insideWordBoundaries(check, state, range.from, range.to) &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">insideWord(check, state, range.from, range.to)))</span><span class="s3">\n                    </span><span class="s1">return Decoration.none;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">query = state.sliceDoc(range.from, range.to);</span><span class="s3">\n                </span><span class="s1">if (!query)</span><span class="s3">\n                    </span><span class="s1">return Decoration.none;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let deco = [];</span><span class="s3">\n        </span><span class="s1">for (let part of view.visibleRanges) {</span><span class="s3">\n            </span><span class="s1">let cursor = new SearchCursor(state.doc, query, part.from, part.to);</span><span class="s3">\n            </span><span class="s1">while (!cursor.next().done) {</span><span class="s3">\n                </span><span class="s1">let { from, to } = cursor.value;</span><span class="s3">\n                </span><span class="s1">if (!check || insideWordBoundaries(check, state, from, to)) {</span><span class="s3">\n                    </span><span class="s1">if (range.empty &amp;&amp; from &lt;= range.from &amp;&amp; to &gt;= range.to)</span><span class="s3">\n                        </span><span class="s1">deco.push(mainMatchDeco.range(from, to));</span><span class="s3">\n                    </span><span class="s1">else if (from &gt;= range.to || to &lt;= range.from)</span><span class="s3">\n                        </span><span class="s1">deco.push(matchDeco.range(from, to));</span><span class="s3">\n                    </span><span class="s1">if (deco.length &gt; conf.maxMatches)</span><span class="s3">\n                        </span><span class="s1">return Decoration.none;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return Decoration.set(deco);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const defaultTheme = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-selectionMatch</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#99ff7780</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-searchMatch .cm-selectionMatch</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">transparent</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">// Select the words around the cursors.</span><span class="s3">\n</span><span class="s1">const selectWord = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { selection } = state;</span><span class="s3">\n    </span><span class="s1">let newSel = EditorSelection.create(selection.ranges.map(range =&gt; state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);</span><span class="s3">\n    </span><span class="s1">if (newSel.eq(selection))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({ selection: newSel }));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">// Find next occurrence of query relative to last cursor. Wrap around</span><span class="s3">\n</span><span class="s1">// the document if there are no more matches.</span><span class="s3">\n</span><span class="s1">function findNextOccurrence(state, query) {</span><span class="s3">\n    </span><span class="s1">let { main, ranges } = state.selection;</span><span class="s3">\n    </span><span class="s1">let word = state.wordAt(main.head), fullWord = word &amp;&amp; word.from == main.from &amp;&amp; word.to == main.to;</span><span class="s3">\n    </span><span class="s1">for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {</span><span class="s3">\n        </span><span class="s1">cursor.next();</span><span class="s3">\n        </span><span class="s1">if (cursor.done) {</span><span class="s3">\n            </span><span class="s1">if (cycled)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));</span><span class="s3">\n            </span><span class="s1">cycled = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (cycled &amp;&amp; ranges.some(r =&gt; r.from == cursor.value.from))</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (fullWord) {</span><span class="s3">\n                </span><span class="s1">let word = state.wordAt(cursor.value.from);</span><span class="s3">\n                </span><span class="s1">if (!word || word.from != cursor.value.from || word.to != cursor.value.to)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return cursor.value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Select next occurrence of the current selection. Expand selection</span><span class="s3">\n</span><span class="s1">to the surrounding word when the selection is empty.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectNextOccurrence = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { ranges } = state.selection;</span><span class="s3">\n    </span><span class="s1">if (ranges.some(sel =&gt; sel.from === sel.to))</span><span class="s3">\n        </span><span class="s1">return selectWord({ state, dispatch });</span><span class="s3">\n    </span><span class="s1">let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);</span><span class="s3">\n    </span><span class="s1">if (state.selection.ranges.some(r =&gt; state.sliceDoc(r.from, r.to) != searchedText))</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let range = findNextOccurrence(state, searchedText);</span><span class="s3">\n    </span><span class="s1">if (!range)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({</span><span class="s3">\n        </span><span class="s1">selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),</span><span class="s3">\n        </span><span class="s1">effects: EditorView.scrollIntoView(range.to)</span><span class="s3">\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">const searchConfigFacet = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine(configs) {</span><span class="s3">\n        </span><span class="s1">return combineConfig(configs, {</span><span class="s3">\n            </span><span class="s1">top: false,</span><span class="s3">\n            </span><span class="s1">caseSensitive: false,</span><span class="s3">\n            </span><span class="s1">literal: false,</span><span class="s3">\n            </span><span class="s1">regexp: false,</span><span class="s3">\n            </span><span class="s1">wholeWord: false,</span><span class="s3">\n            </span><span class="s1">createPanel: view =&gt; new SearchPanel(view),</span><span class="s3">\n            </span><span class="s1">scrollToMatch: range =&gt; EditorView.scrollIntoView(range)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Add search state to the editor configuration, and optionally</span><span class="s3">\n</span><span class="s1">configure the search extension.</span><span class="s3">\n</span><span class="s1">([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically</span><span class="s3">\n</span><span class="s1">enable this if it isn't already on).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function search(config) {</span><span class="s3">\n    </span><span class="s1">return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A search query. Part of the editor's search state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SearchQuery {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a query object.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(config) {</span><span class="s3">\n        </span><span class="s1">this.search = config.search;</span><span class="s3">\n        </span><span class="s1">this.caseSensitive = !!config.caseSensitive;</span><span class="s3">\n        </span><span class="s1">this.literal = !!config.literal;</span><span class="s3">\n        </span><span class="s1">this.regexp = !!config.regexp;</span><span class="s3">\n        </span><span class="s1">this.replace = config.replace || </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.valid = !!this.search &amp;&amp; (!this.regexp || validRegExp(this.search));</span><span class="s3">\n        </span><span class="s1">this.unquoted = this.unquote(this.search);</span><span class="s3">\n        </span><span class="s1">this.wholeWord = !!config.wholeWord;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">unquote(text) {</span><span class="s3">\n        </span><span class="s1">return this.literal ? text :</span><span class="s3">\n            </span><span class="s1">text.replace(/</span><span class="s3">\\\\</span><span class="s1">([nrt</span><span class="s3">\\\\</span><span class="s1">])/g, (_, ch) =&gt; ch == </span><span class="s3">\&quot;</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot; </span><span class="s1">: ch == </span><span class="s3">\&quot;</span><span class="s1">r</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot; </span><span class="s1">: ch == </span><span class="s3">\&quot;</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;\\</span><span class="s1">t</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this query to another query.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">return this.search == other.search &amp;&amp; this.replace == other.replace &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.caseSensitive == other.caseSensitive &amp;&amp; this.regexp == other.regexp &amp;&amp;</span><span class="s3">\n            </span><span class="s1">this.wholeWord == other.wholeWord;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">create() {</span><span class="s3">\n        </span><span class="s1">return this.regexp ? new RegExpQuery(this) : new StringQuery(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a search cursor for this query, searching through the given</span><span class="s3">\n    </span><span class="s1">range in the given state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getCursor(state, from = 0, to) {</span><span class="s3">\n        </span><span class="s1">let st = state.doc ? state : EditorState.create({ doc: state });</span><span class="s3">\n        </span><span class="s1">if (to == null)</span><span class="s3">\n            </span><span class="s1">to = st.doc.length;</span><span class="s3">\n        </span><span class="s1">return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class QueryType {</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">this.spec = spec;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function stringCursor(spec, state, from, to) {</span><span class="s3">\n    </span><span class="s1">return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x =&gt; x.toLowerCase(), spec.wholeWord ? stringWordTest(state.doc, state.charCategorizer(state.selection.main.head)) : undefined);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function stringWordTest(doc, categorizer) {</span><span class="s3">\n    </span><span class="s1">return (from, to, buf, bufPos) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (bufPos &gt; from || bufPos + buf.length &lt; to) {</span><span class="s3">\n            </span><span class="s1">bufPos = Math.max(0, from - 2);</span><span class="s3">\n            </span><span class="s1">buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||</span><span class="s3">\n            </span><span class="s1">categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||</span><span class="s3">\n                </span><span class="s1">categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class StringQuery extends QueryType {</span><span class="s3">\n    </span><span class="s1">constructor(spec) {</span><span class="s3">\n        </span><span class="s1">super(spec);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextMatch(state, curFrom, curTo) {</span><span class="s3">\n        </span><span class="s1">let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();</span><span class="s3">\n        </span><span class="s1">if (cursor.done) {</span><span class="s3">\n            </span><span class="s1">let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);</span><span class="s3">\n            </span><span class="s1">cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return cursor.done || cursor.value.from == curFrom &amp;&amp; cursor.value.to == curTo ? null : cursor.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Searching in reverse is, rather than implementing an inverted search</span><span class="s3">\n    </span><span class="s1">// cursor, done by scanning chunk after chunk forward.</span><span class="s3">\n    </span><span class="s1">prevMatchInRange(state, from, to) {</span><span class="s3">\n        </span><span class="s1">for (let pos = to;;) {</span><span class="s3">\n            </span><span class="s1">let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);</span><span class="s3">\n            </span><span class="s1">let cursor = stringCursor(this.spec, state, start, pos), range = null;</span><span class="s3">\n            </span><span class="s1">while (!cursor.nextOverlapping().done)</span><span class="s3">\n                </span><span class="s1">range = cursor.value;</span><span class="s3">\n            </span><span class="s1">if (range)</span><span class="s3">\n                </span><span class="s1">return range;</span><span class="s3">\n            </span><span class="s1">if (start == from)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">pos -= 10000 /* FindPrev.ChunkSize */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">prevMatch(state, curFrom, curTo) {</span><span class="s3">\n        </span><span class="s1">let found = this.prevMatchInRange(state, 0, curFrom);</span><span class="s3">\n        </span><span class="s1">if (!found)</span><span class="s3">\n            </span><span class="s1">found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);</span><span class="s3">\n        </span><span class="s1">return found &amp;&amp; (found.from != curFrom || found.to != curTo) ? found : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getReplacement(_result) { return this.spec.unquote(this.spec.replace); }</span><span class="s3">\n    </span><span class="s1">matchAll(state, limit) {</span><span class="s3">\n        </span><span class="s1">let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];</span><span class="s3">\n        </span><span class="s1">while (!cursor.next().done) {</span><span class="s3">\n            </span><span class="s1">if (ranges.length &gt;= limit)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">ranges.push(cursor.value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ranges;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">highlight(state, from, to, add) {</span><span class="s3">\n        </span><span class="s1">let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));</span><span class="s3">\n        </span><span class="s1">while (!cursor.next().done)</span><span class="s3">\n            </span><span class="s1">add(cursor.value.from, cursor.value.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function regexpCursor(spec, state, from, to) {</span><span class="s3">\n    </span><span class="s1">return new RegExpCursor(state.doc, spec.search, {</span><span class="s3">\n        </span><span class="s1">ignoreCase: !spec.caseSensitive,</span><span class="s3">\n        </span><span class="s1">test: spec.wholeWord ? regexpWordTest(state.charCategorizer(state.selection.main.head)) : undefined</span><span class="s3">\n    </span><span class="s1">}, from, to);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function charBefore(str, index) {</span><span class="s3">\n    </span><span class="s1">return str.slice(findClusterBreak(str, index, false), index);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function charAfter(str, index) {</span><span class="s3">\n    </span><span class="s1">return str.slice(index, findClusterBreak(str, index));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function regexpWordTest(categorizer) {</span><span class="s3">\n    </span><span class="s1">return (_from, _to, match) =&gt; !match[0].length ||</span><span class="s3">\n        </span><span class="s1">(categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||</span><span class="s3">\n            </span><span class="s1">categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||</span><span class="s3">\n                </span><span class="s1">categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RegExpQuery extends QueryType {</span><span class="s3">\n    </span><span class="s1">nextMatch(state, curFrom, curTo) {</span><span class="s3">\n        </span><span class="s1">let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();</span><span class="s3">\n        </span><span class="s1">if (cursor.done)</span><span class="s3">\n            </span><span class="s1">cursor = regexpCursor(this.spec, state, 0, curFrom).next();</span><span class="s3">\n        </span><span class="s1">return cursor.done ? null : cursor.value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">prevMatchInRange(state, from, to) {</span><span class="s3">\n        </span><span class="s1">for (let size = 1;; size++) {</span><span class="s3">\n            </span><span class="s1">let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);</span><span class="s3">\n            </span><span class="s1">let cursor = regexpCursor(this.spec, state, start, to), range = null;</span><span class="s3">\n            </span><span class="s1">while (!cursor.next().done)</span><span class="s3">\n                </span><span class="s1">range = cursor.value;</span><span class="s3">\n            </span><span class="s1">if (range &amp;&amp; (start == from || range.from &gt; start + 10))</span><span class="s3">\n                </span><span class="s1">return range;</span><span class="s3">\n            </span><span class="s1">if (start == from)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">prevMatch(state, curFrom, curTo) {</span><span class="s3">\n        </span><span class="s1">return this.prevMatchInRange(state, 0, curFrom) ||</span><span class="s3">\n            </span><span class="s1">this.prevMatchInRange(state, curTo, state.doc.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getReplacement(result) {</span><span class="s3">\n        </span><span class="s1">return this.spec.unquote(this.spec.replace).replace(/</span><span class="s3">\\</span><span class="s1">$([$&amp;</span><span class="s3">\\</span><span class="s1">d+])/g, (m, i) =&gt; i == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;\n            </span><span class="s1">: i == </span><span class="s3">\&quot;</span><span class="s1">&amp;</span><span class="s3">\&quot; </span><span class="s1">? result.match[0]</span><span class="s3">\n                </span><span class="s1">: i != </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; +i &lt; result.match.length ? result.match[i]</span><span class="s3">\n                    </span><span class="s1">: m);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">matchAll(state, limit) {</span><span class="s3">\n        </span><span class="s1">let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];</span><span class="s3">\n        </span><span class="s1">while (!cursor.next().done) {</span><span class="s3">\n            </span><span class="s1">if (ranges.length &gt;= limit)</span><span class="s3">\n                </span><span class="s1">return null;</span><span class="s3">\n            </span><span class="s1">ranges.push(cursor.value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ranges;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">highlight(state, from, to, add) {</span><span class="s3">\n        </span><span class="s1">let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));</span><span class="s3">\n        </span><span class="s1">while (!cursor.next().done)</span><span class="s3">\n            </span><span class="s1">add(cursor.value.from, cursor.value.to);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A state effect that updates the current search query. Note that</span><span class="s3">\n</span><span class="s1">this only has an effect if the search state has been initialized</span><span class="s3">\n</span><span class="s1">(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or</span><span class="s3">\n</span><span class="s1">by running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least</span><span class="s3">\n</span><span class="s1">once).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const setSearchQuery = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const togglePanel = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">const searchState = /*@__PURE__*/StateField.define({</span><span class="s3">\n    </span><span class="s1">create(state) {</span><span class="s3">\n        </span><span class="s1">return new SearchState(defaultQuery(state).create(), null);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">update(value, tr) {</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n            </span><span class="s1">if (effect.is(setSearchQuery))</span><span class="s3">\n                </span><span class="s1">value = new SearchState(effect.value.create(), value.panel);</span><span class="s3">\n            </span><span class="s1">else if (effect.is(togglePanel))</span><span class="s3">\n                </span><span class="s1">value = new SearchState(value.query, effect.value ? createSearchPanel : null);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return value;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">provide: f =&gt; showPanel.from(f, val =&gt; val.panel)</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Get the current search query from an editor state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function getSearchQuery(state) {</span><span class="s3">\n    </span><span class="s1">let curState = state.field(searchState, false);</span><span class="s3">\n    </span><span class="s1">return curState ? curState.query.spec : defaultQuery(state);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Query whether the search panel is open in the given editor state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function searchPanelOpen(state) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SearchState {</span><span class="s3">\n    </span><span class="s1">constructor(query, panel) {</span><span class="s3">\n        </span><span class="s1">this.query = query;</span><span class="s3">\n        </span><span class="s1">this.panel = panel;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const matchMark = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-searchMatch</span><span class="s3">\&quot; </span><span class="s1">}), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: </span><span class="s3">\&quot;</span><span class="s1">cm-searchMatch cm-searchMatch-selected</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">this.decorations = this.highlight(view.state.field(searchState));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">let state = update.state.field(searchState);</span><span class="s3">\n        </span><span class="s1">if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)</span><span class="s3">\n            </span><span class="s1">this.decorations = this.highlight(state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">highlight({ query, panel }) {</span><span class="s3">\n        </span><span class="s1">if (!panel || !query.spec.valid)</span><span class="s3">\n            </span><span class="s1">return Decoration.none;</span><span class="s3">\n        </span><span class="s1">let { view } = this;</span><span class="s3">\n        </span><span class="s1">let builder = new RangeSetBuilder();</span><span class="s3">\n        </span><span class="s1">for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i &lt; l; i++) {</span><span class="s3">\n            </span><span class="s1">let { from, to } = ranges[i];</span><span class="s3">\n            </span><span class="s1">while (i &lt; l - 1 &amp;&amp; to &gt; ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)</span><span class="s3">\n                </span><span class="s1">to = ranges[++i].to;</span><span class="s3">\n            </span><span class="s1">query.highlight(view.state, from, to, (from, to) =&gt; {</span><span class="s3">\n                </span><span class="s1">let selected = view.state.selection.ranges.some(r =&gt; r.from == from &amp;&amp; r.to == to);</span><span class="s3">\n                </span><span class="s1">builder.add(from, to, selected ? selectedMatchMark : matchMark);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return builder.finish();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">decorations: v =&gt; v.decorations</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function searchCommand(f) {</span><span class="s3">\n    </span><span class="s1">return view =&gt; {</span><span class="s3">\n        </span><span class="s1">let state = view.state.field(searchState, false);</span><span class="s3">\n        </span><span class="s1">return state &amp;&amp; state.query.spec.valid ? f(view, state) : openSearchPanel(view);</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Open the search panel if it isn't already open, and move the</span><span class="s3">\n</span><span class="s1">selection to the first match after the current main selection.</span><span class="s3">\n</span><span class="s1">Will wrap around to the start of the document when it reaches the</span><span class="s3">\n</span><span class="s1">end.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findNext = /*@__PURE__*/searchCommand((view, { query }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { to } = view.state.selection.main;</span><span class="s3">\n    </span><span class="s1">let next = query.nextMatch(view.state, to, to);</span><span class="s3">\n    </span><span class="s1">if (!next)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let selection = EditorSelection.single(next.from, next.to);</span><span class="s3">\n    </span><span class="s1">let config = view.state.facet(searchConfigFacet);</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">selection,</span><span class="s3">\n        </span><span class="s1">effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">select.search</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">selectSearchInput(view);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Move the selection to the previous instance of the search query,</span><span class="s3">\n</span><span class="s1">before the current main selection. Will wrap past the start</span><span class="s3">\n</span><span class="s1">of the document to start searching at the end again.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const findPrevious = /*@__PURE__*/searchCommand((view, { query }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { state } = view, { from } = state.selection.main;</span><span class="s3">\n    </span><span class="s1">let prev = query.prevMatch(state, from, from);</span><span class="s3">\n    </span><span class="s1">if (!prev)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let selection = EditorSelection.single(prev.from, prev.to);</span><span class="s3">\n    </span><span class="s1">let config = view.state.facet(searchConfigFacet);</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">selection,</span><span class="s3">\n        </span><span class="s1">effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">select.search</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">selectSearchInput(view);</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Select all instances of the search query.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectMatches = /*@__PURE__*/searchCommand((view, { query }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let ranges = query.matchAll(view.state, 1000);</span><span class="s3">\n    </span><span class="s1">if (!ranges || !ranges.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">selection: EditorSelection.create(ranges.map(r =&gt; EditorSelection.range(r.from, r.to))),</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">select.search.matches</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Select all instances of the currently selected text.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const selectSelectionMatches = ({ state, dispatch }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let sel = state.selection;</span><span class="s3">\n    </span><span class="s1">if (sel.ranges.length &gt; 1 || sel.main.empty)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let { from, to } = sel.main;</span><span class="s3">\n    </span><span class="s1">let ranges = [], main = 0;</span><span class="s3">\n    </span><span class="s1">for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {</span><span class="s3">\n        </span><span class="s1">if (ranges.length &gt; 1000)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (cur.value.from == from)</span><span class="s3">\n            </span><span class="s1">main = ranges.length;</span><span class="s3">\n        </span><span class="s1">ranges.push(EditorSelection.range(cur.value.from, cur.value.to));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dispatch(state.update({</span><span class="s3">\n        </span><span class="s1">selection: EditorSelection.create(ranges, main),</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">select.search.matches</span><span class="s3">\&quot;\n    </span><span class="s1">}));</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace the current match of the search query.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const replaceNext = /*@__PURE__*/searchCommand((view, { query }) =&gt; {</span><span class="s3">\n    </span><span class="s1">let { state } = view, { from, to } = state.selection.main;</span><span class="s3">\n    </span><span class="s1">if (state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let match = query.nextMatch(state, from, from);</span><span class="s3">\n    </span><span class="s1">if (!match)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let next = match;</span><span class="s3">\n    </span><span class="s1">let changes = [], selection, replacement;</span><span class="s3">\n    </span><span class="s1">let effects = [];</span><span class="s3">\n    </span><span class="s1">if (next.from == from &amp;&amp; next.to == to) {</span><span class="s3">\n        </span><span class="s1">replacement = state.toText(query.getReplacement(next));</span><span class="s3">\n        </span><span class="s1">changes.push({ from: next.from, to: next.to, insert: replacement });</span><span class="s3">\n        </span><span class="s1">next = query.nextMatch(state, next.from, next.to);</span><span class="s3">\n        </span><span class="s1">effects.push(EditorView.announce.of(state.phrase(</span><span class="s3">\&quot;</span><span class="s1">replaced match on line $</span><span class="s3">\&quot;</span><span class="s1">, state.doc.lineAt(from).number) + </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (next) {</span><span class="s3">\n        </span><span class="s1">let off = changes.length == 0 || changes[0].from &gt;= match.to ? 0 : match.to - match.from - replacement.length;</span><span class="s3">\n        </span><span class="s1">selection = EditorSelection.single(next.from - off, next.to - off);</span><span class="s3">\n        </span><span class="s1">effects.push(announceMatch(view, next));</span><span class="s3">\n        </span><span class="s1">effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">changes, selection, effects,</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.replace</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Replace all instances of the search query with the given</span><span class="s3">\n</span><span class="s1">replacement.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const replaceAll = /*@__PURE__*/searchCommand((view, { query }) =&gt; {</span><span class="s3">\n    </span><span class="s1">if (view.state.readOnly)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let changes = query.matchAll(view.state, 1e9).map(match =&gt; {</span><span class="s3">\n        </span><span class="s1">let { from, to } = match;</span><span class="s3">\n        </span><span class="s1">return { from, to, insert: query.getReplacement(match) };</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!changes.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let announceText = view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">replaced $ matches</span><span class="s3">\&quot;</span><span class="s1">, changes.length) + </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">view.dispatch({</span><span class="s3">\n        </span><span class="s1">changes,</span><span class="s3">\n        </span><span class="s1">effects: EditorView.announce.of(announceText),</span><span class="s3">\n        </span><span class="s1">userEvent: </span><span class="s3">\&quot;</span><span class="s1">input.replace.all</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">function createSearchPanel(view) {</span><span class="s3">\n    </span><span class="s1">return view.state.facet(searchConfigFacet).createPanel(view);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function defaultQuery(state, fallback) {</span><span class="s3">\n    </span><span class="s1">var _a, _b, _c, _d, _e;</span><span class="s3">\n    </span><span class="s1">let sel = state.selection.main;</span><span class="s3">\n    </span><span class="s1">let selText = sel.empty || sel.to &gt; sel.from + 100 ? </span><span class="s3">\&quot;\&quot; </span><span class="s1">: state.sliceDoc(sel.from, sel.to);</span><span class="s3">\n    </span><span class="s1">if (fallback &amp;&amp; !selText)</span><span class="s3">\n        </span><span class="s1">return fallback;</span><span class="s3">\n    </span><span class="s1">let config = state.facet(searchConfigFacet);</span><span class="s3">\n    </span><span class="s1">return new SearchQuery({</span><span class="s3">\n        </span><span class="s1">search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null &amp;&amp; _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/</span><span class="s3">\\</span><span class="s1">n/g, </span><span class="s3">\&quot;\\\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null &amp;&amp; _b !== void 0 ? _b : config.caseSensitive,</span><span class="s3">\n        </span><span class="s1">literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null &amp;&amp; _c !== void 0 ? _c : config.literal,</span><span class="s3">\n        </span><span class="s1">regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null &amp;&amp; _d !== void 0 ? _d : config.regexp,</span><span class="s3">\n        </span><span class="s1">wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null &amp;&amp; _e !== void 0 ? _e : config.wholeWord</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getSearchInput(view) {</span><span class="s3">\n    </span><span class="s1">let panel = getPanel(view, createSearchPanel);</span><span class="s3">\n    </span><span class="s1">return panel &amp;&amp; panel.dom.querySelector(</span><span class="s3">\&quot;</span><span class="s1">[main-field]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function selectSearchInput(view) {</span><span class="s3">\n    </span><span class="s1">let input = getSearchInput(view);</span><span class="s3">\n    </span><span class="s1">if (input &amp;&amp; input == view.root.activeElement)</span><span class="s3">\n        </span><span class="s1">input.select();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Make sure the search panel is open and focused.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const openSearchPanel = view =&gt; {</span><span class="s3">\n    </span><span class="s1">let state = view.state.field(searchState, false);</span><span class="s3">\n    </span><span class="s1">if (state &amp;&amp; state.panel) {</span><span class="s3">\n        </span><span class="s1">let searchInput = getSearchInput(view);</span><span class="s3">\n        </span><span class="s1">if (searchInput &amp;&amp; searchInput != view.root.activeElement) {</span><span class="s3">\n            </span><span class="s1">let query = defaultQuery(view.state, state.query.spec);</span><span class="s3">\n            </span><span class="s1">if (query.valid)</span><span class="s3">\n                </span><span class="s1">view.dispatch({ effects: setSearchQuery.of(query) });</span><span class="s3">\n            </span><span class="s1">searchInput.focus();</span><span class="s3">\n            </span><span class="s1">searchInput.select();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">view.dispatch({ effects: [</span><span class="s3">\n                </span><span class="s1">togglePanel.of(true),</span><span class="s3">\n                </span><span class="s1">state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)</span><span class="s3">\n            </span><span class="s1">] });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Close the search panel.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const closeSearchPanel = view =&gt; {</span><span class="s3">\n    </span><span class="s1">let state = view.state.field(searchState, false);</span><span class="s3">\n    </span><span class="s1">if (!state || !state.panel)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">let panel = getPanel(view, createSearchPanel);</span><span class="s3">\n    </span><span class="s1">if (panel &amp;&amp; panel.dom.contains(view.root.activeElement))</span><span class="s3">\n        </span><span class="s1">view.focus();</span><span class="s3">\n    </span><span class="s1">view.dispatch({ effects: togglePanel.of(false) });</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Default search-related key bindings.</span><span class="s3">\n\n </span><span class="s1">- Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)</span><span class="s3">\n </span><span class="s1">- F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)</span><span class="s3">\n </span><span class="s1">- Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)</span><span class="s3">\n </span><span class="s1">- Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)</span><span class="s3">\n </span><span class="s1">- Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const searchKeymap = [</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-f</span><span class="s3">\&quot;</span><span class="s1">, run: openSearchPanel, scope: </span><span class="s3">\&quot;</span><span class="s1">editor search-panel</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">F3</span><span class="s3">\&quot;</span><span class="s1">, run: findNext, shift: findPrevious, scope: </span><span class="s3">\&quot;</span><span class="s1">editor search-panel</span><span class="s3">\&quot;</span><span class="s1">, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-g</span><span class="s3">\&quot;</span><span class="s1">, run: findNext, shift: findPrevious, scope: </span><span class="s3">\&quot;</span><span class="s1">editor search-panel</span><span class="s3">\&quot;</span><span class="s1">, preventDefault: true },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Escape</span><span class="s3">\&quot;</span><span class="s1">, run: closeSearchPanel, scope: </span><span class="s3">\&quot;</span><span class="s1">editor search-panel</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Shift-l</span><span class="s3">\&quot;</span><span class="s1">, run: selectSelectionMatches },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-Alt-g</span><span class="s3">\&quot;</span><span class="s1">, run: gotoLine },</span><span class="s3">\n    </span><span class="s1">{ key: </span><span class="s3">\&quot;</span><span class="s1">Mod-d</span><span class="s3">\&quot;</span><span class="s1">, run: selectNextOccurrence, preventDefault: true },</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">class SearchPanel {</span><span class="s3">\n    </span><span class="s1">constructor(view) {</span><span class="s3">\n        </span><span class="s1">this.view = view;</span><span class="s3">\n        </span><span class="s1">let query = this.query = view.state.field(searchState).query.spec;</span><span class="s3">\n        </span><span class="s1">this.commit = this.commit.bind(this);</span><span class="s3">\n        </span><span class="s1">this.searchField = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">value: query.search,</span><span class="s3">\n            </span><span class="s1">placeholder: phrase(view, </span><span class="s3">\&quot;</span><span class="s1">Find</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            \&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">: phrase(view, </span><span class="s3">\&quot;</span><span class="s1">Find</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-textfield</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">search</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">form: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">main-field</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">onchange: this.commit,</span><span class="s3">\n            </span><span class="s1">onkeyup: this.commit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.replaceField = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">value: query.replace,</span><span class="s3">\n            </span><span class="s1">placeholder: phrase(view, </span><span class="s3">\&quot;</span><span class="s1">Replace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            \&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">: phrase(view, </span><span class="s3">\&quot;</span><span class="s1">Replace</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n            </span><span class="s1">class: </span><span class="s3">\&quot;</span><span class="s1">cm-textfield</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">replace</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">form: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">onchange: this.commit,</span><span class="s3">\n            </span><span class="s1">onkeyup: this.commit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.caseField = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">checkbox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">case</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">form: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">checked: query.caseSensitive,</span><span class="s3">\n            </span><span class="s1">onchange: this.commit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.reField = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">checkbox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">re</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">form: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">checked: query.regexp,</span><span class="s3">\n            </span><span class="s1">onchange: this.commit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.wordField = elt(</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n            </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">checkbox</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">word</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">form: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">checked: query.wholeWord,</span><span class="s3">\n            </span><span class="s1">onchange: this.commit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">function button(name, onclick, content) {</span><span class="s3">\n            </span><span class="s1">return elt(</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">, { class: </span><span class="s3">\&quot;</span><span class="s1">cm-button</span><span class="s3">\&quot;</span><span class="s1">, name, onclick, type: </span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot; </span><span class="s1">}, content);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.dom = elt(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">, { onkeydown: (e) =&gt; this.keydown(e), class: </span><span class="s3">\&quot;</span><span class="s1">cm-search</span><span class="s3">\&quot; </span><span class="s1">}, [</span><span class="s3">\n            </span><span class="s1">this.searchField,</span><span class="s3">\n            </span><span class="s1">button(</span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; findNext(view), [phrase(view, </span><span class="s3">\&quot;</span><span class="s1">next</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">button(</span><span class="s3">\&quot;</span><span class="s1">prev</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; findPrevious(view), [phrase(view, </span><span class="s3">\&quot;</span><span class="s1">previous</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">button(</span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; selectMatches(view), [phrase(view, </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">elt(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, null, [this.caseField, phrase(view, </span><span class="s3">\&quot;</span><span class="s1">match case</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">elt(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, null, [this.reField, phrase(view, </span><span class="s3">\&quot;</span><span class="s1">regexp</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">elt(</span><span class="s3">\&quot;</span><span class="s1">label</span><span class="s3">\&quot;</span><span class="s1">, null, [this.wordField, phrase(view, </span><span class="s3">\&quot;</span><span class="s1">by word</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n            </span><span class="s1">...view.state.readOnly ? [] : [</span><span class="s3">\n                </span><span class="s1">elt(</span><span class="s3">\&quot;</span><span class="s1">br</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">this.replaceField,</span><span class="s3">\n                </span><span class="s1">button(</span><span class="s3">\&quot;</span><span class="s1">replace</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; replaceNext(view), [phrase(view, </span><span class="s3">\&quot;</span><span class="s1">replace</span><span class="s3">\&quot;</span><span class="s1">)]),</span><span class="s3">\n                </span><span class="s1">button(</span><span class="s3">\&quot;</span><span class="s1">replaceAll</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; replaceAll(view), [phrase(view, </span><span class="s3">\&quot;</span><span class="s1">replace all</span><span class="s3">\&quot;</span><span class="s1">)])</span><span class="s3">\n            </span><span class="s1">],</span><span class="s3">\n            </span><span class="s1">elt(</span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;</span><span class="s1">, {</span><span class="s3">\n                </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">onclick: () =&gt; closeSearchPanel(view),</span><span class="s3">\n                \&quot;</span><span class="s1">aria-label</span><span class="s3">\&quot;</span><span class="s1">: phrase(view, </span><span class="s3">\&quot;</span><span class="s1">close</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n                </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">button</span><span class="s3">\&quot;\n            </span><span class="s1">}, [</span><span class="s3">\&quot;</span><span class="s1"></span><span class="s3">\&quot;</span><span class="s1">])</span><span class="s3">\n        </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">commit() {</span><span class="s3">\n        </span><span class="s1">let query = new SearchQuery({</span><span class="s3">\n            </span><span class="s1">search: this.searchField.value,</span><span class="s3">\n            </span><span class="s1">caseSensitive: this.caseField.checked,</span><span class="s3">\n            </span><span class="s1">regexp: this.reField.checked,</span><span class="s3">\n            </span><span class="s1">wholeWord: this.wordField.checked,</span><span class="s3">\n            </span><span class="s1">replace: this.replaceField.value,</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (!query.eq(this.query)) {</span><span class="s3">\n            </span><span class="s1">this.query = query;</span><span class="s3">\n            </span><span class="s1">this.view.dispatch({ effects: setSearchQuery.of(query) });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">keydown(e) {</span><span class="s3">\n        </span><span class="s1">if (runScopeHandlers(this.view, e, </span><span class="s3">\&quot;</span><span class="s1">search-panel</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n            </span><span class="s1">e.preventDefault();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (e.keyCode == 13 &amp;&amp; e.target == this.searchField) {</span><span class="s3">\n            </span><span class="s1">e.preventDefault();</span><span class="s3">\n            </span><span class="s1">(e.shiftKey ? findPrevious : findNext)(this.view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (e.keyCode == 13 &amp;&amp; e.target == this.replaceField) {</span><span class="s3">\n            </span><span class="s1">e.preventDefault();</span><span class="s3">\n            </span><span class="s1">replaceNext(this.view);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">update(update) {</span><span class="s3">\n        </span><span class="s1">for (let tr of update.transactions)</span><span class="s3">\n            </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n                </span><span class="s1">if (effect.is(setSearchQuery) &amp;&amp; !effect.value.eq(this.query))</span><span class="s3">\n                    </span><span class="s1">this.setQuery(effect.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setQuery(query) {</span><span class="s3">\n        </span><span class="s1">this.query = query;</span><span class="s3">\n        </span><span class="s1">this.searchField.value = query.search;</span><span class="s3">\n        </span><span class="s1">this.replaceField.value = query.replace;</span><span class="s3">\n        </span><span class="s1">this.caseField.checked = query.caseSensitive;</span><span class="s3">\n        </span><span class="s1">this.reField.checked = query.regexp;</span><span class="s3">\n        </span><span class="s1">this.wordField.checked = query.wholeWord;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mount() {</span><span class="s3">\n        </span><span class="s1">this.searchField.select();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get pos() { return 80; }</span><span class="s3">\n    </span><span class="s1">get top() { return this.view.state.facet(searchConfigFacet).top; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function phrase(view, phrase) { return view.state.phrase(phrase); }</span><span class="s3">\n</span><span class="s1">const AnnounceMargin = 30;</span><span class="s3">\n</span><span class="s1">const Break = /[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">.,:;?!]/;</span><span class="s3">\n</span><span class="s1">function announceMatch(view, { from, to }) {</span><span class="s3">\n    </span><span class="s1">let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;</span><span class="s3">\n    </span><span class="s1">let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);</span><span class="s3">\n    </span><span class="s1">let text = view.state.sliceDoc(start, end);</span><span class="s3">\n    </span><span class="s1">if (start != line.from) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; AnnounceMargin; i++)</span><span class="s3">\n            </span><span class="s1">if (!Break.test(text[i + 1]) &amp;&amp; Break.test(text[i])) {</span><span class="s3">\n                </span><span class="s1">text = text.slice(i);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (end != lineEnd) {</span><span class="s3">\n        </span><span class="s1">for (let i = text.length - 1; i &gt; text.length - AnnounceMargin; i--)</span><span class="s3">\n            </span><span class="s1">if (!Break.test(text[i - 1]) &amp;&amp; Break.test(text[i])) {</span><span class="s3">\n                </span><span class="s1">text = text.slice(0, i);</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return EditorView.announce.of(`${view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">current match</span><span class="s3">\&quot;</span><span class="s1">)}. ${text} ${view.state.phrase(</span><span class="s3">\&quot;</span><span class="s1">on line</span><span class="s3">\&quot;</span><span class="s1">)} ${line.number}.`);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const baseTheme = /*@__PURE__*/EditorView.baseTheme({</span><span class="s3">\n    \&quot;</span><span class="s1">.cm-panel.cm-search</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n        </span><span class="s1">padding: </span><span class="s3">\&quot;</span><span class="s1">2px 6px 4px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">relative</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; [name=close]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">position: </span><span class="s3">\&quot;</span><span class="s1">absolute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">top: </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">right: </span><span class="s3">\&quot;</span><span class="s1">4px</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">border: </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">font: </span><span class="s3">\&quot;</span><span class="s1">inherit</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">padding: 0,</span><span class="s3">\n            </span><span class="s1">margin: 0</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; input, &amp; button, &amp; label</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">margin: </span><span class="s3">\&quot;</span><span class="s1">.2em .6em .2em 0</span><span class="s3">\&quot;\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; input[type=checkbox]</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">marginRight: </span><span class="s3">\&quot;</span><span class="s1">.2em</span><span class="s3">\&quot;\n        </span><span class="s1">},</span><span class="s3">\n        \&quot;</span><span class="s1">&amp; label</span><span class="s3">\&quot;</span><span class="s1">: {</span><span class="s3">\n            </span><span class="s1">fontSize: </span><span class="s3">\&quot;</span><span class="s1">80%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">whiteSpace: </span><span class="s3">\&quot;</span><span class="s1">pre</span><span class="s3">\&quot;\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-searchMatch</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#ffff0054</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-searchMatch</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#00ffff8a</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;light .cm-searchMatch-selected</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#ff6a0054</span><span class="s3">\&quot; </span><span class="s1">},</span><span class="s3">\n    \&quot;</span><span class="s1">&amp;dark .cm-searchMatch-selected</span><span class="s3">\&quot;</span><span class="s1">: { backgroundColor: </span><span class="s3">\&quot;</span><span class="s1">#ff00ff8a</span><span class="s3">\&quot; </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const searchExtensions = [</span><span class="s3">\n    </span><span class="s1">searchState,</span><span class="s3">\n    </span><span class="s1">/*@__PURE__*/Prec.low(searchHighlighter),</span><span class="s3">\n    </span><span class="s1">baseTheme</span><span class="s3">\n</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">export { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>