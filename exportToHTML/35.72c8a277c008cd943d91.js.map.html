<html>
<head>
<title>35.72c8a277c008cd943d91.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
35.72c8a277c008cd943d91.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;35.72c8a277c008cd943d91.js?v=72c8a277c008cd943d91&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,IAAI;AACJ;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1CA;AACA;AACA;;AAEyC;AACA;AACR;AACA;AACW;AACV;AACV;;AAEjB;;AAEP;AACA,aAAa,QAAQ;AACrB,cAAc,QAAQ;AACtB,cAAc,QAAQ;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAA8D;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACO,wBAAwB,4BAAU;AACzC;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,qCAAqC,KAAK;AAC1C,kBAAkB,6BAAgB;AAClC,qFAAqF,qBAAqB;AAC1G;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK,EAAE,kBAAU;AACjB;AACA;AACA,KAAK;AACL,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mBAAmB,6BAAgB;AACnC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,WAAW,kCAAc;AACzB;AACA;AACA;AACA;AACA,6BAA6B,0CAA0C;AACvE;AACA,2BAA2B,yBAAyB;AACpD;;AAEA;AACA,aAAa,QAAQ;AACrB,aAAa,KAAK;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,eAAe;AAC1B,WAAW,KAAK;AAChB;AACO;AACP;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA,uBAAuB,6BAAgB;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,gCAAgC,iCAAiC;AACjE,gCAAgC,iCAAiC;AACjE;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,WAAW,mBAAmB;AAC9B,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,WAAW;AACtB,WAAW,YAAY;AACvB,WAAW,KAAK;AAChB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;ACtSA;AACA;AACA;AACA;AAC4C;AACD;AACO;AACzB;AACzB;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA,aAAa;AACb,iCAAiC,aAAa;AAC9C;AACA,4BAA4B,oBAAM;AAClC;AACA,6BAA6B,oBAAM;AACnC,gIAAgI,YAAK;AACrI;AACA,gCAAgC,oBAAa;AAC7C;AACA;AACA,SAAS;AACT,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtLA;AACA;AACA;AACA;AAC2C;AAC3C;AACA;AACA;AACO,oBAAoB,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AChGA;AACA;AACA;AACA;AACkD;AACP;AACO;AACzB;AACzB;AACA;AACA;AACO,yDAAyD;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,uBAAuB,YAAK;AAC5B,wBAAwB,aAAM;AAC9B,0BAA0B,YAAK;AAC/B;AACA;AACA;AACA,qEAAqE,cAAI;AACzE;AACA;AACA;AACA,yDAAyD,UAAU;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAO;AACxC;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAyC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAM;AAC1C;AACA;AACA;AACA;AACA,4BAA4B,oBAAM;AAClC,6BAA6B,oBAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAK;AACjC;AACA,kCAAkC,SAAS;AAC3C,oCAAoC,oBAAa;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oBAAa;AACjD;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,oBAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,kBAAkB,iBAAO;AACzB;AACA;AACA,mBAAmB,iBAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,uBAAuB;AAC3F;AACA;AACA;AACA;AACA,gBAAgB,iBAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,2GAA2G;AAC3G;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,0BAA0B,iBAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,iBAAO;AACxB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,iBAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gCAAgC;AAClD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iBAAO;AACtB;AACA;AACA;AACA,6BAA6B,iBAAO;AACpC;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA,oCAAoC,aAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACp3BA;AACA;AACA;AACA;AAC4C;AACD;AAClB;AACkB;AAC4B;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,wBAAwB,SAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,iBAAiB;AACjB,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,yCAAyC,gBAAgB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,6BAA6B,SAAS,gBAAgB;AACpF;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,uBAAuB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,oCAAoC,oBAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,6BAA6B,UAAU,gBAAgB;AACrG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,UAAU;AACnC;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,UAAU;AAC/G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D;AAC5D,kBAAkB,iBAAO;AACzB;AACA;AACA,mBAAmB,iBAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,UAAU,uBAAuB;AAC3F;AACA,gBAAgB,iBAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAO;AAC1C,8BAA8B,iBAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iBAAO;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAK;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;ACpgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACyB;AACE;AACI;AACJ;AACI;AACJ;AACI;AACkE;AACjG;;;;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;;AAE+B;;AAE/B;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,YAAY;AACZ;AACO,gCAAgC,UAAU;;AAEjD;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO,6BAA6B,UAAU;;AAE9C;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,UAAU;AACrB;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,0BAA0B;AACrC,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,cAAc,iBAAiB;AAC/B;AACA,WAAW,KAAK;AAChB,WAAW,qCAAqC;AAChD,YAAY;AACZ;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc;AAC5B,WAAW,KAAK;AAChB,WAAW,kCAAkC;AAC7C,YAAY;AACZ;AACO;AACP,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO,4CAA4C,aAAa;;AAEhE;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA,kBAAkB,SAAS;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,QAAQ;AACnB,WAAW,oCAAoC;AAC/C;AACO;;AAEA;;AAEP;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,gBAAgB;AAC9B,cAAc,uEAAuE;AACrF,WAAW,KAAK;AAChB,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;AACA,YAAY;AACZ;AACA;AACA,kBAAkB,gBAAgB;AAClC,+BAA+B,KAAK,2BAA2B,KAAK;AACpE;AACA,oBAAoB,KAAK;AACzB;;;;;;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;;AAEmC;AACE;;AAErC;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,YAAY;AACvB;AACO;AACP;AACA,WAAW,eAAe;AAC1B;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,GAAG;AACd,WAAW,GAAG;AACd,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,iBAAiB;AAC5B,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO,4JAA4J,UAAU;;AAE7K;;AAEA;AACA,WAAW,KAAK;AAChB,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,wDAAa,QAAQ,wDAAa;AAC5C;AACA;AACA;AACA,aAAa,6DAAkB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,GAAG;AACjB;AACA,WAAW,GAAG;AACd,WAAW,aAAa;AACxB;AACA;AACO;AACP;;AAEO,gBAAgB,wDAAa;;AAEpC;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,KAAK;AAChB,YAAY;AACZ;AACO;;AAEP;AACA,cAAc,oCAAoC;AAClD,WAAW,KAAK;AAChB,WAAW,MAAM;AACjB,YAAY;AACZ;AACO;;AAEP;AACA,cAAc,oCAAoC;AAClD,WAAW,MAAM;AACjB;AACO;AACP;AACA,aAAa,KAAK;AAClB,cAAc;AACd;AACA;;;;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACO;;AAEP;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,YAAY;AACZ;AACO;AACP;AACA,wBAAwB,aAAa;AACrC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,WAAW,KAAK;AAChB,WAAW,GAAG;AACd,WAAW,cAAc;AACzB,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,uBAAuB;AAClC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC/GA;AACA;AACA;AACA;AACA;;AAEO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;;AAEA;;AAEA;AACP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEA;;AAEP;AACA,WAAW,QAAQ;AACnB,YAAY,SAAS;AACrB;AACO;;;;;;;;;;;;;;;;;ACzDP;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,oBAAoB;AAChC;AACO;;AAEP;AACA;AACA;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B;AACO;;AAEP;AACA;AACA,YAAY,eAAe;AAC3B,WAAW,wBAAwB;AACnC;AACO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,oBAAoB;AAC/B,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kBAAkB;AAC7B;AACO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,oBAAoB;AAC/B,WAAW,8BAA8B;AACzC,YAAY;AACZ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,eAAe;AAC1B,YAAY;AACZ;AACO;;AAEP;AACA,WAAW,oBAAoB;AAC/B,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACO;;;;;;;;;;;;;;;AC3GP;AACA;AACA;AACA;AACA;;AAE+B;AACA;AACI;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uCAAuC;AACtD;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA,gCAAgC,KAAK;AACrC;AACA;AACA,6BAA6B,KAAK;AAClC;;AAEA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,cAAc;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,aAAa,MAAM;AACnB,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,cAAc;AACd;AACA,sBAAsB,qDAAU;AAChC;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA,IAAI,6DAAkB,wBAAwB,qDAAU;AACxD;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa,GAAG;AAChB,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,GAAG;AAChB,aAAa,YAAY;AACzB;AACA;AACA;AACA,WAAW,qDAAU,+BAA+B,qDAAU;AAC9D;;AAEA;AACA,sBAAsB,qDAAU;AAChC;AACA;AACA;;;;;;;;;;;;AChKA;AACA;AACA;AACA;AACA;;AAEO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;;AAEP;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACO;AACP;;AAEA;AACA;AACA,WAAW,aAAa;AACxB,YAAY;AACZ;AACO;;;;;;;;;;;;AC5BP;AACA;AACA;AACA;AACA;;AAEqC;AACJ;;AAEjC;AACA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,YAAY;AACZ;AACO;;AAEP;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY,QAAQ;AACpB;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/utils.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/y-protocols/awareness.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/ydocument.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/yfile.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/ycell.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/ynotebook.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyter/ydoc/lib/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/array.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/function.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/map.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/math.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/object.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/observable.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/set.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/lib0/time.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">export function convertYMapEventToMapChange(event) {</span><span class="s3">\n    </span><span class="s1">let changes = new Map();</span><span class="s3">\n    </span><span class="s1">event.changes.keys.forEach((event, key) =&gt; {</span><span class="s3">\n        </span><span class="s1">changes.set(key, {</span><span class="s3">\n            </span><span class="s1">action: event.action,</span><span class="s3">\n            </span><span class="s1">oldValue: event.oldValue,</span><span class="s3">\n            </span><span class="s1">newValue: this.ymeta.get(key)</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return changes;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a mutual exclude function with the following property:</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* const mutex = createMutex()</span><span class="s3">\n </span><span class="s1">* mutex(() =&gt; {</span><span class="s3">\n </span><span class="s1">*   // This function is immediately executed</span><span class="s3">\n </span><span class="s1">*   mutex(() =&gt; {</span><span class="s3">\n </span><span class="s1">*     // This function is not executed, as the mutex is already active.</span><span class="s3">\n </span><span class="s1">*   })</span><span class="s3">\n </span><span class="s1">* })</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createMutex = () =&gt; {</span><span class="s3">\n    </span><span class="s1">let token = true;</span><span class="s3">\n    </span><span class="s1">return (f) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (token) {</span><span class="s3">\n            </span><span class="s1">token = false;</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">f();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">finally {</span><span class="s3">\n                </span><span class="s1">token = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=utils.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* @module awareness-protocol</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as encoding from 'lib0/encoding'</span><span class="s3">\n</span><span class="s1">import * as decoding from 'lib0/decoding'</span><span class="s3">\n</span><span class="s1">import * as time from 'lib0/time'</span><span class="s3">\n</span><span class="s1">import * as math from 'lib0/math'</span><span class="s3">\n</span><span class="s1">import { Observable } from 'lib0/observable'</span><span class="s3">\n</span><span class="s1">import * as f from 'lib0/function'</span><span class="s3">\n</span><span class="s1">import * as Y from 'yjs' // eslint-disable-line</span><span class="s3">\n\n</span><span class="s1">export const outdatedTimeout = 30000</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @typedef {Object} MetaClientState</span><span class="s3">\n </span><span class="s1">* @property {number} MetaClientState.clock</span><span class="s3">\n </span><span class="s1">* @property {number} MetaClientState.lastUpdated unix timestamp</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* The Awareness class implements a simple shared state protocol that can be used for non-persistent data like awareness information</span><span class="s3">\n </span><span class="s1">* (cursor, username, status, ..). Each client can update its own local state and listen to state changes of</span><span class="s3">\n </span><span class="s1">* remote clients. Every client may set a state of a remote peer to `null` to mark the client as offline.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Each client is identified by a unique client id (something we borrow from `doc.clientID`). A client can override</span><span class="s3">\n </span><span class="s1">* its own state by propagating a message with an increasing timestamp (`clock`). If such a message is received, it is</span><span class="s3">\n </span><span class="s1">* applied if the known state of that client is older than the new state (`clock &lt; newClock`). If a client thinks that</span><span class="s3">\n </span><span class="s1">* a remote client is offline, it may propagate a message with</span><span class="s3">\n </span><span class="s1">* `{ clock: currentClientClock, state: null, client: remoteClient }`. If such a</span><span class="s3">\n </span><span class="s1">* message is received, and the known clock of that client equals the received clock, it will override the state with `null`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Before a client disconnects, it should propagate a `null` state with an updated clock.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Awareness states must be updated every 30 seconds. Otherwise the Awareness instance will delete the client state.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @extends {Observable&lt;string&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Awareness extends Observable {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Y.Doc} doc</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor (doc) {</span><span class="s3">\n    </span><span class="s1">super()</span><span class="s3">\n    </span><span class="s1">this.doc = doc</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {number}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.clientID = doc.clientID</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Maps from client id to client state</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number, Object&lt;string, any&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.states = new Map()</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;number, MetaClientState&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this.meta = new Map()</span><span class="s3">\n    </span><span class="s1">this._checkInterval = /** @type {any} */ (setInterval(() =&gt; {</span><span class="s3">\n      </span><span class="s1">const now = time.getUnixTime()</span><span class="s3">\n      </span><span class="s1">if (this.getLocalState() !== null &amp;&amp; (outdatedTimeout / 2 &lt;= now - /** @type {{lastUpdated:number}} */ (this.meta.get(this.clientID)).lastUpdated)) {</span><span class="s3">\n        </span><span class="s1">// renew local clock</span><span class="s3">\n        </span><span class="s1">this.setLocalState(this.getLocalState())</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">/**</span><span class="s3">\n       </span><span class="s1">* @type {Array&lt;number&gt;}</span><span class="s3">\n       </span><span class="s1">*/</span><span class="s3">\n      </span><span class="s1">const remove = []</span><span class="s3">\n      </span><span class="s1">this.meta.forEach((meta, clientid) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (clientid !== this.clientID &amp;&amp; outdatedTimeout &lt;= now - meta.lastUpdated &amp;&amp; this.states.has(clientid)) {</span><span class="s3">\n          </span><span class="s1">remove.push(clientid)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">if (remove.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">removeAwarenessStates(this, remove, 'timeout')</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, math.floor(outdatedTimeout / 10)))</span><span class="s3">\n    </span><span class="s1">doc.on('destroy', () =&gt; {</span><span class="s3">\n      </span><span class="s1">this.destroy()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">this.setLocalState({})</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this.emit('destroy', [this])</span><span class="s3">\n    </span><span class="s1">this.setLocalState(null)</span><span class="s3">\n    </span><span class="s1">super.destroy()</span><span class="s3">\n    </span><span class="s1">clearInterval(this._checkInterval)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Object&lt;string,any&gt;|null}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getLocalState () {</span><span class="s3">\n    </span><span class="s1">return this.states.get(this.clientID) || null</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {Object&lt;string,any&gt;|null} state</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setLocalState (state) {</span><span class="s3">\n    </span><span class="s1">const clientID = this.clientID</span><span class="s3">\n    </span><span class="s1">const currLocalMeta = this.meta.get(clientID)</span><span class="s3">\n    </span><span class="s1">const clock = currLocalMeta === undefined ? 0 : currLocalMeta.clock + 1</span><span class="s3">\n    </span><span class="s1">const prevState = this.states.get(clientID)</span><span class="s3">\n    </span><span class="s1">if (state === null) {</span><span class="s3">\n      </span><span class="s1">this.states.delete(clientID)</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.states.set(clientID, state)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.meta.set(clientID, {</span><span class="s3">\n      </span><span class="s1">clock,</span><span class="s3">\n      </span><span class="s1">lastUpdated: time.getUnixTime()</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">const added = []</span><span class="s3">\n    </span><span class="s1">const updated = []</span><span class="s3">\n    </span><span class="s1">const filteredUpdated = []</span><span class="s3">\n    </span><span class="s1">const removed = []</span><span class="s3">\n    </span><span class="s1">if (state === null) {</span><span class="s3">\n      </span><span class="s1">removed.push(clientID)</span><span class="s3">\n    </span><span class="s1">} else if (prevState == null) {</span><span class="s3">\n      </span><span class="s1">if (state != null) {</span><span class="s3">\n        </span><span class="s1">added.push(clientID)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">updated.push(clientID)</span><span class="s3">\n      </span><span class="s1">if (!f.equalityDeep(prevState, state)) {</span><span class="s3">\n        </span><span class="s1">filteredUpdated.push(clientID)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (added.length &gt; 0 || filteredUpdated.length &gt; 0 || removed.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.emit('change', [{ added, updated: filteredUpdated, removed }, 'local'])</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.emit('update', [{ added, updated, removed }, 'local'])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {string} field</span><span class="s3">\n   </span><span class="s1">* @param {any} value</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">setLocalStateField (field, value) {</span><span class="s3">\n    </span><span class="s1">const state = this.getLocalState()</span><span class="s3">\n    </span><span class="s1">if (state !== null) {</span><span class="s3">\n      </span><span class="s1">this.setLocalState({</span><span class="s3">\n        </span><span class="s1">...state,</span><span class="s3">\n        </span><span class="s1">[field]: value</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @return {Map&lt;number,Object&lt;string,any&gt;&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">getStates () {</span><span class="s3">\n    </span><span class="s1">return this.states</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Mark (remote) clients as inactive and remove them from the list of active peers.</span><span class="s3">\n </span><span class="s1">* This change will be propagated to remote clients.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Awareness} awareness</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;number&gt;} clients</span><span class="s3">\n </span><span class="s1">* @param {any} origin</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const removeAwarenessStates = (awareness, clients, origin) =&gt; {</span><span class="s3">\n  </span><span class="s1">const removed = []</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; clients.length; i++) {</span><span class="s3">\n    </span><span class="s1">const clientID = clients[i]</span><span class="s3">\n    </span><span class="s1">if (awareness.states.has(clientID)) {</span><span class="s3">\n      </span><span class="s1">awareness.states.delete(clientID)</span><span class="s3">\n      </span><span class="s1">if (clientID === awareness.clientID) {</span><span class="s3">\n        </span><span class="s1">const curMeta = /** @type {MetaClientState} */ (awareness.meta.get(clientID))</span><span class="s3">\n        </span><span class="s1">awareness.meta.set(clientID, {</span><span class="s3">\n          </span><span class="s1">clock: curMeta.clock + 1,</span><span class="s3">\n          </span><span class="s1">lastUpdated: time.getUnixTime()</span><span class="s3">\n        </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">removed.push(clientID)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (removed.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">awareness.emit('change', [{ added: [], updated: [], removed }, origin])</span><span class="s3">\n    </span><span class="s1">awareness.emit('update', [{ added: [], updated: [], removed }, origin])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Awareness} awareness</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;number&gt;} clients</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const encodeAwarenessUpdate = (awareness, clients, states = awareness.states) =&gt; {</span><span class="s3">\n  </span><span class="s1">const len = clients.length</span><span class="s3">\n  </span><span class="s1">const encoder = encoding.createEncoder()</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder, len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">const clientID = clients[i]</span><span class="s3">\n    </span><span class="s1">const state = states.get(clientID) || null</span><span class="s3">\n    </span><span class="s1">const clock = /** @type {MetaClientState} */ (awareness.meta.get(clientID)).clock</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, clientID)</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, clock)</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(encoder, JSON.stringify(state))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Modify the content of an awareness update before re-encoding it to an awareness update.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This might be useful when you have a central server that wants to ensure that clients</span><span class="s3">\n </span><span class="s1">* cant hijack somebody elses identity.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {function(any):any} modify</span><span class="s3">\n </span><span class="s1">* @return {Uint8Array}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const modifyAwarenessUpdate = (update, modify) =&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = decoding.createDecoder(update)</span><span class="s3">\n  </span><span class="s1">const encoder = encoding.createEncoder()</span><span class="s3">\n  </span><span class="s1">const len = decoding.readVarUint(decoder)</span><span class="s3">\n  </span><span class="s1">encoding.writeVarUint(encoder, len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">const clientID = decoding.readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">const clock = decoding.readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decoding.readVarString(decoder))</span><span class="s3">\n    </span><span class="s1">const modifiedState = modify(state)</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, clientID)</span><span class="s3">\n    </span><span class="s1">encoding.writeVarUint(encoder, clock)</span><span class="s3">\n    </span><span class="s1">encoding.writeVarString(encoder, JSON.stringify(modifiedState))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return encoding.toUint8Array(encoder)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Awareness} awareness</span><span class="s3">\n </span><span class="s1">* @param {Uint8Array} update</span><span class="s3">\n </span><span class="s1">* @param {any} origin This will be added to the emitted change event</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const applyAwarenessUpdate = (awareness, update, origin) =&gt; {</span><span class="s3">\n  </span><span class="s1">const decoder = decoding.createDecoder(update)</span><span class="s3">\n  </span><span class="s1">const timestamp = time.getUnixTime()</span><span class="s3">\n  </span><span class="s1">const added = []</span><span class="s3">\n  </span><span class="s1">const updated = []</span><span class="s3">\n  </span><span class="s1">const filteredUpdated = []</span><span class="s3">\n  </span><span class="s1">const removed = []</span><span class="s3">\n  </span><span class="s1">const len = decoding.readVarUint(decoder)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">const clientID = decoding.readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">let clock = decoding.readVarUint(decoder)</span><span class="s3">\n    </span><span class="s1">const state = JSON.parse(decoding.readVarString(decoder))</span><span class="s3">\n    </span><span class="s1">const clientMeta = awareness.meta.get(clientID)</span><span class="s3">\n    </span><span class="s1">const prevState = awareness.states.get(clientID)</span><span class="s3">\n    </span><span class="s1">const currClock = clientMeta === undefined ? 0 : clientMeta.clock</span><span class="s3">\n    </span><span class="s1">if (currClock &lt; clock || (currClock === clock &amp;&amp; state === null &amp;&amp; awareness.states.has(clientID))) {</span><span class="s3">\n      </span><span class="s1">if (state === null) {</span><span class="s3">\n        </span><span class="s1">// never let a remote client remove this local state</span><span class="s3">\n        </span><span class="s1">if (clientID === awareness.clientID &amp;&amp; awareness.getLocalState() != null) {</span><span class="s3">\n          </span><span class="s1">// remote client removed the local state. Do not remote state. Broadcast a message indicating</span><span class="s3">\n          </span><span class="s1">// that this client still exists by increasing the clock</span><span class="s3">\n          </span><span class="s1">clock++</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">awareness.states.delete(clientID)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">awareness.states.set(clientID, state)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">awareness.meta.set(clientID, {</span><span class="s3">\n        </span><span class="s1">clock,</span><span class="s3">\n        </span><span class="s1">lastUpdated: timestamp</span><span class="s3">\n      </span><span class="s1">})</span><span class="s3">\n      </span><span class="s1">if (clientMeta === undefined &amp;&amp; state !== null) {</span><span class="s3">\n        </span><span class="s1">added.push(clientID)</span><span class="s3">\n      </span><span class="s1">} else if (clientMeta !== undefined &amp;&amp; state === null) {</span><span class="s3">\n        </span><span class="s1">removed.push(clientID)</span><span class="s3">\n      </span><span class="s1">} else if (state !== null) {</span><span class="s3">\n        </span><span class="s1">if (!f.equalityDeep(state, prevState)) {</span><span class="s3">\n          </span><span class="s1">filteredUpdated.push(clientID)</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">updated.push(clientID)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (added.length &gt; 0 || filteredUpdated.length &gt; 0 || removed.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">awareness.emit('change', [{</span><span class="s3">\n      </span><span class="s1">added, updated: filteredUpdated, removed</span><span class="s3">\n    </span><span class="s1">}, origin])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (added.length &gt; 0 || updated.length &gt; 0 || removed.length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">awareness.emit('update', [{</span><span class="s3">\n      </span><span class="s1">added, updated, removed</span><span class="s3">\n    </span><span class="s1">}, origin])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">import { JSONExt } from '@lumino/coreutils';</span><span class="s3">\n</span><span class="s1">import { Signal } from '@lumino/signaling';</span><span class="s3">\n</span><span class="s1">import { Awareness } from 'y-protocols/awareness';</span><span class="s3">\n</span><span class="s1">import * as Y from 'yjs';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Generic shareable document.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YDocument {</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle a change to the ystate.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.onStateChanged = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">const stateChange = new Array();</span><span class="s3">\n            </span><span class="s1">event.keysChanged.forEach(key =&gt; {</span><span class="s3">\n                </span><span class="s1">const change = event.changes.keys.get(key);</span><span class="s3">\n                </span><span class="s1">if (change) {</span><span class="s3">\n                    </span><span class="s1">stateChange.push({</span><span class="s3">\n                        </span><span class="s1">name: key,</span><span class="s3">\n                        </span><span class="s1">oldValue: change.oldValue,</span><span class="s3">\n                        </span><span class="s1">newValue: this.ystate.get(key)</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this._changed.emit({ stateChange });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this._changed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._isDisposed = false;</span><span class="s3">\n        </span><span class="s1">this._disposed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._ydoc = (_a = options === null || options === void 0 ? void 0 : options.ydoc) !== null &amp;&amp; _a !== void 0 ? _a : new Y.Doc();</span><span class="s3">\n        </span><span class="s1">this._ystate = this._ydoc.getMap('state');</span><span class="s3">\n        </span><span class="s1">this._undoManager = new Y.UndoManager([], {</span><span class="s3">\n            </span><span class="s1">trackedOrigins: new Set([this]),</span><span class="s3">\n            </span><span class="s1">doc: this._ydoc</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this._awareness = new Awareness(this._ydoc);</span><span class="s3">\n        </span><span class="s1">this._ystate.observe(this.onStateChanged);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* YJS document.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get ydoc() {</span><span class="s3">\n        </span><span class="s1">return this._ydoc;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Shared state</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get ystate() {</span><span class="s3">\n        </span><span class="s1">return this._ystate;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* YJS document undo manager</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get undoManager() {</span><span class="s3">\n        </span><span class="s1">return this._undoManager;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Shared awareness</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get awareness() {</span><span class="s3">\n        </span><span class="s1">return this._awareness;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The changed signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get changed() {</span><span class="s3">\n        </span><span class="s1">return this._changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* A signal emitted when the document is disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get disposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the document is disposed or not.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._isDisposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Document state</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get state() {</span><span class="s3">\n        </span><span class="s1">return JSONExt.deepCopy(this.ystate.toJSON());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the object can undo changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canUndo() {</span><span class="s3">\n        </span><span class="s1">return this.undoManager.undoStack.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the object can redo changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canRedo() {</span><span class="s3">\n        </span><span class="s1">return this.undoManager.redoStack.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this._isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._isDisposed = true;</span><span class="s3">\n        </span><span class="s1">this.ystate.unobserve(this.onStateChanged);</span><span class="s3">\n        </span><span class="s1">this.awareness.destroy();</span><span class="s3">\n        </span><span class="s1">this.undoManager.destroy();</span><span class="s3">\n        </span><span class="s1">this.ydoc.destroy();</span><span class="s3">\n        </span><span class="s1">this._disposed.emit();</span><span class="s3">\n        </span><span class="s1">Signal.clearData(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the value for a state attribute</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param key Key to get</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getState(key) {</span><span class="s3">\n        </span><span class="s1">const value = this.ystate.get(key);</span><span class="s3">\n        </span><span class="s1">return typeof value === 'undefined'</span><span class="s3">\n            </span><span class="s1">? value</span><span class="s3">\n            </span><span class="s1">: JSONExt.deepCopy(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the value of a state attribute</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param key Key to set</span><span class="s3">\n     </span><span class="s1">* @param value New attribute value</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setState(key, value) {</span><span class="s3">\n        </span><span class="s1">if (!JSONExt.deepEqual(this.ystate.get(key), value)) {</span><span class="s3">\n            </span><span class="s1">this.ystate.set(key, value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the document source</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The source</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get source() {</span><span class="s3">\n        </span><span class="s1">return this.getSource();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the document source</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value The source to set</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">set source(value) {</span><span class="s3">\n        </span><span class="s1">this.setSource(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Undo an operation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">undo() {</span><span class="s3">\n        </span><span class="s1">this.undoManager.undo();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Redo an operation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">redo() {</span><span class="s3">\n        </span><span class="s1">this.undoManager.redo();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clear the change stack.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clearUndoHistory() {</span><span class="s3">\n        </span><span class="s1">this.undoManager.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Perform a transaction. While the function f is called, all changes to the shared</span><span class="s3">\n     </span><span class="s1">* document are bundled into a single event.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">transact(f, undoable = true, origin = null) {</span><span class="s3">\n        </span><span class="s1">this.ydoc.transact(f, undoable ? this : origin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ydocument.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">import { YDocument } from './ydocument.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shareable text file.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YFile extends YDocument {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new file</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* The document is empty and must be populated</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Document version</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.version = '1.0.0';</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* YJS file text.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.ysource = this.ydoc.getText('source');</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle a change to the ymodel.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._modelObserver = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">this._changed.emit({ sourceChange: event.changes.delta });</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.undoManager.addToScope(this.ysource);</span><span class="s3">\n        </span><span class="s1">this.ysource.observe(this._modelObserver);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a standalone YFile</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create() {</span><span class="s3">\n        </span><span class="s1">return new YFile();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* File text</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get source() {</span><span class="s3">\n        </span><span class="s1">return this.getSource();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set source(v) {</span><span class="s3">\n        </span><span class="s1">this.setSource(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.ysource.unobserve(this._modelObserver);</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the file text.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns File text.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getSource() {</span><span class="s3">\n        </span><span class="s1">return this.ysource.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the file text.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value New text</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setSource(value) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const ytext = this.ysource;</span><span class="s3">\n            </span><span class="s1">ytext.delete(0, ytext.length);</span><span class="s3">\n            </span><span class="s1">ytext.insert(0, value);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replace content from `start' to `end` with `value`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param start: The start index of the range to replace (inclusive).</span><span class="s3">\n     </span><span class="s1">* @param end: The end index of the range to replace (exclusive).</span><span class="s3">\n     </span><span class="s1">* @param value: New source (optional).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateSource(start, end, value = '') {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const ysource = this.ysource;</span><span class="s3">\n            </span><span class="s1">// insert and then delete.</span><span class="s3">\n            </span><span class="s1">// This ensures that the cursor position is adjusted after the replaced content.</span><span class="s3">\n            </span><span class="s1">ysource.insert(start, value);</span><span class="s3">\n            </span><span class="s1">ysource.delete(start + value.length, end - start);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=yfile.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">import { JSONExt, UUID } from '@lumino/coreutils';</span><span class="s3">\n</span><span class="s1">import { Signal } from '@lumino/signaling';</span><span class="s3">\n</span><span class="s1">import { Awareness } from 'y-protocols/awareness';</span><span class="s3">\n</span><span class="s1">import * as Y from 'yjs';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a new shared cell model given the YJS shared type.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createCellModelFromSharedType = (type, options = {}) =&gt; {</span><span class="s3">\n    </span><span class="s1">switch (type.get('cell_type')) {</span><span class="s3">\n        </span><span class="s1">case 'code':</span><span class="s3">\n            </span><span class="s1">return new YCodeCell(type, type.get('source'), type.get('outputs'), options);</span><span class="s3">\n        </span><span class="s1">case 'markdown':</span><span class="s3">\n            </span><span class="s1">return new YMarkdownCell(type, type.get('source'), options);</span><span class="s3">\n        </span><span class="s1">case 'raw':</span><span class="s3">\n            </span><span class="s1">return new YRawCell(type, type.get('source'), options);</span><span class="s3">\n        </span><span class="s1">default:</span><span class="s3">\n            </span><span class="s1">throw new Error('Found unknown cell type');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a new cell that can be inserted in an existing shared model.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* If no notebook is specified the cell will be standalone.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cell Cell JSON representation</span><span class="s3">\n </span><span class="s1">* @param notebook Notebook to which the cell will be added</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createCell = (cell, notebook) =&gt; {</span><span class="s3">\n    </span><span class="s1">var _a, _b;</span><span class="s3">\n    </span><span class="s1">const ymodel = new Y.Map();</span><span class="s3">\n    </span><span class="s1">const ysource = new Y.Text();</span><span class="s3">\n    </span><span class="s1">const ymetadata = new Y.Map();</span><span class="s3">\n    </span><span class="s1">ymodel.set('source', ysource);</span><span class="s3">\n    </span><span class="s1">ymodel.set('metadata', ymetadata);</span><span class="s3">\n    </span><span class="s1">ymodel.set('cell_type', cell.cell_type);</span><span class="s3">\n    </span><span class="s1">ymodel.set('id', (_a = cell.id) !== null &amp;&amp; _a !== void 0 ? _a : UUID.uuid4());</span><span class="s3">\n    </span><span class="s1">let ycell;</span><span class="s3">\n    </span><span class="s1">switch (cell.cell_type) {</span><span class="s3">\n        </span><span class="s1">case 'markdown': {</span><span class="s3">\n            </span><span class="s1">ycell = new YMarkdownCell(ymodel, ysource, { notebook }, ymetadata);</span><span class="s3">\n            </span><span class="s1">if (cell.attachments != null) {</span><span class="s3">\n                </span><span class="s1">ycell.setAttachments(cell.attachments);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">case 'code': {</span><span class="s3">\n            </span><span class="s1">const youtputs = new Y.Array();</span><span class="s3">\n            </span><span class="s1">ymodel.set('outputs', youtputs);</span><span class="s3">\n            </span><span class="s1">ycell = new YCodeCell(ymodel, ysource, youtputs, {</span><span class="s3">\n                </span><span class="s1">notebook</span><span class="s3">\n            </span><span class="s1">}, ymetadata);</span><span class="s3">\n            </span><span class="s1">const cCell = cell;</span><span class="s3">\n            </span><span class="s1">ycell.execution_count = (_b = cCell.execution_count) !== null &amp;&amp; _b !== void 0 ? _b : null;</span><span class="s3">\n            </span><span class="s1">if (cCell.outputs) {</span><span class="s3">\n                </span><span class="s1">ycell.setOutputs(cCell.outputs);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">default: {</span><span class="s3">\n            </span><span class="s1">// raw</span><span class="s3">\n            </span><span class="s1">ycell = new YRawCell(ymodel, ysource, { notebook }, ymetadata);</span><span class="s3">\n            </span><span class="s1">if (cell.attachments) {</span><span class="s3">\n                </span><span class="s1">ycell.setAttachments(cell.attachments);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cell.metadata != null) {</span><span class="s3">\n        </span><span class="s1">ycell.setMetadata(cell.metadata);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cell.source != null) {</span><span class="s3">\n        </span><span class="s1">ycell.setSource(typeof cell.source === 'string' ? cell.source : cell.source.join(''));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ycell;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Create a new cell that cannot be inserted in an existing shared model.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param cell Cell JSON representation</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const createStandaloneCell = (cell) =&gt; createCell(cell);</span><span class="s3">\n</span><span class="s1">export class YBaseCell {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new YCell that works standalone. It cannot be</span><span class="s3">\n     </span><span class="s1">* inserted into a YNotebook because the Yjs model is already</span><span class="s3">\n     </span><span class="s1">* attached to an anonymous Y.Doc instance.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(id) {</span><span class="s3">\n        </span><span class="s1">return createCell({ id, cell_type: this.prototype.cell_type });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Base cell constructor</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* ### Notes</span><span class="s3">\n     </span><span class="s1">* Don't use the constructor directly - prefer using ``YNotebook.insertCell``</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The ``ysource`` is needed because ``ymodel.get('source')`` will</span><span class="s3">\n     </span><span class="s1">* not return the real source if the model is not yet attached to</span><span class="s3">\n     </span><span class="s1">* a document. Requesting it explicitly allows to introspect a non-empty</span><span class="s3">\n     </span><span class="s1">* source before the cell is attached to the document.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param ymodel Cell map</span><span class="s3">\n     </span><span class="s1">* @param ysource Cell source</span><span class="s3">\n     </span><span class="s1">* @param options </span><span class="s3">\\</span><span class="s1">{ notebook?: The notebook the cell is attached to </span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\n     </span><span class="s1">* @param ymetadata Cell metadata</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(ymodel, ysource, options = {}, ymetadata) {</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle a change to the ymodel.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._modelObserver = (events, transaction) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (transaction.origin !== 'silent-change') {</span><span class="s3">\n                </span><span class="s1">this._changed.emit(this.getChanges(events));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this._metadataChanged = new Signal(this);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* The notebook that this cell belongs to.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._notebook = null;</span><span class="s3">\n        </span><span class="s1">this._changed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._disposed = new Signal(this);</span><span class="s3">\n        </span><span class="s1">this._isDisposed = false;</span><span class="s3">\n        </span><span class="s1">this._undoManager = null;</span><span class="s3">\n        </span><span class="s1">this.ymodel = ymodel;</span><span class="s3">\n        </span><span class="s1">this._ysource = ysource;</span><span class="s3">\n        </span><span class="s1">this._ymetadata = ymetadata !== null &amp;&amp; ymetadata !== void 0 ? ymetadata : this.ymodel.get('metadata');</span><span class="s3">\n        </span><span class="s1">this._prevSourceLength = ysource ? ysource.length : 0;</span><span class="s3">\n        </span><span class="s1">this._notebook = null;</span><span class="s3">\n        </span><span class="s1">this._awareness = null;</span><span class="s3">\n        </span><span class="s1">this._undoManager = null;</span><span class="s3">\n        </span><span class="s1">if (options.notebook) {</span><span class="s3">\n            </span><span class="s1">this._notebook = options.notebook;</span><span class="s3">\n            </span><span class="s1">// We cannot create a undo manager with the cell not yet attached in the notebook</span><span class="s3">\n            </span><span class="s1">// so we defer that to the notebook insertCell method</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// Standalone cell</span><span class="s3">\n            </span><span class="s1">const doc = new Y.Doc();</span><span class="s3">\n            </span><span class="s1">doc.getArray().insert(0, [this.ymodel]);</span><span class="s3">\n            </span><span class="s1">this._awareness = new Awareness(doc);</span><span class="s3">\n            </span><span class="s1">this._undoManager = new Y.UndoManager([this.ymodel], {</span><span class="s3">\n                </span><span class="s1">trackedOrigins: new Set([this])</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.ymodel.observeDeep(this._modelObserver);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell notebook awareness or null if the cell is standalone.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get awareness() {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c;</span><span class="s3">\n        </span><span class="s1">return (_c = (_a = this._awareness) !== null &amp;&amp; _a !== void 0 ? _a : (_b = this.notebook) === null || _b === void 0 ? void 0 : _b.awareness) !== null &amp;&amp; _c !== void 0 ? _c : null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The type of the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cell_type() {</span><span class="s3">\n        </span><span class="s1">throw new Error('A YBaseCell must not be constructed');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The changed signal.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get changed() {</span><span class="s3">\n        </span><span class="s1">return this._changed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Signal emitted when the cell is disposed.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get disposed() {</span><span class="s3">\n        </span><span class="s1">return this._disposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell id</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get id() {</span><span class="s3">\n        </span><span class="s1">return this.getId();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the model has been disposed or not.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isDisposed() {</span><span class="s3">\n        </span><span class="s1">return this._isDisposed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the cell is standalone or not.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* If the cell is standalone. It cannot be</span><span class="s3">\n     </span><span class="s1">* inserted into a YNotebook because the Yjs model is already</span><span class="s3">\n     </span><span class="s1">* attached to an anonymous Y.Doc instance.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isStandalone() {</span><span class="s3">\n        </span><span class="s1">return this._notebook !== null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell metadata.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* You should prefer to access and modify the specific key of interest.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get metadata() {</span><span class="s3">\n        </span><span class="s1">return this.getMetadata();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set metadata(v) {</span><span class="s3">\n        </span><span class="s1">this.setMetadata(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Signal triggered when the cell metadata changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get metadataChanged() {</span><span class="s3">\n        </span><span class="s1">return this._metadataChanged;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The notebook that this cell belongs to.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get notebook() {</span><span class="s3">\n        </span><span class="s1">return this._notebook;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell input content.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get source() {</span><span class="s3">\n        </span><span class="s1">return this.getSource();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set source(v) {</span><span class="s3">\n        </span><span class="s1">this.setSource(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The cell undo manager.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get undoManager() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (!this.notebook) {</span><span class="s3">\n            </span><span class="s1">return this._undoManager;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.disableDocumentWideUndoRedo)</span><span class="s3">\n            </span><span class="s1">? this._undoManager</span><span class="s3">\n            </span><span class="s1">: this.notebook.undoManager;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Defer setting the undo manager as it requires the</span><span class="s3">\n     </span><span class="s1">* cell to be attached to the notebook Y document.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setUndoManager() {</span><span class="s3">\n        </span><span class="s1">if (this._undoManager) {</span><span class="s3">\n            </span><span class="s1">throw new Error('The cell undo manager is already set.');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._notebook &amp;&amp; this._notebook.disableDocumentWideUndoRedo) {</span><span class="s3">\n            </span><span class="s1">this._undoManager = new Y.UndoManager([this.ymodel], {</span><span class="s3">\n                </span><span class="s1">trackedOrigins: new Set([this])</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get ysource() {</span><span class="s3">\n        </span><span class="s1">return this._ysource;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the object can undo changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canUndo() {</span><span class="s3">\n        </span><span class="s1">return !!this.undoManager &amp;&amp; this.undoManager.undoStack.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Whether the object can redo changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">canRedo() {</span><span class="s3">\n        </span><span class="s1">return !!this.undoManager &amp;&amp; this.undoManager.redoStack.length &gt; 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Clear the change stack.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">clearUndoHistory() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">(_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.clear();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Undo an operation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">undo() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">(_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.undo();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Redo an operation.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">redo() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">(_a = this.undoManager) === null || _a === void 0 ? void 0 : _a.redo();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (this._isDisposed)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">this._isDisposed = true;</span><span class="s3">\n        </span><span class="s1">this.ymodel.unobserveDeep(this._modelObserver);</span><span class="s3">\n        </span><span class="s1">if (this._awareness) {</span><span class="s3">\n            </span><span class="s1">// A new document is created for standalone cell.</span><span class="s3">\n            </span><span class="s1">const doc = this._awareness.doc;</span><span class="s3">\n            </span><span class="s1">this._awareness.destroy();</span><span class="s3">\n            </span><span class="s1">doc.destroy();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this._undoManager) {</span><span class="s3">\n            </span><span class="s1">// Be sure to not destroy the document undo manager.</span><span class="s3">\n            </span><span class="s1">if (this._undoManager === ((_a = this.notebook) === null || _a === void 0 ? void 0 : _a.undoManager)) {</span><span class="s3">\n                </span><span class="s1">this._undoManager = null;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this._undoManager.destroy();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._disposed.emit();</span><span class="s3">\n        </span><span class="s1">Signal.clearData(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get cell id.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Cell id</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getId() {</span><span class="s3">\n        </span><span class="s1">return this.ymodel.get('id');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Gets cell's source.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns Cell's source.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getSource() {</span><span class="s3">\n        </span><span class="s1">return this.ysource.toString();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Sets cell's source.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value: New source.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setSource(value) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.ysource.delete(0, this.ysource.length);</span><span class="s3">\n            </span><span class="s1">this.ysource.insert(0, value);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">// @todo Do we need proper replace semantic? This leads to issues in editor bindings because they don't switch source.</span><span class="s3">\n        </span><span class="s1">// this.ymodel.set('source', new Y.Text(value));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replace content from `start' to `end` with `value`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param start: The start index of the range to replace (inclusive).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param end: The end index of the range to replace (exclusive).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value: New source (optional).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateSource(start, end, value = '') {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const ysource = this.ysource;</span><span class="s3">\n            </span><span class="s1">// insert and then delete.</span><span class="s3">\n            </span><span class="s1">// This ensures that the cursor position is adjusted after the replaced content.</span><span class="s3">\n            </span><span class="s1">ysource.insert(start, value);</span><span class="s3">\n            </span><span class="s1">ysource.delete(start + value.length, end - start);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Delete a metadata cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param key The key to delete</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">deleteMetadata(key) {</span><span class="s3">\n        </span><span class="s1">if (typeof this.getMetadata(key) === 'undefined') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._ymetadata.delete(key);</span><span class="s3">\n            </span><span class="s1">const jupyter = this.getMetadata('jupyter');</span><span class="s3">\n            </span><span class="s1">if (key === 'collapsed' &amp;&amp; jupyter) {</span><span class="s3">\n                </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-unused-vars</span><span class="s3">\n                </span><span class="s1">const { outputs_hidden, ...others } = jupyter;</span><span class="s3">\n                </span><span class="s1">if (Object.keys(others).length === 0) {</span><span class="s3">\n                    </span><span class="s1">this._ymetadata.delete('jupyter');</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">this._ymetadata.set('jupyter', others);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (key === 'jupyter') {</span><span class="s3">\n                </span><span class="s1">this._ymetadata.delete('collapsed');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getMetadata(key) {</span><span class="s3">\n        </span><span class="s1">const metadata = this._ymetadata;</span><span class="s3">\n        </span><span class="s1">// Transiently the metadata can be missing - like during destruction</span><span class="s3">\n        </span><span class="s1">if (metadata === undefined) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof key === 'string') {</span><span class="s3">\n            </span><span class="s1">const value = metadata.get(key);</span><span class="s3">\n            </span><span class="s1">return typeof value === 'undefined'</span><span class="s3">\n                </span><span class="s1">? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`</span><span class="s3">\n                </span><span class="s1">: JSONExt.deepCopy(metadata.get(key));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return JSONExt.deepCopy(metadata.toJSON());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setMetadata(metadata, value) {</span><span class="s3">\n        </span><span class="s1">var _a, _b;</span><span class="s3">\n        </span><span class="s1">if (typeof metadata === 'string') {</span><span class="s3">\n            </span><span class="s1">if (typeof value === 'undefined') {</span><span class="s3">\n                </span><span class="s1">throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const key = metadata;</span><span class="s3">\n            </span><span class="s1">// Only set metadata if we change something to avoid infinite</span><span class="s3">\n            </span><span class="s1">// loop of signal changes.</span><span class="s3">\n            </span><span class="s1">if (JSONExt.deepEqual((_a = this.getMetadata(key)) !== null &amp;&amp; _a !== void 0 ? _a : null, value)) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n                </span><span class="s1">var _a;</span><span class="s3">\n                </span><span class="s1">this._ymetadata.set(key, value);</span><span class="s3">\n                </span><span class="s1">if (key === 'collapsed') {</span><span class="s3">\n                    </span><span class="s1">const jupyter = ((_a = this.getMetadata('jupyter')) !== null &amp;&amp; _a !== void 0 ? _a : {});</span><span class="s3">\n                    </span><span class="s1">if (jupyter.outputs_hidden !== value) {</span><span class="s3">\n                        </span><span class="s1">this.setMetadata('jupyter', {</span><span class="s3">\n                            </span><span class="s1">...jupyter,</span><span class="s3">\n                            </span><span class="s1">outputs_hidden: value</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (key === 'jupyter') {</span><span class="s3">\n                    </span><span class="s1">const isHidden = value['outputs_hidden'];</span><span class="s3">\n                    </span><span class="s1">if (typeof isHidden !== 'undefined') {</span><span class="s3">\n                        </span><span class="s1">if (this.getMetadata('collapsed') !== isHidden) {</span><span class="s3">\n                            </span><span class="s1">this.setMetadata('collapsed', isHidden);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">this.deleteMetadata('collapsed');</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">const clone = JSONExt.deepCopy(metadata);</span><span class="s3">\n            </span><span class="s1">if (clone.collapsed != null) {</span><span class="s3">\n                </span><span class="s1">clone.jupyter = clone.jupyter || {};</span><span class="s3">\n                </span><span class="s1">clone.jupyter.outputs_hidden = clone.collapsed;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (((_b = clone === null || clone === void 0 ? void 0 : clone.jupyter) === null || _b === void 0 ? void 0 : _b.outputs_hidden) != null) {</span><span class="s3">\n                </span><span class="s1">clone.collapsed = clone.jupyter.outputs_hidden;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!JSONExt.deepEqual(clone, this.getMetadata())) {</span><span class="s3">\n                </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">for (const [key, value] of Object.entries(clone)) {</span><span class="s3">\n                        </span><span class="s1">this._ymetadata.set(key, value);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}, false);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Serialize the model to JSON.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">id: this.getId(),</span><span class="s3">\n            </span><span class="s1">cell_type: this.cell_type,</span><span class="s3">\n            </span><span class="s1">source: this.getSource(),</span><span class="s3">\n            </span><span class="s1">metadata: this.getMetadata()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Perform a transaction. While the function f is called, all changes to the shared</span><span class="s3">\n     </span><span class="s1">* document are bundled into a single event.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param f Transaction to execute</span><span class="s3">\n     </span><span class="s1">* @param undoable Whether to track the change in the action history or not (default `true`)</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">transact(f, undoable = true, origin = null) {</span><span class="s3">\n        </span><span class="s1">!this.notebook || this.notebook.disableDocumentWideUndoRedo</span><span class="s3">\n            </span><span class="s1">? this.ymodel.doc == null</span><span class="s3">\n                </span><span class="s1">? f()</span><span class="s3">\n                </span><span class="s1">: this.ymodel.doc.transact(f, undoable ? this : origin)</span><span class="s3">\n            </span><span class="s1">: this.notebook.transact(f, undoable);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Extract changes from YJS events</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param events YJS events</span><span class="s3">\n     </span><span class="s1">* @returns Cell changes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getChanges(events) {</span><span class="s3">\n        </span><span class="s1">const changes = {};</span><span class="s3">\n        </span><span class="s1">const sourceEvent = events.find(event =&gt; event.target === this.ymodel.get('source'));</span><span class="s3">\n        </span><span class="s1">if (sourceEvent) {</span><span class="s3">\n            </span><span class="s1">changes.sourceChange = sourceEvent.changes.delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const metadataEvents = events.find(event =&gt; event.target === this._ymetadata);</span><span class="s3">\n        </span><span class="s1">if (metadataEvents) {</span><span class="s3">\n            </span><span class="s1">changes.metadataChange = metadataEvents.changes.keys;</span><span class="s3">\n            </span><span class="s1">metadataEvents.changes.keys.forEach((change, key) =&gt; {</span><span class="s3">\n                </span><span class="s1">switch (change.action) {</span><span class="s3">\n                    </span><span class="s1">case 'add':</span><span class="s3">\n                        </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                            </span><span class="s1">key,</span><span class="s3">\n                            </span><span class="s1">newValue: this._ymetadata.get(key),</span><span class="s3">\n                            </span><span class="s1">type: 'add'</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case 'delete':</span><span class="s3">\n                        </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                            </span><span class="s1">key,</span><span class="s3">\n                            </span><span class="s1">oldValue: change.oldValue,</span><span class="s3">\n                            </span><span class="s1">type: 'remove'</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">case 'update':</span><span class="s3">\n                        </span><span class="s1">{</span><span class="s3">\n                            </span><span class="s1">const newValue = this._ymetadata.get(key);</span><span class="s3">\n                            </span><span class="s1">const oldValue = change.oldValue;</span><span class="s3">\n                            </span><span class="s1">let equal = true;</span><span class="s3">\n                            </span><span class="s1">if (typeof oldValue == 'object' &amp;&amp; typeof newValue == 'object') {</span><span class="s3">\n                                </span><span class="s1">equal = JSONExt.deepEqual(oldValue, newValue);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else {</span><span class="s3">\n                                </span><span class="s1">equal = oldValue === newValue;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">if (!equal) {</span><span class="s3">\n                                </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                                    </span><span class="s1">key,</span><span class="s3">\n                                    </span><span class="s1">type: 'change',</span><span class="s3">\n                                    </span><span class="s1">oldValue,</span><span class="s3">\n                                    </span><span class="s1">newValue</span><span class="s3">\n                                </span><span class="s1">});</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const modelEvent = events.find(event =&gt; event.target === this.ymodel);</span><span class="s3">\n        </span><span class="s1">// The model allows us to replace the complete source with a new string. We express this in the Delta format</span><span class="s3">\n        </span><span class="s1">// as a replace of the complete string.</span><span class="s3">\n        </span><span class="s1">const ysource = this.ymodel.get('source');</span><span class="s3">\n        </span><span class="s1">if (modelEvent &amp;&amp; modelEvent.keysChanged.has('source')) {</span><span class="s3">\n            </span><span class="s1">changes.sourceChange = [</span><span class="s3">\n                </span><span class="s1">{ delete: this._prevSourceLength },</span><span class="s3">\n                </span><span class="s1">{ insert: ysource.toString() }</span><span class="s3">\n            </span><span class="s1">];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._prevSourceLength = ysource.length;</span><span class="s3">\n        </span><span class="s1">return changes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shareable code cell.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YCodeCell extends YBaseCell {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new YCodeCell that works standalone. It cannot be</span><span class="s3">\n     </span><span class="s1">* inserted into a YNotebook because the Yjs model is already</span><span class="s3">\n     </span><span class="s1">* attached to an anonymous Y.Doc instance.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(id) {</span><span class="s3">\n        </span><span class="s1">return super.create(id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Code cell constructor</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* ### Notes</span><span class="s3">\n     </span><span class="s1">* Don't use the constructor directly - prefer using ``YNotebook.insertCell``</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* The ``ysource`` is needed because ``ymodel.get('source')`` will</span><span class="s3">\n     </span><span class="s1">* not return the real source if the model is not yet attached to</span><span class="s3">\n     </span><span class="s1">* a document. Requesting it explicitly allows to introspect a non-empty</span><span class="s3">\n     </span><span class="s1">* source before the cell is attached to the document.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param ymodel Cell map</span><span class="s3">\n     </span><span class="s1">* @param ysource Cell source</span><span class="s3">\n     </span><span class="s1">* @param youtputs Code cell outputs</span><span class="s3">\n     </span><span class="s1">* @param options </span><span class="s3">\\</span><span class="s1">{ notebook?: The notebook the cell is attached to </span><span class="s3">\\</span><span class="s1">}</span><span class="s3">\n     </span><span class="s1">* @param ymetadata Cell metadata</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(ymodel, ysource, youtputs, options = {}, ymetadata) {</span><span class="s3">\n        </span><span class="s1">super(ymodel, ysource, options, ymetadata);</span><span class="s3">\n        </span><span class="s1">this._youtputs = youtputs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The type of the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cell_type() {</span><span class="s3">\n        </span><span class="s1">return 'code';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The code cell's prompt number. Will be null if the cell has not been run.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get execution_count() {</span><span class="s3">\n        </span><span class="s1">return this.ymodel.get('execution_count') || null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set execution_count(count) {</span><span class="s3">\n        </span><span class="s1">// Do not use `this.execution_count`. When initializing the</span><span class="s3">\n        </span><span class="s1">// cell, we need to set execution_count to `null` if we compare</span><span class="s3">\n        </span><span class="s1">// using `this.execution_count` it will return `null` and we will</span><span class="s3">\n        </span><span class="s1">// never initialize it</span><span class="s3">\n        </span><span class="s1">if (this.ymodel.get('execution_count') !== count) {</span><span class="s3">\n            </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.ymodel.set('execution_count', count);</span><span class="s3">\n            </span><span class="s1">}, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* The code cell's execution state.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get executionState() {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">return (_a = this.ymodel.get('execution_state')) !== null &amp;&amp; _a !== void 0 ? _a : 'idle';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set executionState(state) {</span><span class="s3">\n        </span><span class="s1">if (this.ymodel.get('execution_state') !== state) {</span><span class="s3">\n            </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n                </span><span class="s1">this.ymodel.set('execution_state', state);</span><span class="s3">\n            </span><span class="s1">}, false);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell outputs.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get outputs() {</span><span class="s3">\n        </span><span class="s1">return this.getOutputs();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set outputs(v) {</span><span class="s3">\n        </span><span class="s1">this.setOutputs(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get youtputs() {</span><span class="s3">\n        </span><span class="s1">return this._youtputs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Execution, display, or stream outputs.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getOutputs() {</span><span class="s3">\n        </span><span class="s1">return JSONExt.deepCopy(this._youtputs.toJSON());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">createOutputs(outputs) {</span><span class="s3">\n        </span><span class="s1">const newOutputs = [];</span><span class="s3">\n        </span><span class="s1">for (const output of JSONExt.deepCopy(outputs)) {</span><span class="s3">\n            </span><span class="s1">let _newOutput1;</span><span class="s3">\n            </span><span class="s1">if (output.output_type === 'stream') {</span><span class="s3">\n                </span><span class="s1">// Set the text field as a Y.Text</span><span class="s3">\n                </span><span class="s1">const { text, ...outputWithoutText } = output;</span><span class="s3">\n                </span><span class="s1">_newOutput1 = outputWithoutText;</span><span class="s3">\n                </span><span class="s1">const newText = new Y.Text();</span><span class="s3">\n                </span><span class="s1">let _text = text instanceof Array ? text.join() : text;</span><span class="s3">\n                </span><span class="s1">newText.insert(0, _text);</span><span class="s3">\n                </span><span class="s1">_newOutput1['text'] = newText;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">_newOutput1 = output;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const _newOutput2 = [];</span><span class="s3">\n            </span><span class="s1">for (const [key, value] of Object.entries(_newOutput1)) {</span><span class="s3">\n                </span><span class="s1">_newOutput2.push([key, value]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const newOutput = new Y.Map(_newOutput2);</span><span class="s3">\n            </span><span class="s1">newOutputs.push(newOutput);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return newOutputs;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replace all outputs.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setOutputs(outputs) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._youtputs.delete(0, this._youtputs.length);</span><span class="s3">\n            </span><span class="s1">const newOutputs = this.createOutputs(outputs);</span><span class="s3">\n            </span><span class="s1">this._youtputs.insert(0, newOutputs);</span><span class="s3">\n        </span><span class="s1">}, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove text from a stream output.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">removeStreamOutput(index, start, origin = null) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const output = this._youtputs.get(index);</span><span class="s3">\n            </span><span class="s1">const prevText = output.get('text');</span><span class="s3">\n            </span><span class="s1">const length = prevText.length - start;</span><span class="s3">\n            </span><span class="s1">prevText.delete(start, length);</span><span class="s3">\n        </span><span class="s1">}, false, origin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Append text to a stream output.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">appendStreamOutput(index, text, origin = null) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">const output = this._youtputs.get(index);</span><span class="s3">\n            </span><span class="s1">const prevText = output.get('text');</span><span class="s3">\n            </span><span class="s1">prevText.insert(prevText.length, text);</span><span class="s3">\n        </span><span class="s1">}, false, origin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Replace content from `start' to `end` with `outputs`.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param start: The start index of the range to replace (inclusive).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param end: The end index of the range to replace (exclusive).</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param outputs: New outputs (optional).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateOutputs(start, end, outputs = [], origin = null) {</span><span class="s3">\n        </span><span class="s1">const fin = end &lt; this._youtputs.length ? end - start : this._youtputs.length - start;</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._youtputs.delete(start, fin);</span><span class="s3">\n            </span><span class="s1">const newOutputs = this.createOutputs(outputs);</span><span class="s3">\n            </span><span class="s1">this._youtputs.insert(start, newOutputs);</span><span class="s3">\n        </span><span class="s1">}, false, origin);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Serialize the model to JSON.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">...super.toJSON(),</span><span class="s3">\n            </span><span class="s1">outputs: this.getOutputs(),</span><span class="s3">\n            </span><span class="s1">execution_count: this.execution_count</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Extract changes from YJS events</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param events YJS events</span><span class="s3">\n     </span><span class="s1">* @returns Cell changes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getChanges(events) {</span><span class="s3">\n        </span><span class="s1">const changes = super.getChanges(events);</span><span class="s3">\n        </span><span class="s1">const streamOutputEvent = events.find(</span><span class="s3">\n        </span><span class="s1">// Changes to the 'text' of a cell's stream output can be accessed like so:</span><span class="s3">\n        </span><span class="s1">// ycell['outputs'][output_idx]['text']</span><span class="s3">\n        </span><span class="s1">// This translates to an event path of: ['outputs', output_idx, 'text]</span><span class="s3">\n        </span><span class="s1">event =&gt; event.path.length === 3 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">event.path[0] === 'outputs' &amp;&amp;</span><span class="s3">\n            </span><span class="s1">event.path[2] === 'text');</span><span class="s3">\n        </span><span class="s1">if (streamOutputEvent) {</span><span class="s3">\n            </span><span class="s1">changes.streamOutputChange = streamOutputEvent.changes.delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const outputEvent = events.find(event =&gt; event.target === this.ymodel.get('outputs'));</span><span class="s3">\n        </span><span class="s1">if (outputEvent) {</span><span class="s3">\n            </span><span class="s1">changes.outputsChange = outputEvent.changes.delta;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const modelEvent = events.find(event =&gt; event.target === this.ymodel);</span><span class="s3">\n        </span><span class="s1">if (modelEvent &amp;&amp; modelEvent.keysChanged.has('execution_count')) {</span><span class="s3">\n            </span><span class="s1">const change = modelEvent.changes.keys.get('execution_count');</span><span class="s3">\n            </span><span class="s1">changes.executionCountChange = {</span><span class="s3">\n                </span><span class="s1">oldValue: change.oldValue,</span><span class="s3">\n                </span><span class="s1">newValue: this.ymodel.get('execution_count')</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (modelEvent &amp;&amp; modelEvent.keysChanged.has('execution_state')) {</span><span class="s3">\n            </span><span class="s1">const change = modelEvent.changes.keys.get('execution_state');</span><span class="s3">\n            </span><span class="s1">changes.executionStateChange = {</span><span class="s3">\n                </span><span class="s1">oldValue: change.oldValue,</span><span class="s3">\n                </span><span class="s1">newValue: this.ymodel.get('execution_state')</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return changes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class YAttachmentCell extends YBaseCell {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Cell attachments</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get attachments() {</span><span class="s3">\n        </span><span class="s1">return this.getAttachments();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set attachments(v) {</span><span class="s3">\n        </span><span class="s1">this.setAttachments(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Gets the cell attachments.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The cell attachments.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getAttachments() {</span><span class="s3">\n        </span><span class="s1">return this.ymodel.get('attachments');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Sets the cell attachments</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param attachments: The cell attachments.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setAttachments(attachments) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">if (attachments == null) {</span><span class="s3">\n                </span><span class="s1">this.ymodel.delete('attachments');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.ymodel.set('attachments', attachments);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Extract changes from YJS events</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param events YJS events</span><span class="s3">\n     </span><span class="s1">* @returns Cell changes</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getChanges(events) {</span><span class="s3">\n        </span><span class="s1">const changes = super.getChanges(events);</span><span class="s3">\n        </span><span class="s1">const modelEvent = events.find(event =&gt; event.target === this.ymodel);</span><span class="s3">\n        </span><span class="s1">if (modelEvent &amp;&amp; modelEvent.keysChanged.has('attachments')) {</span><span class="s3">\n            </span><span class="s1">const change = modelEvent.changes.keys.get('attachments');</span><span class="s3">\n            </span><span class="s1">changes.attachmentsChange = {</span><span class="s3">\n                </span><span class="s1">oldValue: change.oldValue,</span><span class="s3">\n                </span><span class="s1">newValue: this.ymodel.get('attachments')</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return changes;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shareable raw cell.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YRawCell extends YAttachmentCell {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new YRawCell that works standalone. It cannot be</span><span class="s3">\n     </span><span class="s1">* inserted into a YNotebook because the Yjs model is already</span><span class="s3">\n     </span><span class="s1">* attached to an anonymous Y.Doc instance.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(id) {</span><span class="s3">\n        </span><span class="s1">return super.create(id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* String identifying the type of cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cell_type() {</span><span class="s3">\n        </span><span class="s1">return 'raw';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Serialize the model to JSON.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">id: this.getId(),</span><span class="s3">\n            </span><span class="s1">cell_type: 'raw',</span><span class="s3">\n            </span><span class="s1">source: this.getSource(),</span><span class="s3">\n            </span><span class="s1">metadata: this.getMetadata(),</span><span class="s3">\n            </span><span class="s1">attachments: this.getAttachments()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shareable markdown cell.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YMarkdownCell extends YAttachmentCell {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new YMarkdownCell that works standalone. It cannot be</span><span class="s3">\n     </span><span class="s1">* inserted into a YNotebook because the Yjs model is already</span><span class="s3">\n     </span><span class="s1">* attached to an anonymous Y.Doc instance.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(id) {</span><span class="s3">\n        </span><span class="s1">return super.create(id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* String identifying the type of cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get cell_type() {</span><span class="s3">\n        </span><span class="s1">return 'markdown';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Serialize the model to JSON.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">id: this.getId(),</span><span class="s3">\n            </span><span class="s1">cell_type: 'markdown',</span><span class="s3">\n            </span><span class="s1">source: this.getSource(),</span><span class="s3">\n            </span><span class="s1">metadata: this.getMetadata(),</span><span class="s3">\n            </span><span class="s1">attachments: this.getAttachments()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ycell.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">import { JSONExt } from '@lumino/coreutils';</span><span class="s3">\n</span><span class="s1">import { Signal } from '@lumino/signaling';</span><span class="s3">\n</span><span class="s1">import * as Y from 'yjs';</span><span class="s3">\n</span><span class="s1">import { YDocument } from './ydocument.js';</span><span class="s3">\n</span><span class="s1">import { createCell, createCellModelFromSharedType } from './ycell.js';</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Shared implementation of the Shared Document types.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Shared cells can be inserted into a SharedNotebook.</span><span class="s3">\n </span><span class="s1">* Shared cells only start emitting events when they are connected to a SharedNotebook.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* </span><span class="s3">\&quot;</span><span class="s1">Standalone</span><span class="s3">\&quot; </span><span class="s1">cells must not be inserted into a (Shared)Notebook.</span><span class="s3">\n </span><span class="s1">* Standalone cells emit events immediately after they have been created, but they must not</span><span class="s3">\n </span><span class="s1">* be included into a (Shared)Notebook.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class YNotebook extends YDocument {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Create a new notebook</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* #### Notes</span><span class="s3">\n     </span><span class="s1">* The document is empty and must be populated</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param options</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(options = {}) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Document version</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.version = '2.0.0';</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* YJS map for the notebook metadata</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.ymeta = this.ydoc.getMap('meta');</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle a change to the ystate.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._onMetaChanged = (events) =&gt; {</span><span class="s3">\n            </span><span class="s1">const metadataEvents = events.find(event =&gt; event.target === this.ymeta.get('metadata'));</span><span class="s3">\n            </span><span class="s1">if (metadataEvents) {</span><span class="s3">\n                </span><span class="s1">const metadataChange = metadataEvents.changes.keys;</span><span class="s3">\n                </span><span class="s1">const ymetadata = this.ymeta.get('metadata');</span><span class="s3">\n                </span><span class="s1">metadataEvents.changes.keys.forEach((change, key) =&gt; {</span><span class="s3">\n                    </span><span class="s1">switch (change.action) {</span><span class="s3">\n                        </span><span class="s1">case 'add':</span><span class="s3">\n                            </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                                </span><span class="s1">key,</span><span class="s3">\n                                </span><span class="s1">type: 'add',</span><span class="s3">\n                                </span><span class="s1">newValue: ymetadata.get(key)</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'delete':</span><span class="s3">\n                            </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                                </span><span class="s1">key,</span><span class="s3">\n                                </span><span class="s1">type: 'remove',</span><span class="s3">\n                                </span><span class="s1">oldValue: change.oldValue</span><span class="s3">\n                            </span><span class="s1">});</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">case 'update':</span><span class="s3">\n                            </span><span class="s1">{</span><span class="s3">\n                                </span><span class="s1">const newValue = ymetadata.get(key);</span><span class="s3">\n                                </span><span class="s1">const oldValue = change.oldValue;</span><span class="s3">\n                                </span><span class="s1">let equal = true;</span><span class="s3">\n                                </span><span class="s1">if (typeof oldValue == 'object' &amp;&amp; typeof newValue == 'object') {</span><span class="s3">\n                                    </span><span class="s1">equal = JSONExt.deepEqual(oldValue, newValue);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">equal = oldValue === newValue;</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">if (!equal) {</span><span class="s3">\n                                    </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                                        </span><span class="s1">key,</span><span class="s3">\n                                        </span><span class="s1">type: 'change',</span><span class="s3">\n                                        </span><span class="s1">oldValue,</span><span class="s3">\n                                        </span><span class="s1">newValue</span><span class="s3">\n                                    </span><span class="s1">});</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">this._changed.emit({ metadataChange });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const metaEvent = events.find(event =&gt; event.target === this.ymeta);</span><span class="s3">\n            </span><span class="s1">if (!metaEvent) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (metaEvent.keysChanged.has('metadata')) {</span><span class="s3">\n                </span><span class="s1">// Handle metadata change when adding/removing the YMap</span><span class="s3">\n                </span><span class="s1">const change = metaEvent.changes.keys.get('metadata');</span><span class="s3">\n                </span><span class="s1">if ((change === null || change === void 0 ? void 0 : change.action) === 'add' &amp;&amp; !change.oldValue) {</span><span class="s3">\n                    </span><span class="s1">const metadataChange = new Map();</span><span class="s3">\n                    </span><span class="s1">for (const key of Object.keys(this.metadata)) {</span><span class="s3">\n                        </span><span class="s1">metadataChange.set(key, {</span><span class="s3">\n                            </span><span class="s1">action: 'add',</span><span class="s3">\n                            </span><span class="s1">oldValue: undefined</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                        </span><span class="s1">this._metadataChanged.emit({</span><span class="s3">\n                            </span><span class="s1">key,</span><span class="s3">\n                            </span><span class="s1">type: 'add',</span><span class="s3">\n                            </span><span class="s1">newValue: this.getMetadata(key)</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">this._changed.emit({ metadataChange });</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (metaEvent.keysChanged.has('nbformat')) {</span><span class="s3">\n                </span><span class="s1">const change = metaEvent.changes.keys.get('nbformat');</span><span class="s3">\n                </span><span class="s1">const nbformatChanged = {</span><span class="s3">\n                    </span><span class="s1">key: 'nbformat',</span><span class="s3">\n                    </span><span class="s1">oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,</span><span class="s3">\n                    </span><span class="s1">newValue: this.nbformat</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this._changed.emit({ nbformatChanged });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (metaEvent.keysChanged.has('nbformat_minor')) {</span><span class="s3">\n                </span><span class="s1">const change = metaEvent.changes.keys.get('nbformat_minor');</span><span class="s3">\n                </span><span class="s1">const nbformatChanged = {</span><span class="s3">\n                    </span><span class="s1">key: 'nbformat_minor',</span><span class="s3">\n                    </span><span class="s1">oldValue: (change === null || change === void 0 ? void 0 : change.oldValue) ? change.oldValue : undefined,</span><span class="s3">\n                    </span><span class="s1">newValue: this.nbformat_minor</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">this._changed.emit({ nbformatChanged });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Handle a change to the list of cells.</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._onYCellsChanged = (event) =&gt; {</span><span class="s3">\n            </span><span class="s1">// update the type cell mapping by iterating through the added/removed types</span><span class="s3">\n            </span><span class="s1">event.changes.added.forEach(item =&gt; {</span><span class="s3">\n                </span><span class="s1">const type = item.content.type;</span><span class="s3">\n                </span><span class="s1">if (!this._ycellMapping.has(type)) {</span><span class="s3">\n                    </span><span class="s1">const c = createCellModelFromSharedType(type, { notebook: this });</span><span class="s3">\n                    </span><span class="s1">c.setUndoManager();</span><span class="s3">\n                    </span><span class="s1">this._ycellMapping.set(type, c);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">event.changes.deleted.forEach(item =&gt; {</span><span class="s3">\n                </span><span class="s1">const type = item.content.type;</span><span class="s3">\n                </span><span class="s1">const model = this._ycellMapping.get(type);</span><span class="s3">\n                </span><span class="s1">if (model) {</span><span class="s3">\n                    </span><span class="s1">model.dispose();</span><span class="s3">\n                    </span><span class="s1">this._ycellMapping.delete(type);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">let index = 0;</span><span class="s3">\n            </span><span class="s1">// this reflects the event.changes.delta, but replaces the content of delta.insert with ycells</span><span class="s3">\n            </span><span class="s1">const cellsChange = [];</span><span class="s3">\n            </span><span class="s1">event.changes.delta.forEach((d) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (d.insert != null) {</span><span class="s3">\n                    </span><span class="s1">const insertedCells = d.insert.map((ycell) =&gt; this._ycellMapping.get(ycell));</span><span class="s3">\n                    </span><span class="s1">cellsChange.push({ insert: insertedCells });</span><span class="s3">\n                    </span><span class="s1">this.cells.splice(index, 0, ...insertedCells);</span><span class="s3">\n                    </span><span class="s1">index += d.insert.length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (d.delete != null) {</span><span class="s3">\n                    </span><span class="s1">cellsChange.push(d);</span><span class="s3">\n                    </span><span class="s1">this.cells.splice(index, d.delete);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (d.retain != null) {</span><span class="s3">\n                    </span><span class="s1">cellsChange.push(d);</span><span class="s3">\n                    </span><span class="s1">index += d.retain;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this._changed.emit({</span><span class="s3">\n                </span><span class="s1">cellsChange: cellsChange</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this._metadataChanged = new Signal(this);</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n         </span><span class="s1">* Internal Yjs cells list</span><span class="s3">\n         </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._ycells = this.ydoc.getArray('cells');</span><span class="s3">\n        </span><span class="s1">this._ycellMapping = new WeakMap();</span><span class="s3">\n        </span><span class="s1">this._disableDocumentWideUndoRedo =</span><span class="s3">\n            </span><span class="s1">(_a = options.disableDocumentWideUndoRedo) !== null &amp;&amp; _a !== void 0 ? _a : false;</span><span class="s3">\n        </span><span class="s1">this.cells = this._ycells.toArray().map(ycell =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!this._ycellMapping.has(ycell)) {</span><span class="s3">\n                </span><span class="s1">this._ycellMapping.set(ycell, createCellModelFromSharedType(ycell, { notebook: this }));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return this._ycellMapping.get(ycell);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.undoManager.addToScope(this._ycells);</span><span class="s3">\n        </span><span class="s1">this._ycells.observe(this._onYCellsChanged);</span><span class="s3">\n        </span><span class="s1">this.ymeta.observeDeep(this._onMetaChanged);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Creates a standalone YNotebook</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Note: This method is useful when we need to initialize</span><span class="s3">\n     </span><span class="s1">* the YNotebook from the JavaScript side.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(options = {}) {</span><span class="s3">\n        </span><span class="s1">var _a, _b, _c, _d, _e, _f, _g, _h, _j;</span><span class="s3">\n        </span><span class="s1">const ynotebook = new YNotebook({</span><span class="s3">\n            </span><span class="s1">disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null &amp;&amp; _a !== void 0 ? _a : false</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">const data = {</span><span class="s3">\n            </span><span class="s1">cells: (_c = (_b = options.data) === null || _b === void 0 ? void 0 : _b.cells) !== null &amp;&amp; _c !== void 0 ? _c : [],</span><span class="s3">\n            </span><span class="s1">nbformat: (_e = (_d = options.data) === null || _d === void 0 ? void 0 : _d.nbformat) !== null &amp;&amp; _e !== void 0 ? _e : 4,</span><span class="s3">\n            </span><span class="s1">nbformat_minor: (_g = (_f = options.data) === null || _f === void 0 ? void 0 : _f.nbformat_minor) !== null &amp;&amp; _g !== void 0 ? _g : 5,</span><span class="s3">\n            </span><span class="s1">metadata: (_j = (_h = options.data) === null || _h === void 0 ? void 0 : _h.metadata) !== null &amp;&amp; _j !== void 0 ? _j : {}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">ynotebook.fromJSON(data);</span><span class="s3">\n        </span><span class="s1">return ynotebook;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Wether the undo/redo logic should be</span><span class="s3">\n     </span><span class="s1">* considered on the full document across all cells.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* Default: false</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get disableDocumentWideUndoRedo() {</span><span class="s3">\n        </span><span class="s1">return this._disableDocumentWideUndoRedo;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Notebook metadata</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get metadata() {</span><span class="s3">\n        </span><span class="s1">return this.getMetadata();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set metadata(v) {</span><span class="s3">\n        </span><span class="s1">this.setMetadata(v);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Signal triggered when a metadata changes.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get metadataChanged() {</span><span class="s3">\n        </span><span class="s1">return this._metadataChanged;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* nbformat major version</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get nbformat() {</span><span class="s3">\n        </span><span class="s1">return this.ymeta.get('nbformat');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set nbformat(value) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.ymeta.set('nbformat', value);</span><span class="s3">\n        </span><span class="s1">}, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* nbformat minor version</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get nbformat_minor() {</span><span class="s3">\n        </span><span class="s1">return this.ymeta.get('nbformat_minor');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">set nbformat_minor(value) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.ymeta.set('nbformat_minor', value);</span><span class="s3">\n        </span><span class="s1">}, false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Dispose of the resources.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">dispose() {</span><span class="s3">\n        </span><span class="s1">if (this.isDisposed) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this._ycells.unobserve(this._onYCellsChanged);</span><span class="s3">\n        </span><span class="s1">this.ymeta.unobserveDeep(this._onMetaChanged);</span><span class="s3">\n        </span><span class="s1">super.dispose();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get a shared cell by index.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index: Cell's position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The requested shared cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getCell(index) {</span><span class="s3">\n        </span><span class="s1">return this.cells[index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Add a shared cell at the notebook bottom.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param cell Cell to add.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The added cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addCell(cell) {</span><span class="s3">\n        </span><span class="s1">return this.insertCell(this._ycells.length, cell);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Insert a shared cell into a specific position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index: Cell's position.</span><span class="s3">\n     </span><span class="s1">* @param cell: Cell to insert.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The inserted cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">insertCell(index, cell) {</span><span class="s3">\n        </span><span class="s1">return this.insertCells(index, [cell])[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Insert a list of shared cells into a specific position.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index: Position to insert the cells.</span><span class="s3">\n     </span><span class="s1">* @param cells: Array of shared cells to insert.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The inserted cells.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">insertCells(index, cells) {</span><span class="s3">\n        </span><span class="s1">const yCells = cells.map(c =&gt; {</span><span class="s3">\n            </span><span class="s1">const cell = createCell(c, this);</span><span class="s3">\n            </span><span class="s1">this._ycellMapping.set(cell.ymodel, cell);</span><span class="s3">\n            </span><span class="s1">return cell;</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._ycells.insert(index, yCells.map(cell =&gt; cell.ymodel));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">yCells.forEach(c =&gt; {</span><span class="s3">\n            </span><span class="s1">c.setUndoManager();</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return yCells;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Move a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param fromIndex: Index of the cell to move.</span><span class="s3">\n     </span><span class="s1">* @param toIndex: New position of the cell.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveCell(fromIndex, toIndex) {</span><span class="s3">\n        </span><span class="s1">this.moveCells(fromIndex, toIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Move cells.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param fromIndex: Index of the first cells to move.</span><span class="s3">\n     </span><span class="s1">* @param toIndex: New position of the first cell (in the current array).</span><span class="s3">\n     </span><span class="s1">* @param n: Number of cells to move (default 1)</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">moveCells(fromIndex, toIndex, n = 1) {</span><span class="s3">\n        </span><span class="s1">// FIXME we need to use yjs move feature to preserve undo history</span><span class="s3">\n        </span><span class="s1">const clones = new Array(n)</span><span class="s3">\n            </span><span class="s1">.fill(true)</span><span class="s3">\n            </span><span class="s1">.map((_, idx) =&gt; this.getCell(fromIndex + idx).toJSON());</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._ycells.delete(fromIndex, n);</span><span class="s3">\n            </span><span class="s1">this._ycells.insert(fromIndex &gt; toIndex ? toIndex : toIndex - n + 1, clones.map(clone =&gt; createCell(clone, this).ymodel));</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove a cell.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param index: Index of the cell to remove.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">deleteCell(index) {</span><span class="s3">\n        </span><span class="s1">this.deleteCellRange(index, index + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Remove a range of cells.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param from: The start index of the range to remove (inclusive).</span><span class="s3">\n     </span><span class="s1">* @param to: The end index of the range to remove (exclusive).</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">deleteCellRange(from, to) {</span><span class="s3">\n        </span><span class="s1">// Cells will be removed from the mapping in the model event listener.</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this._ycells.delete(from, to - from);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Delete a metadata notebook.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param key The key to delete</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">deleteMetadata(key) {</span><span class="s3">\n        </span><span class="s1">if (typeof this.getMetadata(key) === 'undefined') {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const allMetadata = this.metadata;</span><span class="s3">\n        </span><span class="s1">delete allMetadata[key];</span><span class="s3">\n        </span><span class="s1">this.setMetadata(allMetadata);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">getMetadata(key) {</span><span class="s3">\n        </span><span class="s1">const ymetadata = this.ymeta.get('metadata');</span><span class="s3">\n        </span><span class="s1">// Transiently the metadata can be missing - like during destruction</span><span class="s3">\n        </span><span class="s1">if (ymetadata === undefined) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (typeof key === 'string') {</span><span class="s3">\n            </span><span class="s1">const value = ymetadata.get(key);</span><span class="s3">\n            </span><span class="s1">return typeof value === 'undefined'</span><span class="s3">\n                </span><span class="s1">? undefined // undefined is converted to `{}` by `JSONExt.deepCopy`</span><span class="s3">\n                </span><span class="s1">: JSONExt.deepCopy(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">return JSONExt.deepCopy(ymetadata.toJSON());</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setMetadata(metadata, value) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">if (typeof metadata === 'string') {</span><span class="s3">\n            </span><span class="s1">if (typeof value === 'undefined') {</span><span class="s3">\n                </span><span class="s1">throw new TypeError(`Metadata value for ${metadata} cannot be 'undefined'; use deleteMetadata.`);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (JSONExt.deepEqual((_a = this.getMetadata(metadata)) !== null &amp;&amp; _a !== void 0 ? _a : null, value)) {</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const update = {};</span><span class="s3">\n            </span><span class="s1">update[metadata] = value;</span><span class="s3">\n            </span><span class="s1">this.updateMetadata(update);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (!this.metadata || !JSONExt.deepEqual(this.metadata, metadata)) {</span><span class="s3">\n                </span><span class="s1">const clone = JSONExt.deepCopy(metadata);</span><span class="s3">\n                </span><span class="s1">const ymetadata = this.ymeta.get('metadata');</span><span class="s3">\n                </span><span class="s1">// Transiently the metadata can be missing - like during destruction</span><span class="s3">\n                </span><span class="s1">if (ymetadata === undefined) {</span><span class="s3">\n                    </span><span class="s1">return undefined;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n                    </span><span class="s1">ymetadata.clear();</span><span class="s3">\n                    </span><span class="s1">for (const [key, value] of Object.entries(clone)) {</span><span class="s3">\n                        </span><span class="s1">ymetadata.set(key, value);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Updates the metadata associated with the notebook.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value: Metadata's attribute to update.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">updateMetadata(value) {</span><span class="s3">\n        </span><span class="s1">// TODO: Maybe modify only attributes instead of replacing the whole metadata?</span><span class="s3">\n        </span><span class="s1">const clone = JSONExt.deepCopy(value);</span><span class="s3">\n        </span><span class="s1">const ymetadata = this.ymeta.get('metadata');</span><span class="s3">\n        </span><span class="s1">// Transiently the metadata can be missing - like during destruction</span><span class="s3">\n        </span><span class="s1">if (ymetadata === undefined) {</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">for (const [key, value] of Object.entries(clone)) {</span><span class="s3">\n                </span><span class="s1">ymetadata.set(key, value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Get the notebook source</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @returns The notebook</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">getSource() {</span><span class="s3">\n        </span><span class="s1">return this.toJSON();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Set the notebook source</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value The notebook</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">setSource(value) {</span><span class="s3">\n        </span><span class="s1">this.fromJSON(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Override the notebook with a JSON-serialized document.</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">* @param value The notebook</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">fromJSON(value) {</span><span class="s3">\n        </span><span class="s1">this.transact(() =&gt; {</span><span class="s3">\n            </span><span class="s1">this.nbformat = value.nbformat;</span><span class="s3">\n            </span><span class="s1">this.nbformat_minor = value.nbformat_minor;</span><span class="s3">\n            </span><span class="s1">const metadata = value.metadata;</span><span class="s3">\n            </span><span class="s1">if (metadata['orig_nbformat'] !== undefined) {</span><span class="s3">\n                </span><span class="s1">delete metadata['orig_nbformat'];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.metadata) {</span><span class="s3">\n                </span><span class="s1">const ymetadata = new Y.Map();</span><span class="s3">\n                </span><span class="s1">for (const [key, value] of Object.entries(metadata)) {</span><span class="s3">\n                    </span><span class="s1">ymetadata.set(key, value);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.ymeta.set('metadata', ymetadata);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.metadata = metadata;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const useId = value.nbformat === 4 &amp;&amp; value.nbformat_minor &gt;= 5;</span><span class="s3">\n            </span><span class="s1">const ycells = value.cells.map(cell =&gt; {</span><span class="s3">\n                </span><span class="s1">if (!useId) {</span><span class="s3">\n                    </span><span class="s1">delete cell.id;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return cell;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">this.insertCells(this.cells.length, ycells);</span><span class="s3">\n            </span><span class="s1">this.deleteCellRange(0, this.cells.length);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Serialize the model to JSON.</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">// strip cell ids if we have notebook format 4.0-4.4</span><span class="s3">\n        </span><span class="s1">const pruneCellId = this.nbformat === 4 &amp;&amp; this.nbformat_minor &lt;= 4;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">metadata: this.metadata,</span><span class="s3">\n            </span><span class="s1">nbformat_minor: this.nbformat_minor,</span><span class="s3">\n            </span><span class="s1">nbformat: this.nbformat,</span><span class="s3">\n            </span><span class="s1">cells: this.cells.map(c =&gt; {</span><span class="s3">\n                </span><span class="s1">const raw = c.toJSON();</span><span class="s3">\n                </span><span class="s1">if (pruneCellId) {</span><span class="s3">\n                    </span><span class="s1">delete raw.id;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return raw;</span><span class="s3">\n            </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=ynotebook.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/* -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">| Copyright (c) Jupyter Development Team.</span><span class="s3">\n</span><span class="s1">| Distributed under the terms of the Modified BSD License.</span><span class="s3">\n</span><span class="s1">|----------------------------------------------------------------------------*/</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @packageDocumentation</span><span class="s3">\n </span><span class="s1">* @module ydoc</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export * from './api.js';</span><span class="s3">\n</span><span class="s1">export * from './utils.js';</span><span class="s3">\n</span><span class="s1">export * from './awareness.js';</span><span class="s3">\n</span><span class="s1">export * from './ytext.js';</span><span class="s3">\n</span><span class="s1">export * from './ydocument.js';</span><span class="s3">\n</span><span class="s1">export * from './yfile.js';</span><span class="s3">\n</span><span class="s1">export * from './ynotebook.js';</span><span class="s3">\n</span><span class="s1">export { YBaseCell, YRawCell, YMarkdownCell, YCodeCell, createStandaloneCell } from './ycell.js';</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=index.js.map&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with Arrays.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as set from './set.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return the last element of an array. The element must exist</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template L</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;L&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {L}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const last = arr =&gt; arr[arr.length - 1]</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template C</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;C&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; /** @type {Array&lt;C&gt;} */ ([])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template D</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;D&gt;} a</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;D&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const copy = a =&gt; /** @type {Array&lt;D&gt;} */ (a.slice())</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Append elements from src to dest</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template M</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;M&gt;} dest</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;M&gt;} src</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const appendTo = (dest, src) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; src.length; i++) {</span><span class="s3">\n    </span><span class="s1">dest.push(src[i])</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transforms something array-like to an actual Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;T&gt;|Iterable&lt;T&gt;} arraylike</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const from = Array.from</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* True iff condition holds on every element in the Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template ITEM</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;ITEM&gt;} ARR</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {function(ITEM, number, ARR):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const every = (arr, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!f(arr[i], i, arr)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* True iff condition holds on some element in the Array.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template S</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;S&gt;} ARR</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {function(S, number, ARR):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const some = (arr, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (f(arr[i], i, arr)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template ELEM</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;ELEM&gt;} a</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;ELEM&gt;} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalFlat = (a, b) =&gt; a.length === b.length &amp;&amp; every(a, (item, index) =&gt; item === b[index])</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template ELEM</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;Array&lt;ELEM&gt;&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;ELEM&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const flatten = arr =&gt; fold(arr, /** @type {Array&lt;ELEM&gt;} */ ([]), (acc, val) =&gt; acc.concat(val))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {number} len</span><span class="s3">\n </span><span class="s1">* @param {function(number, Array&lt;T&gt;):T} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unfold = (len, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const array = new Array(len)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; len; i++) {</span><span class="s3">\n    </span><span class="s1">array[i] = f(i, array)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return array</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @template RESULT</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {RESULT} seed</span><span class="s3">\n </span><span class="s1">* @param {function(RESULT, T, number):RESULT} folder</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const fold = (arr, seed, folder) =&gt; arr.reduce(folder, seed)</span><span class="s3">\n\n</span><span class="s1">export const isArray = Array.isArray</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const unique = arr =&gt; from(set.from(arr))</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @template M</span><span class="s3">\n </span><span class="s1">* @param {ArrayLike&lt;T&gt;} arr</span><span class="s3">\n </span><span class="s1">* @param {function(T):M} mapper</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const uniqueBy = (arr, mapper) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Set&lt;M&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const happened = set.create()</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;T&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const result = []</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">const el = arr[i]</span><span class="s3">\n    </span><span class="s1">const mapped = mapper(el)</span><span class="s3">\n    </span><span class="s1">if (!happened.has(mapped)) {</span><span class="s3">\n      </span><span class="s1">happened.add(mapped)</span><span class="s3">\n      </span><span class="s1">result.push(el)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {ArrayLike&lt;any&gt;} ARR</span><span class="s3">\n </span><span class="s1">* @template {function(ARR extends ArrayLike&lt;infer T&gt; ? T : never, number, ARR):any} MAPPER</span><span class="s3">\n </span><span class="s1">* @param {ARR} arr</span><span class="s3">\n </span><span class="s1">* @param {MAPPER} mapper</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;MAPPER extends function(...any): infer M ? M : never&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (arr, mapper) =&gt; {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @type {Array&lt;any&gt;}</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">const res = Array(arr.length)</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; arr.length; i++) {</span><span class="s3">\n    </span><span class="s1">res[i] = mapper(/** @type {any} */ (arr[i]), i, /** @type {any} */ (arr))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return /** @type {any} */ (res)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Common functions and function call helpers.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n</span><span class="s1">import * as object from './object.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls all functions in `fs` with args. Only throws after all functions were called.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;function&gt;} fs</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;any&gt;} args</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const callAll = (fs, args, i = 0) =&gt; {</span><span class="s3">\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (; i &lt; fs.length; i++) {</span><span class="s3">\n      </span><span class="s1">fs[i](...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">if (i &lt; fs.length) {</span><span class="s3">\n      </span><span class="s1">callAll(fs, args, i + 1)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const nop = () =&gt; {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {function():T} f</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const apply = f =&gt; f()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template A</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {A} a</span><span class="s3">\n </span><span class="s1">* @return {A}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const id = a =&gt; a</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {T} a</span><span class="s3">\n </span><span class="s1">* @param {T} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityStrict = (a, b) =&gt; a === b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;|object} a</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;T&gt;|object} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityFlat = (a, b) =&gt; a === b || (a != null &amp;&amp; b != null &amp;&amp; a.constructor === b.constructor &amp;&amp; ((array.isArray(a) &amp;&amp; array.equalFlat(a, /** @type {Array&lt;T&gt;} */ (b))) || (typeof a === 'object' &amp;&amp; object.equalFlat(a, b))))</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} a</span><span class="s3">\n </span><span class="s1">* @param {any} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalityDeep = (a, b) =&gt; {</span><span class="s3">\n  </span><span class="s1">if (a == null || b == null) {</span><span class="s3">\n    </span><span class="s1">return equalityStrict(a, b)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (a.constructor !== b.constructor) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (a === b) {</span><span class="s3">\n    </span><span class="s1">return true</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">switch (a.constructor) {</span><span class="s3">\n    </span><span class="s1">case ArrayBuffer:</span><span class="s3">\n      </span><span class="s1">a = new Uint8Array(a)</span><span class="s3">\n      </span><span class="s1">b = new Uint8Array(b)</span><span class="s3">\n    </span><span class="s1">// eslint-disable-next-line no-fallthrough</span><span class="s3">\n    </span><span class="s1">case Uint8Array: {</span><span class="s3">\n      </span><span class="s1">if (a.byteLength !== b.byteLength) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (a[i] !== b[i]) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Set: {</span><span class="s3">\n      </span><span class="s1">if (a.size !== b.size) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const value of a) {</span><span class="s3">\n        </span><span class="s1">if (!b.has(value)) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Map: {</span><span class="s3">\n      </span><span class="s1">if (a.size !== b.size) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const key of a.keys()) {</span><span class="s3">\n        </span><span class="s1">if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">case Object:</span><span class="s3">\n      </span><span class="s1">if (object.length(a) !== object.length(b)) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (const key in a) {</span><span class="s3">\n        </span><span class="s1">if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">case Array:</span><span class="s3">\n      </span><span class="s1">if (a.length !== b.length) {</span><span class="s3">\n        </span><span class="s1">return false</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (let i = 0; i &lt; a.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (!equalityDeep(a[i], b[i])) {</span><span class="s3">\n          </span><span class="s1">return false</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">default:</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @template {V} OPTS</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {V} value</span><span class="s3">\n </span><span class="s1">* @param {Array&lt;OPTS&gt;} options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">// @ts-ignore</span><span class="s3">\n</span><span class="s1">export const isOneOf = (value, options) =&gt; options.includes(value)</span><span class="s3">\n</span><span class="s1">/* c8 ignore stop */</span><span class="s3">\n\n</span><span class="s1">export const isArray = array.isArray</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} s</span><span class="s3">\n </span><span class="s1">* @return {s is String}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isString = (s) =&gt; s &amp;&amp; s.constructor === String</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {any} n</span><span class="s3">\n </span><span class="s1">* @return {n is Number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isNumber = n =&gt; n != null &amp;&amp; n.constructor === Number</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {abstract new (...args: any) =&gt; any} TYPE</span><span class="s3">\n </span><span class="s1">* @param {any} n</span><span class="s3">\n </span><span class="s1">* @param {TYPE} T</span><span class="s3">\n </span><span class="s1">* @return {n is InstanceType&lt;TYPE&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const is = (n, T) =&gt; n &amp;&amp; n.constructor === T</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template {abstract new (...args: any) =&gt; any} TYPE</span><span class="s3">\n </span><span class="s1">* @param {TYPE} T</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isTemplate = (T) =&gt;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {any} n</span><span class="s3">\n   </span><span class="s1">* @return {n is InstanceType&lt;TYPE&gt;}</span><span class="s3">\n   </span><span class="s1">**/</span><span class="s3">\n  </span><span class="s1">n =&gt; n &amp;&amp; n.constructor === T</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with key-value stores.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module map</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates a new Map instance.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;any, any&gt;}</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; new Map()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Copy a Map object into a fresh Map object.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template X,Y</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;X,Y&gt;} m</span><span class="s3">\n </span><span class="s1">* @return {Map&lt;X,Y&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const copy = m =&gt; {</span><span class="s3">\n  </span><span class="s1">const r = create()</span><span class="s3">\n  </span><span class="s1">m.forEach((v, k) =&gt; { r.set(k, v) })</span><span class="s3">\n  </span><span class="s1">return r</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Get map property. Create T if property is undefined and set T on map.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* ```js</span><span class="s3">\n </span><span class="s1">* const listeners = map.setIfUndefined(events, 'eventName', set.create)</span><span class="s3">\n </span><span class="s1">* listeners.add(listener)</span><span class="s3">\n </span><span class="s1">* ```</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template V,K</span><span class="s3">\n </span><span class="s1">* @template {Map&lt;K,V&gt;} MAP</span><span class="s3">\n </span><span class="s1">* @param {MAP} map</span><span class="s3">\n </span><span class="s1">* @param {K} key</span><span class="s3">\n </span><span class="s1">* @param {function():V} createT</span><span class="s3">\n </span><span class="s1">* @return {V}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const setIfUndefined = (map, key, createT) =&gt; {</span><span class="s3">\n  </span><span class="s1">let set = map.get(key)</span><span class="s3">\n  </span><span class="s1">if (set === undefined) {</span><span class="s3">\n    </span><span class="s1">map.set(key, set = createT())</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return set</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @template R</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):R} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const res = []</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">res.push(f(value, key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return res</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests whether any key-value pairs pass the test implemented by `f(value, key)`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @todo should rename to some - similarly to Array.some</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const any = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">if (f(value, key)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tests whether all key-value pairs pass the test implemented by `f(value, key)`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @template K</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {Map&lt;K,V&gt;} m</span><span class="s3">\n </span><span class="s1">* @param {function(V,K):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const all = (m, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const [key, value] of m) {</span><span class="s3">\n    </span><span class="s1">if (!f(value, key)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Common Math expressions.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module math</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const floor = Math.floor</span><span class="s3">\n</span><span class="s1">export const ceil = Math.ceil</span><span class="s3">\n</span><span class="s1">export const abs = Math.abs</span><span class="s3">\n</span><span class="s1">export const imul = Math.imul</span><span class="s3">\n</span><span class="s1">export const round = Math.round</span><span class="s3">\n</span><span class="s1">export const log10 = Math.log10</span><span class="s3">\n</span><span class="s1">export const log2 = Math.log2</span><span class="s3">\n</span><span class="s1">export const log = Math.log</span><span class="s3">\n</span><span class="s1">export const sqrt = Math.sqrt</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The sum of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const add = (a, b) =&gt; a + b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The smaller element of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const min = (a, b) =&gt; a &lt; b ? a : b</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @function</span><span class="s3">\n </span><span class="s1">* @param {number} a</span><span class="s3">\n </span><span class="s1">* @param {number} b</span><span class="s3">\n </span><span class="s1">* @return {number} The bigger element of a and b</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const max = (a, b) =&gt; a &gt; b ? a : b</span><span class="s3">\n\n</span><span class="s1">export const isNaN = Number.isNaN</span><span class="s3">\n\n</span><span class="s1">export const pow = Math.pow</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Base 10 exponential function. Returns the value of 10 raised to the power of pow.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} exp</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const exp10 = exp =&gt; Math.pow(10, exp)</span><span class="s3">\n\n</span><span class="s1">export const sign = Math.sign</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {number} n</span><span class="s3">\n </span><span class="s1">* @return {boolean} Wether n is negative. This function also differentiates between -0 and +0</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isNegativeZero = n =&gt; n !== 0 ? n &lt; 0 : 1 / n &lt; 0</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility functions for working with EcmaScript objects.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module object</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @return {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const create = () =&gt; Object.create(null)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Object.assign</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const assign = Object.assign</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const keys = Object.keys</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template V</span><span class="s3">\n </span><span class="s1">* @param {{[k:string]:V}} obj</span><span class="s3">\n </span><span class="s1">* @param {function(V,string):any} f</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const forEach = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">f(obj[key], key)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @todo implement mapToArray &amp; map</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template R</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):R} f</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;R&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const map = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">const results = []</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">results.push(f(obj[key], key))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return results</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const length = obj =&gt; keys(obj).length</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const some = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">if (f(obj[key], key)) {</span><span class="s3">\n      </span><span class="s1">return true</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object|undefined} obj</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const isEmpty = obj =&gt; {</span><span class="s3">\n  </span><span class="s1">// eslint-disable-next-line</span><span class="s3">\n  </span><span class="s1">for (const _k in obj) {</span><span class="s3">\n    </span><span class="s1">return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} obj</span><span class="s3">\n </span><span class="s1">* @param {function(any,string):boolean} f</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const every = (obj, f) =&gt; {</span><span class="s3">\n  </span><span class="s1">for (const key in obj) {</span><span class="s3">\n    </span><span class="s1">if (!f(obj[key], key)) {</span><span class="s3">\n      </span><span class="s1">return false</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return true</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Calls `Object.prototype.hasOwnProperty`.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {any} obj</span><span class="s3">\n </span><span class="s1">* @param {string|symbol} key</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const hasProperty = (obj, key) =&gt; Object.prototype.hasOwnProperty.call(obj, key)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} a</span><span class="s3">\n </span><span class="s1">* @param {Object&lt;string,any&gt;} b</span><span class="s3">\n </span><span class="s1">* @return {boolean}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const equalFlat = (a, b) =&gt; a === b || (length(a) === length(b) &amp;&amp; every(a, (val, key) =&gt; (val !== undefined || hasProperty(b, key)) &amp;&amp; b[key] === val))</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Observable class prototype.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module observable</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as map from './map.js'</span><span class="s3">\n</span><span class="s1">import * as set from './set.js'</span><span class="s3">\n</span><span class="s1">import * as array from './array.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles named events.</span><span class="s3">\n </span><span class="s1">* @experimental</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* This is basically a (better typed) duplicate of Observable, which will replace Observable in the</span><span class="s3">\n </span><span class="s1">* next release.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @template {{[key: string]: function(...any):void}} EVENTS</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class ObservableV2 {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Some desc.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;string, Set&lt;any&gt;&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">on (name, f) {</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(this._observers, /** @type {string} */ (name), set.create).add(f)</span><span class="s3">\n    </span><span class="s1">return f</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">once (name, f) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param  {...any} args</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const _f = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.off(name, /** @type {any} */ (_f))</span><span class="s3">\n      </span><span class="s1">f(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.on(name, /** @type {any} */ (_f))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name</span><span class="s3">\n   </span><span class="s1">* @param {EVENTS[NAME]} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">off (name, f) {</span><span class="s3">\n    </span><span class="s1">const observers = this._observers.get(name)</span><span class="s3">\n    </span><span class="s1">if (observers !== undefined) {</span><span class="s3">\n      </span><span class="s1">observers.delete(f)</span><span class="s3">\n      </span><span class="s1">if (observers.size === 0) {</span><span class="s3">\n        </span><span class="s1">this._observers.delete(name)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Emit a named event. All registered event listeners that listen to the</span><span class="s3">\n   </span><span class="s1">* specified name will receive the event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo This should catch exceptions</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @template {string} NAME</span><span class="s3">\n   </span><span class="s1">* @param {NAME} name The event name.</span><span class="s3">\n   </span><span class="s1">* @param {Parameters&lt;EVENTS[NAME]&gt;} args The arguments that are applied to the event listener.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">emit (name, args) {</span><span class="s3">\n    </span><span class="s1">// copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.</span><span class="s3">\n    </span><span class="s1">return array.from((this._observers.get(name) || map.create()).values()).forEach(f =&gt; f(...args))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/* c8 ignore start */</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Handles named events.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @deprecated</span><span class="s3">\n </span><span class="s1">* @template N</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export class Observable {</span><span class="s3">\n  </span><span class="s1">constructor () {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Some desc.</span><span class="s3">\n     </span><span class="s1">* @type {Map&lt;N, any&gt;}</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">on (name, f) {</span><span class="s3">\n    </span><span class="s1">map.setIfUndefined(this._observers, name, set.create).add(f)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">once (name, f) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* @param  {...any} args</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">const _f = (...args) =&gt; {</span><span class="s3">\n      </span><span class="s1">this.off(name, _f)</span><span class="s3">\n      </span><span class="s1">f(...args)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.on(name, _f)</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param {N} name</span><span class="s3">\n   </span><span class="s1">* @param {function} f</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">off (name, f) {</span><span class="s3">\n    </span><span class="s1">const observers = this._observers.get(name)</span><span class="s3">\n    </span><span class="s1">if (observers !== undefined) {</span><span class="s3">\n      </span><span class="s1">observers.delete(f)</span><span class="s3">\n      </span><span class="s1">if (observers.size === 0) {</span><span class="s3">\n        </span><span class="s1">this._observers.delete(name)</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Emit a named event. All registered event listeners that listen to the</span><span class="s3">\n   </span><span class="s1">* specified name will receive the event.</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @todo This should catch exceptions</span><span class="s3">\n   </span><span class="s1">*</span><span class="s3">\n   </span><span class="s1">* @param {N} name The event name.</span><span class="s3">\n   </span><span class="s1">* @param {Array&lt;any&gt;} args The arguments that are applied to the event listener.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">emit (name, args) {</span><span class="s3">\n    </span><span class="s1">// copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.</span><span class="s3">\n    </span><span class="s1">return array.from((this._observers.get(name) || map.create()).values()).forEach(f =&gt; f(...args))</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">destroy () {</span><span class="s3">\n    </span><span class="s1">this._observers = map.create()</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/* c8 ignore end */</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with sets.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module set</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">export const create = () =&gt; new Set()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Set&lt;T&gt;} set</span><span class="s3">\n </span><span class="s1">* @return {Array&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const toArray = set =&gt; Array.from(set)</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Set&lt;T&gt;} set</span><span class="s3">\n </span><span class="s1">* @return {T}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const first = set =&gt;</span><span class="s3">\n  </span><span class="s1">set.values().next().value || undefined</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* @template T</span><span class="s3">\n </span><span class="s1">* @param {Iterable&lt;T&gt;} entries</span><span class="s3">\n </span><span class="s1">* @return {Set&lt;T&gt;}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const from = entries =&gt; new Set(entries)</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* Utility module to work with time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @module time</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">import * as metric from './metric.js'</span><span class="s3">\n</span><span class="s1">import * as math from './math.js'</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return current time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {Date}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const getDate = () =&gt; new Date()</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Return current unix time.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @return {number}</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const getUnixTime = Date.now</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Transform time (in ms) to a human readable format. E.g. 1100 =&gt; 1.1s. 60s =&gt; 1min. .001 =&gt; 10μs.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param {number} d duration in milliseconds</span><span class="s3">\n </span><span class="s1">* @return {string} humanized approximation of time</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">export const humanizeDuration = d =&gt; {</span><span class="s3">\n  </span><span class="s1">if (d &lt; 60000) {</span><span class="s3">\n    </span><span class="s1">const p = metric.prefix(d, -1)</span><span class="s3">\n    </span><span class="s1">return math.round(p.n * 100) / 100 + p.prefix + 's'</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">d = math.floor(d / 1000)</span><span class="s3">\n  </span><span class="s1">const seconds = d % 60</span><span class="s3">\n  </span><span class="s1">const minutes = math.floor(d / 60) % 60</span><span class="s3">\n  </span><span class="s1">const hours = math.floor(d / 3600) % 24</span><span class="s3">\n  </span><span class="s1">const days = math.floor(d / 86400)</span><span class="s3">\n  </span><span class="s1">if (days &gt; 0) {</span><span class="s3">\n    </span><span class="s1">return days + 'd' + ((hours &gt; 0 || minutes &gt; 30) ? ' ' + (minutes &gt; 30 ? hours + 1 : hours) + 'h' : '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (hours &gt; 0) {</span><span class="s3">\n    </span><span class="s1">/* c8 ignore next */</span><span class="s3">\n    </span><span class="s1">return hours + 'h' + ((minutes &gt; 0 || seconds &gt; 30) ? ' ' + (seconds &gt; 30 ? minutes + 1 : minutes) + 'min' : '')</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return minutes + 'min' + (seconds &gt; 0 ? ' ' + seconds + 's' : '')</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>