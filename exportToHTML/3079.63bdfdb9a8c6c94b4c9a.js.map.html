<html>
<head>
<title>3079.63bdfdb9a8c6c94b4c9a.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3079.63bdfdb9a8c6c94b4c9a.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3079.63bdfdb9a8c6c94b4c9a.js?v=63bdfdb9a8c6c94b4c9a&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,6BAA6B,IAAI,GAAG,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,IAAI;AAC7B,kCAAkC,IAAI;AACtC,kCAAkC,IAAI;AACtC;AACA,4BAA4B,IAAI,MAAM,EAAE;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,EAAE,GAAG,EAAE;AACrC;AACA;AACA,yCAAyC,IAAI,kBAAkB,IAAI,MAAM;AACzE,4CAA4C,IAAI,kBAAkB,IAAI,MAAM;AAC5E,0DAA0D;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,IAAI,EAAE,KAAK;AACxD,gDAAgD,IAAI,yBAAyB,aAAa,IAAI;AAC9F,wCAAwC,IAAI,yBAAyB,SAAS,GAAG,SAAS,GAAG,WAAW,GAAG;AAC3G,iDAAiD,IAAI,yBAAyB;AAC9E,kDAAkD,IAAI,yBAAyB;AAC/E,+CAA+C,IAAI,yBAAyB;AAC5E;AACA;AACA;AACA;AACA;AACA,0BAA0B,EAAE,GAAG,IAAI;AACnC,mBAAmB,IAAI,GAAG,GAAG,sBAAsB,GAAG,6CAA6C,IAAI;AACvG,eAAe,IAAI,aAAa,GAAG,aAAa,GAAG,cAAc,GAAG;AACpE,oBAAoB,IAAI,GAAG,IAAI;AAC/B,4BAA4B,IAAI;AAChC,8JAA8J,IAAI;AAClK;AACA;AACA,iCAAiC,EAAE,GAAG,IAAI;AAC1C,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B;AACA;AACA;AACA;AACA,iCAAiC,EAAE,GAAG,IAAI;AAC1C,2BAA2B,IAAI,KAAK,GAAG,GAAG,GAAG;AAC7C,+BAA+B,IAAI;AACnC,4BAA4B,IAAI,EAAE,IAAI;AACtC,yBAAyB,IAAI;AAC7B,0BAA0B,IAAI;AAC9B;AACA;AACA;AACA;AACA,qBAAqB,IAAI;AACzB;AACA;AACA;AACA,uBAAuB,IAAI;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,IAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC;AACA;AACA,8BAA8B,IAAI;AAClC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA,6BAA6B,IAAI;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,IAAI;AACb;AACA;AACA,2BAA2B,IAAI,EAAE,IAAI;AACrC,8BAA8B,IAAI;AAClC,2BAA2B,EAAE,GAAG,IAAI;AACpC,0BAA0B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC3D,wBAAwB,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,EAAE,IAAI;AACzC;AACA;AACA,kCAAkC,IAAI;AACtC,8BAA8B,IAAI,KAAK,GAAG,kBAAkB,GAAG;AAC/D,4BAA4B,IAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,GAAG;AAC9C,oEAAoE,GAAG;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,IAAI;AACtB;AACA,yBAAyB,IAAI;AAC7B;AACA;AACA,iCAAiC,KAAK;AACtC;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe,EAAE;AAC1D;AACA,gBAAgB,GAAG;AACnB,sCAAsC,GAAG,8CAA8C,GAAG;AAC1F;AACA,0BAA0B,EAAE,GAAG,EAAE;AACjC,mCAAmC,EAAE,GAAG,EAAE;AAC1C,uCAAuC,EAAE,GAAG,EAAE;AAC9C;AACA;AACA;AACA,0CAA0C,EAAE,GAAG,EAAE;AACjD,mDAAmD,EAAE,GAAG,EAAE;AAC1D,qDAAqD,EAAE,GAAG,EAAE;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD,iDAAiD,EAAE,kCAAkC,KAAK,6CAA6C,KAAK;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,sCAAsC,UAAU;AAC5E;AACA,iCAAiC,GAAG,iCAAiC,GAAG,6EAA6E,GAAG,+BAA+B,GAAG,gCAAgC,GAAG;AAC7N;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG;AAC9B;AACA,iCAAiC,GAAG;AACpC,oBAAoB,IAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd,cAAc;AACd,gBAAgB;AAChB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,kBAAkB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,kBAAkB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI,IAAI,WAAW;AAClD,iCAAiC,KAAK,IAAI,YAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI,IAAI,eAAe,SAAS,KAAK;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,sDAAsD;AACtD;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uHAAuH;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mIAAmI;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,uBAAuB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,EAAE,GAAG,GAAG;AAC5D;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA,4CAA4C;AAC5C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6BAA6B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,aAAa;AAC7D;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,aAAa;AAClE;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,QAAQ;AACzB;AACA,gCAAgC,KAAK;AACrC;AACA,WAAW,MAAM;AACjB;AACA;AACA,cAAc,eAAe;AAC7B,oBAAoB,MAAM,GAAG,gCAAgC,KAAK,MAAM;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,yBAAyB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS;AAC/B;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,gBAAgB,QAAQ;AACxB,qBAAqB,gCAAgC;AACrD;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,4BAA4B,gBAAgB;AAC5C;AACA;AACA,oCAAoC,YAAY;AAChD;AACA;AACA,6BAA6B,KAAK;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,wBAAwB,KAAK;AAC7B;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,SAAS,YAAY;AAC7C,kBAAkB,KAAK;AACvB,oCAAoC,KAAK;AACzC;AACA;AACA;AACA;AACA,aAAa,QAAQ;AACrB,0BAA0B,gCAAgC;AAC1D;AACA,SAAS,QAAQ;AACjB,sBAAsB,gCAAgC;AACtD;AACA,eAAe,MAAM;AACrB,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,UAAU,QAAQ;AAClB,uBAAuB,gCAAgC;AACvD;AACA,WAAW,qBAAqB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,+BAA+B,KAAK,SAAS,KAAK;AAClD;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA,SAAS,MAAM;AACf;AACA;AACA,eAAe,MAAM;AACrB;AACA;AACA,UAAU,MAAM;AAChB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA,wFAAwF,cAAc;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,oDAAoD;AAC3F,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA,oFAAoF,cAAc;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,KAAK;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,KAAK;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,SAAS;AACT;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE2R;AAC3R&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/marked/lib/marked.esm.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;/**</span><span class="s3">\n </span><span class="s1">* marked v15.0.7 - a markdown parser</span><span class="s3">\n </span><span class="s1">* Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)</span><span class="s3">\n </span><span class="s1">* https://github.com/markedjs/marked</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* DO NOT EDIT THIS FILE</span><span class="s3">\n </span><span class="s1">* The code in this file is generated from files in ./src/</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the original marked default options.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function _getDefaults() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">async: false,</span><span class="s3">\n        </span><span class="s1">breaks: false,</span><span class="s3">\n        </span><span class="s1">extensions: null,</span><span class="s3">\n        </span><span class="s1">gfm: true,</span><span class="s3">\n        </span><span class="s1">hooks: null,</span><span class="s3">\n        </span><span class="s1">pedantic: false,</span><span class="s3">\n        </span><span class="s1">renderer: null,</span><span class="s3">\n        </span><span class="s1">silent: false,</span><span class="s3">\n        </span><span class="s1">tokenizer: null,</span><span class="s3">\n        </span><span class="s1">walkTokens: null,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">let _defaults = _getDefaults();</span><span class="s3">\n</span><span class="s1">function changeDefaults(newDefaults) {</span><span class="s3">\n    </span><span class="s1">_defaults = newDefaults;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const noopTest = { exec: () =&gt; null };</span><span class="s3">\n</span><span class="s1">function edit(regex, opt = '') {</span><span class="s3">\n    </span><span class="s1">let source = typeof regex === 'string' ? regex : regex.source;</span><span class="s3">\n    </span><span class="s1">const obj = {</span><span class="s3">\n        </span><span class="s1">replace: (name, val) =&gt; {</span><span class="s3">\n            </span><span class="s1">let valSource = typeof val === 'string' ? val : val.source;</span><span class="s3">\n            </span><span class="s1">valSource = valSource.replace(other.caret, '$1');</span><span class="s3">\n            </span><span class="s1">source = source.replace(name, valSource);</span><span class="s3">\n            </span><span class="s1">return obj;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">getRegex: () =&gt; {</span><span class="s3">\n            </span><span class="s1">return new RegExp(source, opt);</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const other = {</span><span class="s3">\n    </span><span class="s1">codeRemoveIndent: /^(?: {1,4}| {0,3}</span><span class="s3">\\</span><span class="s1">t)/gm,</span><span class="s3">\n    </span><span class="s1">outputLinkReplace: /</span><span class="s3">\\\\</span><span class="s1">([</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]])/g,</span><span class="s3">\n    </span><span class="s1">indentCodeCompensation: /^(</span><span class="s3">\\</span><span class="s1">s+)(?:```)/,</span><span class="s3">\n    </span><span class="s1">beginningSpace: /^</span><span class="s3">\\</span><span class="s1">s+/,</span><span class="s3">\n    </span><span class="s1">endingHash: /#$/,</span><span class="s3">\n    </span><span class="s1">startingSpaceChar: /^ /,</span><span class="s3">\n    </span><span class="s1">endingSpaceChar: / $/,</span><span class="s3">\n    </span><span class="s1">nonSpaceChar: /[^ ]/,</span><span class="s3">\n    </span><span class="s1">newLineCharGlobal: /</span><span class="s3">\\</span><span class="s1">n/g,</span><span class="s3">\n    </span><span class="s1">tabCharGlobal: /</span><span class="s3">\\</span><span class="s1">t/g,</span><span class="s3">\n    </span><span class="s1">multipleSpaceGlobal: /</span><span class="s3">\\</span><span class="s1">s+/g,</span><span class="s3">\n    </span><span class="s1">blankLine: /^[ </span><span class="s3">\\</span><span class="s1">t]*$/,</span><span class="s3">\n    </span><span class="s1">doubleBlankLine: /</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*$/,</span><span class="s3">\n    </span><span class="s1">blockquoteStart: /^ {0,3}&gt;/,</span><span class="s3">\n    </span><span class="s1">blockquoteSetextReplace: /</span><span class="s3">\\</span><span class="s1">n {0,3}((?:=+|-+) *)(?=</span><span class="s3">\\</span><span class="s1">n|$)/g,</span><span class="s3">\n    </span><span class="s1">blockquoteSetextReplace2: /^ {0,3}&gt;[ </span><span class="s3">\\</span><span class="s1">t]?/gm,</span><span class="s3">\n    </span><span class="s1">listReplaceTabs: /^</span><span class="s3">\\</span><span class="s1">t+/,</span><span class="s3">\n    </span><span class="s1">listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,</span><span class="s3">\n    </span><span class="s1">listIsTask: /^</span><span class="s3">\\</span><span class="s1">[[ xX]</span><span class="s3">\\</span><span class="s1">] /,</span><span class="s3">\n    </span><span class="s1">listReplaceTask: /^</span><span class="s3">\\</span><span class="s1">[[ xX]</span><span class="s3">\\</span><span class="s1">] +/,</span><span class="s3">\n    </span><span class="s1">anyLine: /</span><span class="s3">\\</span><span class="s1">n.*</span><span class="s3">\\</span><span class="s1">n/,</span><span class="s3">\n    </span><span class="s1">hrefBrackets: /^&lt;(.*)&gt;$/,</span><span class="s3">\n    </span><span class="s1">tableDelimiter: /[:|]/,</span><span class="s3">\n    </span><span class="s1">tableAlignChars: /^</span><span class="s3">\\</span><span class="s1">||</span><span class="s3">\\</span><span class="s1">| *$/g,</span><span class="s3">\n    </span><span class="s1">tableRowBlankLine: /</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*$/,</span><span class="s3">\n    </span><span class="s1">tableAlignRight: /^ *-+: *$/,</span><span class="s3">\n    </span><span class="s1">tableAlignCenter: /^ *:-+: *$/,</span><span class="s3">\n    </span><span class="s1">tableAlignLeft: /^ *:-+ *$/,</span><span class="s3">\n    </span><span class="s1">startATag: /^&lt;a /i,</span><span class="s3">\n    </span><span class="s1">endATag: /^&lt;</span><span class="s3">\\</span><span class="s1">/a&gt;/i,</span><span class="s3">\n    </span><span class="s1">startPreScriptTag: /^&lt;(pre|code|kbd|script)(</span><span class="s3">\\</span><span class="s1">s|&gt;)/i,</span><span class="s3">\n    </span><span class="s1">endPreScriptTag: /^&lt;</span><span class="s3">\\</span><span class="s1">/(pre|code|kbd|script)(</span><span class="s3">\\</span><span class="s1">s|&gt;)/i,</span><span class="s3">\n    </span><span class="s1">startAngleBracket: /^&lt;/,</span><span class="s3">\n    </span><span class="s1">endAngleBracket: /&gt;$/,</span><span class="s3">\n    </span><span class="s1">pedanticHrefTitle: /^([^'</span><span class="s3">\&quot;</span><span class="s1">]*[^</span><span class="s3">\\</span><span class="s1">s])</span><span class="s3">\\</span><span class="s1">s+(['</span><span class="s3">\&quot;</span><span class="s1">])(.*)</span><span class="s3">\\</span><span class="s1">2/,</span><span class="s3">\n    </span><span class="s1">unicodeAlphaNumeric: /[</span><span class="s3">\\</span><span class="s1">p{L}</span><span class="s3">\\</span><span class="s1">p{N}]/u,</span><span class="s3">\n    </span><span class="s1">escapeTest: /[&amp;&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">']/,</span><span class="s3">\n    </span><span class="s1">escapeReplace: /[&amp;&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">']/g,</span><span class="s3">\n    </span><span class="s1">escapeTestNoEncode: /[&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">']|&amp;(?!(#</span><span class="s3">\\</span><span class="s1">d{1,7}|#[Xx][a-fA-F0-9]{1,6}|</span><span class="s3">\\</span><span class="s1">w+);)/,</span><span class="s3">\n    </span><span class="s1">escapeReplaceNoEncode: /[&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">']|&amp;(?!(#</span><span class="s3">\\</span><span class="s1">d{1,7}|#[Xx][a-fA-F0-9]{1,6}|</span><span class="s3">\\</span><span class="s1">w+);)/g,</span><span class="s3">\n    </span><span class="s1">unescapeTest: /&amp;(#(?:</span><span class="s3">\\</span><span class="s1">d+)|(?:#x[0-9A-Fa-f]+)|(?:</span><span class="s3">\\</span><span class="s1">w+));?/ig,</span><span class="s3">\n    </span><span class="s1">caret: /(^|[^</span><span class="s3">\\</span><span class="s1">[])</span><span class="s3">\\</span><span class="s1">^/g,</span><span class="s3">\n    </span><span class="s1">percentDecode: /%25/g,</span><span class="s3">\n    </span><span class="s1">findPipe: /</span><span class="s3">\\</span><span class="s1">|/g,</span><span class="s3">\n    </span><span class="s1">splitPipe: / </span><span class="s3">\\</span><span class="s1">|/,</span><span class="s3">\n    </span><span class="s1">slashPipe: /</span><span class="s3">\\\\\\</span><span class="s1">|/g,</span><span class="s3">\n    </span><span class="s1">carriageReturn: /</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n|</span><span class="s3">\\</span><span class="s1">r/g,</span><span class="s3">\n    </span><span class="s1">spaceLine: /^ +$/gm,</span><span class="s3">\n    </span><span class="s1">notSpaceStart: /^</span><span class="s3">\\</span><span class="s1">S*/,</span><span class="s3">\n    </span><span class="s1">endingNewline: /</span><span class="s3">\\</span><span class="s1">n$/,</span><span class="s3">\n    </span><span class="s1">listItemRegex: (bull) =&gt; new RegExp(`^( {0,3}${bull})((?:[</span><span class="s3">\\</span><span class="s1">t ][^</span><span class="s3">\\\\</span><span class="s1">n]*)?(?:</span><span class="s3">\\\\</span><span class="s1">n|$))`),</span><span class="s3">\n    </span><span class="s1">nextBulletRegex: (indent) =&gt; new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|</span><span class="s3">\\\\</span><span class="s1">d{1,9}[.)])((?:[ </span><span class="s3">\\</span><span class="s1">t][^</span><span class="s3">\\\\</span><span class="s1">n]*)?(?:</span><span class="s3">\\\\</span><span class="s1">n|$))`),</span><span class="s3">\n    </span><span class="s1">hrRegex: (indent) =&gt; new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:</span><span class="s3">\\\\</span><span class="s1">* *){3,})(?:</span><span class="s3">\\\\</span><span class="s1">n+|$)`),</span><span class="s3">\n    </span><span class="s1">fencesBeginRegex: (indent) =&gt; new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`</span><span class="s3">\\</span><span class="s1">`|~~~)`),</span><span class="s3">\n    </span><span class="s1">headingBeginRegex: (indent) =&gt; new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),</span><span class="s3">\n    </span><span class="s1">htmlBeginRegex: (indent) =&gt; new RegExp(`^ {0,${Math.min(3, indent - 1)}}&lt;(?:[a-z].*&gt;|!--)`, 'i'),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Block-Level Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const newline = /^(?:[ </span><span class="s3">\\</span><span class="s1">t]*(?:</span><span class="s3">\\</span><span class="s1">n|$))+/;</span><span class="s3">\n</span><span class="s1">const blockCode = /^((?: {4}| {0,3}</span><span class="s3">\\</span><span class="s1">t)[^</span><span class="s3">\\</span><span class="s1">n]+(?:</span><span class="s3">\\</span><span class="s1">n(?:[ </span><span class="s3">\\</span><span class="s1">t]*(?:</span><span class="s3">\\</span><span class="s1">n|$))*)?)+/;</span><span class="s3">\n</span><span class="s1">const fences = /^ {0,3}(`{3,}(?=[^`</span><span class="s3">\\</span><span class="s1">n]*(?:</span><span class="s3">\\</span><span class="s1">n|$))|~{3,})([^</span><span class="s3">\\</span><span class="s1">n]*)(?:</span><span class="s3">\\</span><span class="s1">n|$)(?:|([</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?)(?:</span><span class="s3">\\</span><span class="s1">n|$))(?: {0,3}</span><span class="s3">\\</span><span class="s1">1[~`]* *(?=</span><span class="s3">\\</span><span class="s1">n|$)|$)/;</span><span class="s3">\n</span><span class="s1">const hr = /^ {0,3}((?:-[</span><span class="s3">\\</span><span class="s1">t ]*){3,}|(?:_[ </span><span class="s3">\\</span><span class="s1">t]*){3,}|(?:</span><span class="s3">\\</span><span class="s1">*[ </span><span class="s3">\\</span><span class="s1">t]*){3,})(?:</span><span class="s3">\\</span><span class="s1">n+|$)/;</span><span class="s3">\n</span><span class="s1">const heading = /^ {0,3}(#{1,6})(?=</span><span class="s3">\\</span><span class="s1">s|$)(.*)(?:</span><span class="s3">\\</span><span class="s1">n+|$)/;</span><span class="s3">\n</span><span class="s1">const bullet = /(?:[*+-]|</span><span class="s3">\\</span><span class="s1">d{1,9}[.)])/;</span><span class="s3">\n</span><span class="s1">const lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|</span><span class="s3">\\</span><span class="s1">n(?!</span><span class="s3">\\</span><span class="s1">s*?</span><span class="s3">\\</span><span class="s1">n|bull |blockCode|fences|blockquote|heading|html|table))+?)</span><span class="s3">\\</span><span class="s1">n {0,3}(=+|-+) *(?:</span><span class="s3">\\</span><span class="s1">n+|$)/;</span><span class="s3">\n</span><span class="s1">const lheading = edit(lheadingCore)</span><span class="s3">\n    </span><span class="s1">.replace(/bull/g, bullet) // lists can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/blockCode/g, /(?: {4}| {0,3}</span><span class="s3">\\</span><span class="s1">t)/) // indented code blocks can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/blockquote/g, / {0,3}&gt;/) // blockquote can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/html/g, / {0,3}&lt;[^</span><span class="s3">\\</span><span class="s1">n&gt;]+&gt;</span><span class="s3">\\</span><span class="s1">n/) // block html can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">|table/g, '') // table not in commonmark</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const lheadingGfm = edit(lheadingCore)</span><span class="s3">\n    </span><span class="s1">.replace(/bull/g, bullet) // lists can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/blockCode/g, /(?: {4}| {0,3}</span><span class="s3">\\</span><span class="s1">t)/) // indented code blocks can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/blockquote/g, / {0,3}&gt;/) // blockquote can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/html/g, / {0,3}&lt;[^</span><span class="s3">\\</span><span class="s1">n&gt;]+&gt;</span><span class="s3">\\</span><span class="s1">n/) // block html can interrupt</span><span class="s3">\n    </span><span class="s1">.replace(/table/g, / {0,3}</span><span class="s3">\\</span><span class="s1">|?(?:[:</span><span class="s3">\\</span><span class="s1">- ]*</span><span class="s3">\\</span><span class="s1">|)+[</span><span class="s3">\\</span><span class="s1">:</span><span class="s3">\\</span><span class="s1">- ]*</span><span class="s3">\\</span><span class="s1">n/) // table can interrupt</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const _paragraph = /^([^</span><span class="s3">\\</span><span class="s1">n]+(?:</span><span class="s3">\\</span><span class="s1">n(?!hr|heading|lheading|blockquote|fences|list|html|table| +</span><span class="s3">\\</span><span class="s1">n)[^</span><span class="s3">\\</span><span class="s1">n]+)*)/;</span><span class="s3">\n</span><span class="s1">const blockText = /^[^</span><span class="s3">\\</span><span class="s1">n]+/;</span><span class="s3">\n</span><span class="s1">const _blockLabel = /(?!</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">])(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">])+/;</span><span class="s3">\n</span><span class="s1">const def = edit(/^ {0,3}</span><span class="s3">\\</span><span class="s1">[(label)</span><span class="s3">\\</span><span class="s1">]: *(?:</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)?([^&lt;</span><span class="s3">\\</span><span class="s1">s][^</span><span class="s3">\\</span><span class="s1">s]*|&lt;.*?&gt;)(?:(?: +(?:</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)?| *</span><span class="s3">\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)(title))? *(?:</span><span class="s3">\\</span><span class="s1">n+|$)/)</span><span class="s3">\n    </span><span class="s1">.replace('label', _blockLabel)</span><span class="s3">\n    </span><span class="s1">.replace('title', /(?:</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\\&quot;</span><span class="s1">?|[^</span><span class="s3">\&quot;\\\\</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">|'[^'</span><span class="s3">\\</span><span class="s1">n]*(?:</span><span class="s3">\\</span><span class="s1">n[^'</span><span class="s3">\\</span><span class="s1">n]+)*</span><span class="s3">\\</span><span class="s1">n?'|</span><span class="s3">\\</span><span class="s1">([^()]*</span><span class="s3">\\</span><span class="s1">))/)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const list = edit(/^( {0,3}bull)([ </span><span class="s3">\\</span><span class="s1">t][^</span><span class="s3">\\</span><span class="s1">n]+?)?(?:</span><span class="s3">\\</span><span class="s1">n|$)/)</span><span class="s3">\n    </span><span class="s1">.replace(/bull/g, bullet)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const _tag = 'address|article|aside|base|basefont|blockquote|body|caption'</span><span class="s3">\n    </span><span class="s1">+ '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'</span><span class="s3">\n    </span><span class="s1">+ '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'</span><span class="s3">\n    </span><span class="s1">+ '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'</span><span class="s3">\n    </span><span class="s1">+ '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'</span><span class="s3">\n    </span><span class="s1">+ '|tr|track|ul';</span><span class="s3">\n</span><span class="s1">const _comment = /&lt;!--(?:-?&gt;|[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?(?:--&gt;|$))/;</span><span class="s3">\n</span><span class="s1">const html = edit('^ {0,3}(?:' // optional indentation</span><span class="s3">\n    </span><span class="s1">+ '&lt;(script|pre|style|textarea)[</span><span class="s3">\\\\</span><span class="s1">s&gt;][</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:&lt;/</span><span class="s3">\\\\</span><span class="s1">1&gt;[^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n+|$)' // (1)</span><span class="s3">\n    </span><span class="s1">+ '|comment[^</span><span class="s3">\\\\</span><span class="s1">n]*(</span><span class="s3">\\\\</span><span class="s1">n+|$)' // (2)</span><span class="s3">\n    </span><span class="s1">+ '|&lt;</span><span class="s3">\\\\</span><span class="s1">?[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:</span><span class="s3">\\\\</span><span class="s1">?&gt;</span><span class="s3">\\\\</span><span class="s1">n*|$)' // (3)</span><span class="s3">\n    </span><span class="s1">+ '|&lt;![A-Z][</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:&gt;</span><span class="s3">\\\\</span><span class="s1">n*|$)' // (4)</span><span class="s3">\n    </span><span class="s1">+ '|&lt;!</span><span class="s3">\\\\</span><span class="s1">[CDATA</span><span class="s3">\\\\</span><span class="s1">[[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">]&gt;</span><span class="s3">\\\\</span><span class="s1">n*|$)' // (5)</span><span class="s3">\n    </span><span class="s1">+ '|&lt;/?(tag)(?: +|</span><span class="s3">\\\\</span><span class="s1">n|/?&gt;)[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:(?:</span><span class="s3">\\\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)+</span><span class="s3">\\\\</span><span class="s1">n|$)' // (6)</span><span class="s3">\n    </span><span class="s1">+ '|&lt;(?!script|pre|style|textarea)([a-z][</span><span class="s3">\\\\</span><span class="s1">w-]*)(?:attribute)*? */?&gt;(?=[ </span><span class="s3">\\\\</span><span class="s1">t]*(?:</span><span class="s3">\\\\</span><span class="s1">n|$))[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:(?:</span><span class="s3">\\\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)+</span><span class="s3">\\\\</span><span class="s1">n|$)' // (7) open tag</span><span class="s3">\n    </span><span class="s1">+ '|&lt;/(?!script|pre|style|textarea)[a-z][</span><span class="s3">\\\\</span><span class="s1">w-]*</span><span class="s3">\\\\</span><span class="s1">s*&gt;(?=[ </span><span class="s3">\\\\</span><span class="s1">t]*(?:</span><span class="s3">\\\\</span><span class="s1">n|$))[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?(?:(?:</span><span class="s3">\\\\</span><span class="s1">n[ </span><span class="s3">\\</span><span class="s1">t]*)+</span><span class="s3">\\\\</span><span class="s1">n|$)' // (7) closing tag</span><span class="s3">\n    </span><span class="s1">+ ')', 'i')</span><span class="s3">\n    </span><span class="s1">.replace('comment', _comment)</span><span class="s3">\n    </span><span class="s1">.replace('tag', _tag)</span><span class="s3">\n    </span><span class="s1">.replace('attribute', / +[a-zA-Z:_][</span><span class="s3">\\</span><span class="s1">w.:-]*(?: *= *</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;\\</span><span class="s1">n]*</span><span class="s3">\&quot;</span><span class="s1">| *= *'[^'</span><span class="s3">\\</span><span class="s1">n]*'| *= *[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">'=&lt;&gt;`]+)?/)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const paragraph = edit(_paragraph)</span><span class="s3">\n    </span><span class="s1">.replace('hr', hr)</span><span class="s3">\n    </span><span class="s1">.replace('heading', ' {0,3}#{1,6}(?:</span><span class="s3">\\\\</span><span class="s1">s|$)')</span><span class="s3">\n    </span><span class="s1">.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs</span><span class="s3">\n    </span><span class="s1">.replace('|table', '')</span><span class="s3">\n    </span><span class="s1">.replace('blockquote', ' {0,3}&gt;')</span><span class="s3">\n    </span><span class="s1">.replace('fences', ' {0,3}(?:`{3,}(?=[^`</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n)|~{3,})[^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n')</span><span class="s3">\n    </span><span class="s1">.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt</span><span class="s3">\n    </span><span class="s1">.replace('html', '&lt;/?(?:tag)(?: +|</span><span class="s3">\\\\</span><span class="s1">n|/?&gt;)|&lt;(?:script|pre|style|textarea|!--)')</span><span class="s3">\n    </span><span class="s1">.replace('tag', _tag) // pars can be interrupted by type (6) html blocks</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const blockquote = edit(/^( {0,3}&gt; ?(paragraph|[^</span><span class="s3">\\</span><span class="s1">n]*)(?:</span><span class="s3">\\</span><span class="s1">n|$))+/)</span><span class="s3">\n    </span><span class="s1">.replace('paragraph', paragraph)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normal Block Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const blockNormal = {</span><span class="s3">\n    </span><span class="s1">blockquote,</span><span class="s3">\n    </span><span class="s1">code: blockCode,</span><span class="s3">\n    </span><span class="s1">def,</span><span class="s3">\n    </span><span class="s1">fences,</span><span class="s3">\n    </span><span class="s1">heading,</span><span class="s3">\n    </span><span class="s1">hr,</span><span class="s3">\n    </span><span class="s1">html,</span><span class="s3">\n    </span><span class="s1">lheading,</span><span class="s3">\n    </span><span class="s1">list,</span><span class="s3">\n    </span><span class="s1">newline,</span><span class="s3">\n    </span><span class="s1">paragraph,</span><span class="s3">\n    </span><span class="s1">table: noopTest,</span><span class="s3">\n    </span><span class="s1">text: blockText,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* GFM Block Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const gfmTable = edit('^ *([^</span><span class="s3">\\\\</span><span class="s1">n ].*)</span><span class="s3">\\\\</span><span class="s1">n' // Header</span><span class="s3">\n    </span><span class="s1">+ ' {0,3}((?:</span><span class="s3">\\\\</span><span class="s1">| *)?:?-+:? *(?:</span><span class="s3">\\\\</span><span class="s1">| *:?-+:? *)*(?:</span><span class="s3">\\\\</span><span class="s1">| *)?)' // Align</span><span class="s3">\n    </span><span class="s1">+ '(?:</span><span class="s3">\\\\</span><span class="s1">n((?:(?! *</span><span class="s3">\\\\</span><span class="s1">n|hr|heading|blockquote|code|fences|list|html).*(?:</span><span class="s3">\\\\</span><span class="s1">n|$))*)</span><span class="s3">\\\\</span><span class="s1">n*|$)') // Cells</span><span class="s3">\n    </span><span class="s1">.replace('hr', hr)</span><span class="s3">\n    </span><span class="s1">.replace('heading', ' {0,3}#{1,6}(?:</span><span class="s3">\\\\</span><span class="s1">s|$)')</span><span class="s3">\n    </span><span class="s1">.replace('blockquote', ' {0,3}&gt;')</span><span class="s3">\n    </span><span class="s1">.replace('code', '(?: {4}| {0,3}</span><span class="s3">\\</span><span class="s1">t)[^</span><span class="s3">\\\\</span><span class="s1">n]')</span><span class="s3">\n    </span><span class="s1">.replace('fences', ' {0,3}(?:`{3,}(?=[^`</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n)|~{3,})[^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n')</span><span class="s3">\n    </span><span class="s1">.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt</span><span class="s3">\n    </span><span class="s1">.replace('html', '&lt;/?(?:tag)(?: +|</span><span class="s3">\\\\</span><span class="s1">n|/?&gt;)|&lt;(?:script|pre|style|textarea|!--)')</span><span class="s3">\n    </span><span class="s1">.replace('tag', _tag) // tables can be interrupted by type (6) html blocks</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const blockGfm = {</span><span class="s3">\n    </span><span class="s1">...blockNormal,</span><span class="s3">\n    </span><span class="s1">lheading: lheadingGfm,</span><span class="s3">\n    </span><span class="s1">table: gfmTable,</span><span class="s3">\n    </span><span class="s1">paragraph: edit(_paragraph)</span><span class="s3">\n        </span><span class="s1">.replace('hr', hr)</span><span class="s3">\n        </span><span class="s1">.replace('heading', ' {0,3}#{1,6}(?:</span><span class="s3">\\\\</span><span class="s1">s|$)')</span><span class="s3">\n        </span><span class="s1">.replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs</span><span class="s3">\n        </span><span class="s1">.replace('table', gfmTable) // interrupt paragraphs with table</span><span class="s3">\n        </span><span class="s1">.replace('blockquote', ' {0,3}&gt;')</span><span class="s3">\n        </span><span class="s1">.replace('fences', ' {0,3}(?:`{3,}(?=[^`</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n)|~{3,})[^</span><span class="s3">\\\\</span><span class="s1">n]*</span><span class="s3">\\\\</span><span class="s1">n')</span><span class="s3">\n        </span><span class="s1">.replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt</span><span class="s3">\n        </span><span class="s1">.replace('html', '&lt;/?(?:tag)(?: +|</span><span class="s3">\\\\</span><span class="s1">n|/?&gt;)|&lt;(?:script|pre|style|textarea|!--)')</span><span class="s3">\n        </span><span class="s1">.replace('tag', _tag) // pars can be interrupted by type (6) html blocks</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Pedantic grammar (original John Gruber's loose markdown specification)</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const blockPedantic = {</span><span class="s3">\n    </span><span class="s1">...blockNormal,</span><span class="s3">\n    </span><span class="s1">html: edit('^ *(?:comment *(?:</span><span class="s3">\\\\</span><span class="s1">n|</span><span class="s3">\\\\</span><span class="s1">s*$)'</span><span class="s3">\n        </span><span class="s1">+ '|&lt;(tag)[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]+?&lt;/</span><span class="s3">\\\\</span><span class="s1">1&gt; *(?:</span><span class="s3">\\\\</span><span class="s1">n{2,}|</span><span class="s3">\\\\</span><span class="s1">s*$)' // closed tag</span><span class="s3">\n        </span><span class="s1">+ '|&lt;tag(?:</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]*</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">'[^</span><span class="s3">\\</span><span class="s1">']*</span><span class="s3">\\</span><span class="s1">'|</span><span class="s3">\\\\</span><span class="s1">s[^</span><span class="s3">\\</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">/&gt;</span><span class="s3">\\\\</span><span class="s1">s]*)*?/?&gt; *(?:</span><span class="s3">\\\\</span><span class="s1">n{2,}|</span><span class="s3">\\\\</span><span class="s1">s*$))')</span><span class="s3">\n        </span><span class="s1">.replace('comment', _comment)</span><span class="s3">\n        </span><span class="s1">.replace(/tag/g, '(?!(?:'</span><span class="s3">\n        </span><span class="s1">+ 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'</span><span class="s3">\n        </span><span class="s1">+ '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'</span><span class="s3">\n        </span><span class="s1">+ '</span><span class="s3">\\\\</span><span class="s1">b)</span><span class="s3">\\\\</span><span class="s1">w+(?!:|[^</span><span class="s3">\\\\</span><span class="s1">w</span><span class="s3">\\\\</span><span class="s1">s@]*@)</span><span class="s3">\\\\</span><span class="s1">b')</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n    </span><span class="s1">def: /^ *</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]+)</span><span class="s3">\\</span><span class="s1">]: *&lt;?([^</span><span class="s3">\\</span><span class="s1">s&gt;]+)&gt;?(?: +([</span><span class="s3">\&quot;</span><span class="s1">(][^</span><span class="s3">\\</span><span class="s1">n]+[</span><span class="s3">\&quot;</span><span class="s1">)]))? *(?:</span><span class="s3">\\</span><span class="s1">n+|$)/,</span><span class="s3">\n    </span><span class="s1">heading: /^(#{1,6})(.*)(?:</span><span class="s3">\\</span><span class="s1">n+|$)/,</span><span class="s3">\n    </span><span class="s1">fences: noopTest, // fences not supported</span><span class="s3">\n    </span><span class="s1">lheading: /^(.+?)</span><span class="s3">\\</span><span class="s1">n {0,3}(=+|-+) *(?:</span><span class="s3">\\</span><span class="s1">n+|$)/,</span><span class="s3">\n    </span><span class="s1">paragraph: edit(_paragraph)</span><span class="s3">\n        </span><span class="s1">.replace('hr', hr)</span><span class="s3">\n        </span><span class="s1">.replace('heading', ' *#{1,6} *[^</span><span class="s3">\\</span><span class="s1">n]')</span><span class="s3">\n        </span><span class="s1">.replace('lheading', lheading)</span><span class="s3">\n        </span><span class="s1">.replace('|table', '')</span><span class="s3">\n        </span><span class="s1">.replace('blockquote', ' {0,3}&gt;')</span><span class="s3">\n        </span><span class="s1">.replace('|fences', '')</span><span class="s3">\n        </span><span class="s1">.replace('|list', '')</span><span class="s3">\n        </span><span class="s1">.replace('|html', '')</span><span class="s3">\n        </span><span class="s1">.replace('|tag', '')</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Inline-Level Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const escape$1 = /^</span><span class="s3">\\\\</span><span class="s1">([!</span><span class="s3">\&quot;</span><span class="s1">#$%&amp;'()*+,</span><span class="s3">\\</span><span class="s1">-./:;&lt;=&gt;?@</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">^_`{|}~])/;</span><span class="s3">\n</span><span class="s1">const inlineCode = /^(`+)([^`]|[^`][</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?[^`])</span><span class="s3">\\</span><span class="s1">1(?!`)/;</span><span class="s3">\n</span><span class="s1">const br = /^( {2,}|</span><span class="s3">\\\\</span><span class="s1">)</span><span class="s3">\\</span><span class="s1">n(?!</span><span class="s3">\\</span><span class="s1">s*$)/;</span><span class="s3">\n</span><span class="s1">const inlineText = /^(`+|[^`])(?:(?= {2,}</span><span class="s3">\\</span><span class="s1">n)|[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?(?:(?=[</span><span class="s3">\\\\</span><span class="s1">&lt;!</span><span class="s3">\\</span><span class="s1">[`*_]|</span><span class="s3">\\</span><span class="s1">b_|$)|[^ ](?= {2,}</span><span class="s3">\\</span><span class="s1">n)))/;</span><span class="s3">\n</span><span class="s1">// list of unicode punctuation marks, plus any missing characters from CommonMark spec</span><span class="s3">\n</span><span class="s1">const _punctuation = /[</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]/u;</span><span class="s3">\n</span><span class="s1">const _punctuationOrSpace = /[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]/u;</span><span class="s3">\n</span><span class="s1">const _notPunctuationOrSpace = /[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]/u;</span><span class="s3">\n</span><span class="s1">const punctuation = edit(/^((?![*_])punctSpace)/, 'u')</span><span class="s3">\n    </span><span class="s1">.replace(/punctSpace/g, _punctuationOrSpace).getRegex();</span><span class="s3">\n</span><span class="s1">// GFM allows ~ inside strong and em for strikethrough</span><span class="s3">\n</span><span class="s1">const _punctuationGfmStrongEm = /(?!~)[</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]/u;</span><span class="s3">\n</span><span class="s1">const _punctuationOrSpaceGfmStrongEm = /(?!~)[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]/u;</span><span class="s3">\n</span><span class="s1">const _notPunctuationOrSpaceGfmStrongEm = /(?:[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">p{P}</span><span class="s3">\\</span><span class="s1">p{S}]|~)/u;</span><span class="s3">\n</span><span class="s1">// sequences em should skip over [title](link), `code`, &lt;html&gt;</span><span class="s3">\n</span><span class="s1">const blockSkip = /</span><span class="s3">\\</span><span class="s1">[[^[</span><span class="s3">\\</span><span class="s1">]]*?</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\\\\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">)]|</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\\\\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">)])*</span><span class="s3">\\</span><span class="s1">))*</span><span class="s3">\\</span><span class="s1">)|`[^`]*?`|&lt;[^&lt;&gt;]*?&gt;/g;</span><span class="s3">\n</span><span class="s1">const emStrongLDelimCore = /^(?:</span><span class="s3">\\</span><span class="s1">*+(?:((?!</span><span class="s3">\\</span><span class="s1">*)punct)|[^</span><span class="s3">\\</span><span class="s1">s*]))|^_+(?:((?!_)punct)|([^</span><span class="s3">\\</span><span class="s1">s_]))/;</span><span class="s3">\n</span><span class="s1">const emStrongLDelim = edit(emStrongLDelimCore, 'u')</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuation)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuationGfmStrongEm)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const emStrongRDelimAstCore = '^[^_*]*?__[^_*]*?</span><span class="s3">\\\\</span><span class="s1">*[^_*]*?(?=__)' // Skip orphan inside strong</span><span class="s3">\n    </span><span class="s1">+ '|[^*]+(?=[^*])' // Consume to delim</span><span class="s3">\n    </span><span class="s1">+ '|(?!</span><span class="s3">\\\\</span><span class="s1">*)punct(</span><span class="s3">\\\\</span><span class="s1">*+)(?=[</span><span class="s3">\\\\</span><span class="s1">s]|$)' // (1) #*** can only be a Right Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|notPunctSpace(</span><span class="s3">\\\\</span><span class="s1">*+)(?!</span><span class="s3">\\\\</span><span class="s1">*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|(?!</span><span class="s3">\\\\</span><span class="s1">*)punctSpace(</span><span class="s3">\\\\</span><span class="s1">*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|[</span><span class="s3">\\\\</span><span class="s1">s](</span><span class="s3">\\\\</span><span class="s1">*+)(?!</span><span class="s3">\\\\</span><span class="s1">*)(?=punct)' // (4) ***# can only be Left Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|(?!</span><span class="s3">\\\\</span><span class="s1">*)punct(</span><span class="s3">\\\\</span><span class="s1">*+)(?!</span><span class="s3">\\\\</span><span class="s1">*)(?=punct)' // (5) #***# can be either Left or Right Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|notPunctSpace(</span><span class="s3">\\\\</span><span class="s1">*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter</span><span class="s3">\n</span><span class="s1">const emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')</span><span class="s3">\n    </span><span class="s1">.replace(/notPunctSpace/g, _notPunctuationOrSpace)</span><span class="s3">\n    </span><span class="s1">.replace(/punctSpace/g, _punctuationOrSpace)</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuation)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')</span><span class="s3">\n    </span><span class="s1">.replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)</span><span class="s3">\n    </span><span class="s1">.replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuationGfmStrongEm)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">// (6) Not allowed for _</span><span class="s3">\n</span><span class="s1">const emStrongRDelimUnd = edit('^[^_*]*?</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">*[^_*]*?_[^_*]*?(?=</span><span class="s3">\\\\</span><span class="s1">*</span><span class="s3">\\\\</span><span class="s1">*)' // Skip orphan inside strong</span><span class="s3">\n    </span><span class="s1">+ '|[^_]+(?=[^_])' // Consume to delim</span><span class="s3">\n    </span><span class="s1">+ '|(?!_)punct(_+)(?=[</span><span class="s3">\\\\</span><span class="s1">s]|$)' // (1) #___ can only be a Right Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|[</span><span class="s3">\\\\</span><span class="s1">s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter</span><span class="s3">\n    </span><span class="s1">+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter</span><span class="s3">\n    </span><span class="s1">.replace(/notPunctSpace/g, _notPunctuationOrSpace)</span><span class="s3">\n    </span><span class="s1">.replace(/punctSpace/g, _punctuationOrSpace)</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuation)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const anyPunctuation = edit(/</span><span class="s3">\\\\</span><span class="s1">(punct)/, 'gu')</span><span class="s3">\n    </span><span class="s1">.replace(/punct/g, _punctuation)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const autolink = edit(/^&lt;(scheme:[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x1f&lt;&gt;]*|email)&gt;/)</span><span class="s3">\n    </span><span class="s1">.replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)</span><span class="s3">\n    </span><span class="s1">.replace('email', /[a-zA-Z0-9.!#$%&amp;'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:</span><span class="s3">\\</span><span class="s1">.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const _inlineComment = edit(_comment).replace('(?:--&gt;|$)', '--&gt;').getRegex();</span><span class="s3">\n</span><span class="s1">const tag = edit('^comment'</span><span class="s3">\n    </span><span class="s1">+ '|^&lt;/[a-zA-Z][</span><span class="s3">\\\\</span><span class="s1">w:-]*</span><span class="s3">\\\\</span><span class="s1">s*&gt;' // self-closing tag</span><span class="s3">\n    </span><span class="s1">+ '|^&lt;[a-zA-Z][</span><span class="s3">\\\\</span><span class="s1">w-]*(?:attribute)*?</span><span class="s3">\\\\</span><span class="s1">s*/?&gt;' // open tag</span><span class="s3">\n    </span><span class="s1">+ '|^&lt;</span><span class="s3">\\\\</span><span class="s1">?[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?</span><span class="s3">\\\\</span><span class="s1">?&gt;' // processing instruction, e.g. &lt;?php ?&gt;</span><span class="s3">\n    </span><span class="s1">+ '|^&lt;![a-zA-Z]+</span><span class="s3">\\\\</span><span class="s1">s[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?&gt;' // declaration, e.g. &lt;!DOCTYPE html&gt;</span><span class="s3">\n    </span><span class="s1">+ '|^&lt;!</span><span class="s3">\\\\</span><span class="s1">[CDATA</span><span class="s3">\\\\</span><span class="s1">[[</span><span class="s3">\\\\</span><span class="s1">s</span><span class="s3">\\\\</span><span class="s1">S]*?</span><span class="s3">\\\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">]&gt;') // CDATA section</span><span class="s3">\n    </span><span class="s1">.replace('comment', _inlineComment)</span><span class="s3">\n    </span><span class="s1">.replace('attribute', /</span><span class="s3">\\</span><span class="s1">s+[a-zA-Z:_][</span><span class="s3">\\</span><span class="s1">w.:-]*(?:</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\&quot;</span><span class="s1">[^</span><span class="s3">\&quot;</span><span class="s1">]*</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*'[^']*'|</span><span class="s3">\\</span><span class="s1">s*=</span><span class="s3">\\</span><span class="s1">s*[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\&quot;</span><span class="s1">'=&lt;&gt;`]+)?/)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const _inlineLabel = /(?:</span><span class="s3">\\</span><span class="s1">[(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">])*</span><span class="s3">\\</span><span class="s1">]|</span><span class="s3">\\\\</span><span class="s1">.|`[^`]*`|[^</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\\\</span><span class="s1">`])*?/;</span><span class="s3">\n</span><span class="s1">const link = edit(/^!?</span><span class="s3">\\</span><span class="s1">[(label)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">s*(href)(?:</span><span class="s3">\\</span><span class="s1">s+(title))?</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">)/)</span><span class="s3">\n    </span><span class="s1">.replace('label', _inlineLabel)</span><span class="s3">\n    </span><span class="s1">.replace('href', /&lt;(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">n&lt;&gt;</span><span class="s3">\\\\</span><span class="s1">])+&gt;|[^</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">x00-</span><span class="s3">\\</span><span class="s1">x1f]*/)</span><span class="s3">\n    </span><span class="s1">.replace('title', /</span><span class="s3">\&quot;</span><span class="s1">(?:</span><span class="s3">\\\\\&quot;</span><span class="s1">?|[^</span><span class="s3">\&quot;\\\\</span><span class="s1">])*</span><span class="s3">\&quot;</span><span class="s1">|'(?:</span><span class="s3">\\\\</span><span class="s1">'?|[^'</span><span class="s3">\\\\</span><span class="s1">])*'|</span><span class="s3">\\</span><span class="s1">((?:</span><span class="s3">\\\\\\</span><span class="s1">)?|[^)</span><span class="s3">\\\\</span><span class="s1">])*</span><span class="s3">\\</span><span class="s1">)/)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const reflink = edit(/^!?</span><span class="s3">\\</span><span class="s1">[(label)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">[(ref)</span><span class="s3">\\</span><span class="s1">]/)</span><span class="s3">\n    </span><span class="s1">.replace('label', _inlineLabel)</span><span class="s3">\n    </span><span class="s1">.replace('ref', _blockLabel)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const nolink = edit(/^!?</span><span class="s3">\\</span><span class="s1">[(ref)</span><span class="s3">\\</span><span class="s1">](?:</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">])?/)</span><span class="s3">\n    </span><span class="s1">.replace('ref', _blockLabel)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">const reflinkSearch = edit('reflink|nolink(?!</span><span class="s3">\\\\</span><span class="s1">()', 'g')</span><span class="s3">\n    </span><span class="s1">.replace('reflink', reflink)</span><span class="s3">\n    </span><span class="s1">.replace('nolink', nolink)</span><span class="s3">\n    </span><span class="s1">.getRegex();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Normal Inline Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const inlineNormal = {</span><span class="s3">\n    </span><span class="s1">_backpedal: noopTest, // only used for GFM url</span><span class="s3">\n    </span><span class="s1">anyPunctuation,</span><span class="s3">\n    </span><span class="s1">autolink,</span><span class="s3">\n    </span><span class="s1">blockSkip,</span><span class="s3">\n    </span><span class="s1">br,</span><span class="s3">\n    </span><span class="s1">code: inlineCode,</span><span class="s3">\n    </span><span class="s1">del: noopTest,</span><span class="s3">\n    </span><span class="s1">emStrongLDelim,</span><span class="s3">\n    </span><span class="s1">emStrongRDelimAst,</span><span class="s3">\n    </span><span class="s1">emStrongRDelimUnd,</span><span class="s3">\n    </span><span class="s1">escape: escape$1,</span><span class="s3">\n    </span><span class="s1">link,</span><span class="s3">\n    </span><span class="s1">nolink,</span><span class="s3">\n    </span><span class="s1">punctuation,</span><span class="s3">\n    </span><span class="s1">reflink,</span><span class="s3">\n    </span><span class="s1">reflinkSearch,</span><span class="s3">\n    </span><span class="s1">tag,</span><span class="s3">\n    </span><span class="s1">text: inlineText,</span><span class="s3">\n    </span><span class="s1">url: noopTest,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Pedantic Inline Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const inlinePedantic = {</span><span class="s3">\n    </span><span class="s1">...inlineNormal,</span><span class="s3">\n    </span><span class="s1">link: edit(/^!?</span><span class="s3">\\</span><span class="s1">[(label)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">((.*?)</span><span class="s3">\\</span><span class="s1">)/)</span><span class="s3">\n        </span><span class="s1">.replace('label', _inlineLabel)</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n    </span><span class="s1">reflink: edit(/^!?</span><span class="s3">\\</span><span class="s1">[(label)</span><span class="s3">\\</span><span class="s1">]</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">[([^</span><span class="s3">\\</span><span class="s1">]]*)</span><span class="s3">\\</span><span class="s1">]/)</span><span class="s3">\n        </span><span class="s1">.replace('label', _inlineLabel)</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* GFM Inline Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const inlineGfm = {</span><span class="s3">\n    </span><span class="s1">...inlineNormal,</span><span class="s3">\n    </span><span class="s1">emStrongRDelimAst: emStrongRDelimAstGfm,</span><span class="s3">\n    </span><span class="s1">emStrongLDelim: emStrongLDelimGfm,</span><span class="s3">\n    </span><span class="s1">url: edit(/^((?:ftp|https?):</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/|www</span><span class="s3">\\</span><span class="s1">.)(?:[a-zA-Z0-9</span><span class="s3">\\</span><span class="s1">-]+</span><span class="s3">\\</span><span class="s1">.?)+[^</span><span class="s3">\\</span><span class="s1">s&lt;]*|^email/, 'i')</span><span class="s3">\n        </span><span class="s1">.replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:</span><span class="s3">\\</span><span class="s1">.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n    </span><span class="s1">_backpedal: /(?:[^?!.,:;*_'</span><span class="s3">\&quot;</span><span class="s1">~()&amp;]+|</span><span class="s3">\\</span><span class="s1">([^)]*</span><span class="s3">\\</span><span class="s1">)|&amp;(?![a-zA-Z0-9]+;$)|[?!.,:;*_'</span><span class="s3">\&quot;</span><span class="s1">~)]+(?!$))+/,</span><span class="s3">\n    </span><span class="s1">del: /^(~~?)(?=[^</span><span class="s3">\\</span><span class="s1">s~])((?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\\\</span><span class="s1">])*?(?:</span><span class="s3">\\\\</span><span class="s1">.|[^</span><span class="s3">\\</span><span class="s1">s~</span><span class="s3">\\\\</span><span class="s1">]))</span><span class="s3">\\</span><span class="s1">1(?=[^~]|$)/,</span><span class="s3">\n    </span><span class="s1">text: /^([`~]+|[^`~])(?:(?= {2,}</span><span class="s3">\\</span><span class="s1">n)|(?=[a-zA-Z0-9.!#$%&amp;'*+</span><span class="s3">\\</span><span class="s1">/=?_`{</span><span class="s3">\\</span><span class="s1">|}~-]+@)|[</span><span class="s3">\\</span><span class="s1">s</span><span class="s3">\\</span><span class="s1">S]*?(?:(?=[</span><span class="s3">\\\\</span><span class="s1">&lt;!</span><span class="s3">\\</span><span class="s1">[`*~_]|</span><span class="s3">\\</span><span class="s1">b_|https?:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/|ftp:</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">/|www</span><span class="s3">\\</span><span class="s1">.|$)|[^ ](?= {2,}</span><span class="s3">\\</span><span class="s1">n)|[^a-zA-Z0-9.!#$%&amp;'*+</span><span class="s3">\\</span><span class="s1">/=?_`{</span><span class="s3">\\</span><span class="s1">|}~-](?=[a-zA-Z0-9.!#$%&amp;'*+</span><span class="s3">\\</span><span class="s1">/=?_`{</span><span class="s3">\\</span><span class="s1">|}~-]+@)))/,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* GFM + Line Breaks Inline Grammar</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const inlineBreaks = {</span><span class="s3">\n    </span><span class="s1">...inlineGfm,</span><span class="s3">\n    </span><span class="s1">br: edit(br).replace('{2,}', '*').getRegex(),</span><span class="s3">\n    </span><span class="s1">text: edit(inlineGfm.text)</span><span class="s3">\n        </span><span class="s1">.replace('</span><span class="s3">\\\\</span><span class="s1">b_', '</span><span class="s3">\\\\</span><span class="s1">b_| {2,}</span><span class="s3">\\\\</span><span class="s1">n')</span><span class="s3">\n        </span><span class="s1">.replace(/</span><span class="s3">\\</span><span class="s1">{2,</span><span class="s3">\\</span><span class="s1">}/g, '*')</span><span class="s3">\n        </span><span class="s1">.getRegex(),</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* exports</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const block = {</span><span class="s3">\n    </span><span class="s1">normal: blockNormal,</span><span class="s3">\n    </span><span class="s1">gfm: blockGfm,</span><span class="s3">\n    </span><span class="s1">pedantic: blockPedantic,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const inline = {</span><span class="s3">\n    </span><span class="s1">normal: inlineNormal,</span><span class="s3">\n    </span><span class="s1">gfm: inlineGfm,</span><span class="s3">\n    </span><span class="s1">breaks: inlineBreaks,</span><span class="s3">\n    </span><span class="s1">pedantic: inlinePedantic,</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Helpers</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const escapeReplacements = {</span><span class="s3">\n    </span><span class="s1">'&amp;': '&amp;amp;',</span><span class="s3">\n    </span><span class="s1">'&lt;': '&amp;lt;',</span><span class="s3">\n    </span><span class="s1">'&gt;': '&amp;gt;',</span><span class="s3">\n    </span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">': '&amp;quot;',</span><span class="s3">\n    \&quot;</span><span class="s1">'</span><span class="s3">\&quot;</span><span class="s1">: '&amp;#39;',</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">const getEscapeReplacement = (ch) =&gt; escapeReplacements[ch];</span><span class="s3">\n</span><span class="s1">function escape(html, encode) {</span><span class="s3">\n    </span><span class="s1">if (encode) {</span><span class="s3">\n        </span><span class="s1">if (other.escapeTest.test(html)) {</span><span class="s3">\n            </span><span class="s1">return html.replace(other.escapeReplace, getEscapeReplacement);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">if (other.escapeTestNoEncode.test(html)) {</span><span class="s3">\n            </span><span class="s1">return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return html;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cleanUrl(href) {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">href = encodeURI(href).replace(other.percentDecode, '%');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">catch {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return href;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function splitCells(tableRow, count) {</span><span class="s3">\n    </span><span class="s1">// ensure that every cell-delimiting pipe has a space</span><span class="s3">\n    </span><span class="s1">// before it to distinguish it from an escaped pipe</span><span class="s3">\n    </span><span class="s1">const row = tableRow.replace(other.findPipe, (match, offset, str) =&gt; {</span><span class="s3">\n        </span><span class="s1">let escaped = false;</span><span class="s3">\n        </span><span class="s1">let curr = offset;</span><span class="s3">\n        </span><span class="s1">while (--curr &gt;= 0 &amp;&amp; str[curr] === '</span><span class="s3">\\\\</span><span class="s1">')</span><span class="s3">\n            </span><span class="s1">escaped = !escaped;</span><span class="s3">\n        </span><span class="s1">if (escaped) {</span><span class="s3">\n            </span><span class="s1">// odd number of slashes means | is escaped</span><span class="s3">\n            </span><span class="s1">// so we leave it alone</span><span class="s3">\n            </span><span class="s1">return '|';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">// add space before unescaped |</span><span class="s3">\n            </span><span class="s1">return ' |';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}), cells = row.split(other.splitPipe);</span><span class="s3">\n    </span><span class="s1">let i = 0;</span><span class="s3">\n    </span><span class="s1">// First/last cell in a row cannot be empty if it has no leading/trailing pipe</span><span class="s3">\n    </span><span class="s1">if (!cells[0].trim()) {</span><span class="s3">\n        </span><span class="s1">cells.shift();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (cells.length &gt; 0 &amp;&amp; !cells.at(-1)?.trim()) {</span><span class="s3">\n        </span><span class="s1">cells.pop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (count) {</span><span class="s3">\n        </span><span class="s1">if (cells.length &gt; count) {</span><span class="s3">\n            </span><span class="s1">cells.splice(count);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">while (cells.length &lt; count)</span><span class="s3">\n                </span><span class="s1">cells.push('');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (; i &lt; cells.length; i++) {</span><span class="s3">\n        </span><span class="s1">// leading or trailing whitespace is ignored per the gfm spec</span><span class="s3">\n        </span><span class="s1">cells[i] = cells[i].trim().replace(other.slashPipe, '|');</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cells;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').</span><span class="s3">\n </span><span class="s1">* /c*$/ is vulnerable to REDOS.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param str</span><span class="s3">\n </span><span class="s1">* @param c</span><span class="s3">\n </span><span class="s1">* @param invert Remove suffix of non-c chars instead. Default falsey.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function rtrim(str, c, invert) {</span><span class="s3">\n    </span><span class="s1">const l = str.length;</span><span class="s3">\n    </span><span class="s1">if (l === 0) {</span><span class="s3">\n        </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Length of suffix matching the invert condition.</span><span class="s3">\n    </span><span class="s1">let suffLen = 0;</span><span class="s3">\n    </span><span class="s1">// Step left until we fail to match the invert condition.</span><span class="s3">\n    </span><span class="s1">while (suffLen &lt; l) {</span><span class="s3">\n        </span><span class="s1">const currChar = str.charAt(l - suffLen - 1);</span><span class="s3">\n        </span><span class="s1">if (currChar === c &amp;&amp; true) {</span><span class="s3">\n            </span><span class="s1">suffLen++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return str.slice(0, l - suffLen);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findClosingBracket(str, b) {</span><span class="s3">\n    </span><span class="s1">if (str.indexOf(b[1]) === -1) {</span><span class="s3">\n        </span><span class="s1">return -1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let level = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; str.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (str[i] === '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (str[i] === b[0]) {</span><span class="s3">\n            </span><span class="s1">level++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (str[i] === b[1]) {</span><span class="s3">\n            </span><span class="s1">level--;</span><span class="s3">\n            </span><span class="s1">if (level &lt; 0) {</span><span class="s3">\n                </span><span class="s1">return i;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function outputLink(cap, link, raw, lexer, rules) {</span><span class="s3">\n    </span><span class="s1">const href = link.href;</span><span class="s3">\n    </span><span class="s1">const title = link.title || null;</span><span class="s3">\n    </span><span class="s1">const text = cap[1].replace(rules.other.outputLinkReplace, '$1');</span><span class="s3">\n    </span><span class="s1">if (cap[0].charAt(0) !== '!') {</span><span class="s3">\n        </span><span class="s1">lexer.state.inLink = true;</span><span class="s3">\n        </span><span class="s1">const token = {</span><span class="s3">\n            </span><span class="s1">type: 'link',</span><span class="s3">\n            </span><span class="s1">raw,</span><span class="s3">\n            </span><span class="s1">href,</span><span class="s3">\n            </span><span class="s1">title,</span><span class="s3">\n            </span><span class="s1">text,</span><span class="s3">\n            </span><span class="s1">tokens: lexer.inlineTokens(text),</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">lexer.state.inLink = false;</span><span class="s3">\n        </span><span class="s1">return token;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">type: 'image',</span><span class="s3">\n        </span><span class="s1">raw,</span><span class="s3">\n        </span><span class="s1">href,</span><span class="s3">\n        </span><span class="s1">title,</span><span class="s3">\n        </span><span class="s1">text,</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function indentCodeCompensation(raw, text, rules) {</span><span class="s3">\n    </span><span class="s1">const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);</span><span class="s3">\n    </span><span class="s1">if (matchIndentToCode === null) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const indentToCode = matchIndentToCode[1];</span><span class="s3">\n    </span><span class="s1">return text</span><span class="s3">\n        </span><span class="s1">.split('</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n        </span><span class="s1">.map(node =&gt; {</span><span class="s3">\n        </span><span class="s1">const matchIndentInNode = node.match(rules.other.beginningSpace);</span><span class="s3">\n        </span><span class="s1">if (matchIndentInNode === null) {</span><span class="s3">\n            </span><span class="s1">return node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const [indentInNode] = matchIndentInNode;</span><span class="s3">\n        </span><span class="s1">if (indentInNode.length &gt;= indentToCode.length) {</span><span class="s3">\n            </span><span class="s1">return node.slice(indentToCode.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return node;</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n        </span><span class="s1">.join('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Tokenizer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class _Tokenizer {</span><span class="s3">\n    </span><span class="s1">options;</span><span class="s3">\n    </span><span class="s1">rules; // set by the lexer</span><span class="s3">\n    </span><span class="s1">lexer; // set by the lexer</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this.options = options || _defaults;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">space(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.newline.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap &amp;&amp; cap[0].length &gt; 0) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'space',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">code(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.code.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'code',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">codeBlockStyle: 'indented',</span><span class="s3">\n                </span><span class="s1">text: !this.options.pedantic</span><span class="s3">\n                    </span><span class="s1">? rtrim(text, '</span><span class="s3">\\</span><span class="s1">n')</span><span class="s3">\n                    </span><span class="s1">: text,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">fences(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.fences.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const raw = cap[0];</span><span class="s3">\n            </span><span class="s1">const text = indentCodeCompensation(raw, cap[3] || '', this.rules);</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'code',</span><span class="s3">\n                </span><span class="s1">raw,</span><span class="s3">\n                </span><span class="s1">lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">heading(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.heading.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">let text = cap[2].trim();</span><span class="s3">\n            </span><span class="s1">// remove trailing #s</span><span class="s3">\n            </span><span class="s1">if (this.rules.other.endingHash.test(text)) {</span><span class="s3">\n                </span><span class="s1">const trimmed = rtrim(text, '#');</span><span class="s3">\n                </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n                    </span><span class="s1">text = trimmed.trim();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {</span><span class="s3">\n                    </span><span class="s1">// CommonMark requires space before trailing #s</span><span class="s3">\n                    </span><span class="s1">text = trimmed.trim();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'heading',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">depth: cap[1].length,</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inline(text),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hr(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.hr.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'hr',</span><span class="s3">\n                </span><span class="s1">raw: rtrim(cap[0], '</span><span class="s3">\\</span><span class="s1">n'),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockquote(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.blockquote.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">let lines = rtrim(cap[0], '</span><span class="s3">\\</span><span class="s1">n').split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n            </span><span class="s1">let raw = '';</span><span class="s3">\n            </span><span class="s1">let text = '';</span><span class="s3">\n            </span><span class="s1">const tokens = [];</span><span class="s3">\n            </span><span class="s1">while (lines.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">let inBlockquote = false;</span><span class="s3">\n                </span><span class="s1">const currentLines = [];</span><span class="s3">\n                </span><span class="s1">let i;</span><span class="s3">\n                </span><span class="s1">for (i = 0; i &lt; lines.length; i++) {</span><span class="s3">\n                    </span><span class="s1">// get lines up to a continuation</span><span class="s3">\n                    </span><span class="s1">if (this.rules.other.blockquoteStart.test(lines[i])) {</span><span class="s3">\n                        </span><span class="s1">currentLines.push(lines[i]);</span><span class="s3">\n                        </span><span class="s1">inBlockquote = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (!inBlockquote) {</span><span class="s3">\n                        </span><span class="s1">currentLines.push(lines[i]);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">break;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">lines = lines.slice(i);</span><span class="s3">\n                </span><span class="s1">const currentRaw = currentLines.join('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n                </span><span class="s1">const currentText = currentRaw</span><span class="s3">\n                    </span><span class="s1">// precede setext continuation with 4 spaces so it isn't a setext</span><span class="s3">\n                    </span><span class="s1">.replace(this.rules.other.blockquoteSetextReplace, '</span><span class="s3">\\</span><span class="s1">n    $1')</span><span class="s3">\n                    </span><span class="s1">.replace(this.rules.other.blockquoteSetextReplace2, '');</span><span class="s3">\n                </span><span class="s1">raw = raw ? `${raw}</span><span class="s3">\\</span><span class="s1">n${currentRaw}` : currentRaw;</span><span class="s3">\n                </span><span class="s1">text = text ? `${text}</span><span class="s3">\\</span><span class="s1">n${currentText}` : currentText;</span><span class="s3">\n                </span><span class="s1">// parse blockquote lines as top level tokens</span><span class="s3">\n                </span><span class="s1">// merge paragraphs if this is a continuation</span><span class="s3">\n                </span><span class="s1">const top = this.lexer.state.top;</span><span class="s3">\n                </span><span class="s1">this.lexer.state.top = true;</span><span class="s3">\n                </span><span class="s1">this.lexer.blockTokens(currentText, tokens, true);</span><span class="s3">\n                </span><span class="s1">this.lexer.state.top = top;</span><span class="s3">\n                </span><span class="s1">// if there is no continuation then we are done</span><span class="s3">\n                </span><span class="s1">if (lines.length === 0) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (lastToken?.type === 'code') {</span><span class="s3">\n                    </span><span class="s1">// blockquote continuation cannot be preceded by a code block</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (lastToken?.type === 'blockquote') {</span><span class="s3">\n                    </span><span class="s1">// include continuation in nested blockquote</span><span class="s3">\n                    </span><span class="s1">const oldToken = lastToken;</span><span class="s3">\n                    </span><span class="s1">const newText = oldToken.raw + '</span><span class="s3">\\</span><span class="s1">n' + lines.join('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n                    </span><span class="s1">const newToken = this.blockquote(newText);</span><span class="s3">\n                    </span><span class="s1">tokens[tokens.length - 1] = newToken;</span><span class="s3">\n                    </span><span class="s1">raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;</span><span class="s3">\n                    </span><span class="s1">text = text.substring(0, text.length - oldToken.text.length) + newToken.text;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (lastToken?.type === 'list') {</span><span class="s3">\n                    </span><span class="s1">// include continuation in nested list</span><span class="s3">\n                    </span><span class="s1">const oldToken = lastToken;</span><span class="s3">\n                    </span><span class="s1">const newText = oldToken.raw + '</span><span class="s3">\\</span><span class="s1">n' + lines.join('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n                    </span><span class="s1">const newToken = this.list(newText);</span><span class="s3">\n                    </span><span class="s1">tokens[tokens.length - 1] = newToken;</span><span class="s3">\n                    </span><span class="s1">raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;</span><span class="s3">\n                    </span><span class="s1">text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;</span><span class="s3">\n                    </span><span class="s1">lines = newText.substring(tokens.at(-1).raw.length).split('</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'blockquote',</span><span class="s3">\n                </span><span class="s1">raw,</span><span class="s3">\n                </span><span class="s1">tokens,</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">list(src) {</span><span class="s3">\n        </span><span class="s1">let cap = this.rules.block.list.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">let bull = cap[1].trim();</span><span class="s3">\n            </span><span class="s1">const isordered = bull.length &gt; 1;</span><span class="s3">\n            </span><span class="s1">const list = {</span><span class="s3">\n                </span><span class="s1">type: 'list',</span><span class="s3">\n                </span><span class="s1">raw: '',</span><span class="s3">\n                </span><span class="s1">ordered: isordered,</span><span class="s3">\n                </span><span class="s1">start: isordered ? +bull.slice(0, -1) : '',</span><span class="s3">\n                </span><span class="s1">loose: false,</span><span class="s3">\n                </span><span class="s1">items: [],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">bull = isordered ? `</span><span class="s3">\\\\</span><span class="s1">d{1,9}</span><span class="s3">\\\\</span><span class="s1">${bull.slice(-1)}` : `</span><span class="s3">\\\\</span><span class="s1">${bull}`;</span><span class="s3">\n            </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n                </span><span class="s1">bull = isordered ? bull : '[*+-]';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Get next list item</span><span class="s3">\n            </span><span class="s1">const itemRegex = this.rules.other.listItemRegex(bull);</span><span class="s3">\n            </span><span class="s1">let endsWithBlankLine = false;</span><span class="s3">\n            </span><span class="s1">// Check if current bullet point can start a new List Item</span><span class="s3">\n            </span><span class="s1">while (src) {</span><span class="s3">\n                </span><span class="s1">let endEarly = false;</span><span class="s3">\n                </span><span class="s1">let raw = '';</span><span class="s3">\n                </span><span class="s1">let itemContents = '';</span><span class="s3">\n                </span><span class="s1">if (!(cap = itemRegex.exec(src))) {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">raw = cap[0];</span><span class="s3">\n                </span><span class="s1">src = src.substring(raw.length);</span><span class="s3">\n                </span><span class="s1">let line = cap[2].split('</span><span class="s3">\\</span><span class="s1">n', 1)[0].replace(this.rules.other.listReplaceTabs, (t) =&gt; ' '.repeat(3 * t.length));</span><span class="s3">\n                </span><span class="s1">let nextLine = src.split('</span><span class="s3">\\</span><span class="s1">n', 1)[0];</span><span class="s3">\n                </span><span class="s1">let blankLine = !line.trim();</span><span class="s3">\n                </span><span class="s1">let indent = 0;</span><span class="s3">\n                </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n                    </span><span class="s1">indent = 2;</span><span class="s3">\n                    </span><span class="s1">itemContents = line.trimStart();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (blankLine) {</span><span class="s3">\n                    </span><span class="s1">indent = cap[1].length + 1;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char</span><span class="s3">\n                    </span><span class="s1">indent = indent &gt; 4 ? 1 : indent; // Treat indented code blocks (&gt; 4 spaces) as having only 1 indent</span><span class="s3">\n                    </span><span class="s1">itemContents = line.slice(indent);</span><span class="s3">\n                    </span><span class="s1">indent += cap[1].length;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (blankLine &amp;&amp; this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line</span><span class="s3">\n                    </span><span class="s1">raw += nextLine + '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                    </span><span class="s1">src = src.substring(nextLine.length + 1);</span><span class="s3">\n                    </span><span class="s1">endEarly = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!endEarly) {</span><span class="s3">\n                    </span><span class="s1">const nextBulletRegex = this.rules.other.nextBulletRegex(indent);</span><span class="s3">\n                    </span><span class="s1">const hrRegex = this.rules.other.hrRegex(indent);</span><span class="s3">\n                    </span><span class="s1">const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);</span><span class="s3">\n                    </span><span class="s1">const headingBeginRegex = this.rules.other.headingBeginRegex(indent);</span><span class="s3">\n                    </span><span class="s1">const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);</span><span class="s3">\n                    </span><span class="s1">// Check if following lines should be included in List Item</span><span class="s3">\n                    </span><span class="s1">while (src) {</span><span class="s3">\n                        </span><span class="s1">const rawLine = src.split('</span><span class="s3">\\</span><span class="s1">n', 1)[0];</span><span class="s3">\n                        </span><span class="s1">let nextLineWithoutTabs;</span><span class="s3">\n                        </span><span class="s1">nextLine = rawLine;</span><span class="s3">\n                        </span><span class="s1">// Re-align to follow commonmark nesting rules</span><span class="s3">\n                        </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n                            </span><span class="s1">nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');</span><span class="s3">\n                            </span><span class="s1">nextLineWithoutTabs = nextLine;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">// End list item if found code fences</span><span class="s3">\n                        </span><span class="s1">if (fencesBeginRegex.test(nextLine)) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">// End list item if found start of new heading</span><span class="s3">\n                        </span><span class="s1">if (headingBeginRegex.test(nextLine)) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">// End list item if found start of html block</span><span class="s3">\n                        </span><span class="s1">if (htmlBeginRegex.test(nextLine)) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">// End list item if found start of new bullet</span><span class="s3">\n                        </span><span class="s1">if (nextBulletRegex.test(nextLine)) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">// Horizontal rule found</span><span class="s3">\n                        </span><span class="s1">if (hrRegex.test(nextLine)) {</span><span class="s3">\n                            </span><span class="s1">break;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) &gt;= indent || !nextLine.trim()) { // Dedent if possible</span><span class="s3">\n                            </span><span class="s1">itemContents += '</span><span class="s3">\\</span><span class="s1">n' + nextLineWithoutTabs.slice(indent);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">// not enough indentation</span><span class="s3">\n                            </span><span class="s1">if (blankLine) {</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">// paragraph continuation unless last line was a different block level element</span><span class="s3">\n                            </span><span class="s1">if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) &gt;= 4) { // indented code block</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">if (fencesBeginRegex.test(line)) {</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">if (headingBeginRegex.test(line)) {</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">if (hrRegex.test(line)) {</span><span class="s3">\n                                </span><span class="s1">break;</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">itemContents += '</span><span class="s3">\\</span><span class="s1">n' + nextLine;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (!blankLine &amp;&amp; !nextLine.trim()) { // Check if current line is blank</span><span class="s3">\n                            </span><span class="s1">blankLine = true;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">raw += rawLine + '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                        </span><span class="s1">src = src.substring(rawLine.length + 1);</span><span class="s3">\n                        </span><span class="s1">line = nextLineWithoutTabs.slice(indent);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (!list.loose) {</span><span class="s3">\n                    </span><span class="s1">// If the previous item ended with a blank line, the list is loose</span><span class="s3">\n                    </span><span class="s1">if (endsWithBlankLine) {</span><span class="s3">\n                        </span><span class="s1">list.loose = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (this.rules.other.doubleBlankLine.test(raw)) {</span><span class="s3">\n                        </span><span class="s1">endsWithBlankLine = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let istask = null;</span><span class="s3">\n                </span><span class="s1">let ischecked;</span><span class="s3">\n                </span><span class="s1">// Check for task list items</span><span class="s3">\n                </span><span class="s1">if (this.options.gfm) {</span><span class="s3">\n                    </span><span class="s1">istask = this.rules.other.listIsTask.exec(itemContents);</span><span class="s3">\n                    </span><span class="s1">if (istask) {</span><span class="s3">\n                        </span><span class="s1">ischecked = istask[0] !== '[ ] ';</span><span class="s3">\n                        </span><span class="s1">itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">list.items.push({</span><span class="s3">\n                    </span><span class="s1">type: 'list_item',</span><span class="s3">\n                    </span><span class="s1">raw,</span><span class="s3">\n                    </span><span class="s1">task: !!istask,</span><span class="s3">\n                    </span><span class="s1">checked: ischecked,</span><span class="s3">\n                    </span><span class="s1">loose: false,</span><span class="s3">\n                    </span><span class="s1">text: itemContents,</span><span class="s3">\n                    </span><span class="s1">tokens: [],</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">list.raw += raw;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic</span><span class="s3">\n            </span><span class="s1">const lastItem = list.items.at(-1);</span><span class="s3">\n            </span><span class="s1">if (lastItem) {</span><span class="s3">\n                </span><span class="s1">lastItem.raw = lastItem.raw.trimEnd();</span><span class="s3">\n                </span><span class="s1">lastItem.text = lastItem.text.trimEnd();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// not a list since there were no items</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">list.raw = list.raw.trimEnd();</span><span class="s3">\n            </span><span class="s1">// Item child tokens handled here at end because we needed to have the final item to trim it first</span><span class="s3">\n            </span><span class="s1">for (let i = 0; i &lt; list.items.length; i++) {</span><span class="s3">\n                </span><span class="s1">this.lexer.state.top = false;</span><span class="s3">\n                </span><span class="s1">list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);</span><span class="s3">\n                </span><span class="s1">if (!list.loose) {</span><span class="s3">\n                    </span><span class="s1">// Check if list should be loose</span><span class="s3">\n                    </span><span class="s1">const spacers = list.items[i].tokens.filter(t =&gt; t.type === 'space');</span><span class="s3">\n                    </span><span class="s1">const hasMultipleLineBreaks = spacers.length &gt; 0 &amp;&amp; spacers.some(t =&gt; this.rules.other.anyLine.test(t.raw));</span><span class="s3">\n                    </span><span class="s1">list.loose = hasMultipleLineBreaks;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// Set all items to loose if list is loose</span><span class="s3">\n            </span><span class="s1">if (list.loose) {</span><span class="s3">\n                </span><span class="s1">for (let i = 0; i &lt; list.items.length; i++) {</span><span class="s3">\n                    </span><span class="s1">list.items[i].loose = true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return list;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">html(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.html.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const token = {</span><span class="s3">\n                </span><span class="s1">type: 'html',</span><span class="s3">\n                </span><span class="s1">block: true,</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',</span><span class="s3">\n                </span><span class="s1">text: cap[0],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">return token;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">def(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.def.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');</span><span class="s3">\n            </span><span class="s1">const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';</span><span class="s3">\n            </span><span class="s1">const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'def',</span><span class="s3">\n                </span><span class="s1">tag,</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">href,</span><span class="s3">\n                </span><span class="s1">title,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">table(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.table.exec(src);</span><span class="s3">\n        </span><span class="s1">if (!cap) {</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!this.rules.other.tableDelimiter.test(cap[2])) {</span><span class="s3">\n            </span><span class="s1">// delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const headers = splitCells(cap[1]);</span><span class="s3">\n        </span><span class="s1">const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');</span><span class="s3">\n        </span><span class="s1">const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('</span><span class="s3">\\</span><span class="s1">n') : [];</span><span class="s3">\n        </span><span class="s1">const item = {</span><span class="s3">\n            </span><span class="s1">type: 'table',</span><span class="s3">\n            </span><span class="s1">raw: cap[0],</span><span class="s3">\n            </span><span class="s1">header: [],</span><span class="s3">\n            </span><span class="s1">align: [],</span><span class="s3">\n            </span><span class="s1">rows: [],</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (headers.length !== aligns.length) {</span><span class="s3">\n            </span><span class="s1">// header and align columns must be equal, rows can be different.</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const align of aligns) {</span><span class="s3">\n            </span><span class="s1">if (this.rules.other.tableAlignRight.test(align)) {</span><span class="s3">\n                </span><span class="s1">item.align.push('right');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.rules.other.tableAlignCenter.test(align)) {</span><span class="s3">\n                </span><span class="s1">item.align.push('center');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.rules.other.tableAlignLeft.test(align)) {</span><span class="s3">\n                </span><span class="s1">item.align.push('left');</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">item.align.push(null);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; headers.length; i++) {</span><span class="s3">\n            </span><span class="s1">item.header.push({</span><span class="s3">\n                </span><span class="s1">text: headers[i],</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inline(headers[i]),</span><span class="s3">\n                </span><span class="s1">header: true,</span><span class="s3">\n                </span><span class="s1">align: item.align[i],</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (const row of rows) {</span><span class="s3">\n            </span><span class="s1">item.rows.push(splitCells(row, item.header.length).map((cell, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">text: cell,</span><span class="s3">\n                    </span><span class="s1">tokens: this.lexer.inline(cell),</span><span class="s3">\n                    </span><span class="s1">header: false,</span><span class="s3">\n                    </span><span class="s1">align: item.align[i],</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return item;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lheading(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.lheading.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'heading',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">depth: cap[2].charAt(0) === '=' ? 1 : 2,</span><span class="s3">\n                </span><span class="s1">text: cap[1],</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inline(cap[1]),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">paragraph(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.paragraph.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const text = cap[1].charAt(cap[1].length - 1) === '</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n                </span><span class="s1">? cap[1].slice(0, -1)</span><span class="s3">\n                </span><span class="s1">: cap[1];</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'paragraph',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inline(text),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">text(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.block.text.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'text',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text: cap[0],</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inline(cap[0]),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">escape(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.escape.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'escape',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text: cap[1],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tag(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.tag.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">if (!this.lexer.state.inLink &amp;&amp; this.rules.other.startATag.test(cap[0])) {</span><span class="s3">\n                </span><span class="s1">this.lexer.state.inLink = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.lexer.state.inLink &amp;&amp; this.rules.other.endATag.test(cap[0])) {</span><span class="s3">\n                </span><span class="s1">this.lexer.state.inLink = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (!this.lexer.state.inRawBlock &amp;&amp; this.rules.other.startPreScriptTag.test(cap[0])) {</span><span class="s3">\n                </span><span class="s1">this.lexer.state.inRawBlock = true;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.lexer.state.inRawBlock &amp;&amp; this.rules.other.endPreScriptTag.test(cap[0])) {</span><span class="s3">\n                </span><span class="s1">this.lexer.state.inRawBlock = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'html',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">inLink: this.lexer.state.inLink,</span><span class="s3">\n                </span><span class="s1">inRawBlock: this.lexer.state.inRawBlock,</span><span class="s3">\n                </span><span class="s1">block: false,</span><span class="s3">\n                </span><span class="s1">text: cap[0],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">link(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.link.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const trimmedUrl = cap[2].trim();</span><span class="s3">\n            </span><span class="s1">if (!this.options.pedantic &amp;&amp; this.rules.other.startAngleBracket.test(trimmedUrl)) {</span><span class="s3">\n                </span><span class="s1">// commonmark requires matching angle brackets</span><span class="s3">\n                </span><span class="s1">if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// ending angle bracket cannot be escaped</span><span class="s3">\n                </span><span class="s1">const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '</span><span class="s3">\\\\</span><span class="s1">');</span><span class="s3">\n                </span><span class="s1">if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// find closing parenthesis</span><span class="s3">\n                </span><span class="s1">const lastParenIndex = findClosingBracket(cap[2], '()');</span><span class="s3">\n                </span><span class="s1">if (lastParenIndex &gt; -1) {</span><span class="s3">\n                    </span><span class="s1">const start = cap[0].indexOf('!') === 0 ? 5 : 4;</span><span class="s3">\n                    </span><span class="s1">const linkLen = start + cap[1].length + lastParenIndex;</span><span class="s3">\n                    </span><span class="s1">cap[2] = cap[2].substring(0, lastParenIndex);</span><span class="s3">\n                    </span><span class="s1">cap[0] = cap[0].substring(0, linkLen).trim();</span><span class="s3">\n                    </span><span class="s1">cap[3] = '';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let href = cap[2];</span><span class="s3">\n            </span><span class="s1">let title = '';</span><span class="s3">\n            </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n                </span><span class="s1">// split pedantic href and title</span><span class="s3">\n                </span><span class="s1">const link = this.rules.other.pedanticHrefTitle.exec(href);</span><span class="s3">\n                </span><span class="s1">if (link) {</span><span class="s3">\n                    </span><span class="s1">href = link[1];</span><span class="s3">\n                    </span><span class="s1">title = link[3];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">title = cap[3] ? cap[3].slice(1, -1) : '';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">href = href.trim();</span><span class="s3">\n            </span><span class="s1">if (this.rules.other.startAngleBracket.test(href)) {</span><span class="s3">\n                </span><span class="s1">if (this.options.pedantic &amp;&amp; !(this.rules.other.endAngleBracket.test(trimmedUrl))) {</span><span class="s3">\n                    </span><span class="s1">// pedantic allows starting angle bracket without ending angle bracket</span><span class="s3">\n                    </span><span class="s1">href = href.slice(1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">href = href.slice(1, -1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return outputLink(cap, {</span><span class="s3">\n                </span><span class="s1">href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,</span><span class="s3">\n                </span><span class="s1">title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,</span><span class="s3">\n            </span><span class="s1">}, cap[0], this.lexer, this.rules);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">reflink(src, links) {</span><span class="s3">\n        </span><span class="s1">let cap;</span><span class="s3">\n        </span><span class="s1">if ((cap = this.rules.inline.reflink.exec(src))</span><span class="s3">\n            </span><span class="s1">|| (cap = this.rules.inline.nolink.exec(src))) {</span><span class="s3">\n            </span><span class="s1">const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');</span><span class="s3">\n            </span><span class="s1">const link = links[linkString.toLowerCase()];</span><span class="s3">\n            </span><span class="s1">if (!link) {</span><span class="s3">\n                </span><span class="s1">const text = cap[0].charAt(0);</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">type: 'text',</span><span class="s3">\n                    </span><span class="s1">raw: text,</span><span class="s3">\n                    </span><span class="s1">text,</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return outputLink(cap, link, cap[0], this.lexer, this.rules);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">emStrong(src, maskedSrc, prevChar = '') {</span><span class="s3">\n        </span><span class="s1">let match = this.rules.inline.emStrongLDelim.exec(src);</span><span class="s3">\n        </span><span class="s1">if (!match)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">// _ can't be between two alphanumerics. </span><span class="s3">\\</span><span class="s1">p{L}</span><span class="s3">\\</span><span class="s1">p{N} includes non-english alphabet/numbers as well</span><span class="s3">\n        </span><span class="s1">if (match[3] &amp;&amp; prevChar.match(this.rules.other.unicodeAlphaNumeric))</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">const nextChar = match[1] || match[2] || '';</span><span class="s3">\n        </span><span class="s1">if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {</span><span class="s3">\n            </span><span class="s1">// unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)</span><span class="s3">\n            </span><span class="s1">const lLength = [...match[0]].length - 1;</span><span class="s3">\n            </span><span class="s1">let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;</span><span class="s3">\n            </span><span class="s1">const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;</span><span class="s3">\n            </span><span class="s1">endReg.lastIndex = 0;</span><span class="s3">\n            </span><span class="s1">// Clip maskedSrc to same section of string as src (move to lexer?)</span><span class="s3">\n            </span><span class="s1">maskedSrc = maskedSrc.slice(-1 * src.length + lLength);</span><span class="s3">\n            </span><span class="s1">while ((match = endReg.exec(maskedSrc)) != null) {</span><span class="s3">\n                </span><span class="s1">rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];</span><span class="s3">\n                </span><span class="s1">if (!rDelim)</span><span class="s3">\n                    </span><span class="s1">continue; // skip single * in __abc*abc__</span><span class="s3">\n                </span><span class="s1">rLength = [...rDelim].length;</span><span class="s3">\n                </span><span class="s1">if (match[3] || match[4]) { // found another Left Delim</span><span class="s3">\n                    </span><span class="s1">delimTotal += rLength;</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (match[5] || match[6]) { // either Left or Right Delim</span><span class="s3">\n                    </span><span class="s1">if (lLength % 3 &amp;&amp; !((lLength + rLength) % 3)) {</span><span class="s3">\n                        </span><span class="s1">midDelimTotal += rLength;</span><span class="s3">\n                        </span><span class="s1">continue; // CommonMark Emphasis Rules 9-10</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">delimTotal -= rLength;</span><span class="s3">\n                </span><span class="s1">if (delimTotal &gt; 0)</span><span class="s3">\n                    </span><span class="s1">continue; // Haven't found enough closing delimiters</span><span class="s3">\n                </span><span class="s1">// Remove extra characters. *a*** -&gt; *a*</span><span class="s3">\n                </span><span class="s1">rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);</span><span class="s3">\n                </span><span class="s1">// char length can be &gt;1 for unicode characters;</span><span class="s3">\n                </span><span class="s1">const lastCharLength = [...match[0]][0].length;</span><span class="s3">\n                </span><span class="s1">const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);</span><span class="s3">\n                </span><span class="s1">// Create `em` if smallest delimiter has odd char count. *a***</span><span class="s3">\n                </span><span class="s1">if (Math.min(lLength, rLength) % 2) {</span><span class="s3">\n                    </span><span class="s1">const text = raw.slice(1, -1);</span><span class="s3">\n                    </span><span class="s1">return {</span><span class="s3">\n                        </span><span class="s1">type: 'em',</span><span class="s3">\n                        </span><span class="s1">raw,</span><span class="s3">\n                        </span><span class="s1">text,</span><span class="s3">\n                        </span><span class="s1">tokens: this.lexer.inlineTokens(text),</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">// Create 'strong' if smallest delimiter has even char count. **a***</span><span class="s3">\n                </span><span class="s1">const text = raw.slice(2, -2);</span><span class="s3">\n                </span><span class="s1">return {</span><span class="s3">\n                    </span><span class="s1">type: 'strong',</span><span class="s3">\n                    </span><span class="s1">raw,</span><span class="s3">\n                    </span><span class="s1">text,</span><span class="s3">\n                    </span><span class="s1">tokens: this.lexer.inlineTokens(text),</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">codespan(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.code.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');</span><span class="s3">\n            </span><span class="s1">const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);</span><span class="s3">\n            </span><span class="s1">const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) &amp;&amp; this.rules.other.endingSpaceChar.test(text);</span><span class="s3">\n            </span><span class="s1">if (hasNonSpaceChars &amp;&amp; hasSpaceCharsOnBothEnds) {</span><span class="s3">\n                </span><span class="s1">text = text.substring(1, text.length - 1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'codespan',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">br(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.br.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'br',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">del(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.del.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'del',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text: cap[2],</span><span class="s3">\n                </span><span class="s1">tokens: this.lexer.inlineTokens(cap[2]),</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">autolink(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.autolink.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">let text, href;</span><span class="s3">\n            </span><span class="s1">if (cap[2] === '@') {</span><span class="s3">\n                </span><span class="s1">text = cap[1];</span><span class="s3">\n                </span><span class="s1">href = 'mailto:' + text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">text = cap[1];</span><span class="s3">\n                </span><span class="s1">href = text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'link',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n                </span><span class="s1">href,</span><span class="s3">\n                </span><span class="s1">tokens: [</span><span class="s3">\n                    </span><span class="s1">{</span><span class="s3">\n                        </span><span class="s1">type: 'text',</span><span class="s3">\n                        </span><span class="s1">raw: text,</span><span class="s3">\n                        </span><span class="s1">text,</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">url(src) {</span><span class="s3">\n        </span><span class="s1">let cap;</span><span class="s3">\n        </span><span class="s1">if (cap = this.rules.inline.url.exec(src)) {</span><span class="s3">\n            </span><span class="s1">let text, href;</span><span class="s3">\n            </span><span class="s1">if (cap[2] === '@') {</span><span class="s3">\n                </span><span class="s1">text = cap[0];</span><span class="s3">\n                </span><span class="s1">href = 'mailto:' + text;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">// do extended autolink path validation</span><span class="s3">\n                </span><span class="s1">let prevCapZero;</span><span class="s3">\n                </span><span class="s1">do {</span><span class="s3">\n                    </span><span class="s1">prevCapZero = cap[0];</span><span class="s3">\n                    </span><span class="s1">cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';</span><span class="s3">\n                </span><span class="s1">} while (prevCapZero !== cap[0]);</span><span class="s3">\n                </span><span class="s1">text = cap[0];</span><span class="s3">\n                </span><span class="s1">if (cap[1] === 'www.') {</span><span class="s3">\n                    </span><span class="s1">href = 'http://' + cap[0];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">href = cap[0];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'link',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text,</span><span class="s3">\n                </span><span class="s1">href,</span><span class="s3">\n                </span><span class="s1">tokens: [</span><span class="s3">\n                    </span><span class="s1">{</span><span class="s3">\n                        </span><span class="s1">type: 'text',</span><span class="s3">\n                        </span><span class="s1">raw: text,</span><span class="s3">\n                        </span><span class="s1">text,</span><span class="s3">\n                    </span><span class="s1">},</span><span class="s3">\n                </span><span class="s1">],</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">inlineText(src) {</span><span class="s3">\n        </span><span class="s1">const cap = this.rules.inline.text.exec(src);</span><span class="s3">\n        </span><span class="s1">if (cap) {</span><span class="s3">\n            </span><span class="s1">const escaped = this.lexer.state.inRawBlock;</span><span class="s3">\n            </span><span class="s1">return {</span><span class="s3">\n                </span><span class="s1">type: 'text',</span><span class="s3">\n                </span><span class="s1">raw: cap[0],</span><span class="s3">\n                </span><span class="s1">text: cap[0],</span><span class="s3">\n                </span><span class="s1">escaped,</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Block Lexer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class _Lexer {</span><span class="s3">\n    </span><span class="s1">tokens;</span><span class="s3">\n    </span><span class="s1">options;</span><span class="s3">\n    </span><span class="s1">state;</span><span class="s3">\n    </span><span class="s1">tokenizer;</span><span class="s3">\n    </span><span class="s1">inlineQueue;</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">// TokenList cannot be created in one go</span><span class="s3">\n        </span><span class="s1">this.tokens = [];</span><span class="s3">\n        </span><span class="s1">this.tokens.links = Object.create(null);</span><span class="s3">\n        </span><span class="s1">this.options = options || _defaults;</span><span class="s3">\n        </span><span class="s1">this.options.tokenizer = this.options.tokenizer || new _Tokenizer();</span><span class="s3">\n        </span><span class="s1">this.tokenizer = this.options.tokenizer;</span><span class="s3">\n        </span><span class="s1">this.tokenizer.options = this.options;</span><span class="s3">\n        </span><span class="s1">this.tokenizer.lexer = this;</span><span class="s3">\n        </span><span class="s1">this.inlineQueue = [];</span><span class="s3">\n        </span><span class="s1">this.state = {</span><span class="s3">\n            </span><span class="s1">inLink: false,</span><span class="s3">\n            </span><span class="s1">inRawBlock: false,</span><span class="s3">\n            </span><span class="s1">top: true,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">const rules = {</span><span class="s3">\n            </span><span class="s1">other,</span><span class="s3">\n            </span><span class="s1">block: block.normal,</span><span class="s3">\n            </span><span class="s1">inline: inline.normal,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n            </span><span class="s1">rules.block = block.pedantic;</span><span class="s3">\n            </span><span class="s1">rules.inline = inline.pedantic;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (this.options.gfm) {</span><span class="s3">\n            </span><span class="s1">rules.block = block.gfm;</span><span class="s3">\n            </span><span class="s1">if (this.options.breaks) {</span><span class="s3">\n                </span><span class="s1">rules.inline = inline.breaks;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">rules.inline = inline.gfm;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.tokenizer.rules = rules;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Expose Rules</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static get rules() {</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">block,</span><span class="s3">\n            </span><span class="s1">inline,</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Static Lex Method</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static lex(src, options) {</span><span class="s3">\n        </span><span class="s1">const lexer = new _Lexer(options);</span><span class="s3">\n        </span><span class="s1">return lexer.lex(src);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Static Lex Inline Method</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static lexInline(src, options) {</span><span class="s3">\n        </span><span class="s1">const lexer = new _Lexer(options);</span><span class="s3">\n        </span><span class="s1">return lexer.inlineTokens(src);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Preprocessing</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lex(src) {</span><span class="s3">\n        </span><span class="s1">src = src.replace(other.carriageReturn, '</span><span class="s3">\\</span><span class="s1">n');</span><span class="s3">\n        </span><span class="s1">this.blockTokens(src, this.tokens);</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.inlineQueue.length; i++) {</span><span class="s3">\n            </span><span class="s1">const next = this.inlineQueue[i];</span><span class="s3">\n            </span><span class="s1">this.inlineTokens(next.src, next.tokens);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.inlineQueue = [];</span><span class="s3">\n        </span><span class="s1">return this.tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockTokens(src, tokens = [], lastParagraphClipped = false) {</span><span class="s3">\n        </span><span class="s1">if (this.options.pedantic) {</span><span class="s3">\n            </span><span class="s1">src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (src) {</span><span class="s3">\n            </span><span class="s1">let token;</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.block?.some((extTokenizer) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (token = extTokenizer.call({ lexer: this }, src, tokens)) {</span><span class="s3">\n                    </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">})) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// newline</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.space(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (token.raw.length === 1 &amp;&amp; lastToken !== undefined) {</span><span class="s3">\n                    </span><span class="s1">// if there's a single </span><span class="s3">\\</span><span class="s1">n as a spacer, it's terminating the last line,</span><span class="s3">\n                    </span><span class="s1">// so move it there so that we don't get unnecessary paragraph tags</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// code</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.code(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">// An indented code block cannot interrupt a paragraph.</span><span class="s3">\n                </span><span class="s1">if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += '</span><span class="s3">\\</span><span class="s1">n' + token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += '</span><span class="s3">\\</span><span class="s1">n' + token.text;</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.at(-1).src = lastToken.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// fences</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.fences(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// heading</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.heading(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// hr</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.hr(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// blockquote</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.blockquote(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// list</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.list(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// html</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.html(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// def</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.def(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += '</span><span class="s3">\\</span><span class="s1">n' + token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += '</span><span class="s3">\\</span><span class="s1">n' + token.raw;</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.at(-1).src = lastToken.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (!this.tokens.links[token.tag]) {</span><span class="s3">\n                    </span><span class="s1">this.tokens.links[token.tag] = {</span><span class="s3">\n                        </span><span class="s1">href: token.href,</span><span class="s3">\n                        </span><span class="s1">title: token.title,</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// table (gfm)</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.table(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// lheading</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.lheading(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// top-level paragraph</span><span class="s3">\n            </span><span class="s1">// prevent paragraph consuming extensions by clipping 'src' to extension start</span><span class="s3">\n            </span><span class="s1">let cutSrc = src;</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.startBlock) {</span><span class="s3">\n                </span><span class="s1">let startIndex = Infinity;</span><span class="s3">\n                </span><span class="s1">const tempSrc = src.slice(1);</span><span class="s3">\n                </span><span class="s1">let tempStart;</span><span class="s3">\n                </span><span class="s1">this.options.extensions.startBlock.forEach((getStartIndex) =&gt; {</span><span class="s3">\n                    </span><span class="s1">tempStart = getStartIndex.call({ lexer: this }, tempSrc);</span><span class="s3">\n                    </span><span class="s1">if (typeof tempStart === 'number' &amp;&amp; tempStart &gt;= 0) {</span><span class="s3">\n                        </span><span class="s1">startIndex = Math.min(startIndex, tempStart);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">if (startIndex &lt; Infinity &amp;&amp; startIndex &gt;= 0) {</span><span class="s3">\n                    </span><span class="s1">cutSrc = src.substring(0, startIndex + 1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (this.state.top &amp;&amp; (token = this.tokenizer.paragraph(cutSrc))) {</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (lastParagraphClipped &amp;&amp; lastToken?.type === 'paragraph') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += '</span><span class="s3">\\</span><span class="s1">n' + token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += '</span><span class="s3">\\</span><span class="s1">n' + token.text;</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.pop();</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.at(-1).src = lastToken.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">lastParagraphClipped = cutSrc.length !== src.length;</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// text</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.text(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (lastToken?.type === 'text') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += '</span><span class="s3">\\</span><span class="s1">n' + token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += '</span><span class="s3">\\</span><span class="s1">n' + token.text;</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.pop();</span><span class="s3">\n                    </span><span class="s1">this.inlineQueue.at(-1).src = lastToken.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (src) {</span><span class="s3">\n                </span><span class="s1">const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);</span><span class="s3">\n                </span><span class="s1">if (this.options.silent) {</span><span class="s3">\n                    </span><span class="s1">console.error(errMsg);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw new Error(errMsg);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.state.top = true;</span><span class="s3">\n        </span><span class="s1">return tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">inline(src, tokens = []) {</span><span class="s3">\n        </span><span class="s1">this.inlineQueue.push({ src, tokens });</span><span class="s3">\n        </span><span class="s1">return tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Lexing/Compiling</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">inlineTokens(src, tokens = []) {</span><span class="s3">\n        </span><span class="s1">// String with links masked to avoid interference with em and strong</span><span class="s3">\n        </span><span class="s1">let maskedSrc = src;</span><span class="s3">\n        </span><span class="s1">let match = null;</span><span class="s3">\n        </span><span class="s1">// Mask out reflinks</span><span class="s3">\n        </span><span class="s1">if (this.tokens.links) {</span><span class="s3">\n            </span><span class="s1">const links = Object.keys(this.tokens.links);</span><span class="s3">\n            </span><span class="s1">if (links.length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {</span><span class="s3">\n                    </span><span class="s1">if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {</span><span class="s3">\n                        </span><span class="s1">maskedSrc = maskedSrc.slice(0, match.index)</span><span class="s3">\n                            </span><span class="s1">+ '[' + 'a'.repeat(match[0].length - 2) + ']'</span><span class="s3">\n                            </span><span class="s1">+ maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Mask out other blocks</span><span class="s3">\n        </span><span class="s1">while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {</span><span class="s3">\n            </span><span class="s1">maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Mask out escaped characters</span><span class="s3">\n        </span><span class="s1">while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {</span><span class="s3">\n            </span><span class="s1">maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let keepPrevChar = false;</span><span class="s3">\n        </span><span class="s1">let prevChar = '';</span><span class="s3">\n        </span><span class="s1">while (src) {</span><span class="s3">\n            </span><span class="s1">if (!keepPrevChar) {</span><span class="s3">\n                </span><span class="s1">prevChar = '';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">keepPrevChar = false;</span><span class="s3">\n            </span><span class="s1">let token;</span><span class="s3">\n            </span><span class="s1">// extensions</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.inline?.some((extTokenizer) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (token = extTokenizer.call({ lexer: this }, src, tokens)) {</span><span class="s3">\n                    </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                    </span><span class="s1">return true;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">})) {</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// escape</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.escape(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// tag</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.tag(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// link</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.link(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// reflink, nolink</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.reflink(src, this.tokens.links)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (token.type === 'text' &amp;&amp; lastToken?.type === 'text') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += token.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// em &amp; strong</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// code</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.codespan(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// br</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.br(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// del (gfm)</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.del(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// autolink</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.autolink(src)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// url (gfm)</span><span class="s3">\n            </span><span class="s1">if (!this.state.inLink &amp;&amp; (token = this.tokenizer.url(src))) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// text</span><span class="s3">\n            </span><span class="s1">// prevent inlineText consuming extensions by clipping 'src' to extension start</span><span class="s3">\n            </span><span class="s1">let cutSrc = src;</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.startInline) {</span><span class="s3">\n                </span><span class="s1">let startIndex = Infinity;</span><span class="s3">\n                </span><span class="s1">const tempSrc = src.slice(1);</span><span class="s3">\n                </span><span class="s1">let tempStart;</span><span class="s3">\n                </span><span class="s1">this.options.extensions.startInline.forEach((getStartIndex) =&gt; {</span><span class="s3">\n                    </span><span class="s1">tempStart = getStartIndex.call({ lexer: this }, tempSrc);</span><span class="s3">\n                    </span><span class="s1">if (typeof tempStart === 'number' &amp;&amp; tempStart &gt;= 0) {</span><span class="s3">\n                        </span><span class="s1">startIndex = Math.min(startIndex, tempStart);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">if (startIndex &lt; Infinity &amp;&amp; startIndex &gt;= 0) {</span><span class="s3">\n                    </span><span class="s1">cutSrc = src.substring(0, startIndex + 1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (token = this.tokenizer.inlineText(cutSrc)) {</span><span class="s3">\n                </span><span class="s1">src = src.substring(token.raw.length);</span><span class="s3">\n                </span><span class="s1">if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started</span><span class="s3">\n                    </span><span class="s1">prevChar = token.raw.slice(-1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">keepPrevChar = true;</span><span class="s3">\n                </span><span class="s1">const lastToken = tokens.at(-1);</span><span class="s3">\n                </span><span class="s1">if (lastToken?.type === 'text') {</span><span class="s3">\n                    </span><span class="s1">lastToken.raw += token.raw;</span><span class="s3">\n                    </span><span class="s1">lastToken.text += token.text;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">tokens.push(token);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (src) {</span><span class="s3">\n                </span><span class="s1">const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);</span><span class="s3">\n                </span><span class="s1">if (this.options.silent) {</span><span class="s3">\n                    </span><span class="s1">console.error(errMsg);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">throw new Error(errMsg);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Renderer</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class _Renderer {</span><span class="s3">\n    </span><span class="s1">options;</span><span class="s3">\n    </span><span class="s1">parser; // set by the parser</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this.options = options || _defaults;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">space(token) {</span><span class="s3">\n        </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">code({ text, lang, escaped }) {</span><span class="s3">\n        </span><span class="s1">const langString = (lang || '').match(other.notSpaceStart)?.[0];</span><span class="s3">\n        </span><span class="s1">const code = text.replace(other.endingNewline, '') + '</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n        </span><span class="s1">if (!langString) {</span><span class="s3">\n            </span><span class="s1">return '&lt;pre&gt;&lt;code&gt;'</span><span class="s3">\n                </span><span class="s1">+ (escaped ? code : escape(code, true))</span><span class="s3">\n                </span><span class="s1">+ '&lt;/code&gt;&lt;/pre&gt;</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return '&lt;pre&gt;&lt;code class=</span><span class="s3">\&quot;</span><span class="s1">language-'</span><span class="s3">\n            </span><span class="s1">+ escape(langString)</span><span class="s3">\n            </span><span class="s1">+ '</span><span class="s3">\&quot;</span><span class="s1">&gt;'</span><span class="s3">\n            </span><span class="s1">+ (escaped ? code : escape(code, true))</span><span class="s3">\n            </span><span class="s1">+ '&lt;/code&gt;&lt;/pre&gt;</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">blockquote({ tokens }) {</span><span class="s3">\n        </span><span class="s1">const body = this.parser.parse(tokens);</span><span class="s3">\n        </span><span class="s1">return `&lt;blockquote&gt;</span><span class="s3">\\</span><span class="s1">n${body}&lt;/blockquote&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">html({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">heading({ tokens, depth }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;h${depth}&gt;${this.parser.parseInline(tokens)}&lt;/h${depth}&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">hr(token) {</span><span class="s3">\n        </span><span class="s1">return '&lt;hr&gt;</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">list(token) {</span><span class="s3">\n        </span><span class="s1">const ordered = token.ordered;</span><span class="s3">\n        </span><span class="s1">const start = token.start;</span><span class="s3">\n        </span><span class="s1">let body = '';</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; token.items.length; j++) {</span><span class="s3">\n            </span><span class="s1">const item = token.items[j];</span><span class="s3">\n            </span><span class="s1">body += this.listitem(item);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">const type = ordered ? 'ol' : 'ul';</span><span class="s3">\n        </span><span class="s1">const startAttr = (ordered &amp;&amp; start !== 1) ? (' start=</span><span class="s3">\&quot;</span><span class="s1">' + start + '</span><span class="s3">\&quot;</span><span class="s1">') : '';</span><span class="s3">\n        </span><span class="s1">return '&lt;' + type + startAttr + '&gt;</span><span class="s3">\\</span><span class="s1">n' + body + '&lt;/' + type + '&gt;</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">listitem(item) {</span><span class="s3">\n        </span><span class="s1">let itemBody = '';</span><span class="s3">\n        </span><span class="s1">if (item.task) {</span><span class="s3">\n            </span><span class="s1">const checkbox = this.checkbox({ checked: !!item.checked });</span><span class="s3">\n            </span><span class="s1">if (item.loose) {</span><span class="s3">\n                </span><span class="s1">if (item.tokens[0]?.type === 'paragraph') {</span><span class="s3">\n                    </span><span class="s1">item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;</span><span class="s3">\n                    </span><span class="s1">if (item.tokens[0].tokens &amp;&amp; item.tokens[0].tokens.length &gt; 0 &amp;&amp; item.tokens[0].tokens[0].type === 'text') {</span><span class="s3">\n                        </span><span class="s1">item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);</span><span class="s3">\n                        </span><span class="s1">item.tokens[0].tokens[0].escaped = true;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">item.tokens.unshift({</span><span class="s3">\n                        </span><span class="s1">type: 'text',</span><span class="s3">\n                        </span><span class="s1">raw: checkbox + ' ',</span><span class="s3">\n                        </span><span class="s1">text: checkbox + ' ',</span><span class="s3">\n                        </span><span class="s1">escaped: true,</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">itemBody += checkbox + ' ';</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">itemBody += this.parser.parse(item.tokens, !!item.loose);</span><span class="s3">\n        </span><span class="s1">return `&lt;li&gt;${itemBody}&lt;/li&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">checkbox({ checked }) {</span><span class="s3">\n        </span><span class="s1">return '&lt;input '</span><span class="s3">\n            </span><span class="s1">+ (checked ? 'checked=</span><span class="s3">\&quot;\&quot; </span><span class="s1">' : '')</span><span class="s3">\n            </span><span class="s1">+ 'disabled=</span><span class="s3">\&quot;\&quot; </span><span class="s1">type=</span><span class="s3">\&quot;</span><span class="s1">checkbox</span><span class="s3">\&quot;</span><span class="s1">&gt;';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">paragraph({ tokens }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;p&gt;${this.parser.parseInline(tokens)}&lt;/p&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">table(token) {</span><span class="s3">\n        </span><span class="s1">let header = '';</span><span class="s3">\n        </span><span class="s1">// header</span><span class="s3">\n        </span><span class="s1">let cell = '';</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; token.header.length; j++) {</span><span class="s3">\n            </span><span class="s1">cell += this.tablecell(token.header[j]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">header += this.tablerow({ text: cell });</span><span class="s3">\n        </span><span class="s1">let body = '';</span><span class="s3">\n        </span><span class="s1">for (let j = 0; j &lt; token.rows.length; j++) {</span><span class="s3">\n            </span><span class="s1">const row = token.rows[j];</span><span class="s3">\n            </span><span class="s1">cell = '';</span><span class="s3">\n            </span><span class="s1">for (let k = 0; k &lt; row.length; k++) {</span><span class="s3">\n                </span><span class="s1">cell += this.tablecell(row[k]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">body += this.tablerow({ text: cell });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (body)</span><span class="s3">\n            </span><span class="s1">body = `&lt;tbody&gt;${body}&lt;/tbody&gt;`;</span><span class="s3">\n        </span><span class="s1">return '&lt;table&gt;</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n            </span><span class="s1">+ '&lt;thead&gt;</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n            </span><span class="s1">+ header</span><span class="s3">\n            </span><span class="s1">+ '&lt;/thead&gt;</span><span class="s3">\\</span><span class="s1">n'</span><span class="s3">\n            </span><span class="s1">+ body</span><span class="s3">\n            </span><span class="s1">+ '&lt;/table&gt;</span><span class="s3">\\</span><span class="s1">n';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tablerow({ text }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;tr&gt;</span><span class="s3">\\</span><span class="s1">n${text}&lt;/tr&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">tablecell(token) {</span><span class="s3">\n        </span><span class="s1">const content = this.parser.parseInline(token.tokens);</span><span class="s3">\n        </span><span class="s1">const type = token.header ? 'th' : 'td';</span><span class="s3">\n        </span><span class="s1">const tag = token.align</span><span class="s3">\n            </span><span class="s1">? `&lt;${type} align=</span><span class="s3">\&quot;</span><span class="s1">${token.align}</span><span class="s3">\&quot;</span><span class="s1">&gt;`</span><span class="s3">\n            </span><span class="s1">: `&lt;${type}&gt;`;</span><span class="s3">\n        </span><span class="s1">return tag + content + `&lt;/${type}&gt;</span><span class="s3">\\</span><span class="s1">n`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* span level renderer</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">strong({ tokens }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;strong&gt;${this.parser.parseInline(tokens)}&lt;/strong&gt;`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">em({ tokens }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;em&gt;${this.parser.parseInline(tokens)}&lt;/em&gt;`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">codespan({ text }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;code&gt;${escape(text, true)}&lt;/code&gt;`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">br(token) {</span><span class="s3">\n        </span><span class="s1">return '&lt;br&gt;';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">del({ tokens }) {</span><span class="s3">\n        </span><span class="s1">return `&lt;del&gt;${this.parser.parseInline(tokens)}&lt;/del&gt;`;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">link({ href, title, tokens }) {</span><span class="s3">\n        </span><span class="s1">const text = this.parser.parseInline(tokens);</span><span class="s3">\n        </span><span class="s1">const cleanHref = cleanUrl(href);</span><span class="s3">\n        </span><span class="s1">if (cleanHref === null) {</span><span class="s3">\n            </span><span class="s1">return text;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">href = cleanHref;</span><span class="s3">\n        </span><span class="s1">let out = '&lt;a href=</span><span class="s3">\&quot;</span><span class="s1">' + href + '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n        </span><span class="s1">if (title) {</span><span class="s3">\n            </span><span class="s1">out += ' title=</span><span class="s3">\&quot;</span><span class="s1">' + (escape(title)) + '</span><span class="s3">\&quot;</span><span class="s1">';</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">out += '&gt;' + text + '&lt;/a&gt;';</span><span class="s3">\n        </span><span class="s1">return out;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">image({ href, title, text }) {</span><span class="s3">\n        </span><span class="s1">const cleanHref = cleanUrl(href);</span><span class="s3">\n        </span><span class="s1">if (cleanHref === null) {</span><span class="s3">\n            </span><span class="s1">return escape(text);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">href = cleanHref;</span><span class="s3">\n        </span><span class="s1">let out = `&lt;img src=</span><span class="s3">\&quot;</span><span class="s1">${href}</span><span class="s3">\&quot; </span><span class="s1">alt=</span><span class="s3">\&quot;</span><span class="s1">${text}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">if (title) {</span><span class="s3">\n            </span><span class="s1">out += ` title=</span><span class="s3">\&quot;</span><span class="s1">${escape(title)}</span><span class="s3">\&quot;</span><span class="s1">`;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">out += '&gt;';</span><span class="s3">\n        </span><span class="s1">return out;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">text(token) {</span><span class="s3">\n        </span><span class="s1">return 'tokens' in token &amp;&amp; token.tokens</span><span class="s3">\n            </span><span class="s1">? this.parser.parseInline(token.tokens)</span><span class="s3">\n            </span><span class="s1">: ('escaped' in token &amp;&amp; token.escaped ? token.text : escape(token.text));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* TextRenderer</span><span class="s3">\n </span><span class="s1">* returns only the textual part of the token</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class _TextRenderer {</span><span class="s3">\n    </span><span class="s1">// no need for block level renderers</span><span class="s3">\n    </span><span class="s1">strong({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">em({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">codespan({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">del({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">html({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">text({ text }) {</span><span class="s3">\n        </span><span class="s1">return text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">link({ text }) {</span><span class="s3">\n        </span><span class="s1">return '' + text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">image({ text }) {</span><span class="s3">\n        </span><span class="s1">return '' + text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">br() {</span><span class="s3">\n        </span><span class="s1">return '';</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Parsing &amp; Compiling</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class _Parser {</span><span class="s3">\n    </span><span class="s1">options;</span><span class="s3">\n    </span><span class="s1">renderer;</span><span class="s3">\n    </span><span class="s1">textRenderer;</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this.options = options || _defaults;</span><span class="s3">\n        </span><span class="s1">this.options.renderer = this.options.renderer || new _Renderer();</span><span class="s3">\n        </span><span class="s1">this.renderer = this.options.renderer;</span><span class="s3">\n        </span><span class="s1">this.renderer.options = this.options;</span><span class="s3">\n        </span><span class="s1">this.renderer.parser = this;</span><span class="s3">\n        </span><span class="s1">this.textRenderer = new _TextRenderer();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Static Parse Method</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static parse(tokens, options) {</span><span class="s3">\n        </span><span class="s1">const parser = new _Parser(options);</span><span class="s3">\n        </span><span class="s1">return parser.parse(tokens);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Static Parse Inline Method</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static parseInline(tokens, options) {</span><span class="s3">\n        </span><span class="s1">const parser = new _Parser(options);</span><span class="s3">\n        </span><span class="s1">return parser.parseInline(tokens);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Parse Loop</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parse(tokens, top = true) {</span><span class="s3">\n        </span><span class="s1">let out = '';</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; tokens.length; i++) {</span><span class="s3">\n            </span><span class="s1">const anyToken = tokens[i];</span><span class="s3">\n            </span><span class="s1">// Run any renderer extensions</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.renderers?.[anyToken.type]) {</span><span class="s3">\n                </span><span class="s1">const genericToken = anyToken;</span><span class="s3">\n                </span><span class="s1">const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);</span><span class="s3">\n                </span><span class="s1">if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {</span><span class="s3">\n                    </span><span class="s1">out += ret || '';</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const token = anyToken;</span><span class="s3">\n            </span><span class="s1">switch (token.type) {</span><span class="s3">\n                </span><span class="s1">case 'space': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.space(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'hr': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.hr(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'heading': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.heading(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'code': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.code(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'table': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.table(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'blockquote': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.blockquote(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'list': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.list(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'html': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.html(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'paragraph': {</span><span class="s3">\n                    </span><span class="s1">out += this.renderer.paragraph(token);</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'text': {</span><span class="s3">\n                    </span><span class="s1">let textToken = token;</span><span class="s3">\n                    </span><span class="s1">let body = this.renderer.text(textToken);</span><span class="s3">\n                    </span><span class="s1">while (i + 1 &lt; tokens.length &amp;&amp; tokens[i + 1].type === 'text') {</span><span class="s3">\n                        </span><span class="s1">textToken = tokens[++i];</span><span class="s3">\n                        </span><span class="s1">body += '</span><span class="s3">\\</span><span class="s1">n' + this.renderer.text(textToken);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (top) {</span><span class="s3">\n                        </span><span class="s1">out += this.renderer.paragraph({</span><span class="s3">\n                            </span><span class="s1">type: 'paragraph',</span><span class="s3">\n                            </span><span class="s1">raw: body,</span><span class="s3">\n                            </span><span class="s1">text: body,</span><span class="s3">\n                            </span><span class="s1">tokens: [{ type: 'text', raw: body, text: body, escaped: true }],</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">out += body;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">default: {</span><span class="s3">\n                    </span><span class="s1">const errMsg = 'Token with </span><span class="s3">\&quot;</span><span class="s1">' + token.type + '</span><span class="s3">\&quot; </span><span class="s1">type was not found.';</span><span class="s3">\n                    </span><span class="s1">if (this.options.silent) {</span><span class="s3">\n                        </span><span class="s1">console.error(errMsg);</span><span class="s3">\n                        </span><span class="s1">return '';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">throw new Error(errMsg);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return out;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Parse Inline Tokens</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">parseInline(tokens, renderer = this.renderer) {</span><span class="s3">\n        </span><span class="s1">let out = '';</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; tokens.length; i++) {</span><span class="s3">\n            </span><span class="s1">const anyToken = tokens[i];</span><span class="s3">\n            </span><span class="s1">// Run any renderer extensions</span><span class="s3">\n            </span><span class="s1">if (this.options.extensions?.renderers?.[anyToken.type]) {</span><span class="s3">\n                </span><span class="s1">const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);</span><span class="s3">\n                </span><span class="s1">if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {</span><span class="s3">\n                    </span><span class="s1">out += ret || '';</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const token = anyToken;</span><span class="s3">\n            </span><span class="s1">switch (token.type) {</span><span class="s3">\n                </span><span class="s1">case 'escape': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.text(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'html': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.html(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'link': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.link(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'image': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.image(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'strong': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.strong(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'em': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.em(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'codespan': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.codespan(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'br': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.br(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'del': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.del(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'text': {</span><span class="s3">\n                    </span><span class="s1">out += renderer.text(token);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">default: {</span><span class="s3">\n                    </span><span class="s1">const errMsg = 'Token with </span><span class="s3">\&quot;</span><span class="s1">' + token.type + '</span><span class="s3">\&quot; </span><span class="s1">type was not found.';</span><span class="s3">\n                    </span><span class="s1">if (this.options.silent) {</span><span class="s3">\n                        </span><span class="s1">console.error(errMsg);</span><span class="s3">\n                        </span><span class="s1">return '';</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">throw new Error(errMsg);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return out;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class _Hooks {</span><span class="s3">\n    </span><span class="s1">options;</span><span class="s3">\n    </span><span class="s1">block;</span><span class="s3">\n    </span><span class="s1">constructor(options) {</span><span class="s3">\n        </span><span class="s1">this.options = options || _defaults;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static passThroughHooks = new Set([</span><span class="s3">\n        </span><span class="s1">'preprocess',</span><span class="s3">\n        </span><span class="s1">'postprocess',</span><span class="s3">\n        </span><span class="s1">'processAllTokens',</span><span class="s3">\n    </span><span class="s1">]);</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process markdown before marked</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">preprocess(markdown) {</span><span class="s3">\n        </span><span class="s1">return markdown;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process HTML after marked is finished</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">postprocess(html) {</span><span class="s3">\n        </span><span class="s1">return html;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Process all tokens before walk tokens</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">processAllTokens(tokens) {</span><span class="s3">\n        </span><span class="s1">return tokens;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Provide function to tokenize markdown</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">provideLexer() {</span><span class="s3">\n        </span><span class="s1">return this.block ? _Lexer.lex : _Lexer.lexInline;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Provide function to parse tokens</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">provideParser() {</span><span class="s3">\n        </span><span class="s1">return this.block ? _Parser.parse : _Parser.parseInline;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">class Marked {</span><span class="s3">\n    </span><span class="s1">defaults = _getDefaults();</span><span class="s3">\n    </span><span class="s1">options = this.setOptions;</span><span class="s3">\n    </span><span class="s1">parse = this.parseMarkdown(true);</span><span class="s3">\n    </span><span class="s1">parseInline = this.parseMarkdown(false);</span><span class="s3">\n    </span><span class="s1">Parser = _Parser;</span><span class="s3">\n    </span><span class="s1">Renderer = _Renderer;</span><span class="s3">\n    </span><span class="s1">TextRenderer = _TextRenderer;</span><span class="s3">\n    </span><span class="s1">Lexer = _Lexer;</span><span class="s3">\n    </span><span class="s1">Tokenizer = _Tokenizer;</span><span class="s3">\n    </span><span class="s1">Hooks = _Hooks;</span><span class="s3">\n    </span><span class="s1">constructor(...args) {</span><span class="s3">\n        </span><span class="s1">this.use(...args);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n     </span><span class="s1">* Run callback for every token</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">walkTokens(tokens, callback) {</span><span class="s3">\n        </span><span class="s1">let values = [];</span><span class="s3">\n        </span><span class="s1">for (const token of tokens) {</span><span class="s3">\n            </span><span class="s1">values = values.concat(callback.call(this, token));</span><span class="s3">\n            </span><span class="s1">switch (token.type) {</span><span class="s3">\n                </span><span class="s1">case 'table': {</span><span class="s3">\n                    </span><span class="s1">const tableToken = token;</span><span class="s3">\n                    </span><span class="s1">for (const cell of tableToken.header) {</span><span class="s3">\n                        </span><span class="s1">values = values.concat(this.walkTokens(cell.tokens, callback));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">for (const row of tableToken.rows) {</span><span class="s3">\n                        </span><span class="s1">for (const cell of row) {</span><span class="s3">\n                            </span><span class="s1">values = values.concat(this.walkTokens(cell.tokens, callback));</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">case 'list': {</span><span class="s3">\n                    </span><span class="s1">const listToken = token;</span><span class="s3">\n                    </span><span class="s1">values = values.concat(this.walkTokens(listToken.items, callback));</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">default: {</span><span class="s3">\n                    </span><span class="s1">const genericToken = token;</span><span class="s3">\n                    </span><span class="s1">if (this.defaults.extensions?.childTokens?.[genericToken.type]) {</span><span class="s3">\n                        </span><span class="s1">this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) =&gt; {</span><span class="s3">\n                            </span><span class="s1">const tokens = genericToken[childTokens].flat(Infinity);</span><span class="s3">\n                            </span><span class="s1">values = values.concat(this.walkTokens(tokens, callback));</span><span class="s3">\n                        </span><span class="s1">});</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else if (genericToken.tokens) {</span><span class="s3">\n                        </span><span class="s1">values = values.concat(this.walkTokens(genericToken.tokens, callback));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return values;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">use(...args) {</span><span class="s3">\n        </span><span class="s1">const extensions = this.defaults.extensions || { renderers: {}, childTokens: {} };</span><span class="s3">\n        </span><span class="s1">args.forEach((pack) =&gt; {</span><span class="s3">\n            </span><span class="s1">// copy options to new object</span><span class="s3">\n            </span><span class="s1">const opts = { ...pack };</span><span class="s3">\n            </span><span class="s1">// set async to true if it was set to true before</span><span class="s3">\n            </span><span class="s1">opts.async = this.defaults.async || opts.async || false;</span><span class="s3">\n            </span><span class="s1">// ==-- Parse </span><span class="s3">\&quot;</span><span class="s1">addon</span><span class="s3">\&quot; </span><span class="s1">extensions --== //</span><span class="s3">\n            </span><span class="s1">if (pack.extensions) {</span><span class="s3">\n                </span><span class="s1">pack.extensions.forEach((ext) =&gt; {</span><span class="s3">\n                    </span><span class="s1">if (!ext.name) {</span><span class="s3">\n                        </span><span class="s1">throw new Error('extension name required');</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if ('renderer' in ext) { // Renderer extensions</span><span class="s3">\n                        </span><span class="s1">const prevRenderer = extensions.renderers[ext.name];</span><span class="s3">\n                        </span><span class="s1">if (prevRenderer) {</span><span class="s3">\n                            </span><span class="s1">// Replace extension with func to run new extension but fall back if false</span><span class="s3">\n                            </span><span class="s1">extensions.renderers[ext.name] = function (...args) {</span><span class="s3">\n                                </span><span class="s1">let ret = ext.renderer.apply(this, args);</span><span class="s3">\n                                </span><span class="s1">if (ret === false) {</span><span class="s3">\n                                    </span><span class="s1">ret = prevRenderer.apply(this, args);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">return ret;</span><span class="s3">\n                            </span><span class="s1">};</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">extensions.renderers[ext.name] = ext.renderer;</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if ('tokenizer' in ext) { // Tokenizer Extensions</span><span class="s3">\n                        </span><span class="s1">if (!ext.level || (ext.level !== 'block' &amp;&amp; ext.level !== 'inline')) {</span><span class="s3">\n                            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">extension level must be 'block' or 'inline'</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">const extLevel = extensions[ext.level];</span><span class="s3">\n                        </span><span class="s1">if (extLevel) {</span><span class="s3">\n                            </span><span class="s1">extLevel.unshift(ext.tokenizer);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">else {</span><span class="s3">\n                            </span><span class="s1">extensions[ext.level] = [ext.tokenizer];</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">if (ext.start) { // Function to check for start of token</span><span class="s3">\n                            </span><span class="s1">if (ext.level === 'block') {</span><span class="s3">\n                                </span><span class="s1">if (extensions.startBlock) {</span><span class="s3">\n                                    </span><span class="s1">extensions.startBlock.push(ext.start);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">extensions.startBlock = [ext.start];</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">else if (ext.level === 'inline') {</span><span class="s3">\n                                </span><span class="s1">if (extensions.startInline) {</span><span class="s3">\n                                    </span><span class="s1">extensions.startInline.push(ext.start);</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                                </span><span class="s1">else {</span><span class="s3">\n                                    </span><span class="s1">extensions.startInline = [ext.start];</span><span class="s3">\n                                </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if ('childTokens' in ext &amp;&amp; ext.childTokens) { // Child tokens to be visited by walkTokens</span><span class="s3">\n                        </span><span class="s1">extensions.childTokens[ext.name] = ext.childTokens;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">opts.extensions = extensions;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// ==-- Parse </span><span class="s3">\&quot;</span><span class="s1">overwrite</span><span class="s3">\&quot; </span><span class="s1">extensions --== //</span><span class="s3">\n            </span><span class="s1">if (pack.renderer) {</span><span class="s3">\n                </span><span class="s1">const renderer = this.defaults.renderer || new _Renderer(this.defaults);</span><span class="s3">\n                </span><span class="s1">for (const prop in pack.renderer) {</span><span class="s3">\n                    </span><span class="s1">if (!(prop in renderer)) {</span><span class="s3">\n                        </span><span class="s1">throw new Error(`renderer '${prop}' does not exist`);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (['options', 'parser'].includes(prop)) {</span><span class="s3">\n                        </span><span class="s1">// ignore options property</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const rendererProp = prop;</span><span class="s3">\n                    </span><span class="s1">const rendererFunc = pack.renderer[rendererProp];</span><span class="s3">\n                    </span><span class="s1">const prevRenderer = renderer[rendererProp];</span><span class="s3">\n                    </span><span class="s1">// Replace renderer with func to run extension, but fall back if false</span><span class="s3">\n                    </span><span class="s1">renderer[rendererProp] = (...args) =&gt; {</span><span class="s3">\n                        </span><span class="s1">let ret = rendererFunc.apply(renderer, args);</span><span class="s3">\n                        </span><span class="s1">if (ret === false) {</span><span class="s3">\n                            </span><span class="s1">ret = prevRenderer.apply(renderer, args);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">return ret || '';</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">opts.renderer = renderer;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (pack.tokenizer) {</span><span class="s3">\n                </span><span class="s1">const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);</span><span class="s3">\n                </span><span class="s1">for (const prop in pack.tokenizer) {</span><span class="s3">\n                    </span><span class="s1">if (!(prop in tokenizer)) {</span><span class="s3">\n                        </span><span class="s1">throw new Error(`tokenizer '${prop}' does not exist`);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (['options', 'rules', 'lexer'].includes(prop)) {</span><span class="s3">\n                        </span><span class="s1">// ignore options, rules, and lexer properties</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const tokenizerProp = prop;</span><span class="s3">\n                    </span><span class="s1">const tokenizerFunc = pack.tokenizer[tokenizerProp];</span><span class="s3">\n                    </span><span class="s1">const prevTokenizer = tokenizer[tokenizerProp];</span><span class="s3">\n                    </span><span class="s1">// Replace tokenizer with func to run extension, but fall back if false</span><span class="s3">\n                    </span><span class="s1">// @ts-expect-error cannot type tokenizer function dynamically</span><span class="s3">\n                    </span><span class="s1">tokenizer[tokenizerProp] = (...args) =&gt; {</span><span class="s3">\n                        </span><span class="s1">let ret = tokenizerFunc.apply(tokenizer, args);</span><span class="s3">\n                        </span><span class="s1">if (ret === false) {</span><span class="s3">\n                            </span><span class="s1">ret = prevTokenizer.apply(tokenizer, args);</span><span class="s3">\n                        </span><span class="s1">}</span><span class="s3">\n                        </span><span class="s1">return ret;</span><span class="s3">\n                    </span><span class="s1">};</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">opts.tokenizer = tokenizer;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// ==-- Parse Hooks extensions --== //</span><span class="s3">\n            </span><span class="s1">if (pack.hooks) {</span><span class="s3">\n                </span><span class="s1">const hooks = this.defaults.hooks || new _Hooks();</span><span class="s3">\n                </span><span class="s1">for (const prop in pack.hooks) {</span><span class="s3">\n                    </span><span class="s1">if (!(prop in hooks)) {</span><span class="s3">\n                        </span><span class="s1">throw new Error(`hook '${prop}' does not exist`);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">if (['options', 'block'].includes(prop)) {</span><span class="s3">\n                        </span><span class="s1">// ignore options and block properties</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">const hooksProp = prop;</span><span class="s3">\n                    </span><span class="s1">const hooksFunc = pack.hooks[hooksProp];</span><span class="s3">\n                    </span><span class="s1">const prevHook = hooks[hooksProp];</span><span class="s3">\n                    </span><span class="s1">if (_Hooks.passThroughHooks.has(prop)) {</span><span class="s3">\n                        </span><span class="s1">// @ts-expect-error cannot type hook function dynamically</span><span class="s3">\n                        </span><span class="s1">hooks[hooksProp] = (arg) =&gt; {</span><span class="s3">\n                            </span><span class="s1">if (this.defaults.async) {</span><span class="s3">\n                                </span><span class="s1">return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret =&gt; {</span><span class="s3">\n                                    </span><span class="s1">return prevHook.call(hooks, ret);</span><span class="s3">\n                                </span><span class="s1">});</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">const ret = hooksFunc.call(hooks, arg);</span><span class="s3">\n                            </span><span class="s1">return prevHook.call(hooks, ret);</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">// @ts-expect-error cannot type hook function dynamically</span><span class="s3">\n                        </span><span class="s1">hooks[hooksProp] = (...args) =&gt; {</span><span class="s3">\n                            </span><span class="s1">let ret = hooksFunc.apply(hooks, args);</span><span class="s3">\n                            </span><span class="s1">if (ret === false) {</span><span class="s3">\n                                </span><span class="s1">ret = prevHook.apply(hooks, args);</span><span class="s3">\n                            </span><span class="s1">}</span><span class="s3">\n                            </span><span class="s1">return ret;</span><span class="s3">\n                        </span><span class="s1">};</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">opts.hooks = hooks;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// ==-- Parse WalkTokens extensions --== //</span><span class="s3">\n            </span><span class="s1">if (pack.walkTokens) {</span><span class="s3">\n                </span><span class="s1">const walkTokens = this.defaults.walkTokens;</span><span class="s3">\n                </span><span class="s1">const packWalktokens = pack.walkTokens;</span><span class="s3">\n                </span><span class="s1">opts.walkTokens = function (token) {</span><span class="s3">\n                    </span><span class="s1">let values = [];</span><span class="s3">\n                    </span><span class="s1">values.push(packWalktokens.call(this, token));</span><span class="s3">\n                    </span><span class="s1">if (walkTokens) {</span><span class="s3">\n                        </span><span class="s1">values = values.concat(walkTokens.call(this, token));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return values;</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.defaults = { ...this.defaults, ...opts };</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setOptions(opt) {</span><span class="s3">\n        </span><span class="s1">this.defaults = { ...this.defaults, ...opt };</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lexer(src, options) {</span><span class="s3">\n        </span><span class="s1">return _Lexer.lex(src, options ?? this.defaults);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parser(tokens, options) {</span><span class="s3">\n        </span><span class="s1">return _Parser.parse(tokens, options ?? this.defaults);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">parseMarkdown(blockType) {</span><span class="s3">\n        </span><span class="s1">// eslint-disable-next-line @typescript-eslint/no-explicit-any</span><span class="s3">\n        </span><span class="s1">const parse = (src, options) =&gt; {</span><span class="s3">\n            </span><span class="s1">const origOpt = { ...options };</span><span class="s3">\n            </span><span class="s1">const opt = { ...this.defaults, ...origOpt };</span><span class="s3">\n            </span><span class="s1">const throwError = this.onError(!!opt.silent, !!opt.async);</span><span class="s3">\n            </span><span class="s1">// throw error if an extension set async to true but parse was called with async: false</span><span class="s3">\n            </span><span class="s1">if (this.defaults.async === true &amp;&amp; origOpt.async === false) {</span><span class="s3">\n                </span><span class="s1">return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">// throw error in case of non string input</span><span class="s3">\n            </span><span class="s1">if (typeof src === 'undefined' || src === null) {</span><span class="s3">\n                </span><span class="s1">return throwError(new Error('marked(): input parameter is undefined or null'));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (typeof src !== 'string') {</span><span class="s3">\n                </span><span class="s1">return throwError(new Error('marked(): input parameter is of type '</span><span class="s3">\n                    </span><span class="s1">+ Object.prototype.toString.call(src) + ', string expected'));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (opt.hooks) {</span><span class="s3">\n                </span><span class="s1">opt.hooks.options = opt;</span><span class="s3">\n                </span><span class="s1">opt.hooks.block = blockType;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);</span><span class="s3">\n            </span><span class="s1">const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);</span><span class="s3">\n            </span><span class="s1">if (opt.async) {</span><span class="s3">\n                </span><span class="s1">return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)</span><span class="s3">\n                    </span><span class="s1">.then(src =&gt; lexer(src, opt))</span><span class="s3">\n                    </span><span class="s1">.then(tokens =&gt; opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)</span><span class="s3">\n                    </span><span class="s1">.then(tokens =&gt; opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() =&gt; tokens) : tokens)</span><span class="s3">\n                    </span><span class="s1">.then(tokens =&gt; parser(tokens, opt))</span><span class="s3">\n                    </span><span class="s1">.then(html =&gt; opt.hooks ? opt.hooks.postprocess(html) : html)</span><span class="s3">\n                    </span><span class="s1">.catch(throwError);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n                </span><span class="s1">if (opt.hooks) {</span><span class="s3">\n                    </span><span class="s1">src = opt.hooks.preprocess(src);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let tokens = lexer(src, opt);</span><span class="s3">\n                </span><span class="s1">if (opt.hooks) {</span><span class="s3">\n                    </span><span class="s1">tokens = opt.hooks.processAllTokens(tokens);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (opt.walkTokens) {</span><span class="s3">\n                    </span><span class="s1">this.walkTokens(tokens, opt.walkTokens);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">let html = parser(tokens, opt);</span><span class="s3">\n                </span><span class="s1">if (opt.hooks) {</span><span class="s3">\n                    </span><span class="s1">html = opt.hooks.postprocess(html);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return html;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">catch (e) {</span><span class="s3">\n                </span><span class="s1">return throwError(e);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">return parse;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">onError(silent, async) {</span><span class="s3">\n        </span><span class="s1">return (e) =&gt; {</span><span class="s3">\n            </span><span class="s1">e.message += '</span><span class="s3">\\</span><span class="s1">nPlease report this to https://github.com/markedjs/marked.';</span><span class="s3">\n            </span><span class="s1">if (silent) {</span><span class="s3">\n                </span><span class="s1">const msg = '&lt;p&gt;An error occurred:&lt;/p&gt;&lt;pre&gt;'</span><span class="s3">\n                    </span><span class="s1">+ escape(e.message + '', true)</span><span class="s3">\n                    </span><span class="s1">+ '&lt;/pre&gt;';</span><span class="s3">\n                </span><span class="s1">if (async) {</span><span class="s3">\n                    </span><span class="s1">return Promise.resolve(msg);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return msg;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (async) {</span><span class="s3">\n                </span><span class="s1">return Promise.reject(e);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">throw e;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const markedInstance = new Marked();</span><span class="s3">\n</span><span class="s1">function marked(src, opt) {</span><span class="s3">\n    </span><span class="s1">return markedInstance.parse(src, opt);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Sets the default options.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param options Hash of options</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.options =</span><span class="s3">\n    </span><span class="s1">marked.setOptions = function (options) {</span><span class="s3">\n        </span><span class="s1">markedInstance.setOptions(options);</span><span class="s3">\n        </span><span class="s1">marked.defaults = markedInstance.defaults;</span><span class="s3">\n        </span><span class="s1">changeDefaults(marked.defaults);</span><span class="s3">\n        </span><span class="s1">return marked;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Gets the original marked default options.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.getDefaults = _getDefaults;</span><span class="s3">\n</span><span class="s1">marked.defaults = _defaults;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Use Extension</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.use = function (...args) {</span><span class="s3">\n    </span><span class="s1">markedInstance.use(...args);</span><span class="s3">\n    </span><span class="s1">marked.defaults = markedInstance.defaults;</span><span class="s3">\n    </span><span class="s1">changeDefaults(marked.defaults);</span><span class="s3">\n    </span><span class="s1">return marked;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Run callback for every token</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.walkTokens = function (tokens, callback) {</span><span class="s3">\n    </span><span class="s1">return markedInstance.walkTokens(tokens, callback);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Compiles markdown to HTML without enclosing `p` tag.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* @param src String of markdown source to be compiled</span><span class="s3">\n </span><span class="s1">* @param options Hash of options</span><span class="s3">\n </span><span class="s1">* @return String of compiled HTML</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.parseInline = markedInstance.parseInline;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Expose</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">marked.Parser = _Parser;</span><span class="s3">\n</span><span class="s1">marked.parser = _Parser.parse;</span><span class="s3">\n</span><span class="s1">marked.Renderer = _Renderer;</span><span class="s3">\n</span><span class="s1">marked.TextRenderer = _TextRenderer;</span><span class="s3">\n</span><span class="s1">marked.Lexer = _Lexer;</span><span class="s3">\n</span><span class="s1">marked.lexer = _Lexer.lex;</span><span class="s3">\n</span><span class="s1">marked.Tokenizer = _Tokenizer;</span><span class="s3">\n</span><span class="s1">marked.Hooks = _Hooks;</span><span class="s3">\n</span><span class="s1">marked.parse = marked;</span><span class="s3">\n</span><span class="s1">const options = marked.options;</span><span class="s3">\n</span><span class="s1">const setOptions = marked.setOptions;</span><span class="s3">\n</span><span class="s1">const use = marked.use;</span><span class="s3">\n</span><span class="s1">const walkTokens = marked.walkTokens;</span><span class="s3">\n</span><span class="s1">const parseInline = marked.parseInline;</span><span class="s3">\n</span><span class="s1">const parse = marked;</span><span class="s3">\n</span><span class="s1">const parser = _Parser.parse;</span><span class="s3">\n</span><span class="s1">const lexer = _Lexer.lex;</span><span class="s3">\n\n</span><span class="s1">export { _Hooks as Hooks, _Lexer as Lexer, Marked, _Parser as Parser, _Renderer as Renderer, _TextRenderer as TextRenderer, _Tokenizer as Tokenizer, _defaults as defaults, _getDefaults as getDefaults, lexer, marked, options, parse, parseInline, parser, setOptions, use, walkTokens };</span><span class="s3">\n</span><span class="s1">//# sourceMappingURL=marked.esm.js.map</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>