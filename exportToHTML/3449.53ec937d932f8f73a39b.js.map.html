<html>
<head>
<title>3449.53ec937d932f8f73a39b.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
3449.53ec937d932f8f73a39b.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;3449.53ec937d932f8f73a39b.js?v=53ec937d932f8f73a39b&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;AAAA;;AAEA;AACA;AACA;;AAEA;AACA,+BAA+B,KAAK;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;;AAGA,0BAA0B,EAAE,IAAI,EAAE;AAClC,0BAA0B,EAAE;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA,MAAM;AACN;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,OAAO;AACvC,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,OAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEO;AACP;AACA;AACA;AACA;AACA,cAAc,mDAAmD;AACjE;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,oBAAoB;AACpB;AACA&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/coffeescript.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;var ERRORCLASS = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">function wordRegexp(words) {</span><span class="s3">\n  </span><span class="s1">return new RegExp(</span><span class="s3">\&quot;</span><span class="s1">^((</span><span class="s3">\&quot; </span><span class="s1">+ words.join(</span><span class="s3">\&quot;</span><span class="s1">)|(</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\\\\</span><span class="s1">b</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var operators = /^(?:-&gt;|=&gt;|</span><span class="s3">\\</span><span class="s1">+[+=]?|-[</span><span class="s3">\\</span><span class="s1">-=]?|</span><span class="s3">\\</span><span class="s1">*[</span><span class="s3">\\</span><span class="s1">*=]?|</span><span class="s3">\\</span><span class="s1">/[</span><span class="s3">\\</span><span class="s1">/=]?|[=!]=|&lt;[&gt;&lt;]?=?|&gt;&gt;?=?|%=?|&amp;=?|</span><span class="s3">\\</span><span class="s1">|=?|</span><span class="s3">\\</span><span class="s1">^=?|</span><span class="s3">\\</span><span class="s1">~|!|</span><span class="s3">\\</span><span class="s1">?|(or|and|</span><span class="s3">\\</span><span class="s1">|</span><span class="s3">\\</span><span class="s1">||&amp;&amp;|</span><span class="s3">\\</span><span class="s1">?)=)/;</span><span class="s3">\n</span><span class="s1">var delimiters = /^(?:[()</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{},:`=;]|</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">.?</span><span class="s3">\\</span><span class="s1">.?)/;</span><span class="s3">\n</span><span class="s1">var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;</span><span class="s3">\n</span><span class="s1">var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;</span><span class="s3">\n\n</span><span class="s1">var wordOperators = wordRegexp([</span><span class="s3">\&quot;</span><span class="s1">and</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">or</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">not</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                \&quot;</span><span class="s1">is</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">isnt</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                                \&quot;</span><span class="s1">instanceof</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">typeof</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">var indentKeywords = [</span><span class="s3">\&quot;</span><span class="s1">for</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">loop</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">if</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">unless</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">else</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">switch</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">try</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">catch</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">finally</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">var commonKeywords = [</span><span class="s3">\&quot;</span><span class="s1">break</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">by</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">continue</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">debugger</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">do</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">in</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">of</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">new</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                      \&quot;</span><span class="s1">this</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">throw</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">when</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">until</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">extends</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n\n</span><span class="s1">var keywords = wordRegexp(indentKeywords.concat(commonKeywords));</span><span class="s3">\n\n</span><span class="s1">indentKeywords = wordRegexp(indentKeywords);</span><span class="s3">\n\n\n</span><span class="s1">var stringPrefixes = /^('{3}|</span><span class="s3">\\\&quot;</span><span class="s1">{3}|['</span><span class="s3">\\\&quot;</span><span class="s1">])/;</span><span class="s3">\n</span><span class="s1">var regexPrefixes = /^(</span><span class="s3">\\</span><span class="s1">/{3}|</span><span class="s3">\\</span><span class="s1">/)/;</span><span class="s3">\n</span><span class="s1">var commonConstants = [</span><span class="s3">\&quot;</span><span class="s1">Infinity</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">NaN</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">null</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">true</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">false</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">on</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">off</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">yes</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">no</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n</span><span class="s1">var constants = wordRegexp(commonConstants);</span><span class="s3">\n\n</span><span class="s1">// Tokenizers</span><span class="s3">\n</span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n  </span><span class="s1">// Handle scope changes</span><span class="s3">\n  </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n    </span><span class="s1">if (state.scope.align === null) state.scope.align = false;</span><span class="s3">\n    </span><span class="s1">var scopeOffset = state.scope.offset;</span><span class="s3">\n    </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n      </span><span class="s1">var lineOffset = stream.indentation();</span><span class="s3">\n      </span><span class="s1">if (lineOffset &gt; scopeOffset &amp;&amp; state.scope.type == </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">indent</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else if (lineOffset &lt; scopeOffset) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">dedent</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (scopeOffset &gt; 0) {</span><span class="s3">\n        </span><span class="s1">dedent(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (stream.eatSpace()) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var ch = stream.peek();</span><span class="s3">\n\n  </span><span class="s1">// Handle docco title comment (single line)</span><span class="s3">\n  </span><span class="s1">if (stream.match(</span><span class="s3">\&quot;</span><span class="s1">####</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle multi line comments</span><span class="s3">\n  </span><span class="s1">if (stream.match(</span><span class="s3">\&quot;</span><span class="s1">###</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n    </span><span class="s1">state.tokenize = longComment;</span><span class="s3">\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Single line comment</span><span class="s3">\n  </span><span class="s1">if (ch === </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle number literals</span><span class="s3">\n  </span><span class="s1">if (stream.match(/^-?[0-9</span><span class="s3">\\</span><span class="s1">.]/, false)) {</span><span class="s3">\n    </span><span class="s1">var floatLiteral = false;</span><span class="s3">\n    </span><span class="s1">// Floats</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+(e[</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">-]?</span><span class="s3">\\</span><span class="s1">d+)?/i)) {</span><span class="s3">\n      </span><span class="s1">floatLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?</span><span class="s3">\\</span><span class="s1">d+</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d*/)) {</span><span class="s3">\n      </span><span class="s1">floatLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d+/)) {</span><span class="s3">\n      </span><span class="s1">floatLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (floatLiteral) {</span><span class="s3">\n      </span><span class="s1">// prevent from getting extra . on 1..</span><span class="s3">\n      </span><span class="s1">if (stream.peek() == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">){</span><span class="s3">\n        </span><span class="s1">stream.backUp(1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Integers</span><span class="s3">\n    </span><span class="s1">var intLiteral = false;</span><span class="s3">\n    </span><span class="s1">// Hex</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?0x[0-9a-f]+/i)) {</span><span class="s3">\n      </span><span class="s1">intLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Decimal</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?[1-9]</span><span class="s3">\\</span><span class="s1">d*(e[</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">-]?</span><span class="s3">\\</span><span class="s1">d+)?/)) {</span><span class="s3">\n      </span><span class="s1">intLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Zero by itself with no other piece of number.</span><span class="s3">\n    </span><span class="s1">if (stream.match(/^-?0(?![</span><span class="s3">\\</span><span class="s1">dx])/i)) {</span><span class="s3">\n      </span><span class="s1">intLiteral = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (intLiteral) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle strings</span><span class="s3">\n  </span><span class="s1">if (stream.match(stringPrefixes)) {</span><span class="s3">\n    </span><span class="s1">state.tokenize = tokenFactory(stream.current(), false, </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Handle regex literals</span><span class="s3">\n  </span><span class="s1">if (stream.match(regexPrefixes)) {</span><span class="s3">\n    </span><span class="s1">if (stream.current() != </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">|| stream.match(/^.*</span><span class="s3">\\</span><span class="s1">//, false)) { // prevent highlight of division</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenFactory(stream.current(), true, </span><span class="s3">\&quot;</span><span class="s1">string.special</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n\n\n  </span><span class="s1">// Handle operators and delimiters</span><span class="s3">\n  </span><span class="s1">if (stream.match(operators) || stream.match(wordOperators)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">operator</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (stream.match(delimiters)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (stream.match(constants)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">atom</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (stream.match(atProp) || state.prop &amp;&amp; stream.match(identifiers)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (stream.match(keywords)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (stream.match(identifiers)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Handle non-detected items</span><span class="s3">\n  </span><span class="s1">stream.next();</span><span class="s3">\n  </span><span class="s1">return ERRORCLASS;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenFactory(delimiter, singleline, outclass) {</span><span class="s3">\n  </span><span class="s1">return function(stream, state) {</span><span class="s3">\n    </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[^'</span><span class="s3">\&quot;\\</span><span class="s1">/</span><span class="s3">\\\\</span><span class="s1">]/);</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">stream.next();</span><span class="s3">\n        </span><span class="s1">if (singleline &amp;&amp; stream.eol()) {</span><span class="s3">\n          </span><span class="s1">return outclass;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (stream.match(delimiter)) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">return outclass;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">stream.eat(/['</span><span class="s3">\&quot;\\</span><span class="s1">/]/);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (singleline) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return outclass;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function longComment(stream, state) {</span><span class="s3">\n  </span><span class="s1">while (!stream.eol()) {</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(/[^#]/);</span><span class="s3">\n    </span><span class="s1">if (stream.match(</span><span class="s3">\&quot;</span><span class="s1">###</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">stream.eatWhile(</span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function indent(stream, state, type = </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n  </span><span class="s1">var offset = 0, align = false, alignOffset = null;</span><span class="s3">\n  </span><span class="s1">for (var scope = state.scope; scope; scope = scope.prev) {</span><span class="s3">\n    </span><span class="s1">if (scope.type === </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot; </span><span class="s1">|| scope.type == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">offset = scope.offset + stream.indentUnit;</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (type !== </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">align = null;</span><span class="s3">\n    </span><span class="s1">alignOffset = stream.column() + stream.current().length;</span><span class="s3">\n  </span><span class="s1">} else if (state.scope.align) {</span><span class="s3">\n    </span><span class="s1">state.scope.align = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.scope = {</span><span class="s3">\n    </span><span class="s1">offset: offset,</span><span class="s3">\n    </span><span class="s1">type: type,</span><span class="s3">\n    </span><span class="s1">prev: state.scope,</span><span class="s3">\n    </span><span class="s1">align: align,</span><span class="s3">\n    </span><span class="s1">alignOffset: alignOffset</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function dedent(stream, state) {</span><span class="s3">\n  </span><span class="s1">if (!state.scope.prev) return;</span><span class="s3">\n  </span><span class="s1">if (state.scope.type === </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">var _indent = stream.indentation();</span><span class="s3">\n    </span><span class="s1">var matched = false;</span><span class="s3">\n    </span><span class="s1">for (var scope = state.scope; scope; scope = scope.prev) {</span><span class="s3">\n      </span><span class="s1">if (_indent === scope.offset) {</span><span class="s3">\n        </span><span class="s1">matched = true;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!matched) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">while (state.scope.prev &amp;&amp; state.scope.offset !== _indent) {</span><span class="s3">\n      </span><span class="s1">state.scope = state.scope.prev;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">state.scope = state.scope.prev;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function tokenLexer(stream, state) {</span><span class="s3">\n  </span><span class="s1">var style = state.tokenize(stream, state);</span><span class="s3">\n  </span><span class="s1">var current = stream.current();</span><span class="s3">\n\n  </span><span class="s1">// Handle scope changes.</span><span class="s3">\n  </span><span class="s1">if (current === </span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">state.dedent = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (((current === </span><span class="s3">\&quot;</span><span class="s1">-&gt;</span><span class="s3">\&quot; </span><span class="s1">|| current === </span><span class="s3">\&quot;</span><span class="s1">=&gt;</span><span class="s3">\&quot;</span><span class="s1">) &amp;&amp; stream.eol())</span><span class="s3">\n      </span><span class="s1">|| style === </span><span class="s3">\&quot;</span><span class="s1">indent</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">indent(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var delimiter_index = </span><span class="s3">\&quot;</span><span class="s1">[({</span><span class="s3">\&quot;</span><span class="s1">.indexOf(current);</span><span class="s3">\n  </span><span class="s1">if (delimiter_index !== -1) {</span><span class="s3">\n    </span><span class="s1">indent(stream, state, </span><span class="s3">\&quot;</span><span class="s1">])}</span><span class="s3">\&quot;</span><span class="s1">.slice(delimiter_index, delimiter_index+1));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (indentKeywords.exec(current)){</span><span class="s3">\n    </span><span class="s1">indent(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (current == </span><span class="s3">\&quot;</span><span class="s1">then</span><span class="s3">\&quot;</span><span class="s1">){</span><span class="s3">\n    </span><span class="s1">dedent(stream, state);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n\n  </span><span class="s1">if (style === </span><span class="s3">\&quot;</span><span class="s1">dedent</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (dedent(stream, state)) {</span><span class="s3">\n      </span><span class="s1">return ERRORCLASS;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">delimiter_index = </span><span class="s3">\&quot;</span><span class="s1">])}</span><span class="s3">\&quot;</span><span class="s1">.indexOf(current);</span><span class="s3">\n  </span><span class="s1">if (delimiter_index !== -1) {</span><span class="s3">\n    </span><span class="s1">while (state.scope.type == </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; state.scope.prev)</span><span class="s3">\n      </span><span class="s1">state.scope = state.scope.prev;</span><span class="s3">\n    </span><span class="s1">if (state.scope.type == current)</span><span class="s3">\n      </span><span class="s1">state.scope = state.scope.prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (state.dedent &amp;&amp; stream.eol()) {</span><span class="s3">\n    </span><span class="s1">if (state.scope.type == </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; state.scope.prev)</span><span class="s3">\n      </span><span class="s1">state.scope = state.scope.prev;</span><span class="s3">\n    </span><span class="s1">state.dedent = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return style == </span><span class="s3">\&quot;</span><span class="s1">indent</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">dedent</span><span class="s3">\&quot; </span><span class="s1">? null : style;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export const coffeeScript = {</span><span class="s3">\n  </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">coffeescript</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">startState: function() {</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">tokenize: tokenBase,</span><span class="s3">\n      </span><span class="s1">scope: {offset: 0, type:</span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot;</span><span class="s1">, prev: null, align: false},</span><span class="s3">\n      </span><span class="s1">prop: false,</span><span class="s3">\n      </span><span class="s1">dedent: 0</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n    </span><span class="s1">var fillAlign = state.scope.align === null &amp;&amp; state.scope;</span><span class="s3">\n    </span><span class="s1">if (fillAlign &amp;&amp; stream.sol()) fillAlign.align = false;</span><span class="s3">\n\n    </span><span class="s1">var style = tokenLexer(stream, state);</span><span class="s3">\n    </span><span class="s1">if (style &amp;&amp; style != </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">if (fillAlign) fillAlign.align = true;</span><span class="s3">\n      </span><span class="s1">state.prop = style == </span><span class="s3">\&quot;</span><span class="s1">punctuation</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; stream.current() == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return style;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">indent: function(state, text) {</span><span class="s3">\n    </span><span class="s1">if (state.tokenize != tokenBase) return 0;</span><span class="s3">\n    </span><span class="s1">var scope = state.scope;</span><span class="s3">\n    </span><span class="s1">var closer = text &amp;&amp; </span><span class="s3">\&quot;</span><span class="s1">])}</span><span class="s3">\&quot;</span><span class="s1">.indexOf(text.charAt(0)) &gt; -1;</span><span class="s3">\n    </span><span class="s1">if (closer) while (scope.type == </span><span class="s3">\&quot;</span><span class="s1">coffee</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; scope.prev) scope = scope.prev;</span><span class="s3">\n    </span><span class="s1">var closes = closer &amp;&amp; scope.type === text.charAt(0);</span><span class="s3">\n    </span><span class="s1">if (scope.align)</span><span class="s3">\n      </span><span class="s1">return scope.alignOffset - (closes ? 1 : 0);</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n      </span><span class="s1">return (closes ? scope.prev : scope).offset;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n\n  </span><span class="s1">languageData: {</span><span class="s3">\n    </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>