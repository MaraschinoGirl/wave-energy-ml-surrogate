<html>
<head>
<title>6357.93ae878d47a849df2283.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
6357.93ae878d47a849df2283.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;6357.93ae878d47a849df2283.js?v=93ae878d47a849df2283&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;;AAEA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,oBAAoB;AAC7C;AACA,CAAC;;AAEM;AACP;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mEAAmE,eAAe;AAClF;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B;AAC5B,6BAA6B;AAC7B,+BAA+B;;;ACtFqD;;AAEpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK,wBAAwB,YAAY;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,GAAG,KAAK,WAAW;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,qBAAqB;AACrB;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mCAAmC;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uCAAuC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yBAAyB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,oDAAoD;AACpD;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qBAAgB;AACzB,WAAW,gBAAkB;AAC7B;AACA,SAAS,iBAAY,OAAO;AAC5B,SAAS,kBAAa,OAAO;AAC7B;AACA;AACA;AACA;AACA;AACA,SAAS,gBAAW;AACpB;AACA,SAAS,kBAAa;AACtB;AACA;AACA,SAAS,iBAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kBAAa,SAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,yBAAyB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,KAAK,0CAA0C,KAAK;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,sCAAsC;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,qBAAqB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,YAAY,aAAa,OAAO;AAC9G;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA,iEAAiE,MAAM,KAAK,IAAI,oBAAoB,OAAO;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,yBAAyB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA,cAAc,WAAW;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,mBAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,4CAA4C,uCAAuC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,IAAI;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA,6CAA6C,WAAW,IAAI,OAAO;AACnE;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qBAAqB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,WAAW,8CAA8C;AACvG,qEAAqE;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA,uBAAuB,qBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,uBAAuB,qBAAgB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oIAAoI,OAAO;AAC3I;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iEAAiE;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,0CAA0C;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,cAAc;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uBAAuB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C,sCAAsC,yBAAyB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kBAAkB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iCAAiC;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,8CAA8C,OAAO;AACrD;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAgB;AAC5B;AACA;AACA;;AAEkX&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@marijn/find-cluster-break/src/index.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/state/dist/index.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;// These are filled with ranges (rangeFrom[i] up to but not including</span><span class="s3">\n</span><span class="s1">// rangeTo[i]) of code points that count as extending characters.</span><span class="s3">\n</span><span class="s1">let rangeFrom = [], rangeTo = []</span><span class="s3">\n\n</span><span class="s1">;(() =&gt; {</span><span class="s3">\n  </span><span class="s1">// Compressed representation of the Grapheme_Cluster_Break=Extend</span><span class="s3">\n  </span><span class="s1">// information from</span><span class="s3">\n  </span><span class="s1">// http://www.unicode.org/Public/16.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.</span><span class="s3">\n  </span><span class="s1">// Each pair of elements represents a range, as an offet from the</span><span class="s3">\n  </span><span class="s1">// previous range and a length. Numbers are in base-36, with the empty</span><span class="s3">\n  </span><span class="s1">// string being a shorthand for 1.</span><span class="s3">\n  </span><span class="s1">let numbers = </span><span class="s3">\&quot;</span><span class="s1">lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o</span><span class="s3">\&quot;</span><span class="s1">.split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">).map(s =&gt; s ? parseInt(s, 36) : 1)</span><span class="s3">\n  </span><span class="s1">for (let i = 0, n = 0; i &lt; numbers.length; i++)</span><span class="s3">\n    </span><span class="s1">(i % 2 ? rangeTo : rangeFrom).push(n = n + numbers[i])</span><span class="s3">\n</span><span class="s1">})()</span><span class="s3">\n\n</span><span class="s1">export function isExtendingChar(code) {</span><span class="s3">\n  </span><span class="s1">if (code &lt; 768) return false</span><span class="s3">\n  </span><span class="s1">for (let from = 0, to = rangeFrom.length;;) {</span><span class="s3">\n    </span><span class="s1">let mid = (from + to) &gt;&gt; 1</span><span class="s3">\n    </span><span class="s1">if (code &lt; rangeFrom[mid]) to = mid</span><span class="s3">\n    </span><span class="s1">else if (code &gt;= rangeTo[mid]) from = mid + 1</span><span class="s3">\n    </span><span class="s1">else return true</span><span class="s3">\n    </span><span class="s1">if (from == to) return false</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function isRegionalIndicator(code) {</span><span class="s3">\n  </span><span class="s1">return code &gt;= 0x1F1E6 &amp;&amp; code &lt;= 0x1F1FF</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function check(code) {</span><span class="s3">\n  </span><span class="s1">for (let i = 0; i &lt; rangeFrom.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (rangeTo[i] &gt; code) return rangeFrom[i] &lt;= code</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const ZWJ = 0x200d</span><span class="s3">\n\n</span><span class="s1">export function findClusterBreak(str, pos, forward = true, includeExtending = true) {</span><span class="s3">\n  </span><span class="s1">return (forward ? nextClusterBreak : prevClusterBreak)(str, pos, includeExtending)</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function nextClusterBreak(str, pos, includeExtending) {</span><span class="s3">\n  </span><span class="s1">if (pos == str.length) return pos</span><span class="s3">\n  </span><span class="s1">// If pos is in the middle of a surrogate pair, move to its start</span><span class="s3">\n  </span><span class="s1">if (pos &amp;&amp; surrogateLow(str.charCodeAt(pos)) &amp;&amp; surrogateHigh(str.charCodeAt(pos - 1))) pos--</span><span class="s3">\n  </span><span class="s1">let prev = codePointAt(str, pos)</span><span class="s3">\n  </span><span class="s1">pos += codePointSize(prev)</span><span class="s3">\n  </span><span class="s1">while (pos &lt; str.length) {</span><span class="s3">\n    </span><span class="s1">let next = codePointAt(str, pos)</span><span class="s3">\n    </span><span class="s1">if (prev == ZWJ || next == ZWJ || includeExtending &amp;&amp; isExtendingChar(next)) {</span><span class="s3">\n      </span><span class="s1">pos += codePointSize(next)</span><span class="s3">\n      </span><span class="s1">prev = next</span><span class="s3">\n    </span><span class="s1">} else if (isRegionalIndicator(next)) {</span><span class="s3">\n      </span><span class="s1">let countBefore = 0, i = pos - 2</span><span class="s3">\n      </span><span class="s1">while (i &gt;= 0 &amp;&amp; isRegionalIndicator(codePointAt(str, i))) { countBefore++; i -= 2 }</span><span class="s3">\n      </span><span class="s1">if (countBefore % 2 == 0) break</span><span class="s3">\n      </span><span class="s1">else pos += 2</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">break</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return pos</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function prevClusterBreak(str, pos, includeExtending) {</span><span class="s3">\n  </span><span class="s1">while (pos &gt; 0) {</span><span class="s3">\n    </span><span class="s1">let found = nextClusterBreak(str, pos - 2, includeExtending)</span><span class="s3">\n    </span><span class="s1">if (found &lt; pos) return found</span><span class="s3">\n    </span><span class="s1">pos--</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 0</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function codePointAt(str, pos) {</span><span class="s3">\n  </span><span class="s1">let code0 = str.charCodeAt(pos)</span><span class="s3">\n  </span><span class="s1">if (!surrogateHigh(code0) || pos + 1 == str.length) return code0</span><span class="s3">\n  </span><span class="s1">let code1 = str.charCodeAt(pos + 1)</span><span class="s3">\n  </span><span class="s1">if (!surrogateLow(code1)) return code0</span><span class="s3">\n  </span><span class="s1">return ((code0 - 0xd800) &lt;&lt; 10) + (code1 - 0xdc00) + 0x10000</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">function surrogateLow(ch) { return ch &gt;= 0xDC00 &amp;&amp; ch &lt; 0xE000 }</span><span class="s3">\n</span><span class="s1">function surrogateHigh(ch) { return ch &gt;= 0xD800 &amp;&amp; ch &lt; 0xDC00 }</span><span class="s3">\n</span><span class="s1">function codePointSize(code) { return code &lt; 0x10000 ? 1 : 2 }</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import { findClusterBreak as findClusterBreak$1 } from '@marijn/find-cluster-break';</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The data structure for documents. @nonabstract</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Text {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the line description around the given position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lineAt(pos) {</span><span class="s3">\n        </span><span class="s1">if (pos &lt; 0 || pos &gt; this.length)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);</span><span class="s3">\n        </span><span class="s1">return this.lineInner(pos, false, 1, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the description for the given (1-based) line number.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">line(n) {</span><span class="s3">\n        </span><span class="s1">if (n &lt; 1 || n &gt; this.lines)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);</span><span class="s3">\n        </span><span class="s1">return this.lineInner(n, true, 1, 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Replace a range of the text with the given content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">replace(from, to, text) {</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">let parts = [];</span><span class="s3">\n        </span><span class="s1">this.decompose(0, from, parts, 2 /* Open.To */);</span><span class="s3">\n        </span><span class="s1">if (text.length)</span><span class="s3">\n            </span><span class="s1">text.decompose(0, text.length, parts, 1 /* Open.From */ | 2 /* Open.To */);</span><span class="s3">\n        </span><span class="s1">this.decompose(to, this.length, parts, 1 /* Open.From */);</span><span class="s3">\n        </span><span class="s1">return TextNode.from(parts, this.length - (to - from) + text.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Append another document to this one.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">append(other) {</span><span class="s3">\n        </span><span class="s1">return this.replace(this.length, this.length, other);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Retrieve the text between the given points.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">slice(from, to = this.length) {</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">let parts = [];</span><span class="s3">\n        </span><span class="s1">this.decompose(from, to, parts, 0);</span><span class="s3">\n        </span><span class="s1">return TextNode.from(parts, to - from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Test whether this text is equal to another instance.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other) {</span><span class="s3">\n        </span><span class="s1">if (other == this)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">if (other.length != this.length || other.lines != this.lines)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">let start = this.scanIdentical(other, 1), end = this.length - this.scanIdentical(other, -1);</span><span class="s3">\n        </span><span class="s1">let a = new RawTextCursor(this), b = new RawTextCursor(other);</span><span class="s3">\n        </span><span class="s1">for (let skip = start, pos = start;;) {</span><span class="s3">\n            </span><span class="s1">a.next(skip);</span><span class="s3">\n            </span><span class="s1">b.next(skip);</span><span class="s3">\n            </span><span class="s1">skip = 0;</span><span class="s3">\n            </span><span class="s1">if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">pos += a.value.length;</span><span class="s3">\n            </span><span class="s1">if (a.done || pos &gt;= end)</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the text. When `dir` is `-1`, iteration happens</span><span class="s3">\n    </span><span class="s1">from end to start. This will return lines and the breaks between</span><span class="s3">\n    </span><span class="s1">them as separate strings.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iter(dir = 1) { return new RawTextCursor(this, dir); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over a range of the text. When `from` &gt; `to`, the</span><span class="s3">\n    </span><span class="s1">iterator will run in reverse.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return a cursor that iterates over the given range of lines,</span><span class="s3">\n    </span><span class="s1">_without_ returning the line breaks between, and yielding empty</span><span class="s3">\n    </span><span class="s1">strings for empty lines.</span><span class="s3">\n    \n    </span><span class="s1">When `from` and `to` are given, they should be 1-based line numbers.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterLines(from, to) {</span><span class="s3">\n        </span><span class="s1">let inner;</span><span class="s3">\n        </span><span class="s1">if (from == null) {</span><span class="s3">\n            </span><span class="s1">inner = this.iter();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (to == null)</span><span class="s3">\n                </span><span class="s1">to = this.lines + 1;</span><span class="s3">\n            </span><span class="s1">let start = this.line(from).from;</span><span class="s3">\n            </span><span class="s1">inner = this.iterRange(start, Math.max(start, to == this.lines + 1 ? this.length : to &lt;= 1 ? 0 : this.line(to - 1).to));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new LineCursor(inner);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return the document as a string, using newline characters to</span><span class="s3">\n    </span><span class="s1">separate lines.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() { return this.sliceString(0); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Convert the document to an array of lines (which can be</span><span class="s3">\n    </span><span class="s1">deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">let lines = [];</span><span class="s3">\n        </span><span class="s1">this.flatten(lines);</span><span class="s3">\n        </span><span class="s1">return lines;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor() { }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a `Text` instance for the given array of lines.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static of(text) {</span><span class="s3">\n        </span><span class="s1">if (text.length == 0)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">A document must have at least one line</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (text.length == 1 &amp;&amp; !text[0])</span><span class="s3">\n            </span><span class="s1">return Text.empty;</span><span class="s3">\n        </span><span class="s1">return text.length &lt;= 32 /* Tree.Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Leaves store an array of line strings. There are always line breaks</span><span class="s3">\n</span><span class="s1">// between these strings. Leaves are limited in size and have to be</span><span class="s3">\n</span><span class="s1">// contained in TextNode instances for bigger documents.</span><span class="s3">\n</span><span class="s1">class TextLeaf extends Text {</span><span class="s3">\n    </span><span class="s1">constructor(text, length = textLength(text)) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lines() { return this.text.length; }</span><span class="s3">\n    </span><span class="s1">get children() { return null; }</span><span class="s3">\n    </span><span class="s1">lineInner(target, isLine, line, offset) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let string = this.text[i], end = offset + string.length;</span><span class="s3">\n            </span><span class="s1">if ((isLine ? line : end) &gt;= target)</span><span class="s3">\n                </span><span class="s1">return new Line(offset, end, line, string);</span><span class="s3">\n            </span><span class="s1">offset = end + 1;</span><span class="s3">\n            </span><span class="s1">line++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decompose(from, to, target, open) {</span><span class="s3">\n        </span><span class="s1">let text = from &lt;= 0 &amp;&amp; to &gt;= this.length ? this</span><span class="s3">\n            </span><span class="s1">: new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));</span><span class="s3">\n        </span><span class="s1">if (open &amp; 1 /* Open.From */) {</span><span class="s3">\n            </span><span class="s1">let prev = target.pop();</span><span class="s3">\n            </span><span class="s1">let joined = appendText(text.text, prev.text.slice(), 0, text.length);</span><span class="s3">\n            </span><span class="s1">if (joined.length &lt;= 32 /* Tree.Branch */) {</span><span class="s3">\n                </span><span class="s1">target.push(new TextLeaf(joined, prev.length + text.length));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let mid = joined.length &gt;&gt; 1;</span><span class="s3">\n                </span><span class="s1">target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">target.push(text);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(from, to, text) {</span><span class="s3">\n        </span><span class="s1">if (!(text instanceof TextLeaf))</span><span class="s3">\n            </span><span class="s1">return super.replace(from, to, text);</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);</span><span class="s3">\n        </span><span class="s1">let newLen = this.length + text.length - (to - from);</span><span class="s3">\n        </span><span class="s1">if (lines.length &lt;= 32 /* Tree.Branch */)</span><span class="s3">\n            </span><span class="s1">return new TextLeaf(lines, newLen);</span><span class="s3">\n        </span><span class="s1">return TextNode.from(TextLeaf.split(lines, []), newLen);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sliceString(from, to = this.length, lineSep = </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let pos = 0, i = 0; pos &lt;= to &amp;&amp; i &lt; this.text.length; i++) {</span><span class="s3">\n            </span><span class="s1">let line = this.text[i], end = pos + line.length;</span><span class="s3">\n            </span><span class="s1">if (pos &gt; from &amp;&amp; i)</span><span class="s3">\n                </span><span class="s1">result += lineSep;</span><span class="s3">\n            </span><span class="s1">if (from &lt; end &amp;&amp; to &gt; pos)</span><span class="s3">\n                </span><span class="s1">result += line.slice(Math.max(0, from - pos), to - pos);</span><span class="s3">\n            </span><span class="s1">pos = end + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flatten(target) {</span><span class="s3">\n        </span><span class="s1">for (let line of this.text)</span><span class="s3">\n            </span><span class="s1">target.push(line);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scanIdentical() { return 0; }</span><span class="s3">\n    </span><span class="s1">static split(text, target) {</span><span class="s3">\n        </span><span class="s1">let part = [], len = -1;</span><span class="s3">\n        </span><span class="s1">for (let line of text) {</span><span class="s3">\n            </span><span class="s1">part.push(line);</span><span class="s3">\n            </span><span class="s1">len += line.length + 1;</span><span class="s3">\n            </span><span class="s1">if (part.length == 32 /* Tree.Branch */) {</span><span class="s3">\n                </span><span class="s1">target.push(new TextLeaf(part, len));</span><span class="s3">\n                </span><span class="s1">part = [];</span><span class="s3">\n                </span><span class="s1">len = -1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (len &gt; -1)</span><span class="s3">\n            </span><span class="s1">target.push(new TextLeaf(part, len));</span><span class="s3">\n        </span><span class="s1">return target;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Nodes provide the tree structure of the `Text` type. They store a</span><span class="s3">\n</span><span class="s1">// number of other nodes or leaves, taking care to balance themselves</span><span class="s3">\n</span><span class="s1">// on changes. There are implied line breaks _between_ the children of</span><span class="s3">\n</span><span class="s1">// a node (but not before the first or after the last child).</span><span class="s3">\n</span><span class="s1">class TextNode extends Text {</span><span class="s3">\n    </span><span class="s1">constructor(children, length) {</span><span class="s3">\n        </span><span class="s1">super();</span><span class="s3">\n        </span><span class="s1">this.children = children;</span><span class="s3">\n        </span><span class="s1">this.length = length;</span><span class="s3">\n        </span><span class="s1">this.lines = 0;</span><span class="s3">\n        </span><span class="s1">for (let child of children)</span><span class="s3">\n            </span><span class="s1">this.lines += child.lines;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">lineInner(target, isLine, line, offset) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0;; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;</span><span class="s3">\n            </span><span class="s1">if ((isLine ? endLine : end) &gt;= target)</span><span class="s3">\n                </span><span class="s1">return child.lineInner(target, isLine, line, offset);</span><span class="s3">\n            </span><span class="s1">offset = end + 1;</span><span class="s3">\n            </span><span class="s1">line = endLine + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">decompose(from, to, target, open) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = 0; pos &lt;= to &amp;&amp; i &lt; this.children.length; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = pos + child.length;</span><span class="s3">\n            </span><span class="s1">if (from &lt;= end &amp;&amp; to &gt;= pos) {</span><span class="s3">\n                </span><span class="s1">let childOpen = open &amp; ((pos &lt;= from ? 1 /* Open.From */ : 0) | (end &gt;= to ? 2 /* Open.To */ : 0));</span><span class="s3">\n                </span><span class="s1">if (pos &gt;= from &amp;&amp; end &lt;= to &amp;&amp; !childOpen)</span><span class="s3">\n                    </span><span class="s1">target.push(child);</span><span class="s3">\n                </span><span class="s1">else</span><span class="s3">\n                    </span><span class="s1">child.decompose(from - pos, to - pos, target, childOpen);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos = end + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">replace(from, to, text) {</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">if (text.lines &lt; this.lines)</span><span class="s3">\n            </span><span class="s1">for (let i = 0, pos = 0; i &lt; this.children.length; i++) {</span><span class="s3">\n                </span><span class="s1">let child = this.children[i], end = pos + child.length;</span><span class="s3">\n                </span><span class="s1">// Fast path: if the change only affects one child and the</span><span class="s3">\n                </span><span class="s1">// child's size remains in the acceptable range, only update</span><span class="s3">\n                </span><span class="s1">// that child</span><span class="s3">\n                </span><span class="s1">if (from &gt;= pos &amp;&amp; to &lt;= end) {</span><span class="s3">\n                    </span><span class="s1">let updated = child.replace(from - pos, to - pos, text);</span><span class="s3">\n                    </span><span class="s1">let totalLines = this.lines - child.lines + updated.lines;</span><span class="s3">\n                    </span><span class="s1">if (updated.lines &lt; (totalLines &gt;&gt; (5 /* Tree.BranchShift */ - 1)) &amp;&amp;</span><span class="s3">\n                        </span><span class="s1">updated.lines &gt; (totalLines &gt;&gt; (5 /* Tree.BranchShift */ + 1))) {</span><span class="s3">\n                        </span><span class="s1">let copy = this.children.slice();</span><span class="s3">\n                        </span><span class="s1">copy[i] = updated;</span><span class="s3">\n                        </span><span class="s1">return new TextNode(copy, this.length - (to - from) + text.length);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">return super.replace(pos, end, updated);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">pos = end + 1;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return super.replace(from, to, text);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">sliceString(from, to = this.length, lineSep = </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">[from, to] = clip(this, from, to);</span><span class="s3">\n        </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = 0; i &lt; this.children.length &amp;&amp; pos &lt;= to; i++) {</span><span class="s3">\n            </span><span class="s1">let child = this.children[i], end = pos + child.length;</span><span class="s3">\n            </span><span class="s1">if (pos &gt; from &amp;&amp; i)</span><span class="s3">\n                </span><span class="s1">result += lineSep;</span><span class="s3">\n            </span><span class="s1">if (from &lt; end &amp;&amp; to &gt; pos)</span><span class="s3">\n                </span><span class="s1">result += child.sliceString(from - pos, to - pos, lineSep);</span><span class="s3">\n            </span><span class="s1">pos = end + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">flatten(target) {</span><span class="s3">\n        </span><span class="s1">for (let child of this.children)</span><span class="s3">\n            </span><span class="s1">child.flatten(target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">scanIdentical(other, dir) {</span><span class="s3">\n        </span><span class="s1">if (!(other instanceof TextNode))</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">let length = 0;</span><span class="s3">\n        </span><span class="s1">let [iA, iB, eA, eB] = dir &gt; 0 ? [0, 0, this.children.length, other.children.length]</span><span class="s3">\n            </span><span class="s1">: [this.children.length - 1, other.children.length - 1, -1, -1];</span><span class="s3">\n        </span><span class="s1">for (;; iA += dir, iB += dir) {</span><span class="s3">\n            </span><span class="s1">if (iA == eA || iB == eB)</span><span class="s3">\n                </span><span class="s1">return length;</span><span class="s3">\n            </span><span class="s1">let chA = this.children[iA], chB = other.children[iB];</span><span class="s3">\n            </span><span class="s1">if (chA != chB)</span><span class="s3">\n                </span><span class="s1">return length + chA.scanIdentical(chB, dir);</span><span class="s3">\n            </span><span class="s1">length += chA.length + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static from(children, length = children.reduce((l, ch) =&gt; l + ch.length + 1, -1)) {</span><span class="s3">\n        </span><span class="s1">let lines = 0;</span><span class="s3">\n        </span><span class="s1">for (let ch of children)</span><span class="s3">\n            </span><span class="s1">lines += ch.lines;</span><span class="s3">\n        </span><span class="s1">if (lines &lt; 32 /* Tree.Branch */) {</span><span class="s3">\n            </span><span class="s1">let flat = [];</span><span class="s3">\n            </span><span class="s1">for (let ch of children)</span><span class="s3">\n                </span><span class="s1">ch.flatten(flat);</span><span class="s3">\n            </span><span class="s1">return new TextLeaf(flat, length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let chunk = Math.max(32 /* Tree.Branch */, lines &gt;&gt; 5 /* Tree.BranchShift */), maxChunk = chunk &lt;&lt; 1, minChunk = chunk &gt;&gt; 1;</span><span class="s3">\n        </span><span class="s1">let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];</span><span class="s3">\n        </span><span class="s1">function add(child) {</span><span class="s3">\n            </span><span class="s1">let last;</span><span class="s3">\n            </span><span class="s1">if (child.lines &gt; maxChunk &amp;&amp; child instanceof TextNode) {</span><span class="s3">\n                </span><span class="s1">for (let node of child.children)</span><span class="s3">\n                    </span><span class="s1">add(node);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (child.lines &gt; minChunk &amp;&amp; (currentLines &gt; minChunk || !currentLines)) {</span><span class="s3">\n                </span><span class="s1">flush();</span><span class="s3">\n                </span><span class="s1">chunked.push(child);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (child instanceof TextLeaf &amp;&amp; currentLines &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &amp;&amp;</span><span class="s3">\n                </span><span class="s1">child.lines + last.lines &lt;= 32 /* Tree.Branch */) {</span><span class="s3">\n                </span><span class="s1">currentLines += child.lines;</span><span class="s3">\n                </span><span class="s1">currentLen += child.length + 1;</span><span class="s3">\n                </span><span class="s1">currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (currentLines + child.lines &gt; chunk)</span><span class="s3">\n                    </span><span class="s1">flush();</span><span class="s3">\n                </span><span class="s1">currentLines += child.lines;</span><span class="s3">\n                </span><span class="s1">currentLen += child.length + 1;</span><span class="s3">\n                </span><span class="s1">currentChunk.push(child);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function flush() {</span><span class="s3">\n            </span><span class="s1">if (currentLines == 0)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));</span><span class="s3">\n            </span><span class="s1">currentLen = -1;</span><span class="s3">\n            </span><span class="s1">currentLines = currentChunk.length = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let child of children)</span><span class="s3">\n            </span><span class="s1">add(child);</span><span class="s3">\n        </span><span class="s1">flush();</span><span class="s3">\n        </span><span class="s1">return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">Text.empty = /*@__PURE__*/new TextLeaf([</span><span class="s3">\&quot;\&quot;</span><span class="s1">], 0);</span><span class="s3">\n</span><span class="s1">function textLength(text) {</span><span class="s3">\n    </span><span class="s1">let length = -1;</span><span class="s3">\n    </span><span class="s1">for (let line of text)</span><span class="s3">\n        </span><span class="s1">length += line.length + 1;</span><span class="s3">\n    </span><span class="s1">return length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function appendText(text, target, from = 0, to = 1e9) {</span><span class="s3">\n    </span><span class="s1">for (let pos = 0, i = 0, first = true; i &lt; text.length &amp;&amp; pos &lt;= to; i++) {</span><span class="s3">\n        </span><span class="s1">let line = text[i], end = pos + line.length;</span><span class="s3">\n        </span><span class="s1">if (end &gt;= from) {</span><span class="s3">\n            </span><span class="s1">if (end &gt; to)</span><span class="s3">\n                </span><span class="s1">line = line.slice(0, to - pos);</span><span class="s3">\n            </span><span class="s1">if (pos &lt; from)</span><span class="s3">\n                </span><span class="s1">line = line.slice(from - pos);</span><span class="s3">\n            </span><span class="s1">if (first) {</span><span class="s3">\n                </span><span class="s1">target[target.length - 1] += line;</span><span class="s3">\n                </span><span class="s1">first = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">target.push(line);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">pos = end + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sliceText(text, from, to) {</span><span class="s3">\n    </span><span class="s1">return appendText(text, [</span><span class="s3">\&quot;\&quot;</span><span class="s1">], from, to);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class RawTextCursor {</span><span class="s3">\n    </span><span class="s1">constructor(text, dir = 1) {</span><span class="s3">\n        </span><span class="s1">this.dir = dir;</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">this.lineBreak = false;</span><span class="s3">\n        </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.nodes = [text];</span><span class="s3">\n        </span><span class="s1">this.offsets = [dir &gt; 0 ? 1 : (text instanceof TextLeaf ? text.text.length : text.children.length) &lt;&lt; 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextInner(skip, dir) {</span><span class="s3">\n        </span><span class="s1">this.done = this.lineBreak = false;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let last = this.nodes.length - 1;</span><span class="s3">\n            </span><span class="s1">let top = this.nodes[last], offsetValue = this.offsets[last], offset = offsetValue &gt;&gt; 1;</span><span class="s3">\n            </span><span class="s1">let size = top instanceof TextLeaf ? top.text.length : top.children.length;</span><span class="s3">\n            </span><span class="s1">if (offset == (dir &gt; 0 ? size : 0)) {</span><span class="s3">\n                </span><span class="s1">if (last == 0) {</span><span class="s3">\n                    </span><span class="s1">this.done = true;</span><span class="s3">\n                    </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">return this;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (dir &gt; 0)</span><span class="s3">\n                    </span><span class="s1">this.offsets[last - 1]++;</span><span class="s3">\n                </span><span class="s1">this.nodes.pop();</span><span class="s3">\n                </span><span class="s1">this.offsets.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if ((offsetValue &amp; 1) == (dir &gt; 0 ? 0 : 1)) {</span><span class="s3">\n                </span><span class="s1">this.offsets[last] += dir;</span><span class="s3">\n                </span><span class="s1">if (skip == 0) {</span><span class="s3">\n                    </span><span class="s1">this.lineBreak = true;</span><span class="s3">\n                    </span><span class="s1">this.value = </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                    </span><span class="s1">return this;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">skip--;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (top instanceof TextLeaf) {</span><span class="s3">\n                </span><span class="s1">// Move to the next string</span><span class="s3">\n                </span><span class="s1">let next = top.text[offset + (dir &lt; 0 ? -1 : 0)];</span><span class="s3">\n                </span><span class="s1">this.offsets[last] += dir;</span><span class="s3">\n                </span><span class="s1">if (next.length &gt; Math.max(0, skip)) {</span><span class="s3">\n                    </span><span class="s1">this.value = skip == 0 ? next : dir &gt; 0 ? next.slice(skip) : next.slice(0, next.length - skip);</span><span class="s3">\n                    </span><span class="s1">return this;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">skip -= next.length;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let next = top.children[offset + (dir &lt; 0 ? -1 : 0)];</span><span class="s3">\n                </span><span class="s1">if (skip &gt; next.length) {</span><span class="s3">\n                    </span><span class="s1">skip -= next.length;</span><span class="s3">\n                    </span><span class="s1">this.offsets[last] += dir;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">if (dir &lt; 0)</span><span class="s3">\n                        </span><span class="s1">this.offsets[last]--;</span><span class="s3">\n                    </span><span class="s1">this.nodes.push(next);</span><span class="s3">\n                    </span><span class="s1">this.offsets.push(dir &gt; 0 ? 1 : (next instanceof TextLeaf ? next.text.length : next.children.length) &lt;&lt; 1);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next(skip = 0) {</span><span class="s3">\n        </span><span class="s1">if (skip &lt; 0) {</span><span class="s3">\n            </span><span class="s1">this.nextInner(-skip, (-this.dir));</span><span class="s3">\n            </span><span class="s1">skip = this.value.length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this.nextInner(skip, this.dir);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class PartialTextCursor {</span><span class="s3">\n    </span><span class="s1">constructor(text, start, end) {</span><span class="s3">\n        </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n        </span><span class="s1">this.cursor = new RawTextCursor(text, start &gt; end ? -1 : 1);</span><span class="s3">\n        </span><span class="s1">this.pos = start &gt; end ? text.length : 0;</span><span class="s3">\n        </span><span class="s1">this.from = Math.min(start, end);</span><span class="s3">\n        </span><span class="s1">this.to = Math.max(start, end);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextInner(skip, dir) {</span><span class="s3">\n        </span><span class="s1">if (dir &lt; 0 ? this.pos &lt;= this.from : this.pos &gt;= this.to) {</span><span class="s3">\n            </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.done = true;</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">skip += Math.max(0, dir &lt; 0 ? this.pos - this.to : this.from - this.pos);</span><span class="s3">\n        </span><span class="s1">let limit = dir &lt; 0 ? this.pos - this.from : this.to - this.pos;</span><span class="s3">\n        </span><span class="s1">if (skip &gt; limit)</span><span class="s3">\n            </span><span class="s1">skip = limit;</span><span class="s3">\n        </span><span class="s1">limit -= skip;</span><span class="s3">\n        </span><span class="s1">let { value } = this.cursor.next(skip);</span><span class="s3">\n        </span><span class="s1">this.pos += (value.length + skip) * dir;</span><span class="s3">\n        </span><span class="s1">this.value = value.length &lt;= limit ? value : dir &lt; 0 ? value.slice(value.length - limit) : value.slice(0, limit);</span><span class="s3">\n        </span><span class="s1">this.done = !this.value;</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next(skip = 0) {</span><span class="s3">\n        </span><span class="s1">if (skip &lt; 0)</span><span class="s3">\n            </span><span class="s1">skip = Math.max(skip, this.from - this.pos);</span><span class="s3">\n        </span><span class="s1">else if (skip &gt; 0)</span><span class="s3">\n            </span><span class="s1">skip = Math.min(skip, this.to - this.pos);</span><span class="s3">\n        </span><span class="s1">return this.nextInner(skip, this.cursor.dir);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineBreak() { return this.cursor.lineBreak &amp;&amp; this.value != </span><span class="s3">\&quot;\&quot;</span><span class="s1">; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LineCursor {</span><span class="s3">\n    </span><span class="s1">constructor(inner) {</span><span class="s3">\n        </span><span class="s1">this.inner = inner;</span><span class="s3">\n        </span><span class="s1">this.afterBreak = true;</span><span class="s3">\n        </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">this.done = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next(skip = 0) {</span><span class="s3">\n        </span><span class="s1">let { done, lineBreak, value } = this.inner.next(skip);</span><span class="s3">\n        </span><span class="s1">if (done &amp;&amp; this.afterBreak) {</span><span class="s3">\n            </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">this.afterBreak = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (done) {</span><span class="s3">\n            </span><span class="s1">this.done = true;</span><span class="s3">\n            </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (lineBreak) {</span><span class="s3">\n            </span><span class="s1">if (this.afterBreak) {</span><span class="s3">\n                </span><span class="s1">this.value = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">this.afterBreak = true;</span><span class="s3">\n                </span><span class="s1">this.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.value = value;</span><span class="s3">\n            </span><span class="s1">this.afterBreak = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get lineBreak() { return false; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">if (typeof Symbol != </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">Text.prototype[Symbol.iterator] = function () { return this.iter(); };</span><span class="s3">\n    </span><span class="s1">RawTextCursor.prototype[Symbol.iterator] = PartialTextCursor.prototype[Symbol.iterator] =</span><span class="s3">\n        </span><span class="s1">LineCursor.prototype[Symbol.iterator] = function () { return this; };</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This type describes a line in the document. It is created</span><span class="s3">\n</span><span class="s1">on-demand when lines are [queried](https://codemirror.net/6/docs/ref/#state.Text.lineAt).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Line {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The position of the start of the line.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The position at the end of the line (_before_ the line break,</span><span class="s3">\n    </span><span class="s1">or at the end of document for the last line).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">to, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This line's line number (1-based).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">number, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The line's content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">text) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.number = number;</span><span class="s3">\n        </span><span class="s1">this.text = text;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The length of the line (not including any line break after it).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get length() { return this.to - this.from; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function clip(text, from, to) {</span><span class="s3">\n    </span><span class="s1">from = Math.max(0, Math.min(text.length, from));</span><span class="s3">\n    </span><span class="s1">return [from, Math.max(from, Math.min(text.length, to))];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Returns a next grapheme cluster break _after_ (not equal to)</span><span class="s3">\n</span><span class="s1">`pos`, if `forward` is true, or before otherwise. Returns `pos`</span><span class="s3">\n</span><span class="s1">itself if no further cluster break is available in the string.</span><span class="s3">\n</span><span class="s1">Moves across surrogate pairs, extending characters (when</span><span class="s3">\n</span><span class="s1">`includeExtending` is true), characters joined with zero-width</span><span class="s3">\n</span><span class="s1">joiners, and flag emoji.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findClusterBreak(str, pos, forward = true, includeExtending = true) {</span><span class="s3">\n    </span><span class="s1">return findClusterBreak$1(str, pos, forward, includeExtending);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function surrogateLow(ch) { return ch &gt;= 0xDC00 &amp;&amp; ch &lt; 0xE000; }</span><span class="s3">\n</span><span class="s1">function surrogateHigh(ch) { return ch &gt;= 0xD800 &amp;&amp; ch &lt; 0xDC00; }</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Find the code point at the given position in a string (like the</span><span class="s3">\n</span><span class="s1">[`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)</span><span class="s3">\n</span><span class="s1">string method).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function codePointAt(str, pos) {</span><span class="s3">\n    </span><span class="s1">let code0 = str.charCodeAt(pos);</span><span class="s3">\n    </span><span class="s1">if (!surrogateHigh(code0) || pos + 1 == str.length)</span><span class="s3">\n        </span><span class="s1">return code0;</span><span class="s3">\n    </span><span class="s1">let code1 = str.charCodeAt(pos + 1);</span><span class="s3">\n    </span><span class="s1">if (!surrogateLow(code1))</span><span class="s3">\n        </span><span class="s1">return code0;</span><span class="s3">\n    </span><span class="s1">return ((code0 - 0xd800) &lt;&lt; 10) + (code1 - 0xdc00) + 0x10000;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Given a Unicode codepoint, return the JavaScript string that</span><span class="s3">\n</span><span class="s1">respresents it (like</span><span class="s3">\n</span><span class="s1">[`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function fromCodePoint(code) {</span><span class="s3">\n    </span><span class="s1">if (code &lt;= 0xffff)</span><span class="s3">\n        </span><span class="s1">return String.fromCharCode(code);</span><span class="s3">\n    </span><span class="s1">code -= 0x10000;</span><span class="s3">\n    </span><span class="s1">return String.fromCharCode((code &gt;&gt; 10) + 0xd800, (code &amp; 1023) + 0xdc00);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The amount of positions a character takes up in a JavaScript string.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function codePointSize(code) { return code &lt; 0x10000 ? 1 : 2; }</span><span class="s3">\n\n</span><span class="s1">const DefaultSplit = /</span><span class="s3">\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n?|</span><span class="s3">\\</span><span class="s1">n/;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Distinguishes different ways in which positions can be mapped.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var MapMode = /*@__PURE__*/(function (MapMode) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map a position to a valid new position, even when its context</span><span class="s3">\n    </span><span class="s1">was deleted.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MapMode[MapMode[</span><span class="s3">\&quot;</span><span class="s1">Simple</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Simple</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return null if deletion happens across the position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MapMode[MapMode[</span><span class="s3">\&quot;</span><span class="s1">TrackDel</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">TrackDel</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return null if the character _before_ the position is deleted.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MapMode[MapMode[</span><span class="s3">\&quot;</span><span class="s1">TrackBefore</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">TrackBefore</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return null if the character _after_ the position is deleted.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">MapMode[MapMode[</span><span class="s3">\&quot;</span><span class="s1">TrackAfter</span><span class="s3">\&quot;</span><span class="s1">] = 3] = </span><span class="s3">\&quot;</span><span class="s1">TrackAfter</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">return MapMode})(MapMode || (MapMode = {}));</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A change description is a variant of [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet)</span><span class="s3">\n</span><span class="s1">that doesn't store the inserted text. As such, it can't be</span><span class="s3">\n</span><span class="s1">applied, but is cheaper to store and manipulate.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ChangeDesc {</span><span class="s3">\n    </span><span class="s1">// Sections are encoded as pairs of integers. The first is the</span><span class="s3">\n    </span><span class="s1">// length in the current document, and the second is -1 for</span><span class="s3">\n    </span><span class="s1">// unaffected sections, and the length of the replacement content</span><span class="s3">\n    </span><span class="s1">// otherwise. So an insertion would be (0, n&gt;0), a deletion (n&gt;0,</span><span class="s3">\n    </span><span class="s1">// 0), and a replacement two positive numbers.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sections) {</span><span class="s3">\n        </span><span class="s1">this.sections = sections;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The length of the document before the change.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get length() {</span><span class="s3">\n        </span><span class="s1">let result = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length; i += 2)</span><span class="s3">\n            </span><span class="s1">result += this.sections[i];</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The length of the document after the change.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get newLength() {</span><span class="s3">\n        </span><span class="s1">let result = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length; i += 2) {</span><span class="s3">\n            </span><span class="s1">let ins = this.sections[i + 1];</span><span class="s3">\n            </span><span class="s1">result += ins &lt; 0 ? this.sections[i] : ins;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">False when there are actual changes in this set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get empty() { return this.sections.length == 0 || this.sections.length == 2 &amp;&amp; this.sections[1] &lt; 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the unchanged parts left by these changes. `posA`</span><span class="s3">\n    </span><span class="s1">provides the position of the range in the old document, `posB`</span><span class="s3">\n    </span><span class="s1">the new position in the changed document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterGaps(f) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, posA = 0, posB = 0; i &lt; this.sections.length;) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i++], ins = this.sections[i++];</span><span class="s3">\n            </span><span class="s1">if (ins &lt; 0) {</span><span class="s3">\n                </span><span class="s1">f(posA, posB, len);</span><span class="s3">\n                </span><span class="s1">posB += len;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">posB += ins;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">posA += len;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the ranges changed by these changes. (See</span><span class="s3">\n    </span><span class="s1">[`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a</span><span class="s3">\n    </span><span class="s1">variant that also provides you with the inserted text.)</span><span class="s3">\n    </span><span class="s1">`fromA`/`toA` provides the extent of the change in the starting</span><span class="s3">\n    </span><span class="s1">document, `fromB`/`toB` the extent of the replacement in the</span><span class="s3">\n    </span><span class="s1">changed document.</span><span class="s3">\n    \n    </span><span class="s1">When `individual` is true, adjacent changes (which are kept</span><span class="s3">\n    </span><span class="s1">separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are</span><span class="s3">\n    </span><span class="s1">reported separately.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterChangedRanges(f, individual = false) {</span><span class="s3">\n        </span><span class="s1">iterChanges(this, f, individual);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a description of the inverted form of these changes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get invertedDesc() {</span><span class="s3">\n        </span><span class="s1">let sections = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length;) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i++], ins = this.sections[i++];</span><span class="s3">\n            </span><span class="s1">if (ins &lt; 0)</span><span class="s3">\n                </span><span class="s1">sections.push(len, ins);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">sections.push(ins, len);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new ChangeDesc(sections);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compute the combined effect of applying another set of changes</span><span class="s3">\n    </span><span class="s1">after this one. The length of the document after this set should</span><span class="s3">\n    </span><span class="s1">match the length before `other`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">composeDesc(other) { return this.empty ? other : other.empty ? this : composeSets(this, other); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map this description, which should start with the same document</span><span class="s3">\n    </span><span class="s1">as `other`, over another set of changes, so that it can be</span><span class="s3">\n    </span><span class="s1">applied after it. When `before` is true, map as if the changes</span><span class="s3">\n    </span><span class="s1">in `this` happened before the ones in `other`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mapDesc(other, before = false) { return other.empty ? this : mapSet(this, other, before); }</span><span class="s3">\n    </span><span class="s1">mapPos(pos, assoc = -1, mode = MapMode.Simple) {</span><span class="s3">\n        </span><span class="s1">let posA = 0, posB = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length;) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i++], ins = this.sections[i++], endA = posA + len;</span><span class="s3">\n            </span><span class="s1">if (ins &lt; 0) {</span><span class="s3">\n                </span><span class="s1">if (endA &gt; pos)</span><span class="s3">\n                    </span><span class="s1">return posB + (pos - posA);</span><span class="s3">\n                </span><span class="s1">posB += len;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (mode != MapMode.Simple &amp;&amp; endA &gt;= pos &amp;&amp;</span><span class="s3">\n                    </span><span class="s1">(mode == MapMode.TrackDel &amp;&amp; posA &lt; pos &amp;&amp; endA &gt; pos ||</span><span class="s3">\n                        </span><span class="s1">mode == MapMode.TrackBefore &amp;&amp; posA &lt; pos ||</span><span class="s3">\n                        </span><span class="s1">mode == MapMode.TrackAfter &amp;&amp; endA &gt; pos))</span><span class="s3">\n                    </span><span class="s1">return null;</span><span class="s3">\n                </span><span class="s1">if (endA &gt; pos || endA == pos &amp;&amp; assoc &lt; 0 &amp;&amp; !len)</span><span class="s3">\n                    </span><span class="s1">return pos == posA || assoc &lt; 0 ? posB : posB + ins;</span><span class="s3">\n                </span><span class="s1">posB += ins;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">posA = endA;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (pos &gt; posA)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);</span><span class="s3">\n        </span><span class="s1">return posB;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Check whether these changes touch a given range. When one of the</span><span class="s3">\n    </span><span class="s1">changes entirely covers the range, the string `</span><span class="s3">\&quot;</span><span class="s1">cover</span><span class="s3">\&quot;</span><span class="s1">` is</span><span class="s3">\n    </span><span class="s1">returned.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">touchesRange(from, to = from) {</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = 0; i &lt; this.sections.length &amp;&amp; pos &lt;= to;) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i++], ins = this.sections[i++], end = pos + len;</span><span class="s3">\n            </span><span class="s1">if (ins &gt;= 0 &amp;&amp; pos &lt;= to &amp;&amp; end &gt;= from)</span><span class="s3">\n                </span><span class="s1">return pos &lt; from &amp;&amp; end &gt; to ? </span><span class="s3">\&quot;</span><span class="s1">cover</span><span class="s3">\&quot; </span><span class="s1">: true;</span><span class="s3">\n            </span><span class="s1">pos = end;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toString() {</span><span class="s3">\n        </span><span class="s1">let result = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length;) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i++], ins = this.sections[i++];</span><span class="s3">\n            </span><span class="s1">result += (result ? </span><span class="s3">\&quot; \&quot; </span><span class="s1">: </span><span class="s3">\&quot;\&quot;</span><span class="s1">) + len + (ins &gt;= 0 ? </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot; </span><span class="s1">+ ins : </span><span class="s3">\&quot;\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Serialize this change desc to a JSON-representable value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() { return this.sections; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a change desc from its JSON representation (as produced</span><span class="s3">\n    </span><span class="s1">by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(json) || json.length % 2 || json.some(a =&gt; typeof a != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">))</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation of ChangeDesc</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new ChangeDesc(json);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(sections) { return new ChangeDesc(sections); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A change set represents a group of modifications to a document. It</span><span class="s3">\n</span><span class="s1">stores the document length, and can only be applied to documents</span><span class="s3">\n</span><span class="s1">with exactly that length.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class ChangeSet extends ChangeDesc {</span><span class="s3">\n    </span><span class="s1">constructor(sections, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">inserted) {</span><span class="s3">\n        </span><span class="s1">super(sections);</span><span class="s3">\n        </span><span class="s1">this.inserted = inserted;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Apply the changes to a document, returning the modified</span><span class="s3">\n    </span><span class="s1">document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">apply(doc) {</span><span class="s3">\n        </span><span class="s1">if (this.length != doc.length)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Applying change set to a document with the wrong length</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">iterChanges(this, (fromA, toA, fromB, _toB, text) =&gt; doc = doc.replace(fromB, fromB + (toA - fromA), text), false);</span><span class="s3">\n        </span><span class="s1">return doc;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">mapDesc(other, before = false) { return mapSet(this, other, before, true); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Given the document as it existed _before_ the changes, return a</span><span class="s3">\n    </span><span class="s1">change set that represents the inverse of this set, which could</span><span class="s3">\n    </span><span class="s1">be used to go from the document created by the changes back to</span><span class="s3">\n    </span><span class="s1">the document as it existed before the changes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">invert(doc) {</span><span class="s3">\n        </span><span class="s1">let sections = this.sections.slice(), inserted = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0, pos = 0; i &lt; sections.length; i += 2) {</span><span class="s3">\n            </span><span class="s1">let len = sections[i], ins = sections[i + 1];</span><span class="s3">\n            </span><span class="s1">if (ins &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">sections[i] = ins;</span><span class="s3">\n                </span><span class="s1">sections[i + 1] = len;</span><span class="s3">\n                </span><span class="s1">let index = i &gt;&gt; 1;</span><span class="s3">\n                </span><span class="s1">while (inserted.length &lt; index)</span><span class="s3">\n                    </span><span class="s1">inserted.push(Text.empty);</span><span class="s3">\n                </span><span class="s1">inserted.push(len ? doc.slice(pos, pos + len) : Text.empty);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">pos += len;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new ChangeSet(sections, inserted);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Combine two subsequent change sets into a single set. `other`</span><span class="s3">\n    </span><span class="s1">must start in the document produced by `this`. If `this` goes</span><span class="s3">\n    </span><span class="s1">`docA`  `docB` and `other` represents `docB`  `docC`, the</span><span class="s3">\n    </span><span class="s1">returned value will represent the change `docA`  `docC`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compose(other) { return this.empty ? other : other.empty ? this : composeSets(this, other, true); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Given another change set starting in the same document, maps this</span><span class="s3">\n    </span><span class="s1">change set over the other, producing a new change set that can be</span><span class="s3">\n    </span><span class="s1">applied to the document produced by applying `other`. When</span><span class="s3">\n    </span><span class="s1">`before` is `true`, order changes as if `this` comes before</span><span class="s3">\n    </span><span class="s1">`other`, otherwise (the default) treat `other` as coming first.</span><span class="s3">\n    \n    </span><span class="s1">Given two changes `A` and `B`, `A.compose(B.map(A))` and</span><span class="s3">\n    </span><span class="s1">`B.compose(A.map(B, true))` will produce the same document. This</span><span class="s3">\n    </span><span class="s1">provides a basic form of [operational</span><span class="s3">\n    </span><span class="s1">transformation](https://en.wikipedia.org/wiki/Operational_transformation),</span><span class="s3">\n    </span><span class="s1">and can be used for collaborative editing.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map(other, before = false) { return other.empty ? this : mapSet(this, other, before, true); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the changed ranges in the document, calling `f` for</span><span class="s3">\n    </span><span class="s1">each, with the range in the original document (`fromA`-`toA`)</span><span class="s3">\n    </span><span class="s1">and the range that replaces it in the new document</span><span class="s3">\n    </span><span class="s1">(`fromB`-`toB`).</span><span class="s3">\n    \n    </span><span class="s1">When `individual` is true, adjacent changes are reported</span><span class="s3">\n    </span><span class="s1">separately.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iterChanges(f, individual = false) {</span><span class="s3">\n        </span><span class="s1">iterChanges(this, f, individual);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change</span><span class="s3">\n    </span><span class="s1">set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get desc() { return ChangeDesc.create(this.sections); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">filter(ranges) {</span><span class="s3">\n        </span><span class="s1">let resultSections = [], resultInserted = [], filteredSections = [];</span><span class="s3">\n        </span><span class="s1">let iter = new SectionIter(this);</span><span class="s3">\n        </span><span class="s1">done: for (let i = 0, pos = 0;;) {</span><span class="s3">\n            </span><span class="s1">let next = i == ranges.length ? 1e9 : ranges[i++];</span><span class="s3">\n            </span><span class="s1">while (pos &lt; next || pos == next &amp;&amp; iter.len == 0) {</span><span class="s3">\n                </span><span class="s1">if (iter.done)</span><span class="s3">\n                    </span><span class="s1">break done;</span><span class="s3">\n                </span><span class="s1">let len = Math.min(iter.len, next - pos);</span><span class="s3">\n                </span><span class="s1">addSection(filteredSections, len, -1);</span><span class="s3">\n                </span><span class="s1">let ins = iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0;</span><span class="s3">\n                </span><span class="s1">addSection(resultSections, len, ins);</span><span class="s3">\n                </span><span class="s1">if (ins &gt; 0)</span><span class="s3">\n                    </span><span class="s1">addInsert(resultInserted, resultSections, iter.text);</span><span class="s3">\n                </span><span class="s1">iter.forward(len);</span><span class="s3">\n                </span><span class="s1">pos += len;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let end = ranges[i++];</span><span class="s3">\n            </span><span class="s1">while (pos &lt; end) {</span><span class="s3">\n                </span><span class="s1">if (iter.done)</span><span class="s3">\n                    </span><span class="s1">break done;</span><span class="s3">\n                </span><span class="s1">let len = Math.min(iter.len, end - pos);</span><span class="s3">\n                </span><span class="s1">addSection(resultSections, len, -1);</span><span class="s3">\n                </span><span class="s1">addSection(filteredSections, len, iter.ins == -1 ? -1 : iter.off == 0 ? iter.ins : 0);</span><span class="s3">\n                </span><span class="s1">iter.forward(len);</span><span class="s3">\n                </span><span class="s1">pos += len;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { changes: new ChangeSet(resultSections, resultInserted),</span><span class="s3">\n            </span><span class="s1">filtered: ChangeDesc.create(filteredSections) };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Serialize this change set to a JSON-representable value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">let parts = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.sections.length; i += 2) {</span><span class="s3">\n            </span><span class="s1">let len = this.sections[i], ins = this.sections[i + 1];</span><span class="s3">\n            </span><span class="s1">if (ins &lt; 0)</span><span class="s3">\n                </span><span class="s1">parts.push(len);</span><span class="s3">\n            </span><span class="s1">else if (ins == 0)</span><span class="s3">\n                </span><span class="s1">parts.push([len]);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">parts.push([len].concat(this.inserted[i &gt;&gt; 1].toJSON()));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return parts;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a change set for the given changes, for a document of the</span><span class="s3">\n    </span><span class="s1">given length, using `lineSep` as line separator.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static of(changes, length, lineSep) {</span><span class="s3">\n        </span><span class="s1">let sections = [], inserted = [], pos = 0;</span><span class="s3">\n        </span><span class="s1">let total = null;</span><span class="s3">\n        </span><span class="s1">function flush(force = false) {</span><span class="s3">\n            </span><span class="s1">if (!force &amp;&amp; !sections.length)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">if (pos &lt; length)</span><span class="s3">\n                </span><span class="s1">addSection(sections, length - pos, -1);</span><span class="s3">\n            </span><span class="s1">let set = new ChangeSet(sections, inserted);</span><span class="s3">\n            </span><span class="s1">total = total ? total.compose(set.map(total)) : set;</span><span class="s3">\n            </span><span class="s1">sections = [];</span><span class="s3">\n            </span><span class="s1">inserted = [];</span><span class="s3">\n            </span><span class="s1">pos = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">function process(spec) {</span><span class="s3">\n            </span><span class="s1">if (Array.isArray(spec)) {</span><span class="s3">\n                </span><span class="s1">for (let sub of spec)</span><span class="s3">\n                    </span><span class="s1">process(sub);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (spec instanceof ChangeSet) {</span><span class="s3">\n                </span><span class="s1">if (spec.length != length)</span><span class="s3">\n                    </span><span class="s1">throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);</span><span class="s3">\n                </span><span class="s1">flush();</span><span class="s3">\n                </span><span class="s1">total = total ? total.compose(spec.map(total)) : spec;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let { from, to = from, insert } = spec;</span><span class="s3">\n                </span><span class="s1">if (from &gt; to || from &lt; 0 || to &gt; length)</span><span class="s3">\n                    </span><span class="s1">throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);</span><span class="s3">\n                </span><span class="s1">let insText = !insert ? Text.empty : typeof insert == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot; </span><span class="s1">? Text.of(insert.split(lineSep || DefaultSplit)) : insert;</span><span class="s3">\n                </span><span class="s1">let insLen = insText.length;</span><span class="s3">\n                </span><span class="s1">if (from == to &amp;&amp; insLen == 0)</span><span class="s3">\n                    </span><span class="s1">return;</span><span class="s3">\n                </span><span class="s1">if (from &lt; pos)</span><span class="s3">\n                    </span><span class="s1">flush();</span><span class="s3">\n                </span><span class="s1">if (from &gt; pos)</span><span class="s3">\n                    </span><span class="s1">addSection(sections, from - pos, -1);</span><span class="s3">\n                </span><span class="s1">addSection(sections, to - from, insLen);</span><span class="s3">\n                </span><span class="s1">addInsert(inserted, sections, insText);</span><span class="s3">\n                </span><span class="s1">pos = to;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">process(changes);</span><span class="s3">\n        </span><span class="s1">flush(!total);</span><span class="s3">\n        </span><span class="s1">return total;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an empty changeset of the given length.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static empty(length) {</span><span class="s3">\n        </span><span class="s1">return new ChangeSet(length ? [length, -1] : [], []);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a changeset from its JSON representation (as produced by</span><span class="s3">\n    </span><span class="s1">[`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">if (!Array.isArray(json))</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation of ChangeSet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let sections = [], inserted = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; json.length; i++) {</span><span class="s3">\n            </span><span class="s1">let part = json[i];</span><span class="s3">\n            </span><span class="s1">if (typeof part == </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">sections.push(part, -1);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!Array.isArray(part) || typeof part[0] != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| part.some((e, i) =&gt; i &amp;&amp; typeof e != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation of ChangeSet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (part.length == 1) {</span><span class="s3">\n                </span><span class="s1">sections.push(part[0], 0);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">while (inserted.length &lt; i)</span><span class="s3">\n                    </span><span class="s1">inserted.push(Text.empty);</span><span class="s3">\n                </span><span class="s1">inserted[i] = Text.of(part.slice(1));</span><span class="s3">\n                </span><span class="s1">sections.push(part[0], inserted[i].length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new ChangeSet(sections, inserted);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static createSet(sections, inserted) {</span><span class="s3">\n        </span><span class="s1">return new ChangeSet(sections, inserted);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addSection(sections, len, ins, forceJoin = false) {</span><span class="s3">\n    </span><span class="s1">if (len == 0 &amp;&amp; ins &lt;= 0)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let last = sections.length - 2;</span><span class="s3">\n    </span><span class="s1">if (last &gt;= 0 &amp;&amp; ins &lt;= 0 &amp;&amp; ins == sections[last + 1])</span><span class="s3">\n        </span><span class="s1">sections[last] += len;</span><span class="s3">\n    </span><span class="s1">else if (last &gt;= 0 &amp;&amp; len == 0 &amp;&amp; sections[last] == 0)</span><span class="s3">\n        </span><span class="s1">sections[last + 1] += ins;</span><span class="s3">\n    </span><span class="s1">else if (forceJoin) {</span><span class="s3">\n        </span><span class="s1">sections[last] += len;</span><span class="s3">\n        </span><span class="s1">sections[last + 1] += ins;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else</span><span class="s3">\n        </span><span class="s1">sections.push(len, ins);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function addInsert(values, sections, value) {</span><span class="s3">\n    </span><span class="s1">if (value.length == 0)</span><span class="s3">\n        </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">let index = (sections.length - 2) &gt;&gt; 1;</span><span class="s3">\n    </span><span class="s1">if (index &lt; values.length) {</span><span class="s3">\n        </span><span class="s1">values[values.length - 1] = values[values.length - 1].append(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">while (values.length &lt; index)</span><span class="s3">\n            </span><span class="s1">values.push(Text.empty);</span><span class="s3">\n        </span><span class="s1">values.push(value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function iterChanges(desc, f, individual) {</span><span class="s3">\n    </span><span class="s1">let inserted = desc.inserted;</span><span class="s3">\n    </span><span class="s1">for (let posA = 0, posB = 0, i = 0; i &lt; desc.sections.length;) {</span><span class="s3">\n        </span><span class="s1">let len = desc.sections[i++], ins = desc.sections[i++];</span><span class="s3">\n        </span><span class="s1">if (ins &lt; 0) {</span><span class="s3">\n            </span><span class="s1">posA += len;</span><span class="s3">\n            </span><span class="s1">posB += len;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let endA = posA, endB = posB, text = Text.empty;</span><span class="s3">\n            </span><span class="s1">for (;;) {</span><span class="s3">\n                </span><span class="s1">endA += len;</span><span class="s3">\n                </span><span class="s1">endB += ins;</span><span class="s3">\n                </span><span class="s1">if (ins &amp;&amp; inserted)</span><span class="s3">\n                    </span><span class="s1">text = text.append(inserted[(i - 2) &gt;&gt; 1]);</span><span class="s3">\n                </span><span class="s1">if (individual || i == desc.sections.length || desc.sections[i + 1] &lt; 0)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">len = desc.sections[i++];</span><span class="s3">\n                </span><span class="s1">ins = desc.sections[i++];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">f(posA, endA, posB, endB, text);</span><span class="s3">\n            </span><span class="s1">posA = endA;</span><span class="s3">\n            </span><span class="s1">posB = endB;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mapSet(setA, setB, before, mkSet = false) {</span><span class="s3">\n    </span><span class="s1">// Produce a copy of setA that applies to the document after setB</span><span class="s3">\n    </span><span class="s1">// has been applied (assuming both start at the same document).</span><span class="s3">\n    </span><span class="s1">let sections = [], insert = mkSet ? [] : null;</span><span class="s3">\n    </span><span class="s1">let a = new SectionIter(setA), b = new SectionIter(setB);</span><span class="s3">\n    </span><span class="s1">// Iterate over both sets in parallel. inserted tracks, for changes</span><span class="s3">\n    </span><span class="s1">// in A that have to be processed piece-by-piece, whether their</span><span class="s3">\n    </span><span class="s1">// content has been inserted already, and refers to the section</span><span class="s3">\n    </span><span class="s1">// index.</span><span class="s3">\n    </span><span class="s1">for (let inserted = -1;;) {</span><span class="s3">\n        </span><span class="s1">if (a.done &amp;&amp; b.len || b.done &amp;&amp; a.len) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Mismatched change set lengths</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (a.ins == -1 &amp;&amp; b.ins == -1) {</span><span class="s3">\n            </span><span class="s1">// Move across ranges skipped by both sets.</span><span class="s3">\n            </span><span class="s1">let len = Math.min(a.len, b.len);</span><span class="s3">\n            </span><span class="s1">addSection(sections, len, -1);</span><span class="s3">\n            </span><span class="s1">a.forward(len);</span><span class="s3">\n            </span><span class="s1">b.forward(len);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (b.ins &gt;= 0 &amp;&amp; (a.ins &lt; 0 || inserted == a.i || a.off == 0 &amp;&amp; (b.len &lt; a.len || b.len == a.len &amp;&amp; !before))) {</span><span class="s3">\n            </span><span class="s1">// If there's a change in B that comes before the next change in</span><span class="s3">\n            </span><span class="s1">// A (ordered by start pos, then len, then before flag), skip</span><span class="s3">\n            </span><span class="s1">// that (and process any changes in A it covers).</span><span class="s3">\n            </span><span class="s1">let len = b.len;</span><span class="s3">\n            </span><span class="s1">addSection(sections, b.ins, -1);</span><span class="s3">\n            </span><span class="s1">while (len) {</span><span class="s3">\n                </span><span class="s1">let piece = Math.min(a.len, len);</span><span class="s3">\n                </span><span class="s1">if (a.ins &gt;= 0 &amp;&amp; inserted &lt; a.i &amp;&amp; a.len &lt;= piece) {</span><span class="s3">\n                    </span><span class="s1">addSection(sections, 0, a.ins);</span><span class="s3">\n                    </span><span class="s1">if (insert)</span><span class="s3">\n                        </span><span class="s1">addInsert(insert, sections, a.text);</span><span class="s3">\n                    </span><span class="s1">inserted = a.i;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">a.forward(piece);</span><span class="s3">\n                </span><span class="s1">len -= piece;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">b.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (a.ins &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">// Process the part of a change in A up to the start of the next</span><span class="s3">\n            </span><span class="s1">// non-deletion change in B (if overlapping).</span><span class="s3">\n            </span><span class="s1">let len = 0, left = a.len;</span><span class="s3">\n            </span><span class="s1">while (left) {</span><span class="s3">\n                </span><span class="s1">if (b.ins == -1) {</span><span class="s3">\n                    </span><span class="s1">let piece = Math.min(left, b.len);</span><span class="s3">\n                    </span><span class="s1">len += piece;</span><span class="s3">\n                    </span><span class="s1">left -= piece;</span><span class="s3">\n                    </span><span class="s1">b.forward(piece);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (b.ins == 0 &amp;&amp; b.len &lt; left) {</span><span class="s3">\n                    </span><span class="s1">left -= b.len;</span><span class="s3">\n                    </span><span class="s1">b.next();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">addSection(sections, len, inserted &lt; a.i ? a.ins : 0);</span><span class="s3">\n            </span><span class="s1">if (insert &amp;&amp; inserted &lt; a.i)</span><span class="s3">\n                </span><span class="s1">addInsert(insert, sections, a.text);</span><span class="s3">\n            </span><span class="s1">inserted = a.i;</span><span class="s3">\n            </span><span class="s1">a.forward(a.len - left);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (a.done &amp;&amp; b.done) {</span><span class="s3">\n            </span><span class="s1">return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Mismatched change set lengths</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function composeSets(setA, setB, mkSet = false) {</span><span class="s3">\n    </span><span class="s1">let sections = [];</span><span class="s3">\n    </span><span class="s1">let insert = mkSet ? [] : null;</span><span class="s3">\n    </span><span class="s1">let a = new SectionIter(setA), b = new SectionIter(setB);</span><span class="s3">\n    </span><span class="s1">for (let open = false;;) {</span><span class="s3">\n        </span><span class="s1">if (a.done &amp;&amp; b.done) {</span><span class="s3">\n            </span><span class="s1">return insert ? ChangeSet.createSet(sections, insert) : ChangeDesc.create(sections);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (a.ins == 0) { // Deletion in A</span><span class="s3">\n            </span><span class="s1">addSection(sections, a.len, 0, open);</span><span class="s3">\n            </span><span class="s1">a.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (b.len == 0 &amp;&amp; !b.done) { // Insertion in B</span><span class="s3">\n            </span><span class="s1">addSection(sections, 0, b.ins, open);</span><span class="s3">\n            </span><span class="s1">if (insert)</span><span class="s3">\n                </span><span class="s1">addInsert(insert, sections, b.text);</span><span class="s3">\n            </span><span class="s1">b.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (a.done || b.done) {</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Mismatched change set lengths</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let len = Math.min(a.len2, b.len), sectionLen = sections.length;</span><span class="s3">\n            </span><span class="s1">if (a.ins == -1) {</span><span class="s3">\n                </span><span class="s1">let insB = b.ins == -1 ? -1 : b.off ? 0 : b.ins;</span><span class="s3">\n                </span><span class="s1">addSection(sections, len, insB, open);</span><span class="s3">\n                </span><span class="s1">if (insert &amp;&amp; insB)</span><span class="s3">\n                    </span><span class="s1">addInsert(insert, sections, b.text);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (b.ins == -1) {</span><span class="s3">\n                </span><span class="s1">addSection(sections, a.off ? 0 : a.len, len, open);</span><span class="s3">\n                </span><span class="s1">if (insert)</span><span class="s3">\n                    </span><span class="s1">addInsert(insert, sections, a.textBit(len));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">addSection(sections, a.off ? 0 : a.len, b.off ? 0 : b.ins, open);</span><span class="s3">\n                </span><span class="s1">if (insert &amp;&amp; !b.off)</span><span class="s3">\n                    </span><span class="s1">addInsert(insert, sections, b.text);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">open = (a.ins &gt; len || b.ins &gt;= 0 &amp;&amp; b.len &gt; len) &amp;&amp; (open || sections.length &gt; sectionLen);</span><span class="s3">\n            </span><span class="s1">a.forward2(len);</span><span class="s3">\n            </span><span class="s1">b.forward(len);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SectionIter {</span><span class="s3">\n    </span><span class="s1">constructor(set) {</span><span class="s3">\n        </span><span class="s1">this.set = set;</span><span class="s3">\n        </span><span class="s1">this.i = 0;</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">let { sections } = this.set;</span><span class="s3">\n        </span><span class="s1">if (this.i &lt; sections.length) {</span><span class="s3">\n            </span><span class="s1">this.len = sections[this.i++];</span><span class="s3">\n            </span><span class="s1">this.ins = sections[this.i++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.len = 0;</span><span class="s3">\n            </span><span class="s1">this.ins = -2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.off = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get done() { return this.ins == -2; }</span><span class="s3">\n    </span><span class="s1">get len2() { return this.ins &lt; 0 ? this.len : this.ins; }</span><span class="s3">\n    </span><span class="s1">get text() {</span><span class="s3">\n        </span><span class="s1">let { inserted } = this.set, index = (this.i - 2) &gt;&gt; 1;</span><span class="s3">\n        </span><span class="s1">return index &gt;= inserted.length ? Text.empty : inserted[index];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">textBit(len) {</span><span class="s3">\n        </span><span class="s1">let { inserted } = this.set, index = (this.i - 2) &gt;&gt; 1;</span><span class="s3">\n        </span><span class="s1">return index &gt;= inserted.length &amp;&amp; !len ? Text.empty</span><span class="s3">\n            </span><span class="s1">: inserted[index].slice(this.off, len == null ? undefined : this.off + len);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forward(len) {</span><span class="s3">\n        </span><span class="s1">if (len == this.len)</span><span class="s3">\n            </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.len -= len;</span><span class="s3">\n            </span><span class="s1">this.off += len;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forward2(len) {</span><span class="s3">\n        </span><span class="s1">if (this.ins == -1)</span><span class="s3">\n            </span><span class="s1">this.forward(len);</span><span class="s3">\n        </span><span class="s1">else if (len == this.ins)</span><span class="s3">\n            </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.ins -= len;</span><span class="s3">\n            </span><span class="s1">this.off += len;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A single selection range. When</span><span class="s3">\n</span><span class="s1">[`allowMultipleSelections`](https://codemirror.net/6/docs/ref/#state.EditorState^allowMultipleSelections)</span><span class="s3">\n</span><span class="s1">is enabled, a [selection](https://codemirror.net/6/docs/ref/#state.EditorSelection) may hold</span><span class="s3">\n</span><span class="s1">multiple ranges. By default, selections hold exactly one range.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class SelectionRange {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The lower boundary of the range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The upper boundary of the range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">to, flags) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.flags = flags;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The anchor of the rangethe side that doesn't move when you</span><span class="s3">\n    </span><span class="s1">extend it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get anchor() { return this.flags &amp; 32 /* RangeFlag.Inverted */ ? this.to : this.from; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The head of the range, which is moved when the range is</span><span class="s3">\n    </span><span class="s1">[extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get head() { return this.flags &amp; 32 /* RangeFlag.Inverted */ ? this.from : this.to; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">True when `anchor` and `head` are at the same position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get empty() { return this.from == this.to; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">If this is a cursor that is explicitly associated with the</span><span class="s3">\n    </span><span class="s1">character on one of its sides, this returns the side. -1 means</span><span class="s3">\n    </span><span class="s1">the character before its position, 1 the character after, and 0</span><span class="s3">\n    </span><span class="s1">means no association.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get assoc() { return this.flags &amp; 8 /* RangeFlag.AssocBefore */ ? -1 : this.flags &amp; 16 /* RangeFlag.AssocAfter */ ? 1 : 0; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The bidirectional text level associated with this cursor, if</span><span class="s3">\n    </span><span class="s1">any.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get bidiLevel() {</span><span class="s3">\n        </span><span class="s1">let level = this.flags &amp; 7 /* RangeFlag.BidiLevelMask */;</span><span class="s3">\n        </span><span class="s1">return level == 7 ? null : level;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The goal column (stored vertical offset) associated with a</span><span class="s3">\n    </span><span class="s1">cursor. This is used to preserve the vertical position when</span><span class="s3">\n    </span><span class="s1">[moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across</span><span class="s3">\n    </span><span class="s1">lines of different length.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get goalColumn() {</span><span class="s3">\n        </span><span class="s1">let value = this.flags &gt;&gt; 6 /* RangeFlag.GoalColumnOffset */;</span><span class="s3">\n        </span><span class="s1">return value == 16777215 /* RangeFlag.NoGoalColumn */ ? undefined : value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map this range through a change, producing a valid range in the</span><span class="s3">\n    </span><span class="s1">updated document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map(change, assoc = -1) {</span><span class="s3">\n        </span><span class="s1">let from, to;</span><span class="s3">\n        </span><span class="s1">if (this.empty) {</span><span class="s3">\n            </span><span class="s1">from = to = change.mapPos(this.from, assoc);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">from = change.mapPos(this.from, 1);</span><span class="s3">\n            </span><span class="s1">to = change.mapPos(this.to, -1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return from == this.from &amp;&amp; to == this.to ? this : new SelectionRange(from, to, this.flags);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Extend this range to cover at least `from` to `to`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">extend(from, to = from) {</span><span class="s3">\n        </span><span class="s1">if (from &lt;= this.anchor &amp;&amp; to &gt;= this.anchor)</span><span class="s3">\n            </span><span class="s1">return EditorSelection.range(from, to);</span><span class="s3">\n        </span><span class="s1">let head = Math.abs(from - this.anchor) &gt; Math.abs(to - this.anchor) ? from : to;</span><span class="s3">\n        </span><span class="s1">return EditorSelection.range(this.anchor, head);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this range to another range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other, includeAssoc = false) {</span><span class="s3">\n        </span><span class="s1">return this.anchor == other.anchor &amp;&amp; this.head == other.head &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(!includeAssoc || !this.empty || this.assoc == other.assoc);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return a JSON-serializable object representing the range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() { return { anchor: this.anchor, head: this.head }; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Convert a JSON representation of a range to a `SelectionRange`</span><span class="s3">\n    </span><span class="s1">instance.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">if (!json || typeof json.anchor != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| typeof json.head != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation for SelectionRange</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return EditorSelection.range(json.anchor, json.head);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(from, to, flags) {</span><span class="s3">\n        </span><span class="s1">return new SelectionRange(from, to, flags);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">An editor selection holds one or more selection ranges.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class EditorSelection {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The ranges in the selection, sorted by position. Ranges cannot</span><span class="s3">\n    </span><span class="s1">overlap (but they may touch, if they aren't empty).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">ranges, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The index of the _main_ range in the selection (which is</span><span class="s3">\n    </span><span class="s1">usually the range that was added last).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">mainIndex) {</span><span class="s3">\n        </span><span class="s1">this.ranges = ranges;</span><span class="s3">\n        </span><span class="s1">this.mainIndex = mainIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map a selection through a change. Used to adjust the selection</span><span class="s3">\n    </span><span class="s1">position for changes.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map(change, assoc = -1) {</span><span class="s3">\n        </span><span class="s1">if (change.empty)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">return EditorSelection.create(this.ranges.map(r =&gt; r.map(change, assoc)), this.mainIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this selection to another selection. By default, ranges</span><span class="s3">\n    </span><span class="s1">are compared only by position. When `includeAssoc` is true,</span><span class="s3">\n    </span><span class="s1">cursor ranges must also have the same</span><span class="s3">\n    </span><span class="s1">[`assoc`](https://codemirror.net/6/docs/ref/#state.SelectionRange.assoc) value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other, includeAssoc = false) {</span><span class="s3">\n        </span><span class="s1">if (this.ranges.length != other.ranges.length ||</span><span class="s3">\n            </span><span class="s1">this.mainIndex != other.mainIndex)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.ranges.length; i++)</span><span class="s3">\n            </span><span class="s1">if (!this.ranges[i].eq(other.ranges[i], includeAssoc))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the primary selection range. Usually, you should make sure</span><span class="s3">\n    </span><span class="s1">your code applies to _all_ ranges, by using methods like</span><span class="s3">\n    </span><span class="s1">[`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get main() { return this.ranges[this.mainIndex]; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Make sure the selection only has one range. Returns a selection</span><span class="s3">\n    </span><span class="s1">holding only the main range from this selection.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">asSingle() {</span><span class="s3">\n        </span><span class="s1">return this.ranges.length == 1 ? this : new EditorSelection([this.main], 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Extend this selection with an extra range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addRange(range, main = true) {</span><span class="s3">\n        </span><span class="s1">return EditorSelection.create([range].concat(this.ranges), main ? 0 : this.mainIndex + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Replace a given range with another range, and then normalize the</span><span class="s3">\n    </span><span class="s1">selection to merge and sort ranges if necessary.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">replaceRange(range, which = this.mainIndex) {</span><span class="s3">\n        </span><span class="s1">let ranges = this.ranges.slice();</span><span class="s3">\n        </span><span class="s1">ranges[which] = range;</span><span class="s3">\n        </span><span class="s1">return EditorSelection.create(ranges, this.mainIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Convert this selection to an object that can be serialized to</span><span class="s3">\n    </span><span class="s1">JSON.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON() {</span><span class="s3">\n        </span><span class="s1">return { ranges: this.ranges.map(r =&gt; r.toJSON()), main: this.mainIndex };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a selection from a JSON representation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromJSON(json) {</span><span class="s3">\n        </span><span class="s1">if (!json || !Array.isArray(json.ranges) || typeof json.main != </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot; </span><span class="s1">|| json.main &gt;= json.ranges.length)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation for EditorSelection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new EditorSelection(json.ranges.map((r) =&gt; SelectionRange.fromJSON(r)), json.main);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a selection holding a single range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static single(anchor, head = anchor) {</span><span class="s3">\n        </span><span class="s1">return new EditorSelection([EditorSelection.range(anchor, head)], 0);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Sort and merge the given set of ranges, creating a valid</span><span class="s3">\n    </span><span class="s1">selection.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(ranges, mainIndex = 0) {</span><span class="s3">\n        </span><span class="s1">if (ranges.length == 0)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">A selection needs at least one range</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">for (let pos = 0, i = 0; i &lt; ranges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let range = ranges[i];</span><span class="s3">\n            </span><span class="s1">if (range.empty ? range.from &lt;= pos : range.from &lt; pos)</span><span class="s3">\n                </span><span class="s1">return EditorSelection.normalized(ranges.slice(), mainIndex);</span><span class="s3">\n            </span><span class="s1">pos = range.to;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new EditorSelection(ranges, mainIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a cursor selection range at the given position. You can</span><span class="s3">\n    </span><span class="s1">safely ignore the optional arguments in most situations.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static cursor(pos, assoc = 0, bidiLevel, goalColumn) {</span><span class="s3">\n        </span><span class="s1">return SelectionRange.create(pos, pos, (assoc == 0 ? 0 : assoc &lt; 0 ? 8 /* RangeFlag.AssocBefore */ : 16 /* RangeFlag.AssocAfter */) |</span><span class="s3">\n            </span><span class="s1">(bidiLevel == null ? 7 : Math.min(6, bidiLevel)) |</span><span class="s3">\n            </span><span class="s1">((goalColumn !== null &amp;&amp; goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) &lt;&lt; 6 /* RangeFlag.GoalColumnOffset */));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a selection range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static range(anchor, head, goalColumn, bidiLevel) {</span><span class="s3">\n        </span><span class="s1">let flags = ((goalColumn !== null &amp;&amp; goalColumn !== void 0 ? goalColumn : 16777215 /* RangeFlag.NoGoalColumn */) &lt;&lt; 6 /* RangeFlag.GoalColumnOffset */) |</span><span class="s3">\n            </span><span class="s1">(bidiLevel == null ? 7 : Math.min(6, bidiLevel));</span><span class="s3">\n        </span><span class="s1">return head &lt; anchor ? SelectionRange.create(head, anchor, 32 /* RangeFlag.Inverted */ | 16 /* RangeFlag.AssocAfter */ | flags)</span><span class="s3">\n            </span><span class="s1">: SelectionRange.create(anchor, head, (head &gt; anchor ? 8 /* RangeFlag.AssocBefore */ : 0) | flags);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static normalized(ranges, mainIndex = 0) {</span><span class="s3">\n        </span><span class="s1">let main = ranges[mainIndex];</span><span class="s3">\n        </span><span class="s1">ranges.sort((a, b) =&gt; a.from - b.from);</span><span class="s3">\n        </span><span class="s1">mainIndex = ranges.indexOf(main);</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; ranges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let range = ranges[i], prev = ranges[i - 1];</span><span class="s3">\n            </span><span class="s1">if (range.empty ? range.from &lt;= prev.to : range.from &lt; prev.to) {</span><span class="s3">\n                </span><span class="s1">let from = prev.from, to = Math.max(range.to, prev.to);</span><span class="s3">\n                </span><span class="s1">if (i &lt;= mainIndex)</span><span class="s3">\n                    </span><span class="s1">mainIndex--;</span><span class="s3">\n                </span><span class="s1">ranges.splice(--i, 2, range.anchor &gt; range.head ? EditorSelection.range(to, from) : EditorSelection.range(from, to));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return new EditorSelection(ranges, mainIndex);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function checkSelection(selection, docLength) {</span><span class="s3">\n    </span><span class="s1">for (let range of selection.ranges)</span><span class="s3">\n        </span><span class="s1">if (range.to &gt; docLength)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Selection points outside of document</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">let nextID = 0;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet is a labeled value that is associated with an editor</span><span class="s3">\n</span><span class="s1">state. It takes inputs from any number of extensions, and combines</span><span class="s3">\n</span><span class="s1">those into a single output value.</span><span class="s3">\n\n</span><span class="s1">Examples of uses of facets are the [tab</span><span class="s3">\n</span><span class="s1">size](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize), [editor</span><span class="s3">\n</span><span class="s1">attributes](https://codemirror.net/6/docs/ref/#view.EditorView^editorAttributes), and [update</span><span class="s3">\n</span><span class="s1">listeners](https://codemirror.net/6/docs/ref/#view.EditorView^updateListener).</span><span class="s3">\n\n</span><span class="s1">Note that `Facet` instances can be used anywhere where</span><span class="s3">\n</span><span class="s1">[`FacetReader`](https://codemirror.net/6/docs/ref/#state.FacetReader) is expected.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Facet {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">combine, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compareInput, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compare, isStatic, enables) {</span><span class="s3">\n        </span><span class="s1">this.combine = combine;</span><span class="s3">\n        </span><span class="s1">this.compareInput = compareInput;</span><span class="s3">\n        </span><span class="s1">this.compare = compare;</span><span class="s3">\n        </span><span class="s1">this.isStatic = isStatic;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.id = nextID++;</span><span class="s3">\n        </span><span class="s1">this.default = combine([]);</span><span class="s3">\n        </span><span class="s1">this.extensions = typeof enables == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">? enables(this) : enables;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns a facet reader for this facet, which can be used to</span><span class="s3">\n    </span><span class="s1">[read](https://codemirror.net/6/docs/ref/#state.EditorState.facet) it but not to define values for it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get reader() { return this; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a new facet.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(config = {}) {</span><span class="s3">\n        </span><span class="s1">return new Facet(config.combine || ((a) =&gt; a), config.compareInput || ((a, b) =&gt; a === b), config.compare || (!config.combine ? sameArray : (a, b) =&gt; a === b), !!config.static, config.enables);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns an extension that adds the given value to this facet.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">of(value) {</span><span class="s3">\n        </span><span class="s1">return new FacetProvider([], this, 0 /* Provider.Static */, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an extension that computes a value for the facet from a</span><span class="s3">\n    </span><span class="s1">state. You must take care to declare the parts of the state that</span><span class="s3">\n    </span><span class="s1">this value depends on, since your function is only called again</span><span class="s3">\n    </span><span class="s1">for a new state when one of those parts changed.</span><span class="s3">\n    \n    </span><span class="s1">In cases where your value depends only on a single field, you'll</span><span class="s3">\n    </span><span class="s1">want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">compute(deps, get) {</span><span class="s3">\n        </span><span class="s1">if (this.isStatic)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't compute a static facet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new FacetProvider(deps, this, 1 /* Provider.Single */, get);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an extension that computes zero or more values for this</span><span class="s3">\n    </span><span class="s1">facet from a state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">computeN(deps, get) {</span><span class="s3">\n        </span><span class="s1">if (this.isStatic)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Can't compute a static facet</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return new FacetProvider(deps, this, 2 /* Provider.Multi */, get);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">from(field, get) {</span><span class="s3">\n        </span><span class="s1">if (!get)</span><span class="s3">\n            </span><span class="s1">get = x =&gt; x;</span><span class="s3">\n        </span><span class="s1">return this.compute([field], state =&gt; get(state.field(field)));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameArray(a, b) {</span><span class="s3">\n    </span><span class="s1">return a == b || a.length == b.length &amp;&amp; a.every((e, i) =&gt; e === b[i]);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class FacetProvider {</span><span class="s3">\n    </span><span class="s1">constructor(dependencies, facet, type, value) {</span><span class="s3">\n        </span><span class="s1">this.dependencies = dependencies;</span><span class="s3">\n        </span><span class="s1">this.facet = facet;</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.id = nextID++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">dynamicSlot(addresses) {</span><span class="s3">\n        </span><span class="s1">var _a;</span><span class="s3">\n        </span><span class="s1">let getter = this.value;</span><span class="s3">\n        </span><span class="s1">let compare = this.facet.compareInput;</span><span class="s3">\n        </span><span class="s1">let id = this.id, idx = addresses[id] &gt;&gt; 1, multi = this.type == 2 /* Provider.Multi */;</span><span class="s3">\n        </span><span class="s1">let depDoc = false, depSel = false, depAddrs = [];</span><span class="s3">\n        </span><span class="s1">for (let dep of this.dependencies) {</span><span class="s3">\n            </span><span class="s1">if (dep == </span><span class="s3">\&quot;</span><span class="s1">doc</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">depDoc = true;</span><span class="s3">\n            </span><span class="s1">else if (dep == </span><span class="s3">\&quot;</span><span class="s1">selection</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                </span><span class="s1">depSel = true;</span><span class="s3">\n            </span><span class="s1">else if ((((_a = addresses[dep.id]) !== null &amp;&amp; _a !== void 0 ? _a : 1) &amp; 1) == 0)</span><span class="s3">\n                </span><span class="s1">depAddrs.push(addresses[dep.id]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">create(state) {</span><span class="s3">\n                </span><span class="s1">state.values[idx] = getter(state);</span><span class="s3">\n                </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">update(state, tr) {</span><span class="s3">\n                </span><span class="s1">if ((depDoc &amp;&amp; tr.docChanged) || (depSel &amp;&amp; (tr.docChanged || tr.selection)) || ensureAll(state, depAddrs)) {</span><span class="s3">\n                    </span><span class="s1">let newVal = getter(state);</span><span class="s3">\n                    </span><span class="s1">if (multi ? !compareArray(newVal, state.values[idx], compare) : !compare(newVal, state.values[idx])) {</span><span class="s3">\n                        </span><span class="s1">state.values[idx] = newVal;</span><span class="s3">\n                        </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">reconfigure: (state, oldState) =&gt; {</span><span class="s3">\n                </span><span class="s1">let newVal, oldAddr = oldState.config.address[id];</span><span class="s3">\n                </span><span class="s1">if (oldAddr != null) {</span><span class="s3">\n                    </span><span class="s1">let oldVal = getAddr(oldState, oldAddr);</span><span class="s3">\n                    </span><span class="s1">if (this.dependencies.every(dep =&gt; {</span><span class="s3">\n                        </span><span class="s1">return dep instanceof Facet ? oldState.facet(dep) === state.facet(dep) :</span><span class="s3">\n                            </span><span class="s1">dep instanceof StateField ? oldState.field(dep, false) == state.field(dep, false) : true;</span><span class="s3">\n                    </span><span class="s1">}) || (multi ? compareArray(newVal = getter(state), oldVal, compare) : compare(newVal = getter(state), oldVal))) {</span><span class="s3">\n                        </span><span class="s1">state.values[idx] = oldVal;</span><span class="s3">\n                        </span><span class="s1">return 0;</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">newVal = getter(state);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">state.values[idx] = newVal;</span><span class="s3">\n                </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compareArray(a, b, compare) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (!compare(a[i], b[i]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ensureAll(state, addrs) {</span><span class="s3">\n    </span><span class="s1">let changed = false;</span><span class="s3">\n    </span><span class="s1">for (let addr of addrs)</span><span class="s3">\n        </span><span class="s1">if (ensureAddr(state, addr) &amp; 1 /* SlotStatus.Changed */)</span><span class="s3">\n            </span><span class="s1">changed = true;</span><span class="s3">\n    </span><span class="s1">return changed;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function dynamicFacetSlot(addresses, facet, providers) {</span><span class="s3">\n    </span><span class="s1">let providerAddrs = providers.map(p =&gt; addresses[p.id]);</span><span class="s3">\n    </span><span class="s1">let providerTypes = providers.map(p =&gt; p.type);</span><span class="s3">\n    </span><span class="s1">let dynamic = providerAddrs.filter(p =&gt; !(p &amp; 1));</span><span class="s3">\n    </span><span class="s1">let idx = addresses[facet.id] &gt;&gt; 1;</span><span class="s3">\n    </span><span class="s1">function get(state) {</span><span class="s3">\n        </span><span class="s1">let values = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; providerAddrs.length; i++) {</span><span class="s3">\n            </span><span class="s1">let value = getAddr(state, providerAddrs[i]);</span><span class="s3">\n            </span><span class="s1">if (providerTypes[i] == 2 /* Provider.Multi */)</span><span class="s3">\n                </span><span class="s1">for (let val of value)</span><span class="s3">\n                    </span><span class="s1">values.push(val);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">values.push(value);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return facet.combine(values);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">create(state) {</span><span class="s3">\n            </span><span class="s1">for (let addr of providerAddrs)</span><span class="s3">\n                </span><span class="s1">ensureAddr(state, addr);</span><span class="s3">\n            </span><span class="s1">state.values[idx] = get(state);</span><span class="s3">\n            </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">update(state, tr) {</span><span class="s3">\n            </span><span class="s1">if (!ensureAll(state, dynamic))</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">let value = get(state);</span><span class="s3">\n            </span><span class="s1">if (facet.compare(value, state.values[idx]))</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">state.values[idx] = value;</span><span class="s3">\n            </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">reconfigure(state, oldState) {</span><span class="s3">\n            </span><span class="s1">let depChanged = ensureAll(state, providerAddrs);</span><span class="s3">\n            </span><span class="s1">let oldProviders = oldState.config.facets[facet.id], oldValue = oldState.facet(facet);</span><span class="s3">\n            </span><span class="s1">if (oldProviders &amp;&amp; !depChanged &amp;&amp; sameArray(providers, oldProviders)) {</span><span class="s3">\n                </span><span class="s1">state.values[idx] = oldValue;</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">let value = get(state);</span><span class="s3">\n            </span><span class="s1">if (facet.compare(value, oldValue)) {</span><span class="s3">\n                </span><span class="s1">state.values[idx] = oldValue;</span><span class="s3">\n                </span><span class="s1">return 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state.values[idx] = value;</span><span class="s3">\n            </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const initField = /*@__PURE__*/Facet.define({ static: true });</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Fields can store additional information in an editor state, and</span><span class="s3">\n</span><span class="s1">keep it in sync with the rest of the state.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class StateField {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">id, createF, updateF, compareF, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">spec) {</span><span class="s3">\n        </span><span class="s1">this.id = id;</span><span class="s3">\n        </span><span class="s1">this.createF = createF;</span><span class="s3">\n        </span><span class="s1">this.updateF = updateF;</span><span class="s3">\n        </span><span class="s1">this.compareF = compareF;</span><span class="s3">\n        </span><span class="s1">this.spec = spec;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this.provides = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a state field.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(config) {</span><span class="s3">\n        </span><span class="s1">let field = new StateField(nextID++, config.create, config.update, config.compare || ((a, b) =&gt; a === b), config);</span><span class="s3">\n        </span><span class="s1">if (config.provide)</span><span class="s3">\n            </span><span class="s1">field.provides = config.provide(field);</span><span class="s3">\n        </span><span class="s1">return field;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">create(state) {</span><span class="s3">\n        </span><span class="s1">let init = state.facet(initField).find(i =&gt; i.field == this);</span><span class="s3">\n        </span><span class="s1">return ((init === null || init === void 0 ? void 0 : init.create) || this.createF)(state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">slot(addresses) {</span><span class="s3">\n        </span><span class="s1">let idx = addresses[this.id] &gt;&gt; 1;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">create: (state) =&gt; {</span><span class="s3">\n                </span><span class="s1">state.values[idx] = this.create(state);</span><span class="s3">\n                </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">update: (state, tr) =&gt; {</span><span class="s3">\n                </span><span class="s1">let oldVal = state.values[idx];</span><span class="s3">\n                </span><span class="s1">let value = this.updateF(oldVal, tr);</span><span class="s3">\n                </span><span class="s1">if (this.compareF(oldVal, value))</span><span class="s3">\n                    </span><span class="s1">return 0;</span><span class="s3">\n                </span><span class="s1">state.values[idx] = value;</span><span class="s3">\n                </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">reconfigure: (state, oldState) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (oldState.config.address[this.id] != null) {</span><span class="s3">\n                    </span><span class="s1">state.values[idx] = oldState.field(this);</span><span class="s3">\n                    </span><span class="s1">return 0;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">state.values[idx] = this.create(state);</span><span class="s3">\n                </span><span class="s1">return 1 /* SlotStatus.Changed */;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns an extension that enables this field and overrides the</span><span class="s3">\n    </span><span class="s1">way it is initialized. Can be useful when you need to provide a</span><span class="s3">\n    </span><span class="s1">non-default starting value for the field.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">init(create) {</span><span class="s3">\n        </span><span class="s1">return [this, initField.of({ field: this, create })];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">State field instances can be used as</span><span class="s3">\n    </span><span class="s1">[`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a</span><span class="s3">\n    </span><span class="s1">given state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get extension() { return this; }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const Prec_ = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };</span><span class="s3">\n</span><span class="s1">function prec(value) {</span><span class="s3">\n    </span><span class="s1">return (ext) =&gt; new PrecExtension(ext, value);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">By default extensions are registered in the order they are found</span><span class="s3">\n</span><span class="s1">in the flattened form of nested array that was provided.</span><span class="s3">\n</span><span class="s1">Individual extension values can be assigned a precedence to</span><span class="s3">\n</span><span class="s1">override this. Extensions that do not have a precedence set get</span><span class="s3">\n</span><span class="s1">the precedence of the nearest parent with a precedence, or</span><span class="s3">\n</span><span class="s1">[`default`](https://codemirror.net/6/docs/ref/#state.Prec.default) if there is no such parent. The</span><span class="s3">\n</span><span class="s1">final ordering of extensions is determined by first sorting by</span><span class="s3">\n</span><span class="s1">precedence and then by order within each precedence.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">const Prec = {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The highest precedence level, for extensions that should end up</span><span class="s3">\n    </span><span class="s1">near the start of the precedence ordering.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">highest: /*@__PURE__*/prec(Prec_.highest),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A higher-than-default precedence, for extensions that should</span><span class="s3">\n    </span><span class="s1">come before those with default precedence.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">high: /*@__PURE__*/prec(Prec_.high),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The default precedence, which is also used for extensions</span><span class="s3">\n    </span><span class="s1">without an explicit precedence.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">default: /*@__PURE__*/prec(Prec_.default),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">A lower-than-default precedence.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">low: /*@__PURE__*/prec(Prec_.low),</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The lowest precedence level. Meant for things that should end up</span><span class="s3">\n    </span><span class="s1">near the end of the extension order.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">lowest: /*@__PURE__*/prec(Prec_.lowest)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">class PrecExtension {</span><span class="s3">\n    </span><span class="s1">constructor(inner, prec) {</span><span class="s3">\n        </span><span class="s1">this.inner = inner;</span><span class="s3">\n        </span><span class="s1">this.prec = prec;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Extension compartments can be used to make a configuration</span><span class="s3">\n</span><span class="s1">dynamic. By [wrapping](https://codemirror.net/6/docs/ref/#state.Compartment.of) part of your</span><span class="s3">\n</span><span class="s1">configuration in a compartment, you can later</span><span class="s3">\n</span><span class="s1">[replace](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure) that part through a</span><span class="s3">\n</span><span class="s1">transaction.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Compartment {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an instance of this compartment to add to your [state</span><span class="s3">\n    </span><span class="s1">configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">of(ext) { return new CompartmentInstance(this, ext); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that</span><span class="s3">\n    </span><span class="s1">reconfigures this compartment.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">reconfigure(content) {</span><span class="s3">\n        </span><span class="s1">return Compartment.reconfigure.of({ compartment: this, extension: content });</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the current content of the compartment in the state, or</span><span class="s3">\n    </span><span class="s1">`undefined` if it isn't present.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get(state) {</span><span class="s3">\n        </span><span class="s1">return state.config.compartments.get(this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class CompartmentInstance {</span><span class="s3">\n    </span><span class="s1">constructor(compartment, inner) {</span><span class="s3">\n        </span><span class="s1">this.compartment = compartment;</span><span class="s3">\n        </span><span class="s1">this.inner = inner;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Configuration {</span><span class="s3">\n    </span><span class="s1">constructor(base, compartments, dynamicSlots, address, staticValues, facets) {</span><span class="s3">\n        </span><span class="s1">this.base = base;</span><span class="s3">\n        </span><span class="s1">this.compartments = compartments;</span><span class="s3">\n        </span><span class="s1">this.dynamicSlots = dynamicSlots;</span><span class="s3">\n        </span><span class="s1">this.address = address;</span><span class="s3">\n        </span><span class="s1">this.staticValues = staticValues;</span><span class="s3">\n        </span><span class="s1">this.facets = facets;</span><span class="s3">\n        </span><span class="s1">this.statusTemplate = [];</span><span class="s3">\n        </span><span class="s1">while (this.statusTemplate.length &lt; dynamicSlots.length)</span><span class="s3">\n            </span><span class="s1">this.statusTemplate.push(0 /* SlotStatus.Unresolved */);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">staticFacet(facet) {</span><span class="s3">\n        </span><span class="s1">let addr = this.address[facet.id];</span><span class="s3">\n        </span><span class="s1">return addr == null ? facet.default : this.staticValues[addr &gt;&gt; 1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static resolve(base, compartments, oldState) {</span><span class="s3">\n        </span><span class="s1">let fields = [];</span><span class="s3">\n        </span><span class="s1">let facets = Object.create(null);</span><span class="s3">\n        </span><span class="s1">let newCompartments = new Map();</span><span class="s3">\n        </span><span class="s1">for (let ext of flatten(base, compartments, newCompartments)) {</span><span class="s3">\n            </span><span class="s1">if (ext instanceof StateField)</span><span class="s3">\n                </span><span class="s1">fields.push(ext);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">(facets[ext.facet.id] || (facets[ext.facet.id] = [])).push(ext);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let address = Object.create(null);</span><span class="s3">\n        </span><span class="s1">let staticValues = [];</span><span class="s3">\n        </span><span class="s1">let dynamicSlots = [];</span><span class="s3">\n        </span><span class="s1">for (let field of fields) {</span><span class="s3">\n            </span><span class="s1">address[field.id] = dynamicSlots.length &lt;&lt; 1;</span><span class="s3">\n            </span><span class="s1">dynamicSlots.push(a =&gt; field.slot(a));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let oldFacets = oldState === null || oldState === void 0 ? void 0 : oldState.config.facets;</span><span class="s3">\n        </span><span class="s1">for (let id in facets) {</span><span class="s3">\n            </span><span class="s1">let providers = facets[id], facet = providers[0].facet;</span><span class="s3">\n            </span><span class="s1">let oldProviders = oldFacets &amp;&amp; oldFacets[id] || [];</span><span class="s3">\n            </span><span class="s1">if (providers.every(p =&gt; p.type == 0 /* Provider.Static */)) {</span><span class="s3">\n                </span><span class="s1">address[facet.id] = (staticValues.length &lt;&lt; 1) | 1;</span><span class="s3">\n                </span><span class="s1">if (sameArray(oldProviders, providers)) {</span><span class="s3">\n                    </span><span class="s1">staticValues.push(oldState.facet(facet));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else {</span><span class="s3">\n                    </span><span class="s1">let value = facet.combine(providers.map(p =&gt; p.value));</span><span class="s3">\n                    </span><span class="s1">staticValues.push(oldState &amp;&amp; facet.compare(value, oldState.facet(facet)) ? oldState.facet(facet) : value);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">for (let p of providers) {</span><span class="s3">\n                    </span><span class="s1">if (p.type == 0 /* Provider.Static */) {</span><span class="s3">\n                        </span><span class="s1">address[p.id] = (staticValues.length &lt;&lt; 1) | 1;</span><span class="s3">\n                        </span><span class="s1">staticValues.push(p.value);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">else {</span><span class="s3">\n                        </span><span class="s1">address[p.id] = dynamicSlots.length &lt;&lt; 1;</span><span class="s3">\n                        </span><span class="s1">dynamicSlots.push(a =&gt; p.dynamicSlot(a));</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">address[facet.id] = dynamicSlots.length &lt;&lt; 1;</span><span class="s3">\n                </span><span class="s1">dynamicSlots.push(a =&gt; dynamicFacetSlot(a, facet, providers));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let dynamic = dynamicSlots.map(f =&gt; f(address));</span><span class="s3">\n        </span><span class="s1">return new Configuration(base, newCompartments, dynamic, address, staticValues, facets);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function flatten(extension, compartments, newCompartments) {</span><span class="s3">\n    </span><span class="s1">let result = [[], [], [], [], []];</span><span class="s3">\n    </span><span class="s1">let seen = new Map();</span><span class="s3">\n    </span><span class="s1">function inner(ext, prec) {</span><span class="s3">\n        </span><span class="s1">let known = seen.get(ext);</span><span class="s3">\n        </span><span class="s1">if (known != null) {</span><span class="s3">\n            </span><span class="s1">if (known &lt;= prec)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n            </span><span class="s1">let found = result[known].indexOf(ext);</span><span class="s3">\n            </span><span class="s1">if (found &gt; -1)</span><span class="s3">\n                </span><span class="s1">result[known].splice(found, 1);</span><span class="s3">\n            </span><span class="s1">if (ext instanceof CompartmentInstance)</span><span class="s3">\n                </span><span class="s1">newCompartments.delete(ext.compartment);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">seen.set(ext, prec);</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(ext)) {</span><span class="s3">\n            </span><span class="s1">for (let e of ext)</span><span class="s3">\n                </span><span class="s1">inner(e, prec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ext instanceof CompartmentInstance) {</span><span class="s3">\n            </span><span class="s1">if (newCompartments.has(ext.compartment))</span><span class="s3">\n                </span><span class="s1">throw new RangeError(`Duplicate use of compartment in extensions`);</span><span class="s3">\n            </span><span class="s1">let content = compartments.get(ext.compartment) || ext.inner;</span><span class="s3">\n            </span><span class="s1">newCompartments.set(ext.compartment, content);</span><span class="s3">\n            </span><span class="s1">inner(content, prec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ext instanceof PrecExtension) {</span><span class="s3">\n            </span><span class="s1">inner(ext.inner, ext.prec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ext instanceof StateField) {</span><span class="s3">\n            </span><span class="s1">result[prec].push(ext);</span><span class="s3">\n            </span><span class="s1">if (ext.provides)</span><span class="s3">\n                </span><span class="s1">inner(ext.provides, prec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (ext instanceof FacetProvider) {</span><span class="s3">\n            </span><span class="s1">result[prec].push(ext);</span><span class="s3">\n            </span><span class="s1">if (ext.facet.extensions)</span><span class="s3">\n                </span><span class="s1">inner(ext.facet.extensions, Prec_.default);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let content = ext.extension;</span><span class="s3">\n            </span><span class="s1">if (!content)</span><span class="s3">\n                </span><span class="s1">throw new Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);</span><span class="s3">\n            </span><span class="s1">inner(content, prec);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">inner(extension, Prec_.default);</span><span class="s3">\n    </span><span class="s1">return result.reduce((a, b) =&gt; a.concat(b));</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function ensureAddr(state, addr) {</span><span class="s3">\n    </span><span class="s1">if (addr &amp; 1)</span><span class="s3">\n        </span><span class="s1">return 2 /* SlotStatus.Computed */;</span><span class="s3">\n    </span><span class="s1">let idx = addr &gt;&gt; 1;</span><span class="s3">\n    </span><span class="s1">let status = state.status[idx];</span><span class="s3">\n    </span><span class="s1">if (status == 4 /* SlotStatus.Computing */)</span><span class="s3">\n        </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Cyclic dependency between fields and/or facets</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (status &amp; 2 /* SlotStatus.Computed */)</span><span class="s3">\n        </span><span class="s1">return status;</span><span class="s3">\n    </span><span class="s1">state.status[idx] = 4 /* SlotStatus.Computing */;</span><span class="s3">\n    </span><span class="s1">let changed = state.computeSlot(state, state.config.dynamicSlots[idx]);</span><span class="s3">\n    </span><span class="s1">return state.status[idx] = 2 /* SlotStatus.Computed */ | changed;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function getAddr(state, addr) {</span><span class="s3">\n    </span><span class="s1">return addr &amp; 1 ? state.config.staticValues[addr &gt;&gt; 1] : state.values[addr &gt;&gt; 1];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">const languageData = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const allowMultipleSelections = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.some(v =&gt; v),</span><span class="s3">\n    </span><span class="s1">static: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const lineSeparator = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.length ? values[0] : undefined,</span><span class="s3">\n    </span><span class="s1">static: true</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">const changeFilter = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const transactionFilter = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const transactionExtender = /*@__PURE__*/Facet.define();</span><span class="s3">\n</span><span class="s1">const readOnly = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.length ? values[0] : false</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Annotations are tagged values that are used to add metadata to</span><span class="s3">\n</span><span class="s1">transactions in an extensible way. They should be used to model</span><span class="s3">\n</span><span class="s1">things that effect the entire transaction (such as its [time</span><span class="s3">\n</span><span class="s1">stamp](https://codemirror.net/6/docs/ref/#state.Transaction^time) or information about its</span><span class="s3">\n</span><span class="s1">[origin](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent)). For effects that happen</span><span class="s3">\n</span><span class="s1">_alongside_ the other changes made by the transaction, [state</span><span class="s3">\n</span><span class="s1">effects](https://codemirror.net/6/docs/ref/#state.StateEffect) are more appropriate.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Annotation {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The annotation type.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">type, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The value of this annotation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">value) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a new type of annotation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define() { return new AnnotationType(); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Marker that identifies a type of [annotation](https://codemirror.net/6/docs/ref/#state.Annotation).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class AnnotationType {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an instance of this annotation.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">of(value) { return new Annotation(this, value); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Representation of a type of state effect. Defined with</span><span class="s3">\n</span><span class="s1">[`StateEffect.define`](https://codemirror.net/6/docs/ref/#state.StateEffect^define).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class StateEffectType {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">// The `any` types in these function types are there to work</span><span class="s3">\n    </span><span class="s1">// around TypeScript issue #37631, where the type guard on</span><span class="s3">\n    </span><span class="s1">// `StateEffect.is` mysteriously stops working when these properly</span><span class="s3">\n    </span><span class="s1">// have type `Value`.</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map) {</span><span class="s3">\n        </span><span class="s1">this.map = map;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this</span><span class="s3">\n    </span><span class="s1">type.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">of(value) { return new StateEffect(this, value); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">State effects can be used to represent additional effects</span><span class="s3">\n</span><span class="s1">associated with a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction.effects). They</span><span class="s3">\n</span><span class="s1">are often useful to model changes to custom [state</span><span class="s3">\n</span><span class="s1">fields](https://codemirror.net/6/docs/ref/#state.StateField), when those changes aren't implicit in</span><span class="s3">\n</span><span class="s1">document or selection changes.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class StateEffect {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">type, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The value of this effect.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">value) {</span><span class="s3">\n        </span><span class="s1">this.type = type;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map this effect through a position mapping. Will return</span><span class="s3">\n    </span><span class="s1">`undefined` when that ends up deleting the effect.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map(mapping) {</span><span class="s3">\n        </span><span class="s1">let mapped = this.type.map(this.value, mapping);</span><span class="s3">\n        </span><span class="s1">return mapped === undefined ? undefined : mapped == this.value ? this : new StateEffect(this.type, mapped);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Tells you whether this effect object is of a given</span><span class="s3">\n    </span><span class="s1">[type](https://codemirror.net/6/docs/ref/#state.StateEffectType).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">is(type) { return this.type == type; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Define a new effect type. The type parameter indicates the type</span><span class="s3">\n    </span><span class="s1">of values that his effect holds. It should be a type that</span><span class="s3">\n    </span><span class="s1">doesn't include `undefined`, since that is used in</span><span class="s3">\n    </span><span class="s1">[mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is</span><span class="s3">\n    </span><span class="s1">removed.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static define(spec = {}) {</span><span class="s3">\n        </span><span class="s1">return new StateEffectType(spec.map || (v =&gt; v));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map an array of effects through a change set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static mapEffects(effects, mapping) {</span><span class="s3">\n        </span><span class="s1">if (!effects.length)</span><span class="s3">\n            </span><span class="s1">return effects;</span><span class="s3">\n        </span><span class="s1">let result = [];</span><span class="s3">\n        </span><span class="s1">for (let effect of effects) {</span><span class="s3">\n            </span><span class="s1">let mapped = effect.map(mapping);</span><span class="s3">\n            </span><span class="s1">if (mapped)</span><span class="s3">\n                </span><span class="s1">result.push(mapped);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This effect can be used to reconfigure the root extensions of</span><span class="s3">\n</span><span class="s1">the editor. Doing this will discard any extensions</span><span class="s3">\n</span><span class="s1">[appended](https://codemirror.net/6/docs/ref/#state.StateEffect^appendConfig), but does not reset</span><span class="s3">\n</span><span class="s1">the content of [reconfigured](https://codemirror.net/6/docs/ref/#state.Compartment.reconfigure)</span><span class="s3">\n</span><span class="s1">compartments.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">StateEffect.reconfigure = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Append extensions to the top-level configuration of the editor.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">StateEffect.appendConfig = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Changes to the editor state are grouped into transactions.</span><span class="s3">\n</span><span class="s1">Typically, a user action creates a single transaction, which may</span><span class="s3">\n</span><span class="s1">contain any number of document changes, may change the selection,</span><span class="s3">\n</span><span class="s1">or have other effects. Create a transaction by calling</span><span class="s3">\n</span><span class="s1">[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update), or immediately</span><span class="s3">\n</span><span class="s1">dispatch one by calling</span><span class="s3">\n</span><span class="s1">[`EditorView.dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Transaction {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The state from which the transaction starts.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">startState, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The document changes made by this transaction.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">changes, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The selection set by this transaction, or undefined if it</span><span class="s3">\n    </span><span class="s1">doesn't explicitly set a selection.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">selection, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The effects added to the transaction.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">effects, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">annotations, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whether the selection should be scrolled into view after this</span><span class="s3">\n    </span><span class="s1">transaction is dispatched.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">scrollIntoView) {</span><span class="s3">\n        </span><span class="s1">this.startState = startState;</span><span class="s3">\n        </span><span class="s1">this.changes = changes;</span><span class="s3">\n        </span><span class="s1">this.selection = selection;</span><span class="s3">\n        </span><span class="s1">this.effects = effects;</span><span class="s3">\n        </span><span class="s1">this.annotations = annotations;</span><span class="s3">\n        </span><span class="s1">this.scrollIntoView = scrollIntoView;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._doc = null;</span><span class="s3">\n        </span><span class="s1">/**</span><span class="s3">\n        </span><span class="s1">@internal</span><span class="s3">\n        </span><span class="s1">*/</span><span class="s3">\n        </span><span class="s1">this._state = null;</span><span class="s3">\n        </span><span class="s1">if (selection)</span><span class="s3">\n            </span><span class="s1">checkSelection(selection, changes.newLength);</span><span class="s3">\n        </span><span class="s1">if (!annotations.some((a) =&gt; a.type == Transaction.time))</span><span class="s3">\n            </span><span class="s1">this.annotations = annotations.concat(Transaction.time.of(Date.now()));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(startState, changes, selection, effects, annotations, scrollIntoView) {</span><span class="s3">\n        </span><span class="s1">return new Transaction(startState, changes, selection, effects, annotations, scrollIntoView);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The new document produced by the transaction. Contrary to</span><span class="s3">\n    </span><span class="s1">[`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't</span><span class="s3">\n    </span><span class="s1">force the entire new state to be computed right away, so it is</span><span class="s3">\n    </span><span class="s1">recommended that [transaction</span><span class="s3">\n    </span><span class="s1">filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter</span><span class="s3">\n    </span><span class="s1">when they need to look at the new document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get newDoc() {</span><span class="s3">\n        </span><span class="s1">return this._doc || (this._doc = this.changes.apply(this.startState.doc));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The new selection produced by the transaction. If</span><span class="s3">\n    </span><span class="s1">[`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,</span><span class="s3">\n    </span><span class="s1">this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's</span><span class="s3">\n    </span><span class="s1">current selection through the changes made by the transaction.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get newSelection() {</span><span class="s3">\n        </span><span class="s1">return this.selection || this.startState.selection.map(this.changes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The new state created by the transaction. Computed on demand</span><span class="s3">\n    </span><span class="s1">(but retained for subsequent access), so it is recommended not to</span><span class="s3">\n    </span><span class="s1">access it in [transaction</span><span class="s3">\n    </span><span class="s1">filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get state() {</span><span class="s3">\n        </span><span class="s1">if (!this._state)</span><span class="s3">\n            </span><span class="s1">this.startState.applyTransaction(this);</span><span class="s3">\n        </span><span class="s1">return this._state;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the value of the given annotation type, if any.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">annotation(type) {</span><span class="s3">\n        </span><span class="s1">for (let ann of this.annotations)</span><span class="s3">\n            </span><span class="s1">if (ann.type == type)</span><span class="s3">\n                </span><span class="s1">return ann.value;</span><span class="s3">\n        </span><span class="s1">return undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether the transaction changed the document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get docChanged() { return !this.changes.empty; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Indicates whether this transaction reconfigures the state</span><span class="s3">\n    </span><span class="s1">(through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or</span><span class="s3">\n    </span><span class="s1">with a top-level configuration</span><span class="s3">\n    </span><span class="s1">[effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get reconfigured() { return this.startState.config != this.state.config; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns true if the transaction has a [user</span><span class="s3">\n    </span><span class="s1">event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to</span><span class="s3">\n    </span><span class="s1">or more specific than `event`. For example, if the transaction</span><span class="s3">\n    </span><span class="s1">has `</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">` as user event, `</span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">` and</span><span class="s3">\n    </span><span class="s1">`</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">` will match it.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">isUserEvent(event) {</span><span class="s3">\n        </span><span class="s1">let e = this.annotation(Transaction.userEvent);</span><span class="s3">\n        </span><span class="s1">return !!(e &amp;&amp; (e == event || e.length &gt; event.length &amp;&amp; e.slice(0, event.length) == event &amp;&amp; e[event.length] == </span><span class="s3">\&quot;</span><span class="s1">.</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Annotation used to store transaction timestamps. Automatically</span><span class="s3">\n</span><span class="s1">added to every transaction, holding `Date.now()`.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Transaction.time = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Annotation used to associate a transaction with a user interface</span><span class="s3">\n</span><span class="s1">event. Holds a string identifying the event, using a</span><span class="s3">\n</span><span class="s1">dot-separated format to support attaching more specific</span><span class="s3">\n</span><span class="s1">information. The events used by the core libraries are:</span><span class="s3">\n\n </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input</span><span class="s3">\&quot;</span><span class="s1">` when content is entered</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input.type</span><span class="s3">\&quot;</span><span class="s1">` for typed input</span><span class="s3">\n     </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input.type.compose</span><span class="s3">\&quot;</span><span class="s1">` for composition</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input.paste</span><span class="s3">\&quot;</span><span class="s1">` for pasted input</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input.drop</span><span class="s3">\&quot;</span><span class="s1">` when adding content with drag-and-drop</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">input.complete</span><span class="s3">\&quot;</span><span class="s1">` when autocompleting</span><span class="s3">\n </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">delete</span><span class="s3">\&quot;</span><span class="s1">` when the user deletes content</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">delete.selection</span><span class="s3">\&quot;</span><span class="s1">` when deleting the selection</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">delete.forward</span><span class="s3">\&quot;</span><span class="s1">` when deleting forward from the selection</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">delete.backward</span><span class="s3">\&quot;</span><span class="s1">` when deleting backward from the selection</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">delete.cut</span><span class="s3">\&quot;</span><span class="s1">` when cutting to the clipboard</span><span class="s3">\n </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">move</span><span class="s3">\&quot;</span><span class="s1">` when content is moved</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">move.drop</span><span class="s3">\&quot;</span><span class="s1">` when content is moved within the editor through drag-and-drop</span><span class="s3">\n </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">select</span><span class="s3">\&quot;</span><span class="s1">` when explicitly changing the selection</span><span class="s3">\n   </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">select.pointer</span><span class="s3">\&quot;</span><span class="s1">` when selecting with a mouse or other pointing device</span><span class="s3">\n </span><span class="s1">- `</span><span class="s3">\&quot;</span><span class="s1">undo</span><span class="s3">\&quot;</span><span class="s1">` and `</span><span class="s3">\&quot;</span><span class="s1">redo</span><span class="s3">\&quot;</span><span class="s1">` for history actions</span><span class="s3">\n\n</span><span class="s1">Use [`isUserEvent`](https://codemirror.net/6/docs/ref/#state.Transaction.isUserEvent) to check</span><span class="s3">\n</span><span class="s1">whether the annotation matches a given event.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Transaction.userEvent = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Annotation indicating whether a transaction should be added to</span><span class="s3">\n</span><span class="s1">the undo history or not.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Transaction.addToHistory = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Annotation indicating (when present and true) that a transaction</span><span class="s3">\n</span><span class="s1">represents a change made by some other actor, not the user. This</span><span class="s3">\n</span><span class="s1">is used, for example, to tag other people's changes in</span><span class="s3">\n</span><span class="s1">collaborative editing.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Transaction.remote = /*@__PURE__*/Annotation.define();</span><span class="s3">\n</span><span class="s1">function joinRanges(a, b) {</span><span class="s3">\n    </span><span class="s1">let result = [];</span><span class="s3">\n    </span><span class="s1">for (let iA = 0, iB = 0;;) {</span><span class="s3">\n        </span><span class="s1">let from, to;</span><span class="s3">\n        </span><span class="s1">if (iA &lt; a.length &amp;&amp; (iB == b.length || b[iB] &gt;= a[iA])) {</span><span class="s3">\n            </span><span class="s1">from = a[iA++];</span><span class="s3">\n            </span><span class="s1">to = a[iA++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else if (iB &lt; b.length) {</span><span class="s3">\n            </span><span class="s1">from = b[iB++];</span><span class="s3">\n            </span><span class="s1">to = b[iB++];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">return result;</span><span class="s3">\n        </span><span class="s1">if (!result.length || result[result.length - 1] &lt; from)</span><span class="s3">\n            </span><span class="s1">result.push(from, to);</span><span class="s3">\n        </span><span class="s1">else if (result[result.length - 1] &lt; to)</span><span class="s3">\n            </span><span class="s1">result[result.length - 1] = to;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function mergeTransaction(a, b, sequential) {</span><span class="s3">\n    </span><span class="s1">var _a;</span><span class="s3">\n    </span><span class="s1">let mapForA, mapForB, changes;</span><span class="s3">\n    </span><span class="s1">if (sequential) {</span><span class="s3">\n        </span><span class="s1">mapForA = b.changes;</span><span class="s3">\n        </span><span class="s1">mapForB = ChangeSet.empty(b.changes.length);</span><span class="s3">\n        </span><span class="s1">changes = a.changes.compose(b.changes);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">mapForA = b.changes.map(a.changes);</span><span class="s3">\n        </span><span class="s1">mapForB = a.changes.mapDesc(b.changes, true);</span><span class="s3">\n        </span><span class="s1">changes = a.changes.compose(mapForA);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">changes,</span><span class="s3">\n        </span><span class="s1">selection: b.selection ? b.selection.map(mapForB) : (_a = a.selection) === null || _a === void 0 ? void 0 : _a.map(mapForA),</span><span class="s3">\n        </span><span class="s1">effects: StateEffect.mapEffects(a.effects, mapForA).concat(StateEffect.mapEffects(b.effects, mapForB)),</span><span class="s3">\n        </span><span class="s1">annotations: a.annotations.length ? a.annotations.concat(b.annotations) : b.annotations,</span><span class="s3">\n        </span><span class="s1">scrollIntoView: a.scrollIntoView || b.scrollIntoView</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveTransactionInner(state, spec, docSize) {</span><span class="s3">\n    </span><span class="s1">let sel = spec.selection, annotations = asArray(spec.annotations);</span><span class="s3">\n    </span><span class="s1">if (spec.userEvent)</span><span class="s3">\n        </span><span class="s1">annotations = annotations.concat(Transaction.userEvent.of(spec.userEvent));</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n        </span><span class="s1">changes: spec.changes instanceof ChangeSet ? spec.changes</span><span class="s3">\n            </span><span class="s1">: ChangeSet.of(spec.changes || [], docSize, state.facet(lineSeparator)),</span><span class="s3">\n        </span><span class="s1">selection: sel &amp;&amp; (sel instanceof EditorSelection ? sel : EditorSelection.single(sel.anchor, sel.head)),</span><span class="s3">\n        </span><span class="s1">effects: asArray(spec.effects),</span><span class="s3">\n        </span><span class="s1">annotations,</span><span class="s3">\n        </span><span class="s1">scrollIntoView: !!spec.scrollIntoView</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function resolveTransaction(state, specs, filter) {</span><span class="s3">\n    </span><span class="s1">let s = resolveTransactionInner(state, specs.length ? specs[0] : {}, state.doc.length);</span><span class="s3">\n    </span><span class="s1">if (specs.length &amp;&amp; specs[0].filter === false)</span><span class="s3">\n        </span><span class="s1">filter = false;</span><span class="s3">\n    </span><span class="s1">for (let i = 1; i &lt; specs.length; i++) {</span><span class="s3">\n        </span><span class="s1">if (specs[i].filter === false)</span><span class="s3">\n            </span><span class="s1">filter = false;</span><span class="s3">\n        </span><span class="s1">let seq = !!specs[i].sequential;</span><span class="s3">\n        </span><span class="s1">s = mergeTransaction(s, resolveTransactionInner(state, specs[i], seq ? s.changes.newLength : state.doc.length), seq);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">let tr = Transaction.create(state, s.changes, s.selection, s.effects, s.annotations, s.scrollIntoView);</span><span class="s3">\n    </span><span class="s1">return extendTransaction(filter ? filterTransaction(tr) : tr);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">// Finish a transaction by applying filters if necessary.</span><span class="s3">\n</span><span class="s1">function filterTransaction(tr) {</span><span class="s3">\n    </span><span class="s1">let state = tr.startState;</span><span class="s3">\n    </span><span class="s1">// Change filters</span><span class="s3">\n    </span><span class="s1">let result = true;</span><span class="s3">\n    </span><span class="s1">for (let filter of state.facet(changeFilter)) {</span><span class="s3">\n        </span><span class="s1">let value = filter(tr);</span><span class="s3">\n        </span><span class="s1">if (value === false) {</span><span class="s3">\n            </span><span class="s1">result = false;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (Array.isArray(value))</span><span class="s3">\n            </span><span class="s1">result = result === true ? value : joinRanges(result, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (result !== true) {</span><span class="s3">\n        </span><span class="s1">let changes, back;</span><span class="s3">\n        </span><span class="s1">if (result === false) {</span><span class="s3">\n            </span><span class="s1">back = tr.changes.invertedDesc;</span><span class="s3">\n            </span><span class="s1">changes = ChangeSet.empty(state.doc.length);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let filtered = tr.changes.filter(result);</span><span class="s3">\n            </span><span class="s1">changes = filtered.changes;</span><span class="s3">\n            </span><span class="s1">back = filtered.filtered.mapDesc(filtered.changes).invertedDesc;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">tr = Transaction.create(state, changes, tr.selection &amp;&amp; tr.selection.map(back), StateEffect.mapEffects(tr.effects, back), tr.annotations, tr.scrollIntoView);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Transaction filters</span><span class="s3">\n    </span><span class="s1">let filters = state.facet(transactionFilter);</span><span class="s3">\n    </span><span class="s1">for (let i = filters.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let filtered = filters[i](tr);</span><span class="s3">\n        </span><span class="s1">if (filtered instanceof Transaction)</span><span class="s3">\n            </span><span class="s1">tr = filtered;</span><span class="s3">\n        </span><span class="s1">else if (Array.isArray(filtered) &amp;&amp; filtered.length == 1 &amp;&amp; filtered[0] instanceof Transaction)</span><span class="s3">\n            </span><span class="s1">tr = filtered[0];</span><span class="s3">\n        </span><span class="s1">else</span><span class="s3">\n            </span><span class="s1">tr = resolveTransaction(state, asArray(filtered), false);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return tr;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function extendTransaction(tr) {</span><span class="s3">\n    </span><span class="s1">let state = tr.startState, extenders = state.facet(transactionExtender), spec = tr;</span><span class="s3">\n    </span><span class="s1">for (let i = extenders.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n        </span><span class="s1">let extension = extenders[i](tr);</span><span class="s3">\n        </span><span class="s1">if (extension &amp;&amp; Object.keys(extension).length)</span><span class="s3">\n            </span><span class="s1">spec = mergeTransaction(spec, resolveTransactionInner(state, extension, tr.changes.newLength), true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return spec == tr ? tr : Transaction.create(state, tr.changes, tr.selection, spec.effects, spec.annotations, spec.scrollIntoView);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">const none = [];</span><span class="s3">\n</span><span class="s1">function asArray(value) {</span><span class="s3">\n    </span><span class="s1">return value == null ? none : Array.isArray(value) ? value : [value];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The categories produced by a [character</span><span class="s3">\n</span><span class="s1">categorizer](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer). These are used</span><span class="s3">\n</span><span class="s1">do things like selecting by word.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">var CharCategory = /*@__PURE__*/(function (CharCategory) {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Word characters.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CharCategory[CharCategory[</span><span class="s3">\&quot;</span><span class="s1">Word</span><span class="s3">\&quot;</span><span class="s1">] = 0] = </span><span class="s3">\&quot;</span><span class="s1">Word</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Whitespace.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CharCategory[CharCategory[</span><span class="s3">\&quot;</span><span class="s1">Space</span><span class="s3">\&quot;</span><span class="s1">] = 1] = </span><span class="s3">\&quot;</span><span class="s1">Space</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Anything else.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">CharCategory[CharCategory[</span><span class="s3">\&quot;</span><span class="s1">Other</span><span class="s3">\&quot;</span><span class="s1">] = 2] = </span><span class="s3">\&quot;</span><span class="s1">Other</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">return CharCategory})(CharCategory || (CharCategory = {}));</span><span class="s3">\n</span><span class="s1">const nonASCIISingleCaseWordChar = /[</span><span class="s3">\\</span><span class="s1">u00df</span><span class="s3">\\</span><span class="s1">u0587</span><span class="s3">\\</span><span class="s1">u0590-</span><span class="s3">\\</span><span class="s1">u05f4</span><span class="s3">\\</span><span class="s1">u0600-</span><span class="s3">\\</span><span class="s1">u06ff</span><span class="s3">\\</span><span class="s1">u3040-</span><span class="s3">\\</span><span class="s1">u309f</span><span class="s3">\\</span><span class="s1">u30a0-</span><span class="s3">\\</span><span class="s1">u30ff</span><span class="s3">\\</span><span class="s1">u3400-</span><span class="s3">\\</span><span class="s1">u4db5</span><span class="s3">\\</span><span class="s1">u4e00-</span><span class="s3">\\</span><span class="s1">u9fcc</span><span class="s3">\\</span><span class="s1">uac00-</span><span class="s3">\\</span><span class="s1">ud7af]/;</span><span class="s3">\n</span><span class="s1">let wordChar;</span><span class="s3">\n</span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">wordChar = /*@__PURE__*/new RegExp(</span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">p{Alphabetic}</span><span class="s3">\\\\</span><span class="s1">p{Number}_]</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">u</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">catch (_) { }</span><span class="s3">\n</span><span class="s1">function hasWordChar(str) {</span><span class="s3">\n    </span><span class="s1">if (wordChar)</span><span class="s3">\n        </span><span class="s1">return wordChar.test(str);</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; str.length; i++) {</span><span class="s3">\n        </span><span class="s1">let ch = str[i];</span><span class="s3">\n        </span><span class="s1">if (/</span><span class="s3">\\</span><span class="s1">w/.test(ch) || ch &gt; </span><span class="s3">\&quot;\\</span><span class="s1">x80</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch)))</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function makeCategorizer(wordChars) {</span><span class="s3">\n    </span><span class="s1">return (char) =&gt; {</span><span class="s3">\n        </span><span class="s1">if (!/</span><span class="s3">\\</span><span class="s1">S/.test(char))</span><span class="s3">\n            </span><span class="s1">return CharCategory.Space;</span><span class="s3">\n        </span><span class="s1">if (hasWordChar(char))</span><span class="s3">\n            </span><span class="s1">return CharCategory.Word;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; wordChars.length; i++)</span><span class="s3">\n            </span><span class="s1">if (char.indexOf(wordChars[i]) &gt; -1)</span><span class="s3">\n                </span><span class="s1">return CharCategory.Word;</span><span class="s3">\n        </span><span class="s1">return CharCategory.Other;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The editor state class is a persistent (immutable) data structure.</span><span class="s3">\n</span><span class="s1">To update a state, you [create](https://codemirror.net/6/docs/ref/#state.EditorState.update) a</span><span class="s3">\n</span><span class="s1">[transaction](https://codemirror.net/6/docs/ref/#state.Transaction), which produces a _new_ state</span><span class="s3">\n</span><span class="s1">instance, without modifying the original object.</span><span class="s3">\n\n</span><span class="s1">As such, _never_ mutate properties of a state directly. That'll</span><span class="s3">\n</span><span class="s1">just break things.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class EditorState {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">config, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current document.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">doc, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The current selection.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">selection, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">values, computeSlot, tr) {</span><span class="s3">\n        </span><span class="s1">this.config = config;</span><span class="s3">\n        </span><span class="s1">this.doc = doc;</span><span class="s3">\n        </span><span class="s1">this.selection = selection;</span><span class="s3">\n        </span><span class="s1">this.values = values;</span><span class="s3">\n        </span><span class="s1">this.status = config.statusTemplate.slice();</span><span class="s3">\n        </span><span class="s1">this.computeSlot = computeSlot;</span><span class="s3">\n        </span><span class="s1">// Fill in the computed state immediately, so that further queries</span><span class="s3">\n        </span><span class="s1">// for it made during the update return this state</span><span class="s3">\n        </span><span class="s1">if (tr)</span><span class="s3">\n            </span><span class="s1">tr._state = this;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.config.dynamicSlots.length; i++)</span><span class="s3">\n            </span><span class="s1">ensureAddr(this, i &lt;&lt; 1);</span><span class="s3">\n        </span><span class="s1">this.computeSlot = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">field(field, require = true) {</span><span class="s3">\n        </span><span class="s1">let addr = this.config.address[field.id];</span><span class="s3">\n        </span><span class="s1">if (addr == null) {</span><span class="s3">\n            </span><span class="s1">if (require)</span><span class="s3">\n                </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Field is not present in this state</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">return undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">ensureAddr(this, addr);</span><span class="s3">\n        </span><span class="s1">return getAddr(this, addr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this</span><span class="s3">\n    </span><span class="s1">state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)</span><span class="s3">\n    </span><span class="s1">can be passed. Unless</span><span class="s3">\n    </span><span class="s1">[`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the</span><span class="s3">\n    </span><span class="s1">[changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec</span><span class="s3">\n    </span><span class="s1">are assumed to start in the _current_ document (not the document</span><span class="s3">\n    </span><span class="s1">produced by previous specs), and its</span><span class="s3">\n    </span><span class="s1">[selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and</span><span class="s3">\n    </span><span class="s1">[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer</span><span class="s3">\n    </span><span class="s1">to the document created by its _own_ changes. The resulting</span><span class="s3">\n    </span><span class="s1">transaction contains the combined effect of all the different</span><span class="s3">\n    </span><span class="s1">specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later</span><span class="s3">\n    </span><span class="s1">specs take precedence over earlier ones.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">update(...specs) {</span><span class="s3">\n        </span><span class="s1">return resolveTransaction(this, specs, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">applyTransaction(tr) {</span><span class="s3">\n        </span><span class="s1">let conf = this.config, { base, compartments } = conf;</span><span class="s3">\n        </span><span class="s1">for (let effect of tr.effects) {</span><span class="s3">\n            </span><span class="s1">if (effect.is(Compartment.reconfigure)) {</span><span class="s3">\n                </span><span class="s1">if (conf) {</span><span class="s3">\n                    </span><span class="s1">compartments = new Map;</span><span class="s3">\n                    </span><span class="s1">conf.compartments.forEach((val, key) =&gt; compartments.set(key, val));</span><span class="s3">\n                    </span><span class="s1">conf = null;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">compartments.set(effect.value.compartment, effect.value.extension);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (effect.is(StateEffect.reconfigure)) {</span><span class="s3">\n                </span><span class="s1">conf = null;</span><span class="s3">\n                </span><span class="s1">base = effect.value;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (effect.is(StateEffect.appendConfig)) {</span><span class="s3">\n                </span><span class="s1">conf = null;</span><span class="s3">\n                </span><span class="s1">base = asArray(base).concat(effect.value);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let startValues;</span><span class="s3">\n        </span><span class="s1">if (!conf) {</span><span class="s3">\n            </span><span class="s1">conf = Configuration.resolve(base, compartments, this);</span><span class="s3">\n            </span><span class="s1">let intermediateState = new EditorState(conf, this.doc, this.selection, conf.dynamicSlots.map(() =&gt; null), (state, slot) =&gt; slot.reconfigure(state, this), null);</span><span class="s3">\n            </span><span class="s1">startValues = intermediateState.values;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">startValues = tr.startState.values.slice();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let selection = tr.startState.facet(allowMultipleSelections) ? tr.newSelection : tr.newSelection.asSingle();</span><span class="s3">\n        </span><span class="s1">new EditorState(conf, tr.newDoc, selection, startValues, (state, slot) =&gt; slot.update(state, tr), tr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that</span><span class="s3">\n    </span><span class="s1">replaces every selection range with the given content.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">replaceSelection(text) {</span><span class="s3">\n        </span><span class="s1">if (typeof text == </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">text = this.toText(text);</span><span class="s3">\n        </span><span class="s1">return this.changeByRange(range =&gt; ({ changes: { from: range.from, to: range.to, insert: text },</span><span class="s3">\n            </span><span class="s1">range: EditorSelection.cursor(range.from + text.length) }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a set of changes and a new selection by running the given</span><span class="s3">\n    </span><span class="s1">function for each range in the active selection. The function</span><span class="s3">\n    </span><span class="s1">can return an optional set of changes (in the coordinate space</span><span class="s3">\n    </span><span class="s1">of the start document), plus an updated range (in the coordinate</span><span class="s3">\n    </span><span class="s1">space of the document produced by the call's own changes). This</span><span class="s3">\n    </span><span class="s1">method will merge all the changes and ranges into a single</span><span class="s3">\n    </span><span class="s1">changeset and selection, and return it as a [transaction</span><span class="s3">\n    </span><span class="s1">spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to</span><span class="s3">\n    </span><span class="s1">[`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">changeByRange(f) {</span><span class="s3">\n        </span><span class="s1">let sel = this.selection;</span><span class="s3">\n        </span><span class="s1">let result1 = f(sel.ranges[0]);</span><span class="s3">\n        </span><span class="s1">let changes = this.changes(result1.changes), ranges = [result1.range];</span><span class="s3">\n        </span><span class="s1">let effects = asArray(result1.effects);</span><span class="s3">\n        </span><span class="s1">for (let i = 1; i &lt; sel.ranges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let result = f(sel.ranges[i]);</span><span class="s3">\n            </span><span class="s1">let newChanges = this.changes(result.changes), newMapped = newChanges.map(changes);</span><span class="s3">\n            </span><span class="s1">for (let j = 0; j &lt; i; j++)</span><span class="s3">\n                </span><span class="s1">ranges[j] = ranges[j].map(newMapped);</span><span class="s3">\n            </span><span class="s1">let mapBy = changes.mapDesc(newChanges, true);</span><span class="s3">\n            </span><span class="s1">ranges.push(result.range.map(mapBy));</span><span class="s3">\n            </span><span class="s1">changes = changes.compose(newMapped);</span><span class="s3">\n            </span><span class="s1">effects = StateEffect.mapEffects(effects, newMapped).concat(StateEffect.mapEffects(asArray(result.effects), mapBy));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">changes,</span><span class="s3">\n            </span><span class="s1">selection: EditorSelection.create(ranges, sel.mainIndex),</span><span class="s3">\n            </span><span class="s1">effects</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change</span><span class="s3">\n    </span><span class="s1">description, taking the state's document length and line</span><span class="s3">\n    </span><span class="s1">separator into account.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">changes(spec = []) {</span><span class="s3">\n        </span><span class="s1">if (spec instanceof ChangeSet)</span><span class="s3">\n            </span><span class="s1">return spec;</span><span class="s3">\n        </span><span class="s1">return ChangeSet.of(spec, this.doc.length, this.facet(EditorState.lineSeparator));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Using the state's [line</span><span class="s3">\n    </span><span class="s1">separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a</span><span class="s3">\n    </span><span class="s1">[`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toText(string) {</span><span class="s3">\n        </span><span class="s1">return Text.of(string.split(this.facet(EditorState.lineSeparator) || DefaultSplit));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return the given range of the document as a string.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">sliceDoc(from = 0, to = this.doc.length) {</span><span class="s3">\n        </span><span class="s1">return this.doc.sliceString(from, to, this.lineBreak);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">facet(facet) {</span><span class="s3">\n        </span><span class="s1">let addr = this.config.address[facet.id];</span><span class="s3">\n        </span><span class="s1">if (addr == null)</span><span class="s3">\n            </span><span class="s1">return facet.default;</span><span class="s3">\n        </span><span class="s1">ensureAddr(this, addr);</span><span class="s3">\n        </span><span class="s1">return getAddr(this, addr);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Convert this state to a JSON-serializable object. When custom</span><span class="s3">\n    </span><span class="s1">fields should be serialized, you can pass them in as an object</span><span class="s3">\n    </span><span class="s1">mapping property names (in the resulting object, which should</span><span class="s3">\n    </span><span class="s1">not use `doc` or `selection`) to fields.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">toJSON(fields) {</span><span class="s3">\n        </span><span class="s1">let result = {</span><span class="s3">\n            </span><span class="s1">doc: this.sliceDoc(),</span><span class="s3">\n            </span><span class="s1">selection: this.selection.toJSON()</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">if (fields)</span><span class="s3">\n            </span><span class="s1">for (let prop in fields) {</span><span class="s3">\n                </span><span class="s1">let value = fields[prop];</span><span class="s3">\n                </span><span class="s1">if (value instanceof StateField &amp;&amp; this.config.address[value.id] != null)</span><span class="s3">\n                    </span><span class="s1">result[prop] = value.spec.toJSON(this.field(fields[prop]), this);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Deserialize a state from its JSON representation. When custom</span><span class="s3">\n    </span><span class="s1">fields should be deserialized, pass the same object you passed</span><span class="s3">\n    </span><span class="s1">to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as</span><span class="s3">\n    </span><span class="s1">third argument.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static fromJSON(json, config = {}, fields) {</span><span class="s3">\n        </span><span class="s1">if (!json || typeof json.doc != </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n            </span><span class="s1">throw new RangeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid JSON representation for EditorState</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let fieldInit = [];</span><span class="s3">\n        </span><span class="s1">if (fields)</span><span class="s3">\n            </span><span class="s1">for (let prop in fields) {</span><span class="s3">\n                </span><span class="s1">if (Object.prototype.hasOwnProperty.call(json, prop)) {</span><span class="s3">\n                    </span><span class="s1">let field = fields[prop], value = json[prop];</span><span class="s3">\n                    </span><span class="s1">fieldInit.push(field.init(state =&gt; field.spec.fromJSON(value, state)));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return EditorState.create({</span><span class="s3">\n            </span><span class="s1">doc: json.doc,</span><span class="s3">\n            </span><span class="s1">selection: EditorSelection.fromJSON(json.selection),</span><span class="s3">\n            </span><span class="s1">extensions: config.extensions ? fieldInit.concat([config.extensions]) : fieldInit</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a new state. You'll usually only need this when</span><span class="s3">\n    </span><span class="s1">initializing an editorupdated states are created by applying</span><span class="s3">\n    </span><span class="s1">transactions.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(config = {}) {</span><span class="s3">\n        </span><span class="s1">let configuration = Configuration.resolve(config.extensions || [], new Map);</span><span class="s3">\n        </span><span class="s1">let doc = config.doc instanceof Text ? config.doc</span><span class="s3">\n            </span><span class="s1">: Text.of((config.doc || </span><span class="s3">\&quot;\&quot;</span><span class="s1">).split(configuration.staticFacet(EditorState.lineSeparator) || DefaultSplit));</span><span class="s3">\n        </span><span class="s1">let selection = !config.selection ? EditorSelection.single(0)</span><span class="s3">\n            </span><span class="s1">: config.selection instanceof EditorSelection ? config.selection</span><span class="s3">\n                </span><span class="s1">: EditorSelection.single(config.selection.anchor, config.selection.head);</span><span class="s3">\n        </span><span class="s1">checkSelection(selection, doc.length);</span><span class="s3">\n        </span><span class="s1">if (!configuration.staticFacet(allowMultipleSelections))</span><span class="s3">\n            </span><span class="s1">selection = selection.asSingle();</span><span class="s3">\n        </span><span class="s1">return new EditorState(configuration, doc, selection, configuration.dynamicSlots.map(() =&gt; null), (state, slot) =&gt; slot.create(state), null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The size (in columns) of a tab in the document, determined by</span><span class="s3">\n    </span><span class="s1">the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get tabSize() { return this.facet(EditorState.tabSize); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)</span><span class="s3">\n    </span><span class="s1">string for this state.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get lineBreak() { return this.facet(EditorState.lineSeparator) || </span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Returns true when the editor is</span><span class="s3">\n    </span><span class="s1">[configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get readOnly() { return this.facet(readOnly); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Look up a translation for the given phrase (via the</span><span class="s3">\n    </span><span class="s1">[`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the</span><span class="s3">\n    </span><span class="s1">original string if no translation is found.</span><span class="s3">\n    \n    </span><span class="s1">If additional arguments are passed, they will be inserted in</span><span class="s3">\n    </span><span class="s1">place of markers like `$1` (for the first value) and `$2`, etc.</span><span class="s3">\n    </span><span class="s1">A single `$` is equivalent to `$1`, and `$$` will produce a</span><span class="s3">\n    </span><span class="s1">literal dollar sign.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">phrase(phrase, ...insert) {</span><span class="s3">\n        </span><span class="s1">for (let map of this.facet(EditorState.phrases))</span><span class="s3">\n            </span><span class="s1">if (Object.prototype.hasOwnProperty.call(map, phrase)) {</span><span class="s3">\n                </span><span class="s1">phrase = map[phrase];</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (insert.length)</span><span class="s3">\n            </span><span class="s1">phrase = phrase.replace(/</span><span class="s3">\\</span><span class="s1">$(</span><span class="s3">\\</span><span class="s1">$|</span><span class="s3">\\</span><span class="s1">d*)/g, (m, i) =&gt; {</span><span class="s3">\n                </span><span class="s1">if (i == </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n                    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n                </span><span class="s1">let n = +(i || 1);</span><span class="s3">\n                </span><span class="s1">return !n || n &gt; insert.length ? m : insert[n - 1];</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">return phrase;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the values for a given language data field, provided by the</span><span class="s3">\n    </span><span class="s1">the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.</span><span class="s3">\n    \n    </span><span class="s1">Examples of language data fields are...</span><span class="s3">\n    \n    </span><span class="s1">- [`</span><span class="s3">\&quot;</span><span class="s1">commentTokens</span><span class="s3">\&quot;</span><span class="s1">`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying</span><span class="s3">\n      </span><span class="s1">comment syntax.</span><span class="s3">\n    </span><span class="s1">- [`</span><span class="s3">\&quot;</span><span class="s1">autocomplete</span><span class="s3">\&quot;</span><span class="s1">`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)</span><span class="s3">\n      </span><span class="s1">for providing language-specific completion sources.</span><span class="s3">\n    </span><span class="s1">- [`</span><span class="s3">\&quot;</span><span class="s1">wordChars</span><span class="s3">\&quot;</span><span class="s1">`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding</span><span class="s3">\n      </span><span class="s1">characters that should be considered part of words in this</span><span class="s3">\n      </span><span class="s1">language.</span><span class="s3">\n    </span><span class="s1">- [`</span><span class="s3">\&quot;</span><span class="s1">closeBrackets</span><span class="s3">\&quot;</span><span class="s1">`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls</span><span class="s3">\n      </span><span class="s1">bracket closing behavior.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">languageDataAt(name, pos, side = -1) {</span><span class="s3">\n        </span><span class="s1">let values = [];</span><span class="s3">\n        </span><span class="s1">for (let provider of this.facet(languageData)) {</span><span class="s3">\n            </span><span class="s1">for (let result of provider(this, pos, side)) {</span><span class="s3">\n                </span><span class="s1">if (Object.prototype.hasOwnProperty.call(result, name))</span><span class="s3">\n                    </span><span class="s1">values.push(result[name]);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return values;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Return a function that can categorize strings (expected to</span><span class="s3">\n    </span><span class="s1">represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))</span><span class="s3">\n    </span><span class="s1">into one of:</span><span class="s3">\n    \n     </span><span class="s1">- Word (contains an alphanumeric character or a character</span><span class="s3">\n       </span><span class="s1">explicitly listed in the local language's `</span><span class="s3">\&quot;</span><span class="s1">wordChars</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n       </span><span class="s1">language data, which should be a string)</span><span class="s3">\n     </span><span class="s1">- Space (contains only whitespace)</span><span class="s3">\n     </span><span class="s1">- Other (anything else)</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">charCategorizer(at) {</span><span class="s3">\n        </span><span class="s1">return makeCategorizer(this.languageDataAt(</span><span class="s3">\&quot;</span><span class="s1">wordChars</span><span class="s3">\&quot;</span><span class="s1">, at).join(</span><span class="s3">\&quot;\&quot;</span><span class="s1">));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Find the word at the given position, meaning the range</span><span class="s3">\n    </span><span class="s1">containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters</span><span class="s3">\n    </span><span class="s1">around it. If no word characters are adjacent to the position,</span><span class="s3">\n    </span><span class="s1">this returns null.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">wordAt(pos) {</span><span class="s3">\n        </span><span class="s1">let { text, from, length } = this.doc.lineAt(pos);</span><span class="s3">\n        </span><span class="s1">let cat = this.charCategorizer(pos);</span><span class="s3">\n        </span><span class="s1">let start = pos - from, end = pos - from;</span><span class="s3">\n        </span><span class="s1">while (start &gt; 0) {</span><span class="s3">\n            </span><span class="s1">let prev = findClusterBreak(text, start, false);</span><span class="s3">\n            </span><span class="s1">if (cat(text.slice(prev, start)) != CharCategory.Word)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">start = prev;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">while (end &lt; length) {</span><span class="s3">\n            </span><span class="s1">let next = findClusterBreak(text, end);</span><span class="s3">\n            </span><span class="s1">if (cat(text.slice(end, next)) != CharCategory.Word)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">end = next;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return start == end ? null : EditorSelection.range(start + from, end + from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet that, when enabled, causes the editor to allow multiple</span><span class="s3">\n</span><span class="s1">ranges to be selected. Be careful though, because by default the</span><span class="s3">\n</span><span class="s1">editor relies on the native DOM selection, which cannot handle</span><span class="s3">\n</span><span class="s1">multiple selections. An extension like</span><span class="s3">\n</span><span class="s1">[`drawSelection`](https://codemirror.net/6/docs/ref/#view.drawSelection) can be used to make</span><span class="s3">\n</span><span class="s1">secondary selections visible to the user.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.allowMultipleSelections = allowMultipleSelections;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Configures the tab size to use in this state. The first</span><span class="s3">\n</span><span class="s1">(highest-precedence) value of the facet is used. If no value is</span><span class="s3">\n</span><span class="s1">given, this defaults to 4.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.tabSize = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">combine: values =&gt; values.length ? values[0] : 4</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The line separator to use. By default, any of `</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">`, `</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">`</span><span class="s3">\n</span><span class="s1">and `</span><span class="s3">\&quot;\\</span><span class="s1">r</span><span class="s3">\&quot;</span><span class="s1">` is treated as a separator when splitting lines, and</span><span class="s3">\n</span><span class="s1">lines are joined with `</span><span class="s3">\&quot;\\</span><span class="s1">n</span><span class="s3">\&quot;</span><span class="s1">`.</span><span class="s3">\n\n</span><span class="s1">When you configure a value here, only that precise separator</span><span class="s3">\n</span><span class="s1">will be used, allowing you to round-trip documents through the</span><span class="s3">\n</span><span class="s1">editor without normalizing line separators.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.lineSeparator = lineSeparator;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This facet controls the value of the</span><span class="s3">\n</span><span class="s1">[`readOnly`](https://codemirror.net/6/docs/ref/#state.EditorState.readOnly) getter, which is</span><span class="s3">\n</span><span class="s1">consulted by commands and extensions that implement editing</span><span class="s3">\n</span><span class="s1">functionality to determine whether they should apply. It</span><span class="s3">\n</span><span class="s1">defaults to false, but when its highest-precedence value is</span><span class="s3">\n</span><span class="s1">`true`, such functionality disables itself.</span><span class="s3">\n\n</span><span class="s1">Not to be confused with</span><span class="s3">\n</span><span class="s1">[`EditorView.editable`](https://codemirror.net/6/docs/ref/#view.EditorView^editable), which</span><span class="s3">\n</span><span class="s1">controls whether the editor's DOM is set to be editable (and</span><span class="s3">\n</span><span class="s1">thus focusable).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.readOnly = readOnly;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Registers translation phrases. The</span><span class="s3">\n</span><span class="s1">[`phrase`](https://codemirror.net/6/docs/ref/#state.EditorState.phrase) method will look through</span><span class="s3">\n</span><span class="s1">all objects registered with this facet to find translations for</span><span class="s3">\n</span><span class="s1">its argument.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.phrases = /*@__PURE__*/Facet.define({</span><span class="s3">\n    </span><span class="s1">compare(a, b) {</span><span class="s3">\n        </span><span class="s1">let kA = Object.keys(a), kB = Object.keys(b);</span><span class="s3">\n        </span><span class="s1">return kA.length == kB.length &amp;&amp; kA.every(k =&gt; a[k] == b[k]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A facet used to register [language</span><span class="s3">\n</span><span class="s1">data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) providers.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.languageData = languageData;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to register change filters, which are called for each</span><span class="s3">\n</span><span class="s1">transaction (unless explicitly</span><span class="s3">\n</span><span class="s1">[disabled](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter)), and can suppress</span><span class="s3">\n</span><span class="s1">part of the transaction's changes.</span><span class="s3">\n\n</span><span class="s1">Such a function can return `true` to indicate that it doesn't</span><span class="s3">\n</span><span class="s1">want to do anything, `false` to completely stop the changes in</span><span class="s3">\n</span><span class="s1">the transaction, or a set of ranges in which changes should be</span><span class="s3">\n</span><span class="s1">suppressed. Such ranges are represented as an array of numbers,</span><span class="s3">\n</span><span class="s1">with each pair of two numbers indicating the start and end of a</span><span class="s3">\n</span><span class="s1">range. So for example `[10, 20, 100, 110]` suppresses changes</span><span class="s3">\n</span><span class="s1">between 10 and 20, and between 100 and 110.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.changeFilter = changeFilter;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Facet used to register a hook that gets a chance to update or</span><span class="s3">\n</span><span class="s1">replace transaction specs before they are applied. This will</span><span class="s3">\n</span><span class="s1">only be applied for transactions that don't have</span><span class="s3">\n</span><span class="s1">[`filter`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter) set to `false`. You</span><span class="s3">\n</span><span class="s1">can either return a single transaction spec (possibly the input</span><span class="s3">\n</span><span class="s1">transaction), or an array of specs (which will be combined in</span><span class="s3">\n</span><span class="s1">the same way as the arguments to</span><span class="s3">\n</span><span class="s1">[`EditorState.update`](https://codemirror.net/6/docs/ref/#state.EditorState.update)).</span><span class="s3">\n\n</span><span class="s1">When possible, it is recommended to avoid accessing</span><span class="s3">\n</span><span class="s1">[`Transaction.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state) in a filter,</span><span class="s3">\n</span><span class="s1">since it will force creation of a state that will then be</span><span class="s3">\n</span><span class="s1">discarded again, if the transaction is actually filtered.</span><span class="s3">\n\n</span><span class="s1">(This functionality should be used with care. Indiscriminately</span><span class="s3">\n</span><span class="s1">modifying transaction is likely to break something or degrade</span><span class="s3">\n</span><span class="s1">the user experience.)</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.transactionFilter = transactionFilter;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">This is a more limited form of</span><span class="s3">\n</span><span class="s1">[`transactionFilter`](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter),</span><span class="s3">\n</span><span class="s1">which can only add</span><span class="s3">\n</span><span class="s1">[annotations](https://codemirror.net/6/docs/ref/#state.TransactionSpec.annotations) and</span><span class="s3">\n</span><span class="s1">[effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects). _But_, this type</span><span class="s3">\n</span><span class="s1">of filter runs even if the transaction has disabled regular</span><span class="s3">\n</span><span class="s1">[filtering](https://codemirror.net/6/docs/ref/#state.TransactionSpec.filter), making it suitable</span><span class="s3">\n</span><span class="s1">for effects that don't need to touch the changes or selection,</span><span class="s3">\n</span><span class="s1">but do want to process every transaction.</span><span class="s3">\n\n</span><span class="s1">Extenders run _after_ filters, when both are present.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">EditorState.transactionExtender = transactionExtender;</span><span class="s3">\n</span><span class="s1">Compartment.reconfigure = /*@__PURE__*/StateEffect.define();</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Utility function for combining behaviors to fill in a config</span><span class="s3">\n</span><span class="s1">object from an array of provided configs. `defaults` should hold</span><span class="s3">\n</span><span class="s1">default values for all optional fields in `Config`.</span><span class="s3">\n\n</span><span class="s1">The function will, by default, error</span><span class="s3">\n</span><span class="s1">when a field gets two values that aren't `===`-equal, but you can</span><span class="s3">\n</span><span class="s1">provide combine functions per field to do something else.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function combineConfig(configs, defaults, // Should hold only the optional properties of Config, but I haven't managed to express that</span><span class="s3">\n</span><span class="s1">combine = {}) {</span><span class="s3">\n    </span><span class="s1">let result = {};</span><span class="s3">\n    </span><span class="s1">for (let config of configs)</span><span class="s3">\n        </span><span class="s1">for (let key of Object.keys(config)) {</span><span class="s3">\n            </span><span class="s1">let value = config[key], current = result[key];</span><span class="s3">\n            </span><span class="s1">if (current === undefined)</span><span class="s3">\n                </span><span class="s1">result[key] = value;</span><span class="s3">\n            </span><span class="s1">else if (current === value || value === undefined) ; // No conflict</span><span class="s3">\n            </span><span class="s1">else if (Object.hasOwnProperty.call(combine, key))</span><span class="s3">\n                </span><span class="s1">result[key] = combine[key](current, value);</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Config merge conflict for field </span><span class="s3">\&quot; </span><span class="s1">+ key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (let key in defaults)</span><span class="s3">\n        </span><span class="s1">if (result[key] === undefined)</span><span class="s3">\n            </span><span class="s1">result[key] = defaults[key];</span><span class="s3">\n    </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Each range is associated with a value, which must inherit from</span><span class="s3">\n</span><span class="s1">this class.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RangeValue {</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare this value with another value. Used when comparing</span><span class="s3">\n    </span><span class="s1">rangesets. The default implementation compares by identity.</span><span class="s3">\n    </span><span class="s1">Unless you are only creating a fixed number of unique instances</span><span class="s3">\n    </span><span class="s1">of your value type, it is a good idea to implement this</span><span class="s3">\n    </span><span class="s1">properly.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">eq(other) { return this == other; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">range(from, to = from) { return Range.create(from, to, this); }</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">RangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;</span><span class="s3">\n</span><span class="s1">RangeValue.prototype.point = false;</span><span class="s3">\n</span><span class="s1">RangeValue.prototype.mapMode = MapMode.TrackDel;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A range associates a value with a range of positions.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class Range {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The range's start position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">from, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Its end position.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">to, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The value associated with this range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">value) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(from, to, value) {</span><span class="s3">\n        </span><span class="s1">return new Range(from, to, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function cmpRange(a, b) {</span><span class="s3">\n    </span><span class="s1">return a.from - b.from || a.value.startSide - b.value.startSide;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class Chunk {</span><span class="s3">\n    </span><span class="s1">constructor(from, to, value, </span><span class="s3">\n    </span><span class="s1">// Chunks are marked with the largest point that occurs</span><span class="s3">\n    </span><span class="s1">// in them (or -1 for no points), so that scans that are</span><span class="s3">\n    </span><span class="s1">// only interested in points (such as the</span><span class="s3">\n    </span><span class="s1">// heightmap-related logic) can skip range-only chunks.</span><span class="s3">\n    </span><span class="s1">maxPoint) {</span><span class="s3">\n        </span><span class="s1">this.from = from;</span><span class="s3">\n        </span><span class="s1">this.to = to;</span><span class="s3">\n        </span><span class="s1">this.value = value;</span><span class="s3">\n        </span><span class="s1">this.maxPoint = maxPoint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get length() { return this.to[this.to.length - 1]; }</span><span class="s3">\n    </span><span class="s1">// Find the index of the given position and side. Use the ranges'</span><span class="s3">\n    </span><span class="s1">// `from` pos when `end == false`, `to` when `end == true`.</span><span class="s3">\n    </span><span class="s1">findIndex(pos, side, end, startAt = 0) {</span><span class="s3">\n        </span><span class="s1">let arr = end ? this.to : this.from;</span><span class="s3">\n        </span><span class="s1">for (let lo = startAt, hi = arr.length;;) {</span><span class="s3">\n            </span><span class="s1">if (lo == hi)</span><span class="s3">\n                </span><span class="s1">return lo;</span><span class="s3">\n            </span><span class="s1">let mid = (lo + hi) &gt;&gt; 1;</span><span class="s3">\n            </span><span class="s1">let diff = arr[mid] - pos || (end ? this.value[mid].endSide : this.value[mid].startSide) - side;</span><span class="s3">\n            </span><span class="s1">if (mid == lo)</span><span class="s3">\n                </span><span class="s1">return diff &gt;= 0 ? lo : hi;</span><span class="s3">\n            </span><span class="s1">if (diff &gt;= 0)</span><span class="s3">\n                </span><span class="s1">hi = mid;</span><span class="s3">\n            </span><span class="s1">else</span><span class="s3">\n                </span><span class="s1">lo = mid + 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">between(offset, from, to, f) {</span><span class="s3">\n        </span><span class="s1">for (let i = this.findIndex(from, -1000000000 /* C.Far */, true), e = this.findIndex(to, 1000000000 /* C.Far */, false, i); i &lt; e; i++)</span><span class="s3">\n            </span><span class="s1">if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">map(offset, changes) {</span><span class="s3">\n        </span><span class="s1">let value = [], from = [], to = [], newPos = -1, maxPoint = -1;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.value.length; i++) {</span><span class="s3">\n            </span><span class="s1">let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;</span><span class="s3">\n            </span><span class="s1">if (curFrom == curTo) {</span><span class="s3">\n                </span><span class="s1">let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);</span><span class="s3">\n                </span><span class="s1">if (mapped == null)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">newFrom = newTo = mapped;</span><span class="s3">\n                </span><span class="s1">if (val.startSide != val.endSide) {</span><span class="s3">\n                    </span><span class="s1">newTo = changes.mapPos(curFrom, val.endSide);</span><span class="s3">\n                    </span><span class="s1">if (newTo &lt; newFrom)</span><span class="s3">\n                        </span><span class="s1">continue;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">newFrom = changes.mapPos(curFrom, val.startSide);</span><span class="s3">\n                </span><span class="s1">newTo = changes.mapPos(curTo, val.endSide);</span><span class="s3">\n                </span><span class="s1">if (newFrom &gt; newTo || newFrom == newTo &amp;&amp; val.startSide &gt; 0 &amp;&amp; val.endSide &lt;= 0)</span><span class="s3">\n                    </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if ((newTo - newFrom || val.endSide - val.startSide) &lt; 0)</span><span class="s3">\n                </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">if (newPos &lt; 0)</span><span class="s3">\n                </span><span class="s1">newPos = newFrom;</span><span class="s3">\n            </span><span class="s1">if (val.point)</span><span class="s3">\n                </span><span class="s1">maxPoint = Math.max(maxPoint, newTo - newFrom);</span><span class="s3">\n            </span><span class="s1">value.push(val);</span><span class="s3">\n            </span><span class="s1">from.push(newFrom - newPos);</span><span class="s3">\n            </span><span class="s1">to.push(newTo - newPos);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#state.Range) in a</span><span class="s3">\n</span><span class="s1">way that makes them efficient to [map](https://codemirror.net/6/docs/ref/#state.RangeSet.map) and</span><span class="s3">\n</span><span class="s1">[update](https://codemirror.net/6/docs/ref/#state.RangeSet.update). This is an immutable data</span><span class="s3">\n</span><span class="s1">structure.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RangeSet {</span><span class="s3">\n    </span><span class="s1">constructor(</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">chunkPos, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">chunk, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">nextLayer, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">maxPoint) {</span><span class="s3">\n        </span><span class="s1">this.chunkPos = chunkPos;</span><span class="s3">\n        </span><span class="s1">this.chunk = chunk;</span><span class="s3">\n        </span><span class="s1">this.nextLayer = nextLayer;</span><span class="s3">\n        </span><span class="s1">this.maxPoint = maxPoint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static create(chunkPos, chunk, nextLayer, maxPoint) {</span><span class="s3">\n        </span><span class="s1">return new RangeSet(chunkPos, chunk, nextLayer, maxPoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get length() {</span><span class="s3">\n        </span><span class="s1">let last = this.chunk.length - 1;</span><span class="s3">\n        </span><span class="s1">return last &lt; 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">The number of ranges in the set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get size() {</span><span class="s3">\n        </span><span class="s1">if (this.isEmpty)</span><span class="s3">\n            </span><span class="s1">return 0;</span><span class="s3">\n        </span><span class="s1">let size = this.nextLayer.size;</span><span class="s3">\n        </span><span class="s1">for (let chunk of this.chunk)</span><span class="s3">\n            </span><span class="s1">size += chunk.value.length;</span><span class="s3">\n        </span><span class="s1">return size;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">chunkEnd(index) {</span><span class="s3">\n        </span><span class="s1">return this.chunkPos[index] + this.chunk[index].length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Update the range set, optionally adding new ranges or filtering</span><span class="s3">\n    </span><span class="s1">out existing ones.</span><span class="s3">\n    \n    </span><span class="s1">(Note: The type parameter is just there as a kludge to work</span><span class="s3">\n    </span><span class="s1">around TypeScript variance issues that prevented `RangeSet&lt;X&gt;`</span><span class="s3">\n    </span><span class="s1">from being a subtype of `RangeSet&lt;Y&gt;` when `X` is a subtype of</span><span class="s3">\n    </span><span class="s1">`Y`.)</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">update(updateSpec) {</span><span class="s3">\n        </span><span class="s1">let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;</span><span class="s3">\n        </span><span class="s1">let filter = updateSpec.filter;</span><span class="s3">\n        </span><span class="s1">if (add.length == 0 &amp;&amp; !filter)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">if (sort)</span><span class="s3">\n            </span><span class="s1">add = add.slice().sort(cmpRange);</span><span class="s3">\n        </span><span class="s1">if (this.isEmpty)</span><span class="s3">\n            </span><span class="s1">return add.length ? RangeSet.of(add) : this;</span><span class="s3">\n        </span><span class="s1">let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];</span><span class="s3">\n        </span><span class="s1">let builder = new RangeSetBuilder();</span><span class="s3">\n        </span><span class="s1">while (cur.value || i &lt; add.length) {</span><span class="s3">\n            </span><span class="s1">if (i &lt; add.length &amp;&amp; (cur.from - add[i].from || cur.startSide - add[i].value.startSide) &gt;= 0) {</span><span class="s3">\n                </span><span class="s1">let range = add[i++];</span><span class="s3">\n                </span><span class="s1">if (!builder.addInner(range.from, range.to, range.value))</span><span class="s3">\n                    </span><span class="s1">spill.push(range);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (cur.rangeIndex == 1 &amp;&amp; cur.chunkIndex &lt; this.chunk.length &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(i == add.length || this.chunkEnd(cur.chunkIndex) &lt; add[i].from) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">(!filter || filterFrom &gt; this.chunkEnd(cur.chunkIndex) || filterTo &lt; this.chunkPos[cur.chunkIndex]) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {</span><span class="s3">\n                </span><span class="s1">cur.nextChunk();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">if (!filter || filterFrom &gt; cur.to || filterTo &lt; cur.from || filter(cur.from, cur.to, cur.value)) {</span><span class="s3">\n                    </span><span class="s1">if (!builder.addInner(cur.from, cur.to, cur.value))</span><span class="s3">\n                        </span><span class="s1">spill.push(Range.create(cur.from, cur.to, cur.value));</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">cur.next();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return builder.finishInner(this.nextLayer.isEmpty &amp;&amp; !spill.length ? RangeSet.empty</span><span class="s3">\n            </span><span class="s1">: this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Map this range set through a set of changes, return the new set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">map(changes) {</span><span class="s3">\n        </span><span class="s1">if (changes.empty || this.isEmpty)</span><span class="s3">\n            </span><span class="s1">return this;</span><span class="s3">\n        </span><span class="s1">let chunks = [], chunkPos = [], maxPoint = -1;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.chunk.length; i++) {</span><span class="s3">\n            </span><span class="s1">let start = this.chunkPos[i], chunk = this.chunk[i];</span><span class="s3">\n            </span><span class="s1">let touch = changes.touchesRange(start, start + chunk.length);</span><span class="s3">\n            </span><span class="s1">if (touch === false) {</span><span class="s3">\n                </span><span class="s1">maxPoint = Math.max(maxPoint, chunk.maxPoint);</span><span class="s3">\n                </span><span class="s1">chunks.push(chunk);</span><span class="s3">\n                </span><span class="s1">chunkPos.push(changes.mapPos(start));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (touch === true) {</span><span class="s3">\n                </span><span class="s1">let { mapped, pos } = chunk.map(start, changes);</span><span class="s3">\n                </span><span class="s1">if (mapped) {</span><span class="s3">\n                    </span><span class="s1">maxPoint = Math.max(maxPoint, mapped.maxPoint);</span><span class="s3">\n                    </span><span class="s1">chunks.push(mapped);</span><span class="s3">\n                    </span><span class="s1">chunkPos.push(pos);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let next = this.nextLayer.map(changes);</span><span class="s3">\n        </span><span class="s1">return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next || RangeSet.empty, maxPoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the ranges that touch the region `from` to `to`,</span><span class="s3">\n    </span><span class="s1">calling `f` for each. There is no guarantee that the ranges will</span><span class="s3">\n    </span><span class="s1">be reported in any specific order. When the callback returns</span><span class="s3">\n    </span><span class="s1">`false`, iteration stops.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">between(from, to, f) {</span><span class="s3">\n        </span><span class="s1">if (this.isEmpty)</span><span class="s3">\n            </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; this.chunk.length; i++) {</span><span class="s3">\n            </span><span class="s1">let start = this.chunkPos[i], chunk = this.chunk[i];</span><span class="s3">\n            </span><span class="s1">if (to &gt;= start &amp;&amp; from &lt;= start + chunk.length &amp;&amp;</span><span class="s3">\n                </span><span class="s1">chunk.between(start, from - start, to - start, f) === false)</span><span class="s3">\n                </span><span class="s1">return;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.nextLayer.between(from, to, f);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the ranges in this set, in order, including all</span><span class="s3">\n    </span><span class="s1">ranges that end at or after `from`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">iter(from = 0) {</span><span class="s3">\n        </span><span class="s1">return HeapCursor.from([this]).goto(from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">get isEmpty() { return this.nextLayer == this; }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over the ranges in a collection of sets, in order,</span><span class="s3">\n    </span><span class="s1">starting from `from`.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static iter(sets, from = 0) {</span><span class="s3">\n        </span><span class="s1">return HeapCursor.from(sets).goto(from);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over two groups of sets, calling methods on `comparator`</span><span class="s3">\n    </span><span class="s1">to notify it of possible differences.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static compare(oldSets, newSets, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">This indicates how the underlying data changed between these</span><span class="s3">\n    </span><span class="s1">ranges, and is needed to synchronize the iteration.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">textDiff, comparator, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Can be used to ignore all non-point ranges, and points below</span><span class="s3">\n    </span><span class="s1">the given size. When -1, all ranges are compared.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">minPointSize = -1) {</span><span class="s3">\n        </span><span class="s1">let a = oldSets.filter(set =&gt; set.maxPoint &gt; 0 || !set.isEmpty &amp;&amp; set.maxPoint &gt;= minPointSize);</span><span class="s3">\n        </span><span class="s1">let b = newSets.filter(set =&gt; set.maxPoint &gt; 0 || !set.isEmpty &amp;&amp; set.maxPoint &gt;= minPointSize);</span><span class="s3">\n        </span><span class="s1">let sharedChunks = findSharedChunks(a, b, textDiff);</span><span class="s3">\n        </span><span class="s1">let sideA = new SpanCursor(a, sharedChunks, minPointSize);</span><span class="s3">\n        </span><span class="s1">let sideB = new SpanCursor(b, sharedChunks, minPointSize);</span><span class="s3">\n        </span><span class="s1">textDiff.iterGaps((fromA, fromB, length) =&gt; compare(sideA, fromA, sideB, fromB, length, comparator));</span><span class="s3">\n        </span><span class="s1">if (textDiff.empty &amp;&amp; textDiff.length == 0)</span><span class="s3">\n            </span><span class="s1">compare(sideA, 0, sideB, 0, 0, comparator);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Compare the contents of two groups of range sets, returning true</span><span class="s3">\n    </span><span class="s1">if they are equivalent in the given range.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static eq(oldSets, newSets, from = 0, to) {</span><span class="s3">\n        </span><span class="s1">if (to == null)</span><span class="s3">\n            </span><span class="s1">to = 1000000000 /* C.Far */ - 1;</span><span class="s3">\n        </span><span class="s1">let a = oldSets.filter(set =&gt; !set.isEmpty &amp;&amp; newSets.indexOf(set) &lt; 0);</span><span class="s3">\n        </span><span class="s1">let b = newSets.filter(set =&gt; !set.isEmpty &amp;&amp; oldSets.indexOf(set) &lt; 0);</span><span class="s3">\n        </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (!a.length)</span><span class="s3">\n            </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">let sharedChunks = findSharedChunks(a, b);</span><span class="s3">\n        </span><span class="s1">let sideA = new SpanCursor(a, sharedChunks, 0).goto(from), sideB = new SpanCursor(b, sharedChunks, 0).goto(from);</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (sideA.to != sideB.to ||</span><span class="s3">\n                </span><span class="s1">!sameValues(sideA.active, sideB.active) ||</span><span class="s3">\n                </span><span class="s1">sideA.point &amp;&amp; (!sideB.point || !sideA.point.eq(sideB.point)))</span><span class="s3">\n                </span><span class="s1">return false;</span><span class="s3">\n            </span><span class="s1">if (sideA.to &gt; to)</span><span class="s3">\n                </span><span class="s1">return true;</span><span class="s3">\n            </span><span class="s1">sideA.next();</span><span class="s3">\n            </span><span class="s1">sideB.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Iterate over a group of range sets at the same time, notifying</span><span class="s3">\n    </span><span class="s1">the iterator about the ranges covering every given piece of</span><span class="s3">\n    </span><span class="s1">content. Returns the open count (see</span><span class="s3">\n    </span><span class="s1">[`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end</span><span class="s3">\n    </span><span class="s1">of the iteration.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static spans(sets, from, to, iterator, </span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">When given and greater than -1, only points of at least this</span><span class="s3">\n    </span><span class="s1">size are taken into account.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">minPointSize = -1) {</span><span class="s3">\n        </span><span class="s1">let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;</span><span class="s3">\n        </span><span class="s1">let openRanges = cursor.openStart;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let curTo = Math.min(cursor.to, to);</span><span class="s3">\n            </span><span class="s1">if (cursor.point) {</span><span class="s3">\n                </span><span class="s1">let active = cursor.activeForPoint(cursor.to);</span><span class="s3">\n                </span><span class="s1">let openCount = cursor.pointFrom &lt; from ? active.length + 1</span><span class="s3">\n                    </span><span class="s1">: cursor.point.startSide &lt; 0 ? active.length</span><span class="s3">\n                        </span><span class="s1">: Math.min(active.length, openRanges);</span><span class="s3">\n                </span><span class="s1">iterator.point(pos, curTo, cursor.point, active, openCount, cursor.pointRank);</span><span class="s3">\n                </span><span class="s1">openRanges = Math.min(cursor.openEnd(curTo), active.length);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (curTo &gt; pos) {</span><span class="s3">\n                </span><span class="s1">iterator.span(pos, curTo, cursor.active, openRanges);</span><span class="s3">\n                </span><span class="s1">openRanges = cursor.openEnd(curTo);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (cursor.to &gt; to)</span><span class="s3">\n                </span><span class="s1">return openRanges + (cursor.point &amp;&amp; cursor.to &gt; to ? 1 : 0);</span><span class="s3">\n            </span><span class="s1">pos = cursor.to;</span><span class="s3">\n            </span><span class="s1">cursor.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create a range set for the given range or array of ranges. By</span><span class="s3">\n    </span><span class="s1">default, this expects the ranges to be _sorted_ (by start</span><span class="s3">\n    </span><span class="s1">position and, if two start at the same position,</span><span class="s3">\n    </span><span class="s1">`value.startSide`). You can pass `true` as second argument to</span><span class="s3">\n    </span><span class="s1">cause the method to sort them.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static of(ranges, sort = false) {</span><span class="s3">\n        </span><span class="s1">let build = new RangeSetBuilder();</span><span class="s3">\n        </span><span class="s1">for (let range of ranges instanceof Range ? [ranges] : sort ? lazySort(ranges) : ranges)</span><span class="s3">\n            </span><span class="s1">build.add(range.from, range.to, range.value);</span><span class="s3">\n        </span><span class="s1">return build.finish();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Join an array of range sets into a single set.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">static join(sets) {</span><span class="s3">\n        </span><span class="s1">if (!sets.length)</span><span class="s3">\n            </span><span class="s1">return RangeSet.empty;</span><span class="s3">\n        </span><span class="s1">let result = sets[sets.length - 1];</span><span class="s3">\n        </span><span class="s1">for (let i = sets.length - 2; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">for (let layer = sets[i]; layer != RangeSet.empty; layer = layer.nextLayer)</span><span class="s3">\n                </span><span class="s1">result = new RangeSet(layer.chunkPos, layer.chunk, result, Math.max(layer.maxPoint, result.maxPoint));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">The empty set of ranges.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">RangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);</span><span class="s3">\n</span><span class="s1">function lazySort(ranges) {</span><span class="s3">\n    </span><span class="s1">if (ranges.length &gt; 1)</span><span class="s3">\n        </span><span class="s1">for (let prev = ranges[0], i = 1; i &lt; ranges.length; i++) {</span><span class="s3">\n            </span><span class="s1">let cur = ranges[i];</span><span class="s3">\n            </span><span class="s1">if (cmpRange(prev, cur) &gt; 0)</span><span class="s3">\n                </span><span class="s1">return ranges.slice().sort(cmpRange);</span><span class="s3">\n            </span><span class="s1">prev = cur;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return ranges;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">RangeSet.empty.nextLayer = RangeSet.empty;</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">A range set builder is a data structure that helps build up a</span><span class="s3">\n</span><span class="s1">[range set](https://codemirror.net/6/docs/ref/#state.RangeSet) directly, without first allocating</span><span class="s3">\n</span><span class="s1">an array of [`Range`](https://codemirror.net/6/docs/ref/#state.Range) objects.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">class RangeSetBuilder {</span><span class="s3">\n    </span><span class="s1">finishChunk(newArrays) {</span><span class="s3">\n        </span><span class="s1">this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));</span><span class="s3">\n        </span><span class="s1">this.chunkPos.push(this.chunkStart);</span><span class="s3">\n        </span><span class="s1">this.chunkStart = -1;</span><span class="s3">\n        </span><span class="s1">this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);</span><span class="s3">\n        </span><span class="s1">this.maxPoint = -1;</span><span class="s3">\n        </span><span class="s1">if (newArrays) {</span><span class="s3">\n            </span><span class="s1">this.from = [];</span><span class="s3">\n            </span><span class="s1">this.to = [];</span><span class="s3">\n            </span><span class="s1">this.value = [];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Create an empty builder.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">constructor() {</span><span class="s3">\n        </span><span class="s1">this.chunks = [];</span><span class="s3">\n        </span><span class="s1">this.chunkPos = [];</span><span class="s3">\n        </span><span class="s1">this.chunkStart = -1;</span><span class="s3">\n        </span><span class="s1">this.last = null;</span><span class="s3">\n        </span><span class="s1">this.lastFrom = -1000000000 /* C.Far */;</span><span class="s3">\n        </span><span class="s1">this.lastTo = -1000000000 /* C.Far */;</span><span class="s3">\n        </span><span class="s1">this.from = [];</span><span class="s3">\n        </span><span class="s1">this.to = [];</span><span class="s3">\n        </span><span class="s1">this.value = [];</span><span class="s3">\n        </span><span class="s1">this.maxPoint = -1;</span><span class="s3">\n        </span><span class="s1">this.setMaxPoint = -1;</span><span class="s3">\n        </span><span class="s1">this.nextLayer = null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Add a range. Ranges should be added in sorted (by `from` and</span><span class="s3">\n    </span><span class="s1">`value.startSide`) order.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">add(from, to, value) {</span><span class="s3">\n        </span><span class="s1">if (!this.addInner(from, to, value))</span><span class="s3">\n            </span><span class="s1">(this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addInner(from, to, value) {</span><span class="s3">\n        </span><span class="s1">let diff = from - this.lastTo || value.startSide - this.last.endSide;</span><span class="s3">\n        </span><span class="s1">if (diff &lt;= 0 &amp;&amp; (from - this.lastFrom || value.startSide - this.last.startSide) &lt; 0)</span><span class="s3">\n            </span><span class="s1">throw new Error(</span><span class="s3">\&quot;</span><span class="s1">Ranges must be added sorted by `from` position and `startSide`</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (diff &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (this.from.length == 250 /* C.ChunkSize */)</span><span class="s3">\n            </span><span class="s1">this.finishChunk(true);</span><span class="s3">\n        </span><span class="s1">if (this.chunkStart &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.chunkStart = from;</span><span class="s3">\n        </span><span class="s1">this.from.push(from - this.chunkStart);</span><span class="s3">\n        </span><span class="s1">this.to.push(to - this.chunkStart);</span><span class="s3">\n        </span><span class="s1">this.last = value;</span><span class="s3">\n        </span><span class="s1">this.lastFrom = from;</span><span class="s3">\n        </span><span class="s1">this.lastTo = to;</span><span class="s3">\n        </span><span class="s1">this.value.push(value);</span><span class="s3">\n        </span><span class="s1">if (value.point)</span><span class="s3">\n            </span><span class="s1">this.maxPoint = Math.max(this.maxPoint, to - from);</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">addChunk(from, chunk) {</span><span class="s3">\n        </span><span class="s1">if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) &lt; 0)</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n        </span><span class="s1">if (this.from.length)</span><span class="s3">\n            </span><span class="s1">this.finishChunk(true);</span><span class="s3">\n        </span><span class="s1">this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);</span><span class="s3">\n        </span><span class="s1">this.chunks.push(chunk);</span><span class="s3">\n        </span><span class="s1">this.chunkPos.push(from);</span><span class="s3">\n        </span><span class="s1">let last = chunk.value.length - 1;</span><span class="s3">\n        </span><span class="s1">this.last = chunk.value[last];</span><span class="s3">\n        </span><span class="s1">this.lastFrom = chunk.from[last] + from;</span><span class="s3">\n        </span><span class="s1">this.lastTo = chunk.to[last] + from;</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">Finish the range set. Returns the new set. The builder can't be</span><span class="s3">\n    </span><span class="s1">used anymore after this has been called.</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">finish() { return this.finishInner(RangeSet.empty); }</span><span class="s3">\n    </span><span class="s1">/**</span><span class="s3">\n    </span><span class="s1">@internal</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">finishInner(next) {</span><span class="s3">\n        </span><span class="s1">if (this.from.length)</span><span class="s3">\n            </span><span class="s1">this.finishChunk(false);</span><span class="s3">\n        </span><span class="s1">if (this.chunks.length == 0)</span><span class="s3">\n            </span><span class="s1">return next;</span><span class="s3">\n        </span><span class="s1">let result = RangeSet.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);</span><span class="s3">\n        </span><span class="s1">this.from = null; // Make sure further `add` calls produce errors</span><span class="s3">\n        </span><span class="s1">return result;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findSharedChunks(a, b, textDiff) {</span><span class="s3">\n    </span><span class="s1">let inA = new Map();</span><span class="s3">\n    </span><span class="s1">for (let set of a)</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; set.chunk.length; i++)</span><span class="s3">\n            </span><span class="s1">if (set.chunk[i].maxPoint &lt;= 0)</span><span class="s3">\n                </span><span class="s1">inA.set(set.chunk[i], set.chunkPos[i]);</span><span class="s3">\n    </span><span class="s1">let shared = new Set();</span><span class="s3">\n    </span><span class="s1">for (let set of b)</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; set.chunk.length; i++) {</span><span class="s3">\n            </span><span class="s1">let known = inA.get(set.chunk[i]);</span><span class="s3">\n            </span><span class="s1">if (known != null &amp;&amp; (textDiff ? textDiff.mapPos(known) : known) == set.chunkPos[i] &amp;&amp;</span><span class="s3">\n                </span><span class="s1">!(textDiff === null || textDiff === void 0 ? void 0 : textDiff.touchesRange(known, known + set.chunk[i].length)))</span><span class="s3">\n                </span><span class="s1">shared.add(set.chunk[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return shared;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class LayerCursor {</span><span class="s3">\n    </span><span class="s1">constructor(layer, skip, minPoint, rank = 0) {</span><span class="s3">\n        </span><span class="s1">this.layer = layer;</span><span class="s3">\n        </span><span class="s1">this.skip = skip;</span><span class="s3">\n        </span><span class="s1">this.minPoint = minPoint;</span><span class="s3">\n        </span><span class="s1">this.rank = rank;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get startSide() { return this.value ? this.value.startSide : 0; }</span><span class="s3">\n    </span><span class="s1">get endSide() { return this.value ? this.value.endSide : 0; }</span><span class="s3">\n    </span><span class="s1">goto(pos, side = -1000000000 /* C.Far */) {</span><span class="s3">\n        </span><span class="s1">this.chunkIndex = this.rangeIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.gotoInner(pos, side, false);</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">gotoInner(pos, side, forward) {</span><span class="s3">\n        </span><span class="s1">while (this.chunkIndex &lt; this.layer.chunk.length) {</span><span class="s3">\n            </span><span class="s1">let next = this.layer.chunk[this.chunkIndex];</span><span class="s3">\n            </span><span class="s1">if (!(this.skip &amp;&amp; this.skip.has(next) ||</span><span class="s3">\n                </span><span class="s1">this.layer.chunkEnd(this.chunkIndex) &lt; pos ||</span><span class="s3">\n                </span><span class="s1">next.maxPoint &lt; this.minPoint))</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">this.chunkIndex++;</span><span class="s3">\n            </span><span class="s1">forward = false;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (this.chunkIndex &lt; this.layer.chunk.length) {</span><span class="s3">\n            </span><span class="s1">let rangeIndex = this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], side, true);</span><span class="s3">\n            </span><span class="s1">if (!forward || this.rangeIndex &lt; rangeIndex)</span><span class="s3">\n                </span><span class="s1">this.setRangeIndex(rangeIndex);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forward(pos, side) {</span><span class="s3">\n        </span><span class="s1">if ((this.to - pos || this.endSide - side) &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.gotoInner(pos, side, true);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">if (this.chunkIndex == this.layer.chunk.length) {</span><span class="s3">\n                </span><span class="s1">this.from = this.to = 1000000000 /* C.Far */;</span><span class="s3">\n                </span><span class="s1">this.value = null;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];</span><span class="s3">\n                </span><span class="s1">let from = chunkPos + chunk.from[this.rangeIndex];</span><span class="s3">\n                </span><span class="s1">this.from = from;</span><span class="s3">\n                </span><span class="s1">this.to = chunkPos + chunk.to[this.rangeIndex];</span><span class="s3">\n                </span><span class="s1">this.value = chunk.value[this.rangeIndex];</span><span class="s3">\n                </span><span class="s1">this.setRangeIndex(this.rangeIndex + 1);</span><span class="s3">\n                </span><span class="s1">if (this.minPoint &lt; 0 || this.value.point &amp;&amp; this.to - this.from &gt;= this.minPoint)</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">setRangeIndex(index) {</span><span class="s3">\n        </span><span class="s1">if (index == this.layer.chunk[this.chunkIndex].value.length) {</span><span class="s3">\n            </span><span class="s1">this.chunkIndex++;</span><span class="s3">\n            </span><span class="s1">if (this.skip) {</span><span class="s3">\n                </span><span class="s1">while (this.chunkIndex &lt; this.layer.chunk.length &amp;&amp; this.skip.has(this.layer.chunk[this.chunkIndex]))</span><span class="s3">\n                    </span><span class="s1">this.chunkIndex++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">this.rangeIndex = 0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">this.rangeIndex = index;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nextChunk() {</span><span class="s3">\n        </span><span class="s1">this.chunkIndex++;</span><span class="s3">\n        </span><span class="s1">this.rangeIndex = 0;</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">compare(other) {</span><span class="s3">\n        </span><span class="s1">return this.from - other.from || this.startSide - other.startSide || this.rank - other.rank ||</span><span class="s3">\n            </span><span class="s1">this.to - other.to || this.endSide - other.endSide;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class HeapCursor {</span><span class="s3">\n    </span><span class="s1">constructor(heap) {</span><span class="s3">\n        </span><span class="s1">this.heap = heap;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">static from(sets, skip = null, minPoint = -1) {</span><span class="s3">\n        </span><span class="s1">let heap = [];</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; sets.length; i++) {</span><span class="s3">\n            </span><span class="s1">for (let cur = sets[i]; !cur.isEmpty; cur = cur.nextLayer) {</span><span class="s3">\n                </span><span class="s1">if (cur.maxPoint &gt;= minPoint)</span><span class="s3">\n                    </span><span class="s1">heap.push(new LayerCursor(cur, skip, minPoint, i));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return heap.length == 1 ? heap[0] : new HeapCursor(heap);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">get startSide() { return this.value ? this.value.startSide : 0; }</span><span class="s3">\n    </span><span class="s1">goto(pos, side = -1000000000 /* C.Far */) {</span><span class="s3">\n        </span><span class="s1">for (let cur of this.heap)</span><span class="s3">\n            </span><span class="s1">cur.goto(pos, side);</span><span class="s3">\n        </span><span class="s1">for (let i = this.heap.length &gt;&gt; 1; i &gt;= 0; i--)</span><span class="s3">\n            </span><span class="s1">heapBubble(this.heap, i);</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forward(pos, side) {</span><span class="s3">\n        </span><span class="s1">for (let cur of this.heap)</span><span class="s3">\n            </span><span class="s1">cur.forward(pos, side);</span><span class="s3">\n        </span><span class="s1">for (let i = this.heap.length &gt;&gt; 1; i &gt;= 0; i--)</span><span class="s3">\n            </span><span class="s1">heapBubble(this.heap, i);</span><span class="s3">\n        </span><span class="s1">if ((this.to - pos || this.value.endSide - side) &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">if (this.heap.length == 0) {</span><span class="s3">\n            </span><span class="s1">this.from = this.to = 1000000000 /* C.Far */;</span><span class="s3">\n            </span><span class="s1">this.value = null;</span><span class="s3">\n            </span><span class="s1">this.rank = -1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">let top = this.heap[0];</span><span class="s3">\n            </span><span class="s1">this.from = top.from;</span><span class="s3">\n            </span><span class="s1">this.to = top.to;</span><span class="s3">\n            </span><span class="s1">this.value = top.value;</span><span class="s3">\n            </span><span class="s1">this.rank = top.rank;</span><span class="s3">\n            </span><span class="s1">if (top.value)</span><span class="s3">\n                </span><span class="s1">top.next();</span><span class="s3">\n            </span><span class="s1">heapBubble(this.heap, 0);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function heapBubble(heap, index) {</span><span class="s3">\n    </span><span class="s1">for (let cur = heap[index];;) {</span><span class="s3">\n        </span><span class="s1">let childIndex = (index &lt;&lt; 1) + 1;</span><span class="s3">\n        </span><span class="s1">if (childIndex &gt;= heap.length)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">let child = heap[childIndex];</span><span class="s3">\n        </span><span class="s1">if (childIndex + 1 &lt; heap.length &amp;&amp; child.compare(heap[childIndex + 1]) &gt;= 0) {</span><span class="s3">\n            </span><span class="s1">child = heap[childIndex + 1];</span><span class="s3">\n            </span><span class="s1">childIndex++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (cur.compare(child) &lt; 0)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">heap[childIndex] = cur;</span><span class="s3">\n        </span><span class="s1">heap[index] = child;</span><span class="s3">\n        </span><span class="s1">index = childIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">class SpanCursor {</span><span class="s3">\n    </span><span class="s1">constructor(sets, skip, minPoint) {</span><span class="s3">\n        </span><span class="s1">this.minPoint = minPoint;</span><span class="s3">\n        </span><span class="s1">this.active = [];</span><span class="s3">\n        </span><span class="s1">this.activeTo = [];</span><span class="s3">\n        </span><span class="s1">this.activeRank = [];</span><span class="s3">\n        </span><span class="s1">this.minActive = -1;</span><span class="s3">\n        </span><span class="s1">// A currently active point range, if any</span><span class="s3">\n        </span><span class="s1">this.point = null;</span><span class="s3">\n        </span><span class="s1">this.pointFrom = 0;</span><span class="s3">\n        </span><span class="s1">this.pointRank = 0;</span><span class="s3">\n        </span><span class="s1">this.to = -1000000000 /* C.Far */;</span><span class="s3">\n        </span><span class="s1">this.endSide = 0;</span><span class="s3">\n        </span><span class="s1">// The amount of open active ranges at the start of the iterator.</span><span class="s3">\n        </span><span class="s1">// Not including points.</span><span class="s3">\n        </span><span class="s1">this.openStart = -1;</span><span class="s3">\n        </span><span class="s1">this.cursor = HeapCursor.from(sets, skip, minPoint);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">goto(pos, side = -1000000000 /* C.Far */) {</span><span class="s3">\n        </span><span class="s1">this.cursor.goto(pos, side);</span><span class="s3">\n        </span><span class="s1">this.active.length = this.activeTo.length = this.activeRank.length = 0;</span><span class="s3">\n        </span><span class="s1">this.minActive = -1;</span><span class="s3">\n        </span><span class="s1">this.to = pos;</span><span class="s3">\n        </span><span class="s1">this.endSide = side;</span><span class="s3">\n        </span><span class="s1">this.openStart = -1;</span><span class="s3">\n        </span><span class="s1">this.next();</span><span class="s3">\n        </span><span class="s1">return this;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">forward(pos, side) {</span><span class="s3">\n        </span><span class="s1">while (this.minActive &gt; -1 &amp;&amp; (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) &lt; 0)</span><span class="s3">\n            </span><span class="s1">this.removeActive(this.minActive);</span><span class="s3">\n        </span><span class="s1">this.cursor.forward(pos, side);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">removeActive(index) {</span><span class="s3">\n        </span><span class="s1">remove(this.active, index);</span><span class="s3">\n        </span><span class="s1">remove(this.activeTo, index);</span><span class="s3">\n        </span><span class="s1">remove(this.activeRank, index);</span><span class="s3">\n        </span><span class="s1">this.minActive = findMinIndex(this.active, this.activeTo);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">addActive(trackOpen) {</span><span class="s3">\n        </span><span class="s1">let i = 0, { value, to, rank } = this.cursor;</span><span class="s3">\n        </span><span class="s1">// Organize active marks by rank first, then by size</span><span class="s3">\n        </span><span class="s1">while (i &lt; this.activeRank.length &amp;&amp; (rank - this.activeRank[i] || to - this.activeTo[i]) &gt; 0)</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">insert(this.active, i, value);</span><span class="s3">\n        </span><span class="s1">insert(this.activeTo, i, to);</span><span class="s3">\n        </span><span class="s1">insert(this.activeRank, i, rank);</span><span class="s3">\n        </span><span class="s1">if (trackOpen)</span><span class="s3">\n            </span><span class="s1">insert(trackOpen, i, this.cursor.from);</span><span class="s3">\n        </span><span class="s1">this.minActive = findMinIndex(this.active, this.activeTo);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// After calling this, if `this.point` != null, the next range is a</span><span class="s3">\n    </span><span class="s1">// point. Otherwise, it's a regular range, covered by `this.active`.</span><span class="s3">\n    </span><span class="s1">next() {</span><span class="s3">\n        </span><span class="s1">let from = this.to, wasPoint = this.point;</span><span class="s3">\n        </span><span class="s1">this.point = null;</span><span class="s3">\n        </span><span class="s1">let trackOpen = this.openStart &lt; 0 ? [] : null;</span><span class="s3">\n        </span><span class="s1">for (;;) {</span><span class="s3">\n            </span><span class="s1">let a = this.minActive;</span><span class="s3">\n            </span><span class="s1">if (a &gt; -1 &amp;&amp; (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) &lt; 0) {</span><span class="s3">\n                </span><span class="s1">if (this.activeTo[a] &gt; from) {</span><span class="s3">\n                    </span><span class="s1">this.to = this.activeTo[a];</span><span class="s3">\n                    </span><span class="s1">this.endSide = this.active[a].endSide;</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">this.removeActive(a);</span><span class="s3">\n                </span><span class="s1">if (trackOpen)</span><span class="s3">\n                    </span><span class="s1">remove(trackOpen, a);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (!this.cursor.value) {</span><span class="s3">\n                </span><span class="s1">this.to = this.endSide = 1000000000 /* C.Far */;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else if (this.cursor.from &gt; from) {</span><span class="s3">\n                </span><span class="s1">this.to = this.cursor.from;</span><span class="s3">\n                </span><span class="s1">this.endSide = this.cursor.startSide;</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">else {</span><span class="s3">\n                </span><span class="s1">let nextVal = this.cursor.value;</span><span class="s3">\n                </span><span class="s1">if (!nextVal.point) { // Opening a range</span><span class="s3">\n                    </span><span class="s1">this.addActive(trackOpen);</span><span class="s3">\n                    </span><span class="s1">this.cursor.next();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else if (wasPoint &amp;&amp; this.cursor.to == this.to &amp;&amp; this.cursor.from &lt; this.cursor.to) {</span><span class="s3">\n                    </span><span class="s1">// Ignore any non-empty points that end precisely at the end of the prev point</span><span class="s3">\n                    </span><span class="s1">this.cursor.next();</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">else { // New point</span><span class="s3">\n                    </span><span class="s1">this.point = nextVal;</span><span class="s3">\n                    </span><span class="s1">this.pointFrom = this.cursor.from;</span><span class="s3">\n                    </span><span class="s1">this.pointRank = this.cursor.rank;</span><span class="s3">\n                    </span><span class="s1">this.to = this.cursor.to;</span><span class="s3">\n                    </span><span class="s1">this.endSide = nextVal.endSide;</span><span class="s3">\n                    </span><span class="s1">this.cursor.next();</span><span class="s3">\n                    </span><span class="s1">this.forward(this.to, this.endSide);</span><span class="s3">\n                    </span><span class="s1">break;</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (trackOpen) {</span><span class="s3">\n            </span><span class="s1">this.openStart = 0;</span><span class="s3">\n            </span><span class="s1">for (let i = trackOpen.length - 1; i &gt;= 0 &amp;&amp; trackOpen[i] &lt; from; i--)</span><span class="s3">\n                </span><span class="s1">this.openStart++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">activeForPoint(to) {</span><span class="s3">\n        </span><span class="s1">if (!this.active.length)</span><span class="s3">\n            </span><span class="s1">return this.active;</span><span class="s3">\n        </span><span class="s1">let active = [];</span><span class="s3">\n        </span><span class="s1">for (let i = this.active.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n            </span><span class="s1">if (this.activeRank[i] &lt; this.pointRank)</span><span class="s3">\n                </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">if (this.activeTo[i] &gt; to || this.activeTo[i] == to &amp;&amp; this.active[i].endSide &gt;= this.point.endSide)</span><span class="s3">\n                </span><span class="s1">active.push(this.active[i]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return active.reverse();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">openEnd(to) {</span><span class="s3">\n        </span><span class="s1">let open = 0;</span><span class="s3">\n        </span><span class="s1">for (let i = this.activeTo.length - 1; i &gt;= 0 &amp;&amp; this.activeTo[i] &gt; to; i--)</span><span class="s3">\n            </span><span class="s1">open++;</span><span class="s3">\n        </span><span class="s1">return open;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function compare(a, startA, b, startB, length, comparator) {</span><span class="s3">\n    </span><span class="s1">a.goto(startA);</span><span class="s3">\n    </span><span class="s1">b.goto(startB);</span><span class="s3">\n    </span><span class="s1">let endB = startB + length;</span><span class="s3">\n    </span><span class="s1">let pos = startB, dPos = startB - startA;</span><span class="s3">\n    </span><span class="s1">for (;;) {</span><span class="s3">\n        </span><span class="s1">let dEnd = (a.to + dPos) - b.to, diff = dEnd || a.endSide - b.endSide;</span><span class="s3">\n        </span><span class="s1">let end = diff &lt; 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);</span><span class="s3">\n        </span><span class="s1">if (a.point || b.point) {</span><span class="s3">\n            </span><span class="s1">if (!(a.point &amp;&amp; b.point &amp;&amp; (a.point == b.point || a.point.eq(b.point)) &amp;&amp;</span><span class="s3">\n                </span><span class="s1">sameValues(a.activeForPoint(a.to), b.activeForPoint(b.to))))</span><span class="s3">\n                </span><span class="s1">comparator.comparePoint(pos, clipEnd, a.point, b.point);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">if (clipEnd &gt; pos &amp;&amp; !sameValues(a.active, b.active))</span><span class="s3">\n                </span><span class="s1">comparator.compareRange(pos, clipEnd, a.active, b.active);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (end &gt; endB)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">if ((dEnd || a.openEnd != b.openEnd) &amp;&amp; comparator.boundChange)</span><span class="s3">\n            </span><span class="s1">comparator.boundChange(end);</span><span class="s3">\n        </span><span class="s1">pos = end;</span><span class="s3">\n        </span><span class="s1">if (diff &lt;= 0)</span><span class="s3">\n            </span><span class="s1">a.next();</span><span class="s3">\n        </span><span class="s1">if (diff &gt;= 0)</span><span class="s3">\n            </span><span class="s1">b.next();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function sameValues(a, b) {</span><span class="s3">\n    </span><span class="s1">if (a.length != b.length)</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; a.length; i++)</span><span class="s3">\n        </span><span class="s1">if (a[i] != b[i] &amp;&amp; !a[i].eq(b[i]))</span><span class="s3">\n            </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function remove(array, index) {</span><span class="s3">\n    </span><span class="s1">for (let i = index, e = array.length - 1; i &lt; e; i++)</span><span class="s3">\n        </span><span class="s1">array[i] = array[i + 1];</span><span class="s3">\n    </span><span class="s1">array.pop();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function insert(array, index, value) {</span><span class="s3">\n    </span><span class="s1">for (let i = array.length - 1; i &gt;= index; i--)</span><span class="s3">\n        </span><span class="s1">array[i + 1] = array[i];</span><span class="s3">\n    </span><span class="s1">array[index] = value;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">function findMinIndex(value, array) {</span><span class="s3">\n    </span><span class="s1">let found = -1, foundPos = 1000000000 /* C.Far */;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; array.length; i++)</span><span class="s3">\n        </span><span class="s1">if ((array[i] - foundPos || value[i].endSide - value[found].endSide) &lt; 0) {</span><span class="s3">\n            </span><span class="s1">found = i;</span><span class="s3">\n            </span><span class="s1">foundPos = array[i];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return found;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Count the column position at the given offset into the string,</span><span class="s3">\n</span><span class="s1">taking extending characters and tab size into account.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function countColumn(string, tabSize, to = string.length) {</span><span class="s3">\n    </span><span class="s1">let n = 0;</span><span class="s3">\n    </span><span class="s1">for (let i = 0; i &lt; to;) {</span><span class="s3">\n        </span><span class="s1">if (string.charCodeAt(i) == 9) {</span><span class="s3">\n            </span><span class="s1">n += tabSize - (n % tabSize);</span><span class="s3">\n            </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">else {</span><span class="s3">\n            </span><span class="s1">n++;</span><span class="s3">\n            </span><span class="s1">i = findClusterBreak(string, i);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return n;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">Find the offset that corresponds to the given column position in a</span><span class="s3">\n</span><span class="s1">string, taking extending characters and tab size into account. By</span><span class="s3">\n</span><span class="s1">default, the string length is returned when it is too short to</span><span class="s3">\n</span><span class="s1">reach the column. Pass `strict` true to make it return -1 in that</span><span class="s3">\n</span><span class="s1">situation.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function findColumn(string, col, tabSize, strict) {</span><span class="s3">\n    </span><span class="s1">for (let i = 0, n = 0;;) {</span><span class="s3">\n        </span><span class="s1">if (n &gt;= col)</span><span class="s3">\n            </span><span class="s1">return i;</span><span class="s3">\n        </span><span class="s1">if (i == string.length)</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;</span><span class="s3">\n        </span><span class="s1">i = findClusterBreak(string, i);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return strict === true ? -1 : string.length;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">export { Annotation, AnnotationType, ChangeDesc, ChangeSet, CharCategory, Compartment, EditorSelection, EditorState, Facet, Line, MapMode, Prec, Range, RangeSet, RangeSetBuilder, RangeValue, SelectionRange, StateEffect, StateEffectType, StateField, Text, Transaction, codePointAt, codePointSize, combineConfig, countColumn, findClusterBreak, findColumn, fromCodePoint };</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>