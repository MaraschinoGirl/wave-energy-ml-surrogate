<html>
<head>
<title>5822.6dcbc72eeab5ed4295aa.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
5822.6dcbc72eeab5ed4295aa.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;5822.6dcbc72eeab5ed4295aa.js?v=6dcbc72eeab5ed4295aa&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;;;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB;AAChB,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;AACzC,2BAA2B;;AAE3B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,uBAAuB;AAC/B;AACA;AACA;AACA,QAAQ,sBAAsB;AAC9B,8CAA8C;AAC9C,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,sBAAsB,oBAAoB;AAC1C;AACA;AACA;;AAEO,4BAA4B;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAqE;AACrE;AACA;AACA;;AAEO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF;AAClF;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU,+BAA+B,KAAK;AAC9C,wBAAwB,GAAG;AAC3B;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA,uCAAuC;AACvC,mCAAmC;AACnC,mCAAmC;AACnC,wCAAwC;AACxC;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA,CAAC&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/legacy-modes/mode/verilog.js&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;function mkVerilog(parserConfig) {</span><span class="s3">\n\n  </span><span class="s1">var statementIndentUnit = parserConfig.statementIndentUnit,</span><span class="s3">\n      </span><span class="s1">dontAlignCalls = parserConfig.dontAlignCalls,</span><span class="s3">\n      </span><span class="s1">noIndentKeywords = parserConfig.noIndentKeywords || [],</span><span class="s3">\n      </span><span class="s1">multiLineStrings = parserConfig.multiLineStrings,</span><span class="s3">\n      </span><span class="s1">hooks = parserConfig.hooks || {};</span><span class="s3">\n\n  </span><span class="s1">function words(str) {</span><span class="s3">\n    </span><span class="s1">var obj = {}, words = str.split(</span><span class="s3">\&quot; \&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; words.length; ++i) obj[words[i]] = true;</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* Keywords from IEEE 1800-2012</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">var keywords = words(</span><span class="s3">\n    \&quot;</span><span class="s1">accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">incdir include initial inout input inside instance int integer interconnect interface intersect join join_any </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">join_none large let liblist library local localparam logic longint macromodule matches medium modport module </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">/** Operators from IEEE 1800-2012</span><span class="s3">\n      </span><span class="s1">unary_operator ::=</span><span class="s3">\n      </span><span class="s1">+ | - | ! | ~ | &amp; | ~&amp; | | | ~| | ^ | ~^ | ^~</span><span class="s3">\n      </span><span class="s1">binary_operator ::=</span><span class="s3">\n      </span><span class="s1">+ | - | * | / | % | == | != | === | !== | ==? | !=? | &amp;&amp; | || | **</span><span class="s3">\n      </span><span class="s1">| &lt; | &lt;= | &gt; | &gt;= | &amp; | | | ^ | ^~ | ~^ | &gt;&gt; | &lt;&lt; | &gt;&gt;&gt; | &lt;&lt;&lt;</span><span class="s3">\n      </span><span class="s1">| -&gt; | &lt;-&gt;</span><span class="s3">\n      </span><span class="s1">inc_or_dec_operator ::= ++ | --</span><span class="s3">\n      </span><span class="s1">unary_module_path_operator ::=</span><span class="s3">\n      </span><span class="s1">! | ~ | &amp; | ~&amp; | | | ~| | ^ | ~^ | ^~</span><span class="s3">\n      </span><span class="s1">binary_module_path_operator ::=</span><span class="s3">\n      </span><span class="s1">== | != | &amp;&amp; | || | &amp; | | | ^ | ^~ | ~^</span><span class="s3">\n  </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">var isOperatorChar = /[</span><span class="s3">\\</span><span class="s1">+</span><span class="s3">\\</span><span class="s1">-</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">/!~&amp;|^%=?:]/;</span><span class="s3">\n  </span><span class="s1">var isBracketChar = /[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}()]/;</span><span class="s3">\n\n  </span><span class="s1">var unsignedNumber = /</span><span class="s3">\\</span><span class="s1">d[0-9_]*/;</span><span class="s3">\n  </span><span class="s1">var decimalLiteral = /</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">s*'s?d</span><span class="s3">\\</span><span class="s1">s*</span><span class="s3">\\</span><span class="s1">d[0-9_]*/i;</span><span class="s3">\n  </span><span class="s1">var binaryLiteral = /</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">s*'s?b</span><span class="s3">\\</span><span class="s1">s*[xz01][xz01_]*/i;</span><span class="s3">\n  </span><span class="s1">var octLiteral = /</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">s*'s?o</span><span class="s3">\\</span><span class="s1">s*[xz0-7][xz0-7_]*/i;</span><span class="s3">\n  </span><span class="s1">var hexLiteral = /</span><span class="s3">\\</span><span class="s1">d*</span><span class="s3">\\</span><span class="s1">s*'s?h</span><span class="s3">\\</span><span class="s1">s*[0-9a-fxz?][0-9a-fxz?_]*/i;</span><span class="s3">\n  </span><span class="s1">var realLiteral = /(</span><span class="s3">\\</span><span class="s1">d[</span><span class="s3">\\</span><span class="s1">d_]*(</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d[</span><span class="s3">\\</span><span class="s1">d_]*)?E-?[</span><span class="s3">\\</span><span class="s1">d_]+)|(</span><span class="s3">\\</span><span class="s1">d[</span><span class="s3">\\</span><span class="s1">d_]*</span><span class="s3">\\</span><span class="s1">.</span><span class="s3">\\</span><span class="s1">d[</span><span class="s3">\\</span><span class="s1">d_]*)/i;</span><span class="s3">\n\n  </span><span class="s1">var closingBracketOrWord = /^((</span><span class="s3">\\</span><span class="s1">w+)|[)}</span><span class="s3">\\</span><span class="s1">]])/;</span><span class="s3">\n  </span><span class="s1">var closingBracket = /[)}</span><span class="s3">\\</span><span class="s1">]]/;</span><span class="s3">\n\n  </span><span class="s1">var curPunc;</span><span class="s3">\n  </span><span class="s1">var curKeyword;</span><span class="s3">\n\n  </span><span class="s1">// Block openings which are closed by a matching keyword in the form of (</span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot; </span><span class="s1">+ keyword)</span><span class="s3">\n  </span><span class="s1">// E.g. </span><span class="s3">\&quot;</span><span class="s1">task</span><span class="s3">\&quot; </span><span class="s1">=&gt; </span><span class="s3">\&quot;</span><span class="s1">endtask</span><span class="s3">\&quot;\n  </span><span class="s1">var blockKeywords = words(</span><span class="s3">\n    \&quot;</span><span class="s1">case checker class clocking config function generate interface module package </span><span class="s3">\&quot; </span><span class="s1">+</span><span class="s3">\n      \&quot;</span><span class="s1">primitive program property specify sequence table task</span><span class="s3">\&quot;\n  </span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">// Opening/closing pairs</span><span class="s3">\n  </span><span class="s1">var openClose = {};</span><span class="s3">\n  </span><span class="s1">for (var keyword in blockKeywords) {</span><span class="s3">\n    </span><span class="s1">openClose[keyword] = </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot; </span><span class="s1">+ keyword;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">begin</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">end</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">casex</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">endcase</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">casez</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">endcase</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">do</span><span class="s3">\&quot;   </span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">while</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">fork</span><span class="s3">\&quot; </span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">join;join_any;join_none</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">openClose[</span><span class="s3">\&quot;</span><span class="s1">covergroup</span><span class="s3">\&quot;</span><span class="s1">] = </span><span class="s3">\&quot;</span><span class="s1">endgroup</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n  </span><span class="s1">for (var i in noIndentKeywords) {</span><span class="s3">\n    </span><span class="s1">var keyword = noIndentKeywords[i];</span><span class="s3">\n    </span><span class="s1">if (openClose[keyword]) {</span><span class="s3">\n      </span><span class="s1">openClose[keyword] = undefined;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Keywords which open statements that are ended with a semi-colon</span><span class="s3">\n  </span><span class="s1">var statementKeywords = words(</span><span class="s3">\&quot;</span><span class="s1">always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">function tokenBase(stream, state) {</span><span class="s3">\n    </span><span class="s1">var ch = stream.peek(), style;</span><span class="s3">\n    </span><span class="s1">if (hooks[ch] &amp;&amp; (style = hooks[ch](stream, state)) != false) return style;</span><span class="s3">\n    </span><span class="s1">if (hooks.tokenBase &amp;&amp; (style = hooks.tokenBase(stream, state)) != false)</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n\n    </span><span class="s1">if (/[,;:</span><span class="s3">\\</span><span class="s1">.]/.test(ch)) {</span><span class="s3">\n      </span><span class="s1">curPunc = stream.next();</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (isBracketChar.test(ch)) {</span><span class="s3">\n      </span><span class="s1">curPunc = stream.next();</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bracket</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Macros (tick-defines)</span><span class="s3">\n    </span><span class="s1">if (ch == '`') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">if (stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/)) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// System calls</span><span class="s3">\n    </span><span class="s1">if (ch == '$') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">if (stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/)) {</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Time literals</span><span class="s3">\n    </span><span class="s1">if (ch == '#') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">d_.]/);</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Strings</span><span class="s3">\n    </span><span class="s1">if (ch == '</span><span class="s3">\&quot;</span><span class="s1">') {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">state.tokenize = tokenString(ch);</span><span class="s3">\n      </span><span class="s1">return state.tokenize(stream, state);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Comments</span><span class="s3">\n    </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">stream.next();</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenComment;</span><span class="s3">\n        </span><span class="s1">return tokenComment(stream, state);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (stream.eat(</span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n        </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">stream.backUp(1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Numeric literals</span><span class="s3">\n    </span><span class="s1">if (stream.match(realLiteral) ||</span><span class="s3">\n        </span><span class="s1">stream.match(decimalLiteral) ||</span><span class="s3">\n        </span><span class="s1">stream.match(binaryLiteral) ||</span><span class="s3">\n        </span><span class="s1">stream.match(octLiteral) ||</span><span class="s3">\n        </span><span class="s1">stream.match(hexLiteral) ||</span><span class="s3">\n        </span><span class="s1">stream.match(unsignedNumber) ||</span><span class="s3">\n        </span><span class="s1">stream.match(realLiteral)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Operators</span><span class="s3">\n    </span><span class="s1">if (stream.eatWhile(isOperatorChar)) {</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// Keywords / plain variables</span><span class="s3">\n    </span><span class="s1">if (stream.eatWhile(/[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">$_]/)) {</span><span class="s3">\n      </span><span class="s1">var cur = stream.current();</span><span class="s3">\n      </span><span class="s1">if (keywords[cur]) {</span><span class="s3">\n        </span><span class="s1">if (openClose[cur]) {</span><span class="s3">\n          </span><span class="s1">curPunc = </span><span class="s3">\&quot;</span><span class="s1">newblock</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (statementKeywords[cur]) {</span><span class="s3">\n          </span><span class="s1">curPunc = </span><span class="s3">\&quot;</span><span class="s1">newstatement</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">curKeyword = cur;</span><span class="s3">\n        </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">stream.next();</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenString(quote) {</span><span class="s3">\n    </span><span class="s1">return function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var escaped = false, next, end = false;</span><span class="s3">\n      </span><span class="s1">while ((next = stream.next()) != null) {</span><span class="s3">\n        </span><span class="s1">if (next == quote &amp;&amp; !escaped) {end = true; break;}</span><span class="s3">\n        </span><span class="s1">escaped = !escaped &amp;&amp; next == </span><span class="s3">\&quot;\\\\\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (end || !(escaped || multiLineStrings))</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n      </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">string</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function tokenComment(stream, state) {</span><span class="s3">\n    </span><span class="s1">var maybeEnd = false, ch;</span><span class="s3">\n    </span><span class="s1">while (ch = stream.next()) {</span><span class="s3">\n      </span><span class="s1">if (ch == </span><span class="s3">\&quot;</span><span class="s1">/</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; maybeEnd) {</span><span class="s3">\n        </span><span class="s1">state.tokenize = tokenBase;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">maybeEnd = (ch == </span><span class="s3">\&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function Context(indented, column, type, align, prev) {</span><span class="s3">\n    </span><span class="s1">this.indented = indented;</span><span class="s3">\n    </span><span class="s1">this.column = column;</span><span class="s3">\n    </span><span class="s1">this.type = type;</span><span class="s3">\n    </span><span class="s1">this.align = align;</span><span class="s3">\n    </span><span class="s1">this.prev = prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function pushContext(state, col, type) {</span><span class="s3">\n    </span><span class="s1">var indent = state.indented;</span><span class="s3">\n    </span><span class="s1">var c = new Context(indent, col, type, null, state.context);</span><span class="s3">\n    </span><span class="s1">return state.context = c;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">function popContext(state) {</span><span class="s3">\n    </span><span class="s1">var t = state.context.type;</span><span class="s3">\n    </span><span class="s1">if (t == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">|| t == </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot; </span><span class="s1">|| t == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">state.indented = state.context.indented;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return state.context = state.context.prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function isClosing(text, contextClosing) {</span><span class="s3">\n    </span><span class="s1">if (text == contextClosing) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// contextClosing may be multiple keywords separated by ;</span><span class="s3">\n      </span><span class="s1">var closingKeywords = contextClosing.split(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">for (var i in closingKeywords) {</span><span class="s3">\n        </span><span class="s1">if (text == closingKeywords[i]) {</span><span class="s3">\n          </span><span class="s1">return true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">function buildElectricInputRegEx() {</span><span class="s3">\n    </span><span class="s1">// Reindentation should occur on any bracket char: {}()[]</span><span class="s3">\n    </span><span class="s1">// or on a match of any of the block closing keywords, at</span><span class="s3">\n    </span><span class="s1">// the end of a line</span><span class="s3">\n    </span><span class="s1">var allClosings = [];</span><span class="s3">\n    </span><span class="s1">for (var i in openClose) {</span><span class="s3">\n      </span><span class="s1">if (openClose[i]) {</span><span class="s3">\n        </span><span class="s1">var closings = openClose[i].split(</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">for (var j in closings) {</span><span class="s3">\n          </span><span class="s1">allClosings.push(closings[j]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var re = new RegExp(</span><span class="s3">\&quot;</span><span class="s1">[{}()</span><span class="s3">\\\\</span><span class="s1">[</span><span class="s3">\\\\</span><span class="s1">]]|(</span><span class="s3">\&quot; </span><span class="s1">+ allClosings.join(</span><span class="s3">\&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">) + </span><span class="s3">\&quot;</span><span class="s1">)$</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">return re;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Interface</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">verilog</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n    </span><span class="s1">startState: function(indentUnit) {</span><span class="s3">\n      </span><span class="s1">var state = {</span><span class="s3">\n        </span><span class="s1">tokenize: null,</span><span class="s3">\n        </span><span class="s1">context: new Context(-indentUnit, 0, </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">, false),</span><span class="s3">\n        </span><span class="s1">indented: 0,</span><span class="s3">\n        </span><span class="s1">startOfLine: true</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (hooks.startState) hooks.startState(state);</span><span class="s3">\n      </span><span class="s1">return state;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var ctx = state.context;</span><span class="s3">\n      </span><span class="s1">if (stream.sol()) {</span><span class="s3">\n        </span><span class="s1">if (ctx.align == null) ctx.align = false;</span><span class="s3">\n        </span><span class="s1">state.indented = stream.indentation();</span><span class="s3">\n        </span><span class="s1">state.startOfLine = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (hooks.token) {</span><span class="s3">\n        </span><span class="s1">// Call hook, with an optional return value of a style to override verilog styling.</span><span class="s3">\n        </span><span class="s1">var style = hooks.token(stream, state);</span><span class="s3">\n        </span><span class="s1">if (style !== undefined) {</span><span class="s3">\n          </span><span class="s1">return style;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (stream.eatSpace()) return null;</span><span class="s3">\n      </span><span class="s1">curPunc = null;</span><span class="s3">\n      </span><span class="s1">curKeyword = null;</span><span class="s3">\n      </span><span class="s1">var style = (state.tokenize || tokenBase)(stream, state);</span><span class="s3">\n      </span><span class="s1">if (style == </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot; </span><span class="s1">|| style == </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">) return style;</span><span class="s3">\n      </span><span class="s1">if (ctx.align == null) ctx.align = true;</span><span class="s3">\n\n      </span><span class="s1">if (curPunc == ctx.type) {</span><span class="s3">\n        </span><span class="s1">popContext(state);</span><span class="s3">\n      </span><span class="s1">} else if ((curPunc == </span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) ||</span><span class="s3">\n                 </span><span class="s1">(ctx.type &amp;&amp; isClosing(curKeyword, ctx.type))) {</span><span class="s3">\n        </span><span class="s1">ctx = popContext(state);</span><span class="s3">\n        </span><span class="s1">while (ctx &amp;&amp; ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) ctx = popContext(state);</span><span class="s3">\n      </span><span class="s1">} else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">[</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">(</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (ctx &amp;&amp; ctx.type == </span><span class="s3">\&quot;</span><span class="s1">endcase</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; curPunc == </span><span class="s3">\&quot;</span><span class="s1">:</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">newstatement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">pushContext(state, stream.column(), </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">} else if (curPunc == </span><span class="s3">\&quot;</span><span class="s1">newblock</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (curKeyword == </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ctx &amp;&amp; (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">|| ctx.type == </span><span class="s3">\&quot;</span><span class="s1">endgroup</span><span class="s3">\&quot;</span><span class="s1">)) {</span><span class="s3">\n          </span><span class="s1">// The 'function' keyword can appear in some other contexts where it actually does not</span><span class="s3">\n          </span><span class="s1">// indicate a function (import/export DPI and covergroup definitions).</span><span class="s3">\n          </span><span class="s1">// Do nothing in this case</span><span class="s3">\n        </span><span class="s1">} else if (curKeyword == </span><span class="s3">\&quot;</span><span class="s1">task</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; ctx &amp;&amp; ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">// Same thing for task</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var close = openClose[curKeyword];</span><span class="s3">\n          </span><span class="s1">pushContext(state, stream.column(), close);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">state.startOfLine = false;</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">indent: function(state, textAfter, cx) {</span><span class="s3">\n      </span><span class="s1">if (state.tokenize != tokenBase &amp;&amp; state.tokenize != null) return null;</span><span class="s3">\n      </span><span class="s1">if (hooks.indent) {</span><span class="s3">\n        </span><span class="s1">var fromHook = hooks.indent(state);</span><span class="s3">\n        </span><span class="s1">if (fromHook &gt;= 0) return fromHook;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var ctx = state.context, firstChar = textAfter &amp;&amp; textAfter.charAt(0);</span><span class="s3">\n      </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; firstChar == </span><span class="s3">\&quot;</span><span class="s1">}</span><span class="s3">\&quot;</span><span class="s1">) ctx = ctx.prev;</span><span class="s3">\n      </span><span class="s1">var closing = false;</span><span class="s3">\n      </span><span class="s1">var possibleClosing = textAfter.match(closingBracketOrWord);</span><span class="s3">\n      </span><span class="s1">if (possibleClosing)</span><span class="s3">\n        </span><span class="s1">closing = isClosing(possibleClosing[0], ctx.type);</span><span class="s3">\n      </span><span class="s1">if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">statement</span><span class="s3">\&quot;</span><span class="s1">) return ctx.indented + (firstChar == </span><span class="s3">\&quot;</span><span class="s1">{</span><span class="s3">\&quot; </span><span class="s1">? 0 : statementIndentUnit || cx.unit);</span><span class="s3">\n      </span><span class="s1">else if (closingBracket.test(ctx.type) &amp;&amp; ctx.align &amp;&amp; !dontAlignCalls) return ctx.column + (closing ? 0 : 1);</span><span class="s3">\n      </span><span class="s1">else if (ctx.type == </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; !closing) return ctx.indented + (statementIndentUnit || cx.unit);</span><span class="s3">\n      </span><span class="s1">else return ctx.indented + (closing ? 0 : cx.unit);</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">languageData: {</span><span class="s3">\n      </span><span class="s1">indentOnInput: buildElectricInputRegEx(),</span><span class="s3">\n      </span><span class="s1">commentTokens: {line: </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">, block: {open: </span><span class="s3">\&quot;</span><span class="s1">/*</span><span class="s3">\&quot;</span><span class="s1">, close: </span><span class="s3">\&quot;</span><span class="s1">*/</span><span class="s3">\&quot;</span><span class="s1">}}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export const verilog = mkVerilog({})</span><span class="s3">\n\n</span><span class="s1">// TL-Verilog mode.</span><span class="s3">\n</span><span class="s1">// See tl-x.org for language spec.</span><span class="s3">\n</span><span class="s1">// See the mode in action at makerchip.com.</span><span class="s3">\n</span><span class="s1">// Contact: steve.hoover@redwoodeda.com</span><span class="s3">\n\n</span><span class="s1">// TLV Identifier prefixes.</span><span class="s3">\n</span><span class="s1">// Note that sign is not treated separately, so </span><span class="s3">\&quot;</span><span class="s1">+/-</span><span class="s3">\&quot; </span><span class="s1">versions of numeric identifiers</span><span class="s3">\n</span><span class="s1">// are included.</span><span class="s3">\n</span><span class="s1">var tlvIdentifierStyle = {</span><span class="s3">\n  \&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">link</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">,  // Should condition this off for &gt; TLV 1c.</span><span class="s3">\n  \&quot;</span><span class="s1">$</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">$$</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">?$</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">?*</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">qualifier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">contentSeparator</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">/-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">property</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@++</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@+=</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@+=-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@--</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@-=</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variableName.special</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">%+</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">%-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">%</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;&gt;</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">&lt;&lt;</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">&lt;&gt;</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">#</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">tag</span><span class="s3">\&quot;</span><span class="s1">,  // Need to choose a style for this.</span><span class="s3">\n  \&quot;</span><span class="s1">^</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">^^</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">^!</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">attribute</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">*</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">**</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">variable</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;\\\\\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;\\\&quot;\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Lines starting with these characters define scope (result in indentation).</span><span class="s3">\n</span><span class="s1">var tlvScopePrefixChars = {</span><span class="s3">\n  \&quot;</span><span class="s1">/</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">beh-hier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">&gt;</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">beh-hier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">-</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">phys-hier</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">|</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">pipe</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">?</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">when</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;</span><span class="s1">@</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">stage</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  \&quot;\\\\\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var tlvIndentUnit = 3;</span><span class="s3">\n</span><span class="s1">var tlvTrackStatements = false;</span><span class="s3">\n</span><span class="s1">var tlvIdentMatch = /^([~!@#</span><span class="s3">\\</span><span class="s1">$%</span><span class="s3">\\</span><span class="s1">^&amp;</span><span class="s3">\\</span><span class="s1">*-</span><span class="s3">\\</span><span class="s1">+=</span><span class="s3">\\</span><span class="s1">?</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\\\\\</span><span class="s1">|'</span><span class="s3">\&quot;</span><span class="s1">&lt;&gt;]+)([</span><span class="s3">\\</span><span class="s1">d</span><span class="s3">\\</span><span class="s1">w_]*)/;  // Matches an identifier.</span><span class="s3">\n</span><span class="s1">// Note that ':' is excluded, because of it's use in [:].</span><span class="s3">\n</span><span class="s1">var tlvLineIndentationMatch = /^[! ] */;</span><span class="s3">\n</span><span class="s1">var tlvCommentMatch = /^</span><span class="s3">\\</span><span class="s1">/[</span><span class="s3">\\</span><span class="s1">/</span><span class="s3">\\</span><span class="s1">*]/;</span><span class="s3">\n\n</span><span class="s1">export const tlv = mkVerilog({</span><span class="s3">\n  </span><span class="s1">hooks: {</span><span class="s3">\n    </span><span class="s1">electricInput: false,</span><span class="s3">\n\n    </span><span class="s1">// Return undefined for verilog tokenizing, or style for TLV token (null not used).</span><span class="s3">\n    </span><span class="s1">// Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting</span><span class="s3">\n    </span><span class="s1">// can be enabled with the definition of cm-tlv-* styles, including highlighting for:</span><span class="s3">\n    </span><span class="s1">//   - M4 tokens</span><span class="s3">\n    </span><span class="s1">//   - TLV scope indentation</span><span class="s3">\n    </span><span class="s1">//   - Statement delimitation (enabled by tlvTrackStatements)</span><span class="s3">\n    </span><span class="s1">token: function(stream, state) {</span><span class="s3">\n      </span><span class="s1">var style = undefined;</span><span class="s3">\n      </span><span class="s1">var match;  // Return value of pattern matches.</span><span class="s3">\n\n      </span><span class="s1">// Set highlighting mode based on code region (TLV or SV).</span><span class="s3">\n      </span><span class="s1">if (stream.sol() &amp;&amp; ! state.tlvInBlockComment) {</span><span class="s3">\n        </span><span class="s1">// Process region.</span><span class="s3">\n        </span><span class="s1">if (stream.peek() == '</span><span class="s3">\\\\</span><span class="s1">') {</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">def</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n          </span><span class="s1">if (stream.string.match(/</span><span class="s3">\\\\</span><span class="s1">SV/)) {</span><span class="s3">\n            </span><span class="s1">state.tlvCodeActive = false;</span><span class="s3">\n          </span><span class="s1">} else if (stream.string.match(/</span><span class="s3">\\\\</span><span class="s1">TLV/)){</span><span class="s3">\n            </span><span class="s1">state.tlvCodeActive = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Correct indentation in the face of a line prefix char.</span><span class="s3">\n        </span><span class="s1">if (state.tlvCodeActive &amp;&amp; stream.pos == 0 &amp;&amp;</span><span class="s3">\n            </span><span class="s1">(state.indented == 0) &amp;&amp; (match = stream.match(tlvLineIndentationMatch, false))) {</span><span class="s3">\n          </span><span class="s1">state.indented = match[0].length;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Compute indentation state:</span><span class="s3">\n        </span><span class="s1">//   o Auto indentation on next line</span><span class="s3">\n        </span><span class="s1">//   o Indentation scope styles</span><span class="s3">\n        </span><span class="s1">var indented = state.indented;</span><span class="s3">\n        </span><span class="s1">var depth = indented / tlvIndentUnit;</span><span class="s3">\n        </span><span class="s1">if (depth &lt;= state.tlvIndentationStyle.length) {</span><span class="s3">\n          </span><span class="s1">// not deeper than current scope</span><span class="s3">\n\n          </span><span class="s1">var blankline = stream.string.length == indented;</span><span class="s3">\n          </span><span class="s1">var chPos = depth * tlvIndentUnit;</span><span class="s3">\n          </span><span class="s1">if (chPos &lt; stream.string.length) {</span><span class="s3">\n            </span><span class="s1">var bodyString = stream.string.slice(chPos);</span><span class="s3">\n            </span><span class="s1">var ch = bodyString[0];</span><span class="s3">\n            </span><span class="s1">if (tlvScopePrefixChars[ch] &amp;&amp; ((match = bodyString.match(tlvIdentMatch)) &amp;&amp;</span><span class="s3">\n                                            </span><span class="s1">tlvIdentifierStyle[match[1]])) {</span><span class="s3">\n              </span><span class="s1">// This line begins scope.</span><span class="s3">\n              </span><span class="s1">// Next line gets indented one level.</span><span class="s3">\n              </span><span class="s1">indented += tlvIndentUnit;</span><span class="s3">\n              </span><span class="s1">// Style the next level of indentation (except non-region keyword identifiers,</span><span class="s3">\n              </span><span class="s1">//   which are statements themselves)</span><span class="s3">\n              </span><span class="s1">if (!(ch == </span><span class="s3">\&quot;\\\\\&quot; </span><span class="s1">&amp;&amp; chPos &gt; 0)) {</span><span class="s3">\n                </span><span class="s1">state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];</span><span class="s3">\n                </span><span class="s1">if (tlvTrackStatements) {state.statementComment = false;}</span><span class="s3">\n                </span><span class="s1">depth++;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Clear out deeper indentation levels unless line is blank.</span><span class="s3">\n          </span><span class="s1">if (!blankline) {</span><span class="s3">\n            </span><span class="s1">while (state.tlvIndentationStyle.length &gt; depth) {</span><span class="s3">\n              </span><span class="s1">state.tlvIndentationStyle.pop();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// Set next level of indentation.</span><span class="s3">\n        </span><span class="s1">state.tlvNextIndent = indented;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (state.tlvCodeActive) {</span><span class="s3">\n        </span><span class="s1">// Highlight as TLV.</span><span class="s3">\n\n        </span><span class="s1">var beginStatement = false;</span><span class="s3">\n        </span><span class="s1">if (tlvTrackStatements) {</span><span class="s3">\n          </span><span class="s1">// This starts a statement if the position is at the scope level</span><span class="s3">\n          </span><span class="s1">// and we're not within a statement leading comment.</span><span class="s3">\n          </span><span class="s1">beginStatement =</span><span class="s3">\n            </span><span class="s1">(stream.peek() != </span><span class="s3">\&quot; \&quot;</span><span class="s1">) &amp;&amp;   // not a space</span><span class="s3">\n            </span><span class="s1">(style === undefined) &amp;&amp;    // not a region identifier</span><span class="s3">\n            </span><span class="s1">!state.tlvInBlockComment &amp;&amp; // not in block comment</span><span class="s3">\n            </span><span class="s1">//!stream.match(tlvCommentMatch, false) &amp;&amp; // not comment start</span><span class="s3">\n          </span><span class="s1">(stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit);  // at scope level</span><span class="s3">\n          </span><span class="s1">if (beginStatement) {</span><span class="s3">\n            </span><span class="s1">if (state.statementComment) {</span><span class="s3">\n              </span><span class="s1">// statement already started by comment</span><span class="s3">\n              </span><span class="s1">beginStatement = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">state.statementComment =</span><span class="s3">\n              </span><span class="s1">stream.match(tlvCommentMatch, false); // comment start</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">var match;</span><span class="s3">\n        </span><span class="s1">if (style !== undefined) {</span><span class="s3">\n        </span><span class="s1">} else if (state.tlvInBlockComment) {</span><span class="s3">\n          </span><span class="s1">// In a block comment.</span><span class="s3">\n          </span><span class="s1">if (stream.match(/^.*?</span><span class="s3">\\</span><span class="s1">*</span><span class="s3">\\</span><span class="s1">//)) {</span><span class="s3">\n            </span><span class="s1">// Exit block comment.</span><span class="s3">\n            </span><span class="s1">state.tlvInBlockComment = false;</span><span class="s3">\n            </span><span class="s1">if (tlvTrackStatements &amp;&amp; !stream.eol()) {</span><span class="s3">\n              </span><span class="s1">// Anything after comment is assumed to be real statement content.</span><span class="s3">\n              </span><span class="s1">state.statementComment = false;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else if ((match = stream.match(tlvCommentMatch)) &amp;&amp; !state.tlvInBlockComment) {</span><span class="s3">\n          </span><span class="s1">// Start comment.</span><span class="s3">\n          </span><span class="s1">if (match[0] == </span><span class="s3">\&quot;</span><span class="s1">//</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">// Line comment.</span><span class="s3">\n            </span><span class="s1">stream.skipToEnd();</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// Block comment.</span><span class="s3">\n            </span><span class="s1">state.tlvInBlockComment = true;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">comment</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else if (match = stream.match(tlvIdentMatch)) {</span><span class="s3">\n          </span><span class="s1">// looks like an identifier (or identifier prefix)</span><span class="s3">\n          </span><span class="s1">var prefix = match[1];</span><span class="s3">\n          </span><span class="s1">var mnemonic = match[2];</span><span class="s3">\n          </span><span class="s1">if (// is identifier prefix</span><span class="s3">\n            </span><span class="s1">tlvIdentifierStyle.hasOwnProperty(prefix) &amp;&amp;</span><span class="s3">\n              </span><span class="s1">// has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)</span><span class="s3">\n            </span><span class="s1">(mnemonic.length &gt; 0 || stream.eol())) {</span><span class="s3">\n            </span><span class="s1">style = tlvIdentifierStyle[prefix];</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">// Just swallow one character and try again.</span><span class="s3">\n            </span><span class="s1">// This enables subsequent identifier match with preceding symbol character, which</span><span class="s3">\n            </span><span class="s1">//   is legal within a statement.  (Eg, !$reset).  It also enables detection of</span><span class="s3">\n            </span><span class="s1">//   comment start with preceding symbols.</span><span class="s3">\n            </span><span class="s1">stream.backUp(stream.current().length - 1);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(/^</span><span class="s3">\\</span><span class="s1">t+/)) {</span><span class="s3">\n          </span><span class="s1">// Highlight tabs, which are illegal.</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">invalid</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(/^[</span><span class="s3">\\</span><span class="s1">[</span><span class="s3">\\</span><span class="s1">]{}</span><span class="s3">\\</span><span class="s1">(</span><span class="s3">\\</span><span class="s1">);</span><span class="s3">\\</span><span class="s1">:]+/)) {</span><span class="s3">\n          </span><span class="s1">// [:], (), {}, ;.</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">meta</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else if (match = stream.match(/^[mM]4([</span><span class="s3">\\</span><span class="s1">+_])?[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">d_]*/)) {</span><span class="s3">\n          </span><span class="s1">// m4 pre proc</span><span class="s3">\n          </span><span class="s1">style = (match[1] == </span><span class="s3">\&quot;</span><span class="s1">+</span><span class="s3">\&quot;</span><span class="s1">) ? </span><span class="s3">\&quot;</span><span class="s1">keyword.special</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(/^ +/)){</span><span class="s3">\n          </span><span class="s1">// Skip over spaces.</span><span class="s3">\n          </span><span class="s1">if (stream.eol()) {</span><span class="s3">\n            </span><span class="s1">// Trailing spaces.</span><span class="s3">\n            </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">error</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else if (stream.match(/^[</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">d_]+/)) {</span><span class="s3">\n          </span><span class="s1">// alpha-numeric token.</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// Eat the next char w/ no formatting.</span><span class="s3">\n          </span><span class="s1">stream.next();</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (stream.match(/^[mM]4([</span><span class="s3">\\</span><span class="s1">w</span><span class="s3">\\</span><span class="s1">d_]*)/)) {</span><span class="s3">\n          </span><span class="s1">// m4 pre proc</span><span class="s3">\n          </span><span class="s1">style = </span><span class="s3">\&quot;</span><span class="s1">keyword</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return style;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">indent: function(state) {</span><span class="s3">\n      </span><span class="s1">return (state.tlvCodeActive == true) ? state.tlvNextIndent : -1;</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n\n    </span><span class="s1">startState: function(state) {</span><span class="s3">\n      </span><span class="s1">state.tlvIndentationStyle = [];  // Styles to use for each level of indentation.</span><span class="s3">\n      </span><span class="s1">state.tlvCodeActive = true;  // True when we're in a TLV region (and at beginning of file).</span><span class="s3">\n      </span><span class="s1">state.tlvNextIndent = -1;    // The number of spaces to autoindent the next line if tlvCodeActive.</span><span class="s3">\n      </span><span class="s1">state.tlvInBlockComment = false;  // True inside /**/ comment.</span><span class="s3">\n      </span><span class="s1">if (tlvTrackStatements) {</span><span class="s3">\n        </span><span class="s1">state.statementComment = false;  // True inside a statement's header comment.</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>