<html>
<head>
<title>2425.6472013fa9798ece0dc9.js.map</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #bcbec4;}
.s1 { color: #6aab73;}
.s2 { color: #2aacb8;}
.s3 { color: #cf8e6d;}
.ln { color: #4b5059; font-weight: normal; font-style: normal; }
</style>
</head>
<body bgcolor="#1e1f22">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
2425.6472013fa9798ece0dc9.js.map</font>
</center></td></tr></table>
<pre><a name="l1"><span class="ln">1    </span></a><span class="s0">{</span><span class="s1">&quot;version&quot;</span><span class="s0">:</span><span class="s2">3</span><span class="s0">,</span><span class="s1">&quot;file&quot;</span><span class="s0">:</span><span class="s1">&quot;2425.6472013fa9798ece0dc9.js?v=6472013fa9798ece0dc9&quot;</span><span class="s0">,</span><span class="s1">&quot;mappings&quot;</span><span class="s0">:</span><span class="s1">&quot;;;;;;AAAA;AACA,IAAI,IAAyD;AAC7D,2BAA2B,mBAAO,CAAC,KAAW;AAC9C,MAAM,EAK+C;AACrD,CAAC;AACD,yBAAyB;AACzB;AACA;;AAEA;AACA;;;;AAIA;;AAEA;AACA,qFAAqF,aAAa;AAClG;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,mCAAmC,iCAAiC,eAAe,eAAe,gBAAgB,oBAAoB,MAAM,0CAA0C,+BAA+B,aAAa,qBAAqB,uCAAuC,cAAc,WAAW,YAAY,UAAU,MAAM,2CAA2C,UAAU,sBAAsB,eAAe,2BAA2B,0BAA0B,cAAc,2CAA2C,gCAAgC,OAAO,mFAAmF;;AAErpB;AACA;AACA;;AAEA,iBAAiB,+BAAmB;;AAEpC;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,gEAAgE;AACpJ;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D;AACA;AACA;;AAEA,UAAU,gCAAmB;AAC7B,iBAAiB,gCAAmB;AACpC,eAAe,gCAAmB;AAClC,aAAa,gCAAmB;AAChC,iBAAiB,gCAAmB;AACpC,sBAAsB,gCAAmB;AACzC,wBAAwB,gCAAmB;AAC3C,oBAAoB,gCAAmB;;AAEvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,kEAAkE;AACtH,qDAAqD,kEAAkE;AACvH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kIAAkI;AAClI,4GAA4G;AAC5G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iFAAiF;AACjF;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,mBAAmB;;AAEnB,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA;AACA;;AAEA,aAAa,gCAAmB;AAChC,UAAU,gCAAmB;;AAE7B,eAAe,gCAAmB;AAClC;;AAEA,gBAAgB,gCAAmB;AACnC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,OAAO,yBAAyB,eAAe,GAAG,IAAI;AACtD;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO,kCAAkC,GAAG,iCAAiC;AAC7E;;AAEA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B,CAAC;;AAED;AACA;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,8EAA8E;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF;AAChF,YAAY;AACZ,oFAAoF;AACpF;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,8EAA8E;AAClH,WAAW;;AAEX;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA,eAAe;AACf;AACA;AACA,wCAAwC,kFAAkF;AAC1H;AACA;AACA,4DAA4D,QAAQ;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0FAA0F;AAC1F,aAAa;AACb,YAAY;AACZ;AACA,8FAA8F;AAC9F,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,2MAA2M;AACvP,sBAAsB;AACtB;AACA,4CAA4C,oGAAoG;AAChJ;AACA,oBAAoB;AACpB;AACA,4CAA4C,uLAAuL;AACnO;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,4CAA4C,gGAAgG;AAC5I,sBAAsB;AACtB;AACA,8CAA8C,gNAAgN;AAC9P;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,eAAe;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,WAAW;AACX,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D;AACA;AACA;;AAEA,UAAU,gCAAmB;AAC7B,aAAa,gCAAmB;AAChC,UAAU,gCAAmB;;AAE7B;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B,+BAA+B;AAC/B,kCAAkC;AAClC,iCAAiC;AACjC;AACA;;AAEA,0BAA0B;AAC1B;AACA,cAAc;AACd,gBAAgB;AAChB,gBAAgB;;AAEhB,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA,2CAA2C;AAC3C;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;;AAEA,sBAAsB;AACtB;;AAEA,oBAAoB,cAAc;AAClC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA,MAAM;AACN;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA,wBAAwB,kBAAkB;AAC1C;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,gBAAgB;AACtC,sBAAsB,gBAAgB;AACtC;AACA;AACA;;AAEA;AACA,sBAAsB,kBAAkB;AACxC;AACA;;AAEA,sBAAsB,kBAAkB;AACxC,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,oBAAoB,gBAAgB;AACpC;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,cAAc;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,wBAAwB,gBAAgB;AACxC;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB,iBAAiB;AAC1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAsE,gEAAgE;AACtI;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,yBAAyB;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;;AAEH;AACA;AACA;;AAEA,iFAAiF;;AAEjF;AACA;AACA,gGAAgG;AAChG;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,oFAAoF;;AAEpF;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,wEAAwE,mEAAmE;AAC3I;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP,yBAAyB;AACzB;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;AACvB;AACA;AACA;;AAEA,mBAAmB;;AAEnB,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D,WAAW,gCAAmB;;AAE9B;AACA;AACA;AACA;AACA,IAAI;;AAEJ,sCAAsC;AACtC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA;;AAEA;;AAEA,OAAO;;AAEP,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,mBAAmB,gCAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gCAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAAmB,GAAG,gCAAmB;AACvD;AACA,iBAAiB,0BAAmB;AACpC,UAAU;AACV;AACA,CAAC;;;;;;;AC5gDD;AACA,IAAI,IAAyD;AAC7D,2BAA2B,mBAAO,CAAC,KAAa;AAChD,MAAM,EAK2C;AACjD,CAAC;AACD,yBAAyB;AACzB;AACA;;AAEA;AACA,0CAA0C,8BAAmB;;;;AAI7D;;AAEA,sBAAsB,8BAAmB;AACzC,yBAAyB,8BAAmB;AAC5C,oBAAoB,8BAAmB;AACvC,qBAAqB,8BAAmB;AACxC,4BAA4B,8BAAmB;AAC/C,sBAAsB,8BAAmB;AACzC,oBAAoB,8BAAmB;AACvC,6BAA6B,8BAAmB;;AAEhD;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,wBAAwB,+BAAmB;;AAE3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,mBAAmB,+BAAmB;;AAEtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,aAAa,+BAAmB;;AAEhC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,oBAAoB,+BAAmB;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,+BAAmB;;;;AAI7D,eAAe,+BAAmB;AAClC,uBAAuB,+BAAmB;AAC1C,gBAAgB,+BAAmB;AACnC,eAAe,+BAAmB;AAClC,eAAe,+BAAmB;AAClC,oBAAoB,+BAAmB;AACvC,wBAAwB,+BAAmB;AAC3C,wBAAwB,+BAAmB;AAC3C,sBAAsB,+BAAmB;AACzC,YAAY,+BAAmB;AAC/B,aAAa,+BAAmB;AAChC,iBAAiB,+BAAmB;AACpC,aAAa,+BAAmB;AAChC,cAAc,+BAAmB;AACjC,gBAAgB,+BAAmB;AACnC,aAAa,+BAAmB;AAChC,gBAAgB,+BAAmB;AACnC,iBAAiB,+BAAmB;;AAEpC;AACA;;AAEA,uBAAuB;AACvB,yBAAyB;AACzB;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,0HAA0H;AAC1H,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mKAAmK;AACnK;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,wBAAwB,8BAA8B;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,wBAAwB,gCAAgC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;;AAEA;AACA;AACA,mCAAmC,2BAA2B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA,4EAA4E,yCAAyC;AACrH,6EAA6E,uCAAuC;AACpH,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,yEAAyE,2CAA2C;AACpH,4EAA4E,qCAAqC;AACjH;AACA,OAAO;AACP,MAAM;AACN,4CAA4C;AAC5C,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,SAAS;;AAET,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qCAAqC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,oCAAoC;AAC1D;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,uCAAuC;AAC/D;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,sBAAsB,wCAAwC;AAC9D;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,sCAAsC;AAC5D;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,0BAA0B,sBAAsB;AAChD;AACA;AACA;AACA,eAAe;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,UAAU;AACxB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA,2BAA2B,2BAA2B;AACtD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B,2BAA2B;;AAE3B,uBAAuB;AACvB;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uBAAuB;AACzC,8BAA8B;AAC9B,oCAAoC;;AAEpC;;AAEA,kEAAkE;AAClE;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD,mEAAmE;;AAEnE,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAsB,mCAAmC;AACzD;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,+BAA+B;;AAEjD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;;AAE/C;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA,kBAAkB,qBAAqB;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;;AAEA,oBAAoB,gBAAgB;AACpC;;AAEA,wBAAwB;AACxB,wBAAwB;;AAExB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,8BAA8B;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kCAAkC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,8BAA8B;AAChD;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA,+BAA+B,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D,mBAAmB,gCAAmB;AACtC,YAAY,gCAAmB;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA,0CAA0C,gCAAmB;;;;AAI7D,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,oBAAoB,eAAe,OAAO;;AAExK,oBAAoB,gCAAmB;AACvC,iBAAiB,gCAAmB;AACpC,aAAa,gCAAmB;AAChC,UAAU,gCAAmB;;AAE7B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,gEAAgE;AAC7H;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL,iCAAiC;AACjC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oEAAoE,mEAAmE;AACvI;;AAEA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,cAAc;AACd;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAsE,mEAAmE;AACzI;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,sEAAsE,mEAAmE;AACzI;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;;AAEL;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;AACA,MAAM;AACN,wBAAwB,wBAAwB;AAChD;AACA;AACA,MAAM;AACN,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,2CAA2C,2DAA2D;AACtG,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA,yCAAyC,2DAA2D;AACpG,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,sCAAsC;AACtC,8BAA8B;AAC9B;AACA,uBAAuB;AACvB,iCAAiC;AACjC,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oEAAoE;AAC9G,UAAU;AACV,sCAAsC,oEAAoE;AAC1G;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,yCAAyC,mEAAmE;AAC5G,UAAU;AACV,qCAAqC,mEAAmE;AACxG;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,2GAA2G;;AAE3G;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,4BAA4B,4BAA4B;AACxD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA,2GAA2G;;AAE3G;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA,4BAA4B,8BAA8B;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA,wBAAwB,yBAAyB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mDAAmD,kCAAkC;AACrF,cAAc;AACd;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,mDAAmD,kCAAkC;AACrF;AACA,WAAW;AACX,SAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kEAAkE;AAClE,kEAAkE;;AAElE;AACA,wBAAwB,oCAAoC;AAC5D;AACA;AACA;;AAEA;AACA,uGAAuG;AACvG,2CAA2C;AAC3C,yFAAyF;;AAEzF;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,gCAAgC;AAChC;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,yGAAyG;;AAEzG;AACA;AACA,WAAW;AACX;;AAEA,0BAA0B,qBAAqB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,WAAW;AACX;AACA,yGAAyG;;AAEzG;AACA;AACA,WAAW;AACX;;AAEA,2BAA2B,sBAAsB;AACjD;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA,+BAA+B,iCAAiC;AAChE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA,+BAA+B,mCAAmC;AAClE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,+BAA+B;AAC/B,gBAAgB;AAChB;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;;AAEA;AACA,uEAAuE,mEAAmE;AAC1I;;AAEA;AACA;;AAEA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yFAAyF,mEAAmE;AAC5J;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uFAAuF,mEAAmE;AAC1J;;AAEA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;;AAEP;AACA;;AAEA;;AAEA,OAAO;;AAEP,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,mBAAmB,iCAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,iCAAmB;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,0BAAmB,GAAG,iCAAmB;AACvD;AACA,iBAAiB,0BAAmB;AACpC,UAAU;AACV;AACA,CAAC;;;;;;;AC7oGD;AACA,IAAI,IAAyD;AAC7D;AACA,MAAM,EAK2B;AACjC,CAAC;AACD,qCAAqC;AACrC;AACA;AACA;AACA;AACA,mBAAmB,8BAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,8BAAmB;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,UAAU,8BAAmB,uBAAuB;AACpD;AACA;AACA,UAAU,8BAAmB;AAC7B,eAAe,8BAAmB;AAClC;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA,oCAAoC,4BAA4B;AAChE,0CAA0C;AAC1C,WAAW,8BAAmB;AAC9B;AACA;AACA;AACA;AACA,UAAU,8BAAmB,kCAAkC;AAC/D;AACA;AACA,UAAU,8BAAmB;AAC7B;AACA;AACA,iBAAiB,8BAAmB,CAAC,8BAAmB;AACxD,UAAU;AACV;AACA;AACA;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;AACtC,gBAAgB,+BAAmB;AACnC,YAAY,+BAAmB;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,+BAAmB;;AAEpD;;;AAGA,mBAAmB,+BAAmB;AACtC,cAAc,+BAAmB;AACjC,iBAAiB,+BAAmB;AACpC,sBAAsB,+BAAmB;AACzC,iBAAiB,+BAAmB;AACpC,aAAa,+BAAmB;;AAEhC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qGAAqG;AACrG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA,oBAAoB,kBAAkB;AACtC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,sBAAsB,gCAAmB;;AAEzC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mBAAmB,gCAAmB;AACtC,cAAc,gCAAmB;AACjC,sBAAsB,gCAAmB;AACzC,oBAAoB,gCAAmB;AACvC,YAAY,gCAAmB;AAC/B,YAAY,gCAAmB;AAC/B,iBAAiB,gCAAmB;AACpC,YAAY,gCAAmB;AAC/B,iBAAiB,gCAAmB;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,OAAO;AACzB;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA;AACA,YAAY,gCAAmB;;AAE/B;AACA,WAAW,gCAAmB,KAAK;AACnC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA,IAAI;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,OAAO;AACzB;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY,gCAAmB;;AAE/B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA,0BAA0B,KAAK;;AAE/B;AACA;AACA,0BAA0B,KAAK;;AAE/B;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ,oCAAoC;AACpC,IAAI;AACJ,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,qGAAqG,qBAAqB,mBAAmB;;AAE7I;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,oBAAoB,eAAe,OAAO;;AAExK,sBAAsB,gCAAmB;AACzC,oBAAoB,gCAAmB;AACvC,YAAY,gCAAmB;AAC/B,YAAY,gCAAmB;AAC/B,aAAa,gCAAmB;AAChC,aAAa,gCAAmB;AAChC,gBAAgB,gCAAmB;AACnC,cAAc,gCAAmB;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,sBAAsB,kBAAkB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,sBAAsB,kBAAkB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA,oBAAoB,kBAAkB;AACtC;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,sBAAsB,0BAA0B;AAChD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;;AAEA;AACA;;AAEA,sBAAsB,iBAAiB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,aAAa,gCAAmB;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,gCAAmB;;AAEpD;;;AAGA,mCAAmC,0BAA0B,0CAA0C,gBAAgB,OAAO,oBAAoB,eAAe,OAAO;;AAExK,aAAa,gCAAmB;AAChC,wBAAwB,gCAAmB;AAC3C,sBAAsB,gCAAmB;AACzC,gBAAgB,gCAAmB;AACnC,YAAY,gCAAmB;;AAE/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA,IAAI;AACJ,gBAAgB,mBAAmB;AACnC;;AAEA,sBAAsB,mBAAmB;AACzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA,kBAAkB,WAAW;AAC7B;AACA;;AAEA,kBAAkB,WAAW;AAC7B,oBAAoB,WAAW;AAC/B;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uBAAuB,cAAc;AACrC,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,cAAc,mBAAmB;AACjC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,uBAAuB;AAC1D,qCAAqC,uBAAuB;AAC5D;AACA,0BAA0B,uBAAuB;AACjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,8BAA8B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,YAAY,iCAAmB;AAC/B,wBAAwB,iCAAmB;;AAE3C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,YAAY,iCAAmB;AAC/B,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,wBAAwB,iCAAmB;;AAE3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,OAAO;AACzB;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA,oBAAoB,sBAAsB;AAC1C;AACA,sBAAsB,sBAAsB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,qBAAqB;AACvC;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,mBAAmB;AACrC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB,kBAAkB;AACpC;AACA;;AAEA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,iCAAmB;;AAEpC;AACA;AACA;;AAEA;;AAEA;AACA,uDAAuD;;AAEvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA,iFAAiF;AACjF;AACA,KAAK;AACL;AACA;AACA,iFAAiF;AACjF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mDAAmD;;AAEnD;AACA,8CAA8C;;AAE9C;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C,sEAAsE;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc,OAAO;;AAErB;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA,OAAO;AACP;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8BAA8B,cAAc;AAC5C;AACA;AACA;AACA,6BAA6B,aAAa;AAC1C,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA,8BAA8B,cAAc;AAC5C;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA,2BAA2B,SAAS;AACpC;AACA,+BAA+B,UAAU;AACzC;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA,8BAA8B,eAAe;AAC7C;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA,2BAA2B,eAAe;AAC1C;AACA;AACA,QAAQ;AACR,2BAA2B,eAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU;AACzC;AACA;AACA,OAAO;AACP,gCAAgC,UAAU;AAC1C;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA,mCAAmC,eAAe;AAClD;AACA;AACA;AACA;AACA,yBAAyB,eAAe;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA,iCAAiC,2CAA2C,gBAAgB,kBAAkB,OAAO,2BAA2B,wDAAwD,gCAAgC,uDAAuD,+DAA+D,yDAAyD,qEAAqE,6DAA6D,wBAAwB;;AAEjjB,kDAAkD,0CAA0C;;AAE5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,wBAAwB,eAAe;AACvC;;AAEA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA;AACA,yBAAyB,gBAAgB;AACzC;;AAEA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;;AAEA;AACA,8BAA8B,iBAAiB;AAC/C,kCAAkC,iBAAiB;AACnD;AACA;AACA,mIAAmI;;AAEnI;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;AACA;AACA,+CAA+C;AAC/C;AACA;AACA,qBAAqB;AACrB;;AAEA,yFAAyF;AACzF;AACA,iBAAiB;;AAEjB;AACA;;AAEA;AACA;;AAEA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,CAAC;;AAED;;AAEA,OAAO;AACP;AACA,iCAAiC,iCAAmB;;AAEpD;;;AAGA;AACA;AACA;;AAEA,sBAAsB,iCAAmB;AACzC,+BAA+B,iCAAmB;AAClD,0BAA0B,iCAAmB;AAC7C,0BAA0B,iCAAmB;AAC7C,wBAAwB,iCAAmB;AAC3C,qBAAqB,iCAAmB;AACxC,qBAAqB,iCAAmB;AACxC,uBAAuB,iCAAmB;AAC1C,mBAAmB,iCAAmB;AACtC,qBAAqB,iCAAmB;AACxC,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,wBAAwB,iCAAmB;AAC3C,wBAAwB,iCAAmB;AAC3C,uBAAuB,iCAAmB;AAC1C,+BAA+B,iCAAmB;AAClD,uBAAuB,iCAAmB;AAC1C,wBAAwB,iCAAmB;AAC3C,0BAA0B,iCAAmB;AAC7C,oBAAoB,iCAAmB;AACvC,mBAAmB,iCAAmB;AACtC,2BAA2B,iCAAmB;AAC9C,mBAAmB,iCAAmB;AACtC,oBAAoB,iCAAmB;AACvC,6BAA6B,iCAAmB;AAChD,6BAA6B,iCAAmB;AAChD,oBAAoB,iCAAmB;AACvC,iBAAiB,iCAAmB;;AAEpC;;AAEA,OAAO;AACP;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,sCAAsC,QAAQ;AAC9C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,2BAA2B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO;AACP;AACA,CAAC;;;;;;;;;;;;;;;;;;;;;;;ACzmK6B;AAGA;AAGA;AAGA;AACA;AAGA;AAcA;;AAE9B;AAC2C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAM,eAAe,MAAM,GAAG,WAAW,IAAI,OAAO;AACzE,qBAAqB,qEAAM,iBAAiB,WAAW,EAAE,MAAM,KAAK,MAAM,GAAG,MAAM;AACnF,qBAAqB,qEAAM,mBAAmB,MAAM,KAAK,UAAU,GAAG,MAAM;AAC5E,qBAAqB,qEAAM,eAAe,UAAU,KAAK,MAAM,GAAG,OAAO,IAAI,MAAM;AACnF;AACA;AACA,qBAAqB,qEAAM;AAC3B,qBAAqB,qEAAM;AAC3B,qBAAqB,qEAAM;AAC3B,qBAAqB,qEAAM;AAC3B;AACA,uDAAuD,qEAAM;AAC7D;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD,8CAA8C,qEAAM;AACpD;AACA;AACA,CAAC;AACD,+CAA+C,qEAAM;AACrD;AACA;AACA,CAAC;AACD,+CAA+C,qEAAM;AACrD;AACA;AACA,CAAC;AACD,gDAAgD,qEAAM;AACtD;AACA;AACA;AACA,CAAC;AACD,2CAA2C,qEAAM;AACjD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,uDAAuD,qEAAM;AAC7D;AACA,CAAC;AACD,mDAAmD,qEAAM;AACzD,kBAAkB,UAAU,EAAE,UAAU;AACxC;AACA,CAAC;AACD,+DAA+D,qEAAM;AACrE;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,CAAC;AACD,wDAAwD,qEAAM;AAC9D;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,CAAC;AACD,wDAAwD,qEAAM;AAC9D;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD,4CAA4C,qEAAM;AAClD;AACA;AACA,CAAC;AACD,6CAA6C,qEAAM;AACnD;AACA;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC;AACA,CAAC;;AAED;AACA,kCAAkC,gFAAqB;AACvD,gBAAgB,yEAAe;AAC/B,WAAW;AACX,YAAY;AACZ;AACA,mBAAmB;AACnB;AACA;AACA;AACA,CAAC;AACD,6BAA6B,qEAAM;AACnC;AACA,EAAE,oEAAK;AACP,CAAC;AACD,iCAAiC,qEAAM;AACvC;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,yBAAyB,GAAG,iCAAiC,gCAAgC;AAC7F;AACA;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA,wBAAwB,GAAG;AAC3B;AACA;AACA;AACA,sCAAsC,GAAG;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kCAAkC,qEAAM;AACxC,kCAAkC,qEAAM,YAAY,gBAAgB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,mCAAmC,qEAAM;AACzC,+BAA+B,qEAAM;AACrC,8BAA8B,qEAAM;AACpC,+BAA+B,qEAAM,YAAY,6BAA6B;AAC9E;AACA;AACA,uBAAuB,GAAG,iCAAiC,gCAAgC;AAC3F;AACA;AACA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA;AACA;AACA,sBAAsB,GAAG;AACzB;AACA;AACA;AACA,oCAAoC,GAAG;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,gCAAgC,qEAAM;AACtC;AACA,CAAC;AACD,8BAA8B,qEAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,4DAA4D,MAAM,IAAI,MAAM,2BAA2B,OAAO;AAC9G;AACA;AACA;AACA;AACA,6DAA6D,MAAM,IAAI,MAAM,2BAA2B,OAAO;AAC/G;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,MAAM;AACjC;AACA;AACA;AACA;AACA,4BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,+BAA+B,qEAAM;AACrC,wCAAwC,qEAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA,KAAK,IAAI;AACT;AACA,sBAAsB;AACtB;AACA,8CAA8C,kBAAkB;AAChE;AACA;AACA,gCAAgC,qEAAM;AACtC,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,sCAAsC,qEAAM;AAC5C;AACA,CAAC;AACD,qCAAqC,qEAAM;AAC3C;AACA;AACA,iBAAiB;AACjB,iBAAiB;AACjB,aAAa;AACb,aAAa;AACb,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAS;AACxB;AACA;AACA;AACA;AACA;AACA,qEAAM;;AAEN;AACA,iCAAiC,qEAAM;AACvC,EAAE,8EAAgB;AAClB;AACA,iDAAiD,6BAA6B;AAC9E,mDAAmD,8BAA8B;AACjF;AACA,CAAC;AACD;AACA,yBAAyB,qEAAM;AAC/B,sBAAsB,mEAAK;AAC3B,IAAI,8DAAG;AACP;AACA,GAAG;AACH;;AAEA;AACA,gCAAgC,qEAAM;AACtC;AACA,oBAAoB;AACpB,cAAc;AACd;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,cAAc;AACd,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACkC;AACE;AACR;;AAE5B;AACA,+BAA+B,qEAAM;AACrC,gEAAgE,kBAAkB,KAAK,KAAK;AAC5F,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6GAA6G,cAAc,uBAAuB,kBAAkB,uGAAuG,cAAc,uBAAuB,kBAAkB,uGAAuG,cAAc,uBAAuB,kBAAkB,yFAAyF,cAAc,uBAAuB,kBAAkB,kEAAkE,cAAc,uBAAuB,kBAAkB,kEAAkE,cAAc,uBAAuB,kBAAkB;AACl2B;AACA,KAAK;AACL;AACA;AACA,yFAAyF,cAAc,uBAAuB,kBAAkB,oEAAoE,cAAc,uBAAuB,kBAAkB,oEAAoE,cAAc,uBAAuB,kBAAkB,yHAAyH,kBAAkB,sHAAsH,cAAc,sBAAsB,6HAA6H,kBAAkB,sHAAsH,cAAc,sBAAsB,6HAA6H,kBAAkB,sHAAsH,cAAc,sBAAsB,+DAA+D,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB,+DAA+D,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB,+DAA+D,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB,wDAAwD,cAAc,sBAAsB;AAC9kE;AACA,KAAK;AACL;AACA;AACA,qFAAqF,cAAc,uBAAuB,kBAAkB,mEAAmE,cAAc,uBAAuB,kBAAkB,mEAAmE,cAAc,uBAAuB,kBAAkB,mEAAmE,cAAc,uBAAuB,kBAAkB,mEAAmE,cAAc,uBAAuB,kBAAkB,qEAAqE,cAAc,uBAAuB,kBAAkB,mEAAmE,cAAc,uBAAuB,kBAAkB,8JAA8J,kBAAkB;AAC1hC;AACA,KAAK;AACL;AACA;AACA,6DAA6D,cAAc,uBAAuB,kBAAkB,gEAAgE,cAAc,uBAAuB,kBAAkB,gEAAgE,cAAc,uBAAuB,kBAAkB,6EAA6E,cAAc,uBAAuB,kBAAkB,4EAA4E,cAAc,uBAAuB,kBAAkB,sEAAsE,cAAc,uBAAuB,kBAAkB,sEAAsE,cAAc,uBAAuB,kBAAkB;AACn2B;AACA,KAAK;AACL;AACA;AACA,yVAAyV,cAAc,uBAAuB,kBAAkB;AAChZ;AACA,KAAK;AACL,aAAa,sEAAW;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC,qEAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,YAAY,uBAAuB;AACnC,cAAc,mBAAmB;AACjC,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,GAAG,QAAQ,IAAI,KAAK,GAAG,MAAM,GAAG,KAAK,GAAG,MAAM;AAC7F;AACA;AACA;AACA,8HAA8H,OAAO,GAAG,OAAO;AAC/I;AACA;AACA;AACA;AACA,8HAA8H,OAAO,GAAG,OAAO;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA,gBAAgB,yEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,yEAAS;AACrB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,qFAAqF,gBAAgB;AACrG;AACA;AACA;AACA;AACA,4BAA4B,KAAK,IAAI,2BAA2B;AAChE,4BAA4B,sBAAsB,IAAI,uBAAuB;AAC7E,yBAAyB,gBAAgB,OAAO,oBAAoB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,iCAAiC,qEAAM;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,MAAM,yEAAU,cAAc,uFAAuF,EAAE;AACzI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,yEAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY,yEAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD,mCAAmC,qEAAM;AACzC;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ,yEAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM,yEAAU,iBAAiB,6EAA6E,EAAE;AAC9H;AACA,MAAM;AACN;AACA,cAAc,MAAM,yEAAU,YAAY,6EAA6E,EAAE;AACzH;AACA;AACA;AACA,gGAAgG,SAAS,GAAG;AAC5G;AACA;AACA;AACA,mDAAmD,uCAAuC;AAC1F,MAAM;AACN;AACA;AACA,cAAc,UAAU,GAAG,WAAW,cAAc,UAAU,YAAY,UAAU;AACpF;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,oCAAoC,qEAAM;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA,gFAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,0DAAS,KAAK,wDAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN;AACA;AACA,YAAY,4EAA4E;AACxF;AACA;AACA,aAAa,MAAM,GAAG,MAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN;AACA,4CAA4C,qEAAM;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C,8BAA8B,gBAAgB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,cAAc;AACd,8BAA8B,IAAI,GAAG,MAAM;AAC3C;AACA,8BAA8B,IAAI,GAAG,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAM;AACN;AACA;AACA,mCAAmC,qEAAM,aAAa,OAAO,GAAG,OAAO;AACvE,mCAAmC,qEAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA,WAAW;AACX;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,qEAAM;AACN,uEAAuE,8BAA8B;AACrG;AACA,qBAAqB,qDAAM;AAC3B,eAAe,8DAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,4BAA4B,2BAA2B;AACvD;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA;AACA,OAAO;AACP;AACA;AACA,gBAAgB,kBAAkB;AAClC,gBAAgB,kBAAkB;AAClC;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,qEAAM;AACZ;AACA;AACA;AACA,kBAAkB,eAAe;AACjC,kBAAkB,eAAe;AACjC;AACA;AACA;AACA,oBAAoB,YAAY;AAChC;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,MAAM,8DAAG;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA,qEAAM;AACN,2BAA2B,qEAAM;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,8EAAgB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gFAAiB;AACnB,CAAC;AACD,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AAGE;;;;;;;;;;;;;ACxmC4B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qEAAM;;AAIJ;;;;;;;;;;;;;AClB4B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAM;AACV;AACA;AACA;AACA;AACA;;AAIE&quot;</span><span class="s0">,</span><span class="s1">&quot;sources&quot;</span><span class="s0">:[</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cytoscape-fcose/cytoscape-fcose.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/cytoscape-fcose/node_modules/layout-base/layout-base.js&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-IEHRJDOE.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/chunk-4BMEZGHF.mjs&quot;</span><span class="s0">,</span><span class="s1">&quot;webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/mermaid/dist/chunks/mermaid.core/chunk-XZIHB7SX.mjs&quot;</span><span class="s0">],</span><span class="s1">&quot;sourcesContent&quot;</span><span class="s0">:[</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory(require(</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">cytoscapeFcose</span><span class="s3">\&quot;</span><span class="s1">] = factory(require(</span><span class="s3">\&quot;</span><span class="s1">cose-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">cytoscapeFcose</span><span class="s3">\&quot;</span><span class="s1">] = factory(root[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {</span><span class="s3">\n</span><span class="s1">return /******/ (() =&gt; { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_modules__ = ({</span><span class="s3">\n\n</span><span class="s1">/***/ 658:</span><span class="s3">\n</span><span class="s1">/***/ ((module) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">// Simple, internal Object.assign() polyfill for options objects etc.</span><span class="s3">\n\n</span><span class="s1">module.exports = Object.assign != null ? Object.assign.bind(Object) : function (tgt) {</span><span class="s3">\n  </span><span class="s1">for (var _len = arguments.length, srcs = Array(_len &gt; 1 ? _len - 1 : 0), _key = 1; _key &lt; _len; _key++) {</span><span class="s3">\n    </span><span class="s1">srcs[_key - 1] = arguments[_key];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">srcs.forEach(function (src) {</span><span class="s3">\n    </span><span class="s1">Object.keys(src).forEach(function (k) {</span><span class="s3">\n      </span><span class="s1">return tgt[k] = src[k];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return tgt;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 548:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i &amp;&amp; _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n &amp;&amp; _i[</span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">]) _i[</span><span class="s3">\&quot;</span><span class="s1">return</span><span class="s3">\&quot;</span><span class="s1">](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Invalid attempt to destructure non-iterable instance</span><span class="s3">\&quot;</span><span class="s1">); } }; }();</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Auxiliary functions</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var LinkedList = __webpack_require__(140).layoutBase.LinkedList;</span><span class="s3">\n\n</span><span class="s1">var auxiliary = {};</span><span class="s3">\n\n</span><span class="s1">// get the top most nodes</span><span class="s3">\n</span><span class="s1">auxiliary.getTopMostNodes = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var nodesMap = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodesMap[nodes[i].id()] = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var roots = nodes.filter(function (ele, i) {</span><span class="s3">\n    </span><span class="s1">if (typeof ele === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">ele = i;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var parent = ele.parent()[0];</span><span class="s3">\n    </span><span class="s1">while (parent != null) {</span><span class="s3">\n      </span><span class="s1">if (nodesMap[parent.id()]) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">parent = parent.parent()[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return roots;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// find disconnected components and create dummy nodes that connect them</span><span class="s3">\n</span><span class="s1">auxiliary.connectComponents = function (cy, eles, topMostNodes, dummyNodes) {</span><span class="s3">\n  </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var visitedTopMostNodes = [];</span><span class="s3">\n  </span><span class="s1">var currentNeighbor = void 0;</span><span class="s3">\n  </span><span class="s1">var minDegreeNode = void 0;</span><span class="s3">\n  </span><span class="s1">var minDegree = void 0;</span><span class="s3">\n\n  </span><span class="s1">var isConnected = false;</span><span class="s3">\n  </span><span class="s1">var count = 1;</span><span class="s3">\n  </span><span class="s1">var nodesConnectedToDummy = [];</span><span class="s3">\n  </span><span class="s1">var components = [];</span><span class="s3">\n\n  </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n    </span><span class="s1">var cmpt = cy.collection();</span><span class="s3">\n    </span><span class="s1">components.push(cmpt);</span><span class="s3">\n\n    </span><span class="s1">var currentNode = topMostNodes[0];</span><span class="s3">\n    </span><span class="s1">var childrenOfCurrentNode = cy.collection();</span><span class="s3">\n    </span><span class="s1">childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));</span><span class="s3">\n    </span><span class="s1">visitedTopMostNodes.push(currentNode);</span><span class="s3">\n\n    </span><span class="s1">childrenOfCurrentNode.forEach(function (node) {</span><span class="s3">\n      </span><span class="s1">queue.push(node);</span><span class="s3">\n      </span><span class="s1">visited.add(node);</span><span class="s3">\n      </span><span class="s1">cmpt.merge(node);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">var _loop2 = function _loop2() {</span><span class="s3">\n      </span><span class="s1">currentNode = queue.shift();</span><span class="s3">\n\n      </span><span class="s1">// Traverse all neighbors of this node</span><span class="s3">\n      </span><span class="s1">var neighborNodes = cy.collection();</span><span class="s3">\n      </span><span class="s1">currentNode.neighborhood().nodes().forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">if (eles.intersection(currentNode.edgesWith(node)).length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">neighborNodes.merge(node);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; neighborNodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">var neighborNode = neighborNodes[i];</span><span class="s3">\n        </span><span class="s1">currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));</span><span class="s3">\n        </span><span class="s1">if (currentNeighbor != null &amp;&amp; !visited.has(currentNeighbor[0])) {</span><span class="s3">\n          </span><span class="s1">var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());</span><span class="s3">\n\n          </span><span class="s1">childrenOfNeighbor.forEach(function (node) {</span><span class="s3">\n            </span><span class="s1">queue.push(node);</span><span class="s3">\n            </span><span class="s1">visited.add(node);</span><span class="s3">\n            </span><span class="s1">cmpt.merge(node);</span><span class="s3">\n            </span><span class="s1">if (topMostNodes.has(node)) {</span><span class="s3">\n              </span><span class="s1">visitedTopMostNodes.push(node);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">while (queue.length != 0) {</span><span class="s3">\n      </span><span class="s1">_loop2();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">cmpt.forEach(function (node) {</span><span class="s3">\n      </span><span class="s1">eles.intersection(node.connectedEdges()).forEach(function (e) {</span><span class="s3">\n        </span><span class="s1">// connectedEdges() usually cached</span><span class="s3">\n        </span><span class="s1">if (cmpt.has(e.source()) &amp;&amp; cmpt.has(e.target())) {</span><span class="s3">\n          </span><span class="s1">// has() is cheap</span><span class="s3">\n          </span><span class="s1">cmpt.merge(e);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (visitedTopMostNodes.length == topMostNodes.length) {</span><span class="s3">\n      </span><span class="s1">isConnected = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!isConnected || isConnected &amp;&amp; count &gt; 1) {</span><span class="s3">\n      </span><span class="s1">minDegreeNode = visitedTopMostNodes[0];</span><span class="s3">\n      </span><span class="s1">minDegree = minDegreeNode.connectedEdges().length;</span><span class="s3">\n      </span><span class="s1">visitedTopMostNodes.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">if (node.connectedEdges().length &lt; minDegree) {</span><span class="s3">\n          </span><span class="s1">minDegree = node.connectedEdges().length;</span><span class="s3">\n          </span><span class="s1">minDegreeNode = node;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">nodesConnectedToDummy.push(minDegreeNode.id());</span><span class="s3">\n      </span><span class="s1">// TO DO: Check efficiency of this part</span><span class="s3">\n      </span><span class="s1">var temp = cy.collection();</span><span class="s3">\n      </span><span class="s1">temp.merge(visitedTopMostNodes[0]);</span><span class="s3">\n      </span><span class="s1">visitedTopMostNodes.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">temp.merge(node);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">visitedTopMostNodes = [];</span><span class="s3">\n      </span><span class="s1">topMostNodes = topMostNodes.difference(temp);</span><span class="s3">\n      </span><span class="s1">count++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">_loop();</span><span class="s3">\n  </span><span class="s1">} while (!isConnected);</span><span class="s3">\n\n  </span><span class="s1">if (dummyNodes) {</span><span class="s3">\n    </span><span class="s1">if (nodesConnectedToDummy.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return components;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// relocates componentResult to originalCenter if there is no fixedNodeConstraint</span><span class="s3">\n</span><span class="s1">auxiliary.relocateComponent = function (originalCenter, componentResult, options) {</span><span class="s3">\n  </span><span class="s1">if (!options.fixedNodeConstraint) {</span><span class="s3">\n    </span><span class="s1">var minXCoord = Number.POSITIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">var maxXCoord = Number.NEGATIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">var minYCoord = Number.POSITIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">var maxYCoord = Number.NEGATIVE_INFINITY;</span><span class="s3">\n    </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">// calculate current bounding box</span><span class="s3">\n      </span><span class="s1">var _iteratorNormalCompletion = true;</span><span class="s3">\n      </span><span class="s1">var _didIteratorError = false;</span><span class="s3">\n      </span><span class="s1">var _iteratorError = undefined;</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {</span><span class="s3">\n          </span><span class="s1">var _ref = _step.value;</span><span class="s3">\n\n          </span><span class="s1">var _ref2 = _slicedToArray(_ref, 2);</span><span class="s3">\n\n          </span><span class="s1">var key = _ref2[0];</span><span class="s3">\n          </span><span class="s1">var value = _ref2[1];</span><span class="s3">\n\n          </span><span class="s1">var cyNode = options.cy.getElementById(key);</span><span class="s3">\n          </span><span class="s1">if (cyNode) {</span><span class="s3">\n            </span><span class="s1">var nodeBB = cyNode.boundingBox();</span><span class="s3">\n            </span><span class="s1">var leftX = componentResult.xCoords[value] - nodeBB.w / 2;</span><span class="s3">\n            </span><span class="s1">var rightX = componentResult.xCoords[value] + nodeBB.w / 2;</span><span class="s3">\n            </span><span class="s1">var topY = componentResult.yCoords[value] - nodeBB.h / 2;</span><span class="s3">\n            </span><span class="s1">var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;</span><span class="s3">\n\n            </span><span class="s1">if (leftX &lt; minXCoord) minXCoord = leftX;</span><span class="s3">\n            </span><span class="s1">if (rightX &gt; maxXCoord) maxXCoord = rightX;</span><span class="s3">\n            </span><span class="s1">if (topY &lt; minYCoord) minYCoord = topY;</span><span class="s3">\n            </span><span class="s1">if (bottomY &gt; maxYCoord) maxYCoord = bottomY;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">// find difference between current and original center</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_didIteratorError = true;</span><span class="s3">\n        </span><span class="s1">_iteratorError = err;</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {</span><span class="s3">\n            </span><span class="s1">_iterator.return();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">if (_didIteratorError) {</span><span class="s3">\n            </span><span class="s1">throw _iteratorError;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;</span><span class="s3">\n      </span><span class="s1">var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;</span><span class="s3">\n      </span><span class="s1">// move component to original center</span><span class="s3">\n      </span><span class="s1">componentResult.xCoords = componentResult.xCoords.map(function (x) {</span><span class="s3">\n        </span><span class="s1">return x + diffOnX;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">componentResult.yCoords = componentResult.yCoords.map(function (y) {</span><span class="s3">\n        </span><span class="s1">return y + diffOnY;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">// calculate current bounding box</span><span class="s3">\n      </span><span class="s1">Object.keys(componentResult).forEach(function (item) {</span><span class="s3">\n        </span><span class="s1">var node = componentResult[item];</span><span class="s3">\n        </span><span class="s1">var leftX = node.getRect().x;</span><span class="s3">\n        </span><span class="s1">var rightX = node.getRect().x + node.getRect().width;</span><span class="s3">\n        </span><span class="s1">var topY = node.getRect().y;</span><span class="s3">\n        </span><span class="s1">var bottomY = node.getRect().y + node.getRect().height;</span><span class="s3">\n\n        </span><span class="s1">if (leftX &lt; minXCoord) minXCoord = leftX;</span><span class="s3">\n        </span><span class="s1">if (rightX &gt; maxXCoord) maxXCoord = rightX;</span><span class="s3">\n        </span><span class="s1">if (topY &lt; minYCoord) minYCoord = topY;</span><span class="s3">\n        </span><span class="s1">if (bottomY &gt; maxYCoord) maxYCoord = bottomY;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">// find difference between current and original center</span><span class="s3">\n      </span><span class="s1">var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;</span><span class="s3">\n      </span><span class="s1">var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;</span><span class="s3">\n      </span><span class="s1">// move component to original center</span><span class="s3">\n      </span><span class="s1">Object.keys(componentResult).forEach(function (item) {</span><span class="s3">\n        </span><span class="s1">var node = componentResult[item];</span><span class="s3">\n        </span><span class="s1">node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">auxiliary.calcBoundingBox = function (parentNode, xCoords, yCoords, nodeIndexes) {</span><span class="s3">\n  </span><span class="s1">// calculate bounds</span><span class="s3">\n  </span><span class="s1">var left = Number.MAX_SAFE_INTEGER;</span><span class="s3">\n  </span><span class="s1">var right = Number.MIN_SAFE_INTEGER;</span><span class="s3">\n  </span><span class="s1">var top = Number.MAX_SAFE_INTEGER;</span><span class="s3">\n  </span><span class="s1">var bottom = Number.MIN_SAFE_INTEGER;</span><span class="s3">\n  </span><span class="s1">var nodeLeft = void 0;</span><span class="s3">\n  </span><span class="s1">var nodeRight = void 0;</span><span class="s3">\n  </span><span class="s1">var nodeTop = void 0;</span><span class="s3">\n  </span><span class="s1">var nodeBottom = void 0;</span><span class="s3">\n\n  </span><span class="s1">var nodes = parentNode.descendants().not(</span><span class="s3">\&quot;</span><span class="s1">:parent</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var node = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;</span><span class="s3">\n    </span><span class="s1">nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;</span><span class="s3">\n    </span><span class="s1">nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;</span><span class="s3">\n    </span><span class="s1">nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (right &lt; nodeRight) {</span><span class="s3">\n      </span><span class="s1">right = nodeRight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bottom &lt; nodeBottom) {</span><span class="s3">\n      </span><span class="s1">bottom = nodeBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var boundingBox = {};</span><span class="s3">\n  </span><span class="s1">boundingBox.topLeftX = left;</span><span class="s3">\n  </span><span class="s1">boundingBox.topLeftY = top;</span><span class="s3">\n  </span><span class="s1">boundingBox.width = right - left;</span><span class="s3">\n  </span><span class="s1">boundingBox.height = bottom - top;</span><span class="s3">\n  </span><span class="s1">return boundingBox;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// This function finds and returns parent nodes whose all children are hidden</span><span class="s3">\n</span><span class="s1">auxiliary.calcParentsWithoutChildren = function (cy, eles) {</span><span class="s3">\n  </span><span class="s1">var parentsWithoutChildren = cy.collection();</span><span class="s3">\n  </span><span class="s1">eles.nodes(':parent').forEach(function (parent) {</span><span class="s3">\n    </span><span class="s1">var check = false;</span><span class="s3">\n    </span><span class="s1">parent.children().forEach(function (child) {</span><span class="s3">\n      </span><span class="s1">if (child.css('display') != 'none') {</span><span class="s3">\n        </span><span class="s1">check = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">if (!check) {</span><span class="s3">\n      </span><span class="s1">parentsWithoutChildren.merge(parent);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return parentsWithoutChildren;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = auxiliary;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 816:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">/**</span><span class="s3">\n  </span><span class="s1">The implementation of the postprocessing part that applies CoSE layout over the spectral layout</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var aux = __webpack_require__(548);</span><span class="s3">\n</span><span class="s1">var CoSELayout = __webpack_require__(140).CoSELayout;</span><span class="s3">\n</span><span class="s1">var CoSENode = __webpack_require__(140).CoSENode;</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(140).layoutBase.PointD;</span><span class="s3">\n</span><span class="s1">var DimensionD = __webpack_require__(140).layoutBase.DimensionD;</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;</span><span class="s3">\n</span><span class="s1">var CoSEConstants = __webpack_require__(140).CoSEConstants;</span><span class="s3">\n\n</span><span class="s1">// main function that cose layout is processed</span><span class="s3">\n</span><span class="s1">var coseLayout = function coseLayout(options, spectralResult) {</span><span class="s3">\n\n  </span><span class="s1">var cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes();</span><span class="s3">\n  </span><span class="s1">var edges = eles.edges();</span><span class="s3">\n\n  </span><span class="s1">var nodeIndexes = void 0;</span><span class="s3">\n  </span><span class="s1">var xCoords = void 0;</span><span class="s3">\n  </span><span class="s1">var yCoords = void 0;</span><span class="s3">\n  </span><span class="s1">var idToLNode = {};</span><span class="s3">\n\n  </span><span class="s1">if (options.randomize) {</span><span class="s3">\n    </span><span class="s1">nodeIndexes = spectralResult[</span><span class="s3">\&quot;</span><span class="s1">nodeIndexes</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">xCoords = spectralResult[</span><span class="s3">\&quot;</span><span class="s1">xCoords</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">yCoords = spectralResult[</span><span class="s3">\&quot;</span><span class="s1">yCoords</span><span class="s3">\&quot;</span><span class="s1">];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var isFn = function isFn(fn) {</span><span class="s3">\n    </span><span class="s1">return typeof fn === 'function';</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">var optFn = function optFn(opt, ele) {</span><span class="s3">\n    </span><span class="s1">if (isFn(opt)) {</span><span class="s3">\n      </span><span class="s1">return opt(ele);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return opt;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/**** Postprocessing functions ****/</span><span class="s3">\n\n  </span><span class="s1">var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);</span><span class="s3">\n\n  </span><span class="s1">// transfer cytoscape nodes to cose nodes</span><span class="s3">\n  </span><span class="s1">var processChildrenList = function processChildrenList(parent, children, layout, options) {</span><span class="s3">\n    </span><span class="s1">var size = children.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; size; i++) {</span><span class="s3">\n      </span><span class="s1">var theChild = children[i];</span><span class="s3">\n      </span><span class="s1">var children_of_children = null;</span><span class="s3">\n      </span><span class="s1">if (theChild.intersection(parentsWithoutChildren).length == 0) {</span><span class="s3">\n        </span><span class="s1">children_of_children = theChild.children();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">var theNode = void 0;</span><span class="s3">\n\n      </span><span class="s1">var dimensions = theChild.layoutDimensions({</span><span class="s3">\n        </span><span class="s1">nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">if (theChild.outerWidth() != null &amp;&amp; theChild.outerHeight() != null) {</span><span class="s3">\n        </span><span class="s1">if (options.randomize) {</span><span class="s3">\n          </span><span class="s1">if (!theChild.isParent()) {</span><span class="s3">\n            </span><span class="s1">theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);</span><span class="s3">\n            </span><span class="s1">if (theChild.intersection(parentsWithoutChildren).length == 0) {</span><span class="s3">\n              </span><span class="s1">theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">// for the parentsWithoutChildren</span><span class="s3">\n              </span><span class="s1">theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">theNode = parent.add(new CoSENode(this.graphManager));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// Attach id to the layout node and repulsion value</span><span class="s3">\n      </span><span class="s1">theNode.id = theChild.data(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);</span><span class="s3">\n      </span><span class="s1">// Attach the paddings of cy node to layout node</span><span class="s3">\n      </span><span class="s1">theNode.paddingLeft = parseInt(theChild.css('padding'));</span><span class="s3">\n      </span><span class="s1">theNode.paddingTop = parseInt(theChild.css('padding'));</span><span class="s3">\n      </span><span class="s1">theNode.paddingRight = parseInt(theChild.css('padding'));</span><span class="s3">\n      </span><span class="s1">theNode.paddingBottom = parseInt(theChild.css('padding'));</span><span class="s3">\n\n      </span><span class="s1">//Attach the label properties to both compound and simple nodes if labels will be included in node dimensions</span><span class="s3">\n      </span><span class="s1">//These properties will be used while updating bounds of compounds during iterations or tiling</span><span class="s3">\n      </span><span class="s1">//and will be used for simple nodes while transferring final positions to cytoscape</span><span class="s3">\n      </span><span class="s1">if (options.nodeDimensionsIncludeLabels) {</span><span class="s3">\n        </span><span class="s1">theNode.labelWidth = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).w;</span><span class="s3">\n        </span><span class="s1">theNode.labelHeight = theChild.boundingBox({ includeLabels: true, includeNodes: false, includeOverlays: false }).h;</span><span class="s3">\n        </span><span class="s1">theNode.labelPosVertical = theChild.css(</span><span class="s3">\&quot;</span><span class="s1">text-valign</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">theNode.labelPosHorizontal = theChild.css(</span><span class="s3">\&quot;</span><span class="s1">text-halign</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// Map the layout node</span><span class="s3">\n      </span><span class="s1">idToLNode[theChild.data(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">)] = theNode;</span><span class="s3">\n\n      </span><span class="s1">if (isNaN(theNode.rect.x)) {</span><span class="s3">\n        </span><span class="s1">theNode.rect.x = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (isNaN(theNode.rect.y)) {</span><span class="s3">\n        </span><span class="s1">theNode.rect.y = 0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (children_of_children != null &amp;&amp; children_of_children.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">var theNewGraph = void 0;</span><span class="s3">\n        </span><span class="s1">theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);</span><span class="s3">\n        </span><span class="s1">processChildrenList(theNewGraph, children_of_children, layout, options);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// transfer cytoscape edges to cose edges</span><span class="s3">\n  </span><span class="s1">var processEdges = function processEdges(layout, gm, edges) {</span><span class="s3">\n    </span><span class="s1">var idealLengthTotal = 0;</span><span class="s3">\n    </span><span class="s1">var edgeCount = 0;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n      </span><span class="s1">var edge = edges[i];</span><span class="s3">\n      </span><span class="s1">var sourceNode = idToLNode[edge.data(</span><span class="s3">\&quot;</span><span class="s1">source</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n      </span><span class="s1">var targetNode = idToLNode[edge.data(</span><span class="s3">\&quot;</span><span class="s1">target</span><span class="s3">\&quot;</span><span class="s1">)];</span><span class="s3">\n      </span><span class="s1">if (sourceNode &amp;&amp; targetNode &amp;&amp; sourceNode !== targetNode &amp;&amp; sourceNode.getEdgesBetween(targetNode).length == 0) {</span><span class="s3">\n        </span><span class="s1">var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);</span><span class="s3">\n        </span><span class="s1">e1.id = edge.id();</span><span class="s3">\n        </span><span class="s1">e1.idealLength = optFn(options.idealEdgeLength, edge);</span><span class="s3">\n        </span><span class="s1">e1.edgeElasticity = optFn(options.edgeElasticity, edge);</span><span class="s3">\n        </span><span class="s1">idealLengthTotal += e1.idealLength;</span><span class="s3">\n        </span><span class="s1">edgeCount++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// we need to update the ideal edge length constant with the avg. ideal length value after processing edges</span><span class="s3">\n    </span><span class="s1">// in case there is no edge, use other options</span><span class="s3">\n    </span><span class="s1">if (options.idealEdgeLength != null) {</span><span class="s3">\n      </span><span class="s1">if (edgeCount &gt; 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;else if (!isFn(options.idealEdgeLength)) // in case there is no edge, but option gives a value to use</span><span class="s3">\n        </span><span class="s1">CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;else // in case there is no edge and we cannot get a value from option (because it's a function)</span><span class="s3">\n        </span><span class="s1">CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;</span><span class="s3">\n      </span><span class="s1">// we need to update these constant values based on the ideal edge length constant</span><span class="s3">\n      </span><span class="s1">CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;</span><span class="s3">\n      </span><span class="s1">CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// transfer cytoscape constraints to cose layout</span><span class="s3">\n  </span><span class="s1">var processConstraints = function processConstraints(layout, options) {</span><span class="s3">\n    </span><span class="s1">// get nodes to be fixed</span><span class="s3">\n    </span><span class="s1">if (options.fixedNodeConstraint) {</span><span class="s3">\n      </span><span class="s1">layout.constraints[</span><span class="s3">\&quot;</span><span class="s1">fixedNodeConstraint</span><span class="s3">\&quot;</span><span class="s1">] = options.fixedNodeConstraint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// get nodes to be aligned</span><span class="s3">\n    </span><span class="s1">if (options.alignmentConstraint) {</span><span class="s3">\n      </span><span class="s1">layout.constraints[</span><span class="s3">\&quot;</span><span class="s1">alignmentConstraint</span><span class="s3">\&quot;</span><span class="s1">] = options.alignmentConstraint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// get nodes to be relatively placed</span><span class="s3">\n    </span><span class="s1">if (options.relativePlacementConstraint) {</span><span class="s3">\n      </span><span class="s1">layout.constraints[</span><span class="s3">\&quot;</span><span class="s1">relativePlacementConstraint</span><span class="s3">\&quot;</span><span class="s1">] = options.relativePlacementConstraint;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/**** Apply postprocessing ****/</span><span class="s3">\n  </span><span class="s1">if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;</span><span class="s3">\n  </span><span class="s1">if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;</span><span class="s3">\n  </span><span class="s1">if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;</span><span class="s3">\n  </span><span class="s1">if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;</span><span class="s3">\n  </span><span class="s1">if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;</span><span class="s3">\n  </span><span class="s1">if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;</span><span class="s3">\n  </span><span class="s1">if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;</span><span class="s3">\n\n  </span><span class="s1">if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;</span><span class="s3">\n\n  </span><span class="s1">if (options.quality == 'proof') LayoutConstants.QUALITY = 2;else LayoutConstants.QUALITY = 0;</span><span class="s3">\n\n  </span><span class="s1">CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILE = options.tile;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;</span><span class="s3">\n\n  </span><span class="s1">CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;</span><span class="s3">\n  </span><span class="s1">CoSEConstants.PURE_INCREMENTAL = !options.randomize;</span><span class="s3">\n  </span><span class="s1">LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;</span><span class="s3">\n\n  </span><span class="s1">// This part is for debug/demo purpose</span><span class="s3">\n  </span><span class="s1">if (options.step == </span><span class="s3">\&quot;</span><span class="s1">transformed</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.ENFORCE_CONSTRAINTS = false;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.APPLY_LAYOUT = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (options.step == </span><span class="s3">\&quot;</span><span class="s1">enforced</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.ENFORCE_CONSTRAINTS = true;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.APPLY_LAYOUT = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (options.step == </span><span class="s3">\&quot;</span><span class="s1">cose</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.ENFORCE_CONSTRAINTS = false;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.APPLY_LAYOUT = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (options.step == </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.ENFORCE_CONSTRAINTS = true;</span><span class="s3">\n    </span><span class="s1">CoSEConstants.APPLY_LAYOUT = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {</span><span class="s3">\n    </span><span class="s1">CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var coseLayout = new CoSELayout();</span><span class="s3">\n  </span><span class="s1">var gm = coseLayout.newGraphManager();</span><span class="s3">\n\n  </span><span class="s1">processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);</span><span class="s3">\n  </span><span class="s1">processEdges(coseLayout, gm, edges);</span><span class="s3">\n  </span><span class="s1">processConstraints(coseLayout, options);</span><span class="s3">\n\n  </span><span class="s1">coseLayout.runLayout();</span><span class="s3">\n\n  </span><span class="s1">return idToLNode;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = { coseLayout: coseLayout };</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 212:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n  </span><span class="s1">The implementation of the fcose layout algorithm</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var assign = __webpack_require__(658);</span><span class="s3">\n</span><span class="s1">var aux = __webpack_require__(548);</span><span class="s3">\n\n</span><span class="s1">var _require = __webpack_require__(657),</span><span class="s3">\n    </span><span class="s1">spectralLayout = _require.spectralLayout;</span><span class="s3">\n\n</span><span class="s1">var _require2 = __webpack_require__(816),</span><span class="s3">\n    </span><span class="s1">coseLayout = _require2.coseLayout;</span><span class="s3">\n\n</span><span class="s1">var defaults = Object.freeze({</span><span class="s3">\n\n  </span><span class="s1">// 'draft', 'default' or 'proof' </span><span class="s3">\n  </span><span class="s1">// - 'draft' only applies spectral layout </span><span class="s3">\n  </span><span class="s1">// - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)</span><span class="s3">\n  </span><span class="s1">// - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) </span><span class="s3">\n  </span><span class="s1">quality: </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">// Use random node positions at beginning of layout</span><span class="s3">\n  </span><span class="s1">// if this is set to false, then quality option must be </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;\n  </span><span class="s1">randomize: true,</span><span class="s3">\n  </span><span class="s1">// Whether or not to animate the layout</span><span class="s3">\n  </span><span class="s1">animate: true,</span><span class="s3">\n  </span><span class="s1">// Duration of animation in ms, if enabled</span><span class="s3">\n  </span><span class="s1">animationDuration: 1000,</span><span class="s3">\n  </span><span class="s1">// Easing of animation, if enabled</span><span class="s3">\n  </span><span class="s1">animationEasing: undefined,</span><span class="s3">\n  </span><span class="s1">// Fit the viewport to the repositioned nodes</span><span class="s3">\n  </span><span class="s1">fit: true,</span><span class="s3">\n  </span><span class="s1">// Padding around layout</span><span class="s3">\n  </span><span class="s1">padding: 30,</span><span class="s3">\n  </span><span class="s1">// Whether to include labels in node dimensions. Valid in </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot; </span><span class="s1">quality</span><span class="s3">\n  </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n  </span><span class="s1">// Whether or not simple nodes (non-compound nodes) are of uniform dimensions</span><span class="s3">\n  </span><span class="s1">uniformNodeDimensions: false,</span><span class="s3">\n  </span><span class="s1">// Whether to pack disconnected components - valid only if randomize: true</span><span class="s3">\n  </span><span class="s1">packComponents: true,</span><span class="s3">\n  </span><span class="s1">// Layout step - all, transformed, enforced, cose - for debug purpose only</span><span class="s3">\n  </span><span class="s1">step: </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n\n  </span><span class="s1">/* spectral layout options */</span><span class="s3">\n\n  </span><span class="s1">// False for random, true for greedy</span><span class="s3">\n  </span><span class="s1">samplingType: true,</span><span class="s3">\n  </span><span class="s1">// Sample size to construct distance matrix</span><span class="s3">\n  </span><span class="s1">sampleSize: 25,</span><span class="s3">\n  </span><span class="s1">// Separation amount between nodes</span><span class="s3">\n  </span><span class="s1">nodeSeparation: 75,</span><span class="s3">\n  </span><span class="s1">// Power iteration tolerance</span><span class="s3">\n  </span><span class="s1">piTol: 0.0000001,</span><span class="s3">\n\n  </span><span class="s1">/* CoSE layout options */</span><span class="s3">\n\n  </span><span class="s1">// Node repulsion (non overlapping) multiplier</span><span class="s3">\n  </span><span class="s1">nodeRepulsion: function nodeRepulsion(node) {</span><span class="s3">\n    </span><span class="s1">return 4500;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Ideal edge (non nested) length</span><span class="s3">\n  </span><span class="s1">idealEdgeLength: function idealEdgeLength(edge) {</span><span class="s3">\n    </span><span class="s1">return 50;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Divisor to compute edge forces</span><span class="s3">\n  </span><span class="s1">edgeElasticity: function edgeElasticity(edge) {</span><span class="s3">\n    </span><span class="s1">return 0.45;</span><span class="s3">\n  </span><span class="s1">},</span><span class="s3">\n  </span><span class="s1">// Nesting factor (multiplier) to compute ideal edge length for nested edges</span><span class="s3">\n  </span><span class="s1">nestingFactor: 0.1,</span><span class="s3">\n  </span><span class="s1">// Gravity force (constant)</span><span class="s3">\n  </span><span class="s1">gravity: 0.25,</span><span class="s3">\n  </span><span class="s1">// Maximum number of iterations to perform</span><span class="s3">\n  </span><span class="s1">numIter: 2500,</span><span class="s3">\n  </span><span class="s1">// For enabling tiling</span><span class="s3">\n  </span><span class="s1">tile: true,</span><span class="s3">\n  </span><span class="s1">// The function that specifies the criteria for comparing nodes while sorting them during tiling operation.</span><span class="s3">\n  </span><span class="s1">// Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.</span><span class="s3">\n  </span><span class="s1">tilingCompareBy: undefined,</span><span class="s3">\n  </span><span class="s1">// Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)</span><span class="s3">\n  </span><span class="s1">tilingPaddingVertical: 10,</span><span class="s3">\n  </span><span class="s1">// Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)</span><span class="s3">\n  </span><span class="s1">tilingPaddingHorizontal: 10,</span><span class="s3">\n  </span><span class="s1">// Gravity range (constant) for compounds</span><span class="s3">\n  </span><span class="s1">gravityRangeCompound: 1.5,</span><span class="s3">\n  </span><span class="s1">// Gravity force (constant) for compounds</span><span class="s3">\n  </span><span class="s1">gravityCompound: 1.0,</span><span class="s3">\n  </span><span class="s1">// Gravity range (constant)</span><span class="s3">\n  </span><span class="s1">gravityRange: 3.8,</span><span class="s3">\n  </span><span class="s1">// Initial cooling factor for incremental layout  </span><span class="s3">\n  </span><span class="s1">initialEnergyOnIncremental: 0.3,</span><span class="s3">\n\n  </span><span class="s1">/* constraint options */</span><span class="s3">\n\n  </span><span class="s1">// Fix required nodes to predefined positions</span><span class="s3">\n  </span><span class="s1">// [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]</span><span class="s3">\n  </span><span class="s1">fixedNodeConstraint: undefined,</span><span class="s3">\n  </span><span class="s1">// Align required nodes in vertical/horizontal direction</span><span class="s3">\n  </span><span class="s1">// {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}</span><span class="s3">\n  </span><span class="s1">alignmentConstraint: undefined,</span><span class="s3">\n  </span><span class="s1">// Place two nodes relatively in vertical/horizontal direction </span><span class="s3">\n  </span><span class="s1">// [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]</span><span class="s3">\n  </span><span class="s1">relativePlacementConstraint: undefined,</span><span class="s3">\n\n  </span><span class="s1">/* layout event callbacks */</span><span class="s3">\n  </span><span class="s1">ready: function ready() {}, // on layoutready</span><span class="s3">\n  </span><span class="s1">stop: function stop() {} // on layoutstop</span><span class="s3">\n</span><span class="s1">});</span><span class="s3">\n\n</span><span class="s1">var Layout = function () {</span><span class="s3">\n  </span><span class="s1">function Layout(options) {</span><span class="s3">\n    </span><span class="s1">_classCallCheck(this, Layout);</span><span class="s3">\n\n    </span><span class="s1">this.options = assign({}, defaults, options);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_createClass(Layout, [{</span><span class="s3">\n    </span><span class="s1">key: 'run',</span><span class="s3">\n    </span><span class="s1">value: function run() {</span><span class="s3">\n      </span><span class="s1">var layout = this;</span><span class="s3">\n      </span><span class="s1">var options = this.options;</span><span class="s3">\n      </span><span class="s1">var cy = options.cy;</span><span class="s3">\n      </span><span class="s1">var eles = options.eles;</span><span class="s3">\n\n      </span><span class="s1">var spectralResult = [];</span><span class="s3">\n      </span><span class="s1">var xCoords = void 0;</span><span class="s3">\n      </span><span class="s1">var yCoords = void 0;</span><span class="s3">\n      </span><span class="s1">var coseResult = [];</span><span class="s3">\n      </span><span class="s1">var components = void 0;</span><span class="s3">\n      </span><span class="s1">var componentCenters = [];</span><span class="s3">\n\n      </span><span class="s1">// basic validity check for constraint inputs </span><span class="s3">\n      </span><span class="s1">if (options.fixedNodeConstraint &amp;&amp; (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {</span><span class="s3">\n        </span><span class="s1">options.fixedNodeConstraint = undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (options.alignmentConstraint) {</span><span class="s3">\n        </span><span class="s1">if (options.alignmentConstraint.vertical &amp;&amp; (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {</span><span class="s3">\n          </span><span class="s1">options.alignmentConstraint.vertical = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (options.alignmentConstraint.horizontal &amp;&amp; (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {</span><span class="s3">\n          </span><span class="s1">options.alignmentConstraint.horizontal = undefined;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (options.relativePlacementConstraint &amp;&amp; (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {</span><span class="s3">\n        </span><span class="s1">options.relativePlacementConstraint = undefined;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// if any constraint exists, set some options</span><span class="s3">\n      </span><span class="s1">var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;</span><span class="s3">\n      </span><span class="s1">if (constraintExist) {</span><span class="s3">\n        </span><span class="s1">// constraints work with these options</span><span class="s3">\n        </span><span class="s1">options.tile = false;</span><span class="s3">\n        </span><span class="s1">options.packComponents = false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// decide component packing is enabled or not</span><span class="s3">\n      </span><span class="s1">var layUtil = void 0;</span><span class="s3">\n      </span><span class="s1">var packingEnabled = false;</span><span class="s3">\n      </span><span class="s1">if (cy.layoutUtilities &amp;&amp; options.packComponents) {</span><span class="s3">\n        </span><span class="s1">layUtil = cy.layoutUtilities(</span><span class="s3">\&quot;</span><span class="s1">get</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (!layUtil) layUtil = cy.layoutUtilities();</span><span class="s3">\n        </span><span class="s1">packingEnabled = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (eles.nodes().length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">// if packing is not enabled, perform layout on the whole graph</span><span class="s3">\n        </span><span class="s1">if (!packingEnabled) {</span><span class="s3">\n          </span><span class="s1">// store component center</span><span class="s3">\n          </span><span class="s1">var boundingBox = options.eles.boundingBox();</span><span class="s3">\n          </span><span class="s1">componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });</span><span class="s3">\n          </span><span class="s1">// apply spectral layout</span><span class="s3">\n          </span><span class="s1">if (options.randomize) {</span><span class="s3">\n            </span><span class="s1">var result = spectralLayout(options);</span><span class="s3">\n            </span><span class="s1">spectralResult.push(result);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// apply cose layout as postprocessing</span><span class="s3">\n          </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">|| options.quality == </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">coseResult.push(coseLayout(options, spectralResult[0]));</span><span class="s3">\n            </span><span class="s1">aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">// packing is enabled</span><span class="s3">\n          </span><span class="s1">var topMostNodes = aux.getTopMostNodes(options.eles.nodes());</span><span class="s3">\n          </span><span class="s1">components = aux.connectComponents(cy, options.eles, topMostNodes);</span><span class="s3">\n          </span><span class="s1">// store component centers</span><span class="s3">\n          </span><span class="s1">components.forEach(function (component) {</span><span class="s3">\n            </span><span class="s1">var boundingBox = component.boundingBox();</span><span class="s3">\n            </span><span class="s1">componentCenters.push({ x: boundingBox.x1 + boundingBox.w / 2, y: boundingBox.y1 + boundingBox.h / 2 });</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n\n          </span><span class="s1">//send each component to spectral layout if randomized</span><span class="s3">\n          </span><span class="s1">if (options.randomize) {</span><span class="s3">\n            </span><span class="s1">components.forEach(function (component) {</span><span class="s3">\n              </span><span class="s1">options.eles = component;</span><span class="s3">\n              </span><span class="s1">spectralResult.push(spectralLayout(options));</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">|| options.quality == </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">var toBeTiledNodes = cy.collection();</span><span class="s3">\n            </span><span class="s1">if (options.tile) {</span><span class="s3">\n              </span><span class="s1">// behave nodes to be tiled as one component</span><span class="s3">\n              </span><span class="s1">var nodeIndexes = new Map();</span><span class="s3">\n              </span><span class="s1">var _xCoords = [];</span><span class="s3">\n              </span><span class="s1">var _yCoords = [];</span><span class="s3">\n              </span><span class="s1">var count = 0;</span><span class="s3">\n              </span><span class="s1">var tempSpectralResult = { nodeIndexes: nodeIndexes, xCoords: _xCoords, yCoords: _yCoords };</span><span class="s3">\n              </span><span class="s1">var indexesToBeDeleted = [];</span><span class="s3">\n              </span><span class="s1">components.forEach(function (component, index) {</span><span class="s3">\n                </span><span class="s1">if (component.edges().length == 0) {</span><span class="s3">\n                  </span><span class="s1">component.nodes().forEach(function (node, i) {</span><span class="s3">\n                    </span><span class="s1">toBeTiledNodes.merge(component.nodes()[i]);</span><span class="s3">\n                    </span><span class="s1">if (!node.isParent()) {</span><span class="s3">\n                      </span><span class="s1">tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);</span><span class="s3">\n                      </span><span class="s1">tempSpectralResult.xCoords.push(component.nodes()[0].position().x);</span><span class="s3">\n                      </span><span class="s1">tempSpectralResult.yCoords.push(component.nodes()[0].position().y);</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">});</span><span class="s3">\n                  </span><span class="s1">indexesToBeDeleted.push(index);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">if (toBeTiledNodes.length &gt; 1) {</span><span class="s3">\n                </span><span class="s1">var _boundingBox = toBeTiledNodes.boundingBox();</span><span class="s3">\n                </span><span class="s1">componentCenters.push({ x: _boundingBox.x1 + _boundingBox.w / 2, y: _boundingBox.y1 + _boundingBox.h / 2 });</span><span class="s3">\n                </span><span class="s1">components.push(toBeTiledNodes);</span><span class="s3">\n                </span><span class="s1">spectralResult.push(tempSpectralResult);</span><span class="s3">\n                </span><span class="s1">for (var i = indexesToBeDeleted.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n                  </span><span class="s1">components.splice(indexesToBeDeleted[i], 1);</span><span class="s3">\n                  </span><span class="s1">spectralResult.splice(indexesToBeDeleted[i], 1);</span><span class="s3">\n                  </span><span class="s1">componentCenters.splice(indexesToBeDeleted[i], 1);</span><span class="s3">\n                </span><span class="s1">};</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">components.forEach(function (component, index) {</span><span class="s3">\n              </span><span class="s1">// send each component to cose layout</span><span class="s3">\n              </span><span class="s1">options.eles = component;</span><span class="s3">\n              </span><span class="s1">coseResult.push(coseLayout(options, spectralResult[index]));</span><span class="s3">\n              </span><span class="s1">aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">components.forEach(function (component, index) {</span><span class="s3">\n              </span><span class="s1">aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// packing</span><span class="s3">\n          </span><span class="s1">var componentsEvaluated = new Set();</span><span class="s3">\n          </span><span class="s1">if (components.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">var subgraphs = [];</span><span class="s3">\n            </span><span class="s1">var hiddenEles = eles.filter(function (ele) {</span><span class="s3">\n              </span><span class="s1">return ele.css('display') == 'none';</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">components.forEach(function (component, index) {</span><span class="s3">\n              </span><span class="s1">var nodeIndexes = void 0;</span><span class="s3">\n              </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">nodeIndexes = spectralResult[index].nodeIndexes;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n\n              </span><span class="s1">if (component.nodes().not(hiddenEles).length &gt; 0) {</span><span class="s3">\n                </span><span class="s1">var subgraph = {};</span><span class="s3">\n                </span><span class="s1">subgraph.edges = [];</span><span class="s3">\n                </span><span class="s1">subgraph.nodes = [];</span><span class="s3">\n                </span><span class="s1">var nodeIndex = void 0;</span><span class="s3">\n                </span><span class="s1">component.nodes().not(hiddenEles).forEach(function (node) {</span><span class="s3">\n                  </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">if (!node.isParent()) {</span><span class="s3">\n                      </span><span class="s1">nodeIndex = nodeIndexes.get(node.id());</span><span class="s3">\n                      </span><span class="s1">subgraph.nodes.push({ x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2, y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2, width: node.boundingbox().w, height: node.boundingbox().h });</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);</span><span class="s3">\n                      </span><span class="s1">subgraph.nodes.push({ x: parentInfo.topLeftX, y: parentInfo.topLeftY, width: parentInfo.width, height: parentInfo.height });</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">} else {</span><span class="s3">\n                    </span><span class="s1">if (coseResult[index][node.id()]) {</span><span class="s3">\n                      </span><span class="s1">subgraph.nodes.push({ x: coseResult[index][node.id()].getLeft(), y: coseResult[index][node.id()].getTop(), width: coseResult[index][node.id()].getWidth(), height: coseResult[index][node.id()].getHeight() });</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">component.edges().forEach(function (edge) {</span><span class="s3">\n                  </span><span class="s1">var source = edge.source();</span><span class="s3">\n                  </span><span class="s1">var target = edge.target();</span><span class="s3">\n                  </span><span class="s1">if (source.css(</span><span class="s3">\&quot;</span><span class="s1">display</span><span class="s3">\&quot;</span><span class="s1">) != </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; target.css(</span><span class="s3">\&quot;</span><span class="s1">display</span><span class="s3">\&quot;</span><span class="s1">) != </span><span class="s3">\&quot;</span><span class="s1">none</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                    </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                      </span><span class="s1">var sourceNodeIndex = nodeIndexes.get(source.id());</span><span class="s3">\n                      </span><span class="s1">var targetNodeIndex = nodeIndexes.get(target.id());</span><span class="s3">\n                      </span><span class="s1">var sourceCenter = [];</span><span class="s3">\n                      </span><span class="s1">var targetCenter = [];</span><span class="s3">\n                      </span><span class="s1">if (source.isParent()) {</span><span class="s3">\n                        </span><span class="s1">var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);</span><span class="s3">\n                        </span><span class="s1">sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);</span><span class="s3">\n                        </span><span class="s1">sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);</span><span class="s3">\n                      </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);</span><span class="s3">\n                        </span><span class="s1">sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                      </span><span class="s1">if (target.isParent()) {</span><span class="s3">\n                        </span><span class="s1">var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);</span><span class="s3">\n                        </span><span class="s1">targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);</span><span class="s3">\n                        </span><span class="s1">targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);</span><span class="s3">\n                      </span><span class="s1">} else {</span><span class="s3">\n                        </span><span class="s1">targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);</span><span class="s3">\n                        </span><span class="s1">targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                      </span><span class="s1">subgraph.edges.push({ startX: sourceCenter[0], startY: sourceCenter[1], endX: targetCenter[0], endY: targetCenter[1] });</span><span class="s3">\n                    </span><span class="s1">} else {</span><span class="s3">\n                      </span><span class="s1">if (coseResult[index][source.id()] &amp;&amp; coseResult[index][target.id()]) {</span><span class="s3">\n                        </span><span class="s1">subgraph.edges.push({ startX: coseResult[index][source.id()].getCenterX(), startY: coseResult[index][source.id()].getCenterY(), endX: coseResult[index][target.id()].getCenterX(), endY: coseResult[index][target.id()].getCenterY() });</span><span class="s3">\n                      </span><span class="s1">}</span><span class="s3">\n                    </span><span class="s1">}</span><span class="s3">\n                  </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">if (subgraph.nodes.length &gt; 0) {</span><span class="s3">\n                  </span><span class="s1">subgraphs.push(subgraph);</span><span class="s3">\n                  </span><span class="s1">componentsEvaluated.add(index);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;</span><span class="s3">\n            </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">spectralResult.forEach(function (result, index) {</span><span class="s3">\n                </span><span class="s1">var newXCoords = result.xCoords.map(function (x) {</span><span class="s3">\n                  </span><span class="s1">return x + shiftResult[index].dx;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">var newYCoords = result.yCoords.map(function (y) {</span><span class="s3">\n                  </span><span class="s1">return y + shiftResult[index].dy;</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">result.xCoords = newXCoords;</span><span class="s3">\n                </span><span class="s1">result.yCoords = newYCoords;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">var _count = 0;</span><span class="s3">\n              </span><span class="s1">componentsEvaluated.forEach(function (index) {</span><span class="s3">\n                </span><span class="s1">Object.keys(coseResult[index]).forEach(function (item) {</span><span class="s3">\n                  </span><span class="s1">var nodeRectangle = coseResult[index][item];</span><span class="s3">\n                  </span><span class="s1">nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">_count++;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// get each element's calculated position</span><span class="s3">\n      </span><span class="s1">var getPositions = function getPositions(ele, i) {</span><span class="s3">\n        </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">|| options.quality == </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">if (typeof ele === </span><span class="s3">\&quot;</span><span class="s1">number</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">ele = i;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var pos = void 0;</span><span class="s3">\n          </span><span class="s1">var node = void 0;</span><span class="s3">\n          </span><span class="s1">var theId = ele.data('id');</span><span class="s3">\n          </span><span class="s1">coseResult.forEach(function (result) {</span><span class="s3">\n            </span><span class="s1">if (theId in result) {</span><span class="s3">\n              </span><span class="s1">pos = { x: result[theId].getRect().getCenterX(), y: result[theId].getRect().getCenterY() };</span><span class="s3">\n              </span><span class="s1">node = result[theId];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (options.nodeDimensionsIncludeLabels) {</span><span class="s3">\n            </span><span class="s1">if (node.labelWidth) {</span><span class="s3">\n              </span><span class="s1">if (node.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">pos.x += node.labelWidth / 2;</span><span class="s3">\n              </span><span class="s1">} else if (node.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">pos.x -= node.labelWidth / 2;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (node.labelHeight) {</span><span class="s3">\n              </span><span class="s1">if (node.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">pos.y += node.labelHeight / 2;</span><span class="s3">\n              </span><span class="s1">} else if (node.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n                </span><span class="s1">pos.y -= node.labelHeight / 2;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (pos == undefined) pos = { x: ele.position(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">), y: ele.position(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">) };</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">x: pos.x,</span><span class="s3">\n            </span><span class="s1">y: pos.y</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var _pos = void 0;</span><span class="s3">\n          </span><span class="s1">spectralResult.forEach(function (result) {</span><span class="s3">\n            </span><span class="s1">var index = result.nodeIndexes.get(ele.id());</span><span class="s3">\n            </span><span class="s1">if (index != undefined) {</span><span class="s3">\n              </span><span class="s1">_pos = { x: result.xCoords[index], y: result.yCoords[index] };</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">if (_pos == undefined) _pos = { x: ele.position(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">), y: ele.position(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">) };</span><span class="s3">\n          </span><span class="s1">return {</span><span class="s3">\n            </span><span class="s1">x: _pos.x,</span><span class="s3">\n            </span><span class="s1">y: _pos.y</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">// quality = </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot; </span><span class="s1">and randomize = false are contradictive so in that case positions don't change</span><span class="s3">\n      </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">|| options.quality == </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot; </span><span class="s1">|| options.randomize) {</span><span class="s3">\n        </span><span class="s1">// transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)</span><span class="s3">\n        </span><span class="s1">var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);</span><span class="s3">\n        </span><span class="s1">var _hiddenEles = eles.filter(function (ele) {</span><span class="s3">\n          </span><span class="s1">return ele.css('display') == 'none';</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">options.eles = eles.not(_hiddenEles);</span><span class="s3">\n\n        </span><span class="s1">eles.nodes().not(</span><span class="s3">\&quot;</span><span class="s1">:parent</span><span class="s3">\&quot;</span><span class="s1">).not(_hiddenEles).layoutPositions(layout, options, getPositions);</span><span class="s3">\n\n        </span><span class="s1">if (parentsWithoutChildren.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">parentsWithoutChildren.forEach(function (ele) {</span><span class="s3">\n            </span><span class="s1">ele.position(getPositions(ele));</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">console.log(</span><span class="s3">\&quot;</span><span class="s1">If randomize option is set to false, then quality option must be 'default' or 'proof'.</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n\n  </span><span class="s1">return Layout;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = Layout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 657:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">/**</span><span class="s3">\n  </span><span class="s1">The implementation of the spectral layout that is the first part of the fcose layout algorithm</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var aux = __webpack_require__(548);</span><span class="s3">\n</span><span class="s1">var Matrix = __webpack_require__(140).layoutBase.Matrix;</span><span class="s3">\n</span><span class="s1">var SVD = __webpack_require__(140).layoutBase.SVD;</span><span class="s3">\n\n</span><span class="s1">// main function that spectral layout is processed</span><span class="s3">\n</span><span class="s1">var spectralLayout = function spectralLayout(options) {</span><span class="s3">\n\n  </span><span class="s1">var cy = options.cy;</span><span class="s3">\n  </span><span class="s1">var eles = options.eles;</span><span class="s3">\n  </span><span class="s1">var nodes = eles.nodes();</span><span class="s3">\n  </span><span class="s1">var parentNodes = eles.nodes(</span><span class="s3">\&quot;</span><span class="s1">:parent</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n  </span><span class="s1">var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors</span><span class="s3">\n  </span><span class="s1">var nodeIndexes = new Map(); // map to keep indexes to nodes</span><span class="s3">\n  </span><span class="s1">var parentChildMap = new Map(); // mapping btw. compound and its representative node </span><span class="s3">\n  </span><span class="s1">var allNodesNeighborhood = []; // array to keep neighborhood of all nodes</span><span class="s3">\n  </span><span class="s1">var xCoords = [];</span><span class="s3">\n  </span><span class="s1">var yCoords = [];</span><span class="s3">\n\n  </span><span class="s1">var samplesColumn = []; // sampled vertices</span><span class="s3">\n  </span><span class="s1">var minDistancesColumn = [];</span><span class="s3">\n  </span><span class="s1">var C = []; // column sampling matrix</span><span class="s3">\n  </span><span class="s1">var PHI = []; // intersection of column and row sampling matrices </span><span class="s3">\n  </span><span class="s1">var INV = []; // inverse of PHI </span><span class="s3">\n\n  </span><span class="s1">var firstSample = void 0; // the first sampled node</span><span class="s3">\n  </span><span class="s1">var nodeSize = void 0;</span><span class="s3">\n\n  </span><span class="s1">var infinity = 100000000;</span><span class="s3">\n  </span><span class="s1">var small = 0.000000001;</span><span class="s3">\n\n  </span><span class="s1">var piTol = options.piTol;</span><span class="s3">\n  </span><span class="s1">var samplingType = options.samplingType; // false for random, true for greedy</span><span class="s3">\n  </span><span class="s1">var nodeSeparation = options.nodeSeparation;</span><span class="s3">\n  </span><span class="s1">var sampleSize = void 0;</span><span class="s3">\n\n  </span><span class="s1">/**** Spectral-preprocessing functions ****/</span><span class="s3">\n\n  </span><span class="s1">/**** Spectral layout functions ****/</span><span class="s3">\n\n  </span><span class="s1">// determine which columns to be sampled</span><span class="s3">\n  </span><span class="s1">var randomSampleCR = function randomSampleCR() {</span><span class="s3">\n    </span><span class="s1">var sample = 0;</span><span class="s3">\n    </span><span class="s1">var count = 0;</span><span class="s3">\n    </span><span class="s1">var flag = false;</span><span class="s3">\n\n    </span><span class="s1">while (count &lt; sampleSize) {</span><span class="s3">\n      </span><span class="s1">sample = Math.floor(Math.random() * nodeSize);</span><span class="s3">\n\n      </span><span class="s1">flag = false;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; count; i++) {</span><span class="s3">\n        </span><span class="s1">if (samplesColumn[i] == sample) {</span><span class="s3">\n          </span><span class="s1">flag = true;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!flag) {</span><span class="s3">\n        </span><span class="s1">samplesColumn[count] = sample;</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">continue;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// takes the index of the node(pivot) to initiate BFS as a parameter</span><span class="s3">\n  </span><span class="s1">var BFS = function BFS(pivot, index, samplingMethod) {</span><span class="s3">\n    </span><span class="s1">var path = []; // the front of the path</span><span class="s3">\n    </span><span class="s1">var front = 0; // the back of the path</span><span class="s3">\n    </span><span class="s1">var back = 0;</span><span class="s3">\n    </span><span class="s1">var current = 0;</span><span class="s3">\n    </span><span class="s1">var temp = void 0;</span><span class="s3">\n    </span><span class="s1">var distance = [];</span><span class="s3">\n\n    </span><span class="s1">var max_dist = 0; // the furthest node to be returned</span><span class="s3">\n    </span><span class="s1">var max_ind = 1;</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; nodeSize; i++) {</span><span class="s3">\n      </span><span class="s1">distance[i] = infinity;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">path[back] = pivot;</span><span class="s3">\n    </span><span class="s1">distance[pivot] = 0;</span><span class="s3">\n\n    </span><span class="s1">while (back &gt;= front) {</span><span class="s3">\n      </span><span class="s1">current = path[front++];</span><span class="s3">\n      </span><span class="s1">var neighbors = allNodesNeighborhood[current];</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; neighbors.length; _i++) {</span><span class="s3">\n        </span><span class="s1">temp = nodeIndexes.get(neighbors[_i]);</span><span class="s3">\n        </span><span class="s1">if (distance[temp] == infinity) {</span><span class="s3">\n          </span><span class="s1">distance[temp] = distance[current] + 1;</span><span class="s3">\n          </span><span class="s1">path[++back] = temp;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">C[current][index] = distance[current] * nodeSeparation;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (samplingMethod) {</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodeSize; _i2++) {</span><span class="s3">\n        </span><span class="s1">if (C[_i2][index] &lt; minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (var _i3 = 0; _i3 &lt; nodeSize; _i3++) {</span><span class="s3">\n        </span><span class="s1">if (minDistancesColumn[_i3] &gt; max_dist) {</span><span class="s3">\n          </span><span class="s1">max_dist = minDistancesColumn[_i3];</span><span class="s3">\n          </span><span class="s1">max_ind = _i3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return max_ind;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// apply BFS to all nodes or selected samples</span><span class="s3">\n  </span><span class="s1">var allBFS = function allBFS(samplingMethod) {</span><span class="s3">\n\n    </span><span class="s1">var sample = void 0;</span><span class="s3">\n\n    </span><span class="s1">if (!samplingMethod) {</span><span class="s3">\n      </span><span class="s1">randomSampleCR();</span><span class="s3">\n\n      </span><span class="s1">// call BFS</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; sampleSize; i++) {</span><span class="s3">\n        </span><span class="s1">BFS(samplesColumn[i], i, samplingMethod, false);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">sample = Math.floor(Math.random() * nodeSize);</span><span class="s3">\n      </span><span class="s1">firstSample = sample;</span><span class="s3">\n\n      </span><span class="s1">for (var _i4 = 0; _i4 &lt; nodeSize; _i4++) {</span><span class="s3">\n        </span><span class="s1">minDistancesColumn[_i4] = infinity;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (var _i5 = 0; _i5 &lt; sampleSize; _i5++) {</span><span class="s3">\n        </span><span class="s1">samplesColumn[_i5] = sample;</span><span class="s3">\n        </span><span class="s1">sample = BFS(sample, _i5, samplingMethod);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// form the squared distances for C</span><span class="s3">\n    </span><span class="s1">for (var _i6 = 0; _i6 &lt; nodeSize; _i6++) {</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; sampleSize; j++) {</span><span class="s3">\n        </span><span class="s1">C[_i6][j] *= C[_i6][j];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// form PHI</span><span class="s3">\n    </span><span class="s1">for (var _i7 = 0; _i7 &lt; sampleSize; _i7++) {</span><span class="s3">\n      </span><span class="s1">PHI[_i7] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (var _i8 = 0; _i8 &lt; sampleSize; _i8++) {</span><span class="s3">\n      </span><span class="s1">for (var _j = 0; _j &lt; sampleSize; _j++) {</span><span class="s3">\n        </span><span class="s1">PHI[_i8][_j] = C[samplesColumn[_j]][_i8];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// perform the SVD algorithm and apply a regularization step</span><span class="s3">\n  </span><span class="s1">var sample = function sample() {</span><span class="s3">\n\n    </span><span class="s1">var SVDResult = SVD.svd(PHI);</span><span class="s3">\n\n    </span><span class="s1">var a_q = SVDResult.S;</span><span class="s3">\n    </span><span class="s1">var a_u = SVDResult.U;</span><span class="s3">\n    </span><span class="s1">var a_v = SVDResult.V;</span><span class="s3">\n\n    </span><span class="s1">var max_s = a_q[0] * a_q[0] * a_q[0];</span><span class="s3">\n\n    </span><span class="s1">var a_Sig = [];</span><span class="s3">\n\n    </span><span class="s1">//  regularization</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; sampleSize; i++) {</span><span class="s3">\n      </span><span class="s1">a_Sig[i] = [];</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; sampleSize; j++) {</span><span class="s3">\n        </span><span class="s1">a_Sig[i][j] = 0;</span><span class="s3">\n        </span><span class="s1">if (i == j) {</span><span class="s3">\n          </span><span class="s1">a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// calculate final coordinates </span><span class="s3">\n  </span><span class="s1">var powerIteration = function powerIteration() {</span><span class="s3">\n    </span><span class="s1">// two largest eigenvalues</span><span class="s3">\n    </span><span class="s1">var theta1 = void 0;</span><span class="s3">\n    </span><span class="s1">var theta2 = void 0;</span><span class="s3">\n\n    </span><span class="s1">// initial guesses for eigenvectors</span><span class="s3">\n    </span><span class="s1">var Y1 = [];</span><span class="s3">\n    </span><span class="s1">var Y2 = [];</span><span class="s3">\n\n    </span><span class="s1">var V1 = [];</span><span class="s3">\n    </span><span class="s1">var V2 = [];</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; nodeSize; i++) {</span><span class="s3">\n      </span><span class="s1">Y1[i] = Math.random();</span><span class="s3">\n      </span><span class="s1">Y2[i] = Math.random();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">Y1 = Matrix.normalize(Y1);</span><span class="s3">\n    </span><span class="s1">Y2 = Matrix.normalize(Y2);</span><span class="s3">\n\n    </span><span class="s1">var count = 0;</span><span class="s3">\n    </span><span class="s1">// to keep track of the improvement ratio in power iteration</span><span class="s3">\n    </span><span class="s1">var current = small;</span><span class="s3">\n    </span><span class="s1">var previous = small;</span><span class="s3">\n\n    </span><span class="s1">var temp = void 0;</span><span class="s3">\n\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">count++;</span><span class="s3">\n\n      </span><span class="s1">for (var _i9 = 0; _i9 &lt; nodeSize; _i9++) {</span><span class="s3">\n        </span><span class="s1">V1[_i9] = Y1[_i9];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));</span><span class="s3">\n      </span><span class="s1">theta1 = Matrix.dotProduct(V1, Y1);</span><span class="s3">\n      </span><span class="s1">Y1 = Matrix.normalize(Y1);</span><span class="s3">\n\n      </span><span class="s1">current = Matrix.dotProduct(V1, Y1);</span><span class="s3">\n\n      </span><span class="s1">temp = Math.abs(current / previous);</span><span class="s3">\n\n      </span><span class="s1">if (temp &lt;= 1 + piTol &amp;&amp; temp &gt;= 1) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">previous = current;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (var _i10 = 0; _i10 &lt; nodeSize; _i10++) {</span><span class="s3">\n      </span><span class="s1">V1[_i10] = Y1[_i10];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">count = 0;</span><span class="s3">\n    </span><span class="s1">previous = small;</span><span class="s3">\n    </span><span class="s1">while (true) {</span><span class="s3">\n      </span><span class="s1">count++;</span><span class="s3">\n\n      </span><span class="s1">for (var _i11 = 0; _i11 &lt; nodeSize; _i11++) {</span><span class="s3">\n        </span><span class="s1">V2[_i11] = Y2[_i11];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));</span><span class="s3">\n      </span><span class="s1">Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));</span><span class="s3">\n      </span><span class="s1">theta2 = Matrix.dotProduct(V2, Y2);</span><span class="s3">\n      </span><span class="s1">Y2 = Matrix.normalize(Y2);</span><span class="s3">\n\n      </span><span class="s1">current = Matrix.dotProduct(V2, Y2);</span><span class="s3">\n\n      </span><span class="s1">temp = Math.abs(current / previous);</span><span class="s3">\n\n      </span><span class="s1">if (temp &lt;= 1 + piTol &amp;&amp; temp &gt;= 1) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">previous = current;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">for (var _i12 = 0; _i12 &lt; nodeSize; _i12++) {</span><span class="s3">\n      </span><span class="s1">V2[_i12] = Y2[_i12];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// theta1 now contains dominant eigenvalue</span><span class="s3">\n    </span><span class="s1">// theta2 now contains the second-largest eigenvalue</span><span class="s3">\n    </span><span class="s1">// V1 now contains theta1's eigenvector</span><span class="s3">\n    </span><span class="s1">// V2 now contains theta2's eigenvector</span><span class="s3">\n\n    </span><span class="s1">//populate the two vectors</span><span class="s3">\n    </span><span class="s1">xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));</span><span class="s3">\n    </span><span class="s1">yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/**** Preparation for spectral layout (Preprocessing) ****/</span><span class="s3">\n\n  </span><span class="s1">// connect disconnected components (first top level, then inside of each compound node)</span><span class="s3">\n  </span><span class="s1">aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);</span><span class="s3">\n\n  </span><span class="s1">parentNodes.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// assign indexes to nodes (first real, then dummy nodes)</span><span class="s3">\n  </span><span class="s1">var index = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (!nodes[i].isParent()) {</span><span class="s3">\n      </span><span class="s1">nodeIndexes.set(nodes[i].id(), index++);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var _iteratorNormalCompletion = true;</span><span class="s3">\n  </span><span class="s1">var _didIteratorError = false;</span><span class="s3">\n  </span><span class="s1">var _iteratorError = undefined;</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {</span><span class="s3">\n      </span><span class="s1">var key = _step.value;</span><span class="s3">\n\n      </span><span class="s1">nodeIndexes.set(key, index++);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// instantiate the neighborhood matrix</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">_didIteratorError = true;</span><span class="s3">\n    </span><span class="s1">_iteratorError = err;</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {</span><span class="s3">\n        </span><span class="s1">_iterator.return();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">if (_didIteratorError) {</span><span class="s3">\n        </span><span class="s1">throw _iteratorError;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var _i13 = 0; _i13 &lt; nodeIndexes.size; _i13++) {</span><span class="s3">\n    </span><span class="s1">allNodesNeighborhood[_i13] = [];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// form a parent-child map to keep representative node of each compound node  </span><span class="s3">\n  </span><span class="s1">parentNodes.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">var children = ele.children().intersection(eles);</span><span class="s3">\n\n    </span><span class="s1">//      let random = 0;</span><span class="s3">\n    </span><span class="s1">while (children.nodes(</span><span class="s3">\&quot;</span><span class="s1">:childless</span><span class="s3">\&quot;</span><span class="s1">).length == 0) {</span><span class="s3">\n      </span><span class="s1">//        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly</span><span class="s3">\n      </span><span class="s1">children = children.nodes()[0].children().intersection(eles);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">//  select the representative node - we can apply different methods here</span><span class="s3">\n    </span><span class="s1">//      random = Math.floor(Math.random() * children.nodes(</span><span class="s3">\&quot;</span><span class="s1">:childless</span><span class="s3">\&quot;</span><span class="s1">).length);</span><span class="s3">\n    </span><span class="s1">var index = 0;</span><span class="s3">\n    </span><span class="s1">var min = children.nodes(</span><span class="s3">\&quot;</span><span class="s1">:childless</span><span class="s3">\&quot;</span><span class="s1">)[0].connectedEdges().length;</span><span class="s3">\n    </span><span class="s1">children.nodes(</span><span class="s3">\&quot;</span><span class="s1">:childless</span><span class="s3">\&quot;</span><span class="s1">).forEach(function (ele2, i) {</span><span class="s3">\n      </span><span class="s1">if (ele2.connectedEdges().length &lt; min) {</span><span class="s3">\n        </span><span class="s1">min = ele2.connectedEdges().length;</span><span class="s3">\n        </span><span class="s1">index = i;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">parentChildMap.set(ele.id(), children.nodes(</span><span class="s3">\&quot;</span><span class="s1">:childless</span><span class="s3">\&quot;</span><span class="s1">)[index].id());</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// add neighborhood relations (first real, then dummy nodes)</span><span class="s3">\n  </span><span class="s1">nodes.forEach(function (ele) {</span><span class="s3">\n    </span><span class="s1">var eleIndex = void 0;</span><span class="s3">\n\n    </span><span class="s1">if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));else eleIndex = nodeIndexes.get(ele.id());</span><span class="s3">\n\n    </span><span class="s1">ele.neighborhood().nodes().forEach(function (node) {</span><span class="s3">\n      </span><span class="s1">if (eles.intersection(ele.edgesWith(node)).length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));else allNodesNeighborhood[eleIndex].push(node.id());</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">var _loop = function _loop(_key) {</span><span class="s3">\n    </span><span class="s1">var eleIndex = nodeIndexes.get(_key);</span><span class="s3">\n    </span><span class="s1">var disconnectedId = void 0;</span><span class="s3">\n    </span><span class="s1">dummyNodes.get(_key).forEach(function (id) {</span><span class="s3">\n      </span><span class="s1">if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);else disconnectedId = id;</span><span class="s3">\n\n      </span><span class="s1">allNodesNeighborhood[eleIndex].push(disconnectedId);</span><span class="s3">\n      </span><span class="s1">allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">var _iteratorNormalCompletion2 = true;</span><span class="s3">\n  </span><span class="s1">var _didIteratorError2 = false;</span><span class="s3">\n  </span><span class="s1">var _iteratorError2 = undefined;</span><span class="s3">\n\n  </span><span class="s1">try {</span><span class="s3">\n    </span><span class="s1">for (var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {</span><span class="s3">\n      </span><span class="s1">var _key = _step2.value;</span><span class="s3">\n\n      </span><span class="s1">_loop(_key);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// nodeSize now only considers the size of transformed graph</span><span class="s3">\n  </span><span class="s1">} catch (err) {</span><span class="s3">\n    </span><span class="s1">_didIteratorError2 = true;</span><span class="s3">\n    </span><span class="s1">_iteratorError2 = err;</span><span class="s3">\n  </span><span class="s1">} finally {</span><span class="s3">\n    </span><span class="s1">try {</span><span class="s3">\n      </span><span class="s1">if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {</span><span class="s3">\n        </span><span class="s1">_iterator2.return();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} finally {</span><span class="s3">\n      </span><span class="s1">if (_didIteratorError2) {</span><span class="s3">\n        </span><span class="s1">throw _iteratorError2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">nodeSize = nodeIndexes.size;</span><span class="s3">\n\n  </span><span class="s1">var spectralResult = void 0;</span><span class="s3">\n\n  </span><span class="s1">// If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem</span><span class="s3">\n  </span><span class="s1">// So skip spectral and layout the graph with cose</span><span class="s3">\n  </span><span class="s1">if (nodeSize &gt; 2) {</span><span class="s3">\n    </span><span class="s1">// if # of nodes in transformed graph is smaller than sample size,</span><span class="s3">\n    </span><span class="s1">// then use # of nodes as sample size</span><span class="s3">\n    </span><span class="s1">sampleSize = nodeSize &lt; options.sampleSize ? nodeSize : options.sampleSize;</span><span class="s3">\n\n    </span><span class="s1">// instantiates the partial matrices that will be used in spectral layout</span><span class="s3">\n    </span><span class="s1">for (var _i14 = 0; _i14 &lt; nodeSize; _i14++) {</span><span class="s3">\n      </span><span class="s1">C[_i14] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var _i15 = 0; _i15 &lt; sampleSize; _i15++) {</span><span class="s3">\n      </span><span class="s1">INV[_i15] = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/**** Apply spectral layout ****/</span><span class="s3">\n\n    </span><span class="s1">if (options.quality == </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot; </span><span class="s1">|| options.step == </span><span class="s3">\&quot;</span><span class="s1">all</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">allBFS(samplingType);</span><span class="s3">\n      </span><span class="s1">sample();</span><span class="s3">\n      </span><span class="s1">powerIteration();</span><span class="s3">\n\n      </span><span class="s1">spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">nodeIndexes.forEach(function (value, key) {</span><span class="s3">\n        </span><span class="s1">xCoords.push(cy.getElementById(key).position(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n        </span><span class="s1">yCoords.push(cy.getElementById(key).position(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return spectralResult;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var iterator = nodeIndexes.keys();</span><span class="s3">\n    </span><span class="s1">var firstNode = cy.getElementById(iterator.next().value);</span><span class="s3">\n    </span><span class="s1">var firstNodePos = firstNode.position();</span><span class="s3">\n    </span><span class="s1">var firstNodeWidth = firstNode.outerWidth();</span><span class="s3">\n    </span><span class="s1">xCoords.push(firstNodePos.x);</span><span class="s3">\n    </span><span class="s1">yCoords.push(firstNodePos.y);</span><span class="s3">\n    </span><span class="s1">if (nodeSize == 2) {</span><span class="s3">\n      </span><span class="s1">var secondNode = cy.getElementById(iterator.next().value);</span><span class="s3">\n      </span><span class="s1">var secondNodeWidth = secondNode.outerWidth();</span><span class="s3">\n      </span><span class="s1">xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);</span><span class="s3">\n      </span><span class="s1">yCoords.push(firstNodePos.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">spectralResult = { nodeIndexes: nodeIndexes, xCoords: xCoords, yCoords: yCoords };</span><span class="s3">\n    </span><span class="s1">return spectralResult;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = { spectralLayout: spectralLayout };</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 579:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var impl = __webpack_require__(212);</span><span class="s3">\n\n</span><span class="s1">// registers the extension on a cytoscape lib ref</span><span class="s3">\n</span><span class="s1">var register = function register(cytoscape) {</span><span class="s3">\n  </span><span class="s1">if (!cytoscape) {</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">} // can't register if cytoscape unspecified</span><span class="s3">\n\n  </span><span class="s1">cytoscape('layout', 'fcose', impl); // register with cytoscape.js</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">if (typeof cytoscape !== 'undefined') {</span><span class="s3">\n  </span><span class="s1">// expose to global cytoscape (i.e. window.cytoscape)</span><span class="s3">\n  </span><span class="s1">register(cytoscape);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = register;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 140:</span><span class="s3">\n</span><span class="s1">/***/ ((module) =&gt; {</span><span class="s3">\n\n</span><span class="s1">module.exports = __WEBPACK_EXTERNAL_MODULE__140__;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_module_cache__ = {};</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var cachedModule = __webpack_module_cache__[moduleId];</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if (cachedModule !== undefined) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return cachedModule.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = __webpack_module_cache__[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">// no module.id needed</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">// no module.loaded needed</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_modules__[moduleId](module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// startup</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// This entry module is referenced by other modules so it can't be inlined</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_exports__ = __webpack_require__(579);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_exports__;</span><span class="s3">\n</span><span class="s1">/******/ })()</span><span class="s3">\n</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory(require(</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">] = factory(require(</span><span class="s3">\&quot;</span><span class="s1">layout-base</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">coseBase</span><span class="s3">\&quot;</span><span class="s1">] = factory(root[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">})(this, function(__WEBPACK_EXTERNAL_MODULE__551__) {</span><span class="s3">\n</span><span class="s1">return /******/ (() =&gt; { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_modules__ = ({</span><span class="s3">\n\n</span><span class="s1">/***/ 45:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var coseBase = {};</span><span class="s3">\n\n</span><span class="s1">coseBase.layoutBase = __webpack_require__(551);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEConstants = __webpack_require__(806);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEEdge = __webpack_require__(767);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEGraph = __webpack_require__(880);</span><span class="s3">\n</span><span class="s1">coseBase.CoSEGraphManager = __webpack_require__(578);</span><span class="s3">\n</span><span class="s1">coseBase.CoSELayout = __webpack_require__(765);</span><span class="s3">\n</span><span class="s1">coseBase.CoSENode = __webpack_require__(991);</span><span class="s3">\n</span><span class="s1">coseBase.ConstraintHandler = __webpack_require__(902);</span><span class="s3">\n\n</span><span class="s1">module.exports = coseBase;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 806:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;</span><span class="s3">\n\n</span><span class="s1">function CoSEConstants() {}</span><span class="s3">\n\n</span><span class="s1">//CoSEConstants inherits static props in FDLayoutConstants</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutConstants) {</span><span class="s3">\n  </span><span class="s1">CoSEConstants[prop] = FDLayoutConstants[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEConstants.DEFAULT_USE_MULTI_LEVEL_SCALING = false;</span><span class="s3">\n</span><span class="s1">CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n</span><span class="s1">CoSEConstants.DEFAULT_COMPONENT_SEPERATION = 60;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILE = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILING_PADDING_VERTICAL = 10;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TILING_PADDING_HORIZONTAL = 10;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.ENFORCE_CONSTRAINTS = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.APPLY_LAYOUT = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS = true;</span><span class="s3">\n</span><span class="s1">CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true; // this should be set to false if there will be a constraint</span><span class="s3">\n</span><span class="s1">// This constant is for differentiating whether actual layout algorithm that uses cose-base wants to apply only incremental layout or </span><span class="s3">\n</span><span class="s1">// an incremental layout on top of a randomized layout. If it is only incremental layout, then this constant should be true.</span><span class="s3">\n</span><span class="s1">CoSEConstants.PURE_INCREMENTAL = CoSEConstants.DEFAULT_INCREMENTAL;</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 767:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var FDLayoutEdge = __webpack_require__(551).FDLayoutEdge;</span><span class="s3">\n\n</span><span class="s1">function CoSEEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">FDLayoutEdge.call(this, source, target, vEdge);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEEdge.prototype = Object.create(FDLayoutEdge.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutEdge) {</span><span class="s3">\n  </span><span class="s1">CoSEEdge[prop] = FDLayoutEdge[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 880:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var LGraph = __webpack_require__(551).LGraph;</span><span class="s3">\n\n</span><span class="s1">function CoSEGraph(parent, graphMgr, vGraph) {</span><span class="s3">\n  </span><span class="s1">LGraph.call(this, parent, graphMgr, vGraph);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEGraph.prototype = Object.create(LGraph.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraph) {</span><span class="s3">\n  </span><span class="s1">CoSEGraph[prop] = LGraph[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEGraph;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 578:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var LGraphManager = __webpack_require__(551).LGraphManager;</span><span class="s3">\n\n</span><span class="s1">function CoSEGraphManager(layout) {</span><span class="s3">\n  </span><span class="s1">LGraphManager.call(this, layout);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSEGraphManager.prototype = Object.create(LGraphManager.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphManager) {</span><span class="s3">\n  </span><span class="s1">CoSEGraphManager[prop] = LGraphManager[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSEGraphManager;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 765:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var FDLayout = __webpack_require__(551).FDLayout;</span><span class="s3">\n</span><span class="s1">var CoSEGraphManager = __webpack_require__(578);</span><span class="s3">\n</span><span class="s1">var CoSEGraph = __webpack_require__(880);</span><span class="s3">\n</span><span class="s1">var CoSENode = __webpack_require__(991);</span><span class="s3">\n</span><span class="s1">var CoSEEdge = __webpack_require__(767);</span><span class="s3">\n</span><span class="s1">var CoSEConstants = __webpack_require__(806);</span><span class="s3">\n</span><span class="s1">var ConstraintHandler = __webpack_require__(902);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(551).FDLayoutConstants;</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(551).LayoutConstants;</span><span class="s3">\n</span><span class="s1">var Point = __webpack_require__(551).Point;</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(551).PointD;</span><span class="s3">\n</span><span class="s1">var DimensionD = __webpack_require__(551).DimensionD;</span><span class="s3">\n</span><span class="s1">var Layout = __webpack_require__(551).Layout;</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(551).Integer;</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(551).IGeometry;</span><span class="s3">\n</span><span class="s1">var LGraph = __webpack_require__(551).LGraph;</span><span class="s3">\n</span><span class="s1">var Transform = __webpack_require__(551).Transform;</span><span class="s3">\n</span><span class="s1">var LinkedList = __webpack_require__(551).LinkedList;</span><span class="s3">\n\n</span><span class="s1">function CoSELayout() {</span><span class="s3">\n  </span><span class="s1">FDLayout.call(this);</span><span class="s3">\n\n  </span><span class="s1">this.toBeTiled = {}; // Memorize if a node is to be tiled or is tiled</span><span class="s3">\n  </span><span class="s1">this.constraints = {}; // keep layout constraints</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype = Object.create(FDLayout.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in FDLayout) {</span><span class="s3">\n  </span><span class="s1">CoSELayout[prop] = FDLayout[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">var gm = new CoSEGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n  </span><span class="s1">return gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newGraph = function (vGraph) {</span><span class="s3">\n  </span><span class="s1">return new CoSEGraph(null, this.graphManager, vGraph);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newNode = function (vNode) {</span><span class="s3">\n  </span><span class="s1">return new CoSENode(this.graphManager, vNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.newEdge = function (vEdge) {</span><span class="s3">\n  </span><span class="s1">return new CoSEEdge(null, null, vEdge);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">FDLayout.prototype.initParameters.call(this, arguments);</span><span class="s3">\n  </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.DEFAULT_EDGE_LENGTH &lt; 10) {</span><span class="s3">\n      </span><span class="s1">this.idealEdgeLength = 10;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.idealEdgeLength = CoSEConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.useSmartIdealEdgeLengthCalculation = CoSEConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;</span><span class="s3">\n    </span><span class="s1">this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;</span><span class="s3">\n    </span><span class="s1">this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n    </span><span class="s1">this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n\n    </span><span class="s1">// variables for tree reduction support</span><span class="s3">\n    </span><span class="s1">this.prunedNodesAll = [];</span><span class="s3">\n    </span><span class="s1">this.growTreeIterations = 0;</span><span class="s3">\n    </span><span class="s1">this.afterGrowthIterations = 0;</span><span class="s3">\n    </span><span class="s1">this.isTreeGrowing = false;</span><span class="s3">\n    </span><span class="s1">this.isGrowthFinished = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// This method is used to set CoSE related parameters used by spring embedder.</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.initSpringEmbedder = function () {</span><span class="s3">\n  </span><span class="s1">FDLayout.prototype.initSpringEmbedder.call(this);</span><span class="s3">\n\n  </span><span class="s1">// variables for cooling</span><span class="s3">\n  </span><span class="s1">this.coolingCycle = 0;</span><span class="s3">\n  </span><span class="s1">this.maxCoolingCycle = this.maxIterations / FDLayoutConstants.CONVERGENCE_CHECK_PERIOD;</span><span class="s3">\n  </span><span class="s1">this.finalTemperature = 0.04;</span><span class="s3">\n  </span><span class="s1">this.coolingAdjuster = 1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.layout = function () {</span><span class="s3">\n  </span><span class="s1">var createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n  </span><span class="s1">if (createBendsAsNeeded) {</span><span class="s3">\n    </span><span class="s1">this.createBendpoints();</span><span class="s3">\n    </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.level = 0;</span><span class="s3">\n  </span><span class="s1">return this.classicLayout();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.classicLayout = function () {</span><span class="s3">\n  </span><span class="s1">this.nodesWithGravity = this.calculateNodesToApplyGravitationTo();</span><span class="s3">\n  </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(this.nodesWithGravity);</span><span class="s3">\n  </span><span class="s1">this.calcNoOfChildrenForAllNodes();</span><span class="s3">\n  </span><span class="s1">this.graphManager.calcLowestCommonAncestors();</span><span class="s3">\n  </span><span class="s1">this.graphManager.calcInclusionTreeDepths();</span><span class="s3">\n  </span><span class="s1">this.graphManager.getRoot().calcEstimatedSize();</span><span class="s3">\n  </span><span class="s1">this.calcIdealEdgeLengths();</span><span class="s3">\n\n  </span><span class="s1">if (!this.incremental) {</span><span class="s3">\n    </span><span class="s1">var forest = this.getFlatForest();</span><span class="s3">\n\n    </span><span class="s1">// The graph associated with this layout is flat and a forest</span><span class="s3">\n    </span><span class="s1">if (forest.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.positionNodesRadially(forest);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// The graph associated with this layout is not flat or a forest</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">// Reduce the trees when incremental mode is not enabled and graph is not a forest </span><span class="s3">\n        </span><span class="s1">this.reduceTrees();</span><span class="s3">\n        </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n        </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n        </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n        </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n          </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n\n        </span><span class="s1">this.positionNodesRandomly();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL) {</span><span class="s3">\n      </span><span class="s1">// Reduce the trees in incremental mode if only this constant is set to true </span><span class="s3">\n      </span><span class="s1">this.reduceTrees();</span><span class="s3">\n      </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n      </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n      </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n        </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Object.keys(this.constraints).length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">ConstraintHandler.handleConstraints(this);</span><span class="s3">\n    </span><span class="s1">this.initConstraintVariables();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.initSpringEmbedder();</span><span class="s3">\n  </span><span class="s1">if (CoSEConstants.APPLY_LAYOUT) {</span><span class="s3">\n    </span><span class="s1">this.runSpringEmbedder();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tick = function () {</span><span class="s3">\n  </span><span class="s1">this.totalIterations++;</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations === this.maxIterations &amp;&amp; !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.isTreeGrowing = true;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations % FDLayoutConstants.CONVERGENCE_CHECK_PERIOD == 0 &amp;&amp; !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.isConverged()) {</span><span class="s3">\n      </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">this.isTreeGrowing = true;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">return true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.coolingCycle++;</span><span class="s3">\n\n    </span><span class="s1">if (this.layoutQuality == 0) {</span><span class="s3">\n      </span><span class="s1">// quality - </span><span class="s3">\&quot;</span><span class="s1">draft</span><span class="s3">\&quot;\n      </span><span class="s1">this.coolingAdjuster = this.coolingCycle;</span><span class="s3">\n    </span><span class="s1">} else if (this.layoutQuality == 1) {</span><span class="s3">\n      </span><span class="s1">// quality - </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;\n      </span><span class="s1">this.coolingAdjuster = this.coolingCycle / 3;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// cooling schedule is based on http://www.btluke.com/simanf1.html -&gt; cooling schedule 3</span><span class="s3">\n    </span><span class="s1">this.coolingFactor = Math.max(this.initialCoolingFactor - Math.pow(this.coolingCycle, Math.log(100 * (this.initialCoolingFactor - this.finalTemperature)) / Math.log(this.maxCoolingCycle)) / 100 * this.coolingAdjuster, this.finalTemperature);</span><span class="s3">\n    </span><span class="s1">this.animationPeriod = Math.ceil(this.initialAnimationPeriod * Math.sqrt(this.coolingFactor));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Operations while tree is growing again </span><span class="s3">\n  </span><span class="s1">if (this.isTreeGrowing) {</span><span class="s3">\n    </span><span class="s1">if (this.growTreeIterations % 10 == 0) {</span><span class="s3">\n      </span><span class="s1">if (this.prunedNodesAll.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n        </span><span class="s1">this.updateGrid();</span><span class="s3">\n        </span><span class="s1">this.growTree(this.prunedNodesAll);</span><span class="s3">\n        </span><span class="s1">// Update nodes that gravity will be applied</span><span class="s3">\n        </span><span class="s1">this.graphManager.resetAllNodesToApplyGravitation();</span><span class="s3">\n        </span><span class="s1">var allNodes = new Set(this.getAllNodes());</span><span class="s3">\n        </span><span class="s1">var intersection = this.nodesWithGravity.filter(function (x) {</span><span class="s3">\n          </span><span class="s1">return allNodes.has(x);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">this.graphManager.setAllNodesToApplyGravitation(intersection);</span><span class="s3">\n\n        </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n        </span><span class="s1">this.updateGrid();</span><span class="s3">\n        </span><span class="s1">if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2;else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.isTreeGrowing = false;</span><span class="s3">\n        </span><span class="s1">this.isGrowthFinished = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.growTreeIterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Operations after growth is finished</span><span class="s3">\n  </span><span class="s1">if (this.isGrowthFinished) {</span><span class="s3">\n    </span><span class="s1">if (this.isConverged()) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.afterGrowthIterations % 10 == 0) {</span><span class="s3">\n      </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n      </span><span class="s1">this.updateGrid();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.PURE_INCREMENTAL) this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL / 2 * ((100 - this.afterGrowthIterations) / 100);else this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL * ((100 - this.afterGrowthIterations) / 100);</span><span class="s3">\n    </span><span class="s1">this.afterGrowthIterations++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var gridUpdateAllowed = !this.isTreeGrowing &amp;&amp; !this.isGrowthFinished;</span><span class="s3">\n  </span><span class="s1">var forceToNodeSurroundingUpdate = this.growTreeIterations % 10 == 1 &amp;&amp; this.isTreeGrowing || this.afterGrowthIterations % 10 == 1 &amp;&amp; this.isGrowthFinished;</span><span class="s3">\n\n  </span><span class="s1">this.totalDisplacement = 0;</span><span class="s3">\n  </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n  </span><span class="s1">this.calcSpringForces();</span><span class="s3">\n  </span><span class="s1">this.calcRepulsionForces(gridUpdateAllowed, forceToNodeSurroundingUpdate);</span><span class="s3">\n  </span><span class="s1">this.calcGravitationalForces();</span><span class="s3">\n  </span><span class="s1">this.moveNodes();</span><span class="s3">\n  </span><span class="s1">this.animate();</span><span class="s3">\n\n  </span><span class="s1">return false; // Layout is not ended yet return false</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.getPositionsData = function () {</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var pData = {};</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var rect = allNodes[i].rect;</span><span class="s3">\n    </span><span class="s1">var id = allNodes[i].id;</span><span class="s3">\n    </span><span class="s1">pData[id] = {</span><span class="s3">\n      </span><span class="s1">id: id,</span><span class="s3">\n      </span><span class="s1">x: rect.getCenterX(),</span><span class="s3">\n      </span><span class="s1">y: rect.getCenterY(),</span><span class="s3">\n      </span><span class="s1">w: rect.width,</span><span class="s3">\n      </span><span class="s1">h: rect.height</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return pData;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.runSpringEmbedder = function () {</span><span class="s3">\n  </span><span class="s1">this.initialAnimationPeriod = 25;</span><span class="s3">\n  </span><span class="s1">this.animationPeriod = this.initialAnimationPeriod;</span><span class="s3">\n  </span><span class="s1">var layoutEnded = false;</span><span class="s3">\n\n  </span><span class="s1">// If aminate option is 'during' signal that layout is supposed to start iterating</span><span class="s3">\n  </span><span class="s1">if (FDLayoutConstants.ANIMATE === 'during') {</span><span class="s3">\n    </span><span class="s1">this.emit('layoutstarted');</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// If aminate option is 'during' tick() function will be called on index.js</span><span class="s3">\n    </span><span class="s1">while (!layoutEnded) {</span><span class="s3">\n      </span><span class="s1">layoutEnded = this.tick();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.graphManager.updateBounds();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// overrides moveNodes method in FDLayout</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.moveNodes = function () {</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">// calculate displacement for each node </span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">node.calculateDisplacement();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Object.keys(this.constraints).length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">this.updateDisplacements();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// move each node</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">node.move();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// constraint related methods: initConstraintVariables and updateDisplacements</span><span class="s3">\n\n</span><span class="s1">// initialize constraint related variables</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.initConstraintVariables = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">this.idToNodeMap = new Map();</span><span class="s3">\n  </span><span class="s1">this.fixedNodeSet = new Set();</span><span class="s3">\n\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">// fill idToNodeMap</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">this.idToNodeMap.set(node.id, node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// calculate fixed node weight for given compound node</span><span class="s3">\n  </span><span class="s1">var calculateCompoundWeight = function calculateCompoundWeight(compoundNode) {</span><span class="s3">\n    </span><span class="s1">var nodes = compoundNode.getChild().getNodes();</span><span class="s3">\n    </span><span class="s1">var node;</span><span class="s3">\n    </span><span class="s1">var fixedNodeWeight = 0;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = nodes[i];</span><span class="s3">\n      </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n        </span><span class="s1">if (self.fixedNodeSet.has(node.id)) {</span><span class="s3">\n          </span><span class="s1">fixedNodeWeight += 100;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">fixedNodeWeight += calculateCompoundWeight(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return fixedNodeWeight;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">if (this.constraints.fixedNodeConstraint) {</span><span class="s3">\n    </span><span class="s1">// fill fixedNodeSet</span><span class="s3">\n    </span><span class="s1">this.constraints.fixedNodeConstraint.forEach(function (nodeData) {</span><span class="s3">\n      </span><span class="s1">self.fixedNodeSet.add(nodeData.nodeId);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// assign fixed node weights to compounds if they contain fixed nodes</span><span class="s3">\n    </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n    </span><span class="s1">var node;</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = allNodes[i];</span><span class="s3">\n      </span><span class="s1">if (node.getChild() != null) {</span><span class="s3">\n        </span><span class="s1">var fixedNodeWeight = calculateCompoundWeight(node);</span><span class="s3">\n        </span><span class="s1">if (fixedNodeWeight &gt; 0) {</span><span class="s3">\n          </span><span class="s1">node.fixedNodeWeight = fixedNodeWeight;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.constraints.relativePlacementConstraint) {</span><span class="s3">\n    </span><span class="s1">var nodeToDummyForVerticalAlignment = new Map();</span><span class="s3">\n    </span><span class="s1">var nodeToDummyForHorizontalAlignment = new Map();</span><span class="s3">\n    </span><span class="s1">this.dummyToNodeForVerticalAlignment = new Map();</span><span class="s3">\n    </span><span class="s1">this.dummyToNodeForHorizontalAlignment = new Map();</span><span class="s3">\n    </span><span class="s1">this.fixedNodesOnHorizontal = new Set();</span><span class="s3">\n    </span><span class="s1">this.fixedNodesOnVertical = new Set();</span><span class="s3">\n\n    </span><span class="s1">// fill maps and sets</span><span class="s3">\n    </span><span class="s1">this.fixedNodeSet.forEach(function (nodeId) {</span><span class="s3">\n      </span><span class="s1">self.fixedNodesOnHorizontal.add(nodeId);</span><span class="s3">\n      </span><span class="s1">self.fixedNodesOnVertical.add(nodeId);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (this.constraints.alignmentConstraint) {</span><span class="s3">\n      </span><span class="s1">if (this.constraints.alignmentConstraint.vertical) {</span><span class="s3">\n        </span><span class="s1">var verticalAlignment = this.constraints.alignmentConstraint.vertical;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; verticalAlignment.length; i++) {</span><span class="s3">\n          </span><span class="s1">this.dummyToNodeForVerticalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i, []);</span><span class="s3">\n          </span><span class="s1">verticalAlignment[i].forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">nodeToDummyForVerticalAlignment.set(nodeId, </span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n            </span><span class="s1">self.dummyToNodeForVerticalAlignment.get(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i).push(nodeId);</span><span class="s3">\n            </span><span class="s1">if (self.fixedNodeSet.has(nodeId)) {</span><span class="s3">\n              </span><span class="s1">self.fixedNodesOnHorizontal.add(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (this.constraints.alignmentConstraint.horizontal) {</span><span class="s3">\n        </span><span class="s1">var horizontalAlignment = this.constraints.alignmentConstraint.horizontal;</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; horizontalAlignment.length; i++) {</span><span class="s3">\n          </span><span class="s1">this.dummyToNodeForHorizontalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i, []);</span><span class="s3">\n          </span><span class="s1">horizontalAlignment[i].forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">nodeToDummyForHorizontalAlignment.set(nodeId, </span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n            </span><span class="s1">self.dummyToNodeForHorizontalAlignment.get(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i).push(nodeId);</span><span class="s3">\n            </span><span class="s1">if (self.fixedNodeSet.has(nodeId)) {</span><span class="s3">\n              </span><span class="s1">self.fixedNodesOnVertical.add(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {</span><span class="s3">\n\n      </span><span class="s1">this.shuffle = function (array) {</span><span class="s3">\n        </span><span class="s1">var j, x, i;</span><span class="s3">\n        </span><span class="s1">for (i = array.length - 1; i &gt;= 2 * array.length / 3; i--) {</span><span class="s3">\n          </span><span class="s1">j = Math.floor(Math.random() * (i + 1));</span><span class="s3">\n          </span><span class="s1">x = array[i];</span><span class="s3">\n          </span><span class="s1">array[i] = array[j];</span><span class="s3">\n          </span><span class="s1">array[j] = x;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return array;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">this.nodesInRelativeHorizontal = [];</span><span class="s3">\n      </span><span class="s1">this.nodesInRelativeVertical = [];</span><span class="s3">\n      </span><span class="s1">this.nodeToRelativeConstraintMapHorizontal = new Map();</span><span class="s3">\n      </span><span class="s1">this.nodeToRelativeConstraintMapVertical = new Map();</span><span class="s3">\n      </span><span class="s1">this.nodeToTempPositionMapHorizontal = new Map();</span><span class="s3">\n      </span><span class="s1">this.nodeToTempPositionMapVertical = new Map();</span><span class="s3">\n\n      </span><span class="s1">// fill arrays and maps</span><span class="s3">\n      </span><span class="s1">this.constraints.relativePlacementConstraint.forEach(function (constraint) {</span><span class="s3">\n        </span><span class="s1">if (constraint.left) {</span><span class="s3">\n          </span><span class="s1">var nodeIdLeft = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;</span><span class="s3">\n          </span><span class="s1">var nodeIdRight = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;</span><span class="s3">\n\n          </span><span class="s1">if (!self.nodesInRelativeHorizontal.includes(nodeIdLeft)) {</span><span class="s3">\n            </span><span class="s1">self.nodesInRelativeHorizontal.push(nodeIdLeft);</span><span class="s3">\n            </span><span class="s1">self.nodeToRelativeConstraintMapHorizontal.set(nodeIdLeft, []);</span><span class="s3">\n            </span><span class="s1">if (self.dummyToNodeForVerticalAlignment.has(nodeIdLeft)) {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdLeft)[0]).getCenterX());</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapHorizontal.set(nodeIdLeft, self.idToNodeMap.get(nodeIdLeft).getCenterX());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!self.nodesInRelativeHorizontal.includes(nodeIdRight)) {</span><span class="s3">\n            </span><span class="s1">self.nodesInRelativeHorizontal.push(nodeIdRight);</span><span class="s3">\n            </span><span class="s1">self.nodeToRelativeConstraintMapHorizontal.set(nodeIdRight, []);</span><span class="s3">\n            </span><span class="s1">if (self.dummyToNodeForVerticalAlignment.has(nodeIdRight)) {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeIdRight)[0]).getCenterX());</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapHorizontal.set(nodeIdRight, self.idToNodeMap.get(nodeIdRight).getCenterX());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">self.nodeToRelativeConstraintMapHorizontal.get(nodeIdLeft).push({ right: nodeIdRight, gap: constraint.gap });</span><span class="s3">\n          </span><span class="s1">self.nodeToRelativeConstraintMapHorizontal.get(nodeIdRight).push({ left: nodeIdLeft, gap: constraint.gap });</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var nodeIdTop = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;</span><span class="s3">\n          </span><span class="s1">var nodeIdBottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;</span><span class="s3">\n\n          </span><span class="s1">if (!self.nodesInRelativeVertical.includes(nodeIdTop)) {</span><span class="s3">\n            </span><span class="s1">self.nodesInRelativeVertical.push(nodeIdTop);</span><span class="s3">\n            </span><span class="s1">self.nodeToRelativeConstraintMapVertical.set(nodeIdTop, []);</span><span class="s3">\n            </span><span class="s1">if (self.dummyToNodeForHorizontalAlignment.has(nodeIdTop)) {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdTop)[0]).getCenterY());</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapVertical.set(nodeIdTop, self.idToNodeMap.get(nodeIdTop).getCenterY());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (!self.nodesInRelativeVertical.includes(nodeIdBottom)) {</span><span class="s3">\n            </span><span class="s1">self.nodesInRelativeVertical.push(nodeIdBottom);</span><span class="s3">\n            </span><span class="s1">self.nodeToRelativeConstraintMapVertical.set(nodeIdBottom, []);</span><span class="s3">\n            </span><span class="s1">if (self.dummyToNodeForHorizontalAlignment.has(nodeIdBottom)) {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeIdBottom)[0]).getCenterY());</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">self.nodeToTempPositionMapVertical.set(nodeIdBottom, self.idToNodeMap.get(nodeIdBottom).getCenterY());</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">self.nodeToRelativeConstraintMapVertical.get(nodeIdTop).push({ bottom: nodeIdBottom, gap: constraint.gap });</span><span class="s3">\n          </span><span class="s1">self.nodeToRelativeConstraintMapVertical.get(nodeIdBottom).push({ top: nodeIdTop, gap: constraint.gap });</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var subGraphOnHorizontal = new Map(); // subgraph from vertical RP constraints</span><span class="s3">\n      </span><span class="s1">var subGraphOnVertical = new Map(); // subgraph from vertical RP constraints</span><span class="s3">\n\n      </span><span class="s1">// construct subgraphs from relative placement constraints </span><span class="s3">\n      </span><span class="s1">this.constraints.relativePlacementConstraint.forEach(function (constraint) {</span><span class="s3">\n        </span><span class="s1">if (constraint.left) {</span><span class="s3">\n          </span><span class="s1">var left = nodeToDummyForVerticalAlignment.has(constraint.left) ? nodeToDummyForVerticalAlignment.get(constraint.left) : constraint.left;</span><span class="s3">\n          </span><span class="s1">var right = nodeToDummyForVerticalAlignment.has(constraint.right) ? nodeToDummyForVerticalAlignment.get(constraint.right) : constraint.right;</span><span class="s3">\n          </span><span class="s1">if (subGraphOnHorizontal.has(left)) {</span><span class="s3">\n            </span><span class="s1">subGraphOnHorizontal.get(left).push(right);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">subGraphOnHorizontal.set(left, [right]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (subGraphOnHorizontal.has(right)) {</span><span class="s3">\n            </span><span class="s1">subGraphOnHorizontal.get(right).push(left);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">subGraphOnHorizontal.set(right, [left]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var top = nodeToDummyForHorizontalAlignment.has(constraint.top) ? nodeToDummyForHorizontalAlignment.get(constraint.top) : constraint.top;</span><span class="s3">\n          </span><span class="s1">var bottom = nodeToDummyForHorizontalAlignment.has(constraint.bottom) ? nodeToDummyForHorizontalAlignment.get(constraint.bottom) : constraint.bottom;</span><span class="s3">\n          </span><span class="s1">if (subGraphOnVertical.has(top)) {</span><span class="s3">\n            </span><span class="s1">subGraphOnVertical.get(top).push(bottom);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">subGraphOnVertical.set(top, [bottom]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (subGraphOnVertical.has(bottom)) {</span><span class="s3">\n            </span><span class="s1">subGraphOnVertical.get(bottom).push(top);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">subGraphOnVertical.set(bottom, [top]);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">// function to construct components from a given graph </span><span class="s3">\n      </span><span class="s1">// also returns an array that keeps whether each component contains fixed node</span><span class="s3">\n      </span><span class="s1">var constructComponents = function constructComponents(graph, fixedNodes) {</span><span class="s3">\n        </span><span class="s1">var components = [];</span><span class="s3">\n        </span><span class="s1">var isFixed = [];</span><span class="s3">\n        </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n        </span><span class="s1">var visited = new Set();</span><span class="s3">\n        </span><span class="s1">var count = 0;</span><span class="s3">\n\n        </span><span class="s1">graph.forEach(function (value, key) {</span><span class="s3">\n          </span><span class="s1">if (!visited.has(key)) {</span><span class="s3">\n            </span><span class="s1">components[count] = [];</span><span class="s3">\n            </span><span class="s1">isFixed[count] = false;</span><span class="s3">\n            </span><span class="s1">var currentNode = key;</span><span class="s3">\n            </span><span class="s1">queue.push(currentNode);</span><span class="s3">\n            </span><span class="s1">visited.add(currentNode);</span><span class="s3">\n            </span><span class="s1">components[count].push(currentNode);</span><span class="s3">\n\n            </span><span class="s1">while (queue.length != 0) {</span><span class="s3">\n              </span><span class="s1">currentNode = queue.shift();</span><span class="s3">\n              </span><span class="s1">if (fixedNodes.has(currentNode)) {</span><span class="s3">\n                </span><span class="s1">isFixed[count] = true;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">var neighbors = graph.get(currentNode);</span><span class="s3">\n              </span><span class="s1">neighbors.forEach(function (neighbor) {</span><span class="s3">\n                </span><span class="s1">if (!visited.has(neighbor)) {</span><span class="s3">\n                  </span><span class="s1">queue.push(neighbor);</span><span class="s3">\n                  </span><span class="s1">visited.add(neighbor);</span><span class="s3">\n                  </span><span class="s1">components[count].push(neighbor);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">count++;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">return { components: components, isFixed: isFixed };</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n\n      </span><span class="s1">var resultOnHorizontal = constructComponents(subGraphOnHorizontal, self.fixedNodesOnHorizontal);</span><span class="s3">\n      </span><span class="s1">this.componentsOnHorizontal = resultOnHorizontal.components;</span><span class="s3">\n      </span><span class="s1">this.fixedComponentsOnHorizontal = resultOnHorizontal.isFixed;</span><span class="s3">\n      </span><span class="s1">var resultOnVertical = constructComponents(subGraphOnVertical, self.fixedNodesOnVertical);</span><span class="s3">\n      </span><span class="s1">this.componentsOnVertical = resultOnVertical.components;</span><span class="s3">\n      </span><span class="s1">this.fixedComponentsOnVertical = resultOnVertical.isFixed;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// updates node displacements based on constraints</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.updateDisplacements = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">if (this.constraints.fixedNodeConstraint) {</span><span class="s3">\n    </span><span class="s1">this.constraints.fixedNodeConstraint.forEach(function (nodeData) {</span><span class="s3">\n      </span><span class="s1">var fixedNode = self.idToNodeMap.get(nodeData.nodeId);</span><span class="s3">\n      </span><span class="s1">fixedNode.displacementX = 0;</span><span class="s3">\n      </span><span class="s1">fixedNode.displacementY = 0;</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.constraints.alignmentConstraint) {</span><span class="s3">\n    </span><span class="s1">if (this.constraints.alignmentConstraint.vertical) {</span><span class="s3">\n      </span><span class="s1">var allVerticalAlignments = this.constraints.alignmentConstraint.vertical;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; allVerticalAlignments.length; i++) {</span><span class="s3">\n        </span><span class="s1">var totalDisplacementX = 0;</span><span class="s3">\n        </span><span class="s1">for (var j = 0; j &lt; allVerticalAlignments[i].length; j++) {</span><span class="s3">\n          </span><span class="s1">if (this.fixedNodeSet.has(allVerticalAlignments[i][j])) {</span><span class="s3">\n            </span><span class="s1">totalDisplacementX = 0;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">totalDisplacementX += this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var averageDisplacementX = totalDisplacementX / allVerticalAlignments[i].length;</span><span class="s3">\n        </span><span class="s1">for (var j = 0; j &lt; allVerticalAlignments[i].length; j++) {</span><span class="s3">\n          </span><span class="s1">this.idToNodeMap.get(allVerticalAlignments[i][j]).displacementX = averageDisplacementX;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.constraints.alignmentConstraint.horizontal) {</span><span class="s3">\n      </span><span class="s1">var allHorizontalAlignments = this.constraints.alignmentConstraint.horizontal;</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; allHorizontalAlignments.length; i++) {</span><span class="s3">\n        </span><span class="s1">var totalDisplacementY = 0;</span><span class="s3">\n        </span><span class="s1">for (var j = 0; j &lt; allHorizontalAlignments[i].length; j++) {</span><span class="s3">\n          </span><span class="s1">if (this.fixedNodeSet.has(allHorizontalAlignments[i][j])) {</span><span class="s3">\n            </span><span class="s1">totalDisplacementY = 0;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">totalDisplacementY += this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var averageDisplacementY = totalDisplacementY / allHorizontalAlignments[i].length;</span><span class="s3">\n        </span><span class="s1">for (var j = 0; j &lt; allHorizontalAlignments[i].length; j++) {</span><span class="s3">\n          </span><span class="s1">this.idToNodeMap.get(allHorizontalAlignments[i][j]).displacementY = averageDisplacementY;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.constraints.relativePlacementConstraint) {</span><span class="s3">\n\n    </span><span class="s1">if (CoSEConstants.RELAX_MOVEMENT_ON_CONSTRAINTS) {</span><span class="s3">\n      </span><span class="s1">// shuffle array to randomize node processing order</span><span class="s3">\n      </span><span class="s1">if (this.totalIterations % 10 == 0) {</span><span class="s3">\n        </span><span class="s1">this.shuffle(this.nodesInRelativeHorizontal);</span><span class="s3">\n        </span><span class="s1">this.shuffle(this.nodesInRelativeVertical);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.nodesInRelativeHorizontal.forEach(function (nodeId) {</span><span class="s3">\n        </span><span class="s1">if (!self.fixedNodesOnHorizontal.has(nodeId)) {</span><span class="s3">\n          </span><span class="s1">var displacement = 0;</span><span class="s3">\n          </span><span class="s1">if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">displacement = self.idToNodeMap.get(self.dummyToNodeForVerticalAlignment.get(nodeId)[0]).displacementX;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">displacement = self.idToNodeMap.get(nodeId).displacementX;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">self.nodeToRelativeConstraintMapHorizontal.get(nodeId).forEach(function (constraint) {</span><span class="s3">\n            </span><span class="s1">if (constraint.right) {</span><span class="s3">\n              </span><span class="s1">var diff = self.nodeToTempPositionMapHorizontal.get(constraint.right) - self.nodeToTempPositionMapHorizontal.get(nodeId) - displacement;</span><span class="s3">\n              </span><span class="s1">if (diff &lt; constraint.gap) {</span><span class="s3">\n                </span><span class="s1">displacement -= constraint.gap - diff;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">var diff = self.nodeToTempPositionMapHorizontal.get(nodeId) - self.nodeToTempPositionMapHorizontal.get(constraint.left) + displacement;</span><span class="s3">\n              </span><span class="s1">if (diff &lt; constraint.gap) {</span><span class="s3">\n                </span><span class="s1">displacement += constraint.gap - diff;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">self.nodeToTempPositionMapHorizontal.set(nodeId, self.nodeToTempPositionMapHorizontal.get(nodeId) + displacement);</span><span class="s3">\n          </span><span class="s1">if (self.dummyToNodeForVerticalAlignment.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">self.dummyToNodeForVerticalAlignment.get(nodeId).forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">self.idToNodeMap.get(nodeId).displacementX = displacement;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">self.idToNodeMap.get(nodeId).displacementX = displacement;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">this.nodesInRelativeVertical.forEach(function (nodeId) {</span><span class="s3">\n        </span><span class="s1">if (!self.fixedNodesOnHorizontal.has(nodeId)) {</span><span class="s3">\n          </span><span class="s1">var displacement = 0;</span><span class="s3">\n          </span><span class="s1">if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">displacement = self.idToNodeMap.get(self.dummyToNodeForHorizontalAlignment.get(nodeId)[0]).displacementY;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">displacement = self.idToNodeMap.get(nodeId).displacementY;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">self.nodeToRelativeConstraintMapVertical.get(nodeId).forEach(function (constraint) {</span><span class="s3">\n            </span><span class="s1">if (constraint.bottom) {</span><span class="s3">\n              </span><span class="s1">var diff = self.nodeToTempPositionMapVertical.get(constraint.bottom) - self.nodeToTempPositionMapVertical.get(nodeId) - displacement;</span><span class="s3">\n              </span><span class="s1">if (diff &lt; constraint.gap) {</span><span class="s3">\n                </span><span class="s1">displacement -= constraint.gap - diff;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">var diff = self.nodeToTempPositionMapVertical.get(nodeId) - self.nodeToTempPositionMapVertical.get(constraint.top) + displacement;</span><span class="s3">\n              </span><span class="s1">if (diff &lt; constraint.gap) {</span><span class="s3">\n                </span><span class="s1">displacement += constraint.gap - diff;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">self.nodeToTempPositionMapVertical.set(nodeId, self.nodeToTempPositionMapVertical.get(nodeId) + displacement);</span><span class="s3">\n          </span><span class="s1">if (self.dummyToNodeForHorizontalAlignment.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">self.dummyToNodeForHorizontalAlignment.get(nodeId).forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">self.idToNodeMap.get(nodeId).displacementY = displacement;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">self.idToNodeMap.get(nodeId).displacementY = displacement;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; this.componentsOnHorizontal.length; i++) {</span><span class="s3">\n        </span><span class="s1">var component = this.componentsOnHorizontal[i];</span><span class="s3">\n        </span><span class="s1">if (this.fixedComponentsOnHorizontal[i]) {</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForVerticalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">self.idToNodeMap.get(nodeId).displacementX = 0;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">this.idToNodeMap.get(component[j]).displacementX = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var sum = 0;</span><span class="s3">\n          </span><span class="s1">var count = 0;</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForVerticalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">var actualNodes = this.dummyToNodeForVerticalAlignment.get(component[j]);</span><span class="s3">\n              </span><span class="s1">sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementX;</span><span class="s3">\n              </span><span class="s1">count += actualNodes.length;</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">sum += this.idToNodeMap.get(component[j]).displacementX;</span><span class="s3">\n              </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var averageDisplacement = sum / count;</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForVerticalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">this.dummyToNodeForVerticalAlignment.get(component[j]).forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">self.idToNodeMap.get(nodeId).displacementX = averageDisplacement;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">this.idToNodeMap.get(component[j]).displacementX = averageDisplacement;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; this.componentsOnVertical.length; i++) {</span><span class="s3">\n        </span><span class="s1">var component = this.componentsOnVertical[i];</span><span class="s3">\n        </span><span class="s1">if (this.fixedComponentsOnVertical[i]) {</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">self.idToNodeMap.get(nodeId).displacementY = 0;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">this.idToNodeMap.get(component[j]).displacementY = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var sum = 0;</span><span class="s3">\n          </span><span class="s1">var count = 0;</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">var actualNodes = this.dummyToNodeForHorizontalAlignment.get(component[j]);</span><span class="s3">\n              </span><span class="s1">sum += actualNodes.length * this.idToNodeMap.get(actualNodes[0]).displacementY;</span><span class="s3">\n              </span><span class="s1">count += actualNodes.length;</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">sum += this.idToNodeMap.get(component[j]).displacementY;</span><span class="s3">\n              </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var averageDisplacement = sum / count;</span><span class="s3">\n          </span><span class="s1">for (var j = 0; j &lt; component.length; j++) {</span><span class="s3">\n            </span><span class="s1">if (this.dummyToNodeForHorizontalAlignment.has(component[j])) {</span><span class="s3">\n              </span><span class="s1">this.dummyToNodeForHorizontalAlignment.get(component[j]).forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">self.idToNodeMap.get(nodeId).displacementY = averageDisplacement;</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">this.idToNodeMap.get(component[j]).displacementY = averageDisplacement;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.calculateNodesToApplyGravitationTo = function () {</span><span class="s3">\n  </span><span class="s1">var nodeList = [];</span><span class="s3">\n  </span><span class="s1">var graph;</span><span class="s3">\n\n  </span><span class="s1">var graphs = this.graphManager.getGraphs();</span><span class="s3">\n  </span><span class="s1">var size = graphs.length;</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; size; i++) {</span><span class="s3">\n    </span><span class="s1">graph = graphs[i];</span><span class="s3">\n\n    </span><span class="s1">graph.updateConnected();</span><span class="s3">\n\n    </span><span class="s1">if (!graph.isConnected) {</span><span class="s3">\n      </span><span class="s1">nodeList = nodeList.concat(graph.getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return nodeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.createBendpoints = function () {</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">edges = edges.concat(this.graphManager.getAllEdges());</span><span class="s3">\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n\n    </span><span class="s1">if (!visited.has(edge)) {</span><span class="s3">\n      </span><span class="s1">var source = edge.getSource();</span><span class="s3">\n      </span><span class="s1">var target = edge.getTarget();</span><span class="s3">\n\n      </span><span class="s1">if (source == target) {</span><span class="s3">\n        </span><span class="s1">edge.getBendpoints().push(new PointD());</span><span class="s3">\n        </span><span class="s1">edge.getBendpoints().push(new PointD());</span><span class="s3">\n        </span><span class="s1">this.createDummyNodesForBendpoints(edge);</span><span class="s3">\n        </span><span class="s1">visited.add(edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var edgeList = [];</span><span class="s3">\n\n        </span><span class="s1">edgeList = edgeList.concat(source.getEdgeListToNode(target));</span><span class="s3">\n        </span><span class="s1">edgeList = edgeList.concat(target.getEdgeListToNode(source));</span><span class="s3">\n\n        </span><span class="s1">if (!visited.has(edgeList[0])) {</span><span class="s3">\n          </span><span class="s1">if (edgeList.length &gt; 1) {</span><span class="s3">\n            </span><span class="s1">var k;</span><span class="s3">\n            </span><span class="s1">for (k = 0; k &lt; edgeList.length; k++) {</span><span class="s3">\n              </span><span class="s1">var multiEdge = edgeList[k];</span><span class="s3">\n              </span><span class="s1">multiEdge.getBendpoints().push(new PointD());</span><span class="s3">\n              </span><span class="s1">this.createDummyNodesForBendpoints(multiEdge);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">edgeList.forEach(function (edge) {</span><span class="s3">\n            </span><span class="s1">visited.add(edge);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (visited.size == edges.length) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.positionNodesRadially = function (forest) {</span><span class="s3">\n  </span><span class="s1">// We tile the trees to a grid row by row; first tree starts at (0,0)</span><span class="s3">\n  </span><span class="s1">var currentStartingPoint = new Point(0, 0);</span><span class="s3">\n  </span><span class="s1">var numberOfColumns = Math.ceil(Math.sqrt(forest.length));</span><span class="s3">\n  </span><span class="s1">var height = 0;</span><span class="s3">\n  </span><span class="s1">var currentY = 0;</span><span class="s3">\n  </span><span class="s1">var currentX = 0;</span><span class="s3">\n  </span><span class="s1">var point = new PointD(0, 0);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; forest.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (i % numberOfColumns == 0) {</span><span class="s3">\n      </span><span class="s1">// Start of a new row, make the x coordinate 0, increment the</span><span class="s3">\n      </span><span class="s1">// y coordinate with the max height of the previous row</span><span class="s3">\n      </span><span class="s1">currentX = 0;</span><span class="s3">\n      </span><span class="s1">currentY = height;</span><span class="s3">\n\n      </span><span class="s1">if (i != 0) {</span><span class="s3">\n        </span><span class="s1">currentY += CoSEConstants.DEFAULT_COMPONENT_SEPERATION;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">height = 0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var tree = forest[i];</span><span class="s3">\n\n    </span><span class="s1">// Find the center of the tree</span><span class="s3">\n    </span><span class="s1">var centerNode = Layout.findCenterOfTree(tree);</span><span class="s3">\n\n    </span><span class="s1">// Set the staring point of the next tree</span><span class="s3">\n    </span><span class="s1">currentStartingPoint.x = currentX;</span><span class="s3">\n    </span><span class="s1">currentStartingPoint.y = currentY;</span><span class="s3">\n\n    </span><span class="s1">// Do a radial layout starting with the center</span><span class="s3">\n    </span><span class="s1">point = CoSELayout.radialLayout(tree, centerNode, currentStartingPoint);</span><span class="s3">\n\n    </span><span class="s1">if (point.y &gt; height) {</span><span class="s3">\n      </span><span class="s1">height = Math.floor(point.y);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">currentX = Math.floor(point.x + CoSEConstants.DEFAULT_COMPONENT_SEPERATION);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.transform(new PointD(LayoutConstants.WORLD_CENTER_X - point.x / 2, LayoutConstants.WORLD_CENTER_Y - point.y / 2));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.radialLayout = function (tree, centerNode, startingPoint) {</span><span class="s3">\n  </span><span class="s1">var radialSep = Math.max(this.maxDiagonalInTree(tree), CoSEConstants.DEFAULT_RADIAL_SEPARATION);</span><span class="s3">\n  </span><span class="s1">CoSELayout.branchRadialLayout(centerNode, null, 0, 359, 0, radialSep);</span><span class="s3">\n  </span><span class="s1">var bounds = LGraph.calculateBounds(tree);</span><span class="s3">\n\n  </span><span class="s1">var transform = new Transform();</span><span class="s3">\n  </span><span class="s1">transform.setDeviceOrgX(bounds.getMinX());</span><span class="s3">\n  </span><span class="s1">transform.setDeviceOrgY(bounds.getMinY());</span><span class="s3">\n  </span><span class="s1">transform.setWorldOrgX(startingPoint.x);</span><span class="s3">\n  </span><span class="s1">transform.setWorldOrgY(startingPoint.y);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = tree[i];</span><span class="s3">\n    </span><span class="s1">node.transform(transform);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var bottomRight = new PointD(bounds.getMaxX(), bounds.getMaxY());</span><span class="s3">\n\n  </span><span class="s1">return transform.inverseTransformPoint(bottomRight);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.branchRadialLayout = function (node, parentOfNode, startAngle, endAngle, distance, radialSeparation) {</span><span class="s3">\n  </span><span class="s1">// First, position this node by finding its angle.</span><span class="s3">\n  </span><span class="s1">var halfInterval = (endAngle - startAngle + 1) / 2;</span><span class="s3">\n\n  </span><span class="s1">if (halfInterval &lt; 0) {</span><span class="s3">\n    </span><span class="s1">halfInterval += 180;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var nodeAngle = (halfInterval + startAngle) % 360;</span><span class="s3">\n  </span><span class="s1">var teta = nodeAngle * IGeometry.TWO_PI / 360;</span><span class="s3">\n\n  </span><span class="s1">// Make polar to java cordinate conversion.</span><span class="s3">\n  </span><span class="s1">var cos_teta = Math.cos(teta);</span><span class="s3">\n  </span><span class="s1">var x_ = distance * Math.cos(teta);</span><span class="s3">\n  </span><span class="s1">var y_ = distance * Math.sin(teta);</span><span class="s3">\n\n  </span><span class="s1">node.setCenter(x_, y_);</span><span class="s3">\n\n  </span><span class="s1">// Traverse all neighbors of this node and recursively call this</span><span class="s3">\n  </span><span class="s1">// function.</span><span class="s3">\n  </span><span class="s1">var neighborEdges = [];</span><span class="s3">\n  </span><span class="s1">neighborEdges = neighborEdges.concat(node.getEdges());</span><span class="s3">\n  </span><span class="s1">var childCount = neighborEdges.length;</span><span class="s3">\n\n  </span><span class="s1">if (parentOfNode != null) {</span><span class="s3">\n    </span><span class="s1">childCount--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var branchCount = 0;</span><span class="s3">\n\n  </span><span class="s1">var incEdgesCount = neighborEdges.length;</span><span class="s3">\n  </span><span class="s1">var startIndex;</span><span class="s3">\n\n  </span><span class="s1">var edges = node.getEdgesBetween(parentOfNode);</span><span class="s3">\n\n  </span><span class="s1">// If there are multiple edges, prune them until there remains only one</span><span class="s3">\n  </span><span class="s1">// edge.</span><span class="s3">\n  </span><span class="s1">while (edges.length &gt; 1) {</span><span class="s3">\n    </span><span class="s1">//neighborEdges.remove(edges.remove(0));</span><span class="s3">\n    </span><span class="s1">var temp = edges[0];</span><span class="s3">\n    </span><span class="s1">edges.splice(0, 1);</span><span class="s3">\n    </span><span class="s1">var index = neighborEdges.indexOf(temp);</span><span class="s3">\n    </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n      </span><span class="s1">neighborEdges.splice(index, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">incEdgesCount--;</span><span class="s3">\n    </span><span class="s1">childCount--;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (parentOfNode != null) {</span><span class="s3">\n    </span><span class="s1">//assert edges.length == 1;</span><span class="s3">\n    </span><span class="s1">startIndex = (neighborEdges.indexOf(edges[0]) + 1) % incEdgesCount;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">startIndex = 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var stepAngle = Math.abs(endAngle - startAngle) / childCount;</span><span class="s3">\n\n  </span><span class="s1">for (var i = startIndex; branchCount != childCount; i = ++i % incEdgesCount) {</span><span class="s3">\n    </span><span class="s1">var currentNeighbor = neighborEdges[i].getOtherEnd(node);</span><span class="s3">\n\n    </span><span class="s1">// Don't back traverse to root node in current tree.</span><span class="s3">\n    </span><span class="s1">if (currentNeighbor == parentOfNode) {</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var childStartAngle = (startAngle + branchCount * stepAngle) % 360;</span><span class="s3">\n    </span><span class="s1">var childEndAngle = (childStartAngle + stepAngle) % 360;</span><span class="s3">\n\n    </span><span class="s1">CoSELayout.branchRadialLayout(currentNeighbor, node, childStartAngle, childEndAngle, distance + radialSeparation, radialSeparation);</span><span class="s3">\n\n    </span><span class="s1">branchCount++;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.maxDiagonalInTree = function (tree) {</span><span class="s3">\n  </span><span class="s1">var maxDiagonal = Integer.MIN_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; tree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = tree[i];</span><span class="s3">\n    </span><span class="s1">var diagonal = node.getDiagonal();</span><span class="s3">\n\n    </span><span class="s1">if (diagonal &gt; maxDiagonal) {</span><span class="s3">\n      </span><span class="s1">maxDiagonal = diagonal;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return maxDiagonal;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.calcRepulsionRange = function () {</span><span class="s3">\n  </span><span class="s1">// formula is 2 x (level + 1) x idealEdgeLength</span><span class="s3">\n  </span><span class="s1">return 2 * (this.level + 1) * this.idealEdgeLength;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Tiling methods</span><span class="s3">\n\n</span><span class="s1">// Group zero degree members whose parents are not to be tiled, create dummy parents where needed and fill memberGroups by their dummp parent id's</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.groupZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">// array of [parent_id x oneDegreeNode_id]</span><span class="s3">\n  </span><span class="s1">var tempMemberGroups = {}; // A temporary map of parent node and its zero degree members</span><span class="s3">\n  </span><span class="s1">this.memberGroups = {}; // A map of dummy parent node and its zero degree members whose parents are not to be tiled</span><span class="s3">\n  </span><span class="s1">this.idToDummyNode = {}; // A map of id to dummy node </span><span class="s3">\n\n  </span><span class="s1">var zeroDegree = []; // List of zero degree nodes whose parents are not to be tiled</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">// Fill zero degree list</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">var parent = node.getParent();</span><span class="s3">\n    </span><span class="s1">// If a node has zero degree and its parent is not to be tiled if exists add that node to zeroDegres list</span><span class="s3">\n    </span><span class="s1">if (this.getNodeDegreeWithChildren(node) === 0 &amp;&amp; (parent.id == undefined || !this.getToBeTiled(parent))) {</span><span class="s3">\n      </span><span class="s1">zeroDegree.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Create a map of parent node and its zero degree members</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; zeroDegree.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = zeroDegree[i]; // Zero degree node itself</span><span class="s3">\n    </span><span class="s1">var p_id = node.getParent().id; // Parent id</span><span class="s3">\n\n    </span><span class="s1">if (typeof tempMemberGroups[p_id] === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot;</span><span class="s1">) tempMemberGroups[p_id] = [];</span><span class="s3">\n\n    </span><span class="s1">tempMemberGroups[p_id] = tempMemberGroups[p_id].concat(node); // Push node to the list belongs to its parent in tempMemberGroups</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// If there are at least two nodes at a level, create a dummy compound for them</span><span class="s3">\n  </span><span class="s1">Object.keys(tempMemberGroups).forEach(function (p_id) {</span><span class="s3">\n    </span><span class="s1">if (tempMemberGroups[p_id].length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">var dummyCompoundId = </span><span class="s3">\&quot;</span><span class="s1">DummyCompound_</span><span class="s3">\&quot; </span><span class="s1">+ p_id; // The id of dummy compound which will be created soon</span><span class="s3">\n      </span><span class="s1">self.memberGroups[dummyCompoundId] = tempMemberGroups[p_id]; // Add dummy compound to memberGroups</span><span class="s3">\n\n      </span><span class="s1">var parent = tempMemberGroups[p_id][0].getParent(); // The parent of zero degree nodes will be the parent of new dummy compound</span><span class="s3">\n\n      </span><span class="s1">// Create a dummy compound with calculated id</span><span class="s3">\n      </span><span class="s1">var dummyCompound = new CoSENode(self.graphManager);</span><span class="s3">\n      </span><span class="s1">dummyCompound.id = dummyCompoundId;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingLeft = parent.paddingLeft || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingRight = parent.paddingRight || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingBottom = parent.paddingBottom || 0;</span><span class="s3">\n      </span><span class="s1">dummyCompound.paddingTop = parent.paddingTop || 0;</span><span class="s3">\n\n      </span><span class="s1">self.idToDummyNode[dummyCompoundId] = dummyCompound;</span><span class="s3">\n\n      </span><span class="s1">var dummyParentGraph = self.getGraphManager().add(self.newGraph(), dummyCompound);</span><span class="s3">\n      </span><span class="s1">var parentGraph = parent.getChild();</span><span class="s3">\n\n      </span><span class="s1">// Add dummy compound to parent the graph</span><span class="s3">\n      </span><span class="s1">parentGraph.add(dummyCompound);</span><span class="s3">\n\n      </span><span class="s1">// For each zero degree node in this level remove it from its parent graph and add it to the graph of dummy parent</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; tempMemberGroups[p_id].length; i++) {</span><span class="s3">\n        </span><span class="s1">var node = tempMemberGroups[p_id][i];</span><span class="s3">\n\n        </span><span class="s1">parentGraph.remove(node);</span><span class="s3">\n        </span><span class="s1">dummyParentGraph.add(node);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.clearCompounds = function () {</span><span class="s3">\n  </span><span class="s1">var childGraphMap = {};</span><span class="s3">\n  </span><span class="s1">var idToNode = {};</span><span class="s3">\n\n  </span><span class="s1">// Get compound ordering by finding the inner one first</span><span class="s3">\n  </span><span class="s1">this.performDFSOnCompounds();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; this.compoundOrder.length; i++) {</span><span class="s3">\n\n    </span><span class="s1">idToNode[this.compoundOrder[i].id] = this.compoundOrder[i];</span><span class="s3">\n    </span><span class="s1">childGraphMap[this.compoundOrder[i].id] = [].concat(this.compoundOrder[i].getChild().getNodes());</span><span class="s3">\n\n    </span><span class="s1">// Remove children of compounds</span><span class="s3">\n    </span><span class="s1">this.graphManager.remove(this.compoundOrder[i].getChild());</span><span class="s3">\n    </span><span class="s1">this.compoundOrder[i].child = null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n\n  </span><span class="s1">// Tile the removed children</span><span class="s3">\n  </span><span class="s1">this.tileCompoundMembers(childGraphMap, idToNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.clearZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var tiledZeroDegreePack = this.tiledZeroDegreePack = [];</span><span class="s3">\n\n  </span><span class="s1">Object.keys(this.memberGroups).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">var compoundNode = self.idToDummyNode[id]; // Get the dummy compound</span><span class="s3">\n\n    </span><span class="s1">tiledZeroDegreePack[id] = self.tileNodes(self.memberGroups[id], compoundNode.paddingLeft + compoundNode.paddingRight);</span><span class="s3">\n\n    </span><span class="s1">// Set the width and height of the dummy compound as calculated</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.width = tiledZeroDegreePack[id].width;</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.height = tiledZeroDegreePack[id].height;</span><span class="s3">\n    </span><span class="s1">compoundNode.setCenter(tiledZeroDegreePack[id].centerX, tiledZeroDegreePack[id].centerY);</span><span class="s3">\n\n    </span><span class="s1">// compound left and top margings for labels</span><span class="s3">\n    </span><span class="s1">// when node labels are included, these values may be set to different values below and are used in tilingPostLayout,</span><span class="s3">\n    </span><span class="s1">// otherwise they stay as zero</span><span class="s3">\n    </span><span class="s1">compoundNode.labelMarginLeft = 0;</span><span class="s3">\n    </span><span class="s1">compoundNode.labelMarginTop = 0;</span><span class="s3">\n\n    </span><span class="s1">// Update compound bounds considering its label properties and set label margins for left and top</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {</span><span class="s3">\n\n      </span><span class="s1">var width = compoundNode.rect.width;</span><span class="s3">\n      </span><span class="s1">var height = compoundNode.rect.height;</span><span class="s3">\n\n      </span><span class="s1">if (compoundNode.labelWidth) {</span><span class="s3">\n        </span><span class="s1">if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.x -= compoundNode.labelWidth;</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(width + compoundNode.labelWidth);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginLeft = compoundNode.labelWidth;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; compoundNode.labelWidth &gt; width) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(compoundNode.labelWidth);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(width + compoundNode.labelWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (compoundNode.labelHeight) {</span><span class="s3">\n        </span><span class="s1">if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.y -= compoundNode.labelHeight;</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(height + compoundNode.labelHeight);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginTop = compoundNode.labelHeight;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; compoundNode.labelHeight &gt; height) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(compoundNode.labelHeight);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(height + compoundNode.labelHeight);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.repopulateCompounds = function () {</span><span class="s3">\n  </span><span class="s1">for (var i = this.compoundOrder.length - 1; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var lCompoundNode = this.compoundOrder[i];</span><span class="s3">\n    </span><span class="s1">var id = lCompoundNode.id;</span><span class="s3">\n    </span><span class="s1">var horizontalMargin = lCompoundNode.paddingLeft;</span><span class="s3">\n    </span><span class="s1">var verticalMargin = lCompoundNode.paddingTop;</span><span class="s3">\n    </span><span class="s1">var labelMarginLeft = lCompoundNode.labelMarginLeft;</span><span class="s3">\n    </span><span class="s1">var labelMarginTop = lCompoundNode.labelMarginTop;</span><span class="s3">\n\n    </span><span class="s1">this.adjustLocations(this.tiledMemberPack[id], lCompoundNode.rect.x, lCompoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.repopulateZeroDegreeMembers = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">var tiledPack = this.tiledZeroDegreePack;</span><span class="s3">\n\n  </span><span class="s1">Object.keys(tiledPack).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">var compoundNode = self.idToDummyNode[id]; // Get the dummy compound by its id</span><span class="s3">\n    </span><span class="s1">var horizontalMargin = compoundNode.paddingLeft;</span><span class="s3">\n    </span><span class="s1">var verticalMargin = compoundNode.paddingTop;</span><span class="s3">\n    </span><span class="s1">var labelMarginLeft = compoundNode.labelMarginLeft;</span><span class="s3">\n    </span><span class="s1">var labelMarginTop = compoundNode.labelMarginTop;</span><span class="s3">\n\n    </span><span class="s1">// Adjust the positions of nodes wrt its compound</span><span class="s3">\n    </span><span class="s1">self.adjustLocations(tiledPack[id], compoundNode.rect.x, compoundNode.rect.y, horizontalMargin, verticalMargin, labelMarginLeft, labelMarginTop);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.getToBeTiled = function (node) {</span><span class="s3">\n  </span><span class="s1">var id = node.id;</span><span class="s3">\n  </span><span class="s1">//firstly check the previous results</span><span class="s3">\n  </span><span class="s1">if (this.toBeTiled[id] != null) {</span><span class="s3">\n    </span><span class="s1">return this.toBeTiled[id];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">//only compound nodes are to be tiled</span><span class="s3">\n  </span><span class="s1">var childGraph = node.getChild();</span><span class="s3">\n  </span><span class="s1">if (childGraph == null) {</span><span class="s3">\n    </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var children = childGraph.getNodes(); // Get the children nodes</span><span class="s3">\n\n  </span><span class="s1">//a compound node is not to be tiled if all of its compound children are not to be tiled</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var theChild = children[i];</span><span class="s3">\n\n    </span><span class="s1">if (this.getNodeDegree(theChild) &gt; 0) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">//pass the children not having the compound structure</span><span class="s3">\n    </span><span class="s1">if (theChild.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[theChild.id] = false;</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!this.getToBeTiled(theChild)) {</span><span class="s3">\n      </span><span class="s1">this.toBeTiled[id] = false;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.toBeTiled[id] = true;</span><span class="s3">\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Get degree of a node depending of its edges and independent of its children</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getNodeDegree = function (node) {</span><span class="s3">\n  </span><span class="s1">var id = node.id;</span><span class="s3">\n  </span><span class="s1">var edges = node.getEdges();</span><span class="s3">\n  </span><span class="s1">var degree = 0;</span><span class="s3">\n\n  </span><span class="s1">// For the edges connected</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; edges.length; i++) {</span><span class="s3">\n    </span><span class="s1">var edge = edges[i];</span><span class="s3">\n    </span><span class="s1">if (edge.getSource().id !== edge.getTarget().id) {</span><span class="s3">\n      </span><span class="s1">degree = degree + 1;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return degree;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Get degree of a node with its children</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getNodeDegreeWithChildren = function (node) {</span><span class="s3">\n  </span><span class="s1">var degree = this.getNodeDegree(node);</span><span class="s3">\n  </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">return degree;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var children = node.getChild().getNodes();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var child = children[i];</span><span class="s3">\n    </span><span class="s1">degree += this.getNodeDegreeWithChildren(child);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return degree;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.performDFSOnCompounds = function () {</span><span class="s3">\n  </span><span class="s1">this.compoundOrder = [];</span><span class="s3">\n  </span><span class="s1">this.fillCompexOrderByDFS(this.graphManager.getRoot().getNodes());</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.fillCompexOrderByDFS = function (children) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; children.length; i++) {</span><span class="s3">\n    </span><span class="s1">var child = children[i];</span><span class="s3">\n    </span><span class="s1">if (child.getChild() != null) {</span><span class="s3">\n      </span><span class="s1">this.fillCompexOrderByDFS(child.getChild().getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.getToBeTiled(child)) {</span><span class="s3">\n      </span><span class="s1">this.compoundOrder.push(child);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* This method places each zero degree member wrt given (x,y) coordinates (top left).</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.adjustLocations = function (organization, x, y, compoundHorizontalMargin, compoundVerticalMargin, compoundLabelMarginLeft, compoundLabelMarginTop) {</span><span class="s3">\n  </span><span class="s1">x += compoundHorizontalMargin + compoundLabelMarginLeft;</span><span class="s3">\n  </span><span class="s1">y += compoundVerticalMargin + compoundLabelMarginTop;</span><span class="s3">\n\n  </span><span class="s1">var left = x;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n    </span><span class="s1">var row = organization.rows[i];</span><span class="s3">\n    </span><span class="s1">x = left;</span><span class="s3">\n    </span><span class="s1">var maxHeight = 0;</span><span class="s3">\n\n    </span><span class="s1">for (var j = 0; j &lt; row.length; j++) {</span><span class="s3">\n      </span><span class="s1">var lnode = row[j];</span><span class="s3">\n\n      </span><span class="s1">lnode.rect.x = x; // + lnode.rect.width / 2;</span><span class="s3">\n      </span><span class="s1">lnode.rect.y = y; // + lnode.rect.height / 2;</span><span class="s3">\n\n      </span><span class="s1">x += lnode.rect.width + organization.horizontalPadding;</span><span class="s3">\n\n      </span><span class="s1">if (lnode.rect.height &gt; maxHeight) maxHeight = lnode.rect.height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">y += maxHeight + organization.verticalPadding;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tileCompoundMembers = function (childGraphMap, idToNode) {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">this.tiledMemberPack = [];</span><span class="s3">\n\n  </span><span class="s1">Object.keys(childGraphMap).forEach(function (id) {</span><span class="s3">\n    </span><span class="s1">// Get the compound node</span><span class="s3">\n    </span><span class="s1">var compoundNode = idToNode[id];</span><span class="s3">\n\n    </span><span class="s1">self.tiledMemberPack[id] = self.tileNodes(childGraphMap[id], compoundNode.paddingLeft + compoundNode.paddingRight);</span><span class="s3">\n\n    </span><span class="s1">compoundNode.rect.width = self.tiledMemberPack[id].width;</span><span class="s3">\n    </span><span class="s1">compoundNode.rect.height = self.tiledMemberPack[id].height;</span><span class="s3">\n    </span><span class="s1">compoundNode.setCenter(self.tiledMemberPack[id].centerX, self.tiledMemberPack[id].centerY);</span><span class="s3">\n\n    </span><span class="s1">// compound left and top margings for labels</span><span class="s3">\n    </span><span class="s1">// when node labels are included, these values may be set to different values below and are used in tilingPostLayout,</span><span class="s3">\n    </span><span class="s1">// otherwise they stay as zero</span><span class="s3">\n    </span><span class="s1">compoundNode.labelMarginLeft = 0;</span><span class="s3">\n    </span><span class="s1">compoundNode.labelMarginTop = 0;</span><span class="s3">\n\n    </span><span class="s1">// Update compound bounds considering its label properties and set label margins for left and top</span><span class="s3">\n    </span><span class="s1">if (CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {</span><span class="s3">\n\n      </span><span class="s1">var width = compoundNode.rect.width;</span><span class="s3">\n      </span><span class="s1">var height = compoundNode.rect.height;</span><span class="s3">\n\n      </span><span class="s1">if (compoundNode.labelWidth) {</span><span class="s3">\n        </span><span class="s1">if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.x -= compoundNode.labelWidth;</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(width + compoundNode.labelWidth);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginLeft = compoundNode.labelWidth;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; compoundNode.labelWidth &gt; width) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.x -= (compoundNode.labelWidth - width) / 2;</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(compoundNode.labelWidth);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginLeft = (compoundNode.labelWidth - width) / 2;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.setWidth(width + compoundNode.labelWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (compoundNode.labelHeight) {</span><span class="s3">\n        </span><span class="s1">if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.y -= compoundNode.labelHeight;</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(height + compoundNode.labelHeight);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginTop = compoundNode.labelHeight;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; compoundNode.labelHeight &gt; height) {</span><span class="s3">\n          </span><span class="s1">compoundNode.rect.y -= (compoundNode.labelHeight - height) / 2;</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(compoundNode.labelHeight);</span><span class="s3">\n          </span><span class="s1">compoundNode.labelMarginTop = (compoundNode.labelHeight - height) / 2;</span><span class="s3">\n        </span><span class="s1">} else if (compoundNode.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">compoundNode.setHeight(height + compoundNode.labelHeight);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tileNodes = function (nodes, minWidth) {</span><span class="s3">\n  </span><span class="s1">var horizontalOrg = this.tileNodesByFavoringDim(nodes, minWidth, true);</span><span class="s3">\n  </span><span class="s1">var verticalOrg = this.tileNodesByFavoringDim(nodes, minWidth, false);</span><span class="s3">\n\n  </span><span class="s1">var horizontalRatio = this.getOrgRatio(horizontalOrg);</span><span class="s3">\n  </span><span class="s1">var verticalRatio = this.getOrgRatio(verticalOrg);</span><span class="s3">\n  </span><span class="s1">var bestOrg;</span><span class="s3">\n\n  </span><span class="s1">// the best ratio is the one that is closer to 1 since the ratios are already normalized</span><span class="s3">\n  </span><span class="s1">// and the best organization is the one that has the best ratio</span><span class="s3">\n  </span><span class="s1">if (verticalRatio &lt; horizontalRatio) {</span><span class="s3">\n    </span><span class="s1">bestOrg = verticalOrg;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">bestOrg = horizontalOrg;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return bestOrg;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// get the width/height ratio of the organization that is normalized so that it will not be less than 1</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getOrgRatio = function (organization) {</span><span class="s3">\n  </span><span class="s1">// get dimensions and calculate the initial ratio</span><span class="s3">\n  </span><span class="s1">var width = organization.width;</span><span class="s3">\n  </span><span class="s1">var height = organization.height;</span><span class="s3">\n  </span><span class="s1">var ratio = width / height;</span><span class="s3">\n\n  </span><span class="s1">// if the initial ratio is less then 1 then inverse it</span><span class="s3">\n  </span><span class="s1">if (ratio &lt; 1) {</span><span class="s3">\n    </span><span class="s1">ratio = 1 / ratio;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// return the normalized ratio</span><span class="s3">\n  </span><span class="s1">return ratio;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\n </span><span class="s1">* Calculates the ideal width for the rows. This method assumes that</span><span class="s3">\n </span><span class="s1">* each node has the same sizes and calculates the ideal row width that</span><span class="s3">\n </span><span class="s1">* approximates a square shaped complex accordingly. However, since nodes would</span><span class="s3">\n </span><span class="s1">* have different sizes some rows would have different sizes and the resulting</span><span class="s3">\n </span><span class="s1">* shape would not be an exact square.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.calcIdealRowWidth = function (members, favorHorizontalDim) {</span><span class="s3">\n  </span><span class="s1">// To approximate a square shaped complex we need to make complex width equal to complex height.</span><span class="s3">\n  </span><span class="s1">// To achieve this we need to solve the following equation system for hc:</span><span class="s3">\n  </span><span class="s1">// (x + bx) * hc - bx = (y + by) * vc - by, hc * vc = n</span><span class="s3">\n  </span><span class="s1">// where x is the avarage width of the nodes, y is the avarage height of nodes</span><span class="s3">\n  </span><span class="s1">// bx and by are the buffer sizes in horizontal and vertical dimensions accordingly,</span><span class="s3">\n  </span><span class="s1">// hc and vc are the number of rows in horizontal and vertical dimensions</span><span class="s3">\n  </span><span class="s1">// n is number of members.</span><span class="s3">\n\n  </span><span class="s1">var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;</span><span class="s3">\n  </span><span class="s1">var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;</span><span class="s3">\n\n  </span><span class="s1">// number of members</span><span class="s3">\n  </span><span class="s1">var membersSize = members.length;</span><span class="s3">\n\n  </span><span class="s1">// sum of the width of all members</span><span class="s3">\n  </span><span class="s1">var totalWidth = 0;</span><span class="s3">\n\n  </span><span class="s1">// sum of the height of all members</span><span class="s3">\n  </span><span class="s1">var totalHeight = 0;</span><span class="s3">\n\n  </span><span class="s1">var maxWidth = 0;</span><span class="s3">\n\n  </span><span class="s1">// traverse all members to calculate total width and total height and get the maximum members width</span><span class="s3">\n  </span><span class="s1">members.forEach(function (node) {</span><span class="s3">\n    </span><span class="s1">totalWidth += node.getWidth();</span><span class="s3">\n    </span><span class="s1">totalHeight += node.getHeight();</span><span class="s3">\n\n    </span><span class="s1">if (node.getWidth() &gt; maxWidth) {</span><span class="s3">\n      </span><span class="s1">maxWidth = node.getWidth();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// average width of the members</span><span class="s3">\n  </span><span class="s1">var averageWidth = totalWidth / membersSize;</span><span class="s3">\n\n  </span><span class="s1">// average height of the members</span><span class="s3">\n  </span><span class="s1">var averageHeight = totalHeight / membersSize;</span><span class="s3">\n\n  </span><span class="s1">// solving the initial equation system for the hc yields the following second degree equation:</span><span class="s3">\n  </span><span class="s1">// hc^2 * (x+bx) + hc * (by - bx) - n * (y + by) = 0</span><span class="s3">\n\n  </span><span class="s1">// the delta value to solve the equation above for hc</span><span class="s3">\n  </span><span class="s1">var delta = Math.pow(verticalPadding - horizontalPadding, 2) + 4 * (averageWidth + horizontalPadding) * (averageHeight + verticalPadding) * membersSize;</span><span class="s3">\n\n  </span><span class="s1">// solve the equation using delta value to calculate the horizontal count</span><span class="s3">\n  </span><span class="s1">// that represents the number of nodes in an ideal row</span><span class="s3">\n  </span><span class="s1">var horizontalCountDouble = (horizontalPadding - verticalPadding + Math.sqrt(delta)) / (2 * (averageWidth + horizontalPadding));</span><span class="s3">\n  </span><span class="s1">// round the calculated horizontal count up or down according to the favored dimension</span><span class="s3">\n  </span><span class="s1">var horizontalCount;</span><span class="s3">\n\n  </span><span class="s1">if (favorHorizontalDim) {</span><span class="s3">\n    </span><span class="s1">horizontalCount = Math.ceil(horizontalCountDouble);</span><span class="s3">\n    </span><span class="s1">// if horizontalCount count is not a float value then both of rounding to floor and ceil</span><span class="s3">\n    </span><span class="s1">// will yield the same values. Instead of repeating the same calculation try going up</span><span class="s3">\n    </span><span class="s1">// while favoring horizontal dimension in such cases</span><span class="s3">\n    </span><span class="s1">if (horizontalCount == horizontalCountDouble) {</span><span class="s3">\n      </span><span class="s1">horizontalCount++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">horizontalCount = Math.floor(horizontalCountDouble);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// ideal width to be calculated</span><span class="s3">\n  </span><span class="s1">var idealWidth = horizontalCount * (averageWidth + horizontalPadding) - horizontalPadding;</span><span class="s3">\n\n  </span><span class="s1">// if max width is bigger than calculated ideal width reset ideal width to it</span><span class="s3">\n  </span><span class="s1">if (maxWidth &gt; idealWidth) {</span><span class="s3">\n    </span><span class="s1">idealWidth = maxWidth;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// add the left-right margins to the ideal row width</span><span class="s3">\n  </span><span class="s1">idealWidth += horizontalPadding * 2;</span><span class="s3">\n\n  </span><span class="s1">// return the ideal row width1</span><span class="s3">\n  </span><span class="s1">return idealWidth;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tileNodesByFavoringDim = function (nodes, minWidth, favorHorizontalDim) {</span><span class="s3">\n  </span><span class="s1">var verticalPadding = CoSEConstants.TILING_PADDING_VERTICAL;</span><span class="s3">\n  </span><span class="s1">var horizontalPadding = CoSEConstants.TILING_PADDING_HORIZONTAL;</span><span class="s3">\n  </span><span class="s1">var tilingCompareBy = CoSEConstants.TILING_COMPARE_BY;</span><span class="s3">\n  </span><span class="s1">var organization = {</span><span class="s3">\n    </span><span class="s1">rows: [],</span><span class="s3">\n    </span><span class="s1">rowWidth: [],</span><span class="s3">\n    </span><span class="s1">rowHeight: [],</span><span class="s3">\n    </span><span class="s1">width: 0,</span><span class="s3">\n    </span><span class="s1">height: minWidth, // assume minHeight equals to minWidth</span><span class="s3">\n    </span><span class="s1">verticalPadding: verticalPadding,</span><span class="s3">\n    </span><span class="s1">horizontalPadding: horizontalPadding,</span><span class="s3">\n    </span><span class="s1">centerX: 0,</span><span class="s3">\n    </span><span class="s1">centerY: 0</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">if (tilingCompareBy) {</span><span class="s3">\n    </span><span class="s1">organization.idealRowWidth = this.calcIdealRowWidth(nodes, favorHorizontalDim);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var getNodeArea = function getNodeArea(n) {</span><span class="s3">\n    </span><span class="s1">return n.rect.width * n.rect.height;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">var areaCompareFcn = function areaCompareFcn(n1, n2) {</span><span class="s3">\n    </span><span class="s1">return getNodeArea(n2) - getNodeArea(n1);</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// Sort the nodes in descending order of their areas</span><span class="s3">\n  </span><span class="s1">nodes.sort(function (n1, n2) {</span><span class="s3">\n    </span><span class="s1">var cmpBy = areaCompareFcn;</span><span class="s3">\n    </span><span class="s1">if (organization.idealRowWidth) {</span><span class="s3">\n      </span><span class="s1">cmpBy = tilingCompareBy;</span><span class="s3">\n      </span><span class="s1">return cmpBy(n1.id, n2.id);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">return cmpBy(n1, n2);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">// Create the organization -&gt; calculate compound center</span><span class="s3">\n  </span><span class="s1">var sumCenterX = 0;</span><span class="s3">\n  </span><span class="s1">var sumCenterY = 0;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">sumCenterX += lNode.getCenterX();</span><span class="s3">\n    </span><span class="s1">sumCenterY += lNode.getCenterY();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">organization.centerX = sumCenterX / nodes.length;</span><span class="s3">\n  </span><span class="s1">organization.centerY = sumCenterY / nodes.length;</span><span class="s3">\n\n  </span><span class="s1">// Create the organization -&gt; tile members</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">if (organization.rows.length == 0) {</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, 0, minWidth);</span><span class="s3">\n    </span><span class="s1">} else if (this.canAddHorizontal(organization, lNode.rect.width, lNode.rect.height)) {</span><span class="s3">\n      </span><span class="s1">var rowIndex = organization.rows.length - 1;</span><span class="s3">\n      </span><span class="s1">if (!organization.idealRowWidth) {</span><span class="s3">\n        </span><span class="s1">rowIndex = this.getShortestRowIndex(organization);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, rowIndex, minWidth);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.insertNodeToRow(organization, lNode, organization.rows.length, minWidth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.shiftToLastRow(organization);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return organization;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.insertNodeToRow = function (organization, node, rowIndex, minWidth) {</span><span class="s3">\n  </span><span class="s1">var minCompoundSize = minWidth;</span><span class="s3">\n\n  </span><span class="s1">// Add new row if needed</span><span class="s3">\n  </span><span class="s1">if (rowIndex == organization.rows.length) {</span><span class="s3">\n    </span><span class="s1">var secondDimension = [];</span><span class="s3">\n\n    </span><span class="s1">organization.rows.push(secondDimension);</span><span class="s3">\n    </span><span class="s1">organization.rowWidth.push(minCompoundSize);</span><span class="s3">\n    </span><span class="s1">organization.rowHeight.push(0);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update row width</span><span class="s3">\n  </span><span class="s1">var w = organization.rowWidth[rowIndex] + node.rect.width;</span><span class="s3">\n\n  </span><span class="s1">if (organization.rows[rowIndex].length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">w += organization.horizontalPadding;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">organization.rowWidth[rowIndex] = w;</span><span class="s3">\n  </span><span class="s1">// Update compound width</span><span class="s3">\n  </span><span class="s1">if (organization.width &lt; w) {</span><span class="s3">\n    </span><span class="s1">organization.width = w;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Update height</span><span class="s3">\n  </span><span class="s1">var h = node.rect.height;</span><span class="s3">\n  </span><span class="s1">if (rowIndex &gt; 0) h += organization.verticalPadding;</span><span class="s3">\n\n  </span><span class="s1">var extraHeight = 0;</span><span class="s3">\n  </span><span class="s1">if (h &gt; organization.rowHeight[rowIndex]) {</span><span class="s3">\n    </span><span class="s1">extraHeight = organization.rowHeight[rowIndex];</span><span class="s3">\n    </span><span class="s1">organization.rowHeight[rowIndex] = h;</span><span class="s3">\n    </span><span class="s1">extraHeight = organization.rowHeight[rowIndex] - extraHeight;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">organization.height += extraHeight;</span><span class="s3">\n\n  </span><span class="s1">// Insert node</span><span class="s3">\n  </span><span class="s1">organization.rows[rowIndex].push(node);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//Scans the rows of an organization and returns the one with the min width</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getShortestRowIndex = function (organization) {</span><span class="s3">\n  </span><span class="s1">var r = -1;</span><span class="s3">\n  </span><span class="s1">var min = Number.MAX_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (organization.rowWidth[i] &lt; min) {</span><span class="s3">\n      </span><span class="s1">r = i;</span><span class="s3">\n      </span><span class="s1">min = organization.rowWidth[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return r;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//Scans the rows of an organization and returns the one with the max width</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.getLongestRowIndex = function (organization) {</span><span class="s3">\n  </span><span class="s1">var r = -1;</span><span class="s3">\n  </span><span class="s1">var max = Number.MIN_VALUE;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; organization.rows.length; i++) {</span><span class="s3">\n\n    </span><span class="s1">if (organization.rowWidth[i] &gt; max) {</span><span class="s3">\n      </span><span class="s1">r = i;</span><span class="s3">\n      </span><span class="s1">max = organization.rowWidth[i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return r;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n</span><span class="s1">* This method checks whether adding extra width to the organization violates</span><span class="s3">\n</span><span class="s1">* the aspect ratio(1) or not.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.canAddHorizontal = function (organization, extraWidth, extraHeight) {</span><span class="s3">\n\n  </span><span class="s1">// if there is an ideal row width specified use it instead of checking the aspect ratio</span><span class="s3">\n  </span><span class="s1">if (organization.idealRowWidth) {</span><span class="s3">\n    </span><span class="s1">var lastRowIndex = organization.rows.length - 1;</span><span class="s3">\n    </span><span class="s1">var lastRowWidth = organization.rowWidth[lastRowIndex];</span><span class="s3">\n\n    </span><span class="s1">// check and return if ideal row width will be exceed if the node is added to the row</span><span class="s3">\n    </span><span class="s1">return lastRowWidth + extraWidth + organization.horizontalPadding &lt;= organization.idealRowWidth;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var sri = this.getShortestRowIndex(organization);</span><span class="s3">\n\n  </span><span class="s1">if (sri &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var min = organization.rowWidth[sri];</span><span class="s3">\n\n  </span><span class="s1">if (min + organization.horizontalPadding + extraWidth &lt;= organization.width) return true;</span><span class="s3">\n\n  </span><span class="s1">var hDiff = 0;</span><span class="s3">\n\n  </span><span class="s1">// Adding to an existing row</span><span class="s3">\n  </span><span class="s1">if (organization.rowHeight[sri] &lt; extraHeight) {</span><span class="s3">\n    </span><span class="s1">if (sri &gt; 0) hDiff = extraHeight + organization.verticalPadding - organization.rowHeight[sri];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var add_to_row_ratio;</span><span class="s3">\n  </span><span class="s1">if (organization.width - min &gt;= extraWidth + organization.horizontalPadding) {</span><span class="s3">\n    </span><span class="s1">add_to_row_ratio = (organization.height + hDiff) / (min + extraWidth + organization.horizontalPadding);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">add_to_row_ratio = (organization.height + hDiff) / organization.width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Adding a new row for this node</span><span class="s3">\n  </span><span class="s1">hDiff = extraHeight + organization.verticalPadding;</span><span class="s3">\n  </span><span class="s1">var add_new_row_ratio;</span><span class="s3">\n  </span><span class="s1">if (organization.width &lt; extraWidth) {</span><span class="s3">\n    </span><span class="s1">add_new_row_ratio = (organization.height + hDiff) / extraWidth;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">add_new_row_ratio = (organization.height + hDiff) / organization.width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (add_new_row_ratio &lt; 1) add_new_row_ratio = 1 / add_new_row_ratio;</span><span class="s3">\n\n  </span><span class="s1">if (add_to_row_ratio &lt; 1) add_to_row_ratio = 1 / add_to_row_ratio;</span><span class="s3">\n\n  </span><span class="s1">return add_to_row_ratio &lt; add_new_row_ratio;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//If moving the last node from the longest row and adding it to the last</span><span class="s3">\n</span><span class="s1">//row makes the bounding box smaller, do it.</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.shiftToLastRow = function (organization) {</span><span class="s3">\n  </span><span class="s1">var longest = this.getLongestRowIndex(organization);</span><span class="s3">\n  </span><span class="s1">var last = organization.rowWidth.length - 1;</span><span class="s3">\n  </span><span class="s1">var row = organization.rows[longest];</span><span class="s3">\n  </span><span class="s1">var node = row[row.length - 1];</span><span class="s3">\n\n  </span><span class="s1">var diff = node.width + organization.horizontalPadding;</span><span class="s3">\n\n  </span><span class="s1">// Check if there is enough space on the last row</span><span class="s3">\n  </span><span class="s1">if (organization.width - organization.rowWidth[last] &gt; diff &amp;&amp; longest != last) {</span><span class="s3">\n    </span><span class="s1">// Remove the last element of the longest row</span><span class="s3">\n    </span><span class="s1">row.splice(-1, 1);</span><span class="s3">\n\n    </span><span class="s1">// Push it to the last row</span><span class="s3">\n    </span><span class="s1">organization.rows[last].push(node);</span><span class="s3">\n\n    </span><span class="s1">organization.rowWidth[longest] = organization.rowWidth[longest] - diff;</span><span class="s3">\n    </span><span class="s1">organization.rowWidth[last] = organization.rowWidth[last] + diff;</span><span class="s3">\n    </span><span class="s1">organization.width = organization.rowWidth[instance.getLongestRowIndex(organization)];</span><span class="s3">\n\n    </span><span class="s1">// Update heights of the organization</span><span class="s3">\n    </span><span class="s1">var maxHeight = Number.MIN_VALUE;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; row.length; i++) {</span><span class="s3">\n      </span><span class="s1">if (row[i].height &gt; maxHeight) maxHeight = row[i].height;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (longest &gt; 0) maxHeight += organization.verticalPadding;</span><span class="s3">\n\n    </span><span class="s1">var prevTotal = organization.rowHeight[longest] + organization.rowHeight[last];</span><span class="s3">\n\n    </span><span class="s1">organization.rowHeight[longest] = maxHeight;</span><span class="s3">\n    </span><span class="s1">if (organization.rowHeight[last] &lt; node.height + organization.verticalPadding) organization.rowHeight[last] = node.height + organization.verticalPadding;</span><span class="s3">\n\n    </span><span class="s1">var finalTotal = organization.rowHeight[longest] + organization.rowHeight[last];</span><span class="s3">\n    </span><span class="s1">organization.height += finalTotal - prevTotal;</span><span class="s3">\n\n    </span><span class="s1">this.shiftToLastRow(organization);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tilingPreLayout = function () {</span><span class="s3">\n  </span><span class="s1">if (CoSEConstants.TILE) {</span><span class="s3">\n    </span><span class="s1">// Find zero degree nodes and create a compound for each level</span><span class="s3">\n    </span><span class="s1">this.groupZeroDegreeMembers();</span><span class="s3">\n    </span><span class="s1">// Tile and clear children of each compound</span><span class="s3">\n    </span><span class="s1">this.clearCompounds();</span><span class="s3">\n    </span><span class="s1">// Separately tile and clear zero degree nodes for each level</span><span class="s3">\n    </span><span class="s1">this.clearZeroDegreeMembers();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSELayout.prototype.tilingPostLayout = function () {</span><span class="s3">\n  </span><span class="s1">if (CoSEConstants.TILE) {</span><span class="s3">\n    </span><span class="s1">this.repopulateZeroDegreeMembers();</span><span class="s3">\n    </span><span class="s1">this.repopulateCompounds();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: Tree Reduction methods</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Reduce trees </span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.reduceTrees = function () {</span><span class="s3">\n  </span><span class="s1">var prunedNodesAll = [];</span><span class="s3">\n  </span><span class="s1">var containsLeaf = true;</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">while (containsLeaf) {</span><span class="s3">\n    </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n    </span><span class="s1">var prunedNodesInStepTemp = [];</span><span class="s3">\n    </span><span class="s1">containsLeaf = false;</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = allNodes[i];</span><span class="s3">\n      </span><span class="s1">if (node.getEdges().length == 1 &amp;&amp; !node.getEdges()[0].isInterGraph &amp;&amp; node.getChild() == null) {</span><span class="s3">\n        </span><span class="s1">if (CoSEConstants.PURE_INCREMENTAL) {</span><span class="s3">\n          </span><span class="s1">var otherEnd = node.getEdges()[0].getOtherEnd(node);</span><span class="s3">\n          </span><span class="s1">var relativePosition = new DimensionD(node.getCenterX() - otherEnd.getCenterX(), node.getCenterY() - otherEnd.getCenterY());</span><span class="s3">\n          </span><span class="s1">prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner(), relativePosition]);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">prunedNodesInStepTemp.push([node, node.getEdges()[0], node.getOwner()]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">containsLeaf = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (containsLeaf == true) {</span><span class="s3">\n      </span><span class="s1">var prunedNodesInStep = [];</span><span class="s3">\n      </span><span class="s1">for (var j = 0; j &lt; prunedNodesInStepTemp.length; j++) {</span><span class="s3">\n        </span><span class="s1">if (prunedNodesInStepTemp[j][0].getEdges().length == 1) {</span><span class="s3">\n          </span><span class="s1">prunedNodesInStep.push(prunedNodesInStepTemp[j]);</span><span class="s3">\n          </span><span class="s1">prunedNodesInStepTemp[j][0].getOwner().remove(prunedNodesInStepTemp[j][0]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">prunedNodesAll.push(prunedNodesInStep);</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n      </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.prunedNodesAll = prunedNodesAll;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Grow tree one step </span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.growTree = function (prunedNodesAll) {</span><span class="s3">\n  </span><span class="s1">var lengthOfPrunedNodesInStep = prunedNodesAll.length;</span><span class="s3">\n  </span><span class="s1">var prunedNodesInStep = prunedNodesAll[lengthOfPrunedNodesInStep - 1];</span><span class="s3">\n\n  </span><span class="s1">var nodeData;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; prunedNodesInStep.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodeData = prunedNodesInStep[i];</span><span class="s3">\n\n    </span><span class="s1">this.findPlaceforPrunedNode(nodeData);</span><span class="s3">\n\n    </span><span class="s1">nodeData[2].add(nodeData[0]);</span><span class="s3">\n    </span><span class="s1">nodeData[2].add(nodeData[1], nodeData[1].source, nodeData[1].target);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">prunedNodesAll.splice(prunedNodesAll.length - 1, 1);</span><span class="s3">\n  </span><span class="s1">this.graphManager.resetAllNodes();</span><span class="s3">\n  </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// Find an appropriate position to replace pruned node, this method can be improved</span><span class="s3">\n</span><span class="s1">CoSELayout.prototype.findPlaceforPrunedNode = function (nodeData) {</span><span class="s3">\n\n  </span><span class="s1">var gridForPrunedNode;</span><span class="s3">\n  </span><span class="s1">var nodeToConnect;</span><span class="s3">\n  </span><span class="s1">var prunedNode = nodeData[0];</span><span class="s3">\n  </span><span class="s1">if (prunedNode == nodeData[1].source) {</span><span class="s3">\n    </span><span class="s1">nodeToConnect = nodeData[1].target;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">nodeToConnect = nodeData[1].source;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (CoSEConstants.PURE_INCREMENTAL) {</span><span class="s3">\n    </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX() + nodeData[3].getWidth(), nodeToConnect.getCenterY() + nodeData[3].getHeight());</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var startGridX = nodeToConnect.startX;</span><span class="s3">\n    </span><span class="s1">var finishGridX = nodeToConnect.finishX;</span><span class="s3">\n    </span><span class="s1">var startGridY = nodeToConnect.startY;</span><span class="s3">\n    </span><span class="s1">var finishGridY = nodeToConnect.finishY;</span><span class="s3">\n\n    </span><span class="s1">var upNodeCount = 0;</span><span class="s3">\n    </span><span class="s1">var downNodeCount = 0;</span><span class="s3">\n    </span><span class="s1">var rightNodeCount = 0;</span><span class="s3">\n    </span><span class="s1">var leftNodeCount = 0;</span><span class="s3">\n    </span><span class="s1">var controlRegions = [upNodeCount, rightNodeCount, downNodeCount, leftNodeCount];</span><span class="s3">\n\n    </span><span class="s1">if (startGridY &gt; 0) {</span><span class="s3">\n      </span><span class="s1">for (var i = startGridX; i &lt;= finishGridX; i++) {</span><span class="s3">\n        </span><span class="s1">controlRegions[0] += this.grid[i][startGridY - 1].length + this.grid[i][startGridY].length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (finishGridX &lt; this.grid.length - 1) {</span><span class="s3">\n      </span><span class="s1">for (var i = startGridY; i &lt;= finishGridY; i++) {</span><span class="s3">\n        </span><span class="s1">controlRegions[1] += this.grid[finishGridX + 1][i].length + this.grid[finishGridX][i].length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (finishGridY &lt; this.grid[0].length - 1) {</span><span class="s3">\n      </span><span class="s1">for (var i = startGridX; i &lt;= finishGridX; i++) {</span><span class="s3">\n        </span><span class="s1">controlRegions[2] += this.grid[i][finishGridY + 1].length + this.grid[i][finishGridY].length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (startGridX &gt; 0) {</span><span class="s3">\n      </span><span class="s1">for (var i = startGridY; i &lt;= finishGridY; i++) {</span><span class="s3">\n        </span><span class="s1">controlRegions[3] += this.grid[startGridX - 1][i].length + this.grid[startGridX][i].length - 1;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var min = Integer.MAX_VALUE;</span><span class="s3">\n    </span><span class="s1">var minCount;</span><span class="s3">\n    </span><span class="s1">var minIndex;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; controlRegions.length; j++) {</span><span class="s3">\n      </span><span class="s1">if (controlRegions[j] &lt; min) {</span><span class="s3">\n        </span><span class="s1">min = controlRegions[j];</span><span class="s3">\n        </span><span class="s1">minCount = 1;</span><span class="s3">\n        </span><span class="s1">minIndex = j;</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[j] == min) {</span><span class="s3">\n        </span><span class="s1">minCount++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (minCount == 3 &amp;&amp; min == 0) {</span><span class="s3">\n      </span><span class="s1">if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[2] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n        </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (minCount == 2 &amp;&amp; min == 0) {</span><span class="s3">\n      </span><span class="s1">var random = Math.floor(Math.random() * 2);</span><span class="s3">\n      </span><span class="s1">if (controlRegions[0] == 0 &amp;&amp; controlRegions[1] == 0) {</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[0] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 0;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[2] == 0) {</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (controlRegions[1] == 0 &amp;&amp; controlRegions[3] == 0) {</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 1;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (random == 0) {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 2;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">gridForPrunedNode = 3;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (minCount == 4 &amp;&amp; min == 0) {</span><span class="s3">\n      </span><span class="s1">var random = Math.floor(Math.random() * 4);</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = random;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">gridForPrunedNode = minIndex;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (gridForPrunedNode == 0) {</span><span class="s3">\n      </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() - nodeToConnect.getHeight() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getHeight() / 2);</span><span class="s3">\n    </span><span class="s1">} else if (gridForPrunedNode == 1) {</span><span class="s3">\n      </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX() + nodeToConnect.getWidth() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getWidth() / 2, nodeToConnect.getCenterY());</span><span class="s3">\n    </span><span class="s1">} else if (gridForPrunedNode == 2) {</span><span class="s3">\n      </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX(), nodeToConnect.getCenterY() + nodeToConnect.getHeight() / 2 + FDLayoutConstants.DEFAULT_EDGE_LENGTH + prunedNode.getHeight() / 2);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">prunedNode.setCenter(nodeToConnect.getCenterX() - nodeToConnect.getWidth() / 2 - FDLayoutConstants.DEFAULT_EDGE_LENGTH - prunedNode.getWidth() / 2, nodeToConnect.getCenterY());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSELayout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 991:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">var FDLayoutNode = __webpack_require__(551).FDLayoutNode;</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(551).IMath;</span><span class="s3">\n\n</span><span class="s1">function CoSENode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">FDLayoutNode.call(this, gm, loc, size, vNode);</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype = Object.create(FDLayoutNode.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in FDLayoutNode) {</span><span class="s3">\n  </span><span class="s1">CoSENode[prop] = FDLayoutNode[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.calculateDisplacement = function () {</span><span class="s3">\n  </span><span class="s1">var layout = this.graphManager.getLayout();</span><span class="s3">\n  </span><span class="s1">// this check is for compound nodes that contain fixed nodes</span><span class="s3">\n  </span><span class="s1">if (this.getChild() != null &amp;&amp; this.fixedNodeWeight) {</span><span class="s3">\n    </span><span class="s1">this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.fixedNodeWeight;</span><span class="s3">\n    </span><span class="s1">this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.fixedNodeWeight;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.displacementX += layout.coolingFactor * (this.springForceX + this.repulsionForceX + this.gravitationForceX) / this.noOfChildren;</span><span class="s3">\n    </span><span class="s1">this.displacementY += layout.coolingFactor * (this.springForceY + this.repulsionForceY + this.gravitationForceY) / this.noOfChildren;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.displacementX) &gt; layout.coolingFactor * layout.maxNodeDisplacement) {</span><span class="s3">\n    </span><span class="s1">this.displacementX = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementX);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.displacementY) &gt; layout.coolingFactor * layout.maxNodeDisplacement) {</span><span class="s3">\n    </span><span class="s1">this.displacementY = layout.coolingFactor * layout.maxNodeDisplacement * IMath.sign(this.displacementY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// non-empty compound node, propogate movement to children as well</span><span class="s3">\n  </span><span class="s1">if (this.child &amp;&amp; this.child.getNodes().length &gt; 0) {</span><span class="s3">\n    </span><span class="s1">this.propogateDisplacementToChildren(this.displacementX, this.displacementY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.propogateDisplacementToChildren = function (dX, dY) {</span><span class="s3">\n  </span><span class="s1">var nodes = this.getChild().getNodes();</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = nodes[i];</span><span class="s3">\n    </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">node.displacementX += dX;</span><span class="s3">\n      </span><span class="s1">node.displacementY += dY;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">node.propogateDisplacementToChildren(dX, dY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.move = function () {</span><span class="s3">\n  </span><span class="s1">var layout = this.graphManager.getLayout();</span><span class="s3">\n\n  </span><span class="s1">// a simple node or an empty compound node, move it</span><span class="s3">\n  </span><span class="s1">if (this.child == null || this.child.getNodes().length == 0) {</span><span class="s3">\n    </span><span class="s1">this.moveBy(this.displacementX, this.displacementY);</span><span class="s3">\n\n    </span><span class="s1">layout.totalDisplacement += Math.abs(this.displacementX) + Math.abs(this.displacementY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.springForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.springForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementX = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementY = 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setPred1 = function (pred1) {</span><span class="s3">\n  </span><span class="s1">this.pred1 = pred1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getPred1 = function () {</span><span class="s3">\n  </span><span class="s1">return pred1;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getPred2 = function () {</span><span class="s3">\n  </span><span class="s1">return pred2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setNext = function (next) {</span><span class="s3">\n  </span><span class="s1">this.next = next;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.getNext = function () {</span><span class="s3">\n  </span><span class="s1">return next;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.setProcessed = function (processed) {</span><span class="s3">\n  </span><span class="s1">this.processed = processed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">CoSENode.prototype.isProcessed = function () {</span><span class="s3">\n  </span><span class="s1">return processed;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = CoSENode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 902:</span><span class="s3">\n</span><span class="s1">/***/ ((module, __unused_webpack_exports, __webpack_require__) =&gt; {</span><span class="s3">\n\n\n\n</span><span class="s1">function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }</span><span class="s3">\n\n</span><span class="s1">var CoSEConstants = __webpack_require__(806);</span><span class="s3">\n</span><span class="s1">var LinkedList = __webpack_require__(551).LinkedList;</span><span class="s3">\n</span><span class="s1">var Matrix = __webpack_require__(551).Matrix;</span><span class="s3">\n</span><span class="s1">var SVD = __webpack_require__(551).SVD;</span><span class="s3">\n\n</span><span class="s1">function ConstraintHandler() {}</span><span class="s3">\n\n</span><span class="s1">ConstraintHandler.handleConstraints = function (layout) {</span><span class="s3">\n  </span><span class="s1">//  let layout = this.graphManager.getLayout();</span><span class="s3">\n\n  </span><span class="s1">// get constraints from layout</span><span class="s3">\n  </span><span class="s1">var constraints = {};</span><span class="s3">\n  </span><span class="s1">constraints.fixedNodeConstraint = layout.constraints.fixedNodeConstraint;</span><span class="s3">\n  </span><span class="s1">constraints.alignmentConstraint = layout.constraints.alignmentConstraint;</span><span class="s3">\n  </span><span class="s1">constraints.relativePlacementConstraint = layout.constraints.relativePlacementConstraint;</span><span class="s3">\n\n  </span><span class="s1">var idToNodeMap = new Map();</span><span class="s3">\n  </span><span class="s1">var nodeIndexes = new Map();</span><span class="s3">\n  </span><span class="s1">var xCoords = [];</span><span class="s3">\n  </span><span class="s1">var yCoords = [];</span><span class="s3">\n\n  </span><span class="s1">var allNodes = layout.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var index = 0;</span><span class="s3">\n  </span><span class="s1">// fill index map and coordinates</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">if (node.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">nodeIndexes.set(node.id, index++);</span><span class="s3">\n      </span><span class="s1">xCoords.push(node.getCenterX());</span><span class="s3">\n      </span><span class="s1">yCoords.push(node.getCenterY());</span><span class="s3">\n      </span><span class="s1">idToNodeMap.set(node.id, node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// if there exists relative placement constraint without gap value, set it to default </span><span class="s3">\n  </span><span class="s1">if (constraints.relativePlacementConstraint) {</span><span class="s3">\n    </span><span class="s1">constraints.relativePlacementConstraint.forEach(function (constraint) {</span><span class="s3">\n      </span><span class="s1">if (!constraint.gap &amp;&amp; constraint.gap != 0) {</span><span class="s3">\n        </span><span class="s1">if (constraint.left) {</span><span class="s3">\n          </span><span class="s1">constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.left).getWidth() / 2 + idToNodeMap.get(constraint.right).getWidth() / 2;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">constraint.gap = CoSEConstants.DEFAULT_EDGE_LENGTH + idToNodeMap.get(constraint.top).getHeight() / 2 + idToNodeMap.get(constraint.bottom).getHeight() / 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">/* auxiliary functions */</span><span class="s3">\n\n  </span><span class="s1">// calculate difference between two position objects</span><span class="s3">\n  </span><span class="s1">var calculatePositionDiff = function calculatePositionDiff(pos1, pos2) {</span><span class="s3">\n    </span><span class="s1">return { x: pos1.x - pos2.x, y: pos1.y - pos2.y };</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// calculate average position of the nodes</span><span class="s3">\n  </span><span class="s1">var calculateAvgPosition = function calculateAvgPosition(nodeIdSet) {</span><span class="s3">\n    </span><span class="s1">var xPosSum = 0;</span><span class="s3">\n    </span><span class="s1">var yPosSum = 0;</span><span class="s3">\n    </span><span class="s1">nodeIdSet.forEach(function (nodeId) {</span><span class="s3">\n      </span><span class="s1">xPosSum += xCoords[nodeIndexes.get(nodeId)];</span><span class="s3">\n      </span><span class="s1">yPosSum += yCoords[nodeIndexes.get(nodeId)];</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return { x: xPosSum / nodeIdSet.size, y: yPosSum / nodeIdSet.size };</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// find an appropriate positioning for the nodes in a given graph according to relative placement constraints</span><span class="s3">\n  </span><span class="s1">// this function also takes the fixed nodes and alignment constraints into account</span><span class="s3">\n  </span><span class="s1">// graph: dag to be evaluated, direction: </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot; </span><span class="s1">or </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\n  </span><span class="s1">// fixedNodes: set of fixed nodes to consider during evaluation, dummyPositions: appropriate coordinates of the dummy nodes  </span><span class="s3">\n  </span><span class="s1">var findAppropriatePositionForRelativePlacement = function findAppropriatePositionForRelativePlacement(graph, direction, fixedNodes, dummyPositions, componentSources) {</span><span class="s3">\n\n    </span><span class="s1">// find union of two sets</span><span class="s3">\n    </span><span class="s1">function setUnion(setA, setB) {</span><span class="s3">\n      </span><span class="s1">var union = new Set(setA);</span><span class="s3">\n      </span><span class="s1">var _iteratorNormalCompletion = true;</span><span class="s3">\n      </span><span class="s1">var _didIteratorError = false;</span><span class="s3">\n      </span><span class="s1">var _iteratorError = undefined;</span><span class="s3">\n\n      </span><span class="s1">try {</span><span class="s3">\n        </span><span class="s1">for (var _iterator = setB[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {</span><span class="s3">\n          </span><span class="s1">var elem = _step.value;</span><span class="s3">\n\n          </span><span class="s1">union.add(elem);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} catch (err) {</span><span class="s3">\n        </span><span class="s1">_didIteratorError = true;</span><span class="s3">\n        </span><span class="s1">_iteratorError = err;</span><span class="s3">\n      </span><span class="s1">} finally {</span><span class="s3">\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">if (!_iteratorNormalCompletion &amp;&amp; _iterator.return) {</span><span class="s3">\n            </span><span class="s1">_iterator.return();</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">if (_didIteratorError) {</span><span class="s3">\n            </span><span class="s1">throw _iteratorError;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">return union;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// find indegree count for each node</span><span class="s3">\n    </span><span class="s1">var inDegrees = new Map();</span><span class="s3">\n\n    </span><span class="s1">graph.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">inDegrees.set(key, 0);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">graph.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">value.forEach(function (adjacent) {</span><span class="s3">\n        </span><span class="s1">inDegrees.set(adjacent.id, inDegrees.get(adjacent.id) + 1);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">var positionMap = new Map(); // keeps the position for each node</span><span class="s3">\n    </span><span class="s1">var pastMap = new Map(); // keeps the predecessors(past) of a node</span><span class="s3">\n    </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n    </span><span class="s1">inDegrees.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">if (value == 0) {</span><span class="s3">\n        </span><span class="s1">queue.push(key);</span><span class="s3">\n        </span><span class="s1">if (!fixedNodes) {</span><span class="s3">\n          </span><span class="s1">if (direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">positionMap.set(key, nodeIndexes.has(key) ? xCoords[nodeIndexes.get(key)] : dummyPositions.get(key));</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">positionMap.set(key, nodeIndexes.has(key) ? yCoords[nodeIndexes.get(key)] : dummyPositions.get(key));</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">positionMap.set(key, Number.NEGATIVE_INFINITY);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (fixedNodes) {</span><span class="s3">\n        </span><span class="s1">pastMap.set(key, new Set([key]));</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">// align sources of each component in enforcement phase</span><span class="s3">\n    </span><span class="s1">if (fixedNodes) {</span><span class="s3">\n      </span><span class="s1">componentSources.forEach(function (component) {</span><span class="s3">\n        </span><span class="s1">var fixedIds = [];</span><span class="s3">\n        </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n          </span><span class="s1">if (fixedNodes.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">fixedIds.push(nodeId);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">if (fixedIds.length &gt; 0) {</span><span class="s3">\n          </span><span class="s1">var position = 0;</span><span class="s3">\n          </span><span class="s1">fixedIds.forEach(function (fixedId) {</span><span class="s3">\n            </span><span class="s1">if (direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">positionMap.set(fixedId, nodeIndexes.has(fixedId) ? xCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));</span><span class="s3">\n              </span><span class="s1">position += positionMap.get(fixedId);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">positionMap.set(fixedId, nodeIndexes.has(fixedId) ? yCoords[nodeIndexes.get(fixedId)] : dummyPositions.get(fixedId));</span><span class="s3">\n              </span><span class="s1">position += positionMap.get(fixedId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">position = position / fixedIds.length;</span><span class="s3">\n          </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (!fixedNodes.has(nodeId)) {</span><span class="s3">\n              </span><span class="s1">positionMap.set(nodeId, position);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">var _position = 0;</span><span class="s3">\n          </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">_position += nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">_position += nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">_position = _position / component.length;</span><span class="s3">\n          </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">positionMap.set(nodeId, _position);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// calculate positions of the nodes</span><span class="s3">\n\n    </span><span class="s1">var _loop = function _loop() {</span><span class="s3">\n      </span><span class="s1">var currentNode = queue.shift();</span><span class="s3">\n      </span><span class="s1">var neighbors = graph.get(currentNode);</span><span class="s3">\n      </span><span class="s1">neighbors.forEach(function (neighbor) {</span><span class="s3">\n        </span><span class="s1">if (positionMap.get(neighbor.id) &lt; positionMap.get(currentNode) + neighbor.gap) {</span><span class="s3">\n          </span><span class="s1">if (fixedNodes &amp;&amp; fixedNodes.has(neighbor.id)) {</span><span class="s3">\n            </span><span class="s1">var fixedPosition = void 0;</span><span class="s3">\n            </span><span class="s1">if (direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">fixedPosition = nodeIndexes.has(neighbor.id) ? xCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">fixedPosition = nodeIndexes.has(neighbor.id) ? yCoords[nodeIndexes.get(neighbor.id)] : dummyPositions.get(neighbor.id);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">positionMap.set(neighbor.id, fixedPosition); // TODO: may do unnecessary work</span><span class="s3">\n            </span><span class="s1">if (fixedPosition &lt; positionMap.get(currentNode) + neighbor.gap) {</span><span class="s3">\n              </span><span class="s1">var diff = positionMap.get(currentNode) + neighbor.gap - fixedPosition;</span><span class="s3">\n              </span><span class="s1">pastMap.get(currentNode).forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">positionMap.set(nodeId, positionMap.get(nodeId) - diff);</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">positionMap.set(neighbor.id, positionMap.get(currentNode) + neighbor.gap);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">inDegrees.set(neighbor.id, inDegrees.get(neighbor.id) - 1);</span><span class="s3">\n        </span><span class="s1">if (inDegrees.get(neighbor.id) == 0) {</span><span class="s3">\n          </span><span class="s1">queue.push(neighbor.id);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (fixedNodes) {</span><span class="s3">\n          </span><span class="s1">pastMap.set(neighbor.id, setUnion(pastMap.get(currentNode), pastMap.get(neighbor.id)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n\n    </span><span class="s1">while (queue.length != 0) {</span><span class="s3">\n      </span><span class="s1">_loop();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// readjust position of the nodes after enforcement</span><span class="s3">\n    </span><span class="s1">if (fixedNodes) {</span><span class="s3">\n      </span><span class="s1">// find indegree count for each node</span><span class="s3">\n      </span><span class="s1">var sinkNodes = new Set();</span><span class="s3">\n\n      </span><span class="s1">graph.forEach(function (value, key) {</span><span class="s3">\n        </span><span class="s1">if (value.length == 0) {</span><span class="s3">\n          </span><span class="s1">sinkNodes.add(key);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">var _components = [];</span><span class="s3">\n      </span><span class="s1">pastMap.forEach(function (value, key) {</span><span class="s3">\n        </span><span class="s1">if (sinkNodes.has(key)) {</span><span class="s3">\n          </span><span class="s1">var isFixedComponent = false;</span><span class="s3">\n          </span><span class="s1">var _iteratorNormalCompletion2 = true;</span><span class="s3">\n          </span><span class="s1">var _didIteratorError2 = false;</span><span class="s3">\n          </span><span class="s1">var _iteratorError2 = undefined;</span><span class="s3">\n\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {</span><span class="s3">\n              </span><span class="s1">var nodeId = _step2.value;</span><span class="s3">\n\n              </span><span class="s1">if (fixedNodes.has(nodeId)) {</span><span class="s3">\n                </span><span class="s1">isFixedComponent = true;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} catch (err) {</span><span class="s3">\n            </span><span class="s1">_didIteratorError2 = true;</span><span class="s3">\n            </span><span class="s1">_iteratorError2 = err;</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">try {</span><span class="s3">\n              </span><span class="s1">if (!_iteratorNormalCompletion2 &amp;&amp; _iterator2.return) {</span><span class="s3">\n                </span><span class="s1">_iterator2.return();</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} finally {</span><span class="s3">\n              </span><span class="s1">if (_didIteratorError2) {</span><span class="s3">\n                </span><span class="s1">throw _iteratorError2;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">if (!isFixedComponent) {</span><span class="s3">\n            </span><span class="s1">var isExist = false;</span><span class="s3">\n            </span><span class="s1">var existAt = void 0;</span><span class="s3">\n            </span><span class="s1">_components.forEach(function (component, index) {</span><span class="s3">\n              </span><span class="s1">if (component.has([].concat(_toConsumableArray(value))[0])) {</span><span class="s3">\n                </span><span class="s1">isExist = true;</span><span class="s3">\n                </span><span class="s1">existAt = index;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">if (!isExist) {</span><span class="s3">\n              </span><span class="s1">_components.push(new Set(value));</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">value.forEach(function (ele) {</span><span class="s3">\n                </span><span class="s1">_components[existAt].add(ele);</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">_components.forEach(function (component, index) {</span><span class="s3">\n        </span><span class="s1">var minBefore = Number.POSITIVE_INFINITY;</span><span class="s3">\n        </span><span class="s1">var minAfter = Number.POSITIVE_INFINITY;</span><span class="s3">\n        </span><span class="s1">var maxBefore = Number.NEGATIVE_INFINITY;</span><span class="s3">\n        </span><span class="s1">var maxAfter = Number.NEGATIVE_INFINITY;</span><span class="s3">\n\n        </span><span class="s1">var _iteratorNormalCompletion3 = true;</span><span class="s3">\n        </span><span class="s1">var _didIteratorError3 = false;</span><span class="s3">\n        </span><span class="s1">var _iteratorError3 = undefined;</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (var _iterator3 = component[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {</span><span class="s3">\n            </span><span class="s1">var nodeId = _step3.value;</span><span class="s3">\n\n            </span><span class="s1">var posBefore = void 0;</span><span class="s3">\n            </span><span class="s1">if (direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">posBefore = nodeIndexes.has(nodeId) ? xCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">posBefore = nodeIndexes.has(nodeId) ? yCoords[nodeIndexes.get(nodeId)] : dummyPositions.get(nodeId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var posAfter = positionMap.get(nodeId);</span><span class="s3">\n            </span><span class="s1">if (posBefore &lt; minBefore) {</span><span class="s3">\n              </span><span class="s1">minBefore = posBefore;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (posBefore &gt; maxBefore) {</span><span class="s3">\n              </span><span class="s1">maxBefore = posBefore;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (posAfter &lt; minAfter) {</span><span class="s3">\n              </span><span class="s1">minAfter = posAfter;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (posAfter &gt; maxAfter) {</span><span class="s3">\n              </span><span class="s1">maxAfter = posAfter;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_didIteratorError3 = true;</span><span class="s3">\n          </span><span class="s1">_iteratorError3 = err;</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (!_iteratorNormalCompletion3 &amp;&amp; _iterator3.return) {</span><span class="s3">\n              </span><span class="s1">_iterator3.return();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">if (_didIteratorError3) {</span><span class="s3">\n              </span><span class="s1">throw _iteratorError3;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">var diff = (minBefore + maxBefore) / 2 - (minAfter + maxAfter) / 2;</span><span class="s3">\n\n        </span><span class="s1">var _iteratorNormalCompletion4 = true;</span><span class="s3">\n        </span><span class="s1">var _didIteratorError4 = false;</span><span class="s3">\n        </span><span class="s1">var _iteratorError4 = undefined;</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (var _iterator4 = component[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {</span><span class="s3">\n            </span><span class="s1">var _nodeId = _step4.value;</span><span class="s3">\n\n            </span><span class="s1">positionMap.set(_nodeId, positionMap.get(_nodeId) + diff);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_didIteratorError4 = true;</span><span class="s3">\n          </span><span class="s1">_iteratorError4 = err;</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (!_iteratorNormalCompletion4 &amp;&amp; _iterator4.return) {</span><span class="s3">\n              </span><span class="s1">_iterator4.return();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">if (_didIteratorError4) {</span><span class="s3">\n              </span><span class="s1">throw _iteratorError4;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return positionMap;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// find transformation based on rel. placement constraints if there are both alignment and rel. placement constraints</span><span class="s3">\n  </span><span class="s1">// or if there are only rel. placement contraints where the largest component isn't sufficiently large</span><span class="s3">\n  </span><span class="s1">var applyReflectionForRelativePlacement = function applyReflectionForRelativePlacement(relativePlacementConstraints) {</span><span class="s3">\n    </span><span class="s1">// variables to count votes</span><span class="s3">\n    </span><span class="s1">var reflectOnY = 0,</span><span class="s3">\n        </span><span class="s1">notReflectOnY = 0;</span><span class="s3">\n    </span><span class="s1">var reflectOnX = 0,</span><span class="s3">\n        </span><span class="s1">notReflectOnX = 0;</span><span class="s3">\n\n    </span><span class="s1">relativePlacementConstraints.forEach(function (constraint) {</span><span class="s3">\n      </span><span class="s1">if (constraint.left) {</span><span class="s3">\n        </span><span class="s1">xCoords[nodeIndexes.get(constraint.left)] - xCoords[nodeIndexes.get(constraint.right)] &gt;= 0 ? reflectOnY++ : notReflectOnY++;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">yCoords[nodeIndexes.get(constraint.top)] - yCoords[nodeIndexes.get(constraint.bottom)] &gt;= 0 ? reflectOnX++ : notReflectOnX++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (reflectOnY &gt; notReflectOnY &amp;&amp; reflectOnX &gt; notReflectOnX) {</span><span class="s3">\n      </span><span class="s1">for (var _i = 0; _i &lt; nodeIndexes.size; _i++) {</span><span class="s3">\n        </span><span class="s1">xCoords[_i] = -1 * xCoords[_i];</span><span class="s3">\n        </span><span class="s1">yCoords[_i] = -1 * yCoords[_i];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (reflectOnY &gt; notReflectOnY) {</span><span class="s3">\n      </span><span class="s1">for (var _i2 = 0; _i2 &lt; nodeIndexes.size; _i2++) {</span><span class="s3">\n        </span><span class="s1">xCoords[_i2] = -1 * xCoords[_i2];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else if (reflectOnX &gt; notReflectOnX) {</span><span class="s3">\n      </span><span class="s1">for (var _i3 = 0; _i3 &lt; nodeIndexes.size; _i3++) {</span><span class="s3">\n        </span><span class="s1">yCoords[_i3] = -1 * yCoords[_i3];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// find weakly connected components in undirected graph</span><span class="s3">\n  </span><span class="s1">var findComponents = function findComponents(graph) {</span><span class="s3">\n    </span><span class="s1">// find weakly connected components in dag</span><span class="s3">\n    </span><span class="s1">var components = [];</span><span class="s3">\n    </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n    </span><span class="s1">var visited = new Set();</span><span class="s3">\n    </span><span class="s1">var count = 0;</span><span class="s3">\n\n    </span><span class="s1">graph.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">if (!visited.has(key)) {</span><span class="s3">\n        </span><span class="s1">components[count] = [];</span><span class="s3">\n        </span><span class="s1">var _currentNode = key;</span><span class="s3">\n        </span><span class="s1">queue.push(_currentNode);</span><span class="s3">\n        </span><span class="s1">visited.add(_currentNode);</span><span class="s3">\n        </span><span class="s1">components[count].push(_currentNode);</span><span class="s3">\n\n        </span><span class="s1">while (queue.length != 0) {</span><span class="s3">\n          </span><span class="s1">_currentNode = queue.shift();</span><span class="s3">\n          </span><span class="s1">var neighbors = graph.get(_currentNode);</span><span class="s3">\n          </span><span class="s1">neighbors.forEach(function (neighbor) {</span><span class="s3">\n            </span><span class="s1">if (!visited.has(neighbor.id)) {</span><span class="s3">\n              </span><span class="s1">queue.push(neighbor.id);</span><span class="s3">\n              </span><span class="s1">visited.add(neighbor.id);</span><span class="s3">\n              </span><span class="s1">components[count].push(neighbor.id);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">count++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return components;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// return undirected version of given dag</span><span class="s3">\n  </span><span class="s1">var dagToUndirected = function dagToUndirected(dag) {</span><span class="s3">\n    </span><span class="s1">var undirected = new Map();</span><span class="s3">\n\n    </span><span class="s1">dag.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">undirected.set(key, []);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">dag.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">value.forEach(function (adjacent) {</span><span class="s3">\n        </span><span class="s1">undirected.get(key).push(adjacent);</span><span class="s3">\n        </span><span class="s1">undirected.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return undirected;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">// return reversed (directions inverted) version of given dag</span><span class="s3">\n  </span><span class="s1">var dagToReversed = function dagToReversed(dag) {</span><span class="s3">\n    </span><span class="s1">var reversed = new Map();</span><span class="s3">\n\n    </span><span class="s1">dag.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">reversed.set(key, []);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">dag.forEach(function (value, key) {</span><span class="s3">\n      </span><span class="s1">value.forEach(function (adjacent) {</span><span class="s3">\n        </span><span class="s1">reversed.get(adjacent.id).push({ id: key, gap: adjacent.gap, direction: adjacent.direction });</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">return reversed;</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n\n  </span><span class="s1">/****  apply transformation to the initial draft layout to better align with constrained nodes ****/</span><span class="s3">\n  </span><span class="s1">// solve the Orthogonal Procrustean Problem to rotate and/or reflect initial draft layout</span><span class="s3">\n  </span><span class="s1">// here we follow the solution in Chapter 20.2 of Borg, I. &amp; Groenen, P. (2005) Modern Multidimensional Scaling: Theory and Applications </span><span class="s3">\n\n  </span><span class="s1">/* construct source and target configurations */</span><span class="s3">\n\n  </span><span class="s1">var targetMatrix = []; // A - target configuration</span><span class="s3">\n  </span><span class="s1">var sourceMatrix = []; // B - source configuration </span><span class="s3">\n  </span><span class="s1">var standardTransformation = false; // false for no transformation, true for standart (Procrustes) transformation (rotation and/or reflection)</span><span class="s3">\n  </span><span class="s1">var reflectionType = false; // false/true for reflection check, 'reflectOnX', 'reflectOnY' or 'reflectOnBoth' for reflection type if necessary</span><span class="s3">\n  </span><span class="s1">var fixedNodes = new Set();</span><span class="s3">\n  </span><span class="s1">var dag = new Map(); // adjacency list to keep directed acyclic graph (dag) that consists of relative placement constraints</span><span class="s3">\n  </span><span class="s1">var dagUndirected = new Map(); // undirected version of the dag</span><span class="s3">\n  </span><span class="s1">var components = []; // weakly connected components</span><span class="s3">\n\n  </span><span class="s1">// fill fixedNodes collection to use later</span><span class="s3">\n  </span><span class="s1">if (constraints.fixedNodeConstraint) {</span><span class="s3">\n    </span><span class="s1">constraints.fixedNodeConstraint.forEach(function (nodeData) {</span><span class="s3">\n      </span><span class="s1">fixedNodes.add(nodeData.nodeId);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// construct dag from relative placement constraints </span><span class="s3">\n  </span><span class="s1">if (constraints.relativePlacementConstraint) {</span><span class="s3">\n    </span><span class="s1">// construct both directed and undirected version of the dag</span><span class="s3">\n    </span><span class="s1">constraints.relativePlacementConstraint.forEach(function (constraint) {</span><span class="s3">\n      </span><span class="s1">if (constraint.left) {</span><span class="s3">\n        </span><span class="s1">if (dag.has(constraint.left)) {</span><span class="s3">\n          </span><span class="s1">dag.get(constraint.left).push({ id: constraint.right, gap: constraint.gap, direction: </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">dag.set(constraint.left, [{ id: constraint.right, gap: constraint.gap, direction: </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot; </span><span class="s1">}]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!dag.has(constraint.right)) {</span><span class="s3">\n          </span><span class="s1">dag.set(constraint.right, []);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (dag.has(constraint.top)) {</span><span class="s3">\n          </span><span class="s1">dag.get(constraint.top).push({ id: constraint.bottom, gap: constraint.gap, direction: </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot; </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">dag.set(constraint.top, [{ id: constraint.bottom, gap: constraint.gap, direction: </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot; </span><span class="s1">}]);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (!dag.has(constraint.bottom)) {</span><span class="s3">\n          </span><span class="s1">dag.set(constraint.bottom, []);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">dagUndirected = dagToUndirected(dag);</span><span class="s3">\n    </span><span class="s1">components = findComponents(dagUndirected);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING) {</span><span class="s3">\n    </span><span class="s1">// first check fixed node constraint</span><span class="s3">\n    </span><span class="s1">if (constraints.fixedNodeConstraint &amp;&amp; constraints.fixedNodeConstraint.length &gt; 1) {</span><span class="s3">\n      </span><span class="s1">constraints.fixedNodeConstraint.forEach(function (nodeData, i) {</span><span class="s3">\n        </span><span class="s1">targetMatrix[i] = [nodeData.position.x, nodeData.position.y];</span><span class="s3">\n        </span><span class="s1">sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeData.nodeId)], yCoords[nodeIndexes.get(nodeData.nodeId)]];</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">standardTransformation = true;</span><span class="s3">\n    </span><span class="s1">} else if (constraints.alignmentConstraint) {</span><span class="s3">\n      </span><span class="s1">(function () {</span><span class="s3">\n        </span><span class="s1">// then check alignment constraint</span><span class="s3">\n        </span><span class="s1">var count = 0;</span><span class="s3">\n        </span><span class="s1">if (constraints.alignmentConstraint.vertical) {</span><span class="s3">\n          </span><span class="s1">var verticalAlign = constraints.alignmentConstraint.vertical;</span><span class="s3">\n\n          </span><span class="s1">var _loop2 = function _loop2(_i4) {</span><span class="s3">\n            </span><span class="s1">var alignmentSet = new Set();</span><span class="s3">\n            </span><span class="s1">verticalAlign[_i4].forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">alignmentSet.add(nodeId);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {</span><span class="s3">\n              </span><span class="s1">return fixedNodes.has(x);</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">var xPos = void 0;</span><span class="s3">\n            </span><span class="s1">if (intersection.size &gt; 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;</span><span class="s3">\n\n            </span><span class="s1">verticalAlign[_i4].forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">targetMatrix[count] = [xPos, yCoords[nodeIndexes.get(nodeId)]];</span><span class="s3">\n              </span><span class="s1">sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];</span><span class="s3">\n              </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n\n          </span><span class="s1">for (var _i4 = 0; _i4 &lt; verticalAlign.length; _i4++) {</span><span class="s3">\n            </span><span class="s1">_loop2(_i4);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">standardTransformation = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (constraints.alignmentConstraint.horizontal) {</span><span class="s3">\n          </span><span class="s1">var horizontalAlign = constraints.alignmentConstraint.horizontal;</span><span class="s3">\n\n          </span><span class="s1">var _loop3 = function _loop3(_i5) {</span><span class="s3">\n            </span><span class="s1">var alignmentSet = new Set();</span><span class="s3">\n            </span><span class="s1">horizontalAlign[_i5].forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">alignmentSet.add(nodeId);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {</span><span class="s3">\n              </span><span class="s1">return fixedNodes.has(x);</span><span class="s3">\n            </span><span class="s1">}));</span><span class="s3">\n            </span><span class="s1">var yPos = void 0;</span><span class="s3">\n            </span><span class="s1">if (intersection.size &gt; 0) yPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;</span><span class="s3">\n\n            </span><span class="s1">horizontalAlign[_i5].forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">targetMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yPos];</span><span class="s3">\n              </span><span class="s1">sourceMatrix[count] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];</span><span class="s3">\n              </span><span class="s1">count++;</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n\n          </span><span class="s1">for (var _i5 = 0; _i5 &lt; horizontalAlign.length; _i5++) {</span><span class="s3">\n            </span><span class="s1">_loop3(_i5);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">standardTransformation = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (constraints.relativePlacementConstraint) {</span><span class="s3">\n          </span><span class="s1">reflectionType = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})();</span><span class="s3">\n    </span><span class="s1">} else if (constraints.relativePlacementConstraint) {</span><span class="s3">\n      </span><span class="s1">// finally check relative placement constraint</span><span class="s3">\n      </span><span class="s1">// find largest component in dag</span><span class="s3">\n      </span><span class="s1">var largestComponentSize = 0;</span><span class="s3">\n      </span><span class="s1">var largestComponentIndex = 0;</span><span class="s3">\n      </span><span class="s1">for (var _i6 = 0; _i6 &lt; components.length; _i6++) {</span><span class="s3">\n        </span><span class="s1">if (components[_i6].length &gt; largestComponentSize) {</span><span class="s3">\n          </span><span class="s1">largestComponentSize = components[_i6].length;</span><span class="s3">\n          </span><span class="s1">largestComponentIndex = _i6;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">// if largest component isn't dominant, then take the votes for reflection</span><span class="s3">\n      </span><span class="s1">if (largestComponentSize &lt; dagUndirected.size / 2) {</span><span class="s3">\n        </span><span class="s1">applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);</span><span class="s3">\n        </span><span class="s1">standardTransformation = false;</span><span class="s3">\n        </span><span class="s1">reflectionType = false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">// use largest component for transformation</span><span class="s3">\n        </span><span class="s1">// construct horizontal and vertical subgraphs in the largest component</span><span class="s3">\n        </span><span class="s1">var subGraphOnHorizontal = new Map();</span><span class="s3">\n        </span><span class="s1">var subGraphOnVertical = new Map();</span><span class="s3">\n        </span><span class="s1">var constraintsInlargestComponent = [];</span><span class="s3">\n\n        </span><span class="s1">components[largestComponentIndex].forEach(function (nodeId) {</span><span class="s3">\n          </span><span class="s1">dag.get(nodeId).forEach(function (adjacent) {</span><span class="s3">\n            </span><span class="s1">if (adjacent.direction == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">if (subGraphOnHorizontal.has(nodeId)) {</span><span class="s3">\n                </span><span class="s1">subGraphOnHorizontal.get(nodeId).push(adjacent);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">subGraphOnHorizontal.set(nodeId, [adjacent]);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (!subGraphOnHorizontal.has(adjacent.id)) {</span><span class="s3">\n                </span><span class="s1">subGraphOnHorizontal.set(adjacent.id, []);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">constraintsInlargestComponent.push({ left: nodeId, right: adjacent.id });</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">if (subGraphOnVertical.has(nodeId)) {</span><span class="s3">\n                </span><span class="s1">subGraphOnVertical.get(nodeId).push(adjacent);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">subGraphOnVertical.set(nodeId, [adjacent]);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (!subGraphOnVertical.has(adjacent.id)) {</span><span class="s3">\n                </span><span class="s1">subGraphOnVertical.set(adjacent.id, []);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">constraintsInlargestComponent.push({ top: nodeId, bottom: adjacent.id });</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">applyReflectionForRelativePlacement(constraintsInlargestComponent);</span><span class="s3">\n        </span><span class="s1">reflectionType = false;</span><span class="s3">\n\n        </span><span class="s1">// calculate appropriate positioning for subgraphs</span><span class="s3">\n        </span><span class="s1">var positionMapHorizontal = findAppropriatePositionForRelativePlacement(subGraphOnHorizontal, </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">var positionMapVertical = findAppropriatePositionForRelativePlacement(subGraphOnVertical, </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n        </span><span class="s1">// construct source and target configuration</span><span class="s3">\n        </span><span class="s1">components[largestComponentIndex].forEach(function (nodeId, i) {</span><span class="s3">\n          </span><span class="s1">sourceMatrix[i] = [xCoords[nodeIndexes.get(nodeId)], yCoords[nodeIndexes.get(nodeId)]];</span><span class="s3">\n          </span><span class="s1">targetMatrix[i] = [];</span><span class="s3">\n          </span><span class="s1">if (positionMapHorizontal.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">targetMatrix[i][0] = positionMapHorizontal.get(nodeId);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">targetMatrix[i][0] = xCoords[nodeIndexes.get(nodeId)];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (positionMapVertical.has(nodeId)) {</span><span class="s3">\n            </span><span class="s1">targetMatrix[i][1] = positionMapVertical.get(nodeId);</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">targetMatrix[i][1] = yCoords[nodeIndexes.get(nodeId)];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">standardTransformation = true;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if transformation is required, then calculate and apply transformation matrix</span><span class="s3">\n    </span><span class="s1">if (standardTransformation) {</span><span class="s3">\n      </span><span class="s1">/* calculate transformation matrix */</span><span class="s3">\n      </span><span class="s1">var transformationMatrix = void 0;</span><span class="s3">\n      </span><span class="s1">var targetMatrixTranspose = Matrix.transpose(targetMatrix); // A'</span><span class="s3">\n      </span><span class="s1">var sourceMatrixTranspose = Matrix.transpose(sourceMatrix); // B'</span><span class="s3">\n\n      </span><span class="s1">// centralize transpose matrices</span><span class="s3">\n      </span><span class="s1">for (var _i7 = 0; _i7 &lt; targetMatrixTranspose.length; _i7++) {</span><span class="s3">\n        </span><span class="s1">targetMatrixTranspose[_i7] = Matrix.multGamma(targetMatrixTranspose[_i7]);</span><span class="s3">\n        </span><span class="s1">sourceMatrixTranspose[_i7] = Matrix.multGamma(sourceMatrixTranspose[_i7]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// do actual calculation for transformation matrix</span><span class="s3">\n      </span><span class="s1">var tempMatrix = Matrix.multMat(targetMatrixTranspose, Matrix.transpose(sourceMatrixTranspose)); // tempMatrix = A'B</span><span class="s3">\n      </span><span class="s1">var SVDResult = SVD.svd(tempMatrix); // SVD(A'B) = USV', svd function returns U, S and V </span><span class="s3">\n      </span><span class="s1">transformationMatrix = Matrix.multMat(SVDResult.V, Matrix.transpose(SVDResult.U)); // transformationMatrix = T = VU'</span><span class="s3">\n\n      </span><span class="s1">/* apply found transformation matrix to obtain final draft layout */</span><span class="s3">\n      </span><span class="s1">for (var _i8 = 0; _i8 &lt; nodeIndexes.size; _i8++) {</span><span class="s3">\n        </span><span class="s1">var temp1 = [xCoords[_i8], yCoords[_i8]];</span><span class="s3">\n        </span><span class="s1">var temp2 = [transformationMatrix[0][0], transformationMatrix[1][0]];</span><span class="s3">\n        </span><span class="s1">var temp3 = [transformationMatrix[0][1], transformationMatrix[1][1]];</span><span class="s3">\n        </span><span class="s1">xCoords[_i8] = Matrix.dotProduct(temp1, temp2);</span><span class="s3">\n        </span><span class="s1">yCoords[_i8] = Matrix.dotProduct(temp1, temp3);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// applied only both alignment and rel. placement constraints exist</span><span class="s3">\n      </span><span class="s1">if (reflectionType) {</span><span class="s3">\n        </span><span class="s1">applyReflectionForRelativePlacement(constraints.relativePlacementConstraint);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (CoSEConstants.ENFORCE_CONSTRAINTS) {</span><span class="s3">\n    </span><span class="s1">/****  enforce constraints on the transformed draft layout ****/</span><span class="s3">\n\n    </span><span class="s1">/* first enforce fixed node constraint */</span><span class="s3">\n\n    </span><span class="s1">if (constraints.fixedNodeConstraint &amp;&amp; constraints.fixedNodeConstraint.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var translationAmount = { x: 0, y: 0 };</span><span class="s3">\n      </span><span class="s1">constraints.fixedNodeConstraint.forEach(function (nodeData, i) {</span><span class="s3">\n        </span><span class="s1">var posInTheory = { x: xCoords[nodeIndexes.get(nodeData.nodeId)], y: yCoords[nodeIndexes.get(nodeData.nodeId)] };</span><span class="s3">\n        </span><span class="s1">var posDesired = nodeData.position;</span><span class="s3">\n        </span><span class="s1">var posDiff = calculatePositionDiff(posDesired, posInTheory);</span><span class="s3">\n        </span><span class="s1">translationAmount.x += posDiff.x;</span><span class="s3">\n        </span><span class="s1">translationAmount.y += posDiff.y;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">translationAmount.x /= constraints.fixedNodeConstraint.length;</span><span class="s3">\n      </span><span class="s1">translationAmount.y /= constraints.fixedNodeConstraint.length;</span><span class="s3">\n\n      </span><span class="s1">xCoords.forEach(function (value, i) {</span><span class="s3">\n        </span><span class="s1">xCoords[i] += translationAmount.x;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">yCoords.forEach(function (value, i) {</span><span class="s3">\n        </span><span class="s1">yCoords[i] += translationAmount.y;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n\n      </span><span class="s1">constraints.fixedNodeConstraint.forEach(function (nodeData) {</span><span class="s3">\n        </span><span class="s1">xCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.x;</span><span class="s3">\n        </span><span class="s1">yCoords[nodeIndexes.get(nodeData.nodeId)] = nodeData.position.y;</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* then enforce alignment constraint */</span><span class="s3">\n\n    </span><span class="s1">if (constraints.alignmentConstraint) {</span><span class="s3">\n      </span><span class="s1">if (constraints.alignmentConstraint.vertical) {</span><span class="s3">\n        </span><span class="s1">var xAlign = constraints.alignmentConstraint.vertical;</span><span class="s3">\n\n        </span><span class="s1">var _loop4 = function _loop4(_i9) {</span><span class="s3">\n          </span><span class="s1">var alignmentSet = new Set();</span><span class="s3">\n          </span><span class="s1">xAlign[_i9].forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">alignmentSet.add(nodeId);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {</span><span class="s3">\n            </span><span class="s1">return fixedNodes.has(x);</span><span class="s3">\n          </span><span class="s1">}));</span><span class="s3">\n          </span><span class="s1">var xPos = void 0;</span><span class="s3">\n          </span><span class="s1">if (intersection.size &gt; 0) xPos = xCoords[nodeIndexes.get(intersection.values().next().value)];else xPos = calculateAvgPosition(alignmentSet).x;</span><span class="s3">\n\n          </span><span class="s1">alignmentSet.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (!fixedNodes.has(nodeId)) xCoords[nodeIndexes.get(nodeId)] = xPos;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">for (var _i9 = 0; _i9 &lt; xAlign.length; _i9++) {</span><span class="s3">\n          </span><span class="s1">_loop4(_i9);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (constraints.alignmentConstraint.horizontal) {</span><span class="s3">\n        </span><span class="s1">var yAlign = constraints.alignmentConstraint.horizontal;</span><span class="s3">\n\n        </span><span class="s1">var _loop5 = function _loop5(_i10) {</span><span class="s3">\n          </span><span class="s1">var alignmentSet = new Set();</span><span class="s3">\n          </span><span class="s1">yAlign[_i10].forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">alignmentSet.add(nodeId);</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">var intersection = new Set([].concat(_toConsumableArray(alignmentSet)).filter(function (x) {</span><span class="s3">\n            </span><span class="s1">return fixedNodes.has(x);</span><span class="s3">\n          </span><span class="s1">}));</span><span class="s3">\n          </span><span class="s1">var yPos = void 0;</span><span class="s3">\n          </span><span class="s1">if (intersection.size &gt; 0) yPos = yCoords[nodeIndexes.get(intersection.values().next().value)];else yPos = calculateAvgPosition(alignmentSet).y;</span><span class="s3">\n\n          </span><span class="s1">alignmentSet.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (!fixedNodes.has(nodeId)) yCoords[nodeIndexes.get(nodeId)] = yPos;</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">for (var _i10 = 0; _i10 &lt; yAlign.length; _i10++) {</span><span class="s3">\n          </span><span class="s1">_loop5(_i10);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">/* finally enforce relative placement constraint */</span><span class="s3">\n\n    </span><span class="s1">if (constraints.relativePlacementConstraint) {</span><span class="s3">\n      </span><span class="s1">(function () {</span><span class="s3">\n        </span><span class="s1">var nodeToDummyForVerticalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var nodeToDummyForHorizontalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var dummyToNodeForVerticalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var dummyToNodeForHorizontalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var dummyPositionsForVerticalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var dummyPositionsForHorizontalAlignment = new Map();</span><span class="s3">\n        </span><span class="s1">var fixedNodesOnHorizontal = new Set();</span><span class="s3">\n        </span><span class="s1">var fixedNodesOnVertical = new Set();</span><span class="s3">\n\n        </span><span class="s1">// fill maps and sets      </span><span class="s3">\n        </span><span class="s1">fixedNodes.forEach(function (nodeId) {</span><span class="s3">\n          </span><span class="s1">fixedNodesOnHorizontal.add(nodeId);</span><span class="s3">\n          </span><span class="s1">fixedNodesOnVertical.add(nodeId);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">if (constraints.alignmentConstraint) {</span><span class="s3">\n          </span><span class="s1">if (constraints.alignmentConstraint.vertical) {</span><span class="s3">\n            </span><span class="s1">var verticalAlignment = constraints.alignmentConstraint.vertical;</span><span class="s3">\n\n            </span><span class="s1">var _loop6 = function _loop6(_i11) {</span><span class="s3">\n              </span><span class="s1">dummyToNodeForVerticalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i11, []);</span><span class="s3">\n              </span><span class="s1">verticalAlignment[_i11].forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">nodeToDummyForVerticalAlignment.set(nodeId, </span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i11);</span><span class="s3">\n                </span><span class="s1">dummyToNodeForVerticalAlignment.get(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i11).push(nodeId);</span><span class="s3">\n                </span><span class="s1">if (fixedNodes.has(nodeId)) {</span><span class="s3">\n                  </span><span class="s1">fixedNodesOnHorizontal.add(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i11);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">dummyPositionsForVerticalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i11, xCoords[nodeIndexes.get(verticalAlignment[_i11][0])]);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n\n            </span><span class="s1">for (var _i11 = 0; _i11 &lt; verticalAlignment.length; _i11++) {</span><span class="s3">\n              </span><span class="s1">_loop6(_i11);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">if (constraints.alignmentConstraint.horizontal) {</span><span class="s3">\n            </span><span class="s1">var horizontalAlignment = constraints.alignmentConstraint.horizontal;</span><span class="s3">\n\n            </span><span class="s1">var _loop7 = function _loop7(_i12) {</span><span class="s3">\n              </span><span class="s1">dummyToNodeForHorizontalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i12, []);</span><span class="s3">\n              </span><span class="s1">horizontalAlignment[_i12].forEach(function (nodeId) {</span><span class="s3">\n                </span><span class="s1">nodeToDummyForHorizontalAlignment.set(nodeId, </span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i12);</span><span class="s3">\n                </span><span class="s1">dummyToNodeForHorizontalAlignment.get(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i12).push(nodeId);</span><span class="s3">\n                </span><span class="s1">if (fixedNodes.has(nodeId)) {</span><span class="s3">\n                  </span><span class="s1">fixedNodesOnVertical.add(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i12);</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n              </span><span class="s1">dummyPositionsForHorizontalAlignment.set(</span><span class="s3">\&quot;</span><span class="s1">dummy</span><span class="s3">\&quot; </span><span class="s1">+ _i12, yCoords[nodeIndexes.get(horizontalAlignment[_i12][0])]);</span><span class="s3">\n            </span><span class="s1">};</span><span class="s3">\n\n            </span><span class="s1">for (var _i12 = 0; _i12 &lt; horizontalAlignment.length; _i12++) {</span><span class="s3">\n              </span><span class="s1">_loop7(_i12);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// construct horizontal and vertical dags (subgraphs) from overall dag</span><span class="s3">\n        </span><span class="s1">var dagOnHorizontal = new Map();</span><span class="s3">\n        </span><span class="s1">var dagOnVertical = new Map();</span><span class="s3">\n\n        </span><span class="s1">var _loop8 = function _loop8(nodeId) {</span><span class="s3">\n          </span><span class="s1">dag.get(nodeId).forEach(function (adjacent) {</span><span class="s3">\n            </span><span class="s1">var sourceId = void 0;</span><span class="s3">\n            </span><span class="s1">var targetNode = void 0;</span><span class="s3">\n            </span><span class="s1">if (adjacent[</span><span class="s3">\&quot;</span><span class="s1">direction</span><span class="s3">\&quot;</span><span class="s1">] == </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">sourceId = nodeToDummyForVerticalAlignment.get(nodeId) ? nodeToDummyForVerticalAlignment.get(nodeId) : nodeId;</span><span class="s3">\n              </span><span class="s1">if (nodeToDummyForVerticalAlignment.get(adjacent.id)) {</span><span class="s3">\n                </span><span class="s1">targetNode = { id: nodeToDummyForVerticalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">targetNode = adjacent;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (dagOnHorizontal.has(sourceId)) {</span><span class="s3">\n                </span><span class="s1">dagOnHorizontal.get(sourceId).push(targetNode);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">dagOnHorizontal.set(sourceId, [targetNode]);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (!dagOnHorizontal.has(targetNode.id)) {</span><span class="s3">\n                </span><span class="s1">dagOnHorizontal.set(targetNode.id, []);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">sourceId = nodeToDummyForHorizontalAlignment.get(nodeId) ? nodeToDummyForHorizontalAlignment.get(nodeId) : nodeId;</span><span class="s3">\n              </span><span class="s1">if (nodeToDummyForHorizontalAlignment.get(adjacent.id)) {</span><span class="s3">\n                </span><span class="s1">targetNode = { id: nodeToDummyForHorizontalAlignment.get(adjacent.id), gap: adjacent.gap, direction: adjacent.direction };</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">targetNode = adjacent;</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (dagOnVertical.has(sourceId)) {</span><span class="s3">\n                </span><span class="s1">dagOnVertical.get(sourceId).push(targetNode);</span><span class="s3">\n              </span><span class="s1">} else {</span><span class="s3">\n                </span><span class="s1">dagOnVertical.set(sourceId, [targetNode]);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n              </span><span class="s1">if (!dagOnVertical.has(targetNode.id)) {</span><span class="s3">\n                </span><span class="s1">dagOnVertical.set(targetNode.id, []);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">var _iteratorNormalCompletion5 = true;</span><span class="s3">\n        </span><span class="s1">var _didIteratorError5 = false;</span><span class="s3">\n        </span><span class="s1">var _iteratorError5 = undefined;</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (var _iterator5 = dag.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {</span><span class="s3">\n            </span><span class="s1">var nodeId = _step5.value;</span><span class="s3">\n\n            </span><span class="s1">_loop8(nodeId);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">// find source nodes of each component in horizontal and vertical dags</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_didIteratorError5 = true;</span><span class="s3">\n          </span><span class="s1">_iteratorError5 = err;</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (!_iteratorNormalCompletion5 &amp;&amp; _iterator5.return) {</span><span class="s3">\n              </span><span class="s1">_iterator5.return();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">if (_didIteratorError5) {</span><span class="s3">\n              </span><span class="s1">throw _iteratorError5;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">var undirectedOnHorizontal = dagToUndirected(dagOnHorizontal);</span><span class="s3">\n        </span><span class="s1">var undirectedOnVertical = dagToUndirected(dagOnVertical);</span><span class="s3">\n        </span><span class="s1">var componentsOnHorizontal = findComponents(undirectedOnHorizontal);</span><span class="s3">\n        </span><span class="s1">var componentsOnVertical = findComponents(undirectedOnVertical);</span><span class="s3">\n        </span><span class="s1">var reversedDagOnHorizontal = dagToReversed(dagOnHorizontal);</span><span class="s3">\n        </span><span class="s1">var reversedDagOnVertical = dagToReversed(dagOnVertical);</span><span class="s3">\n        </span><span class="s1">var componentSourcesOnHorizontal = [];</span><span class="s3">\n        </span><span class="s1">var componentSourcesOnVertical = [];</span><span class="s3">\n\n        </span><span class="s1">componentsOnHorizontal.forEach(function (component, index) {</span><span class="s3">\n          </span><span class="s1">componentSourcesOnHorizontal[index] = [];</span><span class="s3">\n          </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (reversedDagOnHorizontal.get(nodeId).length == 0) {</span><span class="s3">\n              </span><span class="s1">componentSourcesOnHorizontal[index].push(nodeId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">componentsOnVertical.forEach(function (component, index) {</span><span class="s3">\n          </span><span class="s1">componentSourcesOnVertical[index] = [];</span><span class="s3">\n          </span><span class="s1">component.forEach(function (nodeId) {</span><span class="s3">\n            </span><span class="s1">if (reversedDagOnVertical.get(nodeId).length == 0) {</span><span class="s3">\n              </span><span class="s1">componentSourcesOnVertical[index].push(nodeId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n\n        </span><span class="s1">// calculate appropriate positioning for subgraphs</span><span class="s3">\n        </span><span class="s1">var positionMapHorizontal = findAppropriatePositionForRelativePlacement(dagOnHorizontal, </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">, fixedNodesOnHorizontal, dummyPositionsForVerticalAlignment, componentSourcesOnHorizontal);</span><span class="s3">\n        </span><span class="s1">var positionMapVertical = findAppropriatePositionForRelativePlacement(dagOnVertical, </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot;</span><span class="s1">, fixedNodesOnVertical, dummyPositionsForHorizontalAlignment, componentSourcesOnVertical);</span><span class="s3">\n\n        </span><span class="s1">// update positions of the nodes based on relative placement constraints</span><span class="s3">\n\n        </span><span class="s1">var _loop9 = function _loop9(key) {</span><span class="s3">\n          </span><span class="s1">if (dummyToNodeForVerticalAlignment.get(key)) {</span><span class="s3">\n            </span><span class="s1">dummyToNodeForVerticalAlignment.get(key).forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">xCoords[nodeIndexes.get(nodeId)] = positionMapHorizontal.get(key);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">xCoords[nodeIndexes.get(key)] = positionMapHorizontal.get(key);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">var _iteratorNormalCompletion6 = true;</span><span class="s3">\n        </span><span class="s1">var _didIteratorError6 = false;</span><span class="s3">\n        </span><span class="s1">var _iteratorError6 = undefined;</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (var _iterator6 = positionMapHorizontal.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {</span><span class="s3">\n            </span><span class="s1">var key = _step6.value;</span><span class="s3">\n\n            </span><span class="s1">_loop9(key);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_didIteratorError6 = true;</span><span class="s3">\n          </span><span class="s1">_iteratorError6 = err;</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (!_iteratorNormalCompletion6 &amp;&amp; _iterator6.return) {</span><span class="s3">\n              </span><span class="s1">_iterator6.return();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">if (_didIteratorError6) {</span><span class="s3">\n              </span><span class="s1">throw _iteratorError6;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">var _loop10 = function _loop10(key) {</span><span class="s3">\n          </span><span class="s1">if (dummyToNodeForHorizontalAlignment.get(key)) {</span><span class="s3">\n            </span><span class="s1">dummyToNodeForHorizontalAlignment.get(key).forEach(function (nodeId) {</span><span class="s3">\n              </span><span class="s1">yCoords[nodeIndexes.get(nodeId)] = positionMapVertical.get(key);</span><span class="s3">\n            </span><span class="s1">});</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">yCoords[nodeIndexes.get(key)] = positionMapVertical.get(key);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n\n        </span><span class="s1">var _iteratorNormalCompletion7 = true;</span><span class="s3">\n        </span><span class="s1">var _didIteratorError7 = false;</span><span class="s3">\n        </span><span class="s1">var _iteratorError7 = undefined;</span><span class="s3">\n\n        </span><span class="s1">try {</span><span class="s3">\n          </span><span class="s1">for (var _iterator7 = positionMapVertical.keys()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {</span><span class="s3">\n            </span><span class="s1">var key = _step7.value;</span><span class="s3">\n\n            </span><span class="s1">_loop10(key);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} catch (err) {</span><span class="s3">\n          </span><span class="s1">_didIteratorError7 = true;</span><span class="s3">\n          </span><span class="s1">_iteratorError7 = err;</span><span class="s3">\n        </span><span class="s1">} finally {</span><span class="s3">\n          </span><span class="s1">try {</span><span class="s3">\n            </span><span class="s1">if (!_iteratorNormalCompletion7 &amp;&amp; _iterator7.return) {</span><span class="s3">\n              </span><span class="s1">_iterator7.return();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">} finally {</span><span class="s3">\n            </span><span class="s1">if (_didIteratorError7) {</span><span class="s3">\n              </span><span class="s1">throw _iteratorError7;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">})();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// assign new coordinates to nodes after constraint handling</span><span class="s3">\n  </span><span class="s1">for (var _i13 = 0; _i13 &lt; allNodes.length; _i13++) {</span><span class="s3">\n    </span><span class="s1">var _node = allNodes[_i13];</span><span class="s3">\n    </span><span class="s1">if (_node.getChild() == null) {</span><span class="s3">\n      </span><span class="s1">_node.setCenter(xCoords[nodeIndexes.get(_node.id)], yCoords[nodeIndexes.get(_node.id)]);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = ConstraintHandler;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n\n</span><span class="s1">/***/ 551:</span><span class="s3">\n</span><span class="s1">/***/ ((module) =&gt; {</span><span class="s3">\n\n</span><span class="s1">module.exports = __WEBPACK_EXTERNAL_MODULE__551__;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_module_cache__ = {};</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var cachedModule = __webpack_module_cache__[moduleId];</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if (cachedModule !== undefined) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return cachedModule.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = __webpack_module_cache__[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">// no module.id needed</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">// no module.loaded needed</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_modules__[moduleId](module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// startup</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// This entry module is referenced by other modules so it can't be inlined</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var __webpack_exports__ = __webpack_require__(45);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_exports__;</span><span class="s3">\n</span><span class="s1">/******/ })()</span><span class="s3">\n</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;(function webpackUniversalModuleDefinition(root, factory) {</span><span class="s3">\n\t</span><span class="s1">if(typeof exports === 'object' &amp;&amp; typeof module === 'object')</span><span class="s3">\n\t\t</span><span class="s1">module.exports = factory();</span><span class="s3">\n\t</span><span class="s1">else if(typeof define === 'function' &amp;&amp; define.amd)</span><span class="s3">\n\t\t</span><span class="s1">define([], factory);</span><span class="s3">\n\t</span><span class="s1">else if(typeof exports === 'object')</span><span class="s3">\n\t\t</span><span class="s1">exports[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n\t</span><span class="s1">else</span><span class="s3">\n\t\t</span><span class="s1">root[</span><span class="s3">\&quot;</span><span class="s1">layoutBase</span><span class="s3">\&quot;</span><span class="s1">] = factory();</span><span class="s3">\n</span><span class="s1">})(this, function() {</span><span class="s3">\n</span><span class="s1">return /******/ (function(modules) { // webpackBootstrap</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">var installedModules = {};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// The require function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">function __webpack_require__(moduleId) {</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Check if module is in cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(installedModules[moduleId]) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">return installedModules[moduleId].exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Create a new module (and put it into the cache)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var module = installedModules[moduleId] = {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">i: moduleId,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">l: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">exports: {}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Execute the module function</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Flag the module as loaded</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">module.l = true;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">// Return the exports of the module</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return module.exports;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the modules object (__webpack_modules__)</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.m = modules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// expose the module cache</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.c = installedModules;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// identity function for calling harmony imports with the correct context</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.i = function(value) { return value; };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// define getter function for harmony exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.d = function(exports, name, getter) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">if(!__webpack_require__.o(exports, name)) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">Object.defineProperty(exports, name, {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">configurable: false,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">enumerable: true,</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t\t</span><span class="s1">get: getter</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">});</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// getDefaultExport function for compatibility with non-harmony modules</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.n = function(module) {</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">var getter = module &amp;&amp; module.__esModule ?</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getDefault() { return module['default']; } :</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t\t</span><span class="s1">function getModuleExports() { return module; };</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">__webpack_require__.d(getter, 'a', getter);</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t\t</span><span class="s1">return getter;</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Object.prototype.hasOwnProperty.call</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// __webpack_public_path__</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">__webpack_require__.p = </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">/******/</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">// Load entry module and return exports</span><span class="s3">\n</span><span class="s1">/******/ </span><span class="s3">\t</span><span class="s1">return __webpack_require__(__webpack_require__.s = 28);</span><span class="s3">\n</span><span class="s1">/******/ })</span><span class="s3">\n</span><span class="s1">/************************************************************************/</span><span class="s3">\n</span><span class="s1">/******/ ([</span><span class="s3">\n</span><span class="s1">/* 0 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function LayoutConstants() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Layout Quality: 0:draft, 1:default, 2:proof</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.QUALITY = 1;</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* Default parameters</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_INCREMENTAL = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT = true;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT = false;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_ANIMATION_PERIOD = 50;</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = false;</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: General other constants</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Margins of a graph to be applied on bouding rectangle of its contents. We</span><span class="s3">\r\n </span><span class="s1">* assume margins on all four sides to be uniform.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.DEFAULT_GRAPH_MARGIN = 15;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Whether to consider labels in node dimensions or not</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = false;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Default dimension of a non-compound node.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.SIMPLE_NODE_SIZE = 40;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Default dimension of a non-compound node.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.SIMPLE_NODE_HALF_SIZE = LayoutConstants.SIMPLE_NODE_SIZE / 2;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Empty compound node size. When a compound node is empty, its both</span><span class="s3">\r\n </span><span class="s1">* dimensions should be of this value.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.EMPTY_COMPOUND_NODE_SIZE = 40;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Minimum length that an edge should take during layout</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.MIN_EDGE_LENGTH = 1;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* World boundaries that layout operates on</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_BOUNDARY = 1000000;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* World boundaries that random positioning can be performed with</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.INITIAL_WORLD_BOUNDARY = LayoutConstants.WORLD_BOUNDARY / 1000;</span><span class="s3">\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">* Coordinates of the world center</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_CENTER_X = 1200;</span><span class="s3">\n</span><span class="s1">LayoutConstants.WORLD_CENTER_Y = 900;</span><span class="s3">\n\n</span><span class="s1">module.exports = LayoutConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 1 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(9);</span><span class="s3">\n\n</span><span class="s1">function LEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">LGraphObject.call(this, vEdge);</span><span class="s3">\n\n  </span><span class="s1">this.isOverlapingSourceAndTarget = false;</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vEdge;</span><span class="s3">\n  </span><span class="s1">this.bendpoints = [];</span><span class="s3">\n  </span><span class="s1">this.source = source;</span><span class="s3">\n  </span><span class="s1">this.target = target;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LEdge[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getSource = function () {</span><span class="s3">\n  </span><span class="s1">return this.source;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getTarget = function () {</span><span class="s3">\n  </span><span class="s1">return this.target;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.isInterGraph = function () {</span><span class="s3">\n  </span><span class="s1">return this.isInterGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getLength = function () {</span><span class="s3">\n  </span><span class="s1">return this.length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.isOverlapingSourceAndTarget = function () {</span><span class="s3">\n  </span><span class="s1">return this.isOverlapingSourceAndTarget;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getBendpoints = function () {</span><span class="s3">\n  </span><span class="s1">return this.bendpoints;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.lca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getSourceInLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.sourceInLca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getTargetInLca = function () {</span><span class="s3">\n  </span><span class="s1">return this.targetInLca;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getOtherEnd = function (node) {</span><span class="s3">\n  </span><span class="s1">if (this.source === node) {</span><span class="s3">\n    </span><span class="s1">return this.target;</span><span class="s3">\n  </span><span class="s1">} else if (this.target === node) {</span><span class="s3">\n    </span><span class="s1">return this.source;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node is not incident with this edge</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.getOtherEndInGraph = function (node, graph) {</span><span class="s3">\n  </span><span class="s1">var otherEnd = this.getOtherEnd(node);</span><span class="s3">\n  </span><span class="s1">var root = graph.getGraphManager().getRoot();</span><span class="s3">\n\n  </span><span class="s1">while (true) {</span><span class="s3">\n    </span><span class="s1">if (otherEnd.getOwner() == graph) {</span><span class="s3">\n      </span><span class="s1">return otherEnd;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (otherEnd.getOwner() == root) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">otherEnd = otherEnd.getOwner().getParent();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.updateLength = function () {</span><span class="s3">\n  </span><span class="s1">var clipPointCoordinates = new Array(4);</span><span class="s3">\n\n  </span><span class="s1">this.isOverlapingSourceAndTarget = IGeometry.getIntersection(this.target.getRect(), this.source.getRect(), clipPointCoordinates);</span><span class="s3">\n\n  </span><span class="s1">if (!this.isOverlapingSourceAndTarget) {</span><span class="s3">\n    </span><span class="s1">this.lengthX = clipPointCoordinates[0] - clipPointCoordinates[2];</span><span class="s3">\n    </span><span class="s1">this.lengthY = clipPointCoordinates[1] - clipPointCoordinates[3];</span><span class="s3">\n\n    </span><span class="s1">if (Math.abs(this.lengthX) &lt; 1.0) {</span><span class="s3">\n      </span><span class="s1">this.lengthX = IMath.sign(this.lengthX);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (Math.abs(this.lengthY) &lt; 1.0) {</span><span class="s3">\n      </span><span class="s1">this.lengthY = IMath.sign(this.lengthY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LEdge.prototype.updateLengthSimple = function () {</span><span class="s3">\n  </span><span class="s1">this.lengthX = this.target.getCenterX() - this.source.getCenterX();</span><span class="s3">\n  </span><span class="s1">this.lengthY = this.target.getCenterY() - this.source.getCenterY();</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.lengthX) &lt; 1.0) {</span><span class="s3">\n    </span><span class="s1">this.lengthX = IMath.sign(this.lengthX);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (Math.abs(this.lengthY) &lt; 1.0) {</span><span class="s3">\n    </span><span class="s1">this.lengthY = IMath.sign(this.lengthY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.length = Math.sqrt(this.lengthX * this.lengthX + this.lengthY * this.lengthY);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 2 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function LGraphObject(vGraphObject) {</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vGraphObject;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraphObject;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 3 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">var RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var RandomSeed = __webpack_require__(16);</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(5);</span><span class="s3">\n\n</span><span class="s1">function LNode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">//Alternative constructor 1 : LNode(LGraphManager gm, Point loc, Dimension size, Object vNode)</span><span class="s3">\n  </span><span class="s1">if (size == null &amp;&amp; vNode == null) {</span><span class="s3">\n    </span><span class="s1">vNode = loc;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">LGraphObject.call(this, vNode);</span><span class="s3">\n\n  </span><span class="s1">//Alternative constructor 2 : LNode(Layout layout, Object vNode)</span><span class="s3">\n  </span><span class="s1">if (gm.graphManager != null) gm = gm.graphManager;</span><span class="s3">\n\n  </span><span class="s1">this.estimatedSize = Integer.MIN_VALUE;</span><span class="s3">\n  </span><span class="s1">this.inclusionTreeDepth = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">this.vGraphObject = vNode;</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n\n  </span><span class="s1">if (size != null &amp;&amp; loc != null) this.rect = new RectangleD(loc.x, loc.y, size.width, size.height);else this.rect = new RectangleD();</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LNode.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LNode[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.edges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getChild = function () {</span><span class="s3">\n  </span><span class="s1">return this.child;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getOwner = function () {</span><span class="s3">\n  </span><span class="s1">//  if (this.owner != null) {</span><span class="s3">\n  </span><span class="s1">//    if (!(this.owner == null || this.owner.getNodes().indexOf(this) &gt; -1)) {</span><span class="s3">\n  </span><span class="s1">//      throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">//    }</span><span class="s3">\n  </span><span class="s1">//  }</span><span class="s3">\n\n  </span><span class="s1">return this.owner;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.rect.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.rect.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenterX = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x + this.rect.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenterY = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y + this.rect.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getCenter = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.rect.x + this.rect.width / 2, this.rect.y + this.rect.height / 2);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getLocation = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.rect.x, this.rect.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getRect = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getDiagonal = function () {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(this.rect.width * this.rect.width + this.rect.height * this.rect.height);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns half the diagonal length of this node.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">LNode.prototype.getHalfTheDiagonal = function () {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(this.rect.height * this.rect.height + this.rect.width * this.rect.width) / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setRect = function (upperLeft, dimension) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = upperLeft.x;</span><span class="s3">\n  </span><span class="s1">this.rect.y = upperLeft.y;</span><span class="s3">\n  </span><span class="s1">this.rect.width = dimension.width;</span><span class="s3">\n  </span><span class="s1">this.rect.height = dimension.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setCenter = function (cx, cy) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = cx - this.rect.width / 2;</span><span class="s3">\n  </span><span class="s1">this.rect.y = cy - this.rect.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.setLocation = function (x, y) {</span><span class="s3">\n  </span><span class="s1">this.rect.x = x;</span><span class="s3">\n  </span><span class="s1">this.rect.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.moveBy = function (dx, dy) {</span><span class="s3">\n  </span><span class="s1">this.rect.x += dx;</span><span class="s3">\n  </span><span class="s1">this.rect.y += dy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdgeListToNode = function (to) {</span><span class="s3">\n  </span><span class="s1">var edgeList = [];</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (edge.target == to) {</span><span class="s3">\n      </span><span class="s1">if (edge.source != self) throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect edge source!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n      </span><span class="s1">edgeList.push(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return edgeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEdgesBetween = function (other) {</span><span class="s3">\n  </span><span class="s1">var edgeList = [];</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source == self || edge.target == self)) throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect edge source and/or target</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n    </span><span class="s1">if (edge.target == other || edge.source == other) {</span><span class="s3">\n      </span><span class="s1">edgeList.push(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return edgeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getNeighborsList = function () {</span><span class="s3">\n  </span><span class="s1">var neighbors = new Set();</span><span class="s3">\n\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">self.edges.forEach(function (edge) {</span><span class="s3">\n\n    </span><span class="s1">if (edge.source == self) {</span><span class="s3">\n      </span><span class="s1">neighbors.add(edge.target);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">if (edge.target != self) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Incorrect incidency!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">neighbors.add(edge.source);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">return neighbors;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.withChildren = function () {</span><span class="s3">\n  </span><span class="s1">var withNeighborsList = new Set();</span><span class="s3">\n  </span><span class="s1">var childNode;</span><span class="s3">\n  </span><span class="s1">var children;</span><span class="s3">\n\n  </span><span class="s1">withNeighborsList.add(this);</span><span class="s3">\n\n  </span><span class="s1">if (this.child != null) {</span><span class="s3">\n    </span><span class="s1">var nodes = this.child.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">childNode = nodes[i];</span><span class="s3">\n      </span><span class="s1">children = childNode.withChildren();</span><span class="s3">\n      </span><span class="s1">children.forEach(function (node) {</span><span class="s3">\n        </span><span class="s1">withNeighborsList.add(node);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return withNeighborsList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getNoOfChildren = function () {</span><span class="s3">\n  </span><span class="s1">var noOfChildren = 0;</span><span class="s3">\n  </span><span class="s1">var childNode;</span><span class="s3">\n\n  </span><span class="s1">if (this.child == null) {</span><span class="s3">\n    </span><span class="s1">noOfChildren = 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var nodes = this.child.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">childNode = nodes[i];</span><span class="s3">\n\n      </span><span class="s1">noOfChildren += childNode.getNoOfChildren();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (noOfChildren == 0) {</span><span class="s3">\n    </span><span class="s1">noOfChildren = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return noOfChildren;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.estimatedSize == Integer.MIN_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.calcEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.child == null) {</span><span class="s3">\n    </span><span class="s1">return this.estimatedSize = (this.rect.width + this.rect.height) / 2;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = this.child.calcEstimatedSize();</span><span class="s3">\n    </span><span class="s1">this.rect.width = this.estimatedSize;</span><span class="s3">\n    </span><span class="s1">this.rect.height = this.estimatedSize;</span><span class="s3">\n\n    </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.scatter = function () {</span><span class="s3">\n  </span><span class="s1">var randomCenterX;</span><span class="s3">\n  </span><span class="s1">var randomCenterY;</span><span class="s3">\n\n  </span><span class="s1">var minX = -LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">var maxX = LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">randomCenterX = LayoutConstants.WORLD_CENTER_X + RandomSeed.nextDouble() * (maxX - minX) + minX;</span><span class="s3">\n\n  </span><span class="s1">var minY = -LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">var maxY = LayoutConstants.INITIAL_WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">randomCenterY = LayoutConstants.WORLD_CENTER_Y + RandomSeed.nextDouble() * (maxY - minY) + minY;</span><span class="s3">\n\n  </span><span class="s1">this.rect.x = randomCenterX;</span><span class="s3">\n  </span><span class="s1">this.rect.y = randomCenterY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.updateBounds = function () {</span><span class="s3">\n  </span><span class="s1">if (this.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (this.getChild().getNodes().length != 0) {</span><span class="s3">\n    </span><span class="s1">// wrap the children nodes by re-arranging the boundaries</span><span class="s3">\n    </span><span class="s1">var childGraph = this.getChild();</span><span class="s3">\n    </span><span class="s1">childGraph.updateBounds(true);</span><span class="s3">\n\n    </span><span class="s1">this.rect.x = childGraph.getLeft();</span><span class="s3">\n    </span><span class="s1">this.rect.y = childGraph.getTop();</span><span class="s3">\n\n    </span><span class="s1">this.setWidth(childGraph.getRight() - childGraph.getLeft());</span><span class="s3">\n    </span><span class="s1">this.setHeight(childGraph.getBottom() - childGraph.getTop());</span><span class="s3">\n\n    </span><span class="s1">// Update compound bounds considering its label properties    </span><span class="s3">\n    </span><span class="s1">if (LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS) {</span><span class="s3">\n\n      </span><span class="s1">var width = childGraph.getRight() - childGraph.getLeft();</span><span class="s3">\n      </span><span class="s1">var height = childGraph.getBottom() - childGraph.getTop();</span><span class="s3">\n\n      </span><span class="s1">if (this.labelWidth) {</span><span class="s3">\n        </span><span class="s1">if (this.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.rect.x -= this.labelWidth;</span><span class="s3">\n          </span><span class="s1">this.setWidth(width + this.labelWidth);</span><span class="s3">\n        </span><span class="s1">} else if (this.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.labelWidth &gt; width) {</span><span class="s3">\n          </span><span class="s1">this.rect.x -= (this.labelWidth - width) / 2;</span><span class="s3">\n          </span><span class="s1">this.setWidth(this.labelWidth);</span><span class="s3">\n        </span><span class="s1">} else if (this.labelPosHorizontal == </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.setWidth(width + this.labelWidth);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (this.labelHeight) {</span><span class="s3">\n        </span><span class="s1">if (this.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.rect.y -= this.labelHeight;</span><span class="s3">\n          </span><span class="s1">this.setHeight(height + this.labelHeight);</span><span class="s3">\n        </span><span class="s1">} else if (this.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; this.labelHeight &gt; height) {</span><span class="s3">\n          </span><span class="s1">this.rect.y -= (this.labelHeight - height) / 2;</span><span class="s3">\n          </span><span class="s1">this.setHeight(this.labelHeight);</span><span class="s3">\n        </span><span class="s1">} else if (this.labelPosVertical == </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n          </span><span class="s1">this.setHeight(height + this.labelHeight);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getInclusionTreeDepth = function () {</span><span class="s3">\n  </span><span class="s1">if (this.inclusionTreeDepth == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.inclusionTreeDepth;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.transform = function (trans) {</span><span class="s3">\n  </span><span class="s1">var left = this.rect.x;</span><span class="s3">\n\n  </span><span class="s1">if (left &gt; LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">left = LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">} else if (left &lt; -LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">left = -LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var top = this.rect.y;</span><span class="s3">\n\n  </span><span class="s1">if (top &gt; LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">top = LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">} else if (top &lt; -LayoutConstants.WORLD_BOUNDARY) {</span><span class="s3">\n    </span><span class="s1">top = -LayoutConstants.WORLD_BOUNDARY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var leftTop = new PointD(left, top);</span><span class="s3">\n  </span><span class="s1">var vLeftTop = trans.inverseTransformPoint(leftTop);</span><span class="s3">\n\n  </span><span class="s1">this.setLocation(vLeftTop.x, vLeftTop.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getLeft = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.x + this.rect.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getTop = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.rect.y + this.rect.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LNode.prototype.getParent = function () {</span><span class="s3">\n  </span><span class="s1">if (this.owner == null) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return this.owner.getParent();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LNode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 4 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutConstants() {}</span><span class="s3">\n\n</span><span class="s1">//FDLayoutConstants inherits static props in LayoutConstants</span><span class="s3">\n</span><span class="s1">for (var prop in LayoutConstants) {</span><span class="s3">\n  </span><span class="s1">FDLayoutConstants[prop] = LayoutConstants[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutConstants.MAX_ITERATIONS = 2500;</span><span class="s3">\n\n</span><span class="s1">FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_SPRING_STRENGTH = 0.45;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_REPULSION_STRENGTH = 4500.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = 0.4;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = 1.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = 3.8;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = 1.5;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION = true;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION = true;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = 0.3;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.COOLING_ADAPTATION_FACTOR = 0.33;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT = 1000;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT = 5000;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL = 100.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MAX_NODE_DISPLACEMENT = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL * 3;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.CONVERGENCE_CHECK_PERIOD = 100;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = 0.1;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.MIN_EDGE_LENGTH = 1;</span><span class="s3">\n</span><span class="s1">FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD = 10;</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutConstants;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 5 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function PointD(x, y) {</span><span class="s3">\n  </span><span class="s1">if (x == null &amp;&amp; y == null) {</span><span class="s3">\n    </span><span class="s1">this.x = 0;</span><span class="s3">\n    </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.setX = function (x) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.setY = function (y) {</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getDifference = function (pt) {</span><span class="s3">\n  </span><span class="s1">return new DimensionD(this.x - pt.x, this.y - pt.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.getCopy = function () {</span><span class="s3">\n  </span><span class="s1">return new PointD(this.x, this.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">PointD.prototype.translate = function (dim) {</span><span class="s3">\n  </span><span class="s1">this.x += dim.width;</span><span class="s3">\n  </span><span class="s1">this.y += dim.height;</span><span class="s3">\n  </span><span class="s1">return this;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = PointD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 6 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">var Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var LGraphManager = __webpack_require__(7);</span><span class="s3">\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">var Point = __webpack_require__(12);</span><span class="s3">\n</span><span class="s1">var LinkedList = __webpack_require__(11);</span><span class="s3">\n\n</span><span class="s1">function LGraph(parent, obj2, vGraph) {</span><span class="s3">\n  </span><span class="s1">LGraphObject.call(this, vGraph);</span><span class="s3">\n  </span><span class="s1">this.estimatedSize = Integer.MIN_VALUE;</span><span class="s3">\n  </span><span class="s1">this.margin = LayoutConstants.DEFAULT_GRAPH_MARGIN;</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n  </span><span class="s1">this.nodes = [];</span><span class="s3">\n  </span><span class="s1">this.isConnected = false;</span><span class="s3">\n  </span><span class="s1">this.parent = parent;</span><span class="s3">\n\n  </span><span class="s1">if (obj2 != null &amp;&amp; obj2 instanceof LGraphManager) {</span><span class="s3">\n    </span><span class="s1">this.graphManager = obj2;</span><span class="s3">\n  </span><span class="s1">} else if (obj2 != null &amp;&amp; obj2 instanceof Layout) {</span><span class="s3">\n    </span><span class="s1">this.graphManager = obj2.graphManager;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype = Object.create(LGraphObject.prototype);</span><span class="s3">\n</span><span class="s1">for (var prop in LGraphObject) {</span><span class="s3">\n  </span><span class="s1">LGraph[prop] = LGraphObject[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getNodes = function () {</span><span class="s3">\n  </span><span class="s1">return this.nodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.edges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getParent = function () {</span><span class="s3">\n  </span><span class="s1">return this.parent;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getLeft = function () {</span><span class="s3">\n  </span><span class="s1">return this.left;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.right;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getTop = function () {</span><span class="s3">\n  </span><span class="s1">return this.top;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.bottom;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.isConnected = function () {</span><span class="s3">\n  </span><span class="s1">return this.isConnected;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.add = function (obj1, sourceNode, targetNode) {</span><span class="s3">\n  </span><span class="s1">if (sourceNode == null &amp;&amp; targetNode == null) {</span><span class="s3">\n    </span><span class="s1">var newNode = obj1;</span><span class="s3">\n    </span><span class="s1">if (this.graphManager == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph has no graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.getNodes().indexOf(newNode) &gt; -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node already in graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">newNode.owner = this;</span><span class="s3">\n    </span><span class="s1">this.getNodes().push(newNode);</span><span class="s3">\n\n    </span><span class="s1">return newNode;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var newEdge = obj1;</span><span class="s3">\n    </span><span class="s1">if (!(this.getNodes().indexOf(sourceNode) &gt; -1 &amp;&amp; this.getNodes().indexOf(targetNode) &gt; -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source or target not in graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (!(sourceNode.owner == targetNode.owner &amp;&amp; sourceNode.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Both owners must be this graph!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceNode.owner != targetNode.owner) {</span><span class="s3">\n      </span><span class="s1">return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// set source and target</span><span class="s3">\n    </span><span class="s1">newEdge.source = sourceNode;</span><span class="s3">\n    </span><span class="s1">newEdge.target = targetNode;</span><span class="s3">\n\n    </span><span class="s1">// set as intra-graph edge</span><span class="s3">\n    </span><span class="s1">newEdge.isInterGraph = false;</span><span class="s3">\n\n    </span><span class="s1">// add to graph edge list</span><span class="s3">\n    </span><span class="s1">this.getEdges().push(newEdge);</span><span class="s3">\n\n    </span><span class="s1">// add to incidency lists</span><span class="s3">\n    </span><span class="s1">sourceNode.edges.push(newEdge);</span><span class="s3">\n\n    </span><span class="s1">if (targetNode != sourceNode) {</span><span class="s3">\n      </span><span class="s1">targetNode.edges.push(newEdge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return newEdge;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.remove = function (obj) {</span><span class="s3">\n  </span><span class="s1">var node = obj;</span><span class="s3">\n  </span><span class="s1">if (obj instanceof LNode) {</span><span class="s3">\n    </span><span class="s1">if (node == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(node.owner != null &amp;&amp; node.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Owner graph is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.graphManager == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Owner graph manager is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// remove incident edges first (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var edgesToBeRemoved = node.edges.slice();</span><span class="s3">\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var s = edgesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">edge = edgesToBeRemoved[i];</span><span class="s3">\n\n      </span><span class="s1">if (edge.isInterGraph) {</span><span class="s3">\n        </span><span class="s1">this.graphManager.remove(edge);</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">edge.source.owner.remove(edge);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now the node itself</span><span class="s3">\n    </span><span class="s1">var index = this.nodes.indexOf(node);</span><span class="s3">\n    </span><span class="s1">if (index == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Node not in owner node list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.nodes.splice(index, 1);</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">var edge = obj;</span><span class="s3">\n    </span><span class="s1">if (edge == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source != null &amp;&amp; edge.target != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source.owner != null &amp;&amp; edge.target.owner != null &amp;&amp; edge.source.owner == this &amp;&amp; edge.target.owner == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target owner is invalid!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var sourceIndex = edge.source.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">var targetIndex = edge.target.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">if (!(sourceIndex &gt; -1 &amp;&amp; targetIndex &gt; -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target doesn't know this edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edge.source.edges.splice(sourceIndex, 1);</span><span class="s3">\n\n    </span><span class="s1">if (edge.target != edge.source) {</span><span class="s3">\n      </span><span class="s1">edge.target.edges.splice(targetIndex, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.owner.getEdges().indexOf(edge);</span><span class="s3">\n    </span><span class="s1">if (index == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not in owner's edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edge.source.owner.getEdges().splice(index, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateLeftTop = function () {</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var margin;</span><span class="s3">\n\n  </span><span class="s1">var nodes = this.getNodes();</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Do we have any nodes in this graph?</span><span class="s3">\n  </span><span class="s1">if (top == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nodes[0].getParent().paddingLeft != undefined) {</span><span class="s3">\n    </span><span class="s1">margin = nodes[0].getParent().paddingLeft;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">margin = this.margin;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.left = left - margin;</span><span class="s3">\n  </span><span class="s1">this.top = top - margin;</span><span class="s3">\n\n  </span><span class="s1">// Apply the margins and return the result</span><span class="s3">\n  </span><span class="s1">return new Point(this.left, this.top);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateBounds = function (recursive) {</span><span class="s3">\n  </span><span class="s1">// calculate bounds</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var right = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var bottom = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var nodeRight;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeBottom;</span><span class="s3">\n  </span><span class="s1">var margin;</span><span class="s3">\n\n  </span><span class="s1">var nodes = this.nodes;</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n\n    </span><span class="s1">if (recursive &amp;&amp; lNode.child != null) {</span><span class="s3">\n      </span><span class="s1">lNode.updateBounds();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n    </span><span class="s1">nodeRight = lNode.getRight();</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeBottom = lNode.getBottom();</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (right &lt; nodeRight) {</span><span class="s3">\n      </span><span class="s1">right = nodeRight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bottom &lt; nodeBottom) {</span><span class="s3">\n      </span><span class="s1">bottom = nodeBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var boundingRect = new RectangleD(left, top, right - left, bottom - top);</span><span class="s3">\n  </span><span class="s1">if (left == Integer.MAX_VALUE) {</span><span class="s3">\n    </span><span class="s1">this.left = this.parent.getLeft();</span><span class="s3">\n    </span><span class="s1">this.right = this.parent.getRight();</span><span class="s3">\n    </span><span class="s1">this.top = this.parent.getTop();</span><span class="s3">\n    </span><span class="s1">this.bottom = this.parent.getBottom();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (nodes[0].getParent().paddingLeft != undefined) {</span><span class="s3">\n    </span><span class="s1">margin = nodes[0].getParent().paddingLeft;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">margin = this.margin;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.left = boundingRect.x - margin;</span><span class="s3">\n  </span><span class="s1">this.right = boundingRect.x + boundingRect.width + margin;</span><span class="s3">\n  </span><span class="s1">this.top = boundingRect.y - margin;</span><span class="s3">\n  </span><span class="s1">this.bottom = boundingRect.y + boundingRect.height + margin;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.calculateBounds = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var left = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var right = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var top = Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var bottom = -Integer.MAX_VALUE;</span><span class="s3">\n  </span><span class="s1">var nodeLeft;</span><span class="s3">\n  </span><span class="s1">var nodeRight;</span><span class="s3">\n  </span><span class="s1">var nodeTop;</span><span class="s3">\n  </span><span class="s1">var nodeBottom;</span><span class="s3">\n\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">nodeLeft = lNode.getLeft();</span><span class="s3">\n    </span><span class="s1">nodeRight = lNode.getRight();</span><span class="s3">\n    </span><span class="s1">nodeTop = lNode.getTop();</span><span class="s3">\n    </span><span class="s1">nodeBottom = lNode.getBottom();</span><span class="s3">\n\n    </span><span class="s1">if (left &gt; nodeLeft) {</span><span class="s3">\n      </span><span class="s1">left = nodeLeft;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (right &lt; nodeRight) {</span><span class="s3">\n      </span><span class="s1">right = nodeRight;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (top &gt; nodeTop) {</span><span class="s3">\n      </span><span class="s1">top = nodeTop;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (bottom &lt; nodeBottom) {</span><span class="s3">\n      </span><span class="s1">bottom = nodeBottom;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var boundingRect = new RectangleD(left, top, right - left, bottom - top);</span><span class="s3">\n\n  </span><span class="s1">return boundingRect;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getInclusionTreeDepth = function () {</span><span class="s3">\n  </span><span class="s1">if (this == this.graphManager.getRoot()) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return this.parent.getInclusionTreeDepth();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.getEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">if (this.estimatedSize == Integer.MIN_VALUE) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.calcEstimatedSize = function () {</span><span class="s3">\n  </span><span class="s1">var size = 0;</span><span class="s3">\n  </span><span class="s1">var nodes = this.nodes;</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var lNode = nodes[i];</span><span class="s3">\n    </span><span class="s1">size += lNode.calcEstimatedSize();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (size == 0) {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = LayoutConstants.EMPTY_COMPOUND_NODE_SIZE;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">this.estimatedSize = size / Math.sqrt(this.nodes.length);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return this.estimatedSize;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraph.prototype.updateConnected = function () {</span><span class="s3">\n  </span><span class="s1">var self = this;</span><span class="s3">\n  </span><span class="s1">if (this.nodes.length == 0) {</span><span class="s3">\n    </span><span class="s1">this.isConnected = true;</span><span class="s3">\n    </span><span class="s1">return;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var queue = new LinkedList();</span><span class="s3">\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var currentNode = this.nodes[0];</span><span class="s3">\n  </span><span class="s1">var neighborEdges;</span><span class="s3">\n  </span><span class="s1">var currentNeighbor;</span><span class="s3">\n  </span><span class="s1">var childrenOfNode = currentNode.withChildren();</span><span class="s3">\n  </span><span class="s1">childrenOfNode.forEach(function (node) {</span><span class="s3">\n    </span><span class="s1">queue.push(node);</span><span class="s3">\n    </span><span class="s1">visited.add(node);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n\n  </span><span class="s1">while (queue.length !== 0) {</span><span class="s3">\n    </span><span class="s1">currentNode = queue.shift();</span><span class="s3">\n\n    </span><span class="s1">// Traverse all neighbors of this node</span><span class="s3">\n    </span><span class="s1">neighborEdges = currentNode.getEdges();</span><span class="s3">\n    </span><span class="s1">var size = neighborEdges.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; size; i++) {</span><span class="s3">\n      </span><span class="s1">var neighborEdge = neighborEdges[i];</span><span class="s3">\n      </span><span class="s1">currentNeighbor = neighborEdge.getOtherEndInGraph(currentNode, this);</span><span class="s3">\n\n      </span><span class="s1">// Add unvisited neighbors to the list to visit</span><span class="s3">\n      </span><span class="s1">if (currentNeighbor != null &amp;&amp; !visited.has(currentNeighbor)) {</span><span class="s3">\n        </span><span class="s1">var childrenOfNeighbor = currentNeighbor.withChildren();</span><span class="s3">\n\n        </span><span class="s1">childrenOfNeighbor.forEach(function (node) {</span><span class="s3">\n          </span><span class="s1">queue.push(node);</span><span class="s3">\n          </span><span class="s1">visited.add(node);</span><span class="s3">\n        </span><span class="s1">});</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.isConnected = false;</span><span class="s3">\n\n  </span><span class="s1">if (visited.size &gt;= this.nodes.length) {</span><span class="s3">\n    </span><span class="s1">var noOfVisitedInThisGraph = 0;</span><span class="s3">\n\n    </span><span class="s1">visited.forEach(function (visitedNode) {</span><span class="s3">\n      </span><span class="s1">if (visitedNode.owner == self) {</span><span class="s3">\n        </span><span class="s1">noOfVisitedInThisGraph++;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n\n    </span><span class="s1">if (noOfVisitedInThisGraph == this.nodes.length) {</span><span class="s3">\n      </span><span class="s1">this.isConnected = true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraph;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 7 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LGraph;</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n\n</span><span class="s1">function LGraphManager(layout) {</span><span class="s3">\n  </span><span class="s1">LGraph = __webpack_require__(6); // It may be better to initilize this out of this function but it gives an error (Right-hand side of 'instanceof' is not callable) now.</span><span class="s3">\n  </span><span class="s1">this.layout = layout;</span><span class="s3">\n\n  </span><span class="s1">this.graphs = [];</span><span class="s3">\n  </span><span class="s1">this.edges = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.addRoot = function () {</span><span class="s3">\n  </span><span class="s1">var ngraph = this.layout.newGraph();</span><span class="s3">\n  </span><span class="s1">var nnode = this.layout.newNode(null);</span><span class="s3">\n  </span><span class="s1">var root = this.add(ngraph, nnode);</span><span class="s3">\n  </span><span class="s1">this.setRootGraph(root);</span><span class="s3">\n  </span><span class="s1">return this.rootGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.add = function (newGraph, parentNode, newEdge, sourceNode, targetNode) {</span><span class="s3">\n  </span><span class="s1">//there are just 2 parameters are passed then it adds an LGraph else it adds an LEdge</span><span class="s3">\n  </span><span class="s1">if (newEdge == null &amp;&amp; sourceNode == null &amp;&amp; targetNode == null) {</span><span class="s3">\n    </span><span class="s1">if (newGraph == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Parent node is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (this.graphs.indexOf(newGraph) &gt; -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph already in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">this.graphs.push(newGraph);</span><span class="s3">\n\n    </span><span class="s1">if (newGraph.parent != null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Already has a parent!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (parentNode.child != null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Already has a child!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">newGraph.parent = parentNode;</span><span class="s3">\n    </span><span class="s1">parentNode.child = newGraph;</span><span class="s3">\n\n    </span><span class="s1">return newGraph;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">//change the order of the parameters</span><span class="s3">\n    </span><span class="s1">targetNode = newEdge;</span><span class="s3">\n    </span><span class="s1">sourceNode = parentNode;</span><span class="s3">\n    </span><span class="s1">newEdge = newGraph;</span><span class="s3">\n    </span><span class="s1">var sourceGraph = sourceNode.getOwner();</span><span class="s3">\n    </span><span class="s1">var targetGraph = targetNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">if (!(sourceGraph != null &amp;&amp; sourceGraph.getGraphManager() == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(targetGraph != null &amp;&amp; targetGraph.getGraphManager() == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Target not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (sourceGraph == targetGraph) {</span><span class="s3">\n      </span><span class="s1">newEdge.isInterGraph = false;</span><span class="s3">\n      </span><span class="s1">return sourceGraph.add(newEdge, sourceNode, targetNode);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">newEdge.isInterGraph = true;</span><span class="s3">\n\n      </span><span class="s1">// set source and target</span><span class="s3">\n      </span><span class="s1">newEdge.source = sourceNode;</span><span class="s3">\n      </span><span class="s1">newEdge.target = targetNode;</span><span class="s3">\n\n      </span><span class="s1">// add edge to inter-graph edge list</span><span class="s3">\n      </span><span class="s1">if (this.edges.indexOf(newEdge) &gt; -1) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge already in inter-graph edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">this.edges.push(newEdge);</span><span class="s3">\n\n      </span><span class="s1">// add edge to source and target incidency lists</span><span class="s3">\n      </span><span class="s1">if (!(newEdge.source != null &amp;&amp; newEdge.target != null)) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (!(newEdge.source.edges.indexOf(newEdge) == -1 &amp;&amp; newEdge.target.edges.indexOf(newEdge) == -1)) {</span><span class="s3">\n        </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge already in source and/or target incidency list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">newEdge.source.edges.push(newEdge);</span><span class="s3">\n      </span><span class="s1">newEdge.target.edges.push(newEdge);</span><span class="s3">\n\n      </span><span class="s1">return newEdge;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.remove = function (lObj) {</span><span class="s3">\n  </span><span class="s1">if (lObj instanceof LGraph) {</span><span class="s3">\n    </span><span class="s1">var graph = lObj;</span><span class="s3">\n    </span><span class="s1">if (graph.getGraphManager() != this) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Graph not in this graph mgr</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(graph == this.rootGraph || graph.parent != null &amp;&amp; graph.parent.graphManager == this)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Invalid parent node!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// first the edges (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var edgesToBeRemoved = [];</span><span class="s3">\n\n    </span><span class="s1">edgesToBeRemoved = edgesToBeRemoved.concat(graph.getEdges());</span><span class="s3">\n\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var s = edgesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">edge = edgesToBeRemoved[i];</span><span class="s3">\n      </span><span class="s1">graph.remove(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// then the nodes (make a copy to do it safely)</span><span class="s3">\n    </span><span class="s1">var nodesToBeRemoved = [];</span><span class="s3">\n\n    </span><span class="s1">nodesToBeRemoved = nodesToBeRemoved.concat(graph.getNodes());</span><span class="s3">\n\n    </span><span class="s1">var node;</span><span class="s3">\n    </span><span class="s1">s = nodesToBeRemoved.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">node = nodesToBeRemoved[i];</span><span class="s3">\n      </span><span class="s1">graph.remove(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// check if graph is the root</span><span class="s3">\n    </span><span class="s1">if (graph == this.rootGraph) {</span><span class="s3">\n      </span><span class="s1">this.setRootGraph(null);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// now remove the graph itself</span><span class="s3">\n    </span><span class="s1">var index = this.graphs.indexOf(graph);</span><span class="s3">\n    </span><span class="s1">this.graphs.splice(index, 1);</span><span class="s3">\n\n    </span><span class="s1">// also reset the parent of the graph</span><span class="s3">\n    </span><span class="s1">graph.parent = null;</span><span class="s3">\n  </span><span class="s1">} else if (lObj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">edge = lObj;</span><span class="s3">\n    </span><span class="s1">if (edge == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!edge.isInterGraph) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not an inter-graph edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (!(edge.source != null &amp;&amp; edge.target != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// remove edge from source and target nodes' incidency lists</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source.edges.indexOf(edge) != -1 &amp;&amp; edge.target.edges.indexOf(edge) != -1)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Source and/or target doesn't know this edge!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.source.edges.splice(index, 1);</span><span class="s3">\n    </span><span class="s1">index = edge.target.edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.target.edges.splice(index, 1);</span><span class="s3">\n\n    </span><span class="s1">// remove edge from owner graph manager's inter-graph edge list</span><span class="s3">\n\n    </span><span class="s1">if (!(edge.source.owner != null &amp;&amp; edge.source.owner.getGraphManager() != null)) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Edge owner graph or owner graph manager is null!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (edge.source.owner.getGraphManager().edges.indexOf(edge) == -1) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Not in owner graph manager's edge list!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">var index = edge.source.owner.getGraphManager().edges.indexOf(edge);</span><span class="s3">\n    </span><span class="s1">edge.source.owner.getGraphManager().edges.splice(index, 1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.updateBounds = function () {</span><span class="s3">\n  </span><span class="s1">this.rootGraph.updateBounds(true);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getGraphs = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphs;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">if (this.allNodes == null) {</span><span class="s3">\n    </span><span class="s1">var nodeList = [];</span><span class="s3">\n    </span><span class="s1">var graphs = this.getGraphs();</span><span class="s3">\n    </span><span class="s1">var s = graphs.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n      </span><span class="s1">nodeList = nodeList.concat(graphs[i].getNodes());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.allNodes = nodeList;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.allNodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">this.allNodes = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">this.allEdges = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.resetAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">this.allNodesToApplyGravitation = null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">if (this.allEdges == null) {</span><span class="s3">\n    </span><span class="s1">var edgeList = [];</span><span class="s3">\n    </span><span class="s1">var graphs = this.getGraphs();</span><span class="s3">\n    </span><span class="s1">var s = graphs.length;</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; graphs.length; i++) {</span><span class="s3">\n      </span><span class="s1">edgeList = edgeList.concat(graphs[i].getEdges());</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">edgeList = edgeList.concat(this.edges);</span><span class="s3">\n\n    </span><span class="s1">this.allEdges = edgeList;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this.allEdges;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">return this.allNodesToApplyGravitation;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.setAllNodesToApplyGravitation = function (nodeList) {</span><span class="s3">\n  </span><span class="s1">if (this.allNodesToApplyGravitation != null) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.allNodesToApplyGravitation = nodeList;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getRoot = function () {</span><span class="s3">\n  </span><span class="s1">return this.rootGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.setRootGraph = function (graph) {</span><span class="s3">\n  </span><span class="s1">if (graph.getGraphManager() != this) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">Root not in this graph mgr!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.rootGraph = graph;</span><span class="s3">\n  </span><span class="s1">// root graph must have a root node associated with it for convenience</span><span class="s3">\n  </span><span class="s1">if (graph.parent == null) {</span><span class="s3">\n    </span><span class="s1">graph.parent = this.layout.newNode(</span><span class="s3">\&quot;</span><span class="s1">Root node</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.getLayout = function () {</span><span class="s3">\n  </span><span class="s1">return this.layout;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.isOneAncestorOfOther = function (firstNode, secondNode) {</span><span class="s3">\n  </span><span class="s1">if (!(firstNode != null &amp;&amp; secondNode != null)) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (firstNode == secondNode) {</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// Is second node an ancestor of the first one?</span><span class="s3">\n  </span><span class="s1">var ownerGraph = firstNode.getOwner();</span><span class="s3">\n  </span><span class="s1">var parentNode;</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">parentNode = ownerGraph.getParent();</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == secondNode) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">ownerGraph = parentNode.getOwner();</span><span class="s3">\n    </span><span class="s1">if (ownerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n  </span><span class="s1">// Is first node an ancestor of the second one?</span><span class="s3">\n  </span><span class="s1">ownerGraph = secondNode.getOwner();</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">parentNode = ownerGraph.getParent();</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (parentNode == firstNode) {</span><span class="s3">\n      </span><span class="s1">return true;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">ownerGraph = parentNode.getOwner();</span><span class="s3">\n    </span><span class="s1">if (ownerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcLowestCommonAncestors = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var sourceNode;</span><span class="s3">\n  </span><span class="s1">var targetNode;</span><span class="s3">\n  </span><span class="s1">var sourceAncestorGraph;</span><span class="s3">\n  </span><span class="s1">var targetAncestorGraph;</span><span class="s3">\n\n  </span><span class="s1">var edges = this.getAllEdges();</span><span class="s3">\n  </span><span class="s1">var s = edges.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">edge = edges[i];</span><span class="s3">\n\n    </span><span class="s1">sourceNode = edge.source;</span><span class="s3">\n    </span><span class="s1">targetNode = edge.target;</span><span class="s3">\n    </span><span class="s1">edge.lca = null;</span><span class="s3">\n    </span><span class="s1">edge.sourceInLca = sourceNode;</span><span class="s3">\n    </span><span class="s1">edge.targetInLca = targetNode;</span><span class="s3">\n\n    </span><span class="s1">if (sourceNode == targetNode) {</span><span class="s3">\n      </span><span class="s1">edge.lca = sourceNode.getOwner();</span><span class="s3">\n      </span><span class="s1">continue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">sourceAncestorGraph = sourceNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">while (edge.lca == null) {</span><span class="s3">\n      </span><span class="s1">edge.targetInLca = targetNode;</span><span class="s3">\n      </span><span class="s1">targetAncestorGraph = targetNode.getOwner();</span><span class="s3">\n\n      </span><span class="s1">while (edge.lca == null) {</span><span class="s3">\n        </span><span class="s1">if (targetAncestorGraph == sourceAncestorGraph) {</span><span class="s3">\n          </span><span class="s1">edge.lca = targetAncestorGraph;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (targetAncestorGraph == this.rootGraph) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">if (edge.lca != null) {</span><span class="s3">\n          </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">edge.targetInLca = targetAncestorGraph.getParent();</span><span class="s3">\n        </span><span class="s1">targetAncestorGraph = edge.targetInLca.getOwner();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (sourceAncestorGraph == this.rootGraph) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (edge.lca == null) {</span><span class="s3">\n        </span><span class="s1">edge.sourceInLca = sourceAncestorGraph.getParent();</span><span class="s3">\n        </span><span class="s1">sourceAncestorGraph = edge.sourceInLca.getOwner();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">if (edge.lca == null) {</span><span class="s3">\n      </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcLowestCommonAncestor = function (firstNode, secondNode) {</span><span class="s3">\n  </span><span class="s1">if (firstNode == secondNode) {</span><span class="s3">\n    </span><span class="s1">return firstNode.getOwner();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var firstOwnerGraph = firstNode.getOwner();</span><span class="s3">\n\n  </span><span class="s1">do {</span><span class="s3">\n    </span><span class="s1">if (firstOwnerGraph == null) {</span><span class="s3">\n      </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">var secondOwnerGraph = secondNode.getOwner();</span><span class="s3">\n\n    </span><span class="s1">do {</span><span class="s3">\n      </span><span class="s1">if (secondOwnerGraph == null) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (secondOwnerGraph == firstOwnerGraph) {</span><span class="s3">\n        </span><span class="s1">return secondOwnerGraph;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">secondOwnerGraph = secondOwnerGraph.getParent().getOwner();</span><span class="s3">\n    </span><span class="s1">} while (true);</span><span class="s3">\n\n    </span><span class="s1">firstOwnerGraph = firstOwnerGraph.getParent().getOwner();</span><span class="s3">\n  </span><span class="s1">} while (true);</span><span class="s3">\n\n  </span><span class="s1">return firstOwnerGraph;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.calcInclusionTreeDepths = function (graph, depth) {</span><span class="s3">\n  </span><span class="s1">if (graph == null &amp;&amp; depth == null) {</span><span class="s3">\n    </span><span class="s1">graph = this.rootGraph;</span><span class="s3">\n    </span><span class="s1">depth = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">var nodes = graph.getNodes();</span><span class="s3">\n  </span><span class="s1">var s = nodes.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">node = nodes[i];</span><span class="s3">\n    </span><span class="s1">node.inclusionTreeDepth = depth;</span><span class="s3">\n\n    </span><span class="s1">if (node.child != null) {</span><span class="s3">\n      </span><span class="s1">this.calcInclusionTreeDepths(node.child, depth + 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">LGraphManager.prototype.includesInvalidEdge = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var edgesToRemove = [];</span><span class="s3">\n\n  </span><span class="s1">var s = this.edges.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">edge = this.edges[i];</span><span class="s3">\n\n    </span><span class="s1">if (this.isOneAncestorOfOther(edge.source, edge.target)) {</span><span class="s3">\n      </span><span class="s1">edgesToRemove.push(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Remove invalid edges from graph manager</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; edgesToRemove.length; i++) {</span><span class="s3">\n    </span><span class="s1">this.remove(edgesToRemove[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Invalid edges are cleared, so return false</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = LGraphManager;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 8 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This class maintains a list of static geometry related utility methods.</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright: i-Vis Research Group, Bilkent University, 2007 - present</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var Point = __webpack_require__(12);</span><span class="s3">\n\n</span><span class="s1">function IGeometry() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates *half* the amount in x and y directions of the two</span><span class="s3">\n </span><span class="s1">* input rectangles needed to separate them keeping their respective</span><span class="s3">\n </span><span class="s1">* positioning, and returns the result in the input array. An input</span><span class="s3">\n </span><span class="s1">* separation buffer added to the amount in both directions. We assume that</span><span class="s3">\n </span><span class="s1">* the two rectangles do intersect.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.calcSeparationAmount = function (rectA, rectB, overlapAmount, separationBuffer) {</span><span class="s3">\n  </span><span class="s1">if (!rectA.intersects(rectB)) {</span><span class="s3">\n    </span><span class="s1">throw </span><span class="s3">\&quot;</span><span class="s1">assert failed</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var directions = new Array(2);</span><span class="s3">\n\n  </span><span class="s1">this.decideDirectionsForOverlappingNodes(rectA, rectB, directions);</span><span class="s3">\n\n  </span><span class="s1">overlapAmount[0] = Math.min(rectA.getRight(), rectB.getRight()) - Math.max(rectA.x, rectB.x);</span><span class="s3">\n  </span><span class="s1">overlapAmount[1] = Math.min(rectA.getBottom(), rectB.getBottom()) - Math.max(rectA.y, rectB.y);</span><span class="s3">\n\n  </span><span class="s1">// update the overlapping amounts for the following cases:</span><span class="s3">\n  </span><span class="s1">if (rectA.getX() &lt;= rectB.getX() &amp;&amp; rectA.getRight() &gt;= rectB.getRight()) {</span><span class="s3">\n    </span><span class="s1">/* Case x.1:</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">* rectA</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|                       |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        _________      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        |       |      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|________|_______|______|</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t\t\t </span><span class="s1">|       |</span><span class="s3">\n    </span><span class="s1">*           |       |</span><span class="s3">\n    </span><span class="s1">*        rectB</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[0] += Math.min(rectB.getX() - rectA.getX(), rectA.getRight() - rectB.getRight());</span><span class="s3">\n  </span><span class="s1">} else if (rectB.getX() &lt;= rectA.getX() &amp;&amp; rectB.getRight() &gt;= rectA.getRight()) {</span><span class="s3">\n    </span><span class="s1">/* Case x.2:</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">* rectB</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|                       |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        _________      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|        |       |      |</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t</span><span class="s1">|________|_______|______|</span><span class="s3">\n    </span><span class="s1">* </span><span class="s3">\t\t\t </span><span class="s1">|       |</span><span class="s3">\n    </span><span class="s1">*           |       |</span><span class="s3">\n    </span><span class="s1">*        rectA</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[0] += Math.min(rectA.getX() - rectB.getX(), rectB.getRight() - rectA.getRight());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rectA.getY() &lt;= rectB.getY() &amp;&amp; rectA.getBottom() &gt;= rectB.getBottom()) {</span><span class="s3">\n    </span><span class="s1">/* Case y.1:</span><span class="s3">\n     </span><span class="s1">*          ________ rectA</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*   ______|____  rectB</span><span class="s3">\n     </span><span class="s1">*         |    |</span><span class="s3">\n     </span><span class="s1">*         |    |</span><span class="s3">\n     </span><span class="s1">*   ______|____|</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |</span><span class="s3">\n     </span><span class="s1">*         |________</span><span class="s3">\n     </span><span class="s1">*</span><span class="s3">\n     </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[1] += Math.min(rectB.getY() - rectA.getY(), rectA.getBottom() - rectB.getBottom());</span><span class="s3">\n  </span><span class="s1">} else if (rectB.getY() &lt;= rectA.getY() &amp;&amp; rectB.getBottom() &gt;= rectA.getBottom()) {</span><span class="s3">\n    </span><span class="s1">/* Case y.2:</span><span class="s3">\n    </span><span class="s1">*          ________ rectB</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*   ______|____  rectA</span><span class="s3">\n    </span><span class="s1">*         |    |</span><span class="s3">\n    </span><span class="s1">*         |    |</span><span class="s3">\n    </span><span class="s1">*   ______|____|</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |</span><span class="s3">\n    </span><span class="s1">*         |________</span><span class="s3">\n    </span><span class="s1">*</span><span class="s3">\n    </span><span class="s1">*/</span><span class="s3">\n    </span><span class="s1">overlapAmount[1] += Math.min(rectA.getY() - rectB.getY(), rectB.getBottom() - rectA.getBottom());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// find slope of the line passes two centers</span><span class="s3">\n  </span><span class="s1">var slope = Math.abs((rectB.getCenterY() - rectA.getCenterY()) / (rectB.getCenterX() - rectA.getCenterX()));</span><span class="s3">\n  </span><span class="s1">// if centers are overlapped</span><span class="s3">\n  </span><span class="s1">if (rectB.getCenterY() === rectA.getCenterY() &amp;&amp; rectB.getCenterX() === rectA.getCenterX()) {</span><span class="s3">\n    </span><span class="s1">// assume the slope is 1 (45 degree)</span><span class="s3">\n    </span><span class="s1">slope = 1.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var moveByY = slope * overlapAmount[0];</span><span class="s3">\n  </span><span class="s1">var moveByX = overlapAmount[1] / slope;</span><span class="s3">\n  </span><span class="s1">if (overlapAmount[0] &lt; moveByX) {</span><span class="s3">\n    </span><span class="s1">moveByX = overlapAmount[0];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">moveByY = overlapAmount[1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// return half the amount so that if each rectangle is moved by these</span><span class="s3">\n  </span><span class="s1">// amounts in opposite directions, overlap will be resolved</span><span class="s3">\n  </span><span class="s1">overlapAmount[0] = -1 * directions[0] * (moveByX / 2 + separationBuffer);</span><span class="s3">\n  </span><span class="s1">overlapAmount[1] = -1 * directions[1] * (moveByY / 2 + separationBuffer);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method decides the separation direction of overlapping nodes</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* if directions[0] = -1, then rectA goes left</span><span class="s3">\n </span><span class="s1">* if directions[0] = 1,  then rectA goes right</span><span class="s3">\n </span><span class="s1">* if directions[1] = -1, then rectA goes up</span><span class="s3">\n </span><span class="s1">* if directions[1] = 1,  then rectA goes down</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.decideDirectionsForOverlappingNodes = function (rectA, rectB, directions) {</span><span class="s3">\n  </span><span class="s1">if (rectA.getCenterX() &lt; rectB.getCenterX()) {</span><span class="s3">\n    </span><span class="s1">directions[0] = -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">directions[0] = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (rectA.getCenterY() &lt; rectB.getCenterY()) {</span><span class="s3">\n    </span><span class="s1">directions[1] = -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">directions[1] = 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates the intersection (clipping) points of the two</span><span class="s3">\n </span><span class="s1">* input rectangles with line segment defined by the centers of these two</span><span class="s3">\n </span><span class="s1">* rectangles. The clipping points are saved in the input double array and</span><span class="s3">\n </span><span class="s1">* whether or not the two rectangles overlap is returned.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getIntersection2 = function (rectA, rectB, result) {</span><span class="s3">\n  </span><span class="s1">//result[0-1] will contain clipPoint of rectA, result[2-3] will contain clipPoint of rectB</span><span class="s3">\n  </span><span class="s1">var p1x = rectA.getCenterX();</span><span class="s3">\n  </span><span class="s1">var p1y = rectA.getCenterY();</span><span class="s3">\n  </span><span class="s1">var p2x = rectB.getCenterX();</span><span class="s3">\n  </span><span class="s1">var p2y = rectB.getCenterY();</span><span class="s3">\n\n  </span><span class="s1">//if two rectangles intersect, then clipping points are centers</span><span class="s3">\n  </span><span class="s1">if (rectA.intersects(rectB)) {</span><span class="s3">\n    </span><span class="s1">result[0] = p1x;</span><span class="s3">\n    </span><span class="s1">result[1] = p1y;</span><span class="s3">\n    </span><span class="s1">result[2] = p2x;</span><span class="s3">\n    </span><span class="s1">result[3] = p2y;</span><span class="s3">\n    </span><span class="s1">return true;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">//variables for rectA</span><span class="s3">\n  </span><span class="s1">var topLeftAx = rectA.getX();</span><span class="s3">\n  </span><span class="s1">var topLeftAy = rectA.getY();</span><span class="s3">\n  </span><span class="s1">var topRightAx = rectA.getRight();</span><span class="s3">\n  </span><span class="s1">var bottomLeftAx = rectA.getX();</span><span class="s3">\n  </span><span class="s1">var bottomLeftAy = rectA.getBottom();</span><span class="s3">\n  </span><span class="s1">var bottomRightAx = rectA.getRight();</span><span class="s3">\n  </span><span class="s1">var halfWidthA = rectA.getWidthHalf();</span><span class="s3">\n  </span><span class="s1">var halfHeightA = rectA.getHeightHalf();</span><span class="s3">\n  </span><span class="s1">//variables for rectB</span><span class="s3">\n  </span><span class="s1">var topLeftBx = rectB.getX();</span><span class="s3">\n  </span><span class="s1">var topLeftBy = rectB.getY();</span><span class="s3">\n  </span><span class="s1">var topRightBx = rectB.getRight();</span><span class="s3">\n  </span><span class="s1">var bottomLeftBx = rectB.getX();</span><span class="s3">\n  </span><span class="s1">var bottomLeftBy = rectB.getBottom();</span><span class="s3">\n  </span><span class="s1">var bottomRightBx = rectB.getRight();</span><span class="s3">\n  </span><span class="s1">var halfWidthB = rectB.getWidthHalf();</span><span class="s3">\n  </span><span class="s1">var halfHeightB = rectB.getHeightHalf();</span><span class="s3">\n\n  </span><span class="s1">//flag whether clipping points are found</span><span class="s3">\n  </span><span class="s1">var clipPointAFound = false;</span><span class="s3">\n  </span><span class="s1">var clipPointBFound = false;</span><span class="s3">\n\n  </span><span class="s1">// line is vertical</span><span class="s3">\n  </span><span class="s1">if (p1x === p2x) {</span><span class="s3">\n    </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n      </span><span class="s1">result[0] = p1x;</span><span class="s3">\n      </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n      </span><span class="s1">result[2] = p2x;</span><span class="s3">\n      </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else if (p1y &lt; p2y) {</span><span class="s3">\n      </span><span class="s1">result[0] = p1x;</span><span class="s3">\n      </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n      </span><span class="s1">result[2] = p2x;</span><span class="s3">\n      </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n      </span><span class="s1">return false;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">//not line, return null;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// line is horizontal</span><span class="s3">\n  </span><span class="s1">else if (p1y === p2y) {</span><span class="s3">\n      </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n        </span><span class="s1">result[0] = topLeftAx;</span><span class="s3">\n        </span><span class="s1">result[1] = p1y;</span><span class="s3">\n        </span><span class="s1">result[2] = topRightBx;</span><span class="s3">\n        </span><span class="s1">result[3] = p2y;</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} else if (p1x &lt; p2x) {</span><span class="s3">\n        </span><span class="s1">result[0] = topRightAx;</span><span class="s3">\n        </span><span class="s1">result[1] = p1y;</span><span class="s3">\n        </span><span class="s1">result[2] = topLeftBx;</span><span class="s3">\n        </span><span class="s1">result[3] = p2y;</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">//not valid line, return null;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">//slopes of rectA's and rectB's diagonals</span><span class="s3">\n      </span><span class="s1">var slopeA = rectA.height / rectA.width;</span><span class="s3">\n      </span><span class="s1">var slopeB = rectB.height / rectB.width;</span><span class="s3">\n\n      </span><span class="s1">//slope of line between center of rectA and center of rectB</span><span class="s3">\n      </span><span class="s1">var slopePrime = (p2y - p1y) / (p2x - p1x);</span><span class="s3">\n      </span><span class="s1">var cardinalDirectionA = void 0;</span><span class="s3">\n      </span><span class="s1">var cardinalDirectionB = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointAx = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointAy = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointBx = void 0;</span><span class="s3">\n      </span><span class="s1">var tempPointBy = void 0;</span><span class="s3">\n\n      </span><span class="s1">//determine whether clipping point is the corner of nodeA</span><span class="s3">\n      </span><span class="s1">if (-slopeA === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n          </span><span class="s1">result[0] = bottomLeftAx;</span><span class="s3">\n          </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[0] = topRightAx;</span><span class="s3">\n          </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (slopeA === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n          </span><span class="s1">result[0] = topLeftAx;</span><span class="s3">\n          </span><span class="s1">result[1] = topLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[0] = bottomRightAx;</span><span class="s3">\n          </span><span class="s1">result[1] = bottomLeftAy;</span><span class="s3">\n          </span><span class="s1">clipPointAFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//determine whether clipping point is the corner of nodeB</span><span class="s3">\n      </span><span class="s1">if (-slopeB === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p2x &gt; p1x) {</span><span class="s3">\n          </span><span class="s1">result[2] = bottomLeftBx;</span><span class="s3">\n          </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[2] = topRightBx;</span><span class="s3">\n          </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else if (slopeB === slopePrime) {</span><span class="s3">\n        </span><span class="s1">if (p2x &gt; p1x) {</span><span class="s3">\n          </span><span class="s1">result[2] = topLeftBx;</span><span class="s3">\n          </span><span class="s1">result[3] = topLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">result[2] = bottomRightBx;</span><span class="s3">\n          </span><span class="s1">result[3] = bottomLeftBy;</span><span class="s3">\n          </span><span class="s1">clipPointBFound = true;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//if both clipping points are corners</span><span class="s3">\n      </span><span class="s1">if (clipPointAFound &amp;&amp; clipPointBFound) {</span><span class="s3">\n        </span><span class="s1">return false;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">//determine Cardinal Direction of rectangles</span><span class="s3">\n      </span><span class="s1">if (p1x &gt; p2x) {</span><span class="s3">\n        </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 4);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 2);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 3);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 1);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">if (p1y &gt; p2y) {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(-slopeA, slopePrime, 1);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(-slopeB, slopePrime, 3);</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">cardinalDirectionA = this.getCardinalDirection(slopeA, slopePrime, 2);</span><span class="s3">\n          </span><span class="s1">cardinalDirectionB = this.getCardinalDirection(slopeB, slopePrime, 4);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">//calculate clipping Point if it is not found before</span><span class="s3">\n      </span><span class="s1">if (!clipPointAFound) {</span><span class="s3">\n        </span><span class="s1">switch (cardinalDirectionA) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">tempPointAy = topLeftAy;</span><span class="s3">\n            </span><span class="s1">tempPointAx = p1x + -halfHeightA / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">tempPointAx = bottomRightAx;</span><span class="s3">\n            </span><span class="s1">tempPointAy = p1y + halfWidthA * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">tempPointAy = bottomLeftAy;</span><span class="s3">\n            </span><span class="s1">tempPointAx = p1x + halfHeightA / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">tempPointAx = bottomLeftAx;</span><span class="s3">\n            </span><span class="s1">tempPointAy = p1y + -halfWidthA * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[0] = tempPointAx;</span><span class="s3">\n            </span><span class="s1">result[1] = tempPointAy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!clipPointBFound) {</span><span class="s3">\n        </span><span class="s1">switch (cardinalDirectionB) {</span><span class="s3">\n          </span><span class="s1">case 1:</span><span class="s3">\n            </span><span class="s1">tempPointBy = topLeftBy;</span><span class="s3">\n            </span><span class="s1">tempPointBx = p2x + -halfHeightB / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 2:</span><span class="s3">\n            </span><span class="s1">tempPointBx = bottomRightBx;</span><span class="s3">\n            </span><span class="s1">tempPointBy = p2y + halfWidthB * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 3:</span><span class="s3">\n            </span><span class="s1">tempPointBy = bottomLeftBy;</span><span class="s3">\n            </span><span class="s1">tempPointBx = p2x + halfHeightB / slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case 4:</span><span class="s3">\n            </span><span class="s1">tempPointBx = bottomLeftBx;</span><span class="s3">\n            </span><span class="s1">tempPointBy = p2y + -halfWidthB * slopePrime;</span><span class="s3">\n            </span><span class="s1">result[2] = tempPointBx;</span><span class="s3">\n            </span><span class="s1">result[3] = tempPointBy;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return false;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns in which cardinal direction does input point stays</span><span class="s3">\n </span><span class="s1">* 1: North</span><span class="s3">\n </span><span class="s1">* 2: East</span><span class="s3">\n </span><span class="s1">* 3: South</span><span class="s3">\n </span><span class="s1">* 4: West</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getCardinalDirection = function (slope, slopePrime, line) {</span><span class="s3">\n  </span><span class="s1">if (slope &gt; slopePrime) {</span><span class="s3">\n    </span><span class="s1">return line;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 1 + line % 4;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method calculates the intersection of the two lines defined by</span><span class="s3">\n </span><span class="s1">* point pairs (s1,s2) and (f1,f2).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.getIntersection = function (s1, s2, f1, f2) {</span><span class="s3">\n  </span><span class="s1">if (f2 == null) {</span><span class="s3">\n    </span><span class="s1">return this.getIntersection2(s1, s2, f1);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var x1 = s1.x;</span><span class="s3">\n  </span><span class="s1">var y1 = s1.y;</span><span class="s3">\n  </span><span class="s1">var x2 = s2.x;</span><span class="s3">\n  </span><span class="s1">var y2 = s2.y;</span><span class="s3">\n  </span><span class="s1">var x3 = f1.x;</span><span class="s3">\n  </span><span class="s1">var y3 = f1.y;</span><span class="s3">\n  </span><span class="s1">var x4 = f2.x;</span><span class="s3">\n  </span><span class="s1">var y4 = f2.y;</span><span class="s3">\n  </span><span class="s1">var x = void 0,</span><span class="s3">\n      </span><span class="s1">y = void 0; // intersection point</span><span class="s3">\n  </span><span class="s1">var a1 = void 0,</span><span class="s3">\n      </span><span class="s1">a2 = void 0,</span><span class="s3">\n      </span><span class="s1">b1 = void 0,</span><span class="s3">\n      </span><span class="s1">b2 = void 0,</span><span class="s3">\n      </span><span class="s1">c1 = void 0,</span><span class="s3">\n      </span><span class="s1">c2 = void 0; // coefficients of line eqns.</span><span class="s3">\n  </span><span class="s1">var denom = void 0;</span><span class="s3">\n\n  </span><span class="s1">a1 = y2 - y1;</span><span class="s3">\n  </span><span class="s1">b1 = x1 - x2;</span><span class="s3">\n  </span><span class="s1">c1 = x2 * y1 - x1 * y2; // { a1*x + b1*y + c1 = 0 is line 1 }</span><span class="s3">\n\n  </span><span class="s1">a2 = y4 - y3;</span><span class="s3">\n  </span><span class="s1">b2 = x3 - x4;</span><span class="s3">\n  </span><span class="s1">c2 = x4 * y3 - x3 * y4; // { a2*x + b2*y + c2 = 0 is line 2 }</span><span class="s3">\n\n  </span><span class="s1">denom = a1 * b2 - a2 * b1;</span><span class="s3">\n\n  </span><span class="s1">if (denom === 0) {</span><span class="s3">\n    </span><span class="s1">return null;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">x = (b1 * c2 - b2 * c1) / denom;</span><span class="s3">\n  </span><span class="s1">y = (a2 * c1 - a1 * c2) / denom;</span><span class="s3">\n\n  </span><span class="s1">return new Point(x, y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method finds and returns the angle of the vector from the + x-axis</span><span class="s3">\n </span><span class="s1">* in clockwise direction (compatible w/ Java coordinate system!).</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.angleOfVector = function (Cx, Cy, Nx, Ny) {</span><span class="s3">\n  </span><span class="s1">var C_angle = void 0;</span><span class="s3">\n\n  </span><span class="s1">if (Cx !== Nx) {</span><span class="s3">\n    </span><span class="s1">C_angle = Math.atan((Ny - Cy) / (Nx - Cx));</span><span class="s3">\n\n    </span><span class="s1">if (Nx &lt; Cx) {</span><span class="s3">\n      </span><span class="s1">C_angle += Math.PI;</span><span class="s3">\n    </span><span class="s1">} else if (Ny &lt; Cy) {</span><span class="s3">\n      </span><span class="s1">C_angle += this.TWO_PI;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (Ny &lt; Cy) {</span><span class="s3">\n    </span><span class="s1">C_angle = this.ONE_AND_HALF_PI; // 270 degrees</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">C_angle = this.HALF_PI; // 90 degrees</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return C_angle;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method checks whether the given two line segments (one with point</span><span class="s3">\n </span><span class="s1">* p1 and p2, the other with point p3 and p4) intersect at a point other</span><span class="s3">\n </span><span class="s1">* than these points.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.doIntersect = function (p1, p2, p3, p4) {</span><span class="s3">\n  </span><span class="s1">var a = p1.x;</span><span class="s3">\n  </span><span class="s1">var b = p1.y;</span><span class="s3">\n  </span><span class="s1">var c = p2.x;</span><span class="s3">\n  </span><span class="s1">var d = p2.y;</span><span class="s3">\n  </span><span class="s1">var p = p3.x;</span><span class="s3">\n  </span><span class="s1">var q = p3.y;</span><span class="s3">\n  </span><span class="s1">var r = p4.x;</span><span class="s3">\n  </span><span class="s1">var s = p4.y;</span><span class="s3">\n  </span><span class="s1">var det = (c - a) * (s - q) - (r - p) * (d - b);</span><span class="s3">\n\n  </span><span class="s1">if (det === 0) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lambda = ((s - q) * (r - a) + (p - r) * (s - b)) / det;</span><span class="s3">\n    </span><span class="s1">var gamma = ((b - d) * (r - a) + (c - a) * (s - b)) / det;</span><span class="s3">\n    </span><span class="s1">return 0 &lt; lambda &amp;&amp; lambda &lt; 1 &amp;&amp; 0 &lt; gamma &amp;&amp; gamma &lt; 1;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method checks and calculates the intersection of </span><span class="s3">\n </span><span class="s1">* a line segment and a circle.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.findCircleLineIntersections = function (Ex, Ey, Lx, Ly, Cx, Cy, r) {</span><span class="s3">\n\n  </span><span class="s1">// E is the starting point of the ray,</span><span class="s3">\n  </span><span class="s1">// L is the end point of the ray,</span><span class="s3">\n  </span><span class="s1">// C is the center of sphere you're testing against</span><span class="s3">\n  </span><span class="s1">// r is the radius of that sphere</span><span class="s3">\n\n  </span><span class="s1">// Compute:</span><span class="s3">\n  </span><span class="s1">// d = L - E ( Direction vector of ray, from start to end )</span><span class="s3">\n  </span><span class="s1">// f = E - C ( Vector from center sphere to ray start )</span><span class="s3">\n\n  </span><span class="s1">// Then the intersection is found by..</span><span class="s3">\n  </span><span class="s1">// P = E + t * d</span><span class="s3">\n  </span><span class="s1">// This is a parametric equation:</span><span class="s3">\n  </span><span class="s1">// Px = Ex + tdx</span><span class="s3">\n  </span><span class="s1">// Py = Ey + tdy</span><span class="s3">\n\n  </span><span class="s1">// get a, b, c values</span><span class="s3">\n  </span><span class="s1">var a = (Lx - Ex) * (Lx - Ex) + (Ly - Ey) * (Ly - Ey);</span><span class="s3">\n  </span><span class="s1">var b = 2 * ((Ex - Cx) * (Lx - Ex) + (Ey - Cy) * (Ly - Ey));</span><span class="s3">\n  </span><span class="s1">var c = (Ex - Cx) * (Ex - Cx) + (Ey - Cy) * (Ey - Cy) - r * r;</span><span class="s3">\n\n  </span><span class="s1">// get discriminant</span><span class="s3">\n  </span><span class="s1">var disc = b * b - 4 * a * c;</span><span class="s3">\n  </span><span class="s1">if (disc &gt;= 0) {</span><span class="s3">\n    </span><span class="s1">// insert into quadratic formula</span><span class="s3">\n    </span><span class="s1">var t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / (2 * a);</span><span class="s3">\n    </span><span class="s1">var t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / (2 * a);</span><span class="s3">\n    </span><span class="s1">var intersections = null;</span><span class="s3">\n    </span><span class="s1">if (t1 &gt;= 0 &amp;&amp; t1 &lt;= 1) {</span><span class="s3">\n      </span><span class="s1">// t1 is the intersection, and it's closer than t2</span><span class="s3">\n      </span><span class="s1">// (since t1 uses -b - discriminant)</span><span class="s3">\n      </span><span class="s1">// Impale, Poke</span><span class="s3">\n      </span><span class="s1">return [t1];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// here t1 didn't intersect so we are either started</span><span class="s3">\n    </span><span class="s1">// inside the sphere or completely past it</span><span class="s3">\n    </span><span class="s1">if (t2 &gt;= 0 &amp;&amp; t2 &lt;= 1) {</span><span class="s3">\n      </span><span class="s1">// ExitWound</span><span class="s3">\n      </span><span class="s1">return [t2];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return intersections;</span><span class="s3">\n  </span><span class="s1">} else return null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: Class Constants</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* Some useful pre-calculated constants</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IGeometry.HALF_PI = 0.5 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.ONE_AND_HALF_PI = 1.5 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.TWO_PI = 2.0 * Math.PI;</span><span class="s3">\n</span><span class="s1">IGeometry.THREE_PI = 3.0 * Math.PI;</span><span class="s3">\n\n</span><span class="s1">module.exports = IGeometry;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 9 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function IMath() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* This method returns the sign of the input value.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">IMath.sign = function (value) {</span><span class="s3">\n  </span><span class="s1">if (value &gt; 0) {</span><span class="s3">\n    </span><span class="s1">return 1;</span><span class="s3">\n  </span><span class="s1">} else if (value &lt; 0) {</span><span class="s3">\n    </span><span class="s1">return -1;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return 0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">IMath.floor = function (value) {</span><span class="s3">\n  </span><span class="s1">return value &lt; 0 ? Math.ceil(value) : Math.floor(value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">IMath.ceil = function (value) {</span><span class="s3">\n  </span><span class="s1">return value &lt; 0 ? Math.floor(value) : Math.ceil(value);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = IMath;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 10 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function Integer() {}</span><span class="s3">\n\n</span><span class="s1">Integer.MAX_VALUE = 2147483647;</span><span class="s3">\n</span><span class="s1">Integer.MIN_VALUE = -2147483648;</span><span class="s3">\n\n</span><span class="s1">module.exports = Integer;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 11 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">var nodeFrom = function nodeFrom(value) {</span><span class="s3">\n  </span><span class="s1">return { value: value, next: null, prev: null };</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var add = function add(prev, node, next, list) {</span><span class="s3">\n  </span><span class="s1">if (prev !== null) {</span><span class="s3">\n    </span><span class="s1">prev.next = node;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.head = node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (next !== null) {</span><span class="s3">\n    </span><span class="s1">next.prev = node;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.tail = node;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">node.prev = prev;</span><span class="s3">\n  </span><span class="s1">node.next = next;</span><span class="s3">\n\n  </span><span class="s1">list.length++;</span><span class="s3">\n\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var _remove = function _remove(node, list) {</span><span class="s3">\n  </span><span class="s1">var prev = node.prev,</span><span class="s3">\n      </span><span class="s1">next = node.next;</span><span class="s3">\n\n\n  </span><span class="s1">if (prev !== null) {</span><span class="s3">\n    </span><span class="s1">prev.next = next;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.head = next;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (next !== null) {</span><span class="s3">\n    </span><span class="s1">next.prev = prev;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">list.tail = prev;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">node.prev = node.next = null;</span><span class="s3">\n\n  </span><span class="s1">list.length--;</span><span class="s3">\n\n  </span><span class="s1">return node;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">var LinkedList = function () {</span><span class="s3">\n  </span><span class="s1">function LinkedList(vals) {</span><span class="s3">\n    </span><span class="s1">var _this = this;</span><span class="s3">\n\n    </span><span class="s1">_classCallCheck(this, LinkedList);</span><span class="s3">\n\n    </span><span class="s1">this.length = 0;</span><span class="s3">\n    </span><span class="s1">this.head = null;</span><span class="s3">\n    </span><span class="s1">this.tail = null;</span><span class="s3">\n\n    </span><span class="s1">if (vals != null) {</span><span class="s3">\n      </span><span class="s1">vals.forEach(function (v) {</span><span class="s3">\n        </span><span class="s1">return _this.push(v);</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">_createClass(LinkedList, [{</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">size</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function size() {</span><span class="s3">\n      </span><span class="s1">return this.length;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertBefore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertBefore(val, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode.prev, nodeFrom(val), otherNode, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertAfter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertAfter(val, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode, nodeFrom(val), otherNode.next, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertNodeBefore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertNodeBefore(newNode, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode.prev, newNode, otherNode, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">insertNodeAfter</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function insertNodeAfter(newNode, otherNode) {</span><span class="s3">\n      </span><span class="s1">return add(otherNode, newNode, otherNode.next, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">push</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function push(val) {</span><span class="s3">\n      </span><span class="s1">return add(this.tail, nodeFrom(val), null, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">unshift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function unshift(val) {</span><span class="s3">\n      </span><span class="s1">return add(null, nodeFrom(val), this.head, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">remove</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function remove(node) {</span><span class="s3">\n      </span><span class="s1">return _remove(node, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">pop</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function pop() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.tail, this).value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">popNode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function popNode() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.tail, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">shift</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function shift() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.head, this).value;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">shiftNode</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function shiftNode() {</span><span class="s3">\n      </span><span class="s1">return _remove(this.head, this);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">get_object_at</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function get_object_at(index) {</span><span class="s3">\n      </span><span class="s1">if (index &lt;= this.length()) {</span><span class="s3">\n        </span><span class="s1">var i = 1;</span><span class="s3">\n        </span><span class="s1">var current = this.head;</span><span class="s3">\n        </span><span class="s1">while (i &lt; index) {</span><span class="s3">\n          </span><span class="s1">current = current.next;</span><span class="s3">\n          </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return current.value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}, {</span><span class="s3">\n    </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">set_object_at</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">value: function set_object_at(index, value) {</span><span class="s3">\n      </span><span class="s1">if (index &lt;= this.length()) {</span><span class="s3">\n        </span><span class="s1">var i = 1;</span><span class="s3">\n        </span><span class="s1">var current = this.head;</span><span class="s3">\n        </span><span class="s1">while (i &lt; index) {</span><span class="s3">\n          </span><span class="s1">current = current.next;</span><span class="s3">\n          </span><span class="s1">i++;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">current.value = value;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}]);</span><span class="s3">\n\n  </span><span class="s1">return LinkedList;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = LinkedList;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 12 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">/*</span><span class="s3">\r\n </span><span class="s1">*This class is the javascript implementation of the Point.java class in jdk</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">function Point(x, y, p) {</span><span class="s3">\n  </span><span class="s1">this.x = null;</span><span class="s3">\n  </span><span class="s1">this.y = null;</span><span class="s3">\n  </span><span class="s1">if (x == null &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">this.x = 0;</span><span class="s3">\n    </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">} else if (typeof x == 'number' &amp;&amp; typeof y == 'number' &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n  </span><span class="s1">} else if (x.constructor.name == 'Point' &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">p = x;</span><span class="s3">\n    </span><span class="s1">this.x = p.x;</span><span class="s3">\n    </span><span class="s1">this.y = p.y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.getLocation = function () {</span><span class="s3">\n  </span><span class="s1">return new Point(this.x, this.y);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.setLocation = function (x, y, p) {</span><span class="s3">\n  </span><span class="s1">if (x.constructor.name == 'Point' &amp;&amp; y == null &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">p = x;</span><span class="s3">\n    </span><span class="s1">this.setLocation(p.x, p.y);</span><span class="s3">\n  </span><span class="s1">} else if (typeof x == 'number' &amp;&amp; typeof y == 'number' &amp;&amp; p == null) {</span><span class="s3">\n    </span><span class="s1">//if both parameters are integer just move (x,y) location</span><span class="s3">\n    </span><span class="s1">if (parseInt(x) == x &amp;&amp; parseInt(y) == y) {</span><span class="s3">\n      </span><span class="s1">this.move(x, y);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.x = Math.floor(x + 0.5);</span><span class="s3">\n      </span><span class="s1">this.y = Math.floor(y + 0.5);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.move = function (x, y) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.translate = function (dx, dy) {</span><span class="s3">\n  </span><span class="s1">this.x += dx;</span><span class="s3">\n  </span><span class="s1">this.y += dy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.equals = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (obj.constructor.name == </span><span class="s3">\&quot;</span><span class="s1">Point</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">var pt = obj;</span><span class="s3">\n    </span><span class="s1">return this.x == pt.x &amp;&amp; this.y == pt.y;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return this == obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Point.prototype.toString = function () {</span><span class="s3">\n  </span><span class="s1">return new Point().constructor.name + </span><span class="s3">\&quot;</span><span class="s1">[x=</span><span class="s3">\&quot; </span><span class="s1">+ this.x + </span><span class="s3">\&quot;</span><span class="s1">,y=</span><span class="s3">\&quot; </span><span class="s1">+ this.y + </span><span class="s3">\&quot;</span><span class="s1">]</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Point;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 13 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function RectangleD(x, y, width, height) {</span><span class="s3">\n  </span><span class="s1">this.x = 0;</span><span class="s3">\n  </span><span class="s1">this.y = 0;</span><span class="s3">\n  </span><span class="s1">this.width = 0;</span><span class="s3">\n  </span><span class="s1">this.height = 0;</span><span class="s3">\n\n  </span><span class="s1">if (x != null &amp;&amp; y != null &amp;&amp; width != null &amp;&amp; height != null) {</span><span class="s3">\n    </span><span class="s1">this.x = x;</span><span class="s3">\n    </span><span class="s1">this.y = y;</span><span class="s3">\n    </span><span class="s1">this.width = width;</span><span class="s3">\n    </span><span class="s1">this.height = height;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setX = function (x) {</span><span class="s3">\n  </span><span class="s1">this.x = x;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setY = function (y) {</span><span class="s3">\n  </span><span class="s1">this.y = y;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getRight = function () {</span><span class="s3">\n  </span><span class="s1">return this.x + this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getBottom = function () {</span><span class="s3">\n  </span><span class="s1">return this.y + this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.intersects = function (a) {</span><span class="s3">\n  </span><span class="s1">if (this.getRight() &lt; a.x) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.getBottom() &lt; a.y) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (a.getRight() &lt; this.x) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (a.getBottom() &lt; this.y) {</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return true;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getCenterX = function () {</span><span class="s3">\n  </span><span class="s1">return this.x + this.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMinX = function () {</span><span class="s3">\n  </span><span class="s1">return this.getX();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMaxX = function () {</span><span class="s3">\n  </span><span class="s1">return this.getX() + this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getCenterY = function () {</span><span class="s3">\n  </span><span class="s1">return this.y + this.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMinY = function () {</span><span class="s3">\n  </span><span class="s1">return this.getY();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getMaxY = function () {</span><span class="s3">\n  </span><span class="s1">return this.getY() + this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getWidthHalf = function () {</span><span class="s3">\n  </span><span class="s1">return this.width / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">RectangleD.prototype.getHeightHalf = function () {</span><span class="s3">\n  </span><span class="s1">return this.height / 2;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = RectangleD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 14 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _typeof = typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; typeof Symbol.iterator === </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">? function (obj) { return typeof obj; } : function (obj) { return obj &amp;&amp; typeof Symbol === </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; obj.constructor === Symbol &amp;&amp; obj !== Symbol.prototype ? </span><span class="s3">\&quot;</span><span class="s1">symbol</span><span class="s3">\&quot; </span><span class="s1">: typeof obj; };</span><span class="s3">\n\n</span><span class="s1">function UniqueIDGeneretor() {}</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.lastID = 0;</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.createID = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (UniqueIDGeneretor.isPrimitive(obj)) {</span><span class="s3">\n    </span><span class="s1">return obj;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (obj.uniqueID != null) {</span><span class="s3">\n    </span><span class="s1">return obj.uniqueID;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">obj.uniqueID = UniqueIDGeneretor.getString();</span><span class="s3">\n  </span><span class="s1">UniqueIDGeneretor.lastID++;</span><span class="s3">\n  </span><span class="s1">return obj.uniqueID;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.getString = function (id) {</span><span class="s3">\n  </span><span class="s1">if (id == null) id = UniqueIDGeneretor.lastID;</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">Object#</span><span class="s3">\&quot; </span><span class="s1">+ id + </span><span class="s3">\&quot;\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">UniqueIDGeneretor.isPrimitive = function (arg) {</span><span class="s3">\n  </span><span class="s1">var type = typeof arg === </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">undefined</span><span class="s3">\&quot; </span><span class="s1">: _typeof(arg);</span><span class="s3">\n  </span><span class="s1">return arg == null || type != </span><span class="s3">\&quot;</span><span class="s1">object</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; type != </span><span class="s3">\&quot;</span><span class="s1">function</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = UniqueIDGeneretor;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 15 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }</span><span class="s3">\n\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var LGraphManager = __webpack_require__(7);</span><span class="s3">\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var LGraph = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">var PointD = __webpack_require__(5);</span><span class="s3">\n</span><span class="s1">var Transform = __webpack_require__(17);</span><span class="s3">\n</span><span class="s1">var Emitter = __webpack_require__(29);</span><span class="s3">\n\n</span><span class="s1">function Layout(isRemoteUse) {</span><span class="s3">\n  </span><span class="s1">Emitter.call(this);</span><span class="s3">\n\n  </span><span class="s1">//Layout Quality: 0:draft, 1:default, 2:proof</span><span class="s3">\n  </span><span class="s1">this.layoutQuality = LayoutConstants.QUALITY;</span><span class="s3">\n  </span><span class="s1">//Whether layout should create bendpoints as needed or not</span><span class="s3">\n  </span><span class="s1">this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n  </span><span class="s1">//Whether layout should be incremental or not</span><span class="s3">\n  </span><span class="s1">this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">//Whether we animate from before to after layout node positions</span><span class="s3">\n  </span><span class="s1">this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;</span><span class="s3">\n  </span><span class="s1">//Whether we animate the layout process or not</span><span class="s3">\n  </span><span class="s1">this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;</span><span class="s3">\n  </span><span class="s1">//Number iterations that should be done between two successive animations</span><span class="s3">\n  </span><span class="s1">this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\r\n   </span><span class="s1">* Whether or not leaf nodes (non-compound nodes) are of uniform sizes. When</span><span class="s3">\r\n   </span><span class="s1">* they are, both spring and repulsion forces between two leaf nodes can be</span><span class="s3">\r\n   </span><span class="s1">* calculated without the expensive clipping point calculations, resulting</span><span class="s3">\r\n   </span><span class="s1">* in major speed-up.</span><span class="s3">\r\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\r\n   </span><span class="s1">* This is used for creation of bendpoints by using dummy nodes and edges.</span><span class="s3">\r\n   </span><span class="s1">* Maps an LEdge to its dummy bendpoint path.</span><span class="s3">\r\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">this.edgeToDummyNodes = new Map();</span><span class="s3">\n  </span><span class="s1">this.graphManager = new LGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.isLayoutFinished = false;</span><span class="s3">\n  </span><span class="s1">this.isSubLayout = false;</span><span class="s3">\n  </span><span class="s1">this.isRemoteUse = false;</span><span class="s3">\n\n  </span><span class="s1">if (isRemoteUse != null) {</span><span class="s3">\n    </span><span class="s1">this.isRemoteUse = isRemoteUse;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Layout.RANDOM_SEED = 1;</span><span class="s3">\n\n</span><span class="s1">Layout.prototype = Object.create(Emitter.prototype);</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllNodes();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllEdges = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllEdges();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.getAllNodesToApplyGravitation = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getAllNodesToApplyGravitation();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newGraphManager = function () {</span><span class="s3">\n  </span><span class="s1">var gm = new LGraphManager(this);</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n  </span><span class="s1">return gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newGraph = function (vGraph) {</span><span class="s3">\n  </span><span class="s1">return new LGraph(null, this.graphManager, vGraph);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newNode = function (vNode) {</span><span class="s3">\n  </span><span class="s1">return new LNode(this.graphManager, vNode);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.newEdge = function (vEdge) {</span><span class="s3">\n  </span><span class="s1">return new LEdge(null, null, vEdge);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.checkLayoutSuccess = function () {</span><span class="s3">\n  </span><span class="s1">return this.graphManager.getRoot() == null || this.graphManager.getRoot().getNodes().length == 0 || this.graphManager.includesInvalidEdge();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.runLayout = function () {</span><span class="s3">\n  </span><span class="s1">this.isLayoutFinished = false;</span><span class="s3">\n\n  </span><span class="s1">if (this.tilingPreLayout) {</span><span class="s3">\n    </span><span class="s1">this.tilingPreLayout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.initParameters();</span><span class="s3">\n  </span><span class="s1">var isLayoutSuccessfull;</span><span class="s3">\n\n  </span><span class="s1">if (this.checkLayoutSuccess()) {</span><span class="s3">\n    </span><span class="s1">isLayoutSuccessfull = false;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">isLayoutSuccessfull = this.layout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (LayoutConstants.ANIMATE === 'during') {</span><span class="s3">\n    </span><span class="s1">// If this is a 'during' layout animation. Layout is not finished yet. </span><span class="s3">\n    </span><span class="s1">// We need to perform these in index.js when layout is really finished.</span><span class="s3">\n    </span><span class="s1">return false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (isLayoutSuccessfull) {</span><span class="s3">\n    </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n      </span><span class="s1">this.doPostLayout();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.tilingPostLayout) {</span><span class="s3">\n    </span><span class="s1">this.tilingPostLayout();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.isLayoutFinished = true;</span><span class="s3">\n\n  </span><span class="s1">return isLayoutSuccessfull;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method performs the operations required after layout.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.doPostLayout = function () {</span><span class="s3">\n  </span><span class="s1">//assert !isSubLayout : </span><span class="s3">\&quot;</span><span class="s1">Should not be called on sub-layout!</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">// Propagate geometric changes to v-level objects</span><span class="s3">\n  </span><span class="s1">if (!this.incremental) {</span><span class="s3">\n    </span><span class="s1">this.transform();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">this.update();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method updates the geometry of the target graph according to</span><span class="s3">\r\n </span><span class="s1">* calculated layout.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.update2 = function () {</span><span class="s3">\n  </span><span class="s1">// update bend points</span><span class="s3">\n  </span><span class="s1">if (this.createBendsAsNeeded) {</span><span class="s3">\n    </span><span class="s1">this.createBendpointsFromDummyNodes();</span><span class="s3">\n\n    </span><span class="s1">// reset all edges, since the topology has changed</span><span class="s3">\n    </span><span class="s1">this.graphManager.resetAllEdges();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// perform edge, node and root updates if layout is not called</span><span class="s3">\n  </span><span class="s1">// remotely</span><span class="s3">\n  </span><span class="s1">if (!this.isRemoteUse) {</span><span class="s3">\n    </span><span class="s1">// update all edges</span><span class="s3">\n    </span><span class="s1">var edge;</span><span class="s3">\n    </span><span class="s1">var allEdges = this.graphManager.getAllEdges();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; allEdges.length; i++) {</span><span class="s3">\n      </span><span class="s1">edge = allEdges[i];</span><span class="s3">\n      </span><span class="s1">//      this.update(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// recursively update nodes</span><span class="s3">\n    </span><span class="s1">var node;</span><span class="s3">\n    </span><span class="s1">var nodes = this.graphManager.getRoot().getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">node = nodes[i];</span><span class="s3">\n      </span><span class="s1">//      this.update(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// update root graph</span><span class="s3">\n    </span><span class="s1">this.update(this.graphManager.getRoot());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.update = function (obj) {</span><span class="s3">\n  </span><span class="s1">if (obj == null) {</span><span class="s3">\n    </span><span class="s1">this.update2();</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LNode) {</span><span class="s3">\n    </span><span class="s1">var node = obj;</span><span class="s3">\n    </span><span class="s1">if (node.getChild() != null) {</span><span class="s3">\n      </span><span class="s1">// since node is compound, recursively update child nodes</span><span class="s3">\n      </span><span class="s1">var nodes = node.getChild().getNodes();</span><span class="s3">\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">update(nodes[i]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// if the l-level node is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level node implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n    </span><span class="s1">if (node.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vNode = node.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vNode.update(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LEdge) {</span><span class="s3">\n    </span><span class="s1">var edge = obj;</span><span class="s3">\n    </span><span class="s1">// if the l-level edge is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level edge implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n\n    </span><span class="s1">if (edge.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vEdge = edge.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vEdge.update(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else if (obj instanceof LGraph) {</span><span class="s3">\n    </span><span class="s1">var graph = obj;</span><span class="s3">\n    </span><span class="s1">// if the l-level graph is associated with a v-level graph object,</span><span class="s3">\n    </span><span class="s1">// then it is assumed that the v-level object implements the</span><span class="s3">\n    </span><span class="s1">// interface Updatable.</span><span class="s3">\n\n    </span><span class="s1">if (graph.vGraphObject != null) {</span><span class="s3">\n      </span><span class="s1">// cast to Updatable without any type check</span><span class="s3">\n      </span><span class="s1">var vGraph = graph.vGraphObject;</span><span class="s3">\n\n      </span><span class="s1">// call the update method of the interface</span><span class="s3">\n      </span><span class="s1">vGraph.update(graph);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method is used to set all layout parameters to default values</span><span class="s3">\r\n </span><span class="s1">* determined at compile time.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">if (!this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">this.layoutQuality = LayoutConstants.QUALITY;</span><span class="s3">\n    </span><span class="s1">this.animationDuringLayout = LayoutConstants.DEFAULT_ANIMATION_DURING_LAYOUT;</span><span class="s3">\n    </span><span class="s1">this.animationPeriod = LayoutConstants.DEFAULT_ANIMATION_PERIOD;</span><span class="s3">\n    </span><span class="s1">this.animationOnLayout = LayoutConstants.DEFAULT_ANIMATION_ON_LAYOUT;</span><span class="s3">\n    </span><span class="s1">this.incremental = LayoutConstants.DEFAULT_INCREMENTAL;</span><span class="s3">\n    </span><span class="s1">this.createBendsAsNeeded = LayoutConstants.DEFAULT_CREATE_BENDS_AS_NEEDED;</span><span class="s3">\n    </span><span class="s1">this.uniformLeafNodeSizes = LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">if (this.animationDuringLayout) {</span><span class="s3">\n    </span><span class="s1">this.animationOnLayout = false;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.transform = function (newLeftTop) {</span><span class="s3">\n  </span><span class="s1">if (newLeftTop == undefined) {</span><span class="s3">\n    </span><span class="s1">this.transform(new PointD(0, 0));</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">// create a transformation object (from Eclipse to layout). When an</span><span class="s3">\n    </span><span class="s1">// inverse transform is applied, we get upper-left coordinate of the</span><span class="s3">\n    </span><span class="s1">// drawing or the root graph at given input coordinate (some margins</span><span class="s3">\n    </span><span class="s1">// already included in calculation of left-top).</span><span class="s3">\n\n    </span><span class="s1">var trans = new Transform();</span><span class="s3">\n    </span><span class="s1">var leftTop = this.graphManager.getRoot().updateLeftTop();</span><span class="s3">\n\n    </span><span class="s1">if (leftTop != null) {</span><span class="s3">\n      </span><span class="s1">trans.setWorldOrgX(newLeftTop.x);</span><span class="s3">\n      </span><span class="s1">trans.setWorldOrgY(newLeftTop.y);</span><span class="s3">\n\n      </span><span class="s1">trans.setDeviceOrgX(leftTop.x);</span><span class="s3">\n      </span><span class="s1">trans.setDeviceOrgY(leftTop.y);</span><span class="s3">\n\n      </span><span class="s1">var nodes = this.getAllNodes();</span><span class="s3">\n      </span><span class="s1">var node;</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n        </span><span class="s1">node = nodes[i];</span><span class="s3">\n        </span><span class="s1">node.transform(trans);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.prototype.positionNodesRandomly = function (graph) {</span><span class="s3">\n\n  </span><span class="s1">if (graph == undefined) {</span><span class="s3">\n    </span><span class="s1">//assert !this.incremental;</span><span class="s3">\n    </span><span class="s1">this.positionNodesRandomly(this.getGraphManager().getRoot());</span><span class="s3">\n    </span><span class="s1">this.getGraphManager().getRoot().updateBounds(true);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var lNode;</span><span class="s3">\n    </span><span class="s1">var childGraph;</span><span class="s3">\n\n    </span><span class="s1">var nodes = graph.getNodes();</span><span class="s3">\n    </span><span class="s1">for (var i = 0; i &lt; nodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">lNode = nodes[i];</span><span class="s3">\n      </span><span class="s1">childGraph = lNode.getChild();</span><span class="s3">\n\n      </span><span class="s1">if (childGraph == null) {</span><span class="s3">\n        </span><span class="s1">lNode.scatter();</span><span class="s3">\n      </span><span class="s1">} else if (childGraph.getNodes().length == 0) {</span><span class="s3">\n        </span><span class="s1">lNode.scatter();</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">this.positionNodesRandomly(childGraph);</span><span class="s3">\n        </span><span class="s1">lNode.updateBounds();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method returns a list of trees where each tree is represented as a</span><span class="s3">\r\n </span><span class="s1">* list of l-nodes. The method returns a list of size 0 when:</span><span class="s3">\r\n </span><span class="s1">* - The graph is not flat or</span><span class="s3">\r\n </span><span class="s1">* - One of the component(s) of the graph is not a tree.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.getFlatForest = function () {</span><span class="s3">\n  </span><span class="s1">var flatForest = [];</span><span class="s3">\n  </span><span class="s1">var isForest = true;</span><span class="s3">\n\n  </span><span class="s1">// Quick reference for all nodes in the graph manager associated with</span><span class="s3">\n  </span><span class="s1">// this layout. The list should not be changed.</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getRoot().getNodes();</span><span class="s3">\n\n  </span><span class="s1">// First be sure that the graph is flat</span><span class="s3">\n  </span><span class="s1">var isFlat = true;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">if (allNodes[i].getChild() != null) {</span><span class="s3">\n      </span><span class="s1">isFlat = false;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Return empty forest if the graph is not flat.</span><span class="s3">\n  </span><span class="s1">if (!isFlat) {</span><span class="s3">\n    </span><span class="s1">return flatForest;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">// Run BFS for each component of the graph.</span><span class="s3">\n\n  </span><span class="s1">var visited = new Set();</span><span class="s3">\n  </span><span class="s1">var toBeVisited = [];</span><span class="s3">\n  </span><span class="s1">var parents = new Map();</span><span class="s3">\n  </span><span class="s1">var unProcessedNodes = [];</span><span class="s3">\n\n  </span><span class="s1">unProcessedNodes = unProcessedNodes.concat(allNodes);</span><span class="s3">\n\n  </span><span class="s1">// Each iteration of this loop finds a component of the graph and</span><span class="s3">\n  </span><span class="s1">// decides whether it is a tree or not. If it is a tree, adds it to the</span><span class="s3">\n  </span><span class="s1">// forest and continued with the next component.</span><span class="s3">\n\n  </span><span class="s1">while (unProcessedNodes.length &gt; 0 &amp;&amp; isForest) {</span><span class="s3">\n    </span><span class="s1">toBeVisited.push(unProcessedNodes[0]);</span><span class="s3">\n\n    </span><span class="s1">// Start the BFS. Each iteration of this loop visits a node in a</span><span class="s3">\n    </span><span class="s1">// BFS manner.</span><span class="s3">\n    </span><span class="s1">while (toBeVisited.length &gt; 0 &amp;&amp; isForest) {</span><span class="s3">\n      </span><span class="s1">//pool operation</span><span class="s3">\n      </span><span class="s1">var currentNode = toBeVisited[0];</span><span class="s3">\n      </span><span class="s1">toBeVisited.splice(0, 1);</span><span class="s3">\n      </span><span class="s1">visited.add(currentNode);</span><span class="s3">\n\n      </span><span class="s1">// Traverse all neighbors of this node</span><span class="s3">\n      </span><span class="s1">var neighborEdges = currentNode.getEdges();</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; neighborEdges.length; i++) {</span><span class="s3">\n        </span><span class="s1">var currentNeighbor = neighborEdges[i].getOtherEnd(currentNode);</span><span class="s3">\n\n        </span><span class="s1">// If BFS is not growing from this neighbor.</span><span class="s3">\n        </span><span class="s1">if (parents.get(currentNode) != currentNeighbor) {</span><span class="s3">\n          </span><span class="s1">// We haven't previously visited this neighbor.</span><span class="s3">\n          </span><span class="s1">if (!visited.has(currentNeighbor)) {</span><span class="s3">\n            </span><span class="s1">toBeVisited.push(currentNeighbor);</span><span class="s3">\n            </span><span class="s1">parents.set(currentNeighbor, currentNode);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">// Since we have previously visited this neighbor and</span><span class="s3">\n          </span><span class="s1">// this neighbor is not parent of currentNode, given</span><span class="s3">\n          </span><span class="s1">// graph contains a component that is not tree, hence</span><span class="s3">\n          </span><span class="s1">// it is not a forest.</span><span class="s3">\n          </span><span class="s1">else {</span><span class="s3">\n              </span><span class="s1">isForest = false;</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">// The graph contains a component that is not a tree. Empty</span><span class="s3">\n    </span><span class="s1">// previously found trees. The method will end.</span><span class="s3">\n    </span><span class="s1">if (!isForest) {</span><span class="s3">\n      </span><span class="s1">flatForest = [];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">// Save currently visited nodes as a tree in our forest. Reset</span><span class="s3">\n    </span><span class="s1">// visited and parents lists. Continue with the next component of</span><span class="s3">\n    </span><span class="s1">// the graph, if any.</span><span class="s3">\n    </span><span class="s1">else {</span><span class="s3">\n        </span><span class="s1">var temp = [].concat(_toConsumableArray(visited));</span><span class="s3">\n        </span><span class="s1">flatForest.push(temp);</span><span class="s3">\n        </span><span class="s1">//flatForest = flatForest.concat(temp);</span><span class="s3">\n        </span><span class="s1">//unProcessedNodes.removeAll(visited);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; temp.length; i++) {</span><span class="s3">\n          </span><span class="s1">var value = temp[i];</span><span class="s3">\n          </span><span class="s1">var index = unProcessedNodes.indexOf(value);</span><span class="s3">\n          </span><span class="s1">if (index &gt; -1) {</span><span class="s3">\n            </span><span class="s1">unProcessedNodes.splice(index, 1);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">visited = new Set();</span><span class="s3">\n        </span><span class="s1">parents = new Map();</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return flatForest;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method creates dummy nodes (an l-level node with minimal dimensions)</span><span class="s3">\r\n </span><span class="s1">* for the given edge (one per bendpoint). The existing l-level structure</span><span class="s3">\r\n </span><span class="s1">* is updated accordingly.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.createDummyNodesForBendpoints = function (edge) {</span><span class="s3">\n  </span><span class="s1">var dummyNodes = [];</span><span class="s3">\n  </span><span class="s1">var prev = edge.source;</span><span class="s3">\n\n  </span><span class="s1">var graph = this.graphManager.calcLowestCommonAncestor(edge.source, edge.target);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; edge.bendpoints.length; i++) {</span><span class="s3">\n    </span><span class="s1">// create new dummy node</span><span class="s3">\n    </span><span class="s1">var dummyNode = this.newNode(null);</span><span class="s3">\n    </span><span class="s1">dummyNode.setRect(new Point(0, 0), new Dimension(1, 1));</span><span class="s3">\n\n    </span><span class="s1">graph.add(dummyNode);</span><span class="s3">\n\n    </span><span class="s1">// create new dummy edge between prev and dummy node</span><span class="s3">\n    </span><span class="s1">var dummyEdge = this.newEdge(null);</span><span class="s3">\n    </span><span class="s1">this.graphManager.add(dummyEdge, prev, dummyNode);</span><span class="s3">\n\n    </span><span class="s1">dummyNodes.add(dummyNode);</span><span class="s3">\n    </span><span class="s1">prev = dummyNode;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var dummyEdge = this.newEdge(null);</span><span class="s3">\n  </span><span class="s1">this.graphManager.add(dummyEdge, prev, edge.target);</span><span class="s3">\n\n  </span><span class="s1">this.edgeToDummyNodes.set(edge, dummyNodes);</span><span class="s3">\n\n  </span><span class="s1">// remove real edge from graph manager if it is inter-graph</span><span class="s3">\n  </span><span class="s1">if (edge.isInterGraph()) {</span><span class="s3">\n    </span><span class="s1">this.graphManager.remove(edge);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// else, remove the edge from the current graph</span><span class="s3">\n  </span><span class="s1">else {</span><span class="s3">\n      </span><span class="s1">graph.remove(edge);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return dummyNodes;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method creates bendpoints for edges from the dummy nodes</span><span class="s3">\r\n </span><span class="s1">* at l-level.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.createBendpointsFromDummyNodes = function () {</span><span class="s3">\n  </span><span class="s1">var edges = [];</span><span class="s3">\n  </span><span class="s1">edges = edges.concat(this.graphManager.getAllEdges());</span><span class="s3">\n  </span><span class="s1">edges = [].concat(_toConsumableArray(this.edgeToDummyNodes.keys())).concat(edges);</span><span class="s3">\n\n  </span><span class="s1">for (var k = 0; k &lt; edges.length; k++) {</span><span class="s3">\n    </span><span class="s1">var lEdge = edges[k];</span><span class="s3">\n\n    </span><span class="s1">if (lEdge.bendpoints.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">var path = this.edgeToDummyNodes.get(lEdge);</span><span class="s3">\n\n      </span><span class="s1">for (var i = 0; i &lt; path.length; i++) {</span><span class="s3">\n        </span><span class="s1">var dummyNode = path[i];</span><span class="s3">\n        </span><span class="s1">var p = new PointD(dummyNode.getCenterX(), dummyNode.getCenterY());</span><span class="s3">\n\n        </span><span class="s1">// update bendpoint's location according to dummy node</span><span class="s3">\n        </span><span class="s1">var ebp = lEdge.bendpoints.get(i);</span><span class="s3">\n        </span><span class="s1">ebp.x = p.x;</span><span class="s3">\n        </span><span class="s1">ebp.y = p.y;</span><span class="s3">\n\n        </span><span class="s1">// remove the dummy node, dummy edges incident with this</span><span class="s3">\n        </span><span class="s1">// dummy node is also removed (within the remove method)</span><span class="s3">\n        </span><span class="s1">dummyNode.getOwner().remove(dummyNode);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// add the real edge to graph</span><span class="s3">\n      </span><span class="s1">this.graphManager.add(lEdge, lEdge.source, lEdge.target);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Layout.transform = function (sliderValue, defaultValue, minDiv, maxMul) {</span><span class="s3">\n  </span><span class="s1">if (minDiv != undefined &amp;&amp; maxMul != undefined) {</span><span class="s3">\n    </span><span class="s1">var value = defaultValue;</span><span class="s3">\n\n    </span><span class="s1">if (sliderValue &lt;= 50) {</span><span class="s3">\n      </span><span class="s1">var minValue = defaultValue / minDiv;</span><span class="s3">\n      </span><span class="s1">value -= (defaultValue - minValue) / 50 * (50 - sliderValue);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var maxValue = defaultValue * maxMul;</span><span class="s3">\n      </span><span class="s1">value += (maxValue - defaultValue) / 50 * (sliderValue - 50);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return value;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">var a, b;</span><span class="s3">\n\n    </span><span class="s1">if (sliderValue &lt;= 50) {</span><span class="s3">\n      </span><span class="s1">a = 9.0 * defaultValue / 500.0;</span><span class="s3">\n      </span><span class="s1">b = defaultValue / 10.0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">a = 9.0 * defaultValue / 50.0;</span><span class="s3">\n      </span><span class="s1">b = -8 * defaultValue;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">return a * sliderValue + b;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* This method finds and returns the center of the given nodes, assuming</span><span class="s3">\r\n </span><span class="s1">* that the given nodes form a tree in themselves.</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.findCenterOfTree = function (nodes) {</span><span class="s3">\n  </span><span class="s1">var list = [];</span><span class="s3">\n  </span><span class="s1">list = list.concat(nodes);</span><span class="s3">\n\n  </span><span class="s1">var removedNodes = [];</span><span class="s3">\n  </span><span class="s1">var remainingDegrees = new Map();</span><span class="s3">\n  </span><span class="s1">var foundCenter = false;</span><span class="s3">\n  </span><span class="s1">var centerNode = null;</span><span class="s3">\n\n  </span><span class="s1">if (list.length == 1 || list.length == 2) {</span><span class="s3">\n    </span><span class="s1">foundCenter = true;</span><span class="s3">\n    </span><span class="s1">centerNode = list[0];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s3">\n    </span><span class="s1">var node = list[i];</span><span class="s3">\n    </span><span class="s1">var degree = node.getNeighborsList().size;</span><span class="s3">\n    </span><span class="s1">remainingDegrees.set(node, node.getNeighborsList().size);</span><span class="s3">\n\n    </span><span class="s1">if (degree == 1) {</span><span class="s3">\n      </span><span class="s1">removedNodes.push(node);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">var tempList = [];</span><span class="s3">\n  </span><span class="s1">tempList = tempList.concat(removedNodes);</span><span class="s3">\n\n  </span><span class="s1">while (!foundCenter) {</span><span class="s3">\n    </span><span class="s1">var tempList2 = [];</span><span class="s3">\n    </span><span class="s1">tempList2 = tempList2.concat(tempList);</span><span class="s3">\n    </span><span class="s1">tempList = [];</span><span class="s3">\n\n    </span><span class="s1">for (var i = 0; i &lt; list.length; i++) {</span><span class="s3">\n      </span><span class="s1">var node = list[i];</span><span class="s3">\n\n      </span><span class="s1">var index = list.indexOf(node);</span><span class="s3">\n      </span><span class="s1">if (index &gt;= 0) {</span><span class="s3">\n        </span><span class="s1">list.splice(index, 1);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">var neighbours = node.getNeighborsList();</span><span class="s3">\n\n      </span><span class="s1">neighbours.forEach(function (neighbour) {</span><span class="s3">\n        </span><span class="s1">if (removedNodes.indexOf(neighbour) &lt; 0) {</span><span class="s3">\n          </span><span class="s1">var otherDegree = remainingDegrees.get(neighbour);</span><span class="s3">\n          </span><span class="s1">var newDegree = otherDegree - 1;</span><span class="s3">\n\n          </span><span class="s1">if (newDegree == 1) {</span><span class="s3">\n            </span><span class="s1">tempList.push(neighbour);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n\n          </span><span class="s1">remainingDegrees.set(neighbour, newDegree);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">removedNodes = removedNodes.concat(tempList);</span><span class="s3">\n\n    </span><span class="s1">if (list.length == 1 || list.length == 2) {</span><span class="s3">\n      </span><span class="s1">foundCenter = true;</span><span class="s3">\n      </span><span class="s1">centerNode = list[0];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return centerNode;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\r\n </span><span class="s1">* During the coarsening process, this layout may be referenced by two graph managers</span><span class="s3">\r\n </span><span class="s1">* this setter function grants access to change the currently being used graph manager</span><span class="s3">\r\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Layout.prototype.setGraphManager = function (gm) {</span><span class="s3">\n  </span><span class="s1">this.graphManager = gm;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Layout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 16 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function RandomSeed() {}</span><span class="s3">\n</span><span class="s1">// adapted from: https://stackoverflow.com/a/19303725</span><span class="s3">\n</span><span class="s1">RandomSeed.seed = 1;</span><span class="s3">\n</span><span class="s1">RandomSeed.x = 0;</span><span class="s3">\n\n</span><span class="s1">RandomSeed.nextDouble = function () {</span><span class="s3">\n  </span><span class="s1">RandomSeed.x = Math.sin(RandomSeed.seed++) * 10000;</span><span class="s3">\n  </span><span class="s1">return RandomSeed.x - Math.floor(RandomSeed.x);</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = RandomSeed;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 17 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var PointD = __webpack_require__(5);</span><span class="s3">\n\n</span><span class="s1">function Transform(x, y) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgX = 0.0;</span><span class="s3">\n  </span><span class="s1">this.lworldOrgY = 0.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgX = 0.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgY = 0.0;</span><span class="s3">\n  </span><span class="s1">this.lworldExtX = 1.0;</span><span class="s3">\n  </span><span class="s1">this.lworldExtY = 1.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtX = 1.0;</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtY = 1.0;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldOrgX = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldOrgX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldOrgX = function (wox) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgX = wox;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldOrgY = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldOrgY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldOrgY = function (woy) {</span><span class="s3">\n  </span><span class="s1">this.lworldOrgY = woy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldExtX = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldExtX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldExtX = function (wex) {</span><span class="s3">\n  </span><span class="s1">this.lworldExtX = wex;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getWorldExtY = function () {</span><span class="s3">\n  </span><span class="s1">return this.lworldExtY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setWorldExtY = function (wey) {</span><span class="s3">\n  </span><span class="s1">this.lworldExtY = wey;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/* Device related */</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceOrgX = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceOrgX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceOrgX = function (dox) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgX = dox;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceOrgY = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceOrgY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceOrgY = function (doy) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceOrgY = doy;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceExtX = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceExtX;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceExtX = function (dex) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtX = dex;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.getDeviceExtY = function () {</span><span class="s3">\n  </span><span class="s1">return this.ldeviceExtY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.setDeviceExtY = function (dey) {</span><span class="s3">\n  </span><span class="s1">this.ldeviceExtY = dey;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.transformX = function (x) {</span><span class="s3">\n  </span><span class="s1">var xDevice = 0.0;</span><span class="s3">\n  </span><span class="s1">var worldExtX = this.lworldExtX;</span><span class="s3">\n  </span><span class="s1">if (worldExtX != 0.0) {</span><span class="s3">\n    </span><span class="s1">xDevice = this.ldeviceOrgX + (x - this.lworldOrgX) * this.ldeviceExtX / worldExtX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return xDevice;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.transformY = function (y) {</span><span class="s3">\n  </span><span class="s1">var yDevice = 0.0;</span><span class="s3">\n  </span><span class="s1">var worldExtY = this.lworldExtY;</span><span class="s3">\n  </span><span class="s1">if (worldExtY != 0.0) {</span><span class="s3">\n    </span><span class="s1">yDevice = this.ldeviceOrgY + (y - this.lworldOrgY) * this.ldeviceExtY / worldExtY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return yDevice;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformX = function (x) {</span><span class="s3">\n  </span><span class="s1">var xWorld = 0.0;</span><span class="s3">\n  </span><span class="s1">var deviceExtX = this.ldeviceExtX;</span><span class="s3">\n  </span><span class="s1">if (deviceExtX != 0.0) {</span><span class="s3">\n    </span><span class="s1">xWorld = this.lworldOrgX + (x - this.ldeviceOrgX) * this.lworldExtX / deviceExtX;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return xWorld;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformY = function (y) {</span><span class="s3">\n  </span><span class="s1">var yWorld = 0.0;</span><span class="s3">\n  </span><span class="s1">var deviceExtY = this.ldeviceExtY;</span><span class="s3">\n  </span><span class="s1">if (deviceExtY != 0.0) {</span><span class="s3">\n    </span><span class="s1">yWorld = this.lworldOrgY + (y - this.ldeviceOrgY) * this.lworldExtY / deviceExtY;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return yWorld;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">Transform.prototype.inverseTransformPoint = function (inPoint) {</span><span class="s3">\n  </span><span class="s1">var outPoint = new PointD(this.inverseTransformX(inPoint.x), this.inverseTransformY(inPoint.y));</span><span class="s3">\n  </span><span class="s1">return outPoint;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Transform;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 18 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i &lt; arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }</span><span class="s3">\n\n</span><span class="s1">var Layout = __webpack_require__(15);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">var LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">var IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">var IMath = __webpack_require__(9);</span><span class="s3">\n\n</span><span class="s1">function FDLayout() {</span><span class="s3">\n  </span><span class="s1">Layout.call(this);</span><span class="s3">\n\n  </span><span class="s1">this.useSmartIdealEdgeLengthCalculation = FDLayoutConstants.DEFAULT_USE_SMART_IDEAL_EDGE_LENGTH_CALCULATION;</span><span class="s3">\n  </span><span class="s1">this.gravityConstant = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.compoundGravityConstant = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH;</span><span class="s3">\n  </span><span class="s1">this.gravityRangeFactor = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n  </span><span class="s1">this.compoundGravityRangeFactor = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR;</span><span class="s3">\n  </span><span class="s1">this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;</span><span class="s3">\n  </span><span class="s1">this.coolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">this.initialCoolingFactor = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">this.totalDisplacement = 0.0;</span><span class="s3">\n  </span><span class="s1">this.oldTotalDisplacement = 0.0;</span><span class="s3">\n  </span><span class="s1">this.maxIterations = FDLayoutConstants.MAX_ITERATIONS;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype = Object.create(Layout.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in Layout) {</span><span class="s3">\n  </span><span class="s1">FDLayout[prop] = Layout[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.initParameters = function () {</span><span class="s3">\n  </span><span class="s1">Layout.prototype.initParameters.call(this, arguments);</span><span class="s3">\n\n  </span><span class="s1">this.totalIterations = 0;</span><span class="s3">\n  </span><span class="s1">this.notAnimatedIterations = 0;</span><span class="s3">\n\n  </span><span class="s1">this.useFRGridVariant = FDLayoutConstants.DEFAULT_USE_SMART_REPULSION_RANGE_CALCULATION;</span><span class="s3">\n\n  </span><span class="s1">this.grid = [];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcIdealEdgeLengths = function () {</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n  </span><span class="s1">var originalIdealLength;</span><span class="s3">\n  </span><span class="s1">var lcaDepth;</span><span class="s3">\n  </span><span class="s1">var source;</span><span class="s3">\n  </span><span class="s1">var target;</span><span class="s3">\n  </span><span class="s1">var sizeOfSourceInLca;</span><span class="s3">\n  </span><span class="s1">var sizeOfTargetInLca;</span><span class="s3">\n\n  </span><span class="s1">var allEdges = this.getGraphManager().getAllEdges();</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; allEdges.length; i++) {</span><span class="s3">\n    </span><span class="s1">edge = allEdges[i];</span><span class="s3">\n\n    </span><span class="s1">originalIdealLength = edge.idealLength;</span><span class="s3">\n\n    </span><span class="s1">if (edge.isInterGraph) {</span><span class="s3">\n      </span><span class="s1">source = edge.getSource();</span><span class="s3">\n      </span><span class="s1">target = edge.getTarget();</span><span class="s3">\n\n      </span><span class="s1">sizeOfSourceInLca = edge.getSourceInLca().getEstimatedSize();</span><span class="s3">\n      </span><span class="s1">sizeOfTargetInLca = edge.getTargetInLca().getEstimatedSize();</span><span class="s3">\n\n      </span><span class="s1">if (this.useSmartIdealEdgeLengthCalculation) {</span><span class="s3">\n        </span><span class="s1">edge.idealLength += sizeOfSourceInLca + sizeOfTargetInLca - 2 * LayoutConstants.SIMPLE_NODE_SIZE;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">lcaDepth = edge.getLca().getInclusionTreeDepth();</span><span class="s3">\n\n      </span><span class="s1">edge.idealLength += originalIdealLength * FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR * (source.getInclusionTreeDepth() + target.getInclusionTreeDepth() - 2 * lcaDepth);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.initSpringEmbedder = function () {</span><span class="s3">\n\n  </span><span class="s1">var s = this.getAllNodes().length;</span><span class="s3">\n  </span><span class="s1">if (this.incremental) {</span><span class="s3">\n    </span><span class="s1">if (s &gt; FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = Math.max(this.coolingFactor * FDLayoutConstants.COOLING_ADAPTATION_FACTOR, this.coolingFactor - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * this.coolingFactor * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT_INCREMENTAL;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (s &gt; FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = Math.max(FDLayoutConstants.COOLING_ADAPTATION_FACTOR, 1.0 - (s - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) / (FDLayoutConstants.ADAPTATION_UPPER_NODE_LIMIT - FDLayoutConstants.ADAPTATION_LOWER_NODE_LIMIT) * (1 - FDLayoutConstants.COOLING_ADAPTATION_FACTOR));</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.coolingFactor = 1.0;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">this.initialCoolingFactor = this.coolingFactor;</span><span class="s3">\n    </span><span class="s1">this.maxNodeDisplacement = FDLayoutConstants.MAX_NODE_DISPLACEMENT;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">this.maxIterations = Math.max(this.getAllNodes().length * 5, this.maxIterations);</span><span class="s3">\n\n  </span><span class="s1">// Reassign this attribute by using new constant value</span><span class="s3">\n  </span><span class="s1">this.displacementThresholdPerNode = 3.0 * FDLayoutConstants.DEFAULT_EDGE_LENGTH / 100;</span><span class="s3">\n  </span><span class="s1">this.totalDisplacementThreshold = this.displacementThresholdPerNode * this.getAllNodes().length;</span><span class="s3">\n\n  </span><span class="s1">this.repulsionRange = this.calcRepulsionRange();</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcSpringForces = function () {</span><span class="s3">\n  </span><span class="s1">var lEdges = this.getAllEdges();</span><span class="s3">\n  </span><span class="s1">var edge;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lEdges.length; i++) {</span><span class="s3">\n    </span><span class="s1">edge = lEdges[i];</span><span class="s3">\n\n    </span><span class="s1">this.calcSpringForce(edge, edge.idealLength);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionForces = function () {</span><span class="s3">\n  </span><span class="s1">var gridUpdateAllowed = arguments.length &gt; 0 &amp;&amp; arguments[0] !== undefined ? arguments[0] : true;</span><span class="s3">\n  </span><span class="s1">var forceToNodeSurroundingUpdate = arguments.length &gt; 1 &amp;&amp; arguments[1] !== undefined ? arguments[1] : false;</span><span class="s3">\n\n  </span><span class="s1">var i, j;</span><span class="s3">\n  </span><span class="s1">var nodeA, nodeB;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var processedNodeSet;</span><span class="s3">\n\n  </span><span class="s1">if (this.useFRGridVariant) {</span><span class="s3">\n    </span><span class="s1">if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 &amp;&amp; gridUpdateAllowed) {</span><span class="s3">\n      </span><span class="s1">this.updateGrid();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">processedNodeSet = new Set();</span><span class="s3">\n\n    </span><span class="s1">// calculate repulsion forces between each nodes and its surrounding</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n      </span><span class="s1">this.calculateRepulsionForceOfANode(nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate);</span><span class="s3">\n      </span><span class="s1">processedNodeSet.add(nodeA);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n      </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n\n      </span><span class="s1">for (j = i + 1; j &lt; lNodes.length; j++) {</span><span class="s3">\n        </span><span class="s1">nodeB = lNodes[j];</span><span class="s3">\n\n        </span><span class="s1">// If both nodes are not members of the same graph, skip.</span><span class="s3">\n        </span><span class="s1">if (nodeA.getOwner() != nodeB.getOwner()) {</span><span class="s3">\n          </span><span class="s1">continue;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">this.calcRepulsionForce(nodeA, nodeB);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGravitationalForces = function () {</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodesToApplyGravitation();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">this.calcGravitationalForce(node);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.moveNodes = function () {</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = lNodes[i];</span><span class="s3">\n    </span><span class="s1">node.move();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcSpringForce = function (edge, idealLength) {</span><span class="s3">\n  </span><span class="s1">var sourceNode = edge.getSource();</span><span class="s3">\n  </span><span class="s1">var targetNode = edge.getTarget();</span><span class="s3">\n\n  </span><span class="s1">var length;</span><span class="s3">\n  </span><span class="s1">var springForce;</span><span class="s3">\n  </span><span class="s1">var springForceX;</span><span class="s3">\n  </span><span class="s1">var springForceY;</span><span class="s3">\n\n  </span><span class="s1">// Update edge length</span><span class="s3">\n  </span><span class="s1">if (this.uniformLeafNodeSizes &amp;&amp; sourceNode.getChild() == null &amp;&amp; targetNode.getChild() == null) {</span><span class="s3">\n    </span><span class="s1">edge.updateLengthSimple();</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">edge.updateLength();</span><span class="s3">\n\n    </span><span class="s1">if (edge.isOverlapingSourceAndTarget) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">length = edge.getLength();</span><span class="s3">\n\n  </span><span class="s1">if (length == 0) return;</span><span class="s3">\n\n  </span><span class="s1">// Calculate spring forces</span><span class="s3">\n  </span><span class="s1">springForce = edge.edgeElasticity * (length - idealLength);</span><span class="s3">\n\n  </span><span class="s1">// Project force onto x and y axes</span><span class="s3">\n  </span><span class="s1">springForceX = springForce * (edge.lengthX / length);</span><span class="s3">\n  </span><span class="s1">springForceY = springForce * (edge.lengthY / length);</span><span class="s3">\n\n  </span><span class="s1">// Apply forces on the end nodes</span><span class="s3">\n  </span><span class="s1">sourceNode.springForceX += springForceX;</span><span class="s3">\n  </span><span class="s1">sourceNode.springForceY += springForceY;</span><span class="s3">\n  </span><span class="s1">targetNode.springForceX -= springForceX;</span><span class="s3">\n  </span><span class="s1">targetNode.springForceY -= springForceY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionForce = function (nodeA, nodeB) {</span><span class="s3">\n  </span><span class="s1">var rectA = nodeA.getRect();</span><span class="s3">\n  </span><span class="s1">var rectB = nodeB.getRect();</span><span class="s3">\n  </span><span class="s1">var overlapAmount = new Array(2);</span><span class="s3">\n  </span><span class="s1">var clipPoints = new Array(4);</span><span class="s3">\n  </span><span class="s1">var distanceX;</span><span class="s3">\n  </span><span class="s1">var distanceY;</span><span class="s3">\n  </span><span class="s1">var distanceSquared;</span><span class="s3">\n  </span><span class="s1">var distance;</span><span class="s3">\n  </span><span class="s1">var repulsionForce;</span><span class="s3">\n  </span><span class="s1">var repulsionForceX;</span><span class="s3">\n  </span><span class="s1">var repulsionForceY;</span><span class="s3">\n\n  </span><span class="s1">if (rectA.intersects(rectB)) // two nodes overlap</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">// calculate separation amount in x and y directions</span><span class="s3">\n      </span><span class="s1">IGeometry.calcSeparationAmount(rectA, rectB, overlapAmount, FDLayoutConstants.DEFAULT_EDGE_LENGTH / 2.0);</span><span class="s3">\n\n      </span><span class="s1">repulsionForceX = 2 * overlapAmount[0];</span><span class="s3">\n      </span><span class="s1">repulsionForceY = 2 * overlapAmount[1];</span><span class="s3">\n\n      </span><span class="s1">var childrenConstant = nodeA.noOfChildren * nodeB.noOfChildren / (nodeA.noOfChildren + nodeB.noOfChildren);</span><span class="s3">\n\n      </span><span class="s1">// Apply forces on the two nodes</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceX -= childrenConstant * repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceY -= childrenConstant * repulsionForceY;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceX += childrenConstant * repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceY += childrenConstant * repulsionForceY;</span><span class="s3">\n    </span><span class="s1">} else // no overlap</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">// calculate distance</span><span class="s3">\n\n      </span><span class="s1">if (this.uniformLeafNodeSizes &amp;&amp; nodeA.getChild() == null &amp;&amp; nodeB.getChild() == null) // simply base repulsion on distance of node centers</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">distanceX = rectB.getCenterX() - rectA.getCenterX();</span><span class="s3">\n          </span><span class="s1">distanceY = rectB.getCenterY() - rectA.getCenterY();</span><span class="s3">\n        </span><span class="s1">} else // use clipping points</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">IGeometry.getIntersection(rectA, rectB, clipPoints);</span><span class="s3">\n\n          </span><span class="s1">distanceX = clipPoints[2] - clipPoints[0];</span><span class="s3">\n          </span><span class="s1">distanceY = clipPoints[3] - clipPoints[1];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">// No repulsion range. FR grid variant should take care of this.</span><span class="s3">\n      </span><span class="s1">if (Math.abs(distanceX) &lt; FDLayoutConstants.MIN_REPULSION_DIST) {</span><span class="s3">\n        </span><span class="s1">distanceX = IMath.sign(distanceX) * FDLayoutConstants.MIN_REPULSION_DIST;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">if (Math.abs(distanceY) &lt; FDLayoutConstants.MIN_REPULSION_DIST) {</span><span class="s3">\n        </span><span class="s1">distanceY = IMath.sign(distanceY) * FDLayoutConstants.MIN_REPULSION_DIST;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n\n      </span><span class="s1">distanceSquared = distanceX * distanceX + distanceY * distanceY;</span><span class="s3">\n      </span><span class="s1">distance = Math.sqrt(distanceSquared);</span><span class="s3">\n\n      </span><span class="s1">// Here we use half of the nodes' repulsion values for backward compatibility</span><span class="s3">\n      </span><span class="s1">repulsionForce = (nodeA.nodeRepulsion / 2 + nodeB.nodeRepulsion / 2) * nodeA.noOfChildren * nodeB.noOfChildren / distanceSquared;</span><span class="s3">\n\n      </span><span class="s1">// Project force onto x and y axes</span><span class="s3">\n      </span><span class="s1">repulsionForceX = repulsionForce * distanceX / distance;</span><span class="s3">\n      </span><span class="s1">repulsionForceY = repulsionForce * distanceY / distance;</span><span class="s3">\n\n      </span><span class="s1">// Apply forces on the two nodes    </span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceX -= repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeA.repulsionForceY -= repulsionForceY;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceX += repulsionForceX;</span><span class="s3">\n      </span><span class="s1">nodeB.repulsionForceY += repulsionForceY;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGravitationalForce = function (node) {</span><span class="s3">\n  </span><span class="s1">var ownerGraph;</span><span class="s3">\n  </span><span class="s1">var ownerCenterX;</span><span class="s3">\n  </span><span class="s1">var ownerCenterY;</span><span class="s3">\n  </span><span class="s1">var distanceX;</span><span class="s3">\n  </span><span class="s1">var distanceY;</span><span class="s3">\n  </span><span class="s1">var absDistanceX;</span><span class="s3">\n  </span><span class="s1">var absDistanceY;</span><span class="s3">\n  </span><span class="s1">var estimatedSize;</span><span class="s3">\n  </span><span class="s1">ownerGraph = node.getOwner();</span><span class="s3">\n\n  </span><span class="s1">ownerCenterX = (ownerGraph.getRight() + ownerGraph.getLeft()) / 2;</span><span class="s3">\n  </span><span class="s1">ownerCenterY = (ownerGraph.getTop() + ownerGraph.getBottom()) / 2;</span><span class="s3">\n  </span><span class="s1">distanceX = node.getCenterX() - ownerCenterX;</span><span class="s3">\n  </span><span class="s1">distanceY = node.getCenterY() - ownerCenterY;</span><span class="s3">\n  </span><span class="s1">absDistanceX = Math.abs(distanceX) + node.getWidth() / 2;</span><span class="s3">\n  </span><span class="s1">absDistanceY = Math.abs(distanceY) + node.getHeight() / 2;</span><span class="s3">\n\n  </span><span class="s1">if (node.getOwner() == this.graphManager.getRoot()) // in the root graph</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">estimatedSize = ownerGraph.getEstimatedSize() * this.gravityRangeFactor;</span><span class="s3">\n\n      </span><span class="s1">if (absDistanceX &gt; estimatedSize || absDistanceY &gt; estimatedSize) {</span><span class="s3">\n        </span><span class="s1">node.gravitationForceX = -this.gravityConstant * distanceX;</span><span class="s3">\n        </span><span class="s1">node.gravitationForceY = -this.gravityConstant * distanceY;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">} else // inside a compound</span><span class="s3">\n    </span><span class="s1">{</span><span class="s3">\n      </span><span class="s1">estimatedSize = ownerGraph.getEstimatedSize() * this.compoundGravityRangeFactor;</span><span class="s3">\n\n      </span><span class="s1">if (absDistanceX &gt; estimatedSize || absDistanceY &gt; estimatedSize) {</span><span class="s3">\n        </span><span class="s1">node.gravitationForceX = -this.gravityConstant * distanceX * this.compoundGravityConstant;</span><span class="s3">\n        </span><span class="s1">node.gravitationForceY = -this.gravityConstant * distanceY * this.compoundGravityConstant;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.isConverged = function () {</span><span class="s3">\n  </span><span class="s1">var converged;</span><span class="s3">\n  </span><span class="s1">var oscilating = false;</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations &gt; this.maxIterations / 3) {</span><span class="s3">\n    </span><span class="s1">oscilating = Math.abs(this.totalDisplacement - this.oldTotalDisplacement) &lt; 2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">converged = this.totalDisplacement &lt; this.totalDisplacementThreshold;</span><span class="s3">\n\n  </span><span class="s1">this.oldTotalDisplacement = this.totalDisplacement;</span><span class="s3">\n\n  </span><span class="s1">return converged || oscilating;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.animate = function () {</span><span class="s3">\n  </span><span class="s1">if (this.animationDuringLayout &amp;&amp; !this.isSubLayout) {</span><span class="s3">\n    </span><span class="s1">if (this.notAnimatedIterations == this.animationPeriod) {</span><span class="s3">\n      </span><span class="s1">this.update();</span><span class="s3">\n      </span><span class="s1">this.notAnimatedIterations = 0;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">this.notAnimatedIterations++;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//This method calculates the number of children (weight) for all nodes</span><span class="s3">\n</span><span class="s1">FDLayout.prototype.calcNoOfChildrenForAllNodes = function () {</span><span class="s3">\n  </span><span class="s1">var node;</span><span class="s3">\n  </span><span class="s1">var allNodes = this.graphManager.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; allNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">node = allNodes[i];</span><span class="s3">\n    </span><span class="s1">node.noOfChildren = node.getNoOfChildren();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n</span><span class="s1">// Section: FR-Grid Variant Repulsion Force Calculation</span><span class="s3">\n</span><span class="s1">// -----------------------------------------------------------------------------</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcGrid = function (graph) {</span><span class="s3">\n\n  </span><span class="s1">var sizeX = 0;</span><span class="s3">\n  </span><span class="s1">var sizeY = 0;</span><span class="s3">\n\n  </span><span class="s1">sizeX = parseInt(Math.ceil((graph.getRight() - graph.getLeft()) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">sizeY = parseInt(Math.ceil((graph.getBottom() - graph.getTop()) / this.repulsionRange));</span><span class="s3">\n\n  </span><span class="s1">var grid = new Array(sizeX);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; sizeX; i++) {</span><span class="s3">\n    </span><span class="s1">grid[i] = new Array(sizeY);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; sizeX; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; sizeY; j++) {</span><span class="s3">\n      </span><span class="s1">grid[i][j] = new Array();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return grid;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.addNodeToGrid = function (v, left, top) {</span><span class="s3">\n\n  </span><span class="s1">var startX = 0;</span><span class="s3">\n  </span><span class="s1">var finishX = 0;</span><span class="s3">\n  </span><span class="s1">var startY = 0;</span><span class="s3">\n  </span><span class="s1">var finishY = 0;</span><span class="s3">\n\n  </span><span class="s1">startX = parseInt(Math.floor((v.getRect().x - left) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">finishX = parseInt(Math.floor((v.getRect().width + v.getRect().x - left) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">startY = parseInt(Math.floor((v.getRect().y - top) / this.repulsionRange));</span><span class="s3">\n  </span><span class="s1">finishY = parseInt(Math.floor((v.getRect().height + v.getRect().y - top) / this.repulsionRange));</span><span class="s3">\n\n  </span><span class="s1">for (var i = startX; i &lt;= finishX; i++) {</span><span class="s3">\n    </span><span class="s1">for (var j = startY; j &lt;= finishY; j++) {</span><span class="s3">\n      </span><span class="s1">this.grid[i][j].push(v);</span><span class="s3">\n      </span><span class="s1">v.setGridCoordinates(startX, finishX, startY, finishY);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.updateGrid = function () {</span><span class="s3">\n  </span><span class="s1">var i;</span><span class="s3">\n  </span><span class="s1">var nodeA;</span><span class="s3">\n  </span><span class="s1">var lNodes = this.getAllNodes();</span><span class="s3">\n\n  </span><span class="s1">this.grid = this.calcGrid(this.graphManager.getRoot());</span><span class="s3">\n\n  </span><span class="s1">// put all nodes to proper grid cells</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; lNodes.length; i++) {</span><span class="s3">\n    </span><span class="s1">nodeA = lNodes[i];</span><span class="s3">\n    </span><span class="s1">this.addNodeToGrid(nodeA, this.graphManager.getRoot().getLeft(), this.graphManager.getRoot().getTop());</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calculateRepulsionForceOfANode = function (nodeA, processedNodeSet, gridUpdateAllowed, forceToNodeSurroundingUpdate) {</span><span class="s3">\n\n  </span><span class="s1">if (this.totalIterations % FDLayoutConstants.GRID_CALCULATION_CHECK_PERIOD == 1 &amp;&amp; gridUpdateAllowed || forceToNodeSurroundingUpdate) {</span><span class="s3">\n    </span><span class="s1">var surrounding = new Set();</span><span class="s3">\n    </span><span class="s1">nodeA.surrounding = new Array();</span><span class="s3">\n    </span><span class="s1">var nodeB;</span><span class="s3">\n    </span><span class="s1">var grid = this.grid;</span><span class="s3">\n\n    </span><span class="s1">for (var i = nodeA.startX - 1; i &lt; nodeA.finishX + 2; i++) {</span><span class="s3">\n      </span><span class="s1">for (var j = nodeA.startY - 1; j &lt; nodeA.finishY + 2; j++) {</span><span class="s3">\n        </span><span class="s1">if (!(i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length)) {</span><span class="s3">\n          </span><span class="s1">for (var k = 0; k &lt; grid[i][j].length; k++) {</span><span class="s3">\n            </span><span class="s1">nodeB = grid[i][j][k];</span><span class="s3">\n\n            </span><span class="s1">// If both nodes are not members of the same graph, </span><span class="s3">\n            </span><span class="s1">// or both nodes are the same, skip.</span><span class="s3">\n            </span><span class="s1">if (nodeA.getOwner() != nodeB.getOwner() || nodeA == nodeB) {</span><span class="s3">\n              </span><span class="s1">continue;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// check if the repulsion force between</span><span class="s3">\n            </span><span class="s1">// nodeA and nodeB has already been calculated</span><span class="s3">\n            </span><span class="s1">if (!processedNodeSet.has(nodeB) &amp;&amp; !surrounding.has(nodeB)) {</span><span class="s3">\n              </span><span class="s1">var distanceX = Math.abs(nodeA.getCenterX() - nodeB.getCenterX()) - (nodeA.getWidth() / 2 + nodeB.getWidth() / 2);</span><span class="s3">\n              </span><span class="s1">var distanceY = Math.abs(nodeA.getCenterY() - nodeB.getCenterY()) - (nodeA.getHeight() / 2 + nodeB.getHeight() / 2);</span><span class="s3">\n\n              </span><span class="s1">// if the distance between nodeA and nodeB </span><span class="s3">\n              </span><span class="s1">// is less then calculation range</span><span class="s3">\n              </span><span class="s1">if (distanceX &lt;= this.repulsionRange &amp;&amp; distanceY &lt;= this.repulsionRange) {</span><span class="s3">\n                </span><span class="s1">//then add nodeB to surrounding of nodeA</span><span class="s3">\n                </span><span class="s1">surrounding.add(nodeB);</span><span class="s3">\n              </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">nodeA.surrounding = [].concat(_toConsumableArray(surrounding));</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">for (i = 0; i &lt; nodeA.surrounding.length; i++) {</span><span class="s3">\n    </span><span class="s1">this.calcRepulsionForce(nodeA, nodeA.surrounding[i]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">FDLayout.prototype.calcRepulsionRange = function () {</span><span class="s3">\n  </span><span class="s1">return 0.0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayout;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 19 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(4);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutEdge(source, target, vEdge) {</span><span class="s3">\n  </span><span class="s1">LEdge.call(this, source, target, vEdge);</span><span class="s3">\n\n  </span><span class="s1">// Ideal length and elasticity value for this edge</span><span class="s3">\n  </span><span class="s1">this.idealLength = FDLayoutConstants.DEFAULT_EDGE_LENGTH;</span><span class="s3">\n  </span><span class="s1">this.edgeElasticity = FDLayoutConstants.DEFAULT_SPRING_STRENGTH;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutEdge.prototype = Object.create(LEdge.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LEdge) {</span><span class="s3">\n  </span><span class="s1">FDLayoutEdge[prop] = LEdge[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutEdge;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 20 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">var FDLayoutConstants = __webpack_require__(4);</span><span class="s3">\n\n</span><span class="s1">function FDLayoutNode(gm, loc, size, vNode) {</span><span class="s3">\n  </span><span class="s1">// alternative constructor is handled inside LNode</span><span class="s3">\n  </span><span class="s1">LNode.call(this, gm, loc, size, vNode);</span><span class="s3">\n\n  </span><span class="s1">// Repulsion value of this node</span><span class="s3">\n  </span><span class="s1">this.nodeRepulsion = FDLayoutConstants.DEFAULT_REPULSION_STRENGTH;</span><span class="s3">\n\n  </span><span class="s1">//Spring, repulsion and gravitational forces acting on this node</span><span class="s3">\n  </span><span class="s1">this.springForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.springForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.repulsionForceY = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceX = 0;</span><span class="s3">\n  </span><span class="s1">this.gravitationForceY = 0;</span><span class="s3">\n  </span><span class="s1">//Amount by which this node is to be moved in this iteration</span><span class="s3">\n  </span><span class="s1">this.displacementX = 0;</span><span class="s3">\n  </span><span class="s1">this.displacementY = 0;</span><span class="s3">\n\n  </span><span class="s1">//Start and finish grid coordinates that this node is fallen into</span><span class="s3">\n  </span><span class="s1">this.startX = 0;</span><span class="s3">\n  </span><span class="s1">this.finishX = 0;</span><span class="s3">\n  </span><span class="s1">this.startY = 0;</span><span class="s3">\n  </span><span class="s1">this.finishY = 0;</span><span class="s3">\n\n  </span><span class="s1">//Geometric neighbors of this node</span><span class="s3">\n  </span><span class="s1">this.surrounding = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutNode.prototype = Object.create(LNode.prototype);</span><span class="s3">\n\n</span><span class="s1">for (var prop in LNode) {</span><span class="s3">\n  </span><span class="s1">FDLayoutNode[prop] = LNode[prop];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">FDLayoutNode.prototype.setGridCoordinates = function (_startX, _finishX, _startY, _finishY) {</span><span class="s3">\n  </span><span class="s1">this.startX = _startX;</span><span class="s3">\n  </span><span class="s1">this.finishX = _finishX;</span><span class="s3">\n  </span><span class="s1">this.startY = _startY;</span><span class="s3">\n  </span><span class="s1">this.finishY = _finishY;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = FDLayoutNode;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 21 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function DimensionD(width, height) {</span><span class="s3">\n  </span><span class="s1">this.width = 0;</span><span class="s3">\n  </span><span class="s1">this.height = 0;</span><span class="s3">\n  </span><span class="s1">if (width !== null &amp;&amp; height !== null) {</span><span class="s3">\n    </span><span class="s1">this.height = height;</span><span class="s3">\n    </span><span class="s1">this.width = width;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.getWidth = function () {</span><span class="s3">\n  </span><span class="s1">return this.width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.setWidth = function (width) {</span><span class="s3">\n  </span><span class="s1">this.width = width;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.getHeight = function () {</span><span class="s3">\n  </span><span class="s1">return this.height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">DimensionD.prototype.setHeight = function (height) {</span><span class="s3">\n  </span><span class="s1">this.height = height;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = DimensionD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 22 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n\n</span><span class="s1">function HashMap() {</span><span class="s3">\n  </span><span class="s1">this.map = {};</span><span class="s3">\n  </span><span class="s1">this.keys = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.put = function (key, value) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">if (!this.contains(theId)) {</span><span class="s3">\n    </span><span class="s1">this.map[theId] = value;</span><span class="s3">\n    </span><span class="s1">this.keys.push(key);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.contains = function (key) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">return this.map[key] != null;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.get = function (key) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(key);</span><span class="s3">\n  </span><span class="s1">return this.map[theId];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashMap.prototype.keySet = function () {</span><span class="s3">\n  </span><span class="s1">return this.keys;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = HashMap;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 23 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n\n</span><span class="s1">function HashSet() {</span><span class="s3">\n  </span><span class="s1">this.set = {};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.add = function (obj) {</span><span class="s3">\n  </span><span class="s1">var theId = UniqueIDGeneretor.createID(obj);</span><span class="s3">\n  </span><span class="s1">if (!this.contains(theId)) this.set[theId] = obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.remove = function (obj) {</span><span class="s3">\n  </span><span class="s1">delete this.set[UniqueIDGeneretor.createID(obj)];</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.clear = function () {</span><span class="s3">\n  </span><span class="s1">this.set = {};</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.contains = function (obj) {</span><span class="s3">\n  </span><span class="s1">return this.set[UniqueIDGeneretor.createID(obj)] == obj;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.isEmpty = function () {</span><span class="s3">\n  </span><span class="s1">return this.size() === 0;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.size = function () {</span><span class="s3">\n  </span><span class="s1">return Object.keys(this.set).length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">//concats this.set to the given list</span><span class="s3">\n</span><span class="s1">HashSet.prototype.addAllTo = function (list) {</span><span class="s3">\n  </span><span class="s1">var keys = Object.keys(this.set);</span><span class="s3">\n  </span><span class="s1">var length = keys.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; length; i++) {</span><span class="s3">\n    </span><span class="s1">list.push(this.set[keys[i]]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.size = function () {</span><span class="s3">\n  </span><span class="s1">return Object.keys(this.set).length;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">HashSet.prototype.addAll = function (list) {</span><span class="s3">\n  </span><span class="s1">var s = list.length;</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; s; i++) {</span><span class="s3">\n    </span><span class="s1">var v = list[i];</span><span class="s3">\n    </span><span class="s1">this.add(v);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = HashSet;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 24 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">// Some matrix (1d and 2d array) operations</span><span class="s3">\n</span><span class="s1">function Matrix() {}</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* matrix multiplication</span><span class="s3">\n </span><span class="s1">* array1, array2 and result are 2d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.multMat = function (array1, array2) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array1.length; i++) {</span><span class="s3">\n    </span><span class="s1">result[i] = [];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; array2[0].length; j++) {</span><span class="s3">\n      </span><span class="s1">result[i][j] = 0;</span><span class="s3">\n      </span><span class="s1">for (var k = 0; k &lt; array1[0].length; k++) {</span><span class="s3">\n        </span><span class="s1">result[i][j] += array1[i][k] * array2[k][j];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* matrix transpose</span><span class="s3">\n </span><span class="s1">* array and result are 2d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.transpose = function (array) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array[0].length; i++) {</span><span class="s3">\n    </span><span class="s1">result[i] = [];</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; array.length; j++) {</span><span class="s3">\n      </span><span class="s1">result[i][j] = array[j][i];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* multiply array with constant</span><span class="s3">\n </span><span class="s1">* array and result are 1d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.multCons = function (array, constant) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array.length; i++) {</span><span class="s3">\n    </span><span class="s1">result[i] = array[i] * constant;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* substract two arrays</span><span class="s3">\n </span><span class="s1">* array1, array2 and result are 1d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.minusOp = function (array1, array2) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array1.length; i++) {</span><span class="s3">\n    </span><span class="s1">result[i] = array1[i] - array2[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* dot product of two arrays with same size</span><span class="s3">\n </span><span class="s1">* array1 and array2 are 1d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.dotProduct = function (array1, array2) {</span><span class="s3">\n  </span><span class="s1">var product = 0;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array1.length; i++) {</span><span class="s3">\n    </span><span class="s1">product += array1[i] * array2[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return product;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* magnitude of an array</span><span class="s3">\n </span><span class="s1">* array is 1d array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.mag = function (array) {</span><span class="s3">\n  </span><span class="s1">return Math.sqrt(this.dotProduct(array, array));</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* normalization of an array</span><span class="s3">\n </span><span class="s1">* array and result are 1d array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.normalize = function (array) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n  </span><span class="s1">var magnitude = this.mag(array);</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array.length; i++) {</span><span class="s3">\n    </span><span class="s1">result[i] = array[i] / magnitude;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* multiply an array with centering matrix</span><span class="s3">\n </span><span class="s1">* array and result are 1d array</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.multGamma = function (array) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n  </span><span class="s1">var sum = 0;</span><span class="s3">\n\n  </span><span class="s1">for (var i = 0; i &lt; array.length; i++) {</span><span class="s3">\n    </span><span class="s1">sum += array[i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">sum *= -1 / array.length;</span><span class="s3">\n\n  </span><span class="s1">for (var _i = 0; _i &lt; array.length; _i++) {</span><span class="s3">\n    </span><span class="s1">result[_i] = sum + array[_i];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* a special matrix multiplication</span><span class="s3">\n </span><span class="s1">* result = 0.5 * C * INV * C^T * array</span><span class="s3">\n </span><span class="s1">* array and result are 1d, C and INV are 2d arrays</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">Matrix.multL = function (array, C, INV) {</span><span class="s3">\n  </span><span class="s1">var result = [];</span><span class="s3">\n  </span><span class="s1">var temp1 = [];</span><span class="s3">\n  </span><span class="s1">var temp2 = [];</span><span class="s3">\n\n  </span><span class="s1">// multiply by C^T</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; C[0].length; i++) {</span><span class="s3">\n    </span><span class="s1">var sum = 0;</span><span class="s3">\n    </span><span class="s1">for (var j = 0; j &lt; C.length; j++) {</span><span class="s3">\n      </span><span class="s1">sum += -0.5 * C[j][i] * array[j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">temp1[i] = sum;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// multiply the result by INV</span><span class="s3">\n  </span><span class="s1">for (var _i2 = 0; _i2 &lt; INV.length; _i2++) {</span><span class="s3">\n    </span><span class="s1">var _sum = 0;</span><span class="s3">\n    </span><span class="s1">for (var _j = 0; _j &lt; INV.length; _j++) {</span><span class="s3">\n      </span><span class="s1">_sum += INV[_i2][_j] * temp1[_j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">temp2[_i2] = _sum;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">// multiply the result by C</span><span class="s3">\n  </span><span class="s1">for (var _i3 = 0; _i3 &lt; C.length; _i3++) {</span><span class="s3">\n    </span><span class="s1">var _sum2 = 0;</span><span class="s3">\n    </span><span class="s1">for (var _j2 = 0; _j2 &lt; C[0].length; _j2++) {</span><span class="s3">\n      </span><span class="s1">_sum2 += C[_i3][_j2] * temp2[_j2];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">result[_i3] = _sum2;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Matrix;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 25 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">* A classic Quicksort algorithm with Hoare's partition</span><span class="s3">\n </span><span class="s1">* - Works also on LinkedList objects</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">* Copyright: i-Vis Research Group, Bilkent University, 2007 - present</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var LinkedList = __webpack_require__(11);</span><span class="s3">\n\n</span><span class="s1">var Quicksort = function () {</span><span class="s3">\n    </span><span class="s1">function Quicksort(A, compareFunction) {</span><span class="s3">\n        </span><span class="s1">_classCallCheck(this, Quicksort);</span><span class="s3">\n\n        </span><span class="s1">if (compareFunction !== null || compareFunction !== undefined) this.compareFunction = this._defaultCompareFunction;</span><span class="s3">\n\n        </span><span class="s1">var length = void 0;</span><span class="s3">\n        </span><span class="s1">if (A instanceof LinkedList) length = A.size();else length = A.length;</span><span class="s3">\n\n        </span><span class="s1">this._quicksort(A, 0, length - 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">_createClass(Quicksort, [{</span><span class="s3">\n        </span><span class="s1">key: '_quicksort',</span><span class="s3">\n        </span><span class="s1">value: function _quicksort(A, p, r) {</span><span class="s3">\n            </span><span class="s1">if (p &lt; r) {</span><span class="s3">\n                </span><span class="s1">var q = this._partition(A, p, r);</span><span class="s3">\n                </span><span class="s1">this._quicksort(A, p, q);</span><span class="s3">\n                </span><span class="s1">this._quicksort(A, q + 1, r);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_partition',</span><span class="s3">\n        </span><span class="s1">value: function _partition(A, p, r) {</span><span class="s3">\n            </span><span class="s1">var x = this._get(A, p);</span><span class="s3">\n            </span><span class="s1">var i = p;</span><span class="s3">\n            </span><span class="s1">var j = r;</span><span class="s3">\n            </span><span class="s1">while (true) {</span><span class="s3">\n                </span><span class="s1">while (this.compareFunction(x, this._get(A, j))) {</span><span class="s3">\n                    </span><span class="s1">j--;</span><span class="s3">\n                </span><span class="s1">}while (this.compareFunction(this._get(A, i), x)) {</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                </span><span class="s1">}if (i &lt; j) {</span><span class="s3">\n                    </span><span class="s1">this._swap(A, i, j);</span><span class="s3">\n                    </span><span class="s1">i++;</span><span class="s3">\n                    </span><span class="s1">j--;</span><span class="s3">\n                </span><span class="s1">} else return j;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_get',</span><span class="s3">\n        </span><span class="s1">value: function _get(object, index) {</span><span class="s3">\n            </span><span class="s1">if (object instanceof LinkedList) return object.get_object_at(index);else return object[index];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_set',</span><span class="s3">\n        </span><span class="s1">value: function _set(object, index, value) {</span><span class="s3">\n            </span><span class="s1">if (object instanceof LinkedList) object.set_object_at(index, value);else object[index] = value;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_swap',</span><span class="s3">\n        </span><span class="s1">value: function _swap(A, i, j) {</span><span class="s3">\n            </span><span class="s1">var temp = this._get(A, i);</span><span class="s3">\n            </span><span class="s1">this._set(A, i, this._get(A, j));</span><span class="s3">\n            </span><span class="s1">this._set(A, j, temp);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: '_defaultCompareFunction',</span><span class="s3">\n        </span><span class="s1">value: function _defaultCompareFunction(a, b) {</span><span class="s3">\n            </span><span class="s1">return b &gt; a;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}]);</span><span class="s3">\n\n    </span><span class="s1">return Quicksort;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = Quicksort;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 26 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">// Singular Value Decomposition implementation</span><span class="s3">\n</span><span class="s1">function SVD() {};</span><span class="s3">\n\n</span><span class="s1">/* Below singular value decomposition (svd) code including hypot function is adopted from https://github.com/dragonfly-ai/JamaJS</span><span class="s3">\n   </span><span class="s1">Some changes are applied to make the code compatible with the fcose code and to make it independent from Jama.</span><span class="s3">\n   </span><span class="s1">Input matrix is changed to a 2D array instead of Jama matrix. Matrix dimensions are taken according to 2D array instead of using Jama functions.</span><span class="s3">\n   </span><span class="s1">An object that includes singular value components is created for return. </span><span class="s3">\n   </span><span class="s1">The types of input parameters of the hypot function are removed. </span><span class="s3">\n   </span><span class="s1">let is used instead of var for the variable initialization.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n</span><span class="s1">/*</span><span class="s3">\n                               </span><span class="s1">Apache License</span><span class="s3">\n                           </span><span class="s1">Version 2.0, January 2004</span><span class="s3">\n                        </span><span class="s1">http://www.apache.org/licenses/</span><span class="s3">\n\n   </span><span class="s1">TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION</span><span class="s3">\n\n   </span><span class="s1">1. Definitions.</span><span class="s3">\n\n      \&quot;</span><span class="s1">License</span><span class="s3">\&quot; </span><span class="s1">shall mean the terms and conditions for use, reproduction,</span><span class="s3">\n      </span><span class="s1">and distribution as defined by Sections 1 through 9 of this document.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Licensor</span><span class="s3">\&quot; </span><span class="s1">shall mean the copyright owner or entity authorized by</span><span class="s3">\n      </span><span class="s1">the copyright owner that is granting the License.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Legal Entity</span><span class="s3">\&quot; </span><span class="s1">shall mean the union of the acting entity and all</span><span class="s3">\n      </span><span class="s1">other entities that control, are controlled by, or are under common</span><span class="s3">\n      </span><span class="s1">control with that entity. For the purposes of this definition,</span><span class="s3">\n      \&quot;</span><span class="s1">control</span><span class="s3">\&quot; </span><span class="s1">means (i) the power, direct or indirect, to cause the</span><span class="s3">\n      </span><span class="s1">direction or management of such entity, whether by contract or</span><span class="s3">\n      </span><span class="s1">otherwise, or (ii) ownership of fifty percent (50%) or more of the</span><span class="s3">\n      </span><span class="s1">outstanding shares, or (iii) beneficial ownership of such entity.</span><span class="s3">\n\n      \&quot;</span><span class="s1">You</span><span class="s3">\&quot; </span><span class="s1">(or </span><span class="s3">\&quot;</span><span class="s1">Your</span><span class="s3">\&quot;</span><span class="s1">) shall mean an individual or Legal Entity</span><span class="s3">\n      </span><span class="s1">exercising permissions granted by this License.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Source</span><span class="s3">\&quot; </span><span class="s1">form shall mean the preferred form for making modifications,</span><span class="s3">\n      </span><span class="s1">including but not limited to software source code, documentation</span><span class="s3">\n      </span><span class="s1">source, and configuration files.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Object</span><span class="s3">\&quot; </span><span class="s1">form shall mean any form resulting from mechanical</span><span class="s3">\n      </span><span class="s1">transformation or translation of a Source form, including but</span><span class="s3">\n      </span><span class="s1">not limited to compiled object code, generated documentation,</span><span class="s3">\n      </span><span class="s1">and conversions to other media types.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Work</span><span class="s3">\&quot; </span><span class="s1">shall mean the work of authorship, whether in Source or</span><span class="s3">\n      </span><span class="s1">Object form, made available under the License, as indicated by a</span><span class="s3">\n      </span><span class="s1">copyright notice that is included in or attached to the work</span><span class="s3">\n      </span><span class="s1">(an example is provided in the Appendix below).</span><span class="s3">\n\n      \&quot;</span><span class="s1">Derivative Works</span><span class="s3">\&quot; </span><span class="s1">shall mean any work, whether in Source or Object</span><span class="s3">\n      </span><span class="s1">form, that is based on (or derived from) the Work and for which the</span><span class="s3">\n      </span><span class="s1">editorial revisions, annotations, elaborations, or other modifications</span><span class="s3">\n      </span><span class="s1">represent, as a whole, an original work of authorship. For the purposes</span><span class="s3">\n      </span><span class="s1">of this License, Derivative Works shall not include works that remain</span><span class="s3">\n      </span><span class="s1">separable from, or merely link (or bind by name) to the interfaces of,</span><span class="s3">\n      </span><span class="s1">the Work and Derivative Works thereof.</span><span class="s3">\n\n      \&quot;</span><span class="s1">Contribution</span><span class="s3">\&quot; </span><span class="s1">shall mean any work of authorship, including</span><span class="s3">\n      </span><span class="s1">the original version of the Work and any modifications or additions</span><span class="s3">\n      </span><span class="s1">to that Work or Derivative Works thereof, that is intentionally</span><span class="s3">\n      </span><span class="s1">submitted to Licensor for inclusion in the Work by the copyright owner</span><span class="s3">\n      </span><span class="s1">or by an individual or Legal Entity authorized to submit on behalf of</span><span class="s3">\n      </span><span class="s1">the copyright owner. For the purposes of this definition, </span><span class="s3">\&quot;</span><span class="s1">submitted</span><span class="s3">\&quot;\n      </span><span class="s1">means any form of electronic, verbal, or written communication sent</span><span class="s3">\n      </span><span class="s1">to the Licensor or its representatives, including but not limited to</span><span class="s3">\n      </span><span class="s1">communication on electronic mailing lists, source code control systems,</span><span class="s3">\n      </span><span class="s1">and issue tracking systems that are managed by, or on behalf of, the</span><span class="s3">\n      </span><span class="s1">Licensor for the purpose of discussing and improving the Work, but</span><span class="s3">\n      </span><span class="s1">excluding communication that is conspicuously marked or otherwise</span><span class="s3">\n      </span><span class="s1">designated in writing by the copyright owner as </span><span class="s3">\&quot;</span><span class="s1">Not a Contribution.</span><span class="s3">\&quot;\n\n      \&quot;</span><span class="s1">Contributor</span><span class="s3">\&quot; </span><span class="s1">shall mean Licensor and any individual or Legal Entity</span><span class="s3">\n      </span><span class="s1">on behalf of whom a Contribution has been received by Licensor and</span><span class="s3">\n      </span><span class="s1">subsequently incorporated within the Work.</span><span class="s3">\n\n   </span><span class="s1">2. Grant of Copyright License. Subject to the terms and conditions of</span><span class="s3">\n      </span><span class="s1">this License, each Contributor hereby grants to You a perpetual,</span><span class="s3">\n      </span><span class="s1">worldwide, non-exclusive, no-charge, royalty-free, irrevocable</span><span class="s3">\n      </span><span class="s1">copyright license to reproduce, prepare Derivative Works of,</span><span class="s3">\n      </span><span class="s1">publicly display, publicly perform, sublicense, and distribute the</span><span class="s3">\n      </span><span class="s1">Work and such Derivative Works in Source or Object form.</span><span class="s3">\n\n   </span><span class="s1">3. Grant of Patent License. Subject to the terms and conditions of</span><span class="s3">\n      </span><span class="s1">this License, each Contributor hereby grants to You a perpetual,</span><span class="s3">\n      </span><span class="s1">worldwide, non-exclusive, no-charge, royalty-free, irrevocable</span><span class="s3">\n      </span><span class="s1">(except as stated in this section) patent license to make, have made,</span><span class="s3">\n      </span><span class="s1">use, offer to sell, sell, import, and otherwise transfer the Work,</span><span class="s3">\n      </span><span class="s1">where such license applies only to those patent claims licensable</span><span class="s3">\n      </span><span class="s1">by such Contributor that are necessarily infringed by their</span><span class="s3">\n      </span><span class="s1">Contribution(s) alone or by combination of their Contribution(s)</span><span class="s3">\n      </span><span class="s1">with the Work to which such Contribution(s) was submitted. If You</span><span class="s3">\n      </span><span class="s1">institute patent litigation against any entity (including a</span><span class="s3">\n      </span><span class="s1">cross-claim or counterclaim in a lawsuit) alleging that the Work</span><span class="s3">\n      </span><span class="s1">or a Contribution incorporated within the Work constitutes direct</span><span class="s3">\n      </span><span class="s1">or contributory patent infringement, then any patent licenses</span><span class="s3">\n      </span><span class="s1">granted to You under this License for that Work shall terminate</span><span class="s3">\n      </span><span class="s1">as of the date such litigation is filed.</span><span class="s3">\n\n   </span><span class="s1">4. Redistribution. You may reproduce and distribute copies of the</span><span class="s3">\n      </span><span class="s1">Work or Derivative Works thereof in any medium, with or without</span><span class="s3">\n      </span><span class="s1">modifications, and in Source or Object form, provided that You</span><span class="s3">\n      </span><span class="s1">meet the following conditions:</span><span class="s3">\n\n      </span><span class="s1">(a) You must give any other recipients of the Work or</span><span class="s3">\n          </span><span class="s1">Derivative Works a copy of this License; and</span><span class="s3">\n\n      </span><span class="s1">(b) You must cause any modified files to carry prominent notices</span><span class="s3">\n          </span><span class="s1">stating that You changed the files; and</span><span class="s3">\n\n      </span><span class="s1">(c) You must retain, in the Source form of any Derivative Works</span><span class="s3">\n          </span><span class="s1">that You distribute, all copyright, patent, trademark, and</span><span class="s3">\n          </span><span class="s1">attribution notices from the Source form of the Work,</span><span class="s3">\n          </span><span class="s1">excluding those notices that do not pertain to any part of</span><span class="s3">\n          </span><span class="s1">the Derivative Works; and</span><span class="s3">\n\n      </span><span class="s1">(d) If the Work includes a </span><span class="s3">\&quot;</span><span class="s1">NOTICE</span><span class="s3">\&quot; </span><span class="s1">text file as part of its</span><span class="s3">\n          </span><span class="s1">distribution, then any Derivative Works that You distribute must</span><span class="s3">\n          </span><span class="s1">include a readable copy of the attribution notices contained</span><span class="s3">\n          </span><span class="s1">within such NOTICE file, excluding those notices that do not</span><span class="s3">\n          </span><span class="s1">pertain to any part of the Derivative Works, in at least one</span><span class="s3">\n          </span><span class="s1">of the following places: within a NOTICE text file distributed</span><span class="s3">\n          </span><span class="s1">as part of the Derivative Works; within the Source form or</span><span class="s3">\n          </span><span class="s1">documentation, if provided along with the Derivative Works; or,</span><span class="s3">\n          </span><span class="s1">within a display generated by the Derivative Works, if and</span><span class="s3">\n          </span><span class="s1">wherever such third-party notices normally appear. The contents</span><span class="s3">\n          </span><span class="s1">of the NOTICE file are for informational purposes only and</span><span class="s3">\n          </span><span class="s1">do not modify the License. You may add Your own attribution</span><span class="s3">\n          </span><span class="s1">notices within Derivative Works that You distribute, alongside</span><span class="s3">\n          </span><span class="s1">or as an addendum to the NOTICE text from the Work, provided</span><span class="s3">\n          </span><span class="s1">that such additional attribution notices cannot be construed</span><span class="s3">\n          </span><span class="s1">as modifying the License.</span><span class="s3">\n\n      </span><span class="s1">You may add Your own copyright statement to Your modifications and</span><span class="s3">\n      </span><span class="s1">may provide additional or different license terms and conditions</span><span class="s3">\n      </span><span class="s1">for use, reproduction, or distribution of Your modifications, or</span><span class="s3">\n      </span><span class="s1">for any such Derivative Works as a whole, provided Your use,</span><span class="s3">\n      </span><span class="s1">reproduction, and distribution of the Work otherwise complies with</span><span class="s3">\n      </span><span class="s1">the conditions stated in this License.</span><span class="s3">\n\n   </span><span class="s1">5. Submission of Contributions. Unless You explicitly state otherwise,</span><span class="s3">\n      </span><span class="s1">any Contribution intentionally submitted for inclusion in the Work</span><span class="s3">\n      </span><span class="s1">by You to the Licensor shall be under the terms and conditions of</span><span class="s3">\n      </span><span class="s1">this License, without any additional terms or conditions.</span><span class="s3">\n      </span><span class="s1">Notwithstanding the above, nothing herein shall supersede or modify</span><span class="s3">\n      </span><span class="s1">the terms of any separate license agreement you may have executed</span><span class="s3">\n      </span><span class="s1">with Licensor regarding such Contributions.</span><span class="s3">\n\n   </span><span class="s1">6. Trademarks. This License does not grant permission to use the trade</span><span class="s3">\n      </span><span class="s1">names, trademarks, service marks, or product names of the Licensor,</span><span class="s3">\n      </span><span class="s1">except as required for reasonable and customary use in describing the</span><span class="s3">\n      </span><span class="s1">origin of the Work and reproducing the content of the NOTICE file.</span><span class="s3">\n\n   </span><span class="s1">7. Disclaimer of Warranty. Unless required by applicable law or</span><span class="s3">\n      </span><span class="s1">agreed to in writing, Licensor provides the Work (and each</span><span class="s3">\n      </span><span class="s1">Contributor provides its Contributions) on an </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">BASIS,</span><span class="s3">\n      </span><span class="s1">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or</span><span class="s3">\n      </span><span class="s1">implied, including, without limitation, any warranties or conditions</span><span class="s3">\n      </span><span class="s1">of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A</span><span class="s3">\n      </span><span class="s1">PARTICULAR PURPOSE. You are solely responsible for determining the</span><span class="s3">\n      </span><span class="s1">appropriateness of using or redistributing the Work and assume any</span><span class="s3">\n      </span><span class="s1">risks associated with Your exercise of permissions under this License.</span><span class="s3">\n\n   </span><span class="s1">8. Limitation of Liability. In no event and under no legal theory,</span><span class="s3">\n      </span><span class="s1">whether in tort (including negligence), contract, or otherwise,</span><span class="s3">\n      </span><span class="s1">unless required by applicable law (such as deliberate and grossly</span><span class="s3">\n      </span><span class="s1">negligent acts) or agreed to in writing, shall any Contributor be</span><span class="s3">\n      </span><span class="s1">liable to You for damages, including any direct, indirect, special,</span><span class="s3">\n      </span><span class="s1">incidental, or consequential damages of any character arising as a</span><span class="s3">\n      </span><span class="s1">result of this License or out of the use or inability to use the</span><span class="s3">\n      </span><span class="s1">Work (including but not limited to damages for loss of goodwill,</span><span class="s3">\n      </span><span class="s1">work stoppage, computer failure or malfunction, or any and all</span><span class="s3">\n      </span><span class="s1">other commercial damages or losses), even if such Contributor</span><span class="s3">\n      </span><span class="s1">has been advised of the possibility of such damages.</span><span class="s3">\n\n   </span><span class="s1">9. Accepting Warranty or Additional Liability. While redistributing</span><span class="s3">\n      </span><span class="s1">the Work or Derivative Works thereof, You may choose to offer,</span><span class="s3">\n      </span><span class="s1">and charge a fee for, acceptance of support, warranty, indemnity,</span><span class="s3">\n      </span><span class="s1">or other liability obligations and/or rights consistent with this</span><span class="s3">\n      </span><span class="s1">License. However, in accepting such obligations, You may act only</span><span class="s3">\n      </span><span class="s1">on Your own behalf and on Your sole responsibility, not on behalf</span><span class="s3">\n      </span><span class="s1">of any other Contributor, and only if You agree to indemnify,</span><span class="s3">\n      </span><span class="s1">defend, and hold each Contributor harmless for any liability</span><span class="s3">\n      </span><span class="s1">incurred by, or claims asserted against, such Contributor by reason</span><span class="s3">\n      </span><span class="s1">of your accepting any such warranty or additional liability.</span><span class="s3">\n\n   </span><span class="s1">END OF TERMS AND CONDITIONS</span><span class="s3">\n\n   </span><span class="s1">APPENDIX: How to apply the Apache License to your work.</span><span class="s3">\n\n      </span><span class="s1">To apply the Apache License to your work, attach the following</span><span class="s3">\n      </span><span class="s1">boilerplate notice, with the fields enclosed by brackets </span><span class="s3">\&quot;</span><span class="s1">{}</span><span class="s3">\&quot;\n      </span><span class="s1">replaced with your own identifying information. (Don't include</span><span class="s3">\n      </span><span class="s1">the brackets!)  The text should be enclosed in the appropriate</span><span class="s3">\n      </span><span class="s1">comment syntax for the file format. We also recommend that a</span><span class="s3">\n      </span><span class="s1">file or class name and description of purpose be included on the</span><span class="s3">\n      </span><span class="s1">same </span><span class="s3">\&quot;</span><span class="s1">printed page</span><span class="s3">\&quot; </span><span class="s1">as the copyright notice for easier</span><span class="s3">\n      </span><span class="s1">identification within third-party archives.</span><span class="s3">\n\n   </span><span class="s1">Copyright {yyyy} {name of copyright owner}</span><span class="s3">\n\n   </span><span class="s1">Licensed under the Apache License, Version 2.0 (the </span><span class="s3">\&quot;</span><span class="s1">License</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n   </span><span class="s1">you may not use this file except in compliance with the License.</span><span class="s3">\n   </span><span class="s1">You may obtain a copy of the License at</span><span class="s3">\n\n       </span><span class="s1">http://www.apache.org/licenses/LICENSE-2.0</span><span class="s3">\n\n   </span><span class="s1">Unless required by applicable law or agreed to in writing, software</span><span class="s3">\n   </span><span class="s1">distributed under the License is distributed on an </span><span class="s3">\&quot;</span><span class="s1">AS IS</span><span class="s3">\&quot; </span><span class="s1">BASIS,</span><span class="s3">\n   </span><span class="s1">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><span class="s3">\n   </span><span class="s1">See the License for the specific language governing permissions and</span><span class="s3">\n   </span><span class="s1">limitations under the License.</span><span class="s3">\n</span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">SVD.svd = function (A) {</span><span class="s3">\n  </span><span class="s1">this.U = null;</span><span class="s3">\n  </span><span class="s1">this.V = null;</span><span class="s3">\n  </span><span class="s1">this.s = null;</span><span class="s3">\n  </span><span class="s1">this.m = 0;</span><span class="s3">\n  </span><span class="s1">this.n = 0;</span><span class="s3">\n  </span><span class="s1">this.m = A.length;</span><span class="s3">\n  </span><span class="s1">this.n = A[0].length;</span><span class="s3">\n  </span><span class="s1">var nu = Math.min(this.m, this.n);</span><span class="s3">\n  </span><span class="s1">this.s = function (s) {</span><span class="s3">\n    </span><span class="s1">var a = [];</span><span class="s3">\n    </span><span class="s1">while (s-- &gt; 0) {</span><span class="s3">\n      </span><span class="s1">a.push(0);</span><span class="s3">\n    </span><span class="s1">}return a;</span><span class="s3">\n  </span><span class="s1">}(Math.min(this.m + 1, this.n));</span><span class="s3">\n  </span><span class="s1">this.U = function (dims) {</span><span class="s3">\n    </span><span class="s1">var allocate = function allocate(dims) {</span><span class="s3">\n      </span><span class="s1">if (dims.length == 0) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var array = [];</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; dims[0]; i++) {</span><span class="s3">\n          </span><span class="s1">array.push(allocate(dims.slice(1)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return array;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return allocate(dims);</span><span class="s3">\n  </span><span class="s1">}([this.m, nu]);</span><span class="s3">\n  </span><span class="s1">this.V = function (dims) {</span><span class="s3">\n    </span><span class="s1">var allocate = function allocate(dims) {</span><span class="s3">\n      </span><span class="s1">if (dims.length == 0) {</span><span class="s3">\n        </span><span class="s1">return 0;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">var array = [];</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; dims[0]; i++) {</span><span class="s3">\n          </span><span class="s1">array.push(allocate(dims.slice(1)));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return array;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">return allocate(dims);</span><span class="s3">\n  </span><span class="s1">}([this.n, this.n]);</span><span class="s3">\n  </span><span class="s1">var e = function (s) {</span><span class="s3">\n    </span><span class="s1">var a = [];</span><span class="s3">\n    </span><span class="s1">while (s-- &gt; 0) {</span><span class="s3">\n      </span><span class="s1">a.push(0);</span><span class="s3">\n    </span><span class="s1">}return a;</span><span class="s3">\n  </span><span class="s1">}(this.n);</span><span class="s3">\n  </span><span class="s1">var work = function (s) {</span><span class="s3">\n    </span><span class="s1">var a = [];</span><span class="s3">\n    </span><span class="s1">while (s-- &gt; 0) {</span><span class="s3">\n      </span><span class="s1">a.push(0);</span><span class="s3">\n    </span><span class="s1">}return a;</span><span class="s3">\n  </span><span class="s1">}(this.m);</span><span class="s3">\n  </span><span class="s1">var wantu = true;</span><span class="s3">\n  </span><span class="s1">var wantv = true;</span><span class="s3">\n  </span><span class="s1">var nct = Math.min(this.m - 1, this.n);</span><span class="s3">\n  </span><span class="s1">var nrt = Math.max(0, Math.min(this.n - 2, this.m));</span><span class="s3">\n  </span><span class="s1">for (var k = 0; k &lt; Math.max(nct, nrt); k++) {</span><span class="s3">\n    </span><span class="s1">if (k &lt; nct) {</span><span class="s3">\n      </span><span class="s1">this.s[k] = 0;</span><span class="s3">\n      </span><span class="s1">for (var i = k; i &lt; this.m; i++) {</span><span class="s3">\n        </span><span class="s1">this.s[k] = SVD.hypot(this.s[k], A[i][k]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (this.s[k] !== 0.0) {</span><span class="s3">\n        </span><span class="s1">if (A[k][k] &lt; 0.0) {</span><span class="s3">\n          </span><span class="s1">this.s[k] = -this.s[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (var _i = k; _i &lt; this.m; _i++) {</span><span class="s3">\n          </span><span class="s1">A[_i][k] /= this.s[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">A[k][k] += 1.0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">this.s[k] = -this.s[k];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">for (var j = k + 1; j &lt; this.n; j++) {</span><span class="s3">\n      </span><span class="s1">if (function (lhs, rhs) {</span><span class="s3">\n        </span><span class="s1">return lhs &amp;&amp; rhs;</span><span class="s3">\n      </span><span class="s1">}(k &lt; nct, this.s[k] !== 0.0)) {</span><span class="s3">\n        </span><span class="s1">var t = 0;</span><span class="s3">\n        </span><span class="s1">for (var _i2 = k; _i2 &lt; this.m; _i2++) {</span><span class="s3">\n          </span><span class="s1">t += A[_i2][k] * A[_i2][j];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">t = -t / A[k][k];</span><span class="s3">\n        </span><span class="s1">for (var _i3 = k; _i3 &lt; this.m; _i3++) {</span><span class="s3">\n          </span><span class="s1">A[_i3][j] += t * A[_i3][k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">e[j] = A[k][j];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">if (function (lhs, rhs) {</span><span class="s3">\n      </span><span class="s1">return lhs &amp;&amp; rhs;</span><span class="s3">\n    </span><span class="s1">}(wantu, k &lt; nct)) {</span><span class="s3">\n      </span><span class="s1">for (var _i4 = k; _i4 &lt; this.m; _i4++) {</span><span class="s3">\n        </span><span class="s1">this.U[_i4][k] = A[_i4][k];</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (k &lt; nrt) {</span><span class="s3">\n      </span><span class="s1">e[k] = 0;</span><span class="s3">\n      </span><span class="s1">for (var _i5 = k + 1; _i5 &lt; this.n; _i5++) {</span><span class="s3">\n        </span><span class="s1">e[k] = SVD.hypot(e[k], e[_i5]);</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">if (e[k] !== 0.0) {</span><span class="s3">\n        </span><span class="s1">if (e[k + 1] &lt; 0.0) {</span><span class="s3">\n          </span><span class="s1">e[k] = -e[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (var _i6 = k + 1; _i6 &lt; this.n; _i6++) {</span><span class="s3">\n          </span><span class="s1">e[_i6] /= e[k];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">e[k + 1] += 1.0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">e[k] = -e[k];</span><span class="s3">\n      </span><span class="s1">if (function (lhs, rhs) {</span><span class="s3">\n        </span><span class="s1">return lhs &amp;&amp; rhs;</span><span class="s3">\n      </span><span class="s1">}(k + 1 &lt; this.m, e[k] !== 0.0)) {</span><span class="s3">\n        </span><span class="s1">for (var _i7 = k + 1; _i7 &lt; this.m; _i7++) {</span><span class="s3">\n          </span><span class="s1">work[_i7] = 0.0;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (var _j = k + 1; _j &lt; this.n; _j++) {</span><span class="s3">\n          </span><span class="s1">for (var _i8 = k + 1; _i8 &lt; this.m; _i8++) {</span><span class="s3">\n            </span><span class="s1">work[_i8] += e[_j] * A[_i8][_j];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">for (var _j2 = k + 1; _j2 &lt; this.n; _j2++) {</span><span class="s3">\n          </span><span class="s1">var _t = -e[_j2] / e[k + 1];</span><span class="s3">\n          </span><span class="s1">for (var _i9 = k + 1; _i9 &lt; this.m; _i9++) {</span><span class="s3">\n            </span><span class="s1">A[_i9][_j2] += _t * work[_i9];</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (wantv) {</span><span class="s3">\n        </span><span class="s1">for (var _i10 = k + 1; _i10 &lt; this.n; _i10++) {</span><span class="s3">\n          </span><span class="s1">this.V[_i10][k] = e[_i10];</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var p = Math.min(this.n, this.m + 1);</span><span class="s3">\n  </span><span class="s1">if (nct &lt; this.n) {</span><span class="s3">\n    </span><span class="s1">this.s[nct] = A[nct][nct];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (this.m &lt; p) {</span><span class="s3">\n    </span><span class="s1">this.s[p - 1] = 0.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (nrt + 1 &lt; p) {</span><span class="s3">\n    </span><span class="s1">e[nrt] = A[nrt][p - 1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">e[p - 1] = 0.0;</span><span class="s3">\n  </span><span class="s1">if (wantu) {</span><span class="s3">\n    </span><span class="s1">for (var _j3 = nct; _j3 &lt; nu; _j3++) {</span><span class="s3">\n      </span><span class="s1">for (var _i11 = 0; _i11 &lt; this.m; _i11++) {</span><span class="s3">\n        </span><span class="s1">this.U[_i11][_j3] = 0.0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">this.U[_j3][_j3] = 1.0;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">for (var _k = nct - 1; _k &gt;= 0; _k--) {</span><span class="s3">\n      </span><span class="s1">if (this.s[_k] !== 0.0) {</span><span class="s3">\n        </span><span class="s1">for (var _j4 = _k + 1; _j4 &lt; nu; _j4++) {</span><span class="s3">\n          </span><span class="s1">var _t2 = 0;</span><span class="s3">\n          </span><span class="s1">for (var _i12 = _k; _i12 &lt; this.m; _i12++) {</span><span class="s3">\n            </span><span class="s1">_t2 += this.U[_i12][_k] * this.U[_i12][_j4];</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">_t2 = -_t2 / this.U[_k][_k];</span><span class="s3">\n          </span><span class="s1">for (var _i13 = _k; _i13 &lt; this.m; _i13++) {</span><span class="s3">\n            </span><span class="s1">this.U[_i13][_j4] += _t2 * this.U[_i13][_k];</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">for (var _i14 = _k; _i14 &lt; this.m; _i14++) {</span><span class="s3">\n          </span><span class="s1">this.U[_i14][_k] = -this.U[_i14][_k];</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.U[_k][_k] = 1.0 + this.U[_k][_k];</span><span class="s3">\n        </span><span class="s1">for (var _i15 = 0; _i15 &lt; _k - 1; _i15++) {</span><span class="s3">\n          </span><span class="s1">this.U[_i15][_k] = 0.0;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">for (var _i16 = 0; _i16 &lt; this.m; _i16++) {</span><span class="s3">\n          </span><span class="s1">this.U[_i16][_k] = 0.0;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">this.U[_k][_k] = 1.0;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (wantv) {</span><span class="s3">\n    </span><span class="s1">for (var _k2 = this.n - 1; _k2 &gt;= 0; _k2--) {</span><span class="s3">\n      </span><span class="s1">if (function (lhs, rhs) {</span><span class="s3">\n        </span><span class="s1">return lhs &amp;&amp; rhs;</span><span class="s3">\n      </span><span class="s1">}(_k2 &lt; nrt, e[_k2] !== 0.0)) {</span><span class="s3">\n        </span><span class="s1">for (var _j5 = _k2 + 1; _j5 &lt; nu; _j5++) {</span><span class="s3">\n          </span><span class="s1">var _t3 = 0;</span><span class="s3">\n          </span><span class="s1">for (var _i17 = _k2 + 1; _i17 &lt; this.n; _i17++) {</span><span class="s3">\n            </span><span class="s1">_t3 += this.V[_i17][_k2] * this.V[_i17][_j5];</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">_t3 = -_t3 / this.V[_k2 + 1][_k2];</span><span class="s3">\n          </span><span class="s1">for (var _i18 = _k2 + 1; _i18 &lt; this.n; _i18++) {</span><span class="s3">\n            </span><span class="s1">this.V[_i18][_j5] += _t3 * this.V[_i18][_k2];</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">for (var _i19 = 0; _i19 &lt; this.n; _i19++) {</span><span class="s3">\n        </span><span class="s1">this.V[_i19][_k2] = 0.0;</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">this.V[_k2][_k2] = 1.0;</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">var pp = p - 1;</span><span class="s3">\n  </span><span class="s1">var iter = 0;</span><span class="s3">\n  </span><span class="s1">var eps = Math.pow(2.0, -52.0);</span><span class="s3">\n  </span><span class="s1">var tiny = Math.pow(2.0, -966.0);</span><span class="s3">\n  </span><span class="s1">while (p &gt; 0) {</span><span class="s3">\n    </span><span class="s1">var _k3 = void 0;</span><span class="s3">\n    </span><span class="s1">var kase = void 0;</span><span class="s3">\n    </span><span class="s1">for (_k3 = p - 2; _k3 &gt;= -1; _k3--) {</span><span class="s3">\n      </span><span class="s1">if (_k3 === -1) {</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (Math.abs(e[_k3]) &lt;= tiny + eps * (Math.abs(this.s[_k3]) + Math.abs(this.s[_k3 + 1]))) {</span><span class="s3">\n        </span><span class="s1">e[_k3] = 0.0;</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">if (_k3 === p - 2) {</span><span class="s3">\n      </span><span class="s1">kase = 4;</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">var ks = void 0;</span><span class="s3">\n      </span><span class="s1">for (ks = p - 1; ks &gt;= _k3; ks--) {</span><span class="s3">\n        </span><span class="s1">if (ks === _k3) {</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">var _t4 = (ks !== p ? Math.abs(e[ks]) : 0.0) + (ks !== _k3 + 1 ? Math.abs(e[ks - 1]) : 0.0);</span><span class="s3">\n        </span><span class="s1">if (Math.abs(this.s[ks]) &lt;= tiny + eps * _t4) {</span><span class="s3">\n          </span><span class="s1">this.s[ks] = 0.0;</span><span class="s3">\n          </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">if (ks === _k3) {</span><span class="s3">\n        </span><span class="s1">kase = 3;</span><span class="s3">\n      </span><span class="s1">} else if (ks === p - 1) {</span><span class="s3">\n        </span><span class="s1">kase = 1;</span><span class="s3">\n      </span><span class="s1">} else {</span><span class="s3">\n        </span><span class="s1">kase = 2;</span><span class="s3">\n        </span><span class="s1">_k3 = ks;</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">_k3++;</span><span class="s3">\n    </span><span class="s1">switch (kase) {</span><span class="s3">\n      </span><span class="s1">case 1:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var f = e[p - 2];</span><span class="s3">\n          </span><span class="s1">e[p - 2] = 0.0;</span><span class="s3">\n          </span><span class="s1">for (var _j6 = p - 2; _j6 &gt;= _k3; _j6--) {</span><span class="s3">\n            </span><span class="s1">var _t5 = SVD.hypot(this.s[_j6], f);</span><span class="s3">\n            </span><span class="s1">var cs = this.s[_j6] / _t5;</span><span class="s3">\n            </span><span class="s1">var sn = f / _t5;</span><span class="s3">\n            </span><span class="s1">this.s[_j6] = _t5;</span><span class="s3">\n            </span><span class="s1">if (_j6 !== _k3) {</span><span class="s3">\n              </span><span class="s1">f = -sn * e[_j6 - 1];</span><span class="s3">\n              </span><span class="s1">e[_j6 - 1] = cs * e[_j6 - 1];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (wantv) {</span><span class="s3">\n              </span><span class="s1">for (var _i20 = 0; _i20 &lt; this.n; _i20++) {</span><span class="s3">\n                </span><span class="s1">_t5 = cs * this.V[_i20][_j6] + sn * this.V[_i20][p - 1];</span><span class="s3">\n                </span><span class="s1">this.V[_i20][p - 1] = -sn * this.V[_i20][_j6] + cs * this.V[_i20][p - 1];</span><span class="s3">\n                </span><span class="s1">this.V[_i20][_j6] = _t5;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 2:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var _f = e[_k3 - 1];</span><span class="s3">\n          </span><span class="s1">e[_k3 - 1] = 0.0;</span><span class="s3">\n          </span><span class="s1">for (var _j7 = _k3; _j7 &lt; p; _j7++) {</span><span class="s3">\n            </span><span class="s1">var _t6 = SVD.hypot(this.s[_j7], _f);</span><span class="s3">\n            </span><span class="s1">var _cs = this.s[_j7] / _t6;</span><span class="s3">\n            </span><span class="s1">var _sn = _f / _t6;</span><span class="s3">\n            </span><span class="s1">this.s[_j7] = _t6;</span><span class="s3">\n            </span><span class="s1">_f = -_sn * e[_j7];</span><span class="s3">\n            </span><span class="s1">e[_j7] = _cs * e[_j7];</span><span class="s3">\n            </span><span class="s1">if (wantu) {</span><span class="s3">\n              </span><span class="s1">for (var _i21 = 0; _i21 &lt; this.m; _i21++) {</span><span class="s3">\n                </span><span class="s1">_t6 = _cs * this.U[_i21][_j7] + _sn * this.U[_i21][_k3 - 1];</span><span class="s3">\n                </span><span class="s1">this.U[_i21][_k3 - 1] = -_sn * this.U[_i21][_j7] + _cs * this.U[_i21][_k3 - 1];</span><span class="s3">\n                </span><span class="s1">this.U[_i21][_j7] = _t6;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 3:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">var scale = Math.max(Math.max(Math.max(Math.max(Math.abs(this.s[p - 1]), Math.abs(this.s[p - 2])), Math.abs(e[p - 2])), Math.abs(this.s[_k3])), Math.abs(e[_k3]));</span><span class="s3">\n          </span><span class="s1">var sp = this.s[p - 1] / scale;</span><span class="s3">\n          </span><span class="s1">var spm1 = this.s[p - 2] / scale;</span><span class="s3">\n          </span><span class="s1">var epm1 = e[p - 2] / scale;</span><span class="s3">\n          </span><span class="s1">var sk = this.s[_k3] / scale;</span><span class="s3">\n          </span><span class="s1">var ek = e[_k3] / scale;</span><span class="s3">\n          </span><span class="s1">var b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2.0;</span><span class="s3">\n          </span><span class="s1">var c = sp * epm1 * (sp * epm1);</span><span class="s3">\n          </span><span class="s1">var shift = 0.0;</span><span class="s3">\n          </span><span class="s1">if (function (lhs, rhs) {</span><span class="s3">\n            </span><span class="s1">return lhs || rhs;</span><span class="s3">\n          </span><span class="s1">}(b !== 0.0, c !== 0.0)) {</span><span class="s3">\n            </span><span class="s1">shift = Math.sqrt(b * b + c);</span><span class="s3">\n            </span><span class="s1">if (b &lt; 0.0) {</span><span class="s3">\n              </span><span class="s1">shift = -shift;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">shift = c / (b + shift);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">var _f2 = (sk + sp) * (sk - sp) + shift;</span><span class="s3">\n          </span><span class="s1">var g = sk * ek;</span><span class="s3">\n          </span><span class="s1">for (var _j8 = _k3; _j8 &lt; p - 1; _j8++) {</span><span class="s3">\n            </span><span class="s1">var _t7 = SVD.hypot(_f2, g);</span><span class="s3">\n            </span><span class="s1">var _cs2 = _f2 / _t7;</span><span class="s3">\n            </span><span class="s1">var _sn2 = g / _t7;</span><span class="s3">\n            </span><span class="s1">if (_j8 !== _k3) {</span><span class="s3">\n              </span><span class="s1">e[_j8 - 1] = _t7;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_f2 = _cs2 * this.s[_j8] + _sn2 * e[_j8];</span><span class="s3">\n            </span><span class="s1">e[_j8] = _cs2 * e[_j8] - _sn2 * this.s[_j8];</span><span class="s3">\n            </span><span class="s1">g = _sn2 * this.s[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">this.s[_j8 + 1] = _cs2 * this.s[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">if (wantv) {</span><span class="s3">\n              </span><span class="s1">for (var _i22 = 0; _i22 &lt; this.n; _i22++) {</span><span class="s3">\n                </span><span class="s1">_t7 = _cs2 * this.V[_i22][_j8] + _sn2 * this.V[_i22][_j8 + 1];</span><span class="s3">\n                </span><span class="s1">this.V[_i22][_j8 + 1] = -_sn2 * this.V[_i22][_j8] + _cs2 * this.V[_i22][_j8 + 1];</span><span class="s3">\n                </span><span class="s1">this.V[_i22][_j8] = _t7;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_t7 = SVD.hypot(_f2, g);</span><span class="s3">\n            </span><span class="s1">_cs2 = _f2 / _t7;</span><span class="s3">\n            </span><span class="s1">_sn2 = g / _t7;</span><span class="s3">\n            </span><span class="s1">this.s[_j8] = _t7;</span><span class="s3">\n            </span><span class="s1">_f2 = _cs2 * e[_j8] + _sn2 * this.s[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">this.s[_j8 + 1] = -_sn2 * e[_j8] + _cs2 * this.s[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">g = _sn2 * e[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">e[_j8 + 1] = _cs2 * e[_j8 + 1];</span><span class="s3">\n            </span><span class="s1">if (wantu &amp;&amp; _j8 &lt; this.m - 1) {</span><span class="s3">\n              </span><span class="s1">for (var _i23 = 0; _i23 &lt; this.m; _i23++) {</span><span class="s3">\n                </span><span class="s1">_t7 = _cs2 * this.U[_i23][_j8] + _sn2 * this.U[_i23][_j8 + 1];</span><span class="s3">\n                </span><span class="s1">this.U[_i23][_j8 + 1] = -_sn2 * this.U[_i23][_j8] + _cs2 * this.U[_i23][_j8 + 1];</span><span class="s3">\n                </span><span class="s1">this.U[_i23][_j8] = _t7;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">e[p - 2] = _f2;</span><span class="s3">\n          </span><span class="s1">iter = iter + 1;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n      </span><span class="s1">case 4:</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">if (this.s[_k3] &lt;= 0.0) {</span><span class="s3">\n            </span><span class="s1">this.s[_k3] = this.s[_k3] &lt; 0.0 ? -this.s[_k3] : 0.0;</span><span class="s3">\n            </span><span class="s1">if (wantv) {</span><span class="s3">\n              </span><span class="s1">for (var _i24 = 0; _i24 &lt;= pp; _i24++) {</span><span class="s3">\n                </span><span class="s1">this.V[_i24][_k3] = -this.V[_i24][_k3];</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">while (_k3 &lt; pp) {</span><span class="s3">\n            </span><span class="s1">if (this.s[_k3] &gt;= this.s[_k3 + 1]) {</span><span class="s3">\n              </span><span class="s1">break;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">var _t8 = this.s[_k3];</span><span class="s3">\n            </span><span class="s1">this.s[_k3] = this.s[_k3 + 1];</span><span class="s3">\n            </span><span class="s1">this.s[_k3 + 1] = _t8;</span><span class="s3">\n            </span><span class="s1">if (wantv &amp;&amp; _k3 &lt; this.n - 1) {</span><span class="s3">\n              </span><span class="s1">for (var _i25 = 0; _i25 &lt; this.n; _i25++) {</span><span class="s3">\n                </span><span class="s1">_t8 = this.V[_i25][_k3 + 1];</span><span class="s3">\n                </span><span class="s1">this.V[_i25][_k3 + 1] = this.V[_i25][_k3];</span><span class="s3">\n                </span><span class="s1">this.V[_i25][_k3] = _t8;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">if (wantu &amp;&amp; _k3 &lt; this.m - 1) {</span><span class="s3">\n              </span><span class="s1">for (var _i26 = 0; _i26 &lt; this.m; _i26++) {</span><span class="s3">\n                </span><span class="s1">_t8 = this.U[_i26][_k3 + 1];</span><span class="s3">\n                </span><span class="s1">this.U[_i26][_k3 + 1] = this.U[_i26][_k3];</span><span class="s3">\n                </span><span class="s1">this.U[_i26][_k3] = _t8;</span><span class="s3">\n              </span><span class="s1">};</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">_k3++;</span><span class="s3">\n          </span><span class="s1">};</span><span class="s3">\n          </span><span class="s1">iter = 0;</span><span class="s3">\n          </span><span class="s1">p--;</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n        </span><span class="s1">break;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">var result = { U: this.U, V: this.V, S: this.s };</span><span class="s3">\n  </span><span class="s1">return result;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// sqrt(a^2 + b^2) without under/overflow.</span><span class="s3">\n</span><span class="s1">SVD.hypot = function (a, b) {</span><span class="s3">\n  </span><span class="s1">var r = void 0;</span><span class="s3">\n  </span><span class="s1">if (Math.abs(a) &gt; Math.abs(b)) {</span><span class="s3">\n    </span><span class="s1">r = b / a;</span><span class="s3">\n    </span><span class="s1">r = Math.abs(a) * Math.sqrt(1 + r * r);</span><span class="s3">\n  </span><span class="s1">} else if (b != 0) {</span><span class="s3">\n    </span><span class="s1">r = a / b;</span><span class="s3">\n    </span><span class="s1">r = Math.abs(b) * Math.sqrt(1 + r * r);</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">r = 0.0;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return r;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = SVD;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 27 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i &lt; props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (</span><span class="s3">\&quot;</span><span class="s1">value</span><span class="s3">\&quot; </span><span class="s1">in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();</span><span class="s3">\n\n</span><span class="s1">function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(</span><span class="s3">\&quot;</span><span class="s1">Cannot call a class as a function</span><span class="s3">\&quot;</span><span class="s1">); } }</span><span class="s3">\n\n</span><span class="s1">/**</span><span class="s3">\n </span><span class="s1">*   Needleman-Wunsch algorithm is an procedure to compute the optimal global alignment of two string</span><span class="s3">\n </span><span class="s1">*   sequences by S.B.Needleman and C.D.Wunsch (1970).</span><span class="s3">\n </span><span class="s1">*</span><span class="s3">\n </span><span class="s1">*   Aside from the inputs, you can assign the scores for,</span><span class="s3">\n </span><span class="s1">*   - Match: The two characters at the current index are same.</span><span class="s3">\n </span><span class="s1">*   - Mismatch: The two characters at the current index are different.</span><span class="s3">\n </span><span class="s1">*   - Insertion/Deletion(gaps): The best alignment involves one letter aligning to a gap in the other string.</span><span class="s3">\n </span><span class="s1">*/</span><span class="s3">\n\n</span><span class="s1">var NeedlemanWunsch = function () {</span><span class="s3">\n    </span><span class="s1">function NeedlemanWunsch(sequence1, sequence2) {</span><span class="s3">\n        </span><span class="s1">var match_score = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : 1;</span><span class="s3">\n        </span><span class="s1">var mismatch_penalty = arguments.length &gt; 3 &amp;&amp; arguments[3] !== undefined ? arguments[3] : -1;</span><span class="s3">\n        </span><span class="s1">var gap_penalty = arguments.length &gt; 4 &amp;&amp; arguments[4] !== undefined ? arguments[4] : -1;</span><span class="s3">\n\n        </span><span class="s1">_classCallCheck(this, NeedlemanWunsch);</span><span class="s3">\n\n        </span><span class="s1">this.sequence1 = sequence1;</span><span class="s3">\n        </span><span class="s1">this.sequence2 = sequence2;</span><span class="s3">\n        </span><span class="s1">this.match_score = match_score;</span><span class="s3">\n        </span><span class="s1">this.mismatch_penalty = mismatch_penalty;</span><span class="s3">\n        </span><span class="s1">this.gap_penalty = gap_penalty;</span><span class="s3">\n\n        </span><span class="s1">// Just the remove redundancy</span><span class="s3">\n        </span><span class="s1">this.iMax = sequence1.length + 1;</span><span class="s3">\n        </span><span class="s1">this.jMax = sequence2.length + 1;</span><span class="s3">\n\n        </span><span class="s1">// Grid matrix of scores</span><span class="s3">\n        </span><span class="s1">this.grid = new Array(this.iMax);</span><span class="s3">\n        </span><span class="s1">for (var i = 0; i &lt; this.iMax; i++) {</span><span class="s3">\n            </span><span class="s1">this.grid[i] = new Array(this.jMax);</span><span class="s3">\n\n            </span><span class="s1">for (var j = 0; j &lt; this.jMax; j++) {</span><span class="s3">\n                </span><span class="s1">this.grid[i][j] = 0;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Traceback matrix (2D array, each cell is an array of boolean values for [`Diag`, `Up`, `Left`] positions)</span><span class="s3">\n        </span><span class="s1">this.tracebackGrid = new Array(this.iMax);</span><span class="s3">\n        </span><span class="s1">for (var _i = 0; _i &lt; this.iMax; _i++) {</span><span class="s3">\n            </span><span class="s1">this.tracebackGrid[_i] = new Array(this.jMax);</span><span class="s3">\n\n            </span><span class="s1">for (var _j = 0; _j &lt; this.jMax; _j++) {</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[_i][_j] = [null, null, null];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// The aligned sequences (return multiple possibilities)</span><span class="s3">\n        </span><span class="s1">this.alignments = [];</span><span class="s3">\n\n        </span><span class="s1">// Final alignment score</span><span class="s3">\n        </span><span class="s1">this.score = -1;</span><span class="s3">\n\n        </span><span class="s1">// Calculate scores and tracebacks</span><span class="s3">\n        </span><span class="s1">this.computeGrids();</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n\n    </span><span class="s1">_createClass(NeedlemanWunsch, [{</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getScore</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getScore() {</span><span class="s3">\n            </span><span class="s1">return this.score;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAlignments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getAlignments() {</span><span class="s3">\n            </span><span class="s1">return this.alignments;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Main dynamic programming procedure</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">computeGrids</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function computeGrids() {</span><span class="s3">\n            </span><span class="s1">// Fill in the first row</span><span class="s3">\n            </span><span class="s1">for (var j = 1; j &lt; this.jMax; j++) {</span><span class="s3">\n                </span><span class="s1">this.grid[0][j] = this.grid[0][j - 1] + this.gap_penalty;</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[0][j] = [false, false, true];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Fill in the first column</span><span class="s3">\n            </span><span class="s1">for (var i = 1; i &lt; this.iMax; i++) {</span><span class="s3">\n                </span><span class="s1">this.grid[i][0] = this.grid[i - 1][0] + this.gap_penalty;</span><span class="s3">\n                </span><span class="s1">this.tracebackGrid[i][0] = [false, true, false];</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Fill the rest of the grid</span><span class="s3">\n            </span><span class="s1">for (var _i2 = 1; _i2 &lt; this.iMax; _i2++) {</span><span class="s3">\n                </span><span class="s1">for (var _j2 = 1; _j2 &lt; this.jMax; _j2++) {</span><span class="s3">\n                    </span><span class="s1">// Find the max score(s) among [`Diag`, `Up`, `Left`]</span><span class="s3">\n                    </span><span class="s1">var diag = void 0;</span><span class="s3">\n                    </span><span class="s1">if (this.sequence1[_i2 - 1] === this.sequence2[_j2 - 1]) diag = this.grid[_i2 - 1][_j2 - 1] + this.match_score;else diag = this.grid[_i2 - 1][_j2 - 1] + this.mismatch_penalty;</span><span class="s3">\n\n                    </span><span class="s1">var up = this.grid[_i2 - 1][_j2] + this.gap_penalty;</span><span class="s3">\n                    </span><span class="s1">var left = this.grid[_i2][_j2 - 1] + this.gap_penalty;</span><span class="s3">\n\n                    </span><span class="s1">// If there exists multiple max values, capture them for multiple paths</span><span class="s3">\n                    </span><span class="s1">var maxOf = [diag, up, left];</span><span class="s3">\n                    </span><span class="s1">var indices = this.arrayAllMaxIndexes(maxOf);</span><span class="s3">\n\n                    </span><span class="s1">// Update Grids</span><span class="s3">\n                    </span><span class="s1">this.grid[_i2][_j2] = maxOf[indices[0]];</span><span class="s3">\n                    </span><span class="s1">this.tracebackGrid[_i2][_j2] = [indices.includes(0), indices.includes(1), indices.includes(2)];</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">// Update alignment score</span><span class="s3">\n            </span><span class="s1">this.score = this.grid[this.iMax - 1][this.jMax - 1];</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Gets all possible valid sequence combinations</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">alignmentTraceback</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function alignmentTraceback() {</span><span class="s3">\n            </span><span class="s1">var inProcessAlignments = [];</span><span class="s3">\n\n            </span><span class="s1">inProcessAlignments.push({ pos: [this.sequence1.length, this.sequence2.length],</span><span class="s3">\n                </span><span class="s1">seq1: </span><span class="s3">\&quot;\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">seq2: </span><span class="s3">\&quot;\&quot;\n            </span><span class="s1">});</span><span class="s3">\n\n            </span><span class="s1">while (inProcessAlignments[0]) {</span><span class="s3">\n                </span><span class="s1">var current = inProcessAlignments[0];</span><span class="s3">\n                </span><span class="s1">var directions = this.tracebackGrid[current.pos[0]][current.pos[1]];</span><span class="s3">\n\n                </span><span class="s1">if (directions[0]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1] - 1],</span><span class="s3">\n                        </span><span class="s1">seq1: this.sequence1[current.pos[0] - 1] + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: this.sequence2[current.pos[1] - 1] + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (directions[1]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0] - 1, current.pos[1]],</span><span class="s3">\n                        </span><span class="s1">seq1: this.sequence1[current.pos[0] - 1] + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: '-' + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n                </span><span class="s1">if (directions[2]) {</span><span class="s3">\n                    </span><span class="s1">inProcessAlignments.push({ pos: [current.pos[0], current.pos[1] - 1],</span><span class="s3">\n                        </span><span class="s1">seq1: '-' + current.seq1,</span><span class="s3">\n                        </span><span class="s1">seq2: this.sequence2[current.pos[1] - 1] + current.seq2</span><span class="s3">\n                    </span><span class="s1">});</span><span class="s3">\n                </span><span class="s1">}</span><span class="s3">\n\n                </span><span class="s1">if (current.pos[0] === 0 &amp;&amp; current.pos[1] === 0) this.alignments.push({ sequence1: current.seq1,</span><span class="s3">\n                    </span><span class="s1">sequence2: current.seq2</span><span class="s3">\n                </span><span class="s1">});</span><span class="s3">\n\n                </span><span class="s1">inProcessAlignments.shift();</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n\n            </span><span class="s1">return this.alignments;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n\n        </span><span class="s1">// Helper Functions</span><span class="s3">\n\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">getAllIndexes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function getAllIndexes(arr, val) {</span><span class="s3">\n            </span><span class="s1">var indexes = [],</span><span class="s3">\n                </span><span class="s1">i = -1;</span><span class="s3">\n            </span><span class="s1">while ((i = arr.indexOf(val, i + 1)) !== -1) {</span><span class="s3">\n                </span><span class="s1">indexes.push(i);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n            </span><span class="s1">return indexes;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}, {</span><span class="s3">\n        </span><span class="s1">key: </span><span class="s3">\&quot;</span><span class="s1">arrayAllMaxIndexes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">value: function arrayAllMaxIndexes(array) {</span><span class="s3">\n            </span><span class="s1">return this.getAllIndexes(array, Math.max.apply(null, array));</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}]);</span><span class="s3">\n\n    </span><span class="s1">return NeedlemanWunsch;</span><span class="s3">\n</span><span class="s1">}();</span><span class="s3">\n\n</span><span class="s1">module.exports = NeedlemanWunsch;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 28 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">var layoutBase = function layoutBase() {</span><span class="s3">\n  </span><span class="s1">return;</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">layoutBase.FDLayout = __webpack_require__(18);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutConstants = __webpack_require__(4);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutEdge = __webpack_require__(19);</span><span class="s3">\n</span><span class="s1">layoutBase.FDLayoutNode = __webpack_require__(20);</span><span class="s3">\n</span><span class="s1">layoutBase.DimensionD = __webpack_require__(21);</span><span class="s3">\n</span><span class="s1">layoutBase.HashMap = __webpack_require__(22);</span><span class="s3">\n</span><span class="s1">layoutBase.HashSet = __webpack_require__(23);</span><span class="s3">\n</span><span class="s1">layoutBase.IGeometry = __webpack_require__(8);</span><span class="s3">\n</span><span class="s1">layoutBase.IMath = __webpack_require__(9);</span><span class="s3">\n</span><span class="s1">layoutBase.Integer = __webpack_require__(10);</span><span class="s3">\n</span><span class="s1">layoutBase.Point = __webpack_require__(12);</span><span class="s3">\n</span><span class="s1">layoutBase.PointD = __webpack_require__(5);</span><span class="s3">\n</span><span class="s1">layoutBase.RandomSeed = __webpack_require__(16);</span><span class="s3">\n</span><span class="s1">layoutBase.RectangleD = __webpack_require__(13);</span><span class="s3">\n</span><span class="s1">layoutBase.Transform = __webpack_require__(17);</span><span class="s3">\n</span><span class="s1">layoutBase.UniqueIDGeneretor = __webpack_require__(14);</span><span class="s3">\n</span><span class="s1">layoutBase.Quicksort = __webpack_require__(25);</span><span class="s3">\n</span><span class="s1">layoutBase.LinkedList = __webpack_require__(11);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraphObject = __webpack_require__(2);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraph = __webpack_require__(6);</span><span class="s3">\n</span><span class="s1">layoutBase.LEdge = __webpack_require__(1);</span><span class="s3">\n</span><span class="s1">layoutBase.LGraphManager = __webpack_require__(7);</span><span class="s3">\n</span><span class="s1">layoutBase.LNode = __webpack_require__(3);</span><span class="s3">\n</span><span class="s1">layoutBase.Layout = __webpack_require__(15);</span><span class="s3">\n</span><span class="s1">layoutBase.LayoutConstants = __webpack_require__(0);</span><span class="s3">\n</span><span class="s1">layoutBase.NeedlemanWunsch = __webpack_require__(27);</span><span class="s3">\n</span><span class="s1">layoutBase.Matrix = __webpack_require__(24);</span><span class="s3">\n</span><span class="s1">layoutBase.SVD = __webpack_require__(26);</span><span class="s3">\n\n</span><span class="s1">module.exports = layoutBase;</span><span class="s3">\n\n</span><span class="s1">/***/ }),</span><span class="s3">\n</span><span class="s1">/* 29 */</span><span class="s3">\n</span><span class="s1">/***/ (function(module, exports, __webpack_require__) {</span><span class="s3">\n\n\&quot;</span><span class="s1">use strict</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n\n</span><span class="s1">function Emitter() {</span><span class="s3">\n  </span><span class="s1">this.listeners = [];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n\n</span><span class="s1">var p = Emitter.prototype;</span><span class="s3">\n\n</span><span class="s1">p.addListener = function (event, callback) {</span><span class="s3">\n  </span><span class="s1">this.listeners.push({</span><span class="s3">\n    </span><span class="s1">event: event,</span><span class="s3">\n    </span><span class="s1">callback: callback</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">p.removeListener = function (event, callback) {</span><span class="s3">\n  </span><span class="s1">for (var i = this.listeners.length; i &gt;= 0; i--) {</span><span class="s3">\n    </span><span class="s1">var l = this.listeners[i];</span><span class="s3">\n\n    </span><span class="s1">if (l.event === event &amp;&amp; l.callback === callback) {</span><span class="s3">\n      </span><span class="s1">this.listeners.splice(i, 1);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">p.emit = function (event, data) {</span><span class="s3">\n  </span><span class="s1">for (var i = 0; i &lt; this.listeners.length; i++) {</span><span class="s3">\n    </span><span class="s1">var l = this.listeners[i];</span><span class="s3">\n\n    </span><span class="s1">if (event === l.event) {</span><span class="s3">\n      </span><span class="s1">l.callback(data);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">module.exports = Emitter;</span><span class="s3">\n\n</span><span class="s1">/***/ })</span><span class="s3">\n</span><span class="s1">/******/ ]);</span><span class="s3">\n</span><span class="s1">});&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">getIconSVG,</span><span class="s3">\n  </span><span class="s1">registerIconPacks,</span><span class="s3">\n  </span><span class="s1">unknownIcon</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-H2D2JQ3I.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">createText</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-C3MQ5ANM.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">populateCommonDb</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-4BMEZGHF.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">ImperativeState</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-XZIHB7SX.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import </span><span class="s3">\&quot;</span><span class="s1">./chunk-O4NI6UNU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">selectSvgElement</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-7B677QYD.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import {</span><span class="s3">\n  </span><span class="s1">__name,</span><span class="s3">\n  </span><span class="s1">clear,</span><span class="s3">\n  </span><span class="s1">defaultConfig_default,</span><span class="s3">\n  </span><span class="s1">getAccDescription,</span><span class="s3">\n  </span><span class="s1">getAccTitle,</span><span class="s3">\n  </span><span class="s1">getConfig2 as getConfig,</span><span class="s3">\n  </span><span class="s1">getDiagramTitle,</span><span class="s3">\n  </span><span class="s1">log,</span><span class="s3">\n  </span><span class="s1">setAccDescription,</span><span class="s3">\n  </span><span class="s1">setAccTitle,</span><span class="s3">\n  </span><span class="s1">setDiagramTitle,</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureParser.ts</span><span class="s3">\n</span><span class="s1">import { parse } from </span><span class="s3">\&quot;</span><span class="s1">@mermaid-js/parser</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureTypes.ts</span><span class="s3">\n</span><span class="s1">var ArchitectureDirectionName = {</span><span class="s3">\n  </span><span class="s1">L: </span><span class="s3">\&quot;</span><span class="s1">left</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">R: </span><span class="s3">\&quot;</span><span class="s1">right</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">T: </span><span class="s3">\&quot;</span><span class="s1">top</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">B: </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ArchitectureDirectionArrow = {</span><span class="s3">\n  </span><span class="s1">L: /* @__PURE__ */ __name((scale) =&gt; `${scale},${scale / 2} 0,${scale} 0,0`, </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">R: /* @__PURE__ */ __name((scale) =&gt; `0,${scale / 2} ${scale},0 ${scale},${scale}`, </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">T: /* @__PURE__ */ __name((scale) =&gt; `0,0 ${scale},0 ${scale / 2},${scale}`, </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">B: /* @__PURE__ */ __name((scale) =&gt; `${scale / 2},0 ${scale},${scale} 0,${scale}`, </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var ArchitectureDirectionArrowShift = {</span><span class="s3">\n  </span><span class="s1">L: /* @__PURE__ */ __name((orig, arrowSize) =&gt; orig - arrowSize + 2, </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">R: /* @__PURE__ */ __name((orig, _arrowSize) =&gt; orig - 2, </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">T: /* @__PURE__ */ __name((orig, arrowSize) =&gt; orig - arrowSize + 2, </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n  </span><span class="s1">B: /* @__PURE__ */ __name((orig, _arrowSize) =&gt; orig - 2, </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">var getOppositeArchitectureDirection = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">if (isArchitectureDirectionX(x)) {</span><span class="s3">\n    </span><span class="s1">return x === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return x === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getOppositeArchitectureDirection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureDirection = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">const temp = x;</span><span class="s3">\n  </span><span class="s1">return temp === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">|| temp === </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot; </span><span class="s1">|| temp === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">|| temp === </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureDirection</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureDirectionX = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">const temp = x;</span><span class="s3">\n  </span><span class="s1">return temp === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">|| temp === </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureDirectionX</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureDirectionY = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">const temp = x;</span><span class="s3">\n  </span><span class="s1">return temp === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">|| temp === </span><span class="s3">\&quot;</span><span class="s1">B</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureDirectionY</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureDirectionXY = /* @__PURE__ */ __name(function(a, b) {</span><span class="s3">\n  </span><span class="s1">const aX_bY = isArchitectureDirectionX(a) &amp;&amp; isArchitectureDirectionY(b);</span><span class="s3">\n  </span><span class="s1">const aY_bX = isArchitectureDirectionY(a) &amp;&amp; isArchitectureDirectionX(b);</span><span class="s3">\n  </span><span class="s1">return aX_bY || aY_bX;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureDirectionXY</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitecturePairXY = /* @__PURE__ */ __name(function(pair) {</span><span class="s3">\n  </span><span class="s1">const lhs = pair[0];</span><span class="s3">\n  </span><span class="s1">const rhs = pair[1];</span><span class="s3">\n  </span><span class="s1">const aX_bY = isArchitectureDirectionX(lhs) &amp;&amp; isArchitectureDirectionY(rhs);</span><span class="s3">\n  </span><span class="s1">const aY_bX = isArchitectureDirectionY(lhs) &amp;&amp; isArchitectureDirectionX(rhs);</span><span class="s3">\n  </span><span class="s1">return aX_bY || aY_bX;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitecturePairXY</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isValidArchitectureDirectionPair = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">return x !== </span><span class="s3">\&quot;</span><span class="s1">LL</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; x !== </span><span class="s3">\&quot;</span><span class="s1">RR</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; x !== </span><span class="s3">\&quot;</span><span class="s1">TT</span><span class="s3">\&quot; </span><span class="s1">&amp;&amp; x !== </span><span class="s3">\&quot;</span><span class="s1">BB</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isValidArchitectureDirectionPair</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getArchitectureDirectionPair = /* @__PURE__ */ __name(function(sourceDir, targetDir) {</span><span class="s3">\n  </span><span class="s1">const pair = `${sourceDir}${targetDir}`;</span><span class="s3">\n  </span><span class="s1">return isValidArchitectureDirectionPair(pair) ? pair : void 0;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getArchitectureDirectionPair</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ __name(function([x, y], pair) {</span><span class="s3">\n  </span><span class="s1">const lhs = pair[0];</span><span class="s3">\n  </span><span class="s1">const rhs = pair[1];</span><span class="s3">\n  </span><span class="s1">if (isArchitectureDirectionX(lhs)) {</span><span class="s3">\n    </span><span class="s1">if (isArchitectureDirectionY(rhs)) {</span><span class="s3">\n      </span><span class="s1">return [x + (lhs === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? -1 : 1), y + (rhs === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? 1 : -1)];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [x + (lhs === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? -1 : 1), y];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">if (isArchitectureDirectionX(rhs)) {</span><span class="s3">\n      </span><span class="s1">return [x + (rhs === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? 1 : -1), y + (lhs === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? 1 : -1)];</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">return [x, y + (lhs === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? 1 : -1)];</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">shiftPositionByArchitectureDirectionPair</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getArchitectureDirectionXYFactors = /* @__PURE__ */ __name(function(pair) {</span><span class="s3">\n  </span><span class="s1">if (pair === </span><span class="s3">\&quot;</span><span class="s1">LT</span><span class="s3">\&quot; </span><span class="s1">|| pair === </span><span class="s3">\&quot;</span><span class="s1">TL</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [1, 1];</span><span class="s3">\n  </span><span class="s1">} else if (pair === </span><span class="s3">\&quot;</span><span class="s1">BL</span><span class="s3">\&quot; </span><span class="s1">|| pair === </span><span class="s3">\&quot;</span><span class="s1">LB</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [1, -1];</span><span class="s3">\n  </span><span class="s1">} else if (pair === </span><span class="s3">\&quot;</span><span class="s1">BR</span><span class="s3">\&quot; </span><span class="s1">|| pair === </span><span class="s3">\&quot;</span><span class="s1">RB</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n    </span><span class="s1">return [-1, -1];</span><span class="s3">\n  </span><span class="s1">} else {</span><span class="s3">\n    </span><span class="s1">return [-1, 1];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getArchitectureDirectionXYFactors</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getArchitectureDirectionAlignment = /* @__PURE__ */ __name(function(a, b) {</span><span class="s3">\n  </span><span class="s1">if (isArchitectureDirectionXY(a, b)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">bend</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">} else if (isArchitectureDirectionX(a)) {</span><span class="s3">\n    </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getArchitectureDirectionAlignment</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureService = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">const temp = x;</span><span class="s3">\n  </span><span class="s1">return temp.type === </span><span class="s3">\&quot;</span><span class="s1">service</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureService</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var isArchitectureJunction = /* @__PURE__ */ __name(function(x) {</span><span class="s3">\n  </span><span class="s1">const temp = x;</span><span class="s3">\n  </span><span class="s1">return temp.type === </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">isArchitectureJunction</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var edgeData = /* @__PURE__ */ __name((edge) =&gt; {</span><span class="s3">\n  </span><span class="s1">return edge.data();</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">edgeData</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var nodeData = /* @__PURE__ */ __name((node) =&gt; {</span><span class="s3">\n  </span><span class="s1">return node.data();</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">nodeData</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureDb.ts</span><span class="s3">\n</span><span class="s1">var DEFAULT_ARCHITECTURE_CONFIG = defaultConfig_default.architecture;</span><span class="s3">\n</span><span class="s1">var state = new ImperativeState(() =&gt; ({</span><span class="s3">\n  </span><span class="s1">nodes: {},</span><span class="s3">\n  </span><span class="s1">groups: {},</span><span class="s3">\n  </span><span class="s1">edges: [],</span><span class="s3">\n  </span><span class="s1">registeredIds: {},</span><span class="s3">\n  </span><span class="s1">config: DEFAULT_ARCHITECTURE_CONFIG,</span><span class="s3">\n  </span><span class="s1">dataStructures: void 0,</span><span class="s3">\n  </span><span class="s1">elements: {}</span><span class="s3">\n</span><span class="s1">}));</span><span class="s3">\n</span><span class="s1">var clear2 = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">state.reset();</span><span class="s3">\n  </span><span class="s1">clear();</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">clear</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var addService = /* @__PURE__ */ __name(function({</span><span class="s3">\n  </span><span class="s1">id,</span><span class="s3">\n  </span><span class="s1">icon,</span><span class="s3">\n  </span><span class="s1">in: parent,</span><span class="s3">\n  </span><span class="s1">title,</span><span class="s3">\n  </span><span class="s1">iconText</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (state.records.registeredIds[id] !== void 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parent !== void 0) {</span><span class="s3">\n    </span><span class="s1">if (id === parent) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`The service [${id}] cannot be placed within itself`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.records.registeredIds[parent] === void 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`The service [${id}]'s parent does not exist. Please make sure the parent is created before this service`</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.records.registeredIds[parent] === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`The service [${id}]'s parent is not a group`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.records.registeredIds[id] = </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">state.records.nodes[id] = {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">service</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">icon,</span><span class="s3">\n    </span><span class="s1">iconText,</span><span class="s3">\n    </span><span class="s1">title,</span><span class="s3">\n    </span><span class="s1">edges: [],</span><span class="s3">\n    </span><span class="s1">in: parent</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addService</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getServices = /* @__PURE__ */ __name(() =&gt; Object.values(state.records.nodes).filter(isArchitectureService), </span><span class="s3">\&quot;</span><span class="s1">getServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var addJunction = /* @__PURE__ */ __name(function({ id, in: parent }) {</span><span class="s3">\n  </span><span class="s1">state.records.registeredIds[id] = </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">state.records.nodes[id] = {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n    </span><span class="s1">edges: [],</span><span class="s3">\n    </span><span class="s1">in: parent</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addJunction</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getJunctions = /* @__PURE__ */ __name(() =&gt; Object.values(state.records.nodes).filter(isArchitectureJunction), </span><span class="s3">\&quot;</span><span class="s1">getJunctions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getNodes = /* @__PURE__ */ __name(() =&gt; Object.values(state.records.nodes), </span><span class="s3">\&quot;</span><span class="s1">getNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getNode = /* @__PURE__ */ __name((id) =&gt; state.records.nodes[id], </span><span class="s3">\&quot;</span><span class="s1">getNode</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var addGroup = /* @__PURE__ */ __name(function({ id, icon, in: parent, title }) {</span><span class="s3">\n  </span><span class="s1">if (state.records.registeredIds[id] !== void 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (parent !== void 0) {</span><span class="s3">\n    </span><span class="s1">if (id === parent) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`The group [${id}] cannot be placed within itself`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.records.registeredIds[parent] === void 0) {</span><span class="s3">\n      </span><span class="s1">throw new Error(</span><span class="s3">\n        </span><span class="s1">`The group [${id}]'s parent does not exist. Please make sure the parent is created before this group`</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">if (state.records.registeredIds[parent] === </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">throw new Error(`The group [${id}]'s parent is not a group`);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">state.records.registeredIds[id] = </span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n  </span><span class="s1">state.records.groups[id] = {</span><span class="s3">\n    </span><span class="s1">id,</span><span class="s3">\n    </span><span class="s1">icon,</span><span class="s3">\n    </span><span class="s1">title,</span><span class="s3">\n    </span><span class="s1">in: parent</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addGroup</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getGroups = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">return Object.values(state.records.groups);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getGroups</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var addEdge = /* @__PURE__ */ __name(function({</span><span class="s3">\n  </span><span class="s1">lhsId,</span><span class="s3">\n  </span><span class="s1">rhsId,</span><span class="s3">\n  </span><span class="s1">lhsDir,</span><span class="s3">\n  </span><span class="s1">rhsDir,</span><span class="s3">\n  </span><span class="s1">lhsInto,</span><span class="s3">\n  </span><span class="s1">rhsInto,</span><span class="s3">\n  </span><span class="s1">lhsGroup,</span><span class="s3">\n  </span><span class="s1">rhsGroup,</span><span class="s3">\n  </span><span class="s1">title</span><span class="s3">\n</span><span class="s1">}) {</span><span class="s3">\n  </span><span class="s1">if (!isArchitectureDirection(lhsDir)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (!isArchitectureDirection(rhsDir)) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (state.records.nodes[lhsId] === void 0 &amp;&amp; state.records.groups[lhsId] === void 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (state.records.nodes[rhsId] === void 0 &amp;&amp; state.records.groups[lhsId] === void 0) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const lhsGroupId = state.records.nodes[lhsId].in;</span><span class="s3">\n  </span><span class="s1">const rhsGroupId = state.records.nodes[rhsId].in;</span><span class="s3">\n  </span><span class="s1">if (lhsGroup &amp;&amp; lhsGroupId &amp;&amp; rhsGroupId &amp;&amp; lhsGroupId == rhsGroupId) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (rhsGroup &amp;&amp; lhsGroupId &amp;&amp; rhsGroupId &amp;&amp; lhsGroupId == rhsGroupId) {</span><span class="s3">\n    </span><span class="s1">throw new Error(</span><span class="s3">\n      </span><span class="s1">`The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">const edge = {</span><span class="s3">\n    </span><span class="s1">lhsId,</span><span class="s3">\n    </span><span class="s1">lhsDir,</span><span class="s3">\n    </span><span class="s1">lhsInto,</span><span class="s3">\n    </span><span class="s1">lhsGroup,</span><span class="s3">\n    </span><span class="s1">rhsId,</span><span class="s3">\n    </span><span class="s1">rhsDir,</span><span class="s3">\n    </span><span class="s1">rhsInto,</span><span class="s3">\n    </span><span class="s1">rhsGroup,</span><span class="s3">\n    </span><span class="s1">title</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">state.records.edges.push(edge);</span><span class="s3">\n  </span><span class="s1">if (state.records.nodes[lhsId] &amp;&amp; state.records.nodes[rhsId]) {</span><span class="s3">\n    </span><span class="s1">state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);</span><span class="s3">\n    </span><span class="s1">state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">addEdge</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getEdges = /* @__PURE__ */ __name(() =&gt; state.records.edges, </span><span class="s3">\&quot;</span><span class="s1">getEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getDataStructures = /* @__PURE__ */ __name(() =&gt; {</span><span class="s3">\n  </span><span class="s1">if (state.records.dataStructures === void 0) {</span><span class="s3">\n    </span><span class="s1">const groupAlignments = {};</span><span class="s3">\n    </span><span class="s1">const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service]) =&gt; {</span><span class="s3">\n      </span><span class="s1">prevOuter[id] = service.edges.reduce((prevInner, edge) =&gt; {</span><span class="s3">\n        </span><span class="s1">const lhsGroupId = getNode(edge.lhsId)?.in;</span><span class="s3">\n        </span><span class="s1">const rhsGroupId = getNode(edge.rhsId)?.in;</span><span class="s3">\n        </span><span class="s1">if (lhsGroupId &amp;&amp; rhsGroupId &amp;&amp; lhsGroupId !== rhsGroupId) {</span><span class="s3">\n          </span><span class="s1">const alignment = getArchitectureDirectionAlignment(edge.lhsDir, edge.rhsDir);</span><span class="s3">\n          </span><span class="s1">if (alignment !== </span><span class="s3">\&quot;</span><span class="s1">bend</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">groupAlignments[lhsGroupId] ??= {};</span><span class="s3">\n            </span><span class="s1">groupAlignments[lhsGroupId][rhsGroupId] = alignment;</span><span class="s3">\n            </span><span class="s1">groupAlignments[rhsGroupId] ??= {};</span><span class="s3">\n            </span><span class="s1">groupAlignments[rhsGroupId][lhsGroupId] = alignment;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (edge.lhsId === id) {</span><span class="s3">\n          </span><span class="s1">const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);</span><span class="s3">\n          </span><span class="s1">if (pair) {</span><span class="s3">\n            </span><span class="s1">prevInner[pair] = edge.rhsId;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);</span><span class="s3">\n          </span><span class="s1">if (pair) {</span><span class="s3">\n            </span><span class="s1">prevInner[pair] = edge.lhsId;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prevInner;</span><span class="s3">\n      </span><span class="s1">}, {});</span><span class="s3">\n      </span><span class="s1">return prevOuter;</span><span class="s3">\n    </span><span class="s1">}, {});</span><span class="s3">\n    </span><span class="s1">const firstId = Object.keys(adjList)[0];</span><span class="s3">\n    </span><span class="s1">const visited = { [firstId]: 1 };</span><span class="s3">\n    </span><span class="s1">const notVisited = Object.keys(adjList).reduce(</span><span class="s3">\n      </span><span class="s1">(prev, id) =&gt; id === firstId ? prev : { ...prev, [id]: 1 },</span><span class="s3">\n      </span><span class="s1">{}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const BFS = /* @__PURE__ */ __name((startingId) =&gt; {</span><span class="s3">\n      </span><span class="s1">const spatialMap = { [startingId]: [0, 0] };</span><span class="s3">\n      </span><span class="s1">const queue = [startingId];</span><span class="s3">\n      </span><span class="s1">while (queue.length &gt; 0) {</span><span class="s3">\n        </span><span class="s1">const id = queue.shift();</span><span class="s3">\n        </span><span class="s1">if (id) {</span><span class="s3">\n          </span><span class="s1">visited[id] = 1;</span><span class="s3">\n          </span><span class="s1">delete notVisited[id];</span><span class="s3">\n          </span><span class="s1">const adj = adjList[id];</span><span class="s3">\n          </span><span class="s1">const [posX, posY] = spatialMap[id];</span><span class="s3">\n          </span><span class="s1">Object.entries(adj).forEach(([dir, rhsId]) =&gt; {</span><span class="s3">\n            </span><span class="s1">if (!visited[rhsId]) {</span><span class="s3">\n              </span><span class="s1">spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair(</span><span class="s3">\n                </span><span class="s1">[posX, posY],</span><span class="s3">\n                </span><span class="s1">dir</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n              </span><span class="s1">queue.push(rhsId);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">return spatialMap;</span><span class="s3">\n    </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">BFS</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const spatialMaps = [BFS(firstId)];</span><span class="s3">\n    </span><span class="s1">while (Object.keys(notVisited).length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">spatialMaps.push(BFS(Object.keys(notVisited)[0]));</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">state.records.dataStructures = {</span><span class="s3">\n      </span><span class="s1">adjList,</span><span class="s3">\n      </span><span class="s1">spatialMaps,</span><span class="s3">\n      </span><span class="s1">groupAlignments</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return state.records.dataStructures;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">getDataStructures</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var setElementForId = /* @__PURE__ */ __name((id, element) =&gt; {</span><span class="s3">\n  </span><span class="s1">state.records.elements[id] = element;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">setElementForId</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var getElementById = /* @__PURE__ */ __name((id) =&gt; state.records.elements[id], </span><span class="s3">\&quot;</span><span class="s1">getElementById</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var db = {</span><span class="s3">\n  </span><span class="s1">clear: clear2,</span><span class="s3">\n  </span><span class="s1">setDiagramTitle,</span><span class="s3">\n  </span><span class="s1">getDiagramTitle,</span><span class="s3">\n  </span><span class="s1">setAccTitle,</span><span class="s3">\n  </span><span class="s1">getAccTitle,</span><span class="s3">\n  </span><span class="s1">setAccDescription,</span><span class="s3">\n  </span><span class="s1">getAccDescription,</span><span class="s3">\n  </span><span class="s1">addService,</span><span class="s3">\n  </span><span class="s1">getServices,</span><span class="s3">\n  </span><span class="s1">addJunction,</span><span class="s3">\n  </span><span class="s1">getJunctions,</span><span class="s3">\n  </span><span class="s1">getNodes,</span><span class="s3">\n  </span><span class="s1">getNode,</span><span class="s3">\n  </span><span class="s1">addGroup,</span><span class="s3">\n  </span><span class="s1">getGroups,</span><span class="s3">\n  </span><span class="s1">addEdge,</span><span class="s3">\n  </span><span class="s1">getEdges,</span><span class="s3">\n  </span><span class="s1">setElementForId,</span><span class="s3">\n  </span><span class="s1">getElementById,</span><span class="s3">\n  </span><span class="s1">getDataStructures</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">function getConfigField(field) {</span><span class="s3">\n  </span><span class="s1">const arch = getConfig().architecture;</span><span class="s3">\n  </span><span class="s1">if (arch?.[field]) {</span><span class="s3">\n    </span><span class="s1">return arch[field];</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return DEFAULT_ARCHITECTURE_CONFIG[field];</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(getConfigField, </span><span class="s3">\&quot;</span><span class="s1">getConfigField</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureParser.ts</span><span class="s3">\n</span><span class="s1">var populateDb = /* @__PURE__ */ __name((ast, db2) =&gt; {</span><span class="s3">\n  </span><span class="s1">populateCommonDb(ast, db2);</span><span class="s3">\n  </span><span class="s1">ast.groups.map(db2.addGroup);</span><span class="s3">\n  </span><span class="s1">ast.services.map((service) =&gt; db2.addService({ ...service, type: </span><span class="s3">\&quot;</span><span class="s1">service</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">ast.junctions.map((service) =&gt; db2.addJunction({ ...service, type: </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot; </span><span class="s1">}));</span><span class="s3">\n  </span><span class="s1">ast.edges.map(db2.addEdge);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">populateDb</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var parser = {</span><span class="s3">\n  </span><span class="s1">parse: /* @__PURE__ */ __name(async (input) =&gt; {</span><span class="s3">\n    </span><span class="s1">const ast = await parse(</span><span class="s3">\&quot;</span><span class="s1">architecture</span><span class="s3">\&quot;</span><span class="s1">, input);</span><span class="s3">\n    </span><span class="s1">log.debug(ast);</span><span class="s3">\n    </span><span class="s1">populateDb(ast, db);</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">parse</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureStyles.ts</span><span class="s3">\n</span><span class="s1">var getStyles = /* @__PURE__ */ __name((options) =&gt; `</span><span class="s3">\n  </span><span class="s1">.edge {</span><span class="s3">\n    </span><span class="s1">stroke-width: ${options.archEdgeWidth};</span><span class="s3">\n    </span><span class="s1">stroke: ${options.archEdgeColor};</span><span class="s3">\n    </span><span class="s1">fill: none;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">.arrow {</span><span class="s3">\n    </span><span class="s1">fill: ${options.archEdgeArrowColor};</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n\n  </span><span class="s1">.node-bkg {</span><span class="s3">\n    </span><span class="s1">fill: none;</span><span class="s3">\n    </span><span class="s1">stroke: ${options.archGroupBorderColor};</span><span class="s3">\n    </span><span class="s1">stroke-width: ${options.archGroupBorderWidth};</span><span class="s3">\n    </span><span class="s1">stroke-dasharray: 8;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">.node-icon-text {</span><span class="s3">\n    </span><span class="s1">display: flex; </span><span class="s3">\n    </span><span class="s1">align-items: center;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  \n  </span><span class="s1">.node-icon-text &gt; div {</span><span class="s3">\n    </span><span class="s1">color: #fff;</span><span class="s3">\n    </span><span class="s1">margin: 1px;</span><span class="s3">\n    </span><span class="s1">height: fit-content;</span><span class="s3">\n    </span><span class="s1">text-align: center;</span><span class="s3">\n    </span><span class="s1">overflow: hidden;</span><span class="s3">\n    </span><span class="s1">display: -webkit-box;</span><span class="s3">\n    </span><span class="s1">-webkit-box-orient: vertical;</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">`, </span><span class="s3">\&quot;</span><span class="s1">getStyles</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var architectureStyles_default = getStyles;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureRenderer.ts</span><span class="s3">\n</span><span class="s1">import cytoscape from </span><span class="s3">\&quot;</span><span class="s1">cytoscape</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import fcose from </span><span class="s3">\&quot;</span><span class="s1">cytoscape-fcose</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n</span><span class="s1">import { select } from </span><span class="s3">\&quot;</span><span class="s1">d3</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureIcons.ts</span><span class="s3">\n</span><span class="s1">var wrapIcon = /* @__PURE__ */ __name((icon) =&gt; {</span><span class="s3">\n  </span><span class="s1">return `&lt;g&gt;&lt;rect width=</span><span class="s3">\&quot;</span><span class="s1">80</span><span class="s3">\&quot; </span><span class="s1">height=</span><span class="s3">\&quot;</span><span class="s1">80</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #087ebf; stroke-width: 0px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;${icon}&lt;/g&gt;`;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">wrapIcon</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var architectureIcons = {</span><span class="s3">\n  </span><span class="s1">prefix: </span><span class="s3">\&quot;</span><span class="s1">mermaid-architecture</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n  </span><span class="s1">height: 80,</span><span class="s3">\n  </span><span class="s1">width: 80,</span><span class="s3">\n  </span><span class="s1">icons: {</span><span class="s3">\n    </span><span class="s1">database: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\n        </span><span class="s1">'&lt;path id=</span><span class="s3">\&quot;</span><span class="s1">b</span><span class="s3">\&quot; </span><span class="s1">data-name=</span><span class="s3">\&quot;</span><span class="s1">4</span><span class="s3">\&quot; </span><span class="s1">d=</span><span class="s3">\&quot;</span><span class="s1">m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path id=</span><span class="s3">\&quot;</span><span class="s1">c</span><span class="s3">\&quot; </span><span class="s1">data-name=</span><span class="s3">\&quot;</span><span class="s1">3</span><span class="s3">\&quot; </span><span class="s1">d=</span><span class="s3">\&quot;</span><span class="s1">m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path id=</span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot; </span><span class="s1">data-name=</span><span class="s3">\&quot;</span><span class="s1">2</span><span class="s3">\&quot; </span><span class="s1">d=</span><span class="s3">\&quot;</span><span class="s1">m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse id=</span><span class="s3">\&quot;</span><span class="s1">e</span><span class="s3">\&quot; </span><span class="s1">data-name=</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">cx=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">22.14</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">7.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">57.86</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">22.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">60</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">57.86</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">60</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">22.14</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">server: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\n        </span><span class="s1">'&lt;rect x=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">y=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">width=</span><span class="s3">\&quot;</span><span class="s1">45</span><span class="s3">\&quot; </span><span class="s1">height=</span><span class="s3">\&quot;</span><span class="s1">45</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">2</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">2</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">32.5</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">62.5</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">32.5</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">47.5</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">62.5</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">47.5</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;g&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke-width: 0px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;&lt;g&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke-width: 0px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;&lt;g&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke-width: 0px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;&lt;g&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">32.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">25</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">27.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">25</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">22.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">25</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;&lt;g&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">32.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">27.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">22.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;&lt;g&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">32.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">55</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">27.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">55</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">22.5</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">55</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">.75</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;/g&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">disk: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\n        </span><span class="s1">'&lt;rect x=</span><span class="s3">\&quot;</span><span class="s1">20</span><span class="s3">\&quot; </span><span class="s1">y=</span><span class="s3">\&quot;</span><span class="s1">15</span><span class="s3">\&quot; </span><span class="s1">width=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">height=</span><span class="s3">\&quot;</span><span class="s1">50</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">1</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">24</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">19.17</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">.8</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">.83</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">56</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">19.17</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">.8</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">.83</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">24</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">60.83</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">.8</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">.83</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">56</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">60.83</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">.8</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">.83</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">33.75</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">14</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">14.58</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;ellipse cx=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">33.75</span><span class="s3">\&quot; </span><span class="s1">rx=</span><span class="s3">\&quot;</span><span class="s1">4</span><span class="s3">\&quot; </span><span class="s1">ry=</span><span class="s3">\&quot;</span><span class="s1">4.17</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: #fff; stroke-width: 0px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">internet: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\n        </span><span class="s1">'&lt;circle cx=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">cy=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">r=</span><span class="s3">\&quot;</span><span class="s1">22.5</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">62.5</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">17.5</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">62.5</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">40</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">19.75</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">30.1</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">60.25</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">30.1</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;&lt;line x1=</span><span class="s3">\&quot;</span><span class="s1">19.75</span><span class="s3">\&quot; </span><span class="s1">y1=</span><span class="s3">\&quot;</span><span class="s1">49.9</span><span class="s3">\&quot; </span><span class="s1">x2=</span><span class="s3">\&quot;</span><span class="s1">60.25</span><span class="s3">\&quot; </span><span class="s1">y2=</span><span class="s3">\&quot;</span><span class="s1">49.9</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">cloud: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\n        </span><span class="s1">'&lt;path d=</span><span class="s3">\&quot;</span><span class="s1">m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z</span><span class="s3">\&quot; </span><span class="s1">style=</span><span class="s3">\&quot;</span><span class="s1">fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;</span><span class="s3">\&quot;</span><span class="s1">/&gt;'</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">unknown: unknownIcon,</span><span class="s3">\n    </span><span class="s1">blank: {</span><span class="s3">\n      </span><span class="s1">body: wrapIcon(</span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/svgDraw.ts</span><span class="s3">\n</span><span class="s1">var drawEdges = /* @__PURE__ */ __name(async function(edgesEl, cy) {</span><span class="s3">\n  </span><span class="s1">const padding = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">padding</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const iconSize = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const halfIconSize = iconSize / 2;</span><span class="s3">\n  </span><span class="s1">const arrowSize = iconSize / 6;</span><span class="s3">\n  </span><span class="s1">const halfArrowSize = arrowSize / 2;</span><span class="s3">\n  </span><span class="s1">await Promise.all(</span><span class="s3">\n    </span><span class="s1">cy.edges().map(async (edge) =&gt; {</span><span class="s3">\n      </span><span class="s1">const {</span><span class="s3">\n        </span><span class="s1">source,</span><span class="s3">\n        </span><span class="s1">sourceDir,</span><span class="s3">\n        </span><span class="s1">sourceArrow,</span><span class="s3">\n        </span><span class="s1">sourceGroup,</span><span class="s3">\n        </span><span class="s1">target,</span><span class="s3">\n        </span><span class="s1">targetDir,</span><span class="s3">\n        </span><span class="s1">targetArrow,</span><span class="s3">\n        </span><span class="s1">targetGroup,</span><span class="s3">\n        </span><span class="s1">label</span><span class="s3">\n      </span><span class="s1">} = edgeData(edge);</span><span class="s3">\n      </span><span class="s1">let { x: startX, y: startY } = edge[0].sourceEndpoint();</span><span class="s3">\n      </span><span class="s1">const { x: midX, y: midY } = edge[0].midpoint();</span><span class="s3">\n      </span><span class="s1">let { x: endX, y: endY } = edge[0].targetEndpoint();</span><span class="s3">\n      </span><span class="s1">const groupEdgeShift = padding + 4;</span><span class="s3">\n      </span><span class="s1">if (sourceGroup) {</span><span class="s3">\n        </span><span class="s1">if (isArchitectureDirectionX(sourceDir)) {</span><span class="s3">\n          </span><span class="s1">startX += sourceDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? -groupEdgeShift : groupEdgeShift;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">startY += sourceDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? -groupEdgeShift : groupEdgeShift + 18;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (targetGroup) {</span><span class="s3">\n        </span><span class="s1">if (isArchitectureDirectionX(targetDir)) {</span><span class="s3">\n          </span><span class="s1">endX += targetDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? -groupEdgeShift : groupEdgeShift;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">endY += targetDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? -groupEdgeShift : groupEdgeShift + 18;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!sourceGroup &amp;&amp; db.getNode(source)?.type === </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (isArchitectureDirectionX(sourceDir)) {</span><span class="s3">\n          </span><span class="s1">startX += sourceDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? halfIconSize : -halfIconSize;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">startY += sourceDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? halfIconSize : -halfIconSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (!targetGroup &amp;&amp; db.getNode(target)?.type === </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">if (isArchitectureDirectionX(targetDir)) {</span><span class="s3">\n          </span><span class="s1">endX += targetDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? halfIconSize : -halfIconSize;</span><span class="s3">\n        </span><span class="s1">} else {</span><span class="s3">\n          </span><span class="s1">endY += targetDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? halfIconSize : -halfIconSize;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">if (edge[0]._private.rscratch) {</span><span class="s3">\n        </span><span class="s1">const g = edgesEl.insert(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">g.insert(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">, `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">edge</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">if (sourceArrow) {</span><span class="s3">\n          </span><span class="s1">const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;</span><span class="s3">\n          </span><span class="s1">const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;</span><span class="s3">\n          </span><span class="s1">g.insert(</span><span class="s3">\&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">points</span><span class="s3">\&quot;</span><span class="s1">, ArchitectureDirectionArrow[sourceDir](arrowSize)).attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, `translate(${xShift},${yShift})`).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arrow</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (targetArrow) {</span><span class="s3">\n          </span><span class="s1">const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;</span><span class="s3">\n          </span><span class="s1">const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;</span><span class="s3">\n          </span><span class="s1">g.insert(</span><span class="s3">\&quot;</span><span class="s1">polygon</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">points</span><span class="s3">\&quot;</span><span class="s1">, ArchitectureDirectionArrow[targetDir](arrowSize)).attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, `translate(${xShift},${yShift})`).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">arrow</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (label) {</span><span class="s3">\n          </span><span class="s1">const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? </span><span class="s3">\&quot;</span><span class="s1">X</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">Y</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">XY</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n          </span><span class="s1">let width = 0;</span><span class="s3">\n          </span><span class="s1">if (axis === </span><span class="s3">\&quot;</span><span class="s1">X</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">width = Math.abs(startX - endX);</span><span class="s3">\n          </span><span class="s1">} else if (axis === </span><span class="s3">\&quot;</span><span class="s1">Y</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">width = Math.abs(startY - endY) / 1.5;</span><span class="s3">\n          </span><span class="s1">} else {</span><span class="s3">\n            </span><span class="s1">width = Math.abs(startX - endX) / 2;</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">const textElem = g.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">await createText(</span><span class="s3">\n            </span><span class="s1">textElem,</span><span class="s3">\n            </span><span class="s1">label,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">useHtmlLabels: false,</span><span class="s3">\n              </span><span class="s1">width,</span><span class="s3">\n              </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">architecture-service-label</span><span class="s3">\&quot;\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">getConfig()</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">dy</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">1em</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">alignment-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">dominant-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">text-anchor</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">if (axis === </span><span class="s3">\&quot;</span><span class="s1">X</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ midX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ midY + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else if (axis === </span><span class="s3">\&quot;</span><span class="s1">Y</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ midX + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ midY + </span><span class="s3">\&quot;</span><span class="s1">) rotate(-90)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">} else if (axis === </span><span class="s3">\&quot;</span><span class="s1">XY</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n            </span><span class="s1">const pair = getArchitectureDirectionPair(sourceDir, targetDir);</span><span class="s3">\n            </span><span class="s1">if (pair &amp;&amp; isArchitecturePairXY(pair)) {</span><span class="s3">\n              </span><span class="s1">const bboxOrig = textElem.node().getBoundingClientRect();</span><span class="s3">\n              </span><span class="s1">const [x, y] = getArchitectureDirectionXYFactors(pair);</span><span class="s3">\n              </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">dominant-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">auto</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, `rotate(${-1 * x * y * 45})`);</span><span class="s3">\n              </span><span class="s1">const bboxNew = textElem.node().getBoundingClientRect();</span><span class="s3">\n              </span><span class="s1">textElem.attr(</span><span class="s3">\n                \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n                </span><span class="s1">`</span><span class="s3">\n                </span><span class="s1">translate(${midX}, ${midY - bboxOrig.height / 2})</span><span class="s3">\n                </span><span class="s1">translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})</span><span class="s3">\n                </span><span class="s1">rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})</span><span class="s3">\n              </span><span class="s1">`</span><span class="s3">\n              </span><span class="s1">);</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">drawEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var drawGroups = /* @__PURE__ */ __name(async function(groupsEl, cy) {</span><span class="s3">\n  </span><span class="s1">const padding = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">padding</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const groupIconSize = padding * 0.75;</span><span class="s3">\n  </span><span class="s1">const fontSize = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">fontSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const iconSize = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const halfIconSize = iconSize / 2;</span><span class="s3">\n  </span><span class="s1">await Promise.all(</span><span class="s3">\n    </span><span class="s1">cy.nodes().map(async (node) =&gt; {</span><span class="s3">\n      </span><span class="s1">const data = nodeData(node);</span><span class="s3">\n      </span><span class="s1">if (data.type === </span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n        </span><span class="s1">const { h, w, x1, y1 } = node.boundingBox();</span><span class="s3">\n        </span><span class="s1">groupsEl.append(</span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">x</span><span class="s3">\&quot;</span><span class="s1">, x1 + halfIconSize).attr(</span><span class="s3">\&quot;</span><span class="s1">y</span><span class="s3">\&quot;</span><span class="s1">, y1 + halfIconSize).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, w).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, h).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">const groupLabelContainer = groupsEl.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">let shiftedX1 = x1;</span><span class="s3">\n        </span><span class="s1">let shiftedY1 = y1;</span><span class="s3">\n        </span><span class="s1">if (data.icon) {</span><span class="s3">\n          </span><span class="s1">const bkgElem = groupLabelContainer.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">bkgElem.html(</span><span class="s3">\n            </span><span class="s1">`&lt;g&gt;${await getIconSVG(data.icon, { height: groupIconSize, width: groupIconSize, fallbackPrefix: architectureIcons.prefix })}&lt;/g&gt;`</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">bkgElem.attr(</span><span class="s3">\n            \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ (shiftedX1 + halfIconSize + 1) + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ (shiftedY1 + halfIconSize + 1) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">shiftedX1 += groupIconSize;</span><span class="s3">\n          </span><span class="s1">shiftedY1 += fontSize / 2 - 1 - 2;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">if (data.label) {</span><span class="s3">\n          </span><span class="s1">const textElem = groupLabelContainer.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">await createText(</span><span class="s3">\n            </span><span class="s1">textElem,</span><span class="s3">\n            </span><span class="s1">data.label,</span><span class="s3">\n            </span><span class="s1">{</span><span class="s3">\n              </span><span class="s1">useHtmlLabels: false,</span><span class="s3">\n              </span><span class="s1">width: w,</span><span class="s3">\n              </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">architecture-service-label</span><span class="s3">\&quot;\n            </span><span class="s1">},</span><span class="s3">\n            </span><span class="s1">getConfig()</span><span class="s3">\n          </span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">dy</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">1em</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">alignment-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">dominant-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">text-anchor</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">start</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n          </span><span class="s1">textElem.attr(</span><span class="s3">\n            \&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ (shiftedX1 + halfIconSize + 4) + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ (shiftedY1 + halfIconSize + 2) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;\n          </span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">})</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">drawGroups</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var drawServices = /* @__PURE__ */ __name(async function(db2, elem, services) {</span><span class="s3">\n  </span><span class="s1">for (const service of services) {</span><span class="s3">\n    </span><span class="s1">const serviceElem = elem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const iconSize = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (service.title) {</span><span class="s3">\n      </span><span class="s1">const textElem = serviceElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">await createText(</span><span class="s3">\n        </span><span class="s1">textElem,</span><span class="s3">\n        </span><span class="s1">service.title,</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">useHtmlLabels: false,</span><span class="s3">\n          </span><span class="s1">width: iconSize * 1.5,</span><span class="s3">\n          </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">architecture-service-label</span><span class="s3">\&quot;\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">getConfig()</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">dy</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">1em</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">alignment-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">dominant-baseline</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">text-anchor</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">middle</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">textElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ iconSize / 2 + </span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot; </span><span class="s1">+ iconSize + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">const bkgElem = serviceElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">if (service.icon) {</span><span class="s3">\n      </span><span class="s1">bkgElem.html(</span><span class="s3">\n        </span><span class="s1">`&lt;g&gt;${await getIconSVG(service.icon, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}&lt;/g&gt;`</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">} else if (service.iconText) {</span><span class="s3">\n      </span><span class="s1">bkgElem.html(</span><span class="s3">\n        </span><span class="s1">`&lt;g&gt;${await getIconSVG(</span><span class="s3">\&quot;</span><span class="s1">blank</span><span class="s3">\&quot;</span><span class="s1">, { height: iconSize, width: iconSize, fallbackPrefix: architectureIcons.prefix })}&lt;/g&gt;`</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const textElemContainer = bkgElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">const fo = textElemContainer.append(</span><span class="s3">\&quot;</span><span class="s1">foreignObject</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, iconSize).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, iconSize);</span><span class="s3">\n      </span><span class="s1">const divElem = fo.append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-icon-text</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, `height: ${iconSize}px;`).append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).html(service.iconText);</span><span class="s3">\n      </span><span class="s1">const fontSize = parseInt(</span><span class="s3">\n        </span><span class="s1">window.getComputedStyle(divElem.node(), null).getPropertyValue(</span><span class="s3">\&quot;</span><span class="s1">font-size</span><span class="s3">\&quot;</span><span class="s1">).replace(/</span><span class="s3">\\</span><span class="s1">D/g, </span><span class="s3">\&quot;\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">) ?? 16;</span><span class="s3">\n      </span><span class="s1">divElem.attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);</span><span class="s3">\n    </span><span class="s1">} else {</span><span class="s3">\n      </span><span class="s1">bkgElem.append(</span><span class="s3">\&quot;</span><span class="s1">path</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-bkg</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ service.id).attr(</span><span class="s3">\n        \&quot;</span><span class="s1">d</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">`M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`</span><span class="s3">\n      </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">serviceElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">architecture-service</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const { width, height } = serviceElem._groups[0][0].getBBox();</span><span class="s3">\n    </span><span class="s1">service.width = width;</span><span class="s3">\n    </span><span class="s1">service.height = height;</span><span class="s3">\n    </span><span class="s1">db2.setElementForId(service.id, serviceElem);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">return 0;</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">drawServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var drawJunctions = /* @__PURE__ */ __name(function(db2, elem, junctions) {</span><span class="s3">\n  </span><span class="s1">junctions.forEach((junction) =&gt; {</span><span class="s3">\n    </span><span class="s1">const junctionElem = elem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const iconSize = getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const bkgElem = junctionElem.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">bkgElem.append(</span><span class="s3">\&quot;</span><span class="s1">rect</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">node-</span><span class="s3">\&quot; </span><span class="s1">+ junction.id).attr(</span><span class="s3">\&quot;</span><span class="s1">fill-opacity</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">width</span><span class="s3">\&quot;</span><span class="s1">, iconSize).attr(</span><span class="s3">\&quot;</span><span class="s1">height</span><span class="s3">\&quot;</span><span class="s1">, iconSize);</span><span class="s3">\n    </span><span class="s1">junctionElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">architecture-junction</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const { width, height } = junctionElem._groups[0][0].getBBox();</span><span class="s3">\n    </span><span class="s1">junctionElem.width = width;</span><span class="s3">\n    </span><span class="s1">junctionElem.height = height;</span><span class="s3">\n    </span><span class="s1">db2.setElementForId(junction.id, junctionElem);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">drawJunctions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureRenderer.ts</span><span class="s3">\n</span><span class="s1">registerIconPacks([</span><span class="s3">\n  </span><span class="s1">{</span><span class="s3">\n    </span><span class="s1">name: architectureIcons.prefix,</span><span class="s3">\n    </span><span class="s1">icons: architectureIcons</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">]);</span><span class="s3">\n</span><span class="s1">cytoscape.use(fcose);</span><span class="s3">\n</span><span class="s1">function addServices(services, cy) {</span><span class="s3">\n  </span><span class="s1">services.forEach((service) =&gt; {</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">service</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">id: service.id,</span><span class="s3">\n        </span><span class="s1">icon: service.icon,</span><span class="s3">\n        </span><span class="s1">label: service.title,</span><span class="s3">\n        </span><span class="s1">parent: service.in,</span><span class="s3">\n        </span><span class="s1">width: getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">height: getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">node-service</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(addServices, </span><span class="s3">\&quot;</span><span class="s1">addServices</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function addJunctions(junctions, cy) {</span><span class="s3">\n  </span><span class="s1">junctions.forEach((junction) =&gt; {</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">junction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">id: junction.id,</span><span class="s3">\n        </span><span class="s1">parent: junction.in,</span><span class="s3">\n        </span><span class="s1">width: getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n        </span><span class="s1">height: getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">node-junction</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(addJunctions, </span><span class="s3">\&quot;</span><span class="s1">addJunctions</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function positionNodes(db2, cy) {</span><span class="s3">\n  </span><span class="s1">cy.nodes().map((node) =&gt; {</span><span class="s3">\n    </span><span class="s1">const data = nodeData(node);</span><span class="s3">\n    </span><span class="s1">if (data.type === </span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n      </span><span class="s1">return;</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">data.x = node.position().x;</span><span class="s3">\n    </span><span class="s1">data.y = node.position().y;</span><span class="s3">\n    </span><span class="s1">const nodeElem = db2.getElementById(data.id);</span><span class="s3">\n    </span><span class="s1">nodeElem.attr(</span><span class="s3">\&quot;</span><span class="s1">transform</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">translate(</span><span class="s3">\&quot; </span><span class="s1">+ (data.x || 0) + </span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot; </span><span class="s1">+ (data.y || 0) + </span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(positionNodes, </span><span class="s3">\&quot;</span><span class="s1">positionNodes</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function addGroups(groups, cy) {</span><span class="s3">\n  </span><span class="s1">groups.forEach((group) =&gt; {</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">nodes</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">data: {</span><span class="s3">\n        </span><span class="s1">type: </span><span class="s3">\&quot;</span><span class="s1">group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n        </span><span class="s1">id: group.id,</span><span class="s3">\n        </span><span class="s1">icon: group.icon,</span><span class="s3">\n        </span><span class="s1">label: group.title,</span><span class="s3">\n        </span><span class="s1">parent: group.in</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">classes: </span><span class="s3">\&quot;</span><span class="s1">node-group</span><span class="s3">\&quot;\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(addGroups, </span><span class="s3">\&quot;</span><span class="s1">addGroups</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function addEdges(edges, cy) {</span><span class="s3">\n  </span><span class="s1">edges.forEach((parsedEdge) =&gt; {</span><span class="s3">\n    </span><span class="s1">const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;</span><span class="s3">\n    </span><span class="s1">const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? </span><span class="s3">\&quot;</span><span class="s1">segments</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">straight</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n    </span><span class="s1">const edge = {</span><span class="s3">\n      </span><span class="s1">id: `${lhsId}-${rhsId}`,</span><span class="s3">\n      </span><span class="s1">label: title,</span><span class="s3">\n      </span><span class="s1">source: lhsId,</span><span class="s3">\n      </span><span class="s1">sourceDir: lhsDir,</span><span class="s3">\n      </span><span class="s1">sourceArrow: lhsInto,</span><span class="s3">\n      </span><span class="s1">sourceGroup: lhsGroup,</span><span class="s3">\n      </span><span class="s1">sourceEndpoint: lhsDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">0 50%</span><span class="s3">\&quot; </span><span class="s1">: lhsDir === </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">100% 50%</span><span class="s3">\&quot; </span><span class="s1">: lhsDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">50% 0</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">50% 100%</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">target: rhsId,</span><span class="s3">\n      </span><span class="s1">targetDir: rhsDir,</span><span class="s3">\n      </span><span class="s1">targetArrow: rhsInto,</span><span class="s3">\n      </span><span class="s1">targetGroup: rhsGroup,</span><span class="s3">\n      </span><span class="s1">targetEndpoint: rhsDir === </span><span class="s3">\&quot;</span><span class="s1">L</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">0 50%</span><span class="s3">\&quot; </span><span class="s1">: rhsDir === </span><span class="s3">\&quot;</span><span class="s1">R</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">100% 50%</span><span class="s3">\&quot; </span><span class="s1">: rhsDir === </span><span class="s3">\&quot;</span><span class="s1">T</span><span class="s3">\&quot; </span><span class="s1">? </span><span class="s3">\&quot;</span><span class="s1">50% 0</span><span class="s3">\&quot; </span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">50% 100%</span><span class="s3">\&quot;\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">cy.add({</span><span class="s3">\n      </span><span class="s1">group: </span><span class="s3">\&quot;</span><span class="s1">edges</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">data: edge,</span><span class="s3">\n      </span><span class="s1">classes: edgeType</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(addEdges, </span><span class="s3">\&quot;</span><span class="s1">addEdges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function getAlignments(db2, spatialMaps, groupAlignments) {</span><span class="s3">\n  </span><span class="s1">const flattenAlignments = /* @__PURE__ */ __name((alignmentObj, alignmentDir) =&gt; {</span><span class="s3">\n    </span><span class="s1">return Object.entries(alignmentObj).reduce(</span><span class="s3">\n      </span><span class="s1">(prev, [dir, alignments2]) =&gt; {</span><span class="s3">\n        </span><span class="s1">let cnt = 0;</span><span class="s3">\n        </span><span class="s1">const arr = Object.entries(alignments2);</span><span class="s3">\n        </span><span class="s1">if (arr.length === 1) {</span><span class="s3">\n          </span><span class="s1">prev[dir] = arr[0][1];</span><span class="s3">\n          </span><span class="s1">return prev;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">for (let i = 0; i &lt; arr.length - 1; i++) {</span><span class="s3">\n          </span><span class="s1">for (let j = i + 1; j &lt; arr.length; j++) {</span><span class="s3">\n            </span><span class="s1">const [aGroupId, aNodeIds] = arr[i];</span><span class="s3">\n            </span><span class="s1">const [bGroupId, bNodeIds] = arr[j];</span><span class="s3">\n            </span><span class="s1">const alignment = groupAlignments[aGroupId]?.[bGroupId];</span><span class="s3">\n            </span><span class="s1">if (alignment === alignmentDir) {</span><span class="s3">\n              </span><span class="s1">prev[dir] ??= [];</span><span class="s3">\n              </span><span class="s1">prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];</span><span class="s3">\n            </span><span class="s1">} else if (aGroupId === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot; </span><span class="s1">|| bGroupId === </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">) {</span><span class="s3">\n              </span><span class="s1">prev[dir] ??= [];</span><span class="s3">\n              </span><span class="s1">prev[dir] = [...prev[dir], ...aNodeIds, ...bNodeIds];</span><span class="s3">\n            </span><span class="s1">} else {</span><span class="s3">\n              </span><span class="s1">const keyA = `${dir}-${cnt++}`;</span><span class="s3">\n              </span><span class="s1">prev[keyA] = aNodeIds;</span><span class="s3">\n              </span><span class="s1">const keyB = `${dir}-${cnt++}`;</span><span class="s3">\n              </span><span class="s1">prev[keyB] = bNodeIds;</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">return prev;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">{}</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">flattenAlignments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const alignments = spatialMaps.map((spatialMap) =&gt; {</span><span class="s3">\n    </span><span class="s1">const horizontalAlignments = {};</span><span class="s3">\n    </span><span class="s1">const verticalAlignments = {};</span><span class="s3">\n    </span><span class="s1">Object.entries(spatialMap).forEach(([id, [x, y]]) =&gt; {</span><span class="s3">\n      </span><span class="s1">const nodeGroup = db2.getNode(id)?.in ?? </span><span class="s3">\&quot;</span><span class="s1">default</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n      </span><span class="s1">horizontalAlignments[y] ??= {};</span><span class="s3">\n      </span><span class="s1">horizontalAlignments[y][nodeGroup] ??= [];</span><span class="s3">\n      </span><span class="s1">horizontalAlignments[y][nodeGroup].push(id);</span><span class="s3">\n      </span><span class="s1">verticalAlignments[x] ??= {};</span><span class="s3">\n      </span><span class="s1">verticalAlignments[x][nodeGroup] ??= [];</span><span class="s3">\n      </span><span class="s1">verticalAlignments[x][nodeGroup].push(id);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">return {</span><span class="s3">\n      </span><span class="s1">horiz: Object.values(flattenAlignments(horizontalAlignments, </span><span class="s3">\&quot;</span><span class="s1">horizontal</span><span class="s3">\&quot;</span><span class="s1">)).filter(</span><span class="s3">\n        </span><span class="s1">(arr) =&gt; arr.length &gt; 1</span><span class="s3">\n      </span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">vert: Object.values(flattenAlignments(verticalAlignments, </span><span class="s3">\&quot;</span><span class="s1">vertical</span><span class="s3">\&quot;</span><span class="s1">)).filter(</span><span class="s3">\n        </span><span class="s1">(arr) =&gt; arr.length &gt; 1</span><span class="s3">\n      </span><span class="s1">)</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">const [horizontal, vertical] = alignments.reduce(</span><span class="s3">\n    </span><span class="s1">([prevHoriz, prevVert], { horiz, vert }) =&gt; {</span><span class="s3">\n      </span><span class="s1">return [</span><span class="s3">\n        </span><span class="s1">[...prevHoriz, ...horiz],</span><span class="s3">\n        </span><span class="s1">[...prevVert, ...vert]</span><span class="s3">\n      </span><span class="s1">];</span><span class="s3">\n    </span><span class="s1">},</span><span class="s3">\n    </span><span class="s1">[[], []]</span><span class="s3">\n  </span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">return {</span><span class="s3">\n    </span><span class="s1">horizontal,</span><span class="s3">\n    </span><span class="s1">vertical</span><span class="s3">\n  </span><span class="s1">};</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(getAlignments, </span><span class="s3">\&quot;</span><span class="s1">getAlignments</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function getRelativeConstraints(spatialMaps) {</span><span class="s3">\n  </span><span class="s1">const relativeConstraints = [];</span><span class="s3">\n  </span><span class="s1">const posToStr = /* @__PURE__ */ __name((pos) =&gt; `${pos[0]},${pos[1]}`, </span><span class="s3">\&quot;</span><span class="s1">posToStr</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const strToPos = /* @__PURE__ */ __name((pos) =&gt; pos.split(</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\&quot;</span><span class="s1">).map((p) =&gt; parseInt(p)), </span><span class="s3">\&quot;</span><span class="s1">strToPos</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">spatialMaps.forEach((spatialMap) =&gt; {</span><span class="s3">\n    </span><span class="s1">const invSpatialMap = Object.fromEntries(</span><span class="s3">\n      </span><span class="s1">Object.entries(spatialMap).map(([id, pos]) =&gt; [posToStr(pos), id])</span><span class="s3">\n    </span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const queue = [posToStr([0, 0])];</span><span class="s3">\n    </span><span class="s1">const visited = {};</span><span class="s3">\n    </span><span class="s1">const directions = {</span><span class="s3">\n      </span><span class="s1">L: [-1, 0],</span><span class="s3">\n      </span><span class="s1">R: [1, 0],</span><span class="s3">\n      </span><span class="s1">T: [0, 1],</span><span class="s3">\n      </span><span class="s1">B: [0, -1]</span><span class="s3">\n    </span><span class="s1">};</span><span class="s3">\n    </span><span class="s1">while (queue.length &gt; 0) {</span><span class="s3">\n      </span><span class="s1">const curr = queue.shift();</span><span class="s3">\n      </span><span class="s1">if (curr) {</span><span class="s3">\n        </span><span class="s1">visited[curr] = 1;</span><span class="s3">\n        </span><span class="s1">const currId = invSpatialMap[curr];</span><span class="s3">\n        </span><span class="s1">if (currId) {</span><span class="s3">\n          </span><span class="s1">const currPos = strToPos(curr);</span><span class="s3">\n          </span><span class="s1">Object.entries(directions).forEach(([dir, shift]) =&gt; {</span><span class="s3">\n            </span><span class="s1">const newPos = posToStr([currPos[0] + shift[0], currPos[1] + shift[1]]);</span><span class="s3">\n            </span><span class="s1">const newId = invSpatialMap[newPos];</span><span class="s3">\n            </span><span class="s1">if (newId &amp;&amp; !visited[newPos]) {</span><span class="s3">\n              </span><span class="s1">queue.push(newPos);</span><span class="s3">\n              </span><span class="s1">relativeConstraints.push({</span><span class="s3">\n                </span><span class="s1">[ArchitectureDirectionName[dir]]: newId,</span><span class="s3">\n                </span><span class="s1">[ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,</span><span class="s3">\n                </span><span class="s1">gap: 1.5 * getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">)</span><span class="s3">\n              </span><span class="s1">});</span><span class="s3">\n            </span><span class="s1">}</span><span class="s3">\n          </span><span class="s1">});</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n    </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">return relativeConstraints;</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(getRelativeConstraints, </span><span class="s3">\&quot;</span><span class="s1">getRelativeConstraints</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">function layoutArchitecture(services, junctions, groups, edges, db2, { spatialMaps, groupAlignments }) {</span><span class="s3">\n  </span><span class="s1">return new Promise((resolve) =&gt; {</span><span class="s3">\n    </span><span class="s1">const renderEl = select(</span><span class="s3">\&quot;</span><span class="s1">body</span><span class="s3">\&quot;</span><span class="s1">).append(</span><span class="s3">\&quot;</span><span class="s1">div</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">id</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">cy</span><span class="s3">\&quot;</span><span class="s1">).attr(</span><span class="s3">\&quot;</span><span class="s1">style</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">display:none</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n    </span><span class="s1">const cy = cytoscape({</span><span class="s3">\n      </span><span class="s1">container: document.getElementById(</span><span class="s3">\&quot;</span><span class="s1">cy</span><span class="s3">\&quot;</span><span class="s1">),</span><span class="s3">\n      </span><span class="s1">style: [</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">edge</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            \&quot;</span><span class="s1">curve-style</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">straight</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">label: </span><span class="s3">\&quot;</span><span class="s1">data(label)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">source-endpoint</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">data(sourceEndpoint)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">target-endpoint</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">data(targetEndpoint)</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">edge.segments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            \&quot;</span><span class="s1">curve-style</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">segments</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">segment-weights</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">0</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">segment-distances</span><span class="s3">\&quot;</span><span class="s1">: [0.5],</span><span class="s3">\n            </span><span class="s1">// @ts-ignore Incorrect library types</span><span class="s3">\n            \&quot;</span><span class="s1">edge-distances</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">endpoints</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">source-endpoint</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">data(sourceEndpoint)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">target-endpoint</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">data(targetEndpoint)</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">node</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            </span><span class="s1">// @ts-ignore Incorrect library types</span><span class="s3">\n            \&quot;</span><span class="s1">compound-sizing-wrt-labels</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">include</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">node[label]</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            \&quot;</span><span class="s1">text-valign</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">bottom</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">text-halign</span><span class="s3">\&quot;</span><span class="s1">: </span><span class="s3">\&quot;</span><span class="s1">center</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            \&quot;</span><span class="s1">font-size</span><span class="s3">\&quot;</span><span class="s1">: `${getConfigField(</span><span class="s3">\&quot;</span><span class="s1">fontSize</span><span class="s3">\&quot;</span><span class="s1">)}px`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">.node-service</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            </span><span class="s1">label: </span><span class="s3">\&quot;</span><span class="s1">data(label)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">width: </span><span class="s3">\&quot;</span><span class="s1">data(width)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">data(height)</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">.node-junction</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            </span><span class="s1">width: </span><span class="s3">\&quot;</span><span class="s1">data(width)</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n            </span><span class="s1">height: </span><span class="s3">\&quot;</span><span class="s1">data(height)</span><span class="s3">\&quot;\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">},</span><span class="s3">\n        </span><span class="s1">{</span><span class="s3">\n          </span><span class="s1">selector: </span><span class="s3">\&quot;</span><span class="s1">.node-group</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n          </span><span class="s1">style: {</span><span class="s3">\n            </span><span class="s1">// @ts-ignore Incorrect library types</span><span class="s3">\n            </span><span class="s1">padding: `${getConfigField(</span><span class="s3">\&quot;</span><span class="s1">padding</span><span class="s3">\&quot;</span><span class="s1">)}px`</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">]</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">renderEl.remove();</span><span class="s3">\n    </span><span class="s1">addGroups(groups, cy);</span><span class="s3">\n    </span><span class="s1">addServices(services, cy);</span><span class="s3">\n    </span><span class="s1">addJunctions(junctions, cy);</span><span class="s3">\n    </span><span class="s1">addEdges(edges, cy);</span><span class="s3">\n    </span><span class="s1">const alignmentConstraint = getAlignments(db2, spatialMaps, groupAlignments);</span><span class="s3">\n    </span><span class="s1">const relativePlacementConstraint = getRelativeConstraints(spatialMaps);</span><span class="s3">\n    </span><span class="s1">const layout = cy.layout({</span><span class="s3">\n      </span><span class="s1">name: </span><span class="s3">\&quot;</span><span class="s1">fcose</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">quality: </span><span class="s3">\&quot;</span><span class="s1">proof</span><span class="s3">\&quot;</span><span class="s1">,</span><span class="s3">\n      </span><span class="s1">styleEnabled: false,</span><span class="s3">\n      </span><span class="s1">animate: false,</span><span class="s3">\n      </span><span class="s1">nodeDimensionsIncludeLabels: false,</span><span class="s3">\n      </span><span class="s1">// Adjust the edge parameters if it passes through the border of a group</span><span class="s3">\n      </span><span class="s1">// Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67</span><span class="s3">\n      </span><span class="s1">idealEdgeLength(edge) {</span><span class="s3">\n        </span><span class="s1">const [nodeA, nodeB] = edge.connectedNodes();</span><span class="s3">\n        </span><span class="s1">const { parent: parentA } = nodeData(nodeA);</span><span class="s3">\n        </span><span class="s1">const { parent: parentB } = nodeData(nodeB);</span><span class="s3">\n        </span><span class="s1">const elasticity = parentA === parentB ? 1.5 * getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">) : 0.5 * getConfigField(</span><span class="s3">\&quot;</span><span class="s1">iconSize</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n        </span><span class="s1">return elasticity;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">edgeElasticity(edge) {</span><span class="s3">\n        </span><span class="s1">const [nodeA, nodeB] = edge.connectedNodes();</span><span class="s3">\n        </span><span class="s1">const { parent: parentA } = nodeData(nodeA);</span><span class="s3">\n        </span><span class="s1">const { parent: parentB } = nodeData(nodeB);</span><span class="s3">\n        </span><span class="s1">const elasticity = parentA === parentB ? 0.45 : 1e-3;</span><span class="s3">\n        </span><span class="s1">return elasticity;</span><span class="s3">\n      </span><span class="s1">},</span><span class="s3">\n      </span><span class="s1">alignmentConstraint,</span><span class="s3">\n      </span><span class="s1">relativePlacementConstraint</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">layout.one(</span><span class="s3">\&quot;</span><span class="s1">layoutstop</span><span class="s3">\&quot;</span><span class="s1">, () =&gt; {</span><span class="s3">\n      </span><span class="s1">function getSegmentWeights(source, target, pointX, pointY) {</span><span class="s3">\n        </span><span class="s1">let W, D;</span><span class="s3">\n        </span><span class="s1">const { x: sX, y: sY } = source;</span><span class="s3">\n        </span><span class="s1">const { x: tX, y: tY } = target;</span><span class="s3">\n        </span><span class="s1">D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));</span><span class="s3">\n        </span><span class="s1">W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));</span><span class="s3">\n        </span><span class="s1">const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));</span><span class="s3">\n        </span><span class="s1">W = W / distAB;</span><span class="s3">\n        </span><span class="s1">let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);</span><span class="s3">\n        </span><span class="s1">switch (true) {</span><span class="s3">\n          </span><span class="s1">case delta1 &gt;= 0:</span><span class="s3">\n            </span><span class="s1">delta1 = 1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case delta1 &lt; 0:</span><span class="s3">\n            </span><span class="s1">delta1 = -1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);</span><span class="s3">\n        </span><span class="s1">switch (true) {</span><span class="s3">\n          </span><span class="s1">case delta2 &gt;= 0:</span><span class="s3">\n            </span><span class="s1">delta2 = 1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n          </span><span class="s1">case delta2 &lt; 0:</span><span class="s3">\n            </span><span class="s1">delta2 = -1;</span><span class="s3">\n            </span><span class="s1">break;</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">D = Math.abs(D) * delta1;</span><span class="s3">\n        </span><span class="s1">W = W * delta2;</span><span class="s3">\n        </span><span class="s1">return {</span><span class="s3">\n          </span><span class="s1">distances: D,</span><span class="s3">\n          </span><span class="s1">weights: W</span><span class="s3">\n        </span><span class="s1">};</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">__name(getSegmentWeights, </span><span class="s3">\&quot;</span><span class="s1">getSegmentWeights</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n      </span><span class="s1">cy.startBatch();</span><span class="s3">\n      </span><span class="s1">for (const edge of Object.values(cy.edges())) {</span><span class="s3">\n        </span><span class="s1">if (edge.data?.()) {</span><span class="s3">\n          </span><span class="s1">const { x: sX, y: sY } = edge.source().position();</span><span class="s3">\n          </span><span class="s1">const { x: tX, y: tY } = edge.target().position();</span><span class="s3">\n          </span><span class="s1">if (sX !== tX &amp;&amp; sY !== tY) {</span><span class="s3">\n            </span><span class="s1">const sEP = edge.sourceEndpoint();</span><span class="s3">\n            </span><span class="s1">const tEP = edge.targetEndpoint();</span><span class="s3">\n            </span><span class="s1">const { sourceDir } = edgeData(edge);</span><span class="s3">\n            </span><span class="s1">const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [sEP.x, tEP.y] : [tEP.x, sEP.y];</span><span class="s3">\n            </span><span class="s1">const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);</span><span class="s3">\n            </span><span class="s1">edge.style(</span><span class="s3">\&quot;</span><span class="s1">segment-distances</span><span class="s3">\&quot;</span><span class="s1">, distances);</span><span class="s3">\n            </span><span class="s1">edge.style(</span><span class="s3">\&quot;</span><span class="s1">segment-weights</span><span class="s3">\&quot;</span><span class="s1">, weights);</span><span class="s3">\n          </span><span class="s1">}</span><span class="s3">\n        </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">}</span><span class="s3">\n      </span><span class="s1">cy.endBatch();</span><span class="s3">\n      </span><span class="s1">layout.run();</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n    </span><span class="s1">layout.run();</span><span class="s3">\n    </span><span class="s1">cy.ready((e) =&gt; {</span><span class="s3">\n      </span><span class="s1">log.info(</span><span class="s3">\&quot;</span><span class="s1">Ready</span><span class="s3">\&quot;</span><span class="s1">, e);</span><span class="s3">\n      </span><span class="s1">resolve(cy);</span><span class="s3">\n    </span><span class="s1">});</span><span class="s3">\n  </span><span class="s1">});</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(layoutArchitecture, </span><span class="s3">\&quot;</span><span class="s1">layoutArchitecture</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var draw = /* @__PURE__ */ __name(async (text, id, _version, diagObj) =&gt; {</span><span class="s3">\n  </span><span class="s1">const db2 = diagObj.db;</span><span class="s3">\n  </span><span class="s1">const services = db2.getServices();</span><span class="s3">\n  </span><span class="s1">const junctions = db2.getJunctions();</span><span class="s3">\n  </span><span class="s1">const groups = db2.getGroups();</span><span class="s3">\n  </span><span class="s1">const edges = db2.getEdges();</span><span class="s3">\n  </span><span class="s1">const ds = db2.getDataStructures();</span><span class="s3">\n  </span><span class="s1">const svg = selectSvgElement(id);</span><span class="s3">\n  </span><span class="s1">const edgesElem = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">edgesElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">architecture-edges</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const servicesElem = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">servicesElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">architecture-services</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">const groupElem = svg.append(</span><span class="s3">\&quot;</span><span class="s1">g</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">groupElem.attr(</span><span class="s3">\&quot;</span><span class="s1">class</span><span class="s3">\&quot;</span><span class="s1">, </span><span class="s3">\&quot;</span><span class="s1">architecture-groups</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">await drawServices(db2, servicesElem, services);</span><span class="s3">\n  </span><span class="s1">drawJunctions(db2, servicesElem, junctions);</span><span class="s3">\n  </span><span class="s1">const cy = await layoutArchitecture(services, junctions, groups, edges, db2, ds);</span><span class="s3">\n  </span><span class="s1">await drawEdges(edgesElem, cy);</span><span class="s3">\n  </span><span class="s1">await drawGroups(groupElem, cy);</span><span class="s3">\n  </span><span class="s1">positionNodes(db2, cy);</span><span class="s3">\n  </span><span class="s1">setupGraphViewbox(void 0, svg, getConfigField(</span><span class="s3">\&quot;</span><span class="s1">padding</span><span class="s3">\&quot;</span><span class="s1">), getConfigField(</span><span class="s3">\&quot;</span><span class="s1">useMaxWidth</span><span class="s3">\&quot;</span><span class="s1">));</span><span class="s3">\n</span><span class="s1">}, </span><span class="s3">\&quot;</span><span class="s1">draw</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n</span><span class="s1">var renderer = { draw };</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/architecture/architectureDiagram.ts</span><span class="s3">\n</span><span class="s1">var diagram = {</span><span class="s3">\n  </span><span class="s1">parser,</span><span class="s3">\n  </span><span class="s1">db,</span><span class="s3">\n  </span><span class="s1">renderer,</span><span class="s3">\n  </span><span class="s1">styles: architectureStyles_default</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">diagram</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/diagrams/common/populateCommonDb.ts</span><span class="s3">\n</span><span class="s1">function populateCommonDb(ast, db) {</span><span class="s3">\n  </span><span class="s1">if (ast.accDescr) {</span><span class="s3">\n    </span><span class="s1">db.setAccDescription?.(ast.accDescr);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ast.accTitle) {</span><span class="s3">\n    </span><span class="s1">db.setAccTitle?.(ast.accTitle);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">if (ast.title) {</span><span class="s3">\n    </span><span class="s1">db.setDiagramTitle?.(ast.title);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">}</span><span class="s3">\n</span><span class="s1">__name(populateCommonDb, </span><span class="s3">\&quot;</span><span class="s1">populateCommonDb</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">populateCommonDb</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">,</span><span class="s1">&quot;import {</span><span class="s3">\n  </span><span class="s1">__name</span><span class="s3">\n</span><span class="s1">} from </span><span class="s3">\&quot;</span><span class="s1">./chunk-YTJNT7DU.mjs</span><span class="s3">\&quot;</span><span class="s1">;</span><span class="s3">\n\n</span><span class="s1">// src/utils/imperativeState.ts</span><span class="s3">\n</span><span class="s1">var ImperativeState = class {</span><span class="s3">\n  </span><span class="s1">/**</span><span class="s3">\n   </span><span class="s1">* @param init - Function that creates the default state.</span><span class="s3">\n   </span><span class="s1">*/</span><span class="s3">\n  </span><span class="s1">constructor(init) {</span><span class="s3">\n    </span><span class="s1">this.init = init;</span><span class="s3">\n    </span><span class="s1">this.records = this.init();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">static {</span><span class="s3">\n    </span><span class="s1">__name(this, </span><span class="s3">\&quot;</span><span class="s1">ImperativeState</span><span class="s3">\&quot;</span><span class="s1">);</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n  </span><span class="s1">reset() {</span><span class="s3">\n    </span><span class="s1">this.records = this.init();</span><span class="s3">\n  </span><span class="s1">}</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n\n</span><span class="s1">export {</span><span class="s3">\n  </span><span class="s1">ImperativeState</span><span class="s3">\n</span><span class="s1">};</span><span class="s3">\n</span><span class="s1">&quot;</span><span class="s0">],</span><span class="s1">&quot;names&quot;</span><span class="s0">:[],</span><span class="s1">&quot;sourceRoot&quot;</span><span class="s0">:</span><span class="s1">&quot;&quot;</span><span class="s0">}</span></pre>
</body>
</html>